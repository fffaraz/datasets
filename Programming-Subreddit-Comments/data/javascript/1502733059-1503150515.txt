Uber wrote about their experience with Preact here https://eng.uber.com/m-uber/
It acts as an Event Emitter router for different processes that can be implemented in any language not just JavaScript. For more info about EventEmitter: https://nodejs.org/api/events.html Example on how to use TCP Emitter: https://github.com/tcp-emitter/server#example-3
I couldn't contact him, it looks like it decompresses lz4 packed data
I wish you luck (if you decide to take a look ofcorse)
I've used it before in production on a large-ish web app, but the amount of bolt-on additions you need to make just complicates it and makes it no better than using a true application framework. Imo, the simplicity you get on the component level is offset by complex redux reducers, routing, and other things that you take for granted in application frameworks. You end up just writing a DIY application framework anyways, but instead of relying on other tools you end up writing it all yourself which is a huge burden on a smaller team. I really like React for smaller projects. I also really dig Vue. Feels like similar concepts but slimmer package.
&gt; Didn't have this issue. Pointed it at the files I wanted compiled, tweaked a few options, done. Either you're ignoring errors, or you have a lot of false negatives. &gt; That's what any is for. The goal isn't to avoid any no matter the cost, it's to balance type safety with clean code. If you're not going to fully commit to static typing, you might as well not bother. You don't really have type safety. If all you want is IDE hints and warnings about blatant mistakes, you can get that with ESLint and a good IDE (VS Code can do type inference even without TS). &gt; What's the problem? You have to define the type information three times in a row to make it work the way it should. interface IAddress { id: number; houseNumber: string; street: string; town: string; county: string; country: string; postcode: string; } class AddressRecord extends Record({ id: &lt;number&gt;null, street: &lt;string&gt;null, town: &lt;string&gt;null, county: &lt;string&gt;null, country: &lt;string&gt;null, postcode: &lt;string&gt;null, }) implements IAddress { id: number; houseNumber: string; street: string; town: string; county: string; country: string; postcode: string; }; Things like this make Typescript more trouble than it's worth. Your time would be better spent writing more unit tests.
There's a decent course on [Udemy](https://www.udemy.com/angular-reactjs-vuejs-quickstart-comparison/) about evaluating the differences between VueJS, React and Angular. I'm about halfway through it right now. I did an eval for work between them and we settled on VueJS (as a migration from Dojo) for an enterprise internal only project
You can use ts-loader with the webpack in the same way you'd use babel-loader. You choose what version of JS to target in your tsconfig file. It's actually easier to configure than babel, but it's less flexible and there aren't as many third party integrations.
that was a good post; I really need to get into react/preact; just no current projects taking me that route :/ 
Mocha sounds like a way better name. Too bad it didn't stick.
Who cares? It's some garbage proprietary, closed-source framework. They don't matter in the slightest. Just ignore them, and shun any developers stupid enough to use that crap.
Primarily the editor, which doesn't ship with the game. Physics, audio, UI libraries could be added to three.js and still come in around a few 100K rather than dozens of MB. Sure there are features or commercial add-ons for Unity that may not have web equivalents but even if you're not using those you still have to swallow a 50MB minimum footprint. I've done a bunch of 3D projects and never really needed Unity's extra features.
&gt; The move to react was the most productive move I've made in my career. Wow, really? I moved from ng to React too, but I can't say it was the most productive move I've ever made. 
Angular 2 is all you need. If you liked angular you will love angular 2/4. Yes it's different to the one you used, especially the API but believe me you won't regret it. From someone who has heavily used Ember, AngularJS and Angular 2 in enterprise applications and customer facing sites/app for some of the largest retailers in the world. 
The idea with "react ecosystem as a framework" is that you can choose alternatives for every part of "the framework". Or your can stick to default/most recommended ones. In angular you are pretty much stuck with standard parts. If they suits you, you are ok, if they don't you'll have to fight with framework.
Not having looked at Ember in a while, why are you not sticking with it?
I haven't decided that we're 100% not sticking with it, but want to evaluate what's out there.
That's great, but in my experience it's been a lot of reinventing the wheel because you end up doing what a true application framework would have done for you. It starts out so simple but ends up in a massive bundle of custom written things that you would have just gotten for free and with far less work. Suddenly you're writing custom routers and handling complex reducer methods and you wish you would have just picked up something that had it in a more integrated way. 
Could you give an example?
Probably the same reason you seem to think your own opinion is enlightened and view those who disagree with you as contrarian man-children.
react-router v4 for example is like several orders of magnitude better than angular router. Redux? Don't use it. Form validation is the only thing that I'm not found a good solution for. redux-form is ok, but I'd like to have something without redux. I like the simplicity of validation in redux-form. I really like the idea of using applicative functors for validation.
Sure. React doesn't have a built in HTTP helper, it doesn't have state built in, it doesn't have routing, or any way of handling model updates, etc etc. It's just a view library. It's power is that it's un-opinionated, but because of that you end up adding most the opinions, which causes a few issues: 1) It's the burden of the developer to build out a lot of this functionality. Even though React has these plugins you are doing a fair amount of work integrating them. It's definitely not as easy as just import statements. 2) You must have good react experience going in because you are the one that drives the opinionated architecture decisions. It can cause pain over time if you made the wrong choice or didn't have the right experience going in. It's a chicken and egg scenario where you have to be good at React to create a from scratch application. 3) Coherent documentation for your application is split out over 10+ github repos, all changing. Redux or react routes make updates independent of the rest of your plugins etc. It's super hard to coordinate all your little disparate pieces. When major React releases there's no coordination from all your disparate package authors that you now rely on. This is great if you want that level of control; to finely tune your application down to the model updates etc. But not every team or everyone wants/needs that level if fine grained tuning. My feeling is that in the future React will actually end up looking more like Ember/Angular1/Angular 2 where larger modules are more integrated. To make it clear I really like React but it's not the shining golden palace that many make it out to be.
`arg instanceof knex`? to be fair I'm not familiar with Knex. You could also check for unique properties on the object that only knex instances have, something like... ``` function isKnex (obj) { return typeof obj.someKeyOnlyKnexHas !== 'undefined' } ``` If there is no unique key you could make a factory function to add one. You could use Symbols or Object.defineProperty to make this special identifier key non iterable if you don't want to pollute the object. function knexFactory (args) { const knex = Knex(args) knex[Symbol.for('knex')] = true return knex } function isKnex (obj) { return typeof obj[Symbol.for('knex')] !== 'undefined' } // ... console.log(isKnex(someObj)) 
This teaches a very bad lesson: directly manipulating the DOM. This is considered an anti-pattern in react, especially when there are much better, more react-like solutions to the problem. If this component rerenders (which might happen at any point even if the props do not change since it's not a PureComponent) the changes to the DOM may be removed. The react way of doing this would be to add state to the component, tracking whether the image is loaded. The class should be initialized with `state = { isLoaded: false }` or something similar, and instead of the direct DOM manipulation in line 18-22, `this.setState({ isLoaded: true })`. `this.state.isLoaded` should be used to conditionally add the class and styling in the render method. There are also a number of other problems, for instance the component (and thus the ref) may be removed before the image finishes loading. This reads like something written by someone who is not at all familiar with react, or maybe it's just a straight conversion of the polymer component. The react render-method can be called often, and what is returned is what should be shown in the DOM. Making changes to the DOM around this is a big no-no unless you're absolutely sure what you're doing.
I felt exactly the same until I have unity a try. Ok, c# isn't fun like javascript is IMHO, but it's an OK language. But the platform, unity, is just great! Working with Three.js is so slow when compared. And that's even though I'm much better at writing javascript then c#. 
&gt; Either you're ignoring errors, or you have a lot of false negatives. No and no. &gt; If you're not going to fully commit to static typing, you might as well not bother. You don't really have type safety. This is like a guy who's car is covered in pillows criticizing your seat belt because "If you're not going to fully commit to crash safety you might as well not bother!" No, you're being silly, there is a happy balance between everything-is-nailed-down static typing (e.g. Java, C) and no typing, and I find it to be awesome. I love that TS prioritizes being a good practical language over this kind of abstract "safety" or "soundness" nonsense. You get the benefits of static typing where it actually matters (e.g. having an IDE that can actually help you out) and you still get the nice dynamic stuff JS has. &gt; You have to define the type information three times in a row to make it work the way it should. As of Immutable 4.0 you don't, since they improved their type definitions. [It now looks like this.](https://i.imgur.com/njEGJpO.png) You'll notice the types are defined exactly once.
Yea, maybe that's too broad of a blanket statement. As far as building front ends, especially with people not used to the framework, it has been super helpful in constantly being able to deliver value.
Thank you!
I always felt preact should have been named eact to better represent its smaller size when compared to react.
Or it's reason you felt the need to respond with a witless attempt at dismissing my valid point.
First off it's just Angular, AngularJS is for version 1.x. If you don't mind some of the opinions that come with Angular and you're happy to build your whole front end around it then it can be an invaluable framework. It might have a bit of a learning curve with TS, rxjs and the new template syntax but learning all those things will make you a better dev aswell as understand Angular. If you are looking at taking the plunge then I very much suggest using the Angular CLI, it gives you so much free stuff and so many new features coming. And don't forget the Angular gitter https://gitter.im/angular/angular 
fetch, react-router, mobx, ...done. Together they're all simpler than angulars defaults, you're overestimating the effort. As for redux, it's not tied to react, but it's become a go to solution for state management, so there are countless of angular projects using it. Yes, it's explicit but the upside is of course that it makes state simple and parts of the application become truly framework-independent. In our company we have Angular 4 projects that we develop with partners, the churn and complexity that goes into them is stunning to me. Routing is such a simple thing, it doesn't have to be that complex, the same goes for state and HTTP.
How is the react router better than the angular one? And also what is v4? All I can find is v2/3.
Just finished a rewrite from AngularJS 1.2 to Angular 4. I like it, I like it a lot, but RxJS isn't a light thing to learn. If you know everyone working on it will be competent developers who are willing to invest in learning the concepts behind RxJS then it is great.
You're missing some code. ```mongoose``` isn't being used. ```Typist``` isn't declared. 
Now it's fixed. But this time I forgot to add color.
So the code works now?
I built a SaaS application from the ground up using Angular (2). As someone with a lot of MVC experience but no SPA experience, the opinionated nature and ease with which to test really spoke to me and helped steer me in the right direction. It also removed a lot of decision fatigue that I probably would have experienced with React. Also, the CLI made dev setup a breeze and was far superior to create-react-app.
https://analytics.google.com/analytics/web/provision/?authuser=0#provision/SignUp/ Just use google analytics for tracking.
That was a good read, thanks!
It becomes a lot more useful when you are doing multiple asynchronous operations in serial.
why are you so concerned about it? why are you blaming the entire rest of the world when you say something poor? Either you did a bad job explaining or point, or you point is bad. Either way, it's your own fault, not the worlds. Own it and learn from your mistakes. 
I do the same as the parent commenter but exclusively rely on Moment.js for the final conversion. There's just too many edge cases in time that it's just not worth the hassle. 
No fixed. In the contex of the paste bin is complete.
Hi there! Late to the party... Ive been using angular professionally for 2 years. Personally I believe that the other frameworks ( Vue and React ) have come much further with regards to JS front end libraries. 
Meteor Mongo social app :) https://chattermash.com/dashboard/0
This has been debated for years now. You've correctly identified the two classes of solutions, but the first one is called "feature detection" in case you want to google some of the arguments for and against. No method is going to be perfect. 
I know everyone is harping on how UnityScript is different from Javascript but.... you presumably used it, so what's the allure of UnityScript?
Few quick tips... Check out Ahamed Nafeez's talk [here](https://www.youtube.com/watch?v=kedmtrIEW1k). He talks about generic vulnerabilities (namely typical XSS stuff), but he hits on a few points that are useful to you around monitoring native methods. He also released a library that might be useful to you:[ Hookish](https://github.com/skepticfx/hookish). Lastly, I wrote a security application using DOM proxies years ago and ended up having a team rewrite it all using MutationObservers. Might be a better API than manually proxying native methods. 
Do you know if there is a way where I can set up thousands of different links via Google Analytics so that I can track thousands of individual users?
You can just pass an identifier (username) with the tracker
"Burn this into your brain: In javascript, `this` is just a function parameter that you don’t get to name." +1 Too many JavaScripters -- even highly respected ones -- will sometimes say that `this` is "inherently stateful", or they will imply that no function that uses `this` can be pure. When in fact, whether a function is stateful or pure or not, and whether a function uses `this` or not, are two completely independent qualities. A function that uses `this` can be referentially transparent, just like a function that uses any other parameter.
&gt; this.names.map( this._renderListItemName ) Yup, method tear-off is still a common problem in JavaScript. C++ solved it by issuing a warning/error, and Python solved it by automatically binding, implicitly evaluating the above as `this._renderListItemName.bind(this)`. Though, if we eschew `this` and `class` altogether, then the solutions we have to use are still pretty much the same. // Free function; uses parameter `component` rather than `this` function renderListItemName( component, name ) { // ... } // ... // Bad; same problem as method tear-off names.map( renderListItemName ) // Bad; invoked immediately names.map( renderListItemName(App) ) // Good; arrow function names.map( name =&gt; renderListItemName(App, name) ) // Good; bind names.map( renderListItemName.bind(null, App) )
https://reacttraining.com/react-router/ 4 is way better than 2 / 3 since it exposes these minimal components that are tied to history. everything is composable, so all the weirdness of route nesting and prop passing is extremely trivial, and complex things are much easier to reason about
If you find someone using angular 3 then you can safely ignore them :P
What churn? I'm not counting beta because, well, it's beta. Since release the api has been incredibly stable. If your devs are constantly churning angular code it's either because they like redoing stuff or they didn't do it right the first time, stuff like ignoring observables and just hoping they will go away when they are one of the best parts of angular.
OK, I will look into that, thank you.
I use Inferno for most of my side projects because it offers me lifecycle hooks on stateless components/functions. The speed/DX/blah blah blah all seem about the same between React/Preact/Inferno and for about 80% of my use cases there is no difference. The biggest pain is having to use `inferno-compat` or whatever it is to use larger React-ecosystem modules.
Right decision. 
I was on mobile when I replied the first time. I realized that bash _does_ support any unicode character. It might show up as a square for you, but should be fine. Try giving it another go with that in mind. Or, don't put unicode in your damn network name!
Can you do: aBoolean &amp;&amp; &lt;element/&gt; like React yet? I was trying it out recently and the type defs didn't seem to like that.
&gt; Also, the CLI made dev setup a breeze and was far superior to create-react-app. Can you elaborate on this? I'd love to know more, might make me try to pick up Angular.
Ok I looked through that documentation. I didn't read it exhaustively but I gave it a once over. It looks fine. But it doesn't look to have any features that the angular router doesn't. And i don't see anything in there that looks nicer. I mean it looks fine, I would be on board using it. But it's not making me go "Wow, if only angular router could do that / did it that way". Because the Angular router does all that stuff.
I'm not familiar with the react cli but the angular ones does: 1. Ng g(enerate) m(odule)/c(omponent)s(ervice)/p(ipe) and maybe some others I'm forgetting. Skeleton code generation, including things like auto inserting new components into ngModules so you don't have to mess with the basic plumbing much. The code generation also includes generating skeleton test coverage files. 2. Ng serve, run it in the background and you get hot module reloading and browser refreshing. Pretty basic these days but the angular version works 100% of the time for me. I've seen some custom hot reloading that is flaky so I like that their version works so well. 3. Ng build compiles the app into a few bundles (vendor, styles, app) and does aot compilation for you (compiling the templates into the component so you don't have to serve the angular compiler to the client and do a build step there). Also supports providing a different environment specifer which allows you to create different environtment.*.ts files to easily provide constant values for different environments, like different urls for dev/test/prod and things of that nature. 4. Ng eject - spits out the webpack config being used by the cli for that project. This makes it easy to transition off the cli if you ever are forced to. Personally so far I haven't found a compelling reason to move off the cli for an app, but currently the cli doesn't have much support for making a library. But being able to eject a config to get up and running quickly with a library was nice. 5. Ng new - probably should have mentioned this first, but it generates an app for you. Pretty basic, but it does all the essentials including providing basic git ignore info (like node_modules) and the testing harness with both e2e and unit testing is all there when you start a new project. 6. ng test - runs the unit tests written. 7. ng e2e - runs the end to end tests written. 8. ng lint - runs the linter. Those are the things I use the cli for.
Yes, you can. You can even do it without Javascript. HTML inputs have an attribute called `disabled` which you can just remove or set to `false` to undisable it. As for doing it in Javascript, this may help you. https://www.w3schools.com/Jsref/met_element_setattribute.asp
Unity implementation is different in what way?
Open source?
I'm not sure how wasm comes into this. They're just deprecating UnityScript for in-engine scripting - an assembly language wouldn't make much sense for that purpose. You can still compile the actual game to either asm.js or wasm.
Nice! I'm shocked they haven't released this themselves.
Yes! Great response in my opinion. Some people judge Angular for being too opinionated. I feel it's in the sweet spot of being structured but flexible. It's been working great for our team of 3 people working with it so far.
Proxies are awesome and I do use them when handy, but there are good reasons to avoid using them. First and foremost, they cannot be shimmed perfectly. That means any code you write with proxies will not work for older browsers, period. You can kind of come close if you want to make some static assertions, but as far as I know there are no transforms that do such a thing, and even still they would disallow things that are possible. Second, Proxies represent a powerful form of metaprogramming. Metaprogramming is sweet, and if you're just learning about it, it's sweet and you want to use it for everything. Once you make a project that does use it for everything (\*cough\* Rails), you realize it simplifies very little and makes everything harder to reason about (and makes static analysis even harder as a fun byproduct). Lastly, they are actually used by some libraries when available. React uses them to represent their synthetic event system, and I assume they fall back to cruder methods when Proxies aren't available. But yeah they're cool and I would love to see an ActiveRecord-like ORM for JS utilizing them (actually, is there such a thing already? It definitely wouldn't be quite as nice because of the lack of question marks in identifiers) 
&gt; the simplicity you get on the component level is offset by complex redux reducers, routing, and other things that you take for granted in application frameworks This is a really good evaluation. We've recently started a rewrite from an old meteor app with a 5 person team. One big pro of angular was that we could sidestep having to make a bunch more choices, of redux vs flux, and all the other stuff. First class typescript support was a big plus as well. We liked the component model. Be forewarned that if you need server side rendering, it's a little buggy and you should focus on that early to avoid some of the gotcha's that will appear later.
Yeah I figured that it could be abused pretty easily, but I kind of saw it as something that would end up driving things like change detection in frameworks like angular and what not. Something with a lot of tests and eyes on it constantly. I've got limited experience with metaprogramming so I definitely can think of code smells but don't have the in the trenches experience with a language/framework that has (ab)used it heavily.
So... Just overloading?
Thank you for the detailed context, this is what I was looking for. As far as I can tell create-react-app does all of those except item 1, which is pretty cool. I doubt create-react-app would ever add it either because unlike Angular it tries not to be opinionated on how you structure/write your apps.
I'm using it now. It's strong. It's really pretty easy to learn. Very productive. Intuitive API. Router feels good. Life cycles events are good. Two complaints. The bootstrap time is pretty bad. It can be 3 to 5 seconds easy. The second issue I have is change detection doesn't feel super great. They give you events to hook into when value change but it doesn't feel as good and definite as React. I feel like when I subscribe to observable for a sync data calls in the OnInit hook changes haven't been picked up
You can attach listeners to mouse and keyboard input and log them somewhere fairly easily with JavaScript, you'll just need to store the logged events somewhere that persists between page navigation. I wrote a chrome browser extension that did something similar to this for debugging purposes when people submitted reports of errors or UI suggestions
Why are you considering not sticking with it? edit: I'm just picking up React now, coming from Ember, and I'm having a similar experience, being annoyed at how many little decisions I have to make to do basic things. It feels a lot like how I used to make stuff with JQuery spaghetti, except now there's JSX and modules, and ES6/Babel niceties. The extra flexibility, and no prescribed best practice for a lot of this trivial stuff makes me feel like I'm walking into a documentation nightmare. additional edit: Some people have mentioned in here using stuff like React Router, and MobX, and how much they love that stack, and it's like ... React Router was copied from Ember's router, and MobX looks a lot like Ember.Object. So I'm just like scratching my head. This stuff has been available in Ember for years.
I've used most of those and it's really not as simple as people think it is... People love to sell how easy it is to tack all these features on but I've found myself writing verbose reducers and feeling like I'm reinventing my state for the 10th time. Just mobx and 1000+ lines of code! Simple! I really like React and Vue but I wouldn't sell it as anywhere close to as "out of the box" as Angular/Ember. Just my opinion. 
Pot, meet kettle.
"valid"
Two weeks isn't really a lot of time to get up to speed for even the most adept developers. I have about 20 years under my belt and I'm up to speed in about a month to two for really large projects (&gt; 1 million LOCs.) It's good that you are aware that you shouldn't constantly bother your coworkers. If you are still pretty junior in terms of experience, then I would try treating a senior dev to lunch and ask them give you a more holistic review of the components you are working with - it's often that high level frame of reference that helps the details fit together. If you are more mid-level or even senior but on a codebase larger than you have ever experienced, then I would say just give yourself some time and document what you know as you go. Eventually you'll develop a map of the codebase as you perceive it. Backbone is a framework that allows bad developers to hang themselves in terms of cyclomatic complexity, but the foundation is simple enough that you can usually untangle the mess by focusing on the routes (stuff triggered by hashtags) and the respective views (html) and models (specialized javascript objects that give the framework events you can listen to and destroy resources at will without memory leaks.) Learning to isolate these different components will go a long way. I personally like to keep markdown files in key directories that summarize the components and gotchyas for that given tree. I also keep hand-written flow-chart notes for how high-level components fit together. When I'm done making lots of edits (ie weeks after I've jumped into the code) I'll formalize them in a legit flowchart app. Regardless of whether that clarifies the code for you, it should at least impress your manager(s). But it will also give you a basis to discuss things in terms _you_ know, while giving the other team members a way to clarify parts that are still muddled or correct areas where you may have made bad assumptions. If you are not getting that kind of support, (or if they are harping on you being late to finish a task in the first two weeks) then you might be in over your head or you might be working for jerks. Either way, learn as much as you can (both what works and what to avoid in the future.) and give yourself a little more time to settle in.
Have you looked into Google Analytics?
&gt; Who cares? As of 2015, approximately 47% of all mobile game developers, 1 million monthly active developers, and the ~770 million people who have played games that were developed with Unity. Just because you have a stick up your ass doesn't mean nobody cares.
Fair warning, last time I did this JavaScript didn't have an onDisable event for know when this happens to an input - so if you're doing this programmatically you'll need to look for the attribute and or the existence of the disabled/readonly property on the html element if you want to trigger other actions when something is disabled via the DOM
Its definitely a convention. Not everyone uses it or likes it, but its not just you. You can Google it to find plenty of references where its suggested or recommended.
Forgive my ignorance: I'm a junior dev, but AFAIK using wasm modules means that one can code native C#/Unity/C/Rust/.NET (and more) apps, compile them to the wasm standard and have those modules run with near-native performance when required into javascript. That in my understanding would more provide a much more elegant, performant and easily-learnable solution than a Unityscript hybrid. Please correct me if I'm wrong or missing the point.
Is this just a CLI wrapper against the compose.io API?
Goodbye Boo and Javascript, thank you for your service. They were a nice transition from flash/html5/js etc. Boo was a python-like language that was fun. However if it makes it easier to update mono/.net then that is the way to go. I haven't use JavaScript/Boo in a project in quite sometime maybe even 5-ish years but still was nice for beginners/newbies. Boo/JavaScript came free with mono back in the day so it was easier to support, with IL2CPP and mono/.net version updates probably not so much anymore being that it is based on old .net/mono and ES3. Epic did the same thing with UnrealScript for similar reasons and for the better. Editors, tools and even C# have gotten easier and will be better with latest .net/mono for async/await, some dynamic features similar to js and other things. 
It's fairly common to prefix private _members_, e.g. `foo._bar` to indicate that one should not mess around with its value even though it's technically exposed. For variables (e.g `_foo`), it's not nearly as common, but I have seen them on occasion, typically when there's a wrapper function `foo` meant for public consumption, and a implementation function `_foo` that recurses or takes extra params. Another use case I've seen is that of extracting arguments out of a closure, e.g. `var resolve; new Promise(_resolve =&gt; resolve = _resolve)` Another is the double underscore prefix/suffix to indicate a "reserved" status (e.g. `__FOO__`) Other than those use cases, I don't really see the need to prefix underscores, since these days you typically organize things in modules and explicitly export the public stuff anyways (via `export` or `module.exports`)
Now you're ooking with ire.
Try these sources: [Is there an API for the CIA World Factbook or one that provides similar information on Countries?](https://www.quora.com/Is-there-an-API-for-the-CIA-World-Factbook-or-one-that-provides-similar-information-on-Countries)
[removed]
If they use a library like lodash, that naming convention may interfere.
Hmm thanks, I meant programming languages though haha!
This is very impressive. Do you have any ideas of where you'd like the project to go?
I think you're misunderstanding how UnityScript and C# are used in Unity. They're simply two separate syntaxes for interacting with native engine code, and are 1:1 interchangeable. UnityScript is just a similar-looking language to JS, but is basically C# under the hood (it even has C# types and classes).
Everything you said was right, except for the last bit. There was a mild advantage to knowing JS.
We are building an enterprise application using Angular 4 with a c# api the background. It's pretty versatile, but you need to keep up on the current versions for bugs and new features. 
Thank you! My next goals with it are - a) To make it easier to embed, for use in external web pages, tutorials and blogposts. See here for a basic example of embedding it in a blog post - https://blog.patricktriest.com/what-is-async-await-why-should-you-care/ b) Polish the UI a bit more. c) Expand/fork it into a more full-featured web app, capable of saving and sharing code snippets, without compromising the simplicity. d) Find a way (I'm not sure how yet) to detect infinite loops before they are run, or to halt the execution if one is triggered. Maybe moving the code execution into a separate thread using web workers could help with this. Do you have any thoughts or ideas on where to take it?
Does this provide an auto-proxy functionality? Meaning, all methods are simply delegated to the wrapped object, unless overridden? 
It is common, but I honestly agree with their sentiment here. Private members on objects aren't really private. Since it doesn't enforce much, those methods can still easily get used by the API user. Private variables are easy to have anyway. If you really need them, use closures. It's not bad for documentation purposes though, but if your job doesn't like it, don't do it. Maybe use `/** @private */` JSDoc syntax instead. Like someone else already pointed out as well, you can usually see the public variables easily if you're using a module system, just by looking at the exports.
I recommend Vue. You can go nuts with plugins and webpack or keep it simple with a single script tag. The small company I work at moved to Vue from Angular 1 and we are all very impressed. 
Sorry. I'm doing too many things at once :)
JavaScripters may not be familiar with operator overloading, because the language hasn't had it for most of its life, but yes, proxies allow operator overloading for _some_ operators.
There's really no such thing as a router that makes you go "wow". it's such a simple thing in principle. In any case, composing route components is very convenient. I don't know much about composition in Angular, but if angular routes are composable then they're as good as any other routing solution, though I haven't heard anyone talk about routing in angular 2+
I'd need to see an example of exactly what you mean by composable but I specifically meant "wow" in terms of "I wish it had that feature" not in terms of "wow that's objectively awesome".
I'd need to see an example of exactly what you mean by composable but I specifically meant "wow" in terms of "I wish it had that feature" not in terms of "wow that's objectively awesome".
Yeah, by default, actually. [From MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler): &gt; All traps are optional. If a trap has not been defined, the default behavior is to forward the operation to the target.
HTML canvas has a way to convert to image file. But obviously you'd need to put it all in a canvas first.
Yeah that's my last ditch effort, but it's looking like that's what im going to have to do. Not sure how we'll react and canvas play together, or how well a background image will go into a canvas element.
Thanks for the suggestion though! Much appreciated 
Does this mean we could overload to append arrays now?
https://reacttraining.com/react-router/core/guides/philosophy/dynamic-routing This. Angular routes are configured at bootstrap time.
I'd imagine there's got to be some sort of open source JS library to save your current view as an image also. Not sure of the specifics, but there are browser add-ons that save screenshots (and afaik those just run JS too)
The biggest issue with Angular is change detection. It can easily be slow as hell. And the moment you add changeDetection: ChangeDetectionStrategy.OnPush, you are screwed. From now on you are constantly fighting with non-updating UI. "Why it doesn't update? Let's sprinkle some more markForCheck()" The second big issue is that it uses RxJS. The library is brilliant but you have to have pretty decent functional programming background to be able to effectively use it. Our developers ended up in spaghetti of good stream processing code like maps, filters, switchMaps and a lot of .subscribe calls that do some simple logic, set component fields, usually sending the value to some other BehaviorSubjects (instead of using map) and then some other event handles are using them instead of further chaining observables creating a mess of .next() calls. In the end it is really hard to debug and support such code. For example: this.someObservable.subscribe(val=&gt;{ if(val!=null) { this.someBehaviorSubject.next(val.someField); } }) is pretty common. In React you can add such libraries as your team's experience grows. Things like Ramda, redux, redux-saga, redux-observable and so on.
Maybe check out https://github.com/niklasvh/html2canvas. I haven't used it, but it seemed kind of promising. And also it seems like Canvas is currently really the only way to go about this :/ good luck!
There is another convention to be aware of. In a lot of Google code, you'll see the underscore at the end of the variable name. Here's an example from the Shaka codebase. https://github.com/google/shaka-player/blob/master/lib/util/event_manager.js
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [google/shaka-player/.../**event_manager.js** (master → 49bf13d)](https://github.com/google/shaka-player/blob/49bf13d55ae7d5e47c7e35581c56c35b4cff1037/lib/util/event_manager.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dln4erm.)^.
I didn't get to use it but I did little research because of this article and found out it was at least Javascript-like which would be enough for me should I ever use Unity. Even though the language itself might have been different, the similar syntax and sometimes behavior could possibly make me feel more home than C# plus it would be good to know there are languages somewhat inspired by JS ready to be used in gaming industry in popular engines such as Unity. That's what I initially thought anyway. After considering the responses and looking up more about it, it looks way too different from JS so I probably wouldn't enjoy using it as much as I thought.
I had to look around and found this info: http://2ality.com/2015/10/intercepting-method-calls.html Apparently you must do everything yourself, and even provide the fall-thrus. The problem is, you can't trap one property or one method. You trap an operation, which affects all properties or all methods. This code shows what it takes to override one of two methods. But yes, if you do not write a trap, then calls and props are passed through. Proxies in javascript seem pretty weak. class Test { hello() { console.log("hello"); } world() { console.log("world"); } } let t = new Test(); let handler = { get: function(target, propKey, receiver) { const prop = target[propKey]; if (typeof prop === "function") { return function(...args) { if (propKey === "world") { console.log("mars"); } else { return prop.apply(this, args); } }; } else { return prop; } } }; let p = new Proxy(t, handler); p.hello(); p.world(); 
If you are setting change detection to on push you're supposed to feed values to children through the async pipe with an observable. That's the entire point. If you use the async pipe it automatically does the mark for check for you and everything updates as it should. That's kind of the whole point.
OK so it resolves at run time. I guess I can see how that might be useful to *some* setups. You can emulate this to a degree with wildcard routes but it's not exactly the same thing. Do you find this ability genuinely useful? What problem does it solve?
Yep, but say this to all ng2 developers. That's the difference between react and ng2. In react there's only one way to force react to rerender — this.setState(). Yeah, I know about forceUpdate(), but it has very specific use cases and nobody recommends using it regularly. And using markForCheck() is an official way mentioned in all Angular docs and tutorials. Also, I've seen migration from ngOnChanges to typescript setters for @Input() fields to watch for the changes, which is totally weird for me as a react/angular developer. This technic is used by PrimeNG for example. And it leads to some unexpected behaviour in client apps. 
Yep. There is an example below: https://reacttraining.com/react-router/core/guides/philosophy/responsive-routes It changes routes according the device's screen size. And in general v4 routes is conceptually very "reactish". &lt;Route/&gt; is just a simple component that has 2 arguments, path and component to render if path matches. It doesn't require any &lt;router-outlets/&gt; tags. It renders right in place where it is specified. There is no problems like having multiple &lt;router-outlets/&gt;, you just insert any routes wherever you want to.
It is like that, yeah. I wish JS actually had operator overloading, would be really good.
I've used setters as inputs before and never had problems. And I never said mark for changes isn't part of the documentation. I just said that on push is pretty clearly designed to interact with observables, which by their nature are a push mechanic. Reimplementing a push mechanic yourself seems like a strange choice. You can do lots of weird things with angular. So what? That's pretty much true of any large software kit.
Changing layout based on screen size should be done with css. Or at least media queries done in Javascript. That's actually one of my biggest complaints with react is I think it handles css poorly. But that's another discussion entirely. As for router outlets I mean yeah that way might be a bit more simple but the angular way is pretty simple. Each level of the Urlacher corresponds to one router outlet, the default one. If you want to using routing for stuff not directly related to the url then you give a router outlet a name and when specifying the routes you specify the ones for the secondary outlets with their name. Maybe slightly more complicated but it's never caused me any trouble.
One particular problem is that with ngOnChanges all properties are already changed to their new values. And if one of your properties depends on another you can easily do something like this.computedProp = this.prop1+this.prop2. In case of setters order in which setters is the same as order of @input() properties in the component. And you'll have to either call this.computedProp = this.prop1+this.prop2 twice in both setters for prop1 and prop2 or somehow delay computation. 
React-router was derived from Ember's router, and MobX is a lot like Ember.Object, and Ember's very flexible about how you handle network requests. I don't really understand the hype around React, when this stuff has been available in Ember for years, just about from the beginning. Am I missing something?
“Advanced native module features” = npm 5
On the one hand that's totally true. On the other that sounds goofy. I would do computer properties through an observable pipeline. I do understand what your getting at. Having a good experience with angular requires turning a lot of design stuff on its head. So it's fair to say that there can be a knowledge gap. Personally I view a lot of it as similar to say redux. The redux architecture requires a lot of boilerplate and indirection. It seems unwieldy to people that haven't gotten used to it yet because it makes easy things hard. The benefits exist though. And they show themselves when stuff that used to be hard is now much easier.
JavaScript is one of the most important language for for for frontend as well as for backend development. The JavaScript knowledge may help you to become a full stack developer. To be a professional JS developer you should know, first of all, JavaScript language by heart. Without understanding it properly you won’t be able to use frameworks and understand the way they work. Speaking of frameworks, these tools make your job easier. We have made a top 10 list of frameworks based on JavaScript you should learn and use. For example, in every list the first place takes framework called AngularJS. And this is not a surprise, because Angular is the most popular JavaScript framework. It has 1,596 contributors as of writing, making it the framework with the largest community of developers among all frontend JavaScript frameworks on GitHub. Visit our webpage to explore more: https://mobilunity.com/blog/10-top-frameworks-for-javascript-developers-for-hire/
heh, TIL. thanks!
as said before, it was/is mainly used for effectively private members of some object. Reasoning was that when developer did `console.log(someObj)` in concole, he will immediately see what methods was he supposed to used, and what was intended as internal. But with modules (requirejs, commonjs, imports) its largely not so usefull anymore, since you can expose only "public api"
thanks! But I checked it out and it breaks the demo site: &gt; Uncaught TypeError: zBCa.l is not a function Ah yeah, MutationObservers could be really cool for the iframe/object/... parts
Sorry if I'm being overly pedantic here, but isn't it more like over**riding**? At least that's the way I've heard the terms being used in the context of Java. "Over**loading**" would be if you could have several setter methods with different signatures (eg. one accepting an ``int`` as argument, and another one accepting a ``String``). Then, depending on how you call the method (using a ``String`` vs ``int`` as argument), the appropriate "version" of the method would run. "Overriding", on the other hand, would be, ermh.. , overriding some default behavior so that every time you call (for example) ``toString`` some (and only one) non-default version of the method would be run.
https://stackoverflow.com/questions/41470771/webpack-does-the-order-of-plugins-matter
Looks like it
Yep - you can see an example of this here https://github.com/wrakky/array-autosort. It uses a Proxy to automatically sort an array whenever a new item is added to it.
I'm not really sure what you mean to be honest. Mobx has no reducers. This is state we're talking about, the hardest, toughest aspect in application making. These technologies try to make it simple, that's their job. Redux does that once you know how a reducer works, mobx does that even without that knowledge. I am thinking of how terrible it was before these managers existed, state used to be that scary part that could ram any app against a wall once complexity grew, now it's a simple, self-contained little motor whose output dresses up views. Anyway, we're still talking Angular? The default you get there is plain rxjs. I see dozens of projects that combine it with redux again to make it simpler.
Thanks, this is exactly what I was looking for :) it's given me some faith too as I came into this job with only a very basic conceptual understanding of Backbone and I've been able to figure out most things without bothering my coworkers too much. So clearly the tasks I've been given are appropriate, the codebase is decent and I'm not too in over my head in my mid level role. I've been exploring the codebase by hand building flowcharts in draw.io and by looking at ways to visualise the app's dependency tree, as well as taking excessive notes so it seems like I'm on the right track. I like the idea of treating coworkers to lunch in return for a little inside knowledge haha. Cheers mate, you've been very helpful! 
How could we make them stronger? I'm not really familiar with proxies in general, and I thought JS proxies were aiming only to mirror missing method traps found in Python/Ruby/Smalltalk. 
You are correct. 
I think you're right, but as and aside, I wish we could have method overloading in Javascript. Not with types of course, but if pattern matching goes through---pattern matched functions with different signatures would be incredibly powerful. If it doesn't, well, just having overloading based on method arity would be okay.
I use the compat layer on most projects in the production build for smaller size, until now it's been great. I tried inferno-compat as well and smaller projects do fine but it seems to have a couple of problems with some 3rd party plugins/components or i just couldn't get it to work.
That's not reflected in advertised jobs. React appears to be taking over. I agree that javascript itself is the thing to learn, that's more true all the time, as frameworks and libraries are converging on similar, standard-like patterns.
 document.querySelector("...your selector here...").setAttribute("disabled",true)
Consider the other popular dialects of JS: ## Flow - Flow supports it and provides a way to make them treated as private using [`munge_underscores`](https://flow.org/en/docs/config/options/#toc-munge-underscores-boolean). - There is a [feature request for private modifiers](https://github.com/facebook/flow/issues/275). ## Typescript - Has a private modifier: https://www.typescriptlang.org/docs/handbook/classes.html --- Subjectively, I don't like it. It looks messy. I would rather encode the modifier as a comment. One could easily write a babel transform to enforce fields to be private at runtime if necessary. But I guess it is more important during development. 
I think some collaborative features via WebSockets would be neat. It'd be a big task since operational transformations would need to be implemented. It's only tangentially related to the idea of an OpenJS sandbox though, and may be better off as a forked project.
The author failed to mention WebAssembly module support without any command line flags. Pretty big deal IMO.
&gt; "Part of the real problem of today’s software is that most &gt; programmers have learned to program only a little, at the &gt; surface level (...). They have learned very little (or nothing) about &gt; how to metaprogram — even though metaprogramming is one of &gt; the main keys today for getting out of software’s current &gt; mess." Alan Kay, source: http://squab.no-ip.com/collab/uploads/61/IsSoftwareEngineeringAnOxymoron.pdf Metaprogramming is just not-so-obvious for many programmers, unless somebody shows them how to do it. It is similar to other niche concepts, for example to functional programming. If Dan Abramov had not make Redux and if he did not show majority of JS people how to use FP, they wouldn't be even interested. Majority of programmers use only what other people use or what is written in docs or tutorials. And BTW this means also that if you are making tutorial - don't oversimplify it. Many tutorials are oversimplified, with naive bad quality code (probably to be accessible for beginners). This is wrong, because most of programmers don't usually go far away beyond tutorial code. Majority of them won't explore. So I think it is resposibility of tutorial/doc writers to educate people (because they won't educate themselves anyway)
Assembly is a low level abstraction, Java, Javascript, C++, C# are higher level abstractions. You would not ever want to carry out high level tasks on the low level because it rarely makes sense and most certainly you would end up with slower, bigger, buggier apps. The parts that do heavy processing should be low level and we're talking specific little modules here, these parts are then managed by high level, for which javascript is as good a choice as anything else. Another interesting aspect is libraries and such in other languages like C++ that now can be compiled to the web. Unless you're porting the principles remain the same, you would probably still use higher-level than C (f.i. javascript) to steer the app because C could suck at it depending on the app. 
excellent answer! ...the community seems to have collectively realized *automagic* is more trouble than it's worth in the long run. It's just better to be able to trace what you do manually. it also means you can change any part of your call stack with ease. It means control, which pays off for all but simple scaffolding apps. 
The amount of things to learn in Reactlandia has gotten smaller. And now we have our own stack. My perspective is *The React Stack* is just this: - React - Redux (reselect + recompose) - **[Redux-First Router](https://github.com/faceyspacey/redux-first-router)** - Webpack - Maybe Apollo RFR consolidates and packages up the Redux space in a nice way. My demo will give you a quick birds eye overview of what you can do with it: https://codesandbox.io/s/github/faceyspacey/redux-first-router-codesandbox It's a good way to learn redux, to think about redux, and to dive into React in general. 
What you're looking for is probably [Decorators](https://github.com/tc39/proposal-decorators).
shitty copy paste article
You can draw DOM on a canvas using SVGs with a `foreignObject` tag and `ctx.drawImage`. [More info on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).
The LTS won't be released until October: https://github.com/nodejs/LTS
and boo! /s
This is pretty cool and all, but I rarely find myself needing to spin up a DB in the cloud for Dev purposes. Any time I need some instance of a DB, I usually just turn to docker to spin one up locally
Use this to break websites' chain. Array.prototype.slice.call(document.querySelectorAll("INPUT,SELECT,TEXTAREA")).forEach( function(e) { e.disabled = false } )
https://github.com/Flipboard/react-canvas/blob/master/README.md Maybe that might help
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Flipboard/react-canvas/.../**README.md** (master → 0b71180)](https://github.com/Flipboard/react-canvas/blob/0b71180b4061a55410efb4578df2b65c1bf00a8e/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlney7j.)^.
Its all about dependencies and events, so some packages will need to come after another to override an event, or to use another packages methods. I think its more to do with detective work with the packages you are using, rather than anything else.
We moved our projects from AngularJS to Angular this year and started two new ones. I think it's better. But I'm not sure it's going to be much better than Ember if you're already using it. The angular cli saves you time. It sets up the project (the build process and all that) and when you need a new component, service, etc. the cli creates the files and updates the app.module file with the appropriate imports. I understand it's based on the Ember cli so it should feel familiar. Regarding churn, it's not great but they do try to remember people are actually using their stuff. For example, in 4.3 they introduced a whole new http client and haven't documented all the classes it exports and the migration blog posts are extremely superficial. But they're keeping the old one alongside the new so projects using the old client can still use the latest framework version. Documentation is also not great, sometimes the official docs are out of date and you have to google and set the google filter to "last month" because older results will be out of date. It's the same for React. I think Vue has the best documentation of the three. All in all I think Angular is alright but I'm not sure changing from Ember to Angular would be a big improvement.
A check I often do for plagiarism is to pick selected phrases and search for them on Google, and in the 5 or so instances I checked for this site, they were all unique to this article (so it appears to be original content). If you have evidence to the contrary, please share!
&gt; Apparently you must do everything yourself That could be JS's motto 😜 Honestly, Proxies are one of the ES6 features I'm most excited about. Agree they're verbose, but you can do a lot with them. Private property access, simple field validation, proxying functions and being able to intercept their arguments. All really nice stuff. Also, you can always abstract away some of the verbosity. Here's a function that lets you chain rules for the get trap so you can specify a bunch of rules and your value will be the value of the rule that returns something other than `undefined`. function chainGetRules(...rules) { return (...args) =&gt; { let value; for (let i = 0; i &lt; rules.length; i++) { value = rules[i](...args); if (value !== undefined) { return value; } } } } function preventPrivateAccess(target, property) { if (property.indexOf('_') === 0) { throw new Error(`Can not access private property: ${property}`); } } function defaultGetRule(target, property) { return target[property]; } const dessert = new Proxy({ type: 'flan', flavor: 'delicious', _secretIngredient: 'love' }, { get: chainGetRules(preventPrivateAccess, defaultGetRule) }); console.log(dessert.type); // flan console.log(dessert._secretIngredient); // Error: Can not access private property: _secretIngredient
Look at jimp I'm using it for almost exactly that. I am also working on a build pipeline tool for creating combinatorial pixel art. Let me know if you would be interested. 
INB4 O(n^3)
I personally think that proxies can make code hard to understand if abused. But they are very nice for abstracting collections.
apologies I've read this only today. Reordering 10.000 LI elements take less than 100ms here https://webreflection.github.io/hyperHTML/test/many-rows.html + most caveats have been addressed and solved in V1. I hope you'l give it a second chance.
It was one of the most painful points developers using it raised more than once. Performance have been slightly compromised, specially for the text-only upfront-resolved intent, but it gained in reliability, it's now easy to extend it, and it explicitly opts-in/out of HTML, Promises, and DOM nodes. Please give V1 a second chance!
This is amazing work and I'm now on the hype train -- FFT is one of my favorite games ever but (as you pointed out in the about) it hasn't stood the test of time too well and it also has lackluster performance on my phone (android). Do you have plans to start a Patreon or anything similar? Would love to give you some incentive to work on this. Also as a React dev (and someone interested in d3 for awhile) if you are looking for contributors I would love to help you knockout low-hanging fruit.
What would you say is an example of someone abusing proxies? I ask because I think I'm the type of person that's a high risk for abusing proxies.
Should be really nice for Ember.
Oh wow. Why didn't they use an insertion sort?
I've never seen such a posting... though I agree it would be nice to have. If you want to understand the bundle, don't configure a devtool/sourcemap, don't use any plugins except define or dll, and pay attention to your libraryTarget setting. The file is pretty legible with those settings. Then, add stuff back in and see what changes.
&gt;Private members on objects aren't really private. &gt;If you really need them, use closures. It all comes down to what you want. If you work with a bunch of idiots who can't understand the basic concept this thread explains (`_foo` = private) then yes, closures are the only way to go. But if you work with professionals, the prefix allows you to get all the benefits of private methods (ie. you and your co-workers know they can safely be refactored without impacting outside code), with all of the benefits of public methods (you can `console.log` them, run them in your debugger, etc.).
Also, lenses are a well established pattern for this from (as far as I know) functional programming. The npm package partial.lenses does a good, formal take on them. My own npm package vitrarius takes a less formal, maybe less verbose approach. They can be nice for situations with immutable data and side effects.
It was just meant to be a fun little project to learn how proxies work. Efficiency (or being used seriously) wasn't the end goal :)
n^2 logn, yeah? I'm on my phone but couldn't this entire module be like 10 lines of code? it's a simple `i=0;while(compare()&lt;0)i++;array.splice(i,i+1)`
Dart has operator overloading. You can also define how equality works, which is pretty neat (e.g. for using something as a key in a Map). I don't think it would be very usable without types.
[Google's JS style guide](https://google.github.io/styleguide/jsguide.html) uses an underscore suffix (and `@private` in JSdoc) to indicate private.
I think /u/redldr1 simply left out a word. What proxies provide is often called **operator** overloading. Whereas method overloading selects the appropriate method from several candidates, *operator* overloading selects the appropriate *operator* function. For example, [operators as functions](https://docs.python.org/3/library/operator.html) in Python: class C: def __getitem__(self, index): # Return the value at index if index == "foo": return "bar" return "key does not exist" o = C() o["foo"] # "bar" o["baz"] # "key does not exist" Also for example, [operator overloading](http://en.cppreference.com/w/cpp/language/operators) in C++ (this is where the name "operator overloading" comes from): class C { public: auto operator[](string index) { // Return the value at index if (index == "foo") { return string{"bar"}; } return string{"key does not exist"}; } }; C o; o["foo"]; // "bar" o["baz"]; // "key does not exist" Admittedly the implementation of JavaScript's proxies behave more like overriding than overloading, you're right about that, but we say proxies enable operator overloading because they enable the same set of abilities as what other languages call operator overloading.
Multiple inheritance &gt; var a = {x:1}, b = {y:2}; &gt; var BAD = new Proxy({}, { &gt; get(target, property) {return a[property] || y[property];} &gt; }) Keep in mind that Proxies preserve the invariants of the target so you get really weird errors when using them and you break invariants in your handler logic.
Nice work! Is there a real life use case for a 1kb framework? Or is this more like code golfing?
`Proxy`'s are super handy to do some neato stuff, esp. with third party libraries
Wow thats interesting. I hadn't thought of that. Most people consider it to be a poor design choice in the languages that support it at a syntactic level for obvious reasons. It seems the same could be done with a closure and getters and setters though. Can you expand on what you mean by breaking invariants?
Our company just did a Preact/Redux POC, they're still leaning towards React in the long run, though, because it's backed by Facebook and has a much more robust community. Also React has things like react-redux
Working with it you don't really notice that it's that small. I'm using it mainly because it has a very nice and well integrated state management.
The thing is that `foo._bar` is pretty much the only way to implement `protected` (i.e. "this property is not most people's business but some specific thing outside of its own instance needs to access it"), so unfortunately closures don't always cut it.
I recommend brushing up on some basic trig and physics for reference. An infinitely helpful conversion is the [cartesian:polar conversions](https://www.mathsisfun.com/polar-cartesian-coordinates.html) A possible way of doing this would be to have a particle system spawn a bunch of "nodes" that fly out in all directions, and once they hit the canvas border, a bounding box, or some other object, you can have their positon stored in an array, and create a polygon based on those points, which may actually work. you could then define ranges for them, and if you only want them to go so far, limit their distance. As for the 'range' you mentioned, a solution would be to maybe have the particle object take an initial x,y, but also an angle (, and maybe a max distance?). I may try that method in little while. When I do I'll post a link to the work I've tried. 
Thank you a lot, I saw an article of a guy doing this kind of stuff, and he did it by sending 360 rays from a point each 1 degree out, but the light glitched and sometimes it didn't light up what should be lighten up. He then send rays to every corner of shape which was better for CPU and also worked better. I still have no idea how he did it, here is the link for it. http://ncase.me/sight-and-light/ (talking about example 5)
Regarding my maths level, im starting college in like 2 weeks so its not that low. I understand logarithms trig and pythagoras.
To me personally, the small size is not really about the bytes you save (so much room for activities!), but the "simplicity" of the solution. 
Awesome. Really impressed by the last update (Chrome 60) as well (https://developers.google.com/web/updates/2017/05/devtools-release-notes). Step into async is especially useful. 
Thats what I've got right now. https://codepen.io/killerek/pen/MvOwqX?editors=1010
You could probably get the points relative to the position of the light by testing where the light is in relation to the boxes' corners and use those points for the destination of the rays
I am ! I published this last month regarding runtime type checking: https://medium.com/@SylvainPV/type-safety-in-javascript-using-es6-proxies-eee8fbbbd600 Other usecases that I can think of: code coverage, debugging, monitoring, performance warnings, sandboxes... I believe Proxies will be a big deal once they get the &gt;95% support.
I dont know how to send rays, i only know how to do lineTo but no idea how to send a ray all the way and then check for collision with the box.
the "ray" is just a name for the line we're using. Ideally you would send a "ray" by checking all the points in one direction until it reaches a collision where the x and y of the point is inside the x y width and height of the box.
so I have light x y and box x y then i find gradient to hit box x y from position light x y and send ray all the way ?
Neat, I like what you're doing
I know the theory i dont know how to implement it to code, I have no idea how to cast a line based on gradient and then detect what it hits where. This is too difficult for me.
Overriding the default behavior. Instead of `undefined` for properties that don't exist you could return always `0`. This could break code that is not aware of that.
yes, and depending on which side the light is you may need to change the box x and y to box x + width and box y + height. for the corners you know?
Hi friends, thanks for commenting. A lot of things i need to improve in my writing skills. I recommend your comment to bring improvements on my part. I will focus, learn &amp; work for better writing. 
Well right now i figured out how to launch a ray somewhere, im so bad at coding that i dont know what im doing. https://codepen.io/killerek/pen/MvOwqX?editors=1010 Im doing whatever this is.
Great article. Object model looks really cool. I was really expecting libraries like this to explode once proxies started shipping and was really surprised when they didn't. I guess everyone's waiting until support is there.
Just don't forget that in current browsers, proxies are 100-200x slower. Proxies are made for library implementors, but I think most will continue to use more verbose solutions for quite a long time since it's both backward compatible and faster.
Should probably mention request-promise, if only as a postscript to the request library section.
Awesome. Never heard `method tear-off` as a phrase before but that makes great sense. I don't think it actually is a problem without `this` and `class` because then we use factory functions. So you have. const createApp = () =&gt; { const app = { ... render( el ) { const ul = document.createElement('ul') app.names .map( app._renderListItemName ) .forEach( li =&gt; ul.appendChild(li) ); el.innerHTML = ''; el.appendChild(ul); } _renderListItemName( name ) { const li = document.createElement('li'); li.textContent = name; li.addEventListener( 'click', app._logClick ); return li } ... }; return app; } 
JS Object model [invariants](https://tc39.github.io/ecma262/#sec-invariants-of-the-essential-internal-methods) of the target must match the results of Proxy traps. See: https://jsbin.com/xuqecucije/edit?js,console for an example.
This is great! I always have to do this, and it sucks. (async () =&gt; await ... )().then(console.log.bind(console, 'success'), console.log.bind(console, 'fail')) Edit: Ok, I learned my lesson. New rule: don't post old code saying you are thankful it's its no longer needed.
Is there any benefit of doing that instead of: (async () =&gt; { try { await foo() /* ... */ console.log('success') } catch (error) { console.log('fail') } })() I don't really think your example is wrong, just stylistically different. It just seems to make more sense to me to use the try/catch syntax than the promise syntax in this case. But maybe there's a good reason not to do it this way
This might help: https://www.ag-grid.com/ag-grid-understanding-webpack/ Scroll down to `Looking at bundle.js` section.
no expressions needed. Just make 2 text layers, one for the first name, one for the last name. Make the first name right-justified and the last name left justified.
Unfortunately that wouldn't work as the text is for a lower-third graphic meaning the left alignment would need to remain consistent 
Yeah, much cleaner syntax. The .bind() isn't necesary.
Hey there. Author of the post here. That's a great idea, thanks for the suggestion! Going to add that in now. 
It's easier than that. const main = async () =&gt; { // use await here }; main().then(() =&gt; process.exit(0)).catch((err) =&gt; { console.error(err); process.exit(1); }); With top-level await there is no need for a `main()` func.
yeah, this would be really overeengineering because mutliple inheritance could be easily achieved by mixins :) 
Yeah, this should be taken into account, proxies are not for everything and should be created only when it would be hard to solve problem in another way.
How do you migrate from Vue to Vue? Better title would be "Adding state management with Vuex"
Yeah, because I want it to be a one-liner. That's all. But it's moot because we now have this amazing new feature!! 
No man, i appreciate your help, you dont have to be sorry. Im just dumb and dont know how to code this.
I'm not quite sure why that is. Maybe there just hasn't been as much buzz about this feature than other ES6 stuff, and maybe it's because most people don't have much use for this kind of meta programming (and to get a little meta here myself, maybe this is exactly the reason why there isn't much buzz around it). But I also have to say I'm actually quite glad that only a few people are using proxies. They smell of magic, and not the good kind in my opinion. I can't think of many use cases that you couldn't implement with regular objects, and in a far less confusing way at that. I mean, in "good old JS" I could be reasonably sure that an assignment on an object property does what you would expect, assign a value (except for some objects implemented in the host/environment) and *definitely NOT throw some arbitrary exception*. And the same was generally true for accessing a property. If I call a method like ".set(key, value)", I *expect* something going on in this method. But if I write "obj[key] = value", I expect that to be just an assignment. It's bad enough already that some built-in browser APIs (I'm staring at you, cookie!) perform some black magic behind the scenes; if every library writer now does this kind of stuff with proxies, this makes code much harder to reason about, for dubious benefits at best. So if you find yourself writing proxy after proxy, please take a deep breath and think about whether a proxy is really needed for what you want to accomplish. Complexity is a bug's best buddy, after all.
You can definitely add TypeScript definitions. You can bundle the type definitions (in a `.d.ts` file), use other provided type definitions, or write your own for libraries that don't have them. I believe for flow you can include type definitions in a `.js.flow`file. So if your library is `something.js`you can include `something.js.flow` along with your published library and it should just work. Haven't tried, but I'm sure there's a way with flow to write your own definitions for libraries that don't have them.
thanks, I will look into it!
Im having line to rectangle intersection problem right now, do you have any ideas ?
I'm having a hard time trying to put my thoughts into words, in the mean time [this](https://gist.github.com/ChickenProp/3194723) could possibly help.
For 1, it reduces `MyObject.prototype` to `this`, which is objectively shorter, and something that would add up with more definitions. Secondly, and why `call` is used, is that it maintains consistency in how context is used. When you define property members in the constructor, you do so by assigning them to `this`. The same is being done here with member functions. They're defined in `this`, where `this` would represent your class instance. Granted, you are confusing instance members with inherited ones, but presumably that separation is made with the start of the IIFE (though you don't know it until you're at the bottom of the block where `call` is used; where's that function bind operator when you need it?) P.S. I don't think I've ever seen anyone use this "cleaner" approach
I am in full agreement with you. The second example has the benefit of not having to re-type the constructor, but that is where the benefit ends. Not only do you now worry about context (as you have mentioned) but also the added overhead of the runtime of the IIFE wrapper. The second example is in absolutely no way cleaner than the first example. In fact I'd wager that entire section actually adds absolutely no information on the usefulness of closures. It should be removed from the page.
&gt; Secondly, and why call is used, is that it maintains consistency in how context is used. When you define property members in the constructor, you do so by assigning them to this. The same is being done here with member functions. They're defined in this, where this would represent your class instance. I don't agree that this makes it cleaner. There is a very big difference between instance methods defined in the constructor and instance methods defined on the prototype, and that difference is that on-prototype methods are shared across instances, whereas in-constructor methods are defined for each instance. For this reason, it is far cleaner to separate the definitions of those methods in a way that is "consistent" with the language - I would detest working in a codebase that implements constructors this way if performance were a concern or random access memory were a bottleneck.
Why would you want a top-level one-liner? Spaghetti code should be left to PHP.
Caveat: when done very well in libraries, it can be amazing. Fortunately, the use cases I can think of are all serverside and deal with databases. Though I imagine data solutions on the front end (such as MobX) could benefit significantly from Proxies, though I'm not exactly sure how.
Thanks!
for writing quick ad-hoc stuff for debugging/development in the console?
What do you mean?
How come that react / react-dom is so huge compared to this?
Oh this looks very promising, and just a very interesting library in general. Thanks for the suggestion. 
Cleaner, and none of this chaining callbacks. 
No problem, glad to contribute.
Worth mentioning (I don't think the article does), unlike most ES6 features, `Proxy` can't be polyfilled or transpiled using things like Babel. So if your logic relies on `Proxy`, that's going to be a hard incompatability with older browsers.
Hey man, i have made this: https://codepen.io/killerek/pen/MvOwqX?editors=1010, It only works for left side of each box. What do you think ?
That looks fantastic so far. It seems as though It's producing the desired effect on left side of the boxes. just reiterate for the other corners and you'd be perfect. Also I'd recommend switching the alpha for the light and the boxes to make it easier to determine any other issues
The way im doing this is very not efficient but right now i will be happy to just finish it, then i will see if I can cast a ray to corners rather than 360.
One of us appears confused.... From what I can tell: the 2 code blocks are fully identical in practice -- the ctor in the bottom section _only_ defines `name` and `message`, while the methods are attached to the prototype, just like in the top example. I actually think this is a pretty novel way to create a 'class' (per se) that is much more congruent to other languages (if that's what you're after).
&gt; but also the added overhead of the runtime of the IIFE wrapper Pretty sure the overhead of a single function invocation has never been, nor will ever be, a performance concern.
[No.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger)
Come on, that's like saying "why would you want a hammer when you can hit things with a drill?" Different tools for different use cases. debugger (and line/event/var-watch breakpoints) are fantastic tools, but when you want to just see what the result of your async function is on the page, or if you want to quickly call fetch in the console to test your API's schema, or when you want to validate what getUserMedia() returns for constraints on Chrome on macOS vs windows, async one-liners that you can easily type into the console are a great tool. It beats the hell out of writing a bunch of shit then pushing that to the browser and stepping through it only to throw it away a few seconds later because you verified what you needed, or learned the API through experimentation, or determined that probably isn't the best way to go about something.
Check the network tab in the dev tools. The data comes from an API. Just mock that request and you're gucci
Its broken and im stuck on fixing it, no idea why there is random rays of light going through blocks.
First you should try to restrict the the random rectangles' lengths to integers instead of floating points. 
Is it on Github for me to PR
Tomorrow i will see if I can make the rays go to every corner rather than sending 720 rays in every direction.
why not just ... .then(console.log.bind(console, 'success'), console.log.bind(console, 'fail')) ? what's the point of promisifying a promise?
Yup! www.github.com/gbatra17/wheretotech
I always write `someAsyncFunc().then(console.log).catch(console.error)`
lol. Thanks. I'm sure there is an easy way to make that request but I've been fiddling for an hour with no luck. Are you saying I mock up the request as an address and send it? Because every attempt I make to send in one of addresses in the network tab gets kicked back as a bad request.
Right click the entry and hit copy as cURL then you can just paste it into your bash script. Should be pretty easy to tell where to put your parameters after that.
As more surface area for perspective, many projects use Airbnb's style guide for their JavaScript development. Airbnb suggests that you ["do not" use underscores to denote something that should not be touched](https://github.com/airbnb/javascript#naming--leading-underscore), because there is nothing that enforces it. Of course, there are [some ways](http://2ality.com/2016/01/private-data-classes.html) of enforcing some sense of privacy, which I've tried to experiment with, and there are proposals for a [private field in JavaScript](https://github.com/tc39/proposal-private-fields), but generally, across the projects I've seen, the consensus is to use the Revealing Module pattern or any kind of module system to control privacy. My team has argued and discussed it a lot. Your best bet is to see both sides of it and really understand what core values you guys want to have in your code base and see which approach has the best approach for you, as once you pick an implementation, it'll boil down to style.
The common js syntax seems cleaner, imo. Why not just ignore import and stick with the existing require.
&gt; 1 back-end file, no modules. This means you didn't architecture your code which is not good if you want to write backend code. &gt; Used Backbone without any template system. Didn’t attempt to use React, ES6, etc. If you are applying for a full stack position you should be familiar with modern front end workflow. &gt; JS embedded on the page in one script tag You should have minimised/transpiled your JS code. &gt; &lt;script&gt; tags in the head This is a no-no except for third party libs. Your code should always be imported before `&lt;/body&gt;`. &gt; no debounce on keypress Otherwise you are calling the API on every keypress... I don't know if this is typical, but I'd say you aren't ready for a full stack position. An area that wasn't touched are ORMs, database design, SQL queries, etc, which are fundamental to backend work. From your description I'd say you haven't touched much of that either.
All their feedback seems fair and it's a real job with real pay (or so I assume) so why shouldn't they expect you put some back into it? Or rather why would they pick you if someone else did it more thoroughly?
JS version of sign is `Math.sign` lol
Here ¡s a nice trick the article missed. `node -r dotenv/config ./index.js` You can import `.env` files directly from your `npm` script or command line. This is useful because when running your app in Heroku env vars will be added to the process and configured on a dashboard, but when running locally it's more convenient to have them in an `.env` file. There is no need to clutter your code with logic that is only used in one environment.
cleaner is subjective. import is ~~more flexible~~ friendlier to static analysis than require. the reason we should strive to use import over require is that require isn't part of any standard. it was a homebrew implementation to solve the module issue in javascript. it did its duty admirably but now we have a standard and should strive to use it. major browsers are currently working on their own implementation of the esm standard so expect to see the import keyword start to grow in popularity there as well
Yeah… let's remove this. A better example would be: function MyObject(name, message) { this.name = name; this.message = message; } Object.assign(MyObject.prototype, { getName() { return this.name; }, getMessage() { return this.message; } }); const x = new MyObject("SandalsMan", "Hello, World!"); console.log(x.getName(), "says", x.getMessage()); 
Is it not significantly less flexible? A common js module can dynamically construct itself, while an esm is limited to static lexical declarations. Require allows far more flexibility in what is possible for the module to do, and for how it is designed. In which way do you see esm as more flexible ?
hm, maybe flexible wasn't the correct term. friendlier to static analysis was probably closer to what i meant. my mistake.
I can see it being more amenable to static analysis... to a small degree. That is a lot to sacrifice for such a marginal feature imo...
Your teacher is right, did you even try your code and do you know what "sans-serif" looks like? When you use `sans serif`, it's invalid so it falls back to a default. https://jsfiddle.net/hvv3q58n/1/ Check the fiddle above, I made up a whole new font face called `crap` -- notice that `crap` and `sans serif` look _exactly_ the same. Also notice that neither look anything like `sans-serif`.
i'm not sure what it is you're looking for. require isn't compatible with the esm spec and won't be supported as a first class module system. node will likely not have long term support for require. i really dont know what other reasons one would have to stick with require over import if you have a problem with the actual esm that's a horse of a different color. being able to use imports as a psuedo-interface is a powerful tool
I tried your link and I got very different results. "crap" looks like "serif", while there's no difference between "sans serif" and "sans-serif" .... ???
I guess it depends on exactly what's inside the function. But yeah, for simple cases there doesn't seem to be any advantage over vanilla promise syntax. Thankfully it will be moot once this new Chrome version becomes stable.
`var foo = require('foo')` i really don't want a situation where foo could be different depending on context. i called the module by name, i expect it to be the same every single time. it should be a pure function. is there some other flexibility i'm not immediately thinking of?
&gt; **Used Backbone without any template system**. Didn’t attempt to use React, ES6, etc. This is a pretty big one. Backbone is built to use underscore templates out of the box, and it's throughout the documentation as a given. You can replace underscore with other things like handlebars or use lodash if you fancy. Even if you are doing your own clever version of templating, it's hard to argue in favor of doing it a custom way especially when your goal is for another dev to understand your code.
How many browsers have you tested? The first 2 are invalid and fall back to the default, while the 3rd looks just like "Sans-Serif" should in Chrome, Firefox, and even IE on Win7. I highly doubt that one browser, much less all 3, would behave differently on any other OS for such a basic feature that's been around for ages. For further evidence, read the W3C specifications (this is the governing body for HTML/CSS): https://www.w3.org/TR/css-fonts-3/#generic-family-value If you ctrl-F search the page, "sans-serif" shows up 28 times while "sans serif" only shows up once (probably a typo).
How about a library which creates itself based on a specification, like a wsdl or a template. Or a library which might be missing, so you try catch loading it. Or a mutate library which poly fills into its environment. Or a plug in which can define a subset of a specification. These are all possible and more with the existing common js but all ruled out with ems.
+1, love mithril hyperscript
I felt it would be overkill to architecture a coding exercise that just uses one API call (other than connecting with the API key) and with one interactive form field. Didn't know if I would be spending too much time for it. Same deal with the template system. Normally I use React but felt it too much for something of this scope. Won't minimizing the code make it hard to read? This code was sent to be reviewed. When I ask the employer what is more of the priority here, they said it is *somewhat* of a fullstack exercise, but that what is given to me is the expectation of their frontend engineers. I'm less experienced with backend JS than frontend. Although the exercise used Node and Express, there were no database queries involved. Just the usage of twitter API to send JSON data to the frontend.
It would have taken me about 6-8 hours to finish the work if I followed the guidelines. How long should I be willing to spend on a take-home coding exercise (unpaid work) for each prospective employer? For this particular company, this exercise was the step between the phone interview and on-site.
This is such a great breakdown. Better than I could explain! 
Yep, maybe the fact that people `aren't more excited about proxies` is actually good. I don't want to see code where people use proxy for everything (similar thing happened to restructuring - people use it everywhere, even if it obscures code without any bigger profit). I also hate where I debug code and I find out that my bug was caused by some getter/setter deep in 3rd part library code. Besides object with getters/setters can't be fully cloned via Object.assign. It's unpredicable magic. So I prefer to avoid getters/setters (along with Proxy) and treat them as necessary evil. But this doesn't change fact that both Proxy and getters/setters are great for metaprogramming. They allow for observing objects (for debugging purposes or for reactive programming like in Mobx) or for making crazy thing like virtualization of API (somebody made library for this lately) or for detecting mutations and perform automatic immutability (self promoting but I made library for this: https://github.com/hex13/enter-ghost/tree/master/packages/transmutable ) 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [hex13/enter-ghost/.../**transmutable** (master → c112161)](https://github.com/hex13/enter-ghost/tree/c112161baf9aff08098e188a1434402a11415e28/packages/transmutable) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlohcmv.)^.
&gt; Form validation is the only thing that I'm not found a good solution for [...] I'd like to have something without redux I've created a very simple React component (~350 lines of code, no dependency) for form validation: https://github.com/tkrotoff/ReactFormWithConstraints Might suit your needs.
&gt; I felt it would be overkill to architecture a coding exercise that just uses one API call For a quick and dirty stuff for yourself it would be fine, but not for showing your skills. If you are experienced you should know about separation of concerns and single responsibility principle. For example you would never make API calls from inside a React component, likewise you would never make API calls in a Node project from the entry point or server config module. They probably wanted to see if you understood those principles and you should have delivered your best possible code regardless of the requirements. &gt; Same deal with the template system. Normally I use React but felt it too much for something of this scope. They can't know what you are capable of if you don't show it in your code. Your code has to speak for itself. You must also consider that your code could have been reviewed by someone that didn't even know the requirements. *Hey check this stuff some candidate has sent us.* *Whaaat? Nope. This guy doesn't even know about React, babel, webpack, etc.* &gt; Won't minimizing the code make it hard to read? This code was sent to be reviewed. Shouldn't you be delivering a working example and source code too?
Had the same exact issue... a bunch of employers each wanting a custom project that takes anywhere from six hours to multiple nights (said so casually as well!!!) to complete. What I did to save a lot of time was to use a modern boilerplate (where React, Babel, webpack, CSS processors, etc. are all already set up for you). I tried sending everyone to a project I had already made (mind you, I have demonstration videos of big projects I've worked on as well) and they still want me to do their 'projects'. In the end, I just dropped them all and started applying for companies that do white boarding interviews. I would rather study computer science theory than write another throwaway React app.
Why in the WORLD would you do this? What is the possible use case for a mutating dependency? There's no possible scenario I can think of to have a dependency that I can't know the state of until I import it. This is why interfaces exist in other languages. This is why import is so important, to protect from shapeshifting dependency nonsense by people who try to act cleverer than they are.
https://phaser.io/ would be your best bet. Open source, fun to make and has good community. If you have experience programming, you will be fine learning JS along the way, don't worry too much.
This question appears in this subreddit in different forms quite regularly. Responses from developers will vary, but you'll almost always be told to use what other developers deem to be the best choice. To grow as a developer, it is important to make your own informed decisions which should be driven first and foremost by your requirements. Start from the outside and work your way in. Any modern Javascript framework or library will achieve the task. If I were building what you're wanting to build, I would use Aurelia Javascript framework and Firebase for the backend/realtime aspect. But what I would use and what someone else might use will surely be different, I would just use what I know and what I am comfortable in using. You'll be told to use Angular, React or Vue most likely. Have you looked at any of the options out there? Spend a day or two playing with some of the different choices out there and see what appeals to you the most, because what appeals to you and meets your requirements is really all that matters.
Hey, I agree, that would be really cool! Certainly a big task, as you say, but also a fun challenge. Using Socket.io and transmitting text diffs could be a reasonably efficient setup for this. I think that by implementing a "locking" mechanism for the editor, such that only one client could edit at a time, the complexity could be reasonably managed for a basic initial version. Combine that with a sidebar chat client and an invite system, and we could have a pretty compelling collaborative editing app.
No browser has yet implemented WebCL and there will never be one that does. Firefox is going with OpenGL ES 3.1 compute shaders. Firefox is at WebGL 2 which is based on OpenGL ES 3.0. So, it will probably get compute shaders in the future. In the meanwhile, check out [gpu.js](https://github.com/gpujs/gpu.js) and similar libraries.
Yeah, I have no problem not using it. My problem is when they say that it is not a common convention. It implies I'm making it up. I guess I'm being prideful, but it really irks me.
I kind of wish for frontend frameworks that would focus on something other than rendering and the viewmodel. React, Vue, and a zillion other virtual DOM libraries are doing a fine job at this. The hard bits now, it seems to me, are combining in-memory state with with AJAX and realtime (websockets), offline state, error handling, other PWA features, etc. That said, this does look like a nice clean take on the viewmodel framework genre :). Reminds me of mercury.
At your exact stage you may want to dive head first into vanilla JS and the DOM and try to invent your own framework. Then when you use a real framework created by people who have tried and failed a few times you can best appreciate the work it is doing under the hood. If you don't know what `addEventListener` does and how to crawl the dom you are probably going to have a bad time. Most frameworks expect you to know what the difference bewtween `querySelectorAll("#foo")` and `querySelectorAll(".foo")`
I copied this into a simple html page and it works fine. The only thing I can think it might be is the js isn't loaded into the page. Check the dev tools of the browser (F12), see if you get any errors logged.
Thing is, a lot of computer science theroy doesn't work out so well in practice.
wreck is another one to consider... used in hapi
None of these are difficult things, although I could see overlooking them while trying to pump out a quick cookie cutter fullstack app. Perhaps before going in to an interview like that it's wise to brush up on instant project creation, where you go from zero to working site fairly fast. It's not really the same as proper fullstack development, since prefab doitall toolkits are going to be preferable to a meticulous construction. And seriously who still uses backbone.
There are probably many more little optimizations in the react implementation. For example, real world performance and/or memory usage will be different. Also things like lifecycle hooks and per component state can quickly add complexity. Not to mention the extra features like keyed children and all the rest of the backwards compatibility considerations that react takes so seriously.
Well, a large chunk of the npm modules for starters..
Well, it's very nice for writing unit tests. Also, it's fairly common in node libraries for a number of reasons, all of which are valid. For example, promisification.
&gt;They can't know what you are capable of if you don't show it in your code. Your code has to speak for itself. You must also consider that your code could have been reviewed by someone that didn't even know the requirements. In his defense, on this point, that's pretty shitty if it's true. If you're reviewing somebody's work you should know the parameters they're working within.
&gt; that's pretty shitty if it's true Not really. Good practices and clean code are independent of what the code actually does.
Are you talking about polyfilling? That can be done with modules. If you don't mean polyfilling, it's extremely unclear what you're referring to. Please provide a concrete example of a library that mutates when you import it.
Memory usage in Hyperapp is "virtually" the same as vanilla JavaScript and we are always optimizing the Virtual DOM to update the DOM as efficiently as possible; we are not lagging behind. We also support keyed updates and lifecycle events. All in 9.7KLOC lines of code less. (React+ReactDOM is roughly 10KLOC).
Thanks for letting me know, and apologies for posting inappropriately! I've read through the guidelines; just so I'm clear, this post was removed for not being specifically about JavaScript and/or being self-promotion? My intention was to invite the JavaScript community here to participate in sharing their JavaScript-based artwork, but perhaps it's too early in the project for that, and the post wasn't specifically about that. If, once the project is further along, I write a more specific "call for JavaScript artists", would that be appropriate?
Yes, React is doing a lot more, but those things are not important if your render target is only the DOM and you don't support IE9. React is not the the state-of-the-art Virtual DOM implementation. See also [inferno](https://github.com/infernojs/inferno), [domvm](https://github.com/leeoniya/domvm), [ivi](https://github.com/ivijs/ivi), [dio](https://github.com/thysultan/dio.js), etc.
Poly filling has to look at the environment and decide what symbols to provide. With lexical scoping, this doesn't work, because the provided symbols must be static. Bluebird, sinon as promised, are other mutators, which alter other imports. But you cannot mutate an esm. Overall, I think common js will live on, as it is much more feature full than esm. 
I'm really impressed by the care and thought that went into this. I've seen several attempts to implement drag and drop and this looks really good. Just moving based on the center of gravity rather than cursor position puts this so far ahead of so many others I've seen.
In what way?
This would not be accurate if the user deleted the emails. Also, by reading my emails? Not a good approach. I would not a trust an app to do this, even if the repo is open source.
I was using those more as examples of the type of things that would be in react but not in a lean lib. I doubt a team of professional engineers at Facebook are doing nothing with all that extra code.
You don't need to bind console anymore, just go with null or 0
Thanks for the upvote guys!
I'm a full stack web dev with ~6 years experience. We give this same type of task to candidates at my company. Having sat on the interview panel for the technical assessment, it was important that we didn't ask them to do anything we weren't willing to do, to ensure our request was reasonable. I finished a small backed API and Angular frontend of about the same complexity with full coverage and end to end tests in about 3 hours. It's not my intention to brag. My point is having full familiarity with the stack and language, depending on the level of the position you are applying for, I don't think it's should take a whole work day. We allowed and encouraged candidates to use starter projects to save some time, as well. Though, one thing I would note is that for our candidates, we tell them up front what we are looking for, basic code quality metrics and such.
I think you've confused mutating the library and mutating the environment. Modules can mutate the environment. They cannot mutate themselves. Everything you described still works with modules. 
I personally don't like sequelize, it's very opinionated and you need to follow their patterns for things to work. When you use Bookshelf you also need to use Knex, the combination is much more powerful but takes more effort to set up, overall I think it's a better solution because it's not as opinionated, and lets you customize how the ORM mappings work. Knex has other ORM's built on top of it as well, Objection.js is similar to bookshelf but relies on JSON Schema, which may be good for you if you're also using JSON Schema for swagger or if you're using express-ajv for validating data models. 
No, I'm not afraid. Software development is hard and takes a combination of different skills to do effectively. Problem solving is one obvious one but many outside the industry don't realize that managing partnerships across teams and being able to discuss technical ideas with a variety of audiences are also quite important (as are others). It's fairly difficult to find good developers as a result. Next, experience is king. The difference between a junior developer and a senior developer in terms of productivity and effectiveness can be huge because the senior developer has more experience to know what the right questions to ask are or what types of problems are likely to occur. Senior developers can not only solve problems faster than junior developers but can prevent many from ever happening. Will standardization happen? To be honest, I don't much care. I'll learn whatever needs to be learned so if everyone moves in one direction I'm happy to try that out. I think, though, that given the low barrier to entry that we will always have new ideas and alternatives available that a fair number of people will swear by.
I started working on my universal javascript framework, see https://github.com/martijndeh/fire. The goal is to create a complete framework to help you create minimal viable products faster. :)
See my [comment here](https://www.reddit.com/r/javascript/comments/6tt1mw/hyperapp011_shipped_the_1_kb_javascript_library/dloqbwv/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=javascript). React is definitely doing other things. Overengineering too. But do those things justify the extra 10KLOC? Good question. Look at Inferno or Preact for more answers.
Thanks, but I respectfully disagree with the first paragraph. Those are the things the application developer is responsible for, not the library or even framework.
If the event hasn't happened yet and you don't need video, you can use [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). That way when it finally fires, you'll at least get some audio from the booth visitors.
Have you ever written JS for embedded hardware using johnny-five or similar? because in those cases a single function invocation can mean increased ping between transmitters and receivers. 
Good point! I totally forgot about that one :)
What I meant was that making prototype methods (defined on Constructor.prototype) look like constructor methods (defined on `this` inside the constructor function) by making it so that prototype methods are also defined on `this` is confusing, and because it is confusing, it is not clean.
I guess you interpreted my question wrongly. "JS Event" is more like a JS Big Meetup or Conference.
This is how any well-designed drag and drop UI works. Frankly I'm a bit surprised you find this exceptional, or that the author thought "rethinking" is a good way to describe it.
1.) No, because no matter how many programmers there are in the world, regardless of what specific language, they will always be in short supply. There will always be demand for a skilled programmer in the workforce. 2.) What gap are you asking about? Knowledge-gap? Salary? Respect? No matter which, it depends largely on the ethos of the hiring party. In my case, I am a 24 year old software developer from a developing country that started coding at the age of 7 in Borland Delphi Pascal and FORTRAN (so, 17 years of programming experience) and started doing PHP freelance at the age of 12 (so, 12 years of professional experience). Yet, because of my age, I have only ever worked as a junior developer with the exception of my previous job where I worked remotely as a normal software developer, (so, not senior, but also not junior) for a Brooklyn-based Inc 500 company, where the highly respectable, awesome team of higher-ups hugely adopted the mindset of "age !== experience" and put it into practice. This puts me in a place where I have an interesting perspective to share on this topic: While I have all this practical experience behind me, I lack the same amount of experience leading a team, and I think that is what separates a true senior software developer from a regular software developer. A senior developer is someone who can be trusted to not only turn a project-gone-south around, but motivate others to do so as well. A senior developer is someone who is battle-hardened and wise enough to convince their peers during code review not to merge the way timestamps are currently handled because it might cause the shipping container rental to be delivered an entire day late. A senior developer is someone who effectively teaches their inferiors how to consistently maintain the company's architecture and programming style, and more importantly, a senior software developer is someone who understands that it's their ass on the line when someone they're responsible for managing makes a huge mistake. It's not just about experience, it's about responsibility, the ability to motivate and teach others, the ability to work under immense pressure, and a strong loyalty to the company is important as well. 3.) Separate teams and/or companies will definitely standardize more technology, architecture and practices as they grow, so that the process of growing has the least amount of friction possible. However, technology changes and improves exponentially over time, so it's not accurate to expect that standardization itself is a permanent thing - because technology evolves, and our perceptions of how things work, should work or should not work change and evolve with it, standardization has to evolve as well. With changes to technology, there are changes to standards. Technology, software, techniques, paradigms - these are all things that change. New frameworks come out, old frameworks re-surface, etcetera. If anything, I think that what frameworks provide right now will eventually be standardized at the language-level, just as it has been in the past. We're seeing this right now with Vue/React and native Web Components. Companies in the future will push more toward building infrastructure or abstractions on top of standardized native versions of the same thing. But a company standardizing something like "always use react.js for web projects" is just not realistic at all.
Great work! Does this mean JIRA's drag-and-drop system is getting an update? 😝
&gt; I guess it depends on exactly what's inside the function. It's always a promise. You can't await non-promise.
I have to admit that I've never done an interview that involved code -- everywhere that I've worked, code wise, has seen my code in advance, and knows what they are getting into, or at least had the opportunity to see it in advance. But I think if this were what I were faced with, if I had to change jobs in the future, I'd probably go back to sales or something. "Do this with no specs, design your own UI, use whatever libraries you want, and guess what we want out of the final product" sounds exactly like a company that you don't want to work for -- and I'd be willing to bet that their actual products are a mess. 
1) No, there will always be a shortage of programmers because programming moves along at quite a fast pace, and many people don't stay in it for careers. Also, be aware of bias, you may think javascript is the most popular language right now, but that may just be in your niche. IT software development is a huge area. 2) This is a very subjective question. Some people can pick up concepts (and explain them) to a high level quite quickly, some take a bit more time, but get there eventually. No one is the same. 3) There will never be standardisation on something so abstract as a framework. Arguably the closest we got was jquery ecosystem, and that is now waning. As PCs get more powerful, the patterns we can use will increase. 15 years ago you would have had a lot of issues running angular on a 1ghz machine. Basically, things move on, don't procrastinate, get coding. Don't worry.
I have to admit, when I was in game development, and was looking at Unity, and they said "build in JavaScript", I wasn't too experienced with JavaScript at that time (but I knew UnrealScript like the back of my hand, and had some experience in JS from years prior) .. and I took one look at their "JavaScript", and I laughed, and I laughed, and I said "this is stupid." Now, I'm stuck working on a C# project with Unity that is not actually a game, and this is the first time I've ever used C#. C# seems nice, it's interesting. Whoever wrote the syntax probably shouldn't be allowed near programming tools ever again, but the language itself seems real nice. Thing is, it almost seems like it's something that Microsoft just keeps on working on, despite .. who uses it? The reason why I've never used C# before, is because nothing I've ever been interested in used it. Anyway, if you want Javascript, and you want to use it inside a game engine, I believe there are at least 1 or 2 projects, if not more, that incorporate V8 into Unreal. That's probably where I'd go, because I'm super familiar with JavaScript these days, and I haven't touched Unreal C++ in like 8 years now, so I'm sure I'd be lost as hell walking into an Unreal project now, too. 
Got any pointers to some other implementations? Doesn't have to be JavaScript.
so.. a CloudFormation script generator, that only has a couple of services implemented? the idea of being portable between different cloud services seems interesting, but throwing down a layer of abstraction for two things that are probably very different, seems like it might pose more of a problem. 
1- is there something that can be done with proxies, that cannot be done in any other way? 1a- Is there something that you would ever actually want to do, that can be done with proxies, that cannot be done in any other way? 2- is there something that can be done in another way, but proxies make them easier to understand? 
A video? really? 
That looks and feels great! Here is the direct demo link: https://react-beautiful-dnd.netlify.com edit: apparently this already exists and works on mobile: https://github.com/clauderic/react-sortable-hoc
Looks slick, very in-dept post. Here are some examples: https://react-beautiful-dnd.netlify.com/ couldn't find those in the post.
...is this what we are reduced to now? 
I'm suspecting that this is what happens when you translate the English what's new notes in Node 8.0 to a non-English language, and then translate it back to English. 
Wow that looks like a ton of work. Impressive. Is this something you want to build out to a fully supported framework, or more kind of a challenge you're willing to bite yourself into?
Kinda stinks it doesn't work on mobile. 
I like it, but this should be higher up, without mobile support it's ~~pretty useless in most cases~~ sadly not applicable for my projects. Also, with all the nifty extra animation and calculations I wonder how much of a CPU hog it is if it it would work on mobile. 
Sequelize: a huge war machine that is a massive pain in the ass whenever you want to do anything remotely custom or not already specified in the ORM. Bookshelf: meh. Overall: Use Knex instead ; with Objection.js without the schemas if you don't need them but still want that syntactic sugar over knex queries. The experience you'll get using knex and writing queries is very valuable, this is the way I would definitely go.
Sure! Lets write everything with goto instead of functions because 0.01% of the devs write js for embedded hardware!
... what?
https://github.com/clauderic/react-sortable-hoc From the comments to the medium article. Seems like the same behavior and works on mobile.
Jon Duckett's books for basics
Synthetic Events is one of the features, that adds significantly to the overall size of React. 
look forward to playing with this. have wanted something like this for a while. 
And what is the benefit? :)
There could be multiple promises (and some other stuff), is what I was hinting at. It's usually nicer writing those in one place rather than in a chain of `then` callbacks. But yeah, not the kind of the thing you typically do in a REPL anyway. And technically you can await a non-promise... it's just pointless.
it reminds me of my library San Escobar which does similar things: http://npmjs.com/package/san-escobar
Neither-Objection.js is the top dog when it comes to ORMs.
I appreciate the detailed analysis that went into this. Very well done. Edit: One small criticism, it doesn't scroll the container or window when near the top or bottom. Could be achieve with your own implementation on top though.
 document.getElementById("midiframe").style.height = `${document.getElementById("midtext").offsetHeight}px` You've to set it to it's actual height, not style/css height.
It didn't work. Do I need to add jquery for it?
Could you show your html too?
Cheers - we are already thinking about auto scrolling: https://github.com/atlassian/react-beautiful-dnd/issues/27
https://pastebin.com/1g99V7N9
Well, it uses a ton of existing components, like Koa, React, etc, which it's not trying to replace but rather integrate nicely. The idea is to build a solid foundation, yes. :)
https://jsfiddle.net/L16336oo/2/ it works fine for me if I define css for .iframe-fix and iframe
Didn't see that - brilliant work, I'll be using this in any future projects where I need scroll.
Without css. Page looks like this: http://imgur.com/jsq3DuP And iframe should change heigh: http://imgur.com/SRTYJnA
I thought it's the easiest way to display the process. Any better ideas? I can explain it with a few words, too but I thought "a video is worth a 1000 words" ... :P
I figured it. iframe was wrapped in div with specified height, which was needed for iframe display. By changing it I managed to do it.
Yea, I have to agree. His jquery sortable gif is even not right... I have no idea how he even got it to do that, the jquery demo page shows pretty much exactly the same thing he ends up with. https://jqueryui.com/sortable/ 
What comp sci topics do you feel are useful to study? I'm currently at the stage where I'm writing throwaway react apps as you say, but usually to learn new things.
Seems like html &lt;template&gt; tags are the way to go. Supported in the browsers I want to support and they're simple enough.
Here is a reply I posted regarding `react-sortable-hoc`: https://medium.com/@alexandereardon/thanks-for-reaching-out-dimitar-nestorov-8c0bf9abe19 Here is the latest regarding touch support: https://github.com/atlassian/react-beautiful-dnd/issues/11
I guess if you're looking for a dead simple, vanilla version of the other things you mentioned, that's easy enough using something like this... class MyComponent { constructor (el) { this.el = el this.state = { label: 'Counter', count: 1, } } setState (key, value) { this.state[key] = value this.render() } render () { this.el.innerHTML = ` &lt;h3&gt;${this.state.label}&lt;/h3&gt; &lt;div&gt;${this.state.count}&lt;/div&gt;` } } const myComponent = new MyComponent(document.getElementById('my-component')) myComponent.render() myComponent.setState('count', 2) // etc. Is that the kind of thing you're looking for?
Yes, it is a natural next step after getters/setter for transparent reactivity based state management libraries. It solves a lots of problems and hacks (like expando props and arrays).
Well, no. In jQueryUI the elements snap instead of move, it centers on the cursor instead of the center of the dragged element, and it does not support keyboard "dragging".
Isn't this similar to Quokka?
I see a bunch of comments about state management, MobX and ES6 Proxies here and I made an ES6 Proxy based state management library for React a while ago: https://github.com/solkimicreb/react-easy-state. Check it out if you are interested (:
But isn't this a bit overkill compared to Feathersjs or similar frameworks which do almost that, but on the backend only?
Proxying to anything other than the target of the operation seems to be awkward to me. I would say that proxies should be used only to intercept and forward or prevent operations. (You are right btw: the above code is possible and it looks pretty bad)
I just want to point out that Objection doesn't _rely_ on JSON schema. It's the default validation method, but it's optional. You can simply ignore it or use any other validation library.
Heya yeah I had a feeling deleted emails wouldn't work. What approach would you use instead of parsing emails? I'm open for changing how it works or adding alternative methods (keep in mind the Uber api doesn't allow access to receipts unless the app makes actual Uber orders.) Also I had to get the app verified with Google, otherwise they gave users a very scary looking warning message upon consent. You don't have to use the app if you don't want to, but I've gone through a bunch of steps to verify and be public about what the app is doing. Feel free to clone the app and run it locally if you still don't trust me but are curious :)
Ahhh yes, that look very nice. I was afraid that the template literals wouldn't be supported in my target browsers, but apparently [they have wider](http://caniuse.com/#feat=template-literals) support [than &lt;template&gt;](http://caniuse.com/#feat=template). Thanks!
&gt; The common js syntax seems cleaner, imo. The CommonJS syntax is imperative while the standard syntax is declarative. CJS is imperative because they had no other choice. Declarative stuff requires language changes. Declarations are more convenient for tooling because you can analyze them statically.
I think you could store minX, minY, maxX and maxY of currently selected cells at any given time and make sure that all cells between (minX,minY) and (maxX, maxY) are selected.
Modules will be enabled by default in Chrome 61 (next stable). You can try it today with a flag: chrome://flags/#enable-experimental-web-platform-features Demo: https://paulirish.github.io/es-modules-todomvc/ Flags/versions of other browsers: https://github.com/paulirish/es-modules-todomvc#readme
The animation part is not just "pros", it also adds lag to the interaction where you get feedback on where the item gets dropped once the animation is done. It's quick, but it does add lag. Also animation movement in HTML is just as easy as a one line of CSS to make "left"/"top" animated...
Trello. They use placeholders instead of animation (which works better in practice as you get instant feedback where the item goes instead of being lagged by animation). But the other points are more or less the same.
&gt; Fundraisers are generally ok as long as you're not the one benefitting from it.
You should maybe rename this post "8 Top *AngularJS* Frameworks", as the article only talks about Angular-related libraries. 
You can't mutate the symbols in an esm. https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e A common js module otoh is an ordinary object and not something special.
That's awesome! Im gonna look through your library when I get off work.
very interesting. well done. hope an API comes soon.
You Don’t Know JS. Free on github. Don’t worry so much about “a focus on web development.” Everything you learn at this stage will be focused on web development. 
Eloquent Javascript (http://eloquentjavascript.net/) is a great book overall, but is missing ES6 which you can learn about through the MDN docs (https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_2015_support_in_Mozilla)
It's ironic, that if I created new thread about my library, I would surely got upvoted (like OP here). I assume I got downvoted only because this is somebody else thread, and I am "evil" because I mentioned my library in the thread "owned" by someone else. It's also ironic that modest self-promoting in one comment is punished, but big proud self-promoting is awarded (OP created lately two threads on Reddit and one thread on HackerNews. Just for self-promoting). Nevermind I don't like being downvoting for idiotic reason, so I will delete my comment soon. So feel free to downvote even this comment if you don't personally like it. 
This article gives a nice list of which libraries may give us headaches. I do think it's more a case of libraries rather than language though. Node isn't perfect, but rapid scaling is always going to cause headaches. When it comes to libraries it can be hard to tell what is good and what isn't, though there are big flags you can look for. Hapi for instance was made by Walmart and is used in production on very high-traffic servers, most of the features aren't bundled with the main package either, so you only bring in what you need, whereas Express comes packaged with everything. Hapi is great for scaling too, as it's very modular and once setup is very easy to extend. Another thing, I think the JavaScript community and the Node community are quite separate. The vast majority of JS users will only use Node for npm, gulp, etc. They won't be doing any serverside development. So it's Node, as one backend language out of many, being compared with a language that is used universally by all front end devs.
I don't think so. The key difference is the integration with the front-end, which is a key feature of Node on Fire. The idea is that that integration saves you a lot of time. Eventually the framework will have the key functionality you need for your minimal viable product, like auth, api, mail, a/b testing, etc. For example, check https://github.com/martijndeh/fire/blob/master/packages/fire-canary/src/index.js. MyService runs on the server but is invokable from the client.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [martijndeh/fire/.../**index.js** (master → 6075dcf)](https://github.com/martijndeh/fire/blob/6075dcfb41a59607bd2242ccd5eeb55644064d8f/packages/fire-canary/src/index.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlpd920.)^.
Lack of support in IE and the limited ability to polyfill them really limits their utility on the front end, at least until IE finally dies for good.
Now go use flexbox and you won't need js
Sails.js is shit. Don't use it. No wonder it takes too long to run API based on that. The only question I have is-why the hell is the author still working on a product built with node.js? His unending love for Go is more than apparent. He should have just jumped to a company where he'd be using Go.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [maierfelix/Iroh/.../**API.md** (master → c14a8b4)](https://github.com/maierfelix/Iroh/blob/c14a8b4120260eff91a79a6e19a42306fb26e774/API.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlpf457.)^.
There's also [dynamic import](https://github.com/tc39/proposal-dynamic-import) which has the full flexibility of `require`, allowing you to dynamically load modules at runtime, asynchronously.
css-tricks? So what-are we taking advice from html coders now how to write javascript?
Hey man, i have troubles. I did this https://codepen.io/killerek/pen/LjOoEB?editors=0010 But i dont know how to detect ray intersection, when i do it just gets stuck on the corners of boxes and the light does not go where supposed to. Any ideas ?
Sometimes downvotes are obvious, other times they are not. In my experience, bringing up a related project usually isn't an issue, unless you're doing it obsessively (which you aren't). With that said, I reviewed the 2 projects, and it appears that even though they may at times produce similar-looking output, they seem to be very different in their design and purpose. Yours is self-described as "HTML logging", while OP's is "Dynamic code analysis"; these are worlds different in practice... yours is very narrowly focused and looks to be (please correct me if I'm wrong), just a logger with colors and maybe a little more. OP's is an ambitious source-code analyzer which just so happens to log output (the only commonality with your project). So, the downvotes may be due to the fact that you're bringing up a much different and pretty much unrelated project. Also, it's poor form to complain about downvotes (see: [reddiquette](https://www.reddit.com/wiki/reddiquette)).
Somewhere someone will take inspiration out of this bot. 
Hmm. before drawing the lines, get the interesction first with your intersect function, and then draw the lines with those coordinates
it seems you may having problems becuase the `endX` abd `endY` variables are still being used in the drawing process
Thanks! I refactored my method based on your suggestion and it is working great.
I would suggest you learn how to use devtools debugger and try to figure out what's going on from there. It could literally be anything. If you're lucky, it's just an incorrect loading order of the scripts.
Took this for a spin last night. The stack traces are very good compared to, say, a rollup-ed bundle. However, I did run into a few minor annoyances: - it throws if the file extension is not .mjs (this is doubly annoying for me because if you do rename your file, Atom syntax highlighting doesn't work properly for mjs files...) - Named imports for native modules (e.g. `import {readdir} from 'fs'`) don't work. You have to do `import fs from 'fs'; const {readdir} from fs;`. These two aspects are technically configurable, but the whole point of the tool is that presumably upcoming Node versions will behave like its default configuration, so the configuration seems like a catch-22. I also ran into the issue that object spreads throw despite being supported in Node 8.3 The native module named import thing broke stuff when migrating (e.g. code that used `import {join} from 'path'` and had variables called `path`). So, something to keep in mind. One last point of interest was that I had never seen package dependencies implemented the way this one does. It basically bundles itself in a zip file and compiles itself on the fly. Open node_modules/@std/esm/index.js to see what I mean.
Okay thanks, I'll get started looking into that right away. 
&gt; yours is very narrowly focused I would say that my library is just less mature project (this is the reason I didn't create a new story about my library - for now it's just proof of concept and I don't like over-promote proof of concepts). On the other hand my library has nice visualisation so I thought it could be interesting for others. &gt; Yours is self-described as "HTML logging", while OP's is "Dynamic &gt; code analysis"; Ok, I updated description and now it says that it's dynamic code analysis. 
Just from googling that error, it looks like what /u/nightwolfz suggested is most likely the error. Maybe try to make sure that your `jQuery` script is put first before any `jQuery` plugins you have.
Personally I use [caddy server](https://caddyserver.com/) as a reverse proxy. Although, [nginx](https://nginx.org/en/) is probably more standard. It sits in my root project folder. The root project folder holds my `api-server` and my `client` folder. I serve my site resources from `client/dist`, but I also build on the server -- which some people don't like and is probably not recommended. This is what my `Caddyfile` looks like. http://my-site.com { gzip root client/dist proxy /api localhost:3000 proxy /protected localhost:3000 }
Not trying to get into a drawn-out debate on this, just trying to explain the "irony". Simply changing the name isn't going to alter the characteristics of the software, they are still very different; most notably, yours requires that you implement some method calls (`log()`, `spy()`) to see results, whereas OP's is fully instrumented (no alteration of source code required). If you still believe the 2 projects are similar past superficial output, then I'd implore you to take an in-depth look at OP's project and attempt to replicate the behavior in your project. 
Copyright/trademark ideas, not code. You will never be able to restrict someone from borrowing your website's code.
If its all client side, its harder to protect. If you can implement any of it on the backend, that helps, though it doesn't seem like your content lends itself well to that. Otherwise you can try to implement some domain whitelisting which, along with some obfuscation, will make it a bit more difficult for the casual user to be able to use your code on a different site. If it feels like a hopeless cause, put it up on github and revel in the notoriety.
Building an app/website won't make you money. Marketing and customer service will. If your concept is so simple that anyone can copy it with minimal effort, it probably wasn't going to be very profitable because it is essentially a commodity. What is your product? What can your company provide that would make customers choose you over the copycats? This is where I would focus my resources. 
brb writing a library to componentize my XML 
&gt; to replicate the behavior in your project. Technical side is not a big problem. Similar projects for JS exist for years and they are doable. Everybody can make PoC with help of Babel or other tool for AST transformation. Two biggest problems: - get these ideas from Proof of Concept stage to full fledged library which can provide real profits (My library didn't pass this stage. I'm not sure if OP did this, but I may take a deeper look. Looking into someone else code can be big educational experience). - get theses ideas to mainstream (for now dynamic analysis is just geeky thing, nobody really knows how to use to solve real life problems with debugging **big** business aplications). &gt; yours requires that you implement some method calls (log(), spy()) to see results it was meant to be transformed by Babel plugin which would automatically add spies. 
I'm not familiar with trademarking anything but sounds like that's the most viable solution long term. Is this the site everyone uses [USPTO](https://www.uspto.gov/) or do people starting out usually get a lawyer?
In the business world it is more important to obsess over customers than to obsess over competition. It is likely people will steal your code from a public facing web site. But they can never have the passion you put into creating it. Pour your passion into service of customers and don't worry about the drive-by thief.
Yea all client side for now. I want to add some node.js to the mix to support some additional interactivity but that's for a different section of the website. Thanks.
Really good questions, and up until now I guess the whole concept has been around this one thing which turns out can be copied with minimal effort (even though it took me a long time to put it all together). Focusing on answering those questions is definitely going to be way more beneficial long term, thank you.
Make sure you parse the XML with regex first!
I like this, thank you.
We shouldn't cripple desktop capability because of a limitation on another platform, assuming the returns are worthwhile.
You can't copyright or trademark ideas though
I made a bot which will give people in a discord chat server a role based on their speed on typeracer. And if they improve it will update their role. https://github.com/RandomGenerator42/DiscordTyperacerBot/tree/master/New%20folder Also I made an interval alarm. Which will tell me to stand up every twenty minutes for 8 minutes and which will tell me to walk around for two minutes for every twenty eight minutes. https://github.com/RandomGenerator42/Interval-Alaram/blob/master/alarm.html
Thank you, It seems to stem from advanced custom fields pro and I put in a support ticket to see if they have any solutions before I dive into fixing it.
&gt; I do think it's more a case of libraries rather than language though. I address this at the end of the article
That is the part I was responding to. I thought you left it open to discussion, so I gave an example of a good library that has worked well for me, as a way of showing it's probably bad libraries and not a bad language.
Quickly! Better jump on board straight away!
That depends on the user case. A 'general' drag and drop library and it's application should reflect global use cases which are increasingly mobile. If you plan to use this in a desktop environment it's quite an awesome library. Sadly most of my work involves 40+ percent mobile use, so I can't use this without a fallback, which for me is too much of a hassle now. I just hope the library is extended too cover those cases as well, without compromising the desktop experience.
Are you sure the new browserwindow is a separate thread? I would think it would be a new process. If so, then maybe [this](https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread) stackoverflow question can be insightful. 
Please do not worry about the downvotes. I notice your comments often and I enjoy reading them, so I would encourage you to comment as you like.
I've gotten this usually from most open source development if a problem is edge then you usually get a "fuck off", till the creator's ego takes a bash or they need it themselves.
I dont know how to detect if line is going through the box, because on corners at some angles it will go through box,
Thanks :) 
I personally recommend https://github.com/gajus/xfetch. It is a high-level wrapper around `node-fetch` that: &gt; On top of the node-fetch, xfetch implements: &gt; &gt; * HTTP proxy support. &gt; * Response validation. &gt; * Retry request strategy. &gt; * In-built CookieJar. &gt; * Strictly typed API.
that will also allow me to unit test my SVG using JSON!
Okay, so I was confusing process with thread. Thank you for clearing this up. 
And there will be job listings for 'Superhero &lt;framework&gt; Magicians'
Does it do the same with let keyword
What's the point of this comparison? I think it's pretty obvious that a macbook scores a much higher performance than an iphone. Also as safari is completely optimized for mac and ios it's not a surprise that the benchmark results are better?
I am all for mobile first and it's typically how I design, but mobile drag and drop on the web is hard to come by. Even when it's done I don't think I've ever seen it done well. Might be something to mess with when I'm bored next. Anyway, the reason I responded again is I think it's odd you are putting 40~ ahead of 60~. Unless toggling the behavior is too complex or your use case wouldn't benefit much from dnd I don't understand how you can feel your stance is correct from a business perspective. Can you elaborate more?
I created new orm or better ogm for neo4j called neo4-js. It's specifically designed to get started fast, extend the data model easily by yourself and with good flow type support for static typing (even with relations, which should give you awesome autocomplete stuff) :) Maybe you wanna have a look at it, https://neo4.js.org
I’ve done an angular2 drag and drop demo for work and i did’nt manage to do the animations with display flex
Timeout based tests? Jeez... 
&gt; AbridgmentJS : prettify your sitemaps using D3.js That... that is fucking comic gold. 
This is a gold mine. &gt;KingdomJS : like MooTools, but for React components I'm intrigued..
Sorry for noob question but what does "modules" actually mean here? The back end code should be split into multiple files and then those are included with require("path/file.js") as necessary? Or there is more to it than that?
Well... assumptions have to be verified and in all cases Anyway, reading your comment, I'm not sure you read the article carefully. iOS performance is surprising, U'R browser performance is surprising, and Lineage OS bad performance is also surprising. 
Yes, on a mechanical level it's basically splitting your code into different files and folders, requiring, etc. The critical aspect is not really that, but how you organise those files. Do you follow a principle like DRY, SOLID, etc? What about MVC? Do you know and understand [design patterns](http://www.oodesign.com/)? Etc.
I try not to be negative when I read stuff like this, but ... here I go. This feels like he's blaming a lot of library choices on the language. Certainly a couple of these issues are a result of NodeJS's issues (timeout and ram usage), but the overall list is self-induced trauma. These types of problems does feel familiar to me, with pretty much most languages I've began on, up until I get familiar enough to work with it. It seems like they ran headfirst into a project without any serious senior javascript developer and wondered why everything sucked.
If you have lists of things they need to have unique ID's so you can control what you are selecting. There are a bunch plugins to use like http://mbraak.github.io/jqTree/ that can help.
Plot twist: it's not generating imaginary JS libraries, it's actually pulling them from the dark depths of NPM.
So what if it takes 40 hours? Everyone has to do it and as such is fair regardless of personal toll, no? It's weird to think that a company couldn't ask anything of their applicants to make sure they get the best person for the job, no? You think they should rather just shuffle the resumés and pick at random? &gt; (unpaid work) It's not really unpaid work if the company don't use/profit from the product.
thanks for helping me find out a problem with how people could set the number to extremely large values with the console. now the firebase rules say the write will only be accepted in the value in one more than the current value.
Getting enterprise scale and performance is a challenge in any platform. You certainly can't take random off the shelf libraries as enterprise grade without at least reviewing them, most are simply not at that level in any language ecosystem, not even official implementations in many cases. Personally if I have an api with such high load and which cannot even tolerate a 40 second downtime, then I'm more liable to switch to c than go. Why settle for half measures.
This is right but I would also point out that strategic design of your application - keeping all the really hard, interesting and valuable bits on the server is the most effective way to keep your secrets secret.
welcome
&gt; TheocracyJS : unit test your SVG using JSON Never ever thought the need to unit test my SVG before. I'd love to do it now using JSON.
This got me thinking actually, what if I did an ajax call to my own local server for a "key" which if it matches a variable in a piece of my code then it will execute the correct parameters? Trivial to circumvent but at least my site won't be low hanging fruit for parasites. Your solution makes much more sense but as a noobie with limited skills to implement that what do you think about my idea?
Nice!
i don't want to be reactive and all.. But can't you kind of do those things with TypeScript already?
It's common to generate a token for the client to pass back with each request, for authentication - that's basically what an authentication cookie does for you. If your key didn't change for each user then it wouldn't add much value. What does your application do? What's the secret sauce that make it special? As an example, think about a service like google translate. Their secret sauce is doing the translations, and that happens entirely on the server. The front-end of google translations is like 2 edit boxes, a button, a couple dropdowns and a couple ajax functions - basically no IP of interest or value is exposed. This dynamic, as an aside, is why you see applications with no obvious connectivity requirements reaching for reasons to require a server connection. Think about the last version SimCity, made a lot of people pissed out by not having an offline mode, because SimCity basically plays like solitaire and that's what users expected - but the connectivity isn't for the users, it's for the company to control their IP - because if you never need to go to the server, nothing stops you from just copying the executable... My feeling is that you need to identify some aspect of your application that is valuable to users, a reason for them to return, that you can control on the server - that's how you get people to come back and pay you money - in addition to protecting your IP.
Vector driven development
Yaaaaaaaaay Also the name "puppeteer" is perfect. 
Crap, well I fucked this project up big time. This is the most helpful comment in the thread regarding what I was actually asking. Thank you!!
Just update my lightweight embed plugin https://shobhitsharma.github.io/embedo, focus on making easier embeds and emitting events which keeps code sane. 
This is fantastic! [My favorite so far:](https://twitter.com/JSLibGenerator/status/897752323270868992) &gt; IrradiationJS : like Typescript, but for landing pages
You say "imaginary libraries", I say "soon too come libraries".
Not sure why you've being downvoted. I read the article and thought "meh, this seems pretty standard". 
So there is this appliction which allows you to edit timelines by dragging and dropping them. I have about 100% of the users covered with my current solution ( jquery + touch punch ). Implementing this, which is a bit nicer would lose me the 40 percent 'mobile' use ( mostly ipad by the way ). So I have to fix that part myself. That will take time, that I don't have, for a rather minimal improvement. So I do nothing yet and sit this one out, hoping the developer or somebody else comes with an update soon.
&gt; Had the same exact issue... a bunch of employers each wanting a custom project that takes anywhere from six hours to multiple nights (said so casually as well!!!) to complete. That's a problem I have as well. They need time to review multiple applicants, but the applicants usually are more limited in the time to do every interviewers' work. If one company asks you to do a coding exercise I feel like "all right whatever it's probably gonna take one afternoon" but when multiple companies ask you, now you gotta think, are you gonna be able to put the same amount of effort everywhere? Should you just prioritize and ignore some? FWIW, I have seldom come across whiteboarding/theory oriented interviews in all but some of the biggest software companies. Most everyone else seems to conduct interviews in reaction to bootcamp grads that were taught on rote knowledge of frameworks but not on practical problem solving in a way that is language-agnostic.
This one works well with flexbox 🎉
&gt;They can't know what you are capable of if you don't show it in your code. Your code has to speak for itself. You must also consider that your code could have been reviewed by someone that didn't even know the requirements. &gt;Hey check this stuff some candidate has sent us. &gt;Whaaat? Nope. This guy doesn't even know about React, babel, webpack, etc. It's kind of odd because I do have projects that demonstrate this knowledge on Github where they can click to get to from my resume. Bu I usually ran across the situation that /u/nothing4me had. My code is usually reflective of how I approach things in my last job. Rather I am more "aggressive" when it comes to using frameworks in personal projects but didn't want to risk doing something that might have seen out of place in the coding test, but whoops, I screwed that up anywaays. Oh and by the way, we did *not* use React, Babel, Webpack, etc. at work. Sucks, I know. It was a startup but I didn't feel like I made a big impact on the main product's design or architecture (people would say you can make a big impact in small companies more easily but the correlation isn't always there). I was one of three programmers all working remotely and the app's JavaScript code uses almost all proprietary JS, no 3rd party frameworks, and some jQuery for DOM related stuff. The most experienced programmer in the company, who started writing the app in vanilla JS, lives in a ex Soviet bloc nation, and correspondence with him is thin. I can't get much feedback from him, or really push to overhaul the project code and say "you know, what if we re-built the front end with React and start from the oldest features?" So I do have "hobby experience" (I hate calling it that, it doesn't sound appealing to employers) but no real-job experience where what is considered standard practices in JS today.
&gt; It's weird to think that a company couldn't ask anything of their applicants to make sure they get the best person for the job, no? No matter what the interview process is like, the majority of the work is not 'technically interesting' in the way you are thinking. The number of hours I'd put into a coding exercise also depends on how highly I regard what the company is doing. I will probably put a lot more time into applying for a good department in a hot tech company doing many interesting things, but this company falls a tier or two below that.
I couldn't find anything about WebGL support. I imagine that this isn't possible but hey who knows. Anyone know definitively or has anyone tried?
I've only done this with vue and I'd say its a little awkward if you want to use the websocket from multiple components. The way I ended up doing it was having a separate vue instance that opened the websocket and then used that as a bus in components that needed to use the websocket. Not sure if there is a better way to do this, but its what I came up with that works. 
BotJS : A Twitter bot that comes up with imaginary JavaScript libraries
One of these days it will actually come up with something revolutionary and people will just glance over it and laugh. 
One of the caveats with headless is it's often paired with the `--disable-gpu` switch when booting Chrome. So likely not able to work (and there's no API exposed in the Remote Debugging Protocol)
client? server-serving-a-client-index? I almost always reach for Express.
Meteor. Seriously though, just about every framework out there can handle that. There is no best. There are advantages and disadvantages. Become informed and then make a decision based on that knowledge.
[removed]
V3.js: vector-driven unit tests
No, scripts only and significantly faster than CF. if you know how to configure everything already maybe arc isn't for you (unless you want to move faster)
This is great and I really would love to more about lambda calculus but I haven't found any good longform resources to learn from. Maybe I need to seek out some textbooks.
Most of "bad practice" examples are indeed bad - which no1 uses. var a = new Array(); a[0] = new Object({ x: 1, y: 2 }); A[1] = new Object({ x: 2, y: 3 }); var sum = new Array(); a.forEach(function(item){ sum.push(item.x * item.y); }); the fuck is that? Why even use "bad practice" from earlier? const a = [{x: 1, y: 2}, {x: 2, y: 3}] const sum = a.map(item =&gt; item.x * item.y) 
&gt; Puppeteer requires Node version 7.10 or greater Sucks for those of us hopeful we could run it on AWS Lambda. 
Verifying Valid Vectors
Indeed, I didn't read the article carefully. I mostly had a look at the benchmark results. But I think it would be more interesting to compare the iPhone with a Samsung flagship model...That way the hardware would be at least somehow comparable.
The issue with this discussion is it was started with the incorrect context. You didn't say "I can't switch to this because I already have a solution that works better". You said "This is useless". Big difference. This discussion goes a lot deeper as well. Does drag and drop make sense on mobile for a given use case? All I'm saying is calling this useless is pretty presumptuous and every idea has to start somewhere.
Thanks I was looking for a headless chrome node api yesterday but did not find this -.- so I settled for selenium. But this looks awesome
Hmm, unfortunately I don't know – haven't tried out TS. But I would be surprised if TypeScript had first-class support for React as I imagine the only reason Flow has it is because they are both Facebook projects. Maybe someone who is more familiar with TypeScript can correct me.
Wonder how my three.js software rendering fallback will do!
Maybe http://bridge.net could help with something here.
We at Senelda offer the Best Javascript training in Chennai. Senelda provides excellent Javascript training in Chennai from experienced professional. 100% job assurance.
You can checkout Chromeless then!
If you're set on running it in Lambda, you can try out: https://github.com/graphcool/chromeless If you're set on using Puppeteer, you could try running it using StdLib (https://stdlib.com). We support the latest version of Node (full disclosure, I'm a co-founder).
Web Components are exactly this - you just extend HTMLElement. The benefit here is that your element is compatible with the browser itself, the parser and document.createElement() can create it, you're notified of connected state to the document, attribute changes, etc. For DOM updates you can just set innerHTML, but for more efficient updates you can use something like lit-html, which uses template literals and `&lt;template&gt;`: https://github.com/PolymerLabs/lit-html it's &lt; 2k gzipped I'll give an example that's like /u/senocular 's, but that would work if some other framework created the element as part of a template, and only the part of the template that changes. import {html, render} from 'lit-html'; class MyComponent extends HTMLElement { constructor() { super(); this.attachShadow({mode: 'open'}); this.needsRender = true; this.label = 'Counter'; this.count = 1; } get label() { return this._label; } set label(v) { this._label = v; this.invalidate(); } get count() { return this._count; } set count(v) { this._count = v; this.invalidate(); } render() { return html` &lt;h3&gt;${this.label}&lt;/h3&gt; &lt;div&gt;${this.count}&lt;/div&gt; `; } invalidate() { if (!this.needsRender) { this.needsRender = true; Promise.resolve().then(() =&gt; { this.needsRender = false; render(this.render(), this.shadowRoot); ); } } } customElements.define('my-component', MyComponent); now either use the element in the document, call document.createElement('my-component'), or new MyComponent(). You can update state on an instance just by setting a property: `c.count++`, and it will re-render. This works in latest Chrome, Safari and Opera with no polyfills, and IE11, Edge and FireFox with the Web Components polyfills.
Definitely will. Great work so far!
Btw, I guess no plans to support Apex (versus/in addition to Serverless) for Lambda deploys?
I think it would be interesting for sure, anyway I don't own a recent Samsung. Interestingly you were mentioning my MacBook (high end) vs iPhone (quite low-end model) test, and the results show that JS engine speed on iPhone is close to the speed on MacBook...
Where is it that you offer JavaScript training?
Is it something like Upaal you think of? http://www.uppaal.org/ Can be used for complex model-checking.
My friend in Chennai is interested in Javascript training. It isn't clear from your spam, do you offer anything near him?
No, not at all. Something like: https://github.com/fschaefer/Stately.js or http://machina-js.org
what the web site
It pretty much has to be a css style that is hiding it. If you click on the button element in the inspector and scroll through the rules that are being applied to it you'll probably find something there. But if you don't see anything, just brute-force it. Click on the button element in the inspector, then inside the element.style {} block do display: block; height: 100px; width: 200px; background: black; position: absolute; z-index: 10000; If that doesn't work, go back and put !important on each of those styles z-index: 10000 !important; ..... ..... If it still isn't there, it can only be because one of it's parent elements is being hidden somehow. Try a similar approach on it's parent, then the parent of the parent...
Brilliant. Figured it was maybe something like that. Thanks
A mixture of very basic and just plain wrong advice - avoid.
You may want to look into redux which is based on [the flux pattern](https://cdn.infoq.com/statics_s2_20170816-0412/resource/news/2014/05/facebook-mvc-flux/en/resources/flux-react.png), it is a perfect fit for complex conditional ui and it has bindings to pretty much everything. Redux manages state, the UI simply reflects it. the fsm pattern is easily realized with it, there are also [helpers](https://github.com/mheiber/redux-machine), though i don't think you need to adhere to any of it at all, just use redux as it is.
it's like they didn't even test the code snippets they're showing
Are you sure every function of lodash (groupBy, difference, flattenDeep - just few quick examples) have some short representation in vannila ESNext?
Some methods can be replaced with vanilla ES6/ES7, but most of it not. Using it a lot, It's very handy. :)
IMO its a must have when working in bigger teams. It avoids a lot of duplicate code. In addition, its super tiny. Imagine every person writing their own debounce or throttle function in their components ;)
As far as I know there is no 'native' way to deep clone objects that is as simple and efficient as lodash's merge with an object literal. Object.assign does not deep clone and JSON.parse/stringify is a horrible hack. So you're left with either using flat objects which is impractial, your own implementation which is ridiculous/stupid or a battle tested library like lodash. Example usage in a redux reducer: import { merge } from 'lodash' function reducer(state, action) { let newState = merge({}, state) return newState }
imagine all the defects coming from writing your own groupBy, debounce, throttle, ... functions
Low quality article by someone who is obviously a JS beginner.
how to fire fake click event after page load not working angular 2 ..
It has been long since it was more than css
It doesn't mention top-level await :/
Flash is dead.
Of course everything that can be done in lodash can be done in ES6+ (and even ES5) - after all lodash itself is coded in JS. But not everything can be done as easily or concisely. And the fact that lodash has treeshaking built in (meaning, you import only what you need) makes it still a feasible option.
Ah okey. That's indeed quite interesting!
This only launched yesterday at 9am PST. So wasn't in search indexes yet and only really spreading by word of mouth still.
9am PDT happens when this comment is 5 hours and 34 minutes old. You can find the live countdown here: https://countle.com/Vig34984f --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Atom recently merged the .mjs file type, should be in next update I believe : https://github.com/atom/language-javascript/blob/65c77cc1225a2d6963c9cd5599d17a96af16aea5/grammars/javascript.cson#L14
https://github.com/thejameskyle/the-super-tiny-compiler
Typescript works great with react. No idea why Facebook suffers from not invented here syndrome.
I think you read too much in my statement. I said 'pretty useless' and 'most cases'. But I can see how it comes over stronger then I meant it, so iftfy
Object.assign 
This. The TypeScript team is doing such an awesome job that they were able to release first class support for React prior to Flow, dispite Flow being from Facebook.
What does this mean to PhantomJS?
I don't use it for chain, clone, each, map, filter, or reduce. I still use it for at, has, chunk, groupBy, uniqBy, intersection, flatten, cloneDeep, debounce... there's no reason not to use these and others if you need what they do.
And shadowbaned.
It's 3y/o lib, just saying
Object.assign(/u/shanita10, glasses)
Development has already pretty much stoped 
Maybe you could just whip up a framework that manages a *virtual* XML document in the background?
One point in favour of Sequelize: with some jiggery-pokery, I was able to get Typescript types working properly for my models. Better yet, the DTOs inherit from those types - and the same DTOs are used by the server and the Angular front-end. Anyone know if this is possible with Objection?
It's good to have competition and switching to flow is less overwhelming because it fits into the Babel ecosystem really well.
Flow had first-class support for React before TypeScript. This blog post isn't about adding typing support for React (which it has had forever), but it's about improvements/additions to it.
Refer ES6 Coding standard and underscore.js documentation for more reference.
Ah, my bad, recursive assign. 
[As soon as the dev from PhantomJS heard about Chrome Headless he pretty much said he was no longer to support it as it was going to become obsolete](https://groups.google.com/forum/m/#!topic/phantomjs/9aI5d-LDuNE). He was working on his own and said it was "a bloody hell". Plus Chrome Headless used way less memory PhantomJS was awesome while it lasted though. I wish maybe that someone wrote a lib to make it easier to port your old PhantomJS script over to Puppeteer
This is the main reason I ended up going with flow, I literally just needed to add one extra `babel` plugin and everything was set up. Aside from that, I just felt like it fit more with the JS community's paradigms. This is just my opinion, but TypeScript seems to have a substantial portion of its userbase who came from languages like Java or C# who didn't want to learn JS and just went with TypeScript from the get-go. A lot of code from those folks seem to be overly verbose OOP paradigms. When you google `express typescript server`, the first link shows code that looks like this: "use strict"; import * as bodyParser from "body-parser"; import * as express from "express"; import * as path from "path"; /** * The server. * * @class Server */ class Server { public app: express.Application; /** * Bootstrap the application. * * @class Server * @method bootstrap * @static * @return {ng.auto.IInjectorService} Returns the newly created injector for this app. */ public static bootstrap(): Server { return new Server(); } /** * Constructor. * * @class Server * @constructor */ constructor() { //create expressjs application this.app = express(); //configure application this.config(); } /** * Configure routes * * @class Server * @method routes * @return void */ private routes() { //get router let router: express.Router; router = express.Router(); //create routes var index: indexRoute.Index = new indexRoute.Index(); //home page router.get("/", index.index.bind(index.index)); //use router middleware this.app.use(router); } } I really dislike the whole methodology that literally everything needs to be in a class, and I see a lot of code like this from TypeScript users. I just want JavaScript + types without the whole Java-like baggage, which is where I prefer Flow's ideology and most of Flow's userbase seems to better at using more "JS-like" paradigms. This is just my subjective view on it to be fair.
What perfect timing. I was just about to start using [Chrome Remote interface](https://github.com/cyrus-and/chrome-remote-interface) which was recommended by the chrome team via their documentation. But now that an official tool has come out I'll probably use this. I like that it comes with its own install of chromium. CRI needed you to already have Chrome installed and start it up before running any scripts.
I was just kidding, jesus OMG people the domain name doesn't matter. Even if it was three-eyed-raven-sucks-cock.com-you never judge a book by it's cover, you always click the link and read before downvoting. 
Is there any good drag n drop like this for angular 1.5?
Hi /u/Seneldait, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
thanks for spoilers, asshole.
it now supports webgl, https://bugs.chromium.org/p/chromium/issues/detail?id=617551
Other great methods: get, set, pickBy, merge
Yep! Postal.js * https://github.com/postaljs/postal.js * JavaScript pub/sub library supporting advanced subscription features, and several helpful add-ons. Machina.postal * https://github.com/ifandelse/machina.postal * machina.js plugin that auto-wires FSMs into postal.js (message bus) machina.js * https://github.com/ifandelse/machina.js * js ex machina - finite state machines in JavaScript They all work together wonderfully.
They certainly don't all, though ES6 makes it a heck of a lot easier to recreate them: in the end their basic functionality isn't that complicated. What lodash brings to the table is a more standardized api than one you'd roll on your own (all the methods have extended or overloaded arguments that work in a predictable fashion, it's well thought out) and are extremely well tested. Even if you're a JavaScript wiz, that saves you a lot of time and headache. Lodash is probably going to be more performant than your first try at writing these methods, as well as faster than some native methods. I don't think this is as big a deal in most cases: optimization is fine, but it's an added bonus on top of that real win: standardized, well tested utility toolkit that's well known and understood.
What do you mean by treeshaking built in? My understanding is that it's built so that you can import individual functions, but that's not treeshaking per se, it's just a great packaging set up.
For some reason Ted Talks (just tested, I know it's not officially supported) caused the page to be reloading to the Ted Page.
I don't use lodash anymore, ramda is the successor.
This project demonstrates an AWS-powered serverless build, test and deploy pipeline ft. multiple environments. The /src directory contains a React/TypeScript/Webpack-powered web app that is served from S3 with CloudFront as a CDN and Route 53 for DNS. The /infrastructure directory contains all infrastructure and deployment steps defined as code (Terraform and bash scripts). CodeBuild and CodePipeline take care of building, testing and deploying the project. All build logs are stored in CloudWatch. CodePipeline accesses GitHub using an access token. When using CodeBuild to build, test and deploy each project, information about the build environment must be provided. A build environment represents a combination of operating system, programming language runtime, and tools that CodeBuild uses to build, test and deploy - A.K.A. a Docker image. I maintain build environments for the programming languages and tools I use frequently - e.g. docker-node-terraform-aws. The build commands and related settings must also be specified in a buildspec declaration stored at the root level of the project. Because a buildspec declaration must be valid YAML, the spacing in a buildspec declaration is important. If the number of spaces in a buildspec declaration is invalid, builds might fail immediately. A YAML validator can be used to test whether a buildspec declaration is valid YAML. See AWS CodeBuild Concepts and Build Phase Transitions for further information. This project can be updated as needed to build many different types of project. If a project needs to build Docker images/interact with the Docker daemon the Privileged flag under advanced settings of the CodeBuild project in AWS console must be set to true. This can also be set to true using the privileged_mode variable of the build-pipeline module. The buildspec declaration must also start the Docker daemon and wait for it to become interactive. Check out https://github.com/jch254/buildpipeline for more details. 
what's the meaning of #sloppy? do you have a bit of a reference index anywhere to understand the output?
I've been using nightwatch for a few weeks. I hope they add this api an option soon.
&gt; PanaceaJS : like Browserify, but for SVG Heh.
Yes that's what I meant. It's the same effect as tree shaking, but built in by the way the packages are set up.
Hey! I am one of the creators of Ugnis ready to answer questions if you have any.
If you're not too dead set on using protractor and stuff, I'd avoid it all together and use the Selenium plugin for .Net. I use it at work and it's pretty decent. The biggest benefit is that it's all in C# so chances are you'll have an easier time getting your team to use it (or if it's just you, you'll have less of a learning curve).
yep, playing with it now. so do you have someone working on visualising execution path? I'm already seeing this as an awesome potential to help me map my code paths and create unit tests. Love the 'hack-ability' too, kind of a firebug or network sniffer for javascript. I've only recently been thinking about this sort of thing, so I don't know if other similar toolkits exist, but this has made sense to me immediately and good timing.
I wish I knew about all this stuff when I was looking for an ORM. I ended up using Sequelize as it was the most popular thing that showed up when I googled JS orm's and I wasted too much time trying to get it to work.
I'm 25 and sometimes my tooling is very much old-school. I use native connectors for my database engine ; postgres mostly. And a makefile rather than npm scripts, for instance. Sometimes, the simplest solution is the best solution. Overengineering is a trap that a lot of people fall into. Used Sequelize once, never EVER used it again after I had to migrate from sequelize to Knex.
You made my day. Perhaps also my week. Thanks!
all of them seem self explanatory except I don't know what 'PROGRAM' would report on. 
TypeScript user for 9 months, full-time, and my experience is that this is not at all indicative of a general attitude of TypeScript users at all. There is no TypeScript ideology, it is just JavaScript + really pleasant types. Using it with VS Code is just glorious. 
Lazy evaluation. Chaining JS's built-in array methods creates new arrays for each operation. JS's built-in sort and splice also mutate the original array which is annoyingly inconsistent.
There was an [interpreter tutorial](https://www.reddit.com/r/node/comments/6u80be/programming_language_from_scratch_3_easy_steps_to/) posted to r/node just this morning
For sure, totally agree about the simplicity part. I usually avoid ORMs if I can but I was trying to goof around one weekend and add it to an existing node project and I felt the learning curve was a little high. I'm sure it would've been easier if I had started the database from scratch; but that's beside the point. I can drop Hibernate in a project and get it running in an hour tops.
It was a really detailed article implementing the scopes and hoisting and everything and explaining the why and the how I will keep looking as well and if I've found something I will let you know 
The editor demo prevents use, asking me to rotate my device, but rotating a 24" monitor isn't very practical, nor does it have sensors for orientation change. I would guess you are checking the ratio between width and height, probably not the most accurate way to detect if the user is using a mobile device.
Had a quick look at San Escobar - I think where I'm finding the main difference is Iroh is wrapping everything in a very tokenised way and automatically exposing properties and events of the wrapped 'things' (functions, calls, variable assignments etc) which I can just check the values of and take action accordingly. For San Escobar I would probably use for object mutation tracking/logging as a specific production functionality, but that might just be my lack of imagination or seeing usage pathways. Iroh has immediately jumped out at me to use for visualisation/mapping of code flow and debugging/testing.
VictorJS: a web component to containerize your V3.js vector-driven tests.
Thanks - I'm not really proficient enough at coding to contribute to the git, but I'll definitely share what I'm doing - As far as I'm concerned, past the basic principles, seems like magic to me. If I have suggestions/ideas should I put on them on the git as an 'Issue'?
I would do that however we are moving over to a new tech stack for a full rebuild that utilizes angular2. their priority is the automated testing library im writing tests that. but they want it to work on the legacy app, and it does perfectly fine. however the mock data setup they already have uses C# and it's not easy to give it mock data using purely javascript.
 http://imgur.com/rt8BEUe Just a boring output of the function names and parameters to boxes down the page. I'm thinking I'll make a sort of network diagram with the nodes being the functions/property calls and link them with directional curves to show flow back and forth. A key will be seeing if I can identify the anonymous functions being passed around a parameters and have those reflected somehow as nodes too as they are passed into a function and then called as a callback.
Yeah I saw that. For the time being, I ended up using this as an excuse to try out VScode :)
[removed]
Sorry about that, your assumptions are correct, should be fixed now. It was just a css media property (orientation:portrait) without any regard to the size of the monitor. 
Checked Quokka website - it does sound similar with intent/goal but I'm already a bit stuck wondering about quokka files, node.js, editor plugins etc. I'm basically using Iroh like a javascript linter - chuck in normal js code string, run the output. Verbose logging pretty much out of the box and no special environment setup.
So I went to https://ugnis.com/editor/ with my correctly oriented device, a garden variety iPhone on stock browser, and see nothing but a logo. No further info, sorry. 
The problem was more about a forced unskippable warning than the method of detection. For what it's worth, that still doesn't work for me as I have two browsers snapped side-by-side on a 1920x screen, which gives an outerWidth of 960px, but innerWidth is 950px, so it's still matching the 'wrong' media query. That said, virtually all sites get their breakpoints 'wrong' and render me the mobile version, so ideally it just needs a way to skip the warning or failing that a better error message for those not using rotatable computers.
any chance someone has made a working karma launcher for this?
The article is alright but the fact that you confuse asynchronous and concurrent is a bit aggravating... You can still lock up the thread with callbacks, because when the callback function starts executing you're now waiting on it to finish, very simple example &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; window.onload = function () { const btn = document.getElementById("1") const btn2 = document.getElementById("2") const d = document.querySelector("div") btn.onclick = () =&gt; { while (true); } btn2.onclick = () =&gt; { d.innerHTML += "&lt;br&gt;added asdf" } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="1"&gt;click me&lt;/button&gt; &lt;button id="2"&gt;asdf&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
Got it. Ugnis, being the visual editor, is pretty broken when not given enough space, but the current warning is definitely not a good one. I will make the warning less obtrusive as soon as I can, thanks for the feedback. 
[Here's an explanation on StackOverflow](https://stackoverflow.com/questions/15349733/setimmediate-vs-nexttick).
Sorry, Ugnis is really not designed for mobile yet, displaying all the logic requires a lot of space. I will try to make the warning less obtrusive and run more tests on smaller devices. Thank you for your feedback.
&gt; with a TON of frustration trying to make the terminal dashboard work on the incredible variety of terminal environments, led me to create an Electron, web-tech based version The number of environments in computing is too damn high. Someone generate the meme.
This is so cool! I have always wondered if I could use a serverless deployment architecture. How do you see this tool comparing to Jenkins? Definitely want to play around with your repo at some point but I'm curious how you see it in comparison.
That's a [typescript](https://www.typescriptlang.org/) extension.
how to search petabytes across a hundred thousand servers in less than a second with only 1 line of code: http://lmgtfy.com/?q=f /rant
You are very welcome. Your appreciation is appreciated. And I doubt you fucked anything up. Most side projects have only the slightest chance of making any money or even being finished. As long as you didn't take a big debt in the name of your project, then it's fine, it's just another learning another experience. I mean, what would you be doing with your time otherwise? There's many less worthy ways to piss your life away. I re-read your original post - as several others have noted, trying to sell client-side web assets by itself is the hard way to make money. But the discussion makes me want to rant about the value of marketing and branding. Young software developers of the world: don't underestimate the power/value of branding or the marketing team. There's tremendous power for a business in being able to move peoples' minds. Technical competence means very little if no one is buying your product. The type of assets you're developing gain the most value in the context of association with a product or service, something tangible the user finds valuable. And once that association is made, someone else stealing (think propagating) the assets doesn't hurt you, and it might even help. At my office we have a dedicated UI/UX specialist who does all the initial design and css work - maybe that's a good role for you.
I knew this day was coming 
Is it available for linux platform? all i see is mac and windows.
Writing code like this has nothing to do with Typescript itself, all of this (except type annotations of course) is pure ES6. This is just people trying to replicate what they've been doing in Java for 10+ years in Javascript. Typescript has had some pretty fantastic additions this year in its type system to try and represent the patterns JS developers use. Stuff like `keyof`, mapped types, primitive literals aren't made for old and boring Java-like code. All the improvements they're making in the type system are driven by that need. And about these newest additions to Flow, all of this was already available in Typescript, most of it since the feature launched in 1.6 two years ago, and the rest pretty recently (children typing, optional State type).
When any loser who once tinkered with node started putting it on their resume and it started preventing me from being considered for jobs. Real answer: when I felt competent to build a rest API, use SQL, docker, and understand scalability
* ability to make an efficient database that supports the database doing as little work as possible to support the project needs * ability to do back-end code that bridges the front-end and back-end. This code should be easily readable. * ability to make a front-end that has all of the features needed for the project. * ability to design a page that has a great user experience and looks good. * you don't have non-idiomatic code, you use linting, you know what a test is and how it could help you. You don't actually need all of those skills to be top notch. But you better be able to google to figure out problems when you run into them. Or figure something out at least.
came here to say this. you're doing the lord's work.
Haha, this is what prompted me to ask. The company I work at hired a new employee who is "full-stack". I always felt that I need a mastery of multiple backend technologies before I can say I'm a full-stack Dev. Upon looking at his code and him telling me that he's only worked with node on a couple small projects, I realized if he is considered full stack I should start asking for a promotion / looking for a different company. I've been working with node for a year and php for 3 years. I primarily do front end though.
Are you looking [here](https://github.com/FormidableLabs/electron-webpack-dashboard/releases/tag/v0.1.0-beta.2)? Specifically at `webpack-dashboard-app_0.1.0-beta.2_amd64.deb`. Isn't `.deb` for linux?
Visual editors aren't anything new, Delphi has been around for 20 years for example.
Stuff like this is why I love the JS ecosystem/community. This is very cool!
[@JSLibGenerator's latest tweet](http://i.imgur.com/E1dRTzZ.jpg) [@JSLibGenerator on Twitter](https://twitter.com/JSLibGenerator) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
7+ second page loads? The content on that thumbnail looks like it should take 700ms tops. I would suggest trimming back on the 5mb initial payload to get closer to the 300% improvement realm that page is capable of. I checked out the rest of the public facing site and noticed page load times of 11-16 seconds. That's not really acceptable for SPA's, let alone an e-commerce site. I recommend grabbing a second cdn url to increase the number of download channels for your thumbs and/or serving cached sprites instead. And something is very wrong with your CSS bundling as it created 176 duplicate blocks of font-face declarations and 532 duplicate blocks of keyframe declarations (among other problems with the css rules that could be greatly improved by relying on the cascade part of css.) I saw 6 web fonts downloaded but it only looked like 2 were in use. While those are ultimately cached after the first page load, caching only goes so far when you are downloading/mod-checking 250+ resources to a client. The page weight on mobile is so large, that ios wiped out all of the off-viewport content after I locked my iPhone6 and opened it backup again. Just a giant 5k vertical pixels of white space. I would probably drop the number of results down to 20 or so as well, or at least give the end user the option to do so as a quick stop-gap measure until you get the time to improve the other issues.
Webpack-bundle-analyzer would be a great addition to this. Kinda like the fish eye but I feel it gives a better overview.
but couldn't you just replace/transpile this: setTimeout(f) into this: setTimeout(() =&gt; { f(); }); ? or more universal: foo(bar) becomes foo(function (...args) { // spying code here... return bar.apply(this, args); }) ? (although this would require static analysis also - because you would have to determine if identifier `bar` is a function. Although In trivial cases like `setTimeout` callbacks it would be safe to assume that `bar` is a function). Or maybe dynamic analysis would be sufficient. For example if you transpiled this to something like this: foo(spyThing(bar)) and spyIdentifier would be just plain JS function called in runtime: function spyThing(thing) { if (typeof thing == 'function') {....} else if (typeof this === 'object') {...} } so the exact type would be determined by running special function in run time, and specific spy would be created.
I knew this day was coming for React. I think for the React/Redux/Webpack/GraphQL stack there is a good chance a designer could use a WYSIWYG to build large-scale, complex apps without ever needing a developer. It's an old promise of visual editors but this stack could have legs.
IMHO, the "full stack" developer is a unicorn. The skill sets necessary on each end are different. There's overlap to be sure, and most experienced developers have some skills on front and back end, but the _true_ full stack developer is rare indeed. I think the best strategy is to hone your skills on the part of the stack that you enjoy the most,keep yourself abreast of developments in the stack as a whole, and seek employment that is going to work to your strength rather than fit square-ish pegs in round-ish holes. Companies looking to hire "full stack" developers are just being lazy and hoping to get two employees in one. As someone who regularly interviews people for programming roles, there really is a dearth if talent out there. If you can demonstrate mastery of one discipline or another, you're far more hireable than the multitudes who are running around with hazy knowledge, spreading themselves thin trying to be generalists. 
It's funny how open the market for browser automation is. Everyone needs to switch off phantomJS in the next few years and is looking for the easiest option. Sadly, there's probably no money on the line. But you will get your buggy software used by huge corporations for years to come!
Ah Thank you. At that time, Readme had only mac and windows. Now they have updated.
Cool tool for obfuscating malware. /s
This is good point. Although I think static analysis also has place and it can have very good outcome (because people write JS in more or less predictable way, nobody really writes: let a = ((Math.random() &gt; .5) | 0) + 114; window[String.fromCharCode(a) + "e" + "tTimeout"](); (unless it's for some sort of malicious code which tries to obscure what it really does). I think the future of code analysis for JS is both static and dynamic, they should collaborate. One set of tools should provide API for both kinds of analysis. For example it would be possible to get autocompletion within IDE taken from dynamic analysis along with hints taken from the static analysis. 
30 lines of code ^(plus 1000's more lines in a dependency)
How are we already on 4? Didn't 2 come out a year ago?
Only when ML will be advanced enough then yes, probably. Until then, all these types of platforms will just be .NET WebForms all over again. What happens is you try covering all sorts of scenarios and you end up with such complex UIs for building these apps that you would be better off coding them. And when your UI doesn't cover everything then guess what, you will need a couple of consultants for that specific platform to dig into it and make the necessary tweaks. That being said, I really admire what OP and his team have done here, it's really inspiring. If I don't believe in the idea itself it doesn't mean that I don't respect the authors.
Yah.. it's really fucked up the industry. I'm going to start calling myself senior full stack soon enough until I have to go grandmaster fullstack.
One more thing crossed my mind. I think the better approach would be patch the source, not the usage. I.e. instead of detecting foo(bar) (CallExpression with Identifier in it, from the AST perspective) it would be probably better to patch e.g. FunctionExpression/Declaration etc. nodes. Because we know that they are functions: // PATCH THIS function foo() { .... } // AND THIS function bar() { } foo(bar); // NO NEED FOR ADDITIONAL PATCHING and patch setTimeout itself, e.g by putting: ``` window.setTimeout = OUR_SPY(setTimeout) ``` on the beginning of parsed file. So setTimeout is already patched and there is no need for track every use of it. 
Router version was misaligned, so they advanced angular version to get them in step. Also, they are releasing versions more frequently now. I find very little difference in usage between v2 and v4.
I hate headlines like this too. It always peeks my curiosity, which is the point, only to inevitability find out, NO, NO, it's NOT just n-lines of whatever language. It's n-lines with shit load of dependencies. I can't downvote this clickbait fast enough
Cool, I'll have to check it out then
&gt; just think about accessing an object with [] or an array, this could probably solved by using TS or Flow, but I'm not a fan. On the other hand some arrays can be determined by inferring, e.g. const a = 42; const b = a + 40; const arr = [a]; arr.push(b); such code is almost static so it would be pretty easy to infer by calculating expressions and store computed values somewhere. 
When I started writing C modules
Sorry guyz I forgot to check Reddit 😂 Anywayz thank you all for your replies. I will definitely use Lodash from now on rather than coding every tiny function myself 
This is soo true. I am almost full stack. The part I am missing is the artistic design piece. I just don't have the ability to make beautiful sites. I can make perfectly functional sites, but they are just missing that little something in the way of design look and feel. Pair me up with an artistic designer who can make the html and we can do anything. I still put full stack on my resume though. Sorry guys. 
&gt; I could allow them to 'stop/play' execution with a form to mod &gt; variables before continuing.. BTW I saw somewhere (Reddit? HN? GH?) tool where somebody made possible to play/stop code using ES6 generators (actually it was a REPL - where generators kept state of code in REPL). I think it's very interesting idea, but I don't remember a name of this tool. 
Objection provides very extensive typescript typings for it's API: https://github.com/Vincit/objection.js/blob/master/typings/objection/index.d.ts We're rewriting an API from sequelize to objection and the autocomplete in case of objection is just lightyears ahead of sequelize.
&gt; Had a quick look at San Escobar Actually most of San Escobar code is in my imagination. It's imaginary library. This name comes from Polish meme of non-existent Latin American country https://en.wikipedia.org/wiki/San_Escobar It was supposed to be "JS library that not existed before" inspired by tracers for other languages (e.g. Python or Ruby have its own tracers and I saw that there is no tracer in JS) and I made some research, some experiments which involved among others: - creating Babel plugins for patching the code (for attaching spies) - using Electron for debugging NodeJS apps (I don't mean dev tools but making interactive widgets in DOM) - making turtle graphics in JS which highlighted line which was currently running: https://hex13.github.io/tutorials/es6/file - or making my alternative to Redux with own dev tools: https://hex13.github.io/demos/todo/ So San Escobar is really just iceberg of experiments I was doing. I don't develop it actively, but I'm interesting in code visualisation overall so I will probably make something interesting in this area. 
Turtles lay eggs.
I get the top right panel, which is the build progress percentage. Does this project only target modern webpacks? I'm still on v1 currently. Very cool looking! 
Yeah, I'm in the same boat. I could deliver a pixel perfect, cross-browser page - even in IE 6 days. I was doing dynamic, JavaScript-powered, DHTML AJAX sites before jQuery or Sciptaculous and all the follow-ons made it easy. The thing is, I don't LIKE doing front-end work. I like API design. I like information architecture. I like scaling. I like security. I like efficient data access, concurrency, caching, hundred millisecond response times to complex queries. User interaction? Browser compatibility? Progressive enhancement? Responsive design? Pretty designs? Couldn't give two shits! 😂 I DO NOT put full-stack on my resume because I've got the chops and experience to command top dollar as a back-end guy. I can still _do_ front end work ... recently had to do a stint on an Angular project when a contractor flaked out ... But it'd drive me batty if front end work was a significant part of my job description.
Even using lodash's map is better than vanilla map for a large number of use cases. Vanilla: const names = users.map(user =&gt; user.name) Lodash: const names = _.map(users, 'name'); Lodash's version will protect against users being null.
In layman's terms "full stack" is when you can do both frontend and backend. Although this doesn't mean that you can't focus on one or the other. For example after I learned Rails I considered myself a full stack developer because, well, rails has front-end and back-end functionality. In my roles, I've focused more on backend stuff so I put the job titles as "backend developer" on my resume. The term is sort of broad, and not any kind of standard qualification, because there are many facets of backend and frontend development. For example, some companies wouldn't consider you a capable backend dev if you can't do algorithms and systems programming. Some companies wouldn't consider you a capable front-end dev if you didn't know data visualization or use the latest frameworks and build tools. So, "full stack" is kind of a cheap term. Nobody gets hired just because they're "full stack", unless maybe they're a freelancer working with totally non-technical clients who don't care about the stack you use. Rather, people look at the specific technologies you have experience, and what kind of things you've accomplished with them.
Thanks!
You can't really prevent someone from creating an identical-looking site. However if you could find the site and prove that it's a near-clone of yours, you could get the law involved (hiring a lawyer maybe, but also possibly contacting law enforcement yourself). 
i think that in the future, programming will be more ubiquitous. It will probably be introduced to middle school curriculums at some point. already young kids are using tablets/phones. So, yeah, the average JS dev's wage may go down. 
lol, i must have been too tired to be that excited last night. i woke up this morning and thought about it more clearly and im not sure how I could pause execution and still allow them to work with a form. whoops! a bit too eager and imaginative before properly thinking about it. :O
&gt; And about these newest additions to Flow, all of this was already available in Typescript, most of it since the feature launched in 1.6 two years ago, and the rest pretty recently (children typing, optional State type). I would still argue flow has a better dev experience for working with React, TS has issues like [this](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11640#issuecomment-323140411) which can get pretty annoying. Edit: Also, it seems that typing React children with [TypeScript isn't very sophisticated](https://twitter.com/PipoPeperoni/status/898258186376892416)
Thanks, any criticism is welcome and I see where you are coming from. Visual programming was a joke for so long, that it's totally fair to be sceptical. Ugnis end goal is to be powerful enough to write the editor with the editor itself, so I wouldn't say that it lacks power to build complex UI. It's more that text is probably the best medium to express a complex function. And that's actually the fallback that we use - any logic in Ugnis is written like a Pipe from functional programming. Ugnis has nothing visual about logic. You can think of Ugnis as a wonky way to write React+Redux, but in return we can use the visual part to show which component uses and changes state. Also, we remove the boilerplate and ensure type-safety in a way that only a visual editor can - by preventing errors in the first place. On a side note, we have experimented a lot with ML for programming and it doesn't work for the same reason why google translate fails to translate any complex sentence. Statistical models cannot understand recursive logic. Until we have a true AI, we don't have to worry about our jobs being automated. 
Running any code that you did not write/send to the client yourself is *usually* a terrible idea. 
Undo redo would be great.
I consider a full-stack dev anyone that I can say 'Let's build this project/idea' and know that they can help with any part of that process. They might not *know* the process/code/language/etc but they can *jump in without me holding their hand*. For instance, my old lead dev was a fantastic FE and messed around with PHP/BE stuff. He and most people at his skill level claim to be "full-stack". However, I never felt comfortable having him jump in any phase of a project because he would be out of his element outside of FE. I contrast, we had a BE developer that just kiiiiiilled it on every project we gave him. No matter where we put him in the stack, he solved the problem and then helped others with theirs. To me, this kid is a full-stack dev while the lead dev is just a senior FE. When did I start calling myself a full-stack dev? Once I figured out that coding was all input-&gt;output with a few functions in the middle.
If you are trying on a desktop, ctrl (cmd on mac) + z does work. I should probably list the shortcuts in the readme. Thanks for the feedback!
I prefer Flow because it is JS that just so happens to have type annotations. This means, like others have said, I just add a babel-plugin to clean it up, like I do for the other 'syntax' errors I get with `object-rest-spread` and `class-properties`. Typescript to me always felt like I was buying into a new language and its whole ecosystem. Which might be great and even better than Flow but the initial hurdle of setting up/learning/etc over adding `transform-flow-strip-types` to a `babelrc` file isn't worth it to me.
If you are not using a Debian based distro, you will have more luck downloading the AppImage version.
Now i need a *third* monitor.
And I'm here still using my laptop screen with every full app in fullscreen. Just alt-tabbing like a heathen.
&gt; Everything that can be done in Lodash can be done in ES6/ES7 &amp; ESNext. Since Lodash is written in ES5, this is a tautology. Furthermore, 100% of everything any JS library can do, past, present, and future, can be done in JS, because they are written in JS. But if you are thinking the helper functions of ES6 are sufficient equivalents of all lodash functionality, you are sorely mistaken. Mapping over objects, recusively merging objects, unique id generators, and many other utilities have no direct, built-in equivalents. There are also performance concerns due to the requirements of the spec's edge cases that a library like lodash need not conform to.
Wish I could upvote this more times. Recently left a (very) large media organisation where this BS was rife. There were designers adding "full stack" to their LinkedIn profiles because they'd successfully downloaded WOS portable and changed the header image in a wordpress theme. I worked the PHP / MySQL side of town for a dozen years and almost totally front end for another 5 years after that... and don't consider myself anything like a full stack dev. Senior... sure... I'll take the salary package if you want to call me that. :D ;) 
In general, you should actually time these using test data. It's not too difficult. I'd guess the filter is faster or same.
Yet another option :) // Soln 4 let result = data.reduce((hash, item) =&gt; { hash[item.type] = hash[item.type] || []; hash[item.type].push(item); return hash; }, {});
I get an error when visiting your demo with an Adblocker on, and none of the page content is visible (`opacity` is stuck at `0`): Uncaught TypeError: Cannot read property 'nextSibling' of null at demo.min.js:2 at Array.forEach (&lt;anonymous&gt;) at c (demo.min.js:2) at demo.min.js:2 at demo.min.js:2 
Because it's written in python?
node-gyp wraps [gyp](https://gyp.gsrc.io/), which is written in Python.
I have a lot of respect for the TypeScriot and VS Code teams, but this seems rather a not that exciting version =). I also understand that after you reach stability, it's kind of hard to come up with very cool ideas. Keep up the good work though.
The first rule of thumb in optimization is that generally speaking, you should not be optimizing code unless people are complaining that things are slow. The second rule of thumb is that you should follow the Paretto principle (i.e. pursue largest gains for the smallest efforts). For example, did you compress your images first? Are you serving min+gzip code? etc. The `filter` vs `forEach` thing is very very very low in the priority list for potential perf gains, especially if your checks are cheap and your collection only has a few thousand items. The third rule of thumb is that *if* things are indeed slow, and there are no better optimizations to be made, you should benchmark candidate solutions yourself.
I'd prefer to blame summer vacations and stability fixes if we're evaluating by the feature set. Keep in mind both are healthy for the community and our team! ;) 
You are doing a great job Daniel. Thanks for the reply :)
And thanks for all the fish. I use your projects on pretty much everything I do lately.
Are you learning Java or JavaScript? The two have no relationship.
I thought they were dating...
Java script. Sorry. 
/r/learnjavascript has a number of resources to get you started.
**Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) \#3: [Github Repo with 100+ Free resources to learn Full Stack Web Development.](https://np.reddit.com/r/learnjavascript/comments/5zse5u/github_repo_with_100_free_resources_to_learn_full/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
1. Use the most easily maintained solution first. 2. If there is a significant performance issue with that specific area of the code (greater than 20%), try to optimize. 3. When optimizing, first attempt to remove the code entirely by reconsidering your problem and requirements (code that is never run is always the fastest as it takes infinitely little time to run) 4. If that doesn't work, thoroughly test any alternative that is freasible. Pick the most performant variation.
Got it. Thanks for the help
Meh, I love sites built by people like you far more than "artistic" sites any day of the week. I'm sure they is a place for wobbly buttons, excessive animation, etc, but personally I would take "simple and works" over that any day.
- [Youtube playlist of mine](https://www.youtube.com/playlist?list=PLmZLFWEwl1DQdQ5utizV8FfokpyHOn__Q) - (still organizing things so it's not comprehensive). - https://www.hotjs.net/ - https://www.hacksplaining.com/ - http://exploringjs.com/es6/
I didn't check it myself, but you probably want to use this along with VSCode or any other editor with Typescript intellisense: https://www.npmjs.com/package/@types/chrome
You're a full stack dev
Thanks but Its just similar to solution 2
Thank you, I am just looking for best coding practices to start with instead of starting with the easiest way and later refactoring.
last 2 versions, simple policy.
Can't really answer this in a vacuum. Your website has visitors, they have web browsers, the percentage of people who try to visit your website but can't because of their browser should be extremely small. For some sites, you could totally refuse to support IE without that percentage being too high. We don't know what kind of site you have.
For which browsers? I'd assume Safari, Chrome, IE, Edge, FF, and Opera?
From what ive heard and seen, Vue is a very "happy" and pragmatic solution for UI in ES6. Looking into Ramda was an Eye Opener - not that I would actually use it in production - but you can learn much from its ideas. Production wise I actually liked Maquettejs which is a pretty unknown UI library and also is working fine for ES5 envs. Since some months i am experimenting with Redom, a low level but fast and flexible DOM library - especially cool if you wanna learn, how the DOM actually works. Not library level but Purescript, Dart and Clojurescript are very cool projects too and even if you don't use them in the end, your code will look different when you have seen some of the great ideas behind them. Game changing for me was just to get used to core Promise (actually i like it more then async :)). One last honest recommendation: its not a library or language, but the Yt Channel Funfunfunction is gorgeous with its offer for many js ideas.
I recently glanced at some of those "Compile to Native/JVM/JS" languages. The ones that caught my eye were Dart and Kotlin - Kotlin looked familiar to me, like a mix of Java, JavaScript, and Swift. Dart looked like Java and C++ - and sort of verbose. Any thoughts? Edit: One thing I forgot to mention. The reason I looked at Dart was because of its use in Flutter, which is supposed to be the development platform of Google's new OS.
Other then IE11 there's no point in supporting it anymore.
But I did... that's the point. Maybe the explanation wasn't the best.
Currently reading this: https://www.packtpub.com/application-development/dart-scalable-application-development Sure i think too that its pretty verbose, and i probably wouldnt use it for small prototypes or very small apps, but as the application and team grows the more valuable the verbosity will be. But i dont have production apps in dart so i cant talk from my own experience. What I dont like is redundat code and as of yet i didnt find examples of such in dart. 
IE11+ and last 3/4 versions of Chrome (also mobile), Firefox and Safari (expecially mobile). IE11 is the last Microsoft browser available in Win7
&gt; just looking for best coding practices I see. These days many people will probably argue that `.filter` is considered "best practices". Part of that is because higher order array function are "cool" these days, part of it is because of arguments that `.filter` is said to express intent more accurately, and part of it is simply that it ends up being less code. It also lends itself to more functional-oriented coding styles. for example: const ofType = type =&gt; item =&gt; item.type === type; data.filter(ofType('alpha')); data.filter(ofType('beta')); data.filter(ofType('gamma')); Performance wise, the `.forEach` variation is obviously going to be much faster since it only does half as many iterations/checks. So, from a performance standpoint, the forEach option is better (and a for loop is even faster). There are also plenty of people that think that the procedural-ness of the forEach example is easier to understand as a beginner. So as you can see, there's not a clear cut "best" option. Rather than trying to learn best practices, what you'll probably want to do instead is identify the pros and cons of each option and choose for yourself what trade-offs fit your needs better. If you don't know what your needs are, then, as I hinted before, readability typically is considered to be more important than negligible perf gains. The overarching theme here is that it's more important to learn to think critically than it is to memorize people's current opinions about some aspect of some language. 
The restrictions on `.mjs` and importing named exports are part of [Node's rules](https://github.com/nodejs/node-eps/blob/master/002-es-modules.md). However, the loader allows you to unlock features if you want. The lack of object rest-spread is a limitation of Acorn *(the parser)*. The object rest-spread syntax is still stage 3 and unstable *(it changed just last week)*. That said, Chrome uses Acorn in its dev tools to do things like top-level `await` so an issue [has been opened](https://bugs.chromium.org/p/chromium/issues/detail?id=756006) to see if they would contribute a plugin. 
but...is it built with react?
Have used this in the past, highly recommend.
It really depends on your customer base. For example in the gaming industry, you have newest Edge, Chrome, Firefox - and maybe some Yandex, but that is basically a chrome - this similifies things a lot, since I could basically use every single feature. In another job we catered to students and companies. That meant: We were out of luck, a bit older chrome and firefox, and IE11 besides Edge, which was a problem at times. You basically need to know who you are writing for. In general the advice "Last two versions" is a good conservative estimate.
With AngularJS
Your homework?
I wish. The current version uses snabbdom and handmade redux-like state manager. The whole application works exactly the same as a Ugnis component, just written in a text form. The end goal of Ugnis is to write the editor with the editor itself and drop the current snabbdom version. The current version works like an Ugnis component because it actually was an Ugnis component in an older version, but it got too mind-bending, so we just exported the code and kept on working on the exported code.
Microsoft don't support &lt;IE11 themselves... that's the reason to make that the lowest. After that - support Chrome/Edge/FF and if it's not the latest version, they can be expected to be asked to update. Because... what a waste of time (unless there's some corporate inability to update)
jQuery. :D
I like Vue BTW.
May I ask why you didnt go for react in the first place? Seems to me like this was primarly made for it so why not build it with it? 
wh... why is there php code?
Sorry to inform you but we're only hiring rockstar ninja grandmaster fullstack engineers at the moment
JavaScript is very much an object-oriented language, so some of those questions are a bit weird.
TypeScript is a **superset of javascript** and has *.ts extension. Basically web *browsers **can't work** with typescript* and other supersets files. They work only with javascript (*.js). One of the main **advantages** of js in web is that **all versions of js are supported in browsers**. That's why nowadays developers transpile their code from latest JS standards to basic (read lower) version of JS to run their code in old browsers. Same for typescript. During transpiling developers can get source maps which give an ability to open files in web browsers like in text editors (Visual Code, Notepad++). But on production in most cases this is turned off (because of security demands). And of course you **can't run typescript specific code in web browser console**. I am not sure whether I explain in understandable manner why there are some difficulties to work with typescript. You can read in details why developers choose to work with typescript and are advantages to improve your code writing in my article [there](https://binary-studio.com/2017/08/11/typescript-helps-write-better-code/)
Not exactly. Js uses prototype inheritation. You can't really declare a class, you use functions. The es6 class syntax is only syntactic sugar, as under the hood js still uses prototypes. 
Ugnis is made to export to any UI framework, we just started with an exporter to React, because it's the easiest one to build. So why didn't we just build the same app just with React in the first place? We had no idea what we were building. We knew the result we wanted but had no examples of code building code outside of LISP. As far as I am aware, there are no modern Turing-complete visual programming tools. We had to invent most of the concepts and this process is messy. The current version that you see is actually the 8th one and it is build from various parts of previous attempts. Snabbdom comes from a version where we tried to build Ugnis with Ugnis from scratch. That was not a good idea, it's the same problem as the chicken and the egg problem. It turns out, it's much easier to create an egg making robot, make the first egg and hatch the chicken, thus closing the loop, than to create a real chicken in the first place. After the loop is closed you can discard the robot. The current Ugnis version is the robot, that is still not powerful enough create itself, but once it is, the current Snabbdom version will be deleted. So I don't think it's worth rewriting Ugnis to React, I do miss JSX, but the code is good enough.
The object-oriented programming paradigm covers both prototypal and class-based inheritance. It's a common misconception that classes === OO.
I'm not sure, I understand what you mean but this sounds like you want to provide some kind of widget other people can include on their website? Like the Facebook Like-Button or the YouTube-Player-Embed? Those are usually implement with iframes though. Can you futher explain what you are trying to achieve: - Why would people want to include your script? - With what will the div be replaced? - Is it visible and if so, how will users interact with it?
Didn't know. Thanks to point out
Very useful, thank you for posting this!
1. See nodejs 2. I'm guessing the native language for a mobile OS would have better performance and the api support. But JS can compete. See Cordova or aurelia. 3. Definitely can't compete with c++. But see nodejs again 4. As what the other redditor said, it can be an OO language 
Thank you! I've been using at all this time and didn't realize get existed!
As one of the authors of [js-cookie](https://github.com/js-cookie/js-cookie)/[jquery-cookie](https://github.com/carhartl/jquery-cookie), I can say that if this is implemented by all browsers, it’s gonna be a big step to prevent the Open Source Community from creating and maintaining a lot of wrappers around the existing and inefficient `document.cookie` API.
Ačiū / Thank you! :-)
So it's like WC? ;) 
Are you running mongodb in a replica set? Cause that's what it looks like
Nope but I know JS so well now that I can implement them in a matter of minutes. Anyways how to go about searching a particular function in the Lodash Docs as Idk their names &amp; what they do (some functions are easily understood by their names but others not so easy) ? Also, is it necessary to read Lodash Docs so that whenever I do write some JS functions I remember that it is implemented in Lodash ? I have only used Underscore ( 1 year back for simple maps ) so I dont know how to approach Lodash
Does it import only `merge` function or it imports whole lodash ?
You're welcome! Teaching JavaScript community Lithuanian one framework at a time :D
What `ramda` does better than `lodash` ? I know `ramda` is functional but what makes u use `ramda` over `lodash` or is it just a personal preference. Just curious 🤔
Thanks but I have become so addicted writing everything on my own rather than importing other libraries as the code that I write is just 2 lines 😂 for like Mapping &amp; rest examples like DEBOUNCE I copy paste from STACKOVERFLOW thats the major reason for me ignoring all the utility libraries. I only use MOMENT JS as I hate working with DATES 😢
True ❗
You're on fire! :-D
It has all the goodies lodash has plus it's functional. Also compose is a lot more advanced than lodash chain. U can compose all the ramda functions with it.
I see, great explanation though. I've always wondered why there isn't a great editor out there already but you give me hopes :) On a side note, someone already suggested support for Preact which I think wouldnt be to big of a job to implement as its already working with react. I think it would be a great addition.
Our client is working on Chrome 45 :( Flexbox was very buggy back then. 
Preact exporter should be trivial to implement, but if we were really concerned with performance, we would export to pure JS the same way that Svelte does. Because Ugnis knows how the state is connected with the view, we don't need to export to a library with a virtual-DOM. We don't need garbage collection too, so we could export to WASM, but it's hard to say if that would actually be useful.
Wow i didn't realize there is one already and i made hardcore search i guess! 😟
I fixed few bugs in my theme for VSCode: [C64 Purple Soft](https://github.com/wwju/vscode-theme-c64) 
screenshot? 
I look at client logs to see what their visitors use and base my decision on that. There is never any guesswork involved and I never ask reddit who wouldn't know and is clueless to begin with.
Flexbox has not had any issues since version Chrome 29 according to caniuse
Back when I tried out the terminal version on my 3rd monitor, I was pining for a fourth. One for IDE of choice, one for browser, one for browser dev tools, and then the last one for webpack dashboard
I believe it existed back in 1970s or something ;) But this doesn't matter because they are two different platforms (UNIX command line vs. JavaScript) :) 
We have had people accidentally stuck on version, say, Chrome 33 - and they had no idea that Chrome wasn't updating or why...
I know. This does not change the fact, that it renders it differently.
Don't bother with IE9-it lacks flexbox which is a dealbreaker for me.
No it doesn't. 
Yeah and there will be more comment from another one tell me that stuff like this should be using UNIX command line not JavaScript 😂 I thought publish it here will make things better since programmers are more passionate about js. Anyway, i feel i came up with something new, the name at least :)
Sure. * different return data structure * implicit vs. explicit `type` check (doesn't require a new block for every possible `type` value) * `reduce()` vs. `filter()` (single pass vs. double pass) 
Probably not homework, but this user's posting history is interesting to say the least. It feels like he's fishing for content to use an in article, but I've never been able to connect the dots back to anything.
I've found it very powerful. Being able to define build environments with Docker and not worry about maintaining a build server has been a huge win. Any issues we've faced we have been able to utilise other AWS services (e.g. Lambda) to tie things together. We have over twenty projects using a similar format to this project and it's working well.
You can find a working demonstration in the "example" folder
[HyperApp](https://github.com/hyperapp/hyperapp). Functional, simple, and elegant. You can use JSX.. what's not to like. 
Exactly -- your browser support ends with your user base / demographics. If you're selling reverse mortgages that might be every Firefox/Chrome/Safari version known to man and IE6. But if you're at a corporate office making intranet applications, that might be IE11 or fuck off. 
I've replaced my usage of lodash with Ramda. Function composition, pipelines, and auto-curried functions make my JS incredibly clean, Ramda is one of the best things to happen to my code.
v4 has a much better pattern for dynamic component injection and some nifty speed boosts for complex views. still sucks at something like making a component programatically and other things that are trivial in base js. But no worries you get to use typescript -- who doesn't love using bracket notation for no reason and having a backend dev break your type definitions by adding a new property. Who doesn't want email, discussion, and enterprise bureaucracy as a core part of their language? Just good stuff. hahahahaha we showed those Js devs hoping for a lisp-y experience what-for! 
Generally go towards things like map/filter/reduce before doing a forEach/for loop. If you start to hit an actual performance issue - and you have tackled the other low hanging fruit that might be causing it, then maybe consider breaking a few things out into for loops.
Ford or Chevy, which is the better car to drive?
I’m getting a weird error when trying to load this File not in classpath roots: /#!msg/blink-dev/gU-tSdjR4rA/hAYgmxiHCAAJ 
They switched to a regular release schedule a short while back where they release a new version every 2 month (to better align with VSCode's monthly schedule mostly). So since this version covers July and August, you can bet the feature set will be small.
Hi /u/janeboo, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
How would you say this compares to `ab`?
Ford v1 or Chevy v3?
I lean on [classnames](https://www.npmjs.com/package/classnames) quite a bit when developing with React.
Anything for me is written in vanilla. The rest of it is just trending patterns and opinions that one takes on for money.
Totally! I wish the API for classes in React was a bit easier, but classnames gets use a lot closer. 
I dont think so. See below &gt; rs.status()rs.status() { "ok" : 0, "errmsg" : "not running with --replSet", "code" : 76, "codeName" : "NoReplicationEnabled" }
I love styled-jsx, but that might be a heated opinion. It allows you to style your components in the same place they are defined. And it allows you to "scope" it to just that component. I tend to pull invariant and idx into every project I use. Invariant throws errors when things are in a weird state, and idx makes it easier to pull data from deeply nested objects.
I think they're just calling it "Chevy" moving forward.
How about throwing that into a `gh-pages` branch
As everyone says, it depends on your own visitors, but for us it's IE11, Edge 14/15, and the last few version of Chrome, Firefox and Safari. Latest version of Safari for iOS and Chrome for Android too.
&gt; The part I am missing is the artistic design piece. You recognize that this work is design, but you still don't think you're a full-stack **developer** if you aren't competent at it? User Interface **Design** / User Experience is a completely different profession, and competency at it, or lack thereof, doesn't have any bearing on whether or not you are a competent full-stack developer. You need to be able to interpret/translate and implement what the UI/UX guy gives you, but that's it.
Looks to be a limited clone of [ab](https://httpd.apache.org/docs/2.4/programs/ab.html) with the addition of a DNS stat, time-to-first-byte (TTFB) and time-to-last-byte (TTLB). IMHO, that DNS stat is pretty useless since after the first lookup, it'll be cached by the OS. Note how the max is about 23ms in the sample output but the average is 2.61ms. That's DNS hitting cache. I can see TTFB maybe being useful, but TTLB is really just testing network latency. 
It provides a deeper break down, for example this shows the time taken by the server to process the request, the dns lookup time, tls negotiation time, and the bandwidth. So, just more metrics.
Wow, that's super cool! Angular has css component scoping baked in now, and was wishing something similar existed for React... guess it does.
Why not try setting up a simple page in both. Just to go through the motions.
d3 is a great library for data and illustration. though, it's hard to say what's going to be useful for you without knowing what it is you do.
Short answer: Both. Long answer: Whichever is in demand in my area. **Edit: Good article BTW!**
Mhm, dandy stuff.
Thanks, I genuinely appreciate your insight.
From the [classnames readme](https://github.com/JedWatson/classnames) &gt; Usage with React.js &gt; This package is the official replacement for classSet, which was originally shipped in the React.js Addons bundle.
Yeah, that was when they were ripping the DOM stuff out of React. I just wish the API was a little more integrated. 
Wow that's nice 😃 Never heard of it yet 😂 Gonna check it out now 😉
I've been staying away from d3 for a long time Idk why but it looks a bit complex to me yet it is so powerful
To start out, Edge, Firefox, Chrome, and maybe Safari/IE11. Latest 2 versions. Then run metrics on your website to see what your visitors usually use, and adjust accordingly. Also, much of the world is mobile nowadays, so make sure you support mobile. Top browsers there will be Safari, Chrome, and Firefox.
Lol, being a bit dramatic with the 100 years claim. I'm optimistic in the future and current state of JS, but in 100 years browsers will probably be something completely unrecognizable to current day ones. Maybe there won't even be browsers, who knows.
There's no reason to support older version of Chrome or Firefox is there? Updates are freely available. What's one of the first questions any software support person will ask, "Are you using the latest version?"? "No? You need to upgrade to the latest version and let us know if the problem persists." IE is the only browser stuck at a certain version. I don't concern myself with supporting Safari because it's basically Chrome (or vice versa really). So, again, updates freely available. That said, I follow what's already been said, when my user base drops below N% of a browser, I cut off support for it. But, really, IE is the only browser I do this for since the rest are updated regularly.
This is just an advertisement.
If you need to do extensive work with template literals, I found [`common-tags`](https://github.com/declandewet/common-tags) to be an awesome library. It's essentially `lodash`, but for template literals. Template literals make indentation significant, so if you have: const html = ` &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;/div&gt; ` You would literally have extra spaces in your string: &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;/div&gt; But if you use `stripIndent`: import { stripIndent } from 'common-tags' const html = ` &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;/div&gt; ` You don't have to worry about that: &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;/div&gt; It also has a whole bunch of other utilities like having arrays and codeblocks in your strings, etc. I would recommend checking out the docs.
So is the pre work to determine what level you're at already or what? If it is, then don't sweat not knowing something for now, it's going to happen constantly to you. If they're expecting you to know this stuff then wow that's a weird class. Some people posted some links that contain a lot of other tutorials for stuff that's related to JavaScript and you're going to be confused on what you should and shouldn't be learning right now. What you need to lean first is vanilla, plain, barebones JavaScript, not jQuery, react, angular, or anything else(for now). Because you can seriously mess up your understanding of JavaScript if you jump the gun. Something to know, JavaScript will also be named as Ecmascript, or ES# (e.g. ES6, ES7, ES8) the different numbers are different versions of ecmascript that are or aren't supported by browsers. Currently ES5 is the one that's supported but there are features in ES6 that you're very likely to run into as they're just so nice. However I'd say to focus on the basics for now. Most browsers don't support past ES5. You'll learn all about that heap of stuff. For tutorials, It depends on your learning style, I think codeacademy is a great starting course for learning the basics, it's personal preference I like their step by step structure. I started out by writing down everything I learned and when I needed information I would always go back to my own notes and not look anything up, I think this helped with checking if I actually understood the concepts when I was writing them down and following the lesson. After that you'll want to play around, trying things out, I use codepen.io for quick little tests and ideas I want to run without having to setup a developing space. You can also checkout other people's pens, some people create some insane stuff on there. I also highly suggest getting this, you might be able to find it online, YouTube possibly. But it seriously opened up my understanding of JavaScript to a whole new level that most tutorials don't go over. https://www.udemy.com/understand-javascript/
MaterialUI is without a doubt the worst component library I have ever used. Riddled with defects. 
Okay, so you want to distribute some JS file that others can include on their page and that JS file does stuff ( widget/plugin/lib )? If that is the case, look into how to make a jQuery plugin. It will teach you what you are needing even if jQuery isn't cool anymore.
This actually looks kinda dope. Also, I don't think the author included a link to it on GitHub, so here it is: https://github.com/jaystack/repatch
[here's a very good channel for intro to D3](https://www.youtube.com/watch?v=6dcj3X6Bfsk&amp;index=6&amp;list=PLKSYigPHXmWA1nswF-_-l4jIhhh-D1yJE)
Ramda 
Awesome thank you. It's a "coding boot camp" at general assembly. The course work is teaching the basics for now. I'm understanding the definitions of the terms but am having difficulty applying it to situations it's asking me to. 
Agreed. It sucks big time. To the point I started to kind of dislike Material Design even though it doesn't have anything to do with it.
And the day I looked inside it I almost puked. It's completely rotten inside. The design choices were mostly wrong.
There's a useful CLI tool called electron forge which has templates for react, angular, vue, jade, es6/7, and typescript. 
Are you talking about the one in beta? Seems like the one @next has been totally rewritten.
js-joda is a nice alternative to moment, and has immutable structures which however much I use moment (which doesn't) always trips me up.
Async/Await is great, but you should first learn to write proper Promises. For instance `promiseLoops` can easily be written as: function promiseLoops () { const api = new Api() api.getUser() .then(user =&gt; api.getFriends(user.id)) .then(friends =&gt; Promise.all(friends.map(friend=&gt;api.getFriends(friend.id)))) .then(console.log.bind(console,'imaginary friends:')) } ...which (imho) looks more logical at a quick glance than the async/await version.
Fuuuuuck
Disclaimer: self-submission.
Moment is ridiculously bloated. You should consider date_fns instead.
Recompose is handy if you're working with React.
[I gotchu fam](https://danhab99.github.io/ConsoleJS/)
Underscore hasn't been updated in 2 years. Lodash started out as a reimplementation of underscore, but is now it's own thing. Ramda is the cool one. It is a functional programming utility. It only provides pure functions and never mutates data. Use it if you want to learn FP
Sounds like a rehash of FeathersJS, using the same components and everything.
Nice! But wow. I'm immediately turned off from that demo link because that is _not_ going to be allowed to continue... at all, let alone forever, as it seems to be doing.
Styled-components is really nice as well. 
Hi, this is a demo that me and my friend have worked on for some weeks. Note that it takes a while to load the demo In case the demo doesn't run, I have prepared a video of it [here](https://www.youtube.com/watch?v=1bykYClXkRg) This is a demo that implements laplacian deformation in Javascript. Laplacian deformation is a technique that allows you to deform an arbitrary mesh as if it were a cloth-like material. In the demo, you can grab handles on the mesh, and drag them. The vertices of the rest of the mesh are then smoothly updated, resulting in a deformation. The deformations produced by this technique tend to look natural, since the general shape of the mesh is preserved. This kind of technique is useful in 3D-modeling software. 
Just to add to the discussion. So regarding the alpha version, it's absolutely horrible and I totally agree about terribleness. But in this case I used version 1 which contains a huge amount of differences. I have not explored it well in depth yet to absolutely confirm that it ain't riddled with effects, but when i do I can update it here. If this will still be the case for the Version 1.0 thats in beta now, I'll try to find a proper alternative I would also appreciate everyone suggestions on which kind of library/framework prefer and possibly why 
more in-depth: `gyp` is the legacy build tool built &amp; used by the chromium team to abstract the host OS. as a result, node.js -- which is primarily built on v8, the JS engine inside chromium -- decided to use it for its native addon system. `gyp` has been superseded in chromium by [`GN`/`ninja`](https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md#setting-up-the-build), but node has had to keep using it for backwards compatibility with its current native addons (like `node-sass`). alternatives (like `GN`/`ninja` or a pure js implementation of `gyp`) have been proposed, but haven't gained much traction yet. 
I think you may need to investigate a bit more about WebRTC. It's P2P, as in you use a relay server to connect the clients, but to my understanding they transmit the data directly between each other, and only transmit their own data, not other users data. This is great for video calling between a few peers as you don't depend on an intermediate server, but not so great in broadcasting to a large audience, as they would have to transmit to each of the other users, as it seems you are looking for. Again, I might be wrong, as I've only dabbled a bit in webRTC.
caniuse.com is a good place to start when looking at particular feature support and correlated browser usage.
Their CSS is fine in my experience, but I haven't used their React components library. 
Thanks I'll take a look
Lodash, moment and numeral.js are probably the 3 I use the most (in that order) . But with the advent of ES6 and stuff like Babel.... I find my self needing lodash much less than I did before.
Pretty sweet! Thanks this is truly awesome as I like my code indented properly
Its pretty big but its the most useful library for dates so I have to use it even if it adds a lot of KiloBytes to my Project
In which of the proposed methods are you most interested? Also, given the work Facebook and Microsoft have done with Flow and Typescript, is there a strong reason for Ecmascript to further invest in type checking?
https://redom.js.org
Funny I just posted [this](https://www.reddit.com/r/javascript/comments/6u8vn1/are_you_still_using_lodash_if_so_why/) yesterday 😂
Yup, it's useful in that regard.. I needed this when I was creating jade templates dynamically in JS, and indentation was significant with Jade, so it was a life saver lol. 
Didn't knew about numeral.js thanx
Someone in stackoverflow mentioned: &gt; API scheme jsons: [here](https://cs.chromium.org/chromium/src/extensions/common/api/) and [here](https://cs.chromium.org/chromium/src/chrome/common/extensions/api/). And probably more: use a query like file:foo\w*?bar.*?json there. A [raw file content link](https://cs.chromium.org/codesearch/f/chromium/src/chrome/common/extensions/api/proxy.json) is somewhere in the page toolbar or you can use github chromium mirror. Could be a good start if I or someone can come up with a script to put it automatically in the correct format. If there are no better avenues from someone I'll give it a try.
What you are looking for is multicasting. It is usually done at a lower networking level, but it seems WebRTC is somewhat able to handle it with some relatively severe limitations: https://stackoverflow.com/a/20062726/105905 Have fun.
The answer is Vue.
Apparently, he's stuck a few years back in front-end if he's still using that ready function in jQuery. ;)
Will binary asts be backwards compatible?
Gonna take the hate, but I think async/await is syntactic sugar that obscures and bloats more than it alleviates. :(
I think it depends. If you just want to make some API calls, maybe. If you write selenium tests, every line is an asynchronous call so it might be useful there
[MobX](https://github.com/mobxjs/mobx) by far- it's solving a problem many tried to tackle-state management. It was created when redux was all the hype and the sentiment was that we don't need any other state management solution. It goes in a different direction-oppsite to redux-enables you to write OOP style code and still get a consistent rendering of your components. Simple yet magical.
&gt; What if you have a way to dispatch anonymous actions? This would be great. I have plenty of pain points with redux, but that's certainly never been one I've felt. Always cool to see people's approach to the boilerplate, so thanks for posting! I personally like to keep a separation in my mind of the action happening and the state it changes. That distinction may never realize itself in code due to the inherent nature of redux, but just a mental model I personally like.
I'm not a big fan of the animation shown on this site. I always thought it doesn't do async/await any justice because it does look a lot more verbose in the end there. But in general, I've found it to be much cleaner and easier to work with, especially when dealing with a lot of interdependent async operations (especially especially when authors tend to write everything inline). But your experiences could be different and I can respect that. Whatever you end up doing, if it's clean code, I'm with ya.
Y it took a while, but browsers and JS have come a long way. Now if that was 2009 , 8 yrs ago, then it makes u wonder what will 2025 be like?
I'll check this out, thanks!
As in older browsers? No. If you mean compilable back into javascript? Very likely.
Yeah, actions should describe events that have happened, which your reducers just happen to listen for. I think the semantics of that are hard to define and really nail down (the "meta language" as I've heard it called) but if you have a bunch of single use, essentially imperative actions like SET_USER or EDIT_ORGANIZATION then you're really just making function calls with extra steps and in direction. Ideally the action log reads like a series of steps the user has taken.
I prefer jQuery because it makes more sense to me, most answers are just a quick Google away, modifying existing jQuery examples are painless and easy, and jQuery results in less typing for me. I'm happy sticking to jQuery or an equivalent alternative. Edit: If you're just going to downvote, at least have the balls to give a reason. No Balls. You won't.
What was I supposed to be using instead?
Weird, looks good in incognito oO
I am currently using 0.18.3, I gave them the benefit of the doubt because hey its a beta but the trust is totally gone. There is no way in good faith I could use a 1.x release of the library. They've lost all credibility in my mind. 
&gt; Well jQuery as a dependency has to be downloaded EVERY time your site loads. If you're getting it from the CDN, won't every visitor already have it? 
The equivalent alternative is vanilla JS.
I think he's referring to the shortcut: `$(function(){`
All those users had to get it from somewhere right? Maybe your site is where they first have to download it, then they have to pay that cost on your render time. Even if they do have it then it's faster to do nothing than to have to check the change for something. Also if you're not loading in an async tag then the browser still has to pause while the JS gets evaluated. I remember reading a paper or blog s long time ago saying that browser caches aren't as big as you might expect so the "it's guaranteed to already be loaded" might not be as true as we thought. However I can't find it and it was a long time ago so maybe it's not relevant anymore. For my site I'm using 10 lines of JS without jquery. It doesn't make any sense for me to have a 600 line dependency to reduce my code to 8 lines. Keep in mind it's all relative, for many sites the trade off is very worth it. Edit: not sure what's up. My comment says: different strokes for different folks and not having any dependency is still lighter than the lightest dependency possible. Why is that a bad take?
I think it's fine to use tools you're comfortable with. It's also good to understand the breadth of tools out there in case a future project uses something you're not as familiar with. 
Ahh, thanks! It's funny if you're out of the loop for long enough you get to skip a generation of best practices.
HAHAHA, no... it still is :(
You're correct that learning promises is important for understanding async/await. The alternative you gave for promise loops, however, does not actually do the exact same thing as the example "promiseLoops()" function. Promise.all runs promises concurrently(i.e. in parallel), whereas the intention of "promiseLoops()" is to run each operation sequentially. Sequential asynchronous operations are a real pain to organize with normal promises, so the example was meant to highlight how the async/await syntax can make this *sequential* composition much simpler. For an async/await version of the code you provided, you could check out the "asyncAwaitLoopsParallel()" function in the following section.
You might want to check out Node's [`Buffer`](https://nodejs.org/api/buffer.html). [`fs.readFile`](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback) will return a `Buffer` of binary data if you do not pass it any encoding: var file = fs.readFileSync('my-file.txt'); console.log(file.toString('utf8')); Or you can add data to the `Buffer` continuously from a stream.
yes, because those are compile time subsets
hmmm, my understanding is that if I do this, the 'binary data' passed to buffer from the my-file.txt will simply be the binary equivalent of utf8's encoding of "0" and "1" as a string, not a bit. (am I wrong in thinking this?) Does calling file.toString('utf8') treat the contents of file as if it were raw binary data and convert it to utf8 text? What I'm trying to understand how to do, as stupid as it might seem, is take a .txt file with the following contents: 00001010 01101010 10100011 (no spaces included). Obviously, each '0' and '1' in that file would not be a *bit*, but an individual *character*. I want to be able to convert each character into a bit, convert all those bits into bytes, then convert those bytes into a number. Then, I will take that number, and convert it into a random ascii character. I know, I know, "Why would you want to do that?" - it just helps me learn. That's all I can say.
&gt; For my site I'm using 10 lines of JS without jquery. It doesn't make any sense for me to have a 600 line dependency to reduce my code to 8 lines. You wrote this article after writing 10 lines of JS? Regardless, the point still stands: the article states that it has to download jquery on every page load, and that's not going to be true most of the time. /u/afineedge overstated when they said "every visitor" would already have it, but the article is aggressively wrong in stating that it has to be downloaded every time.
jQuery is great for getting a working product pretty damn quickly. Once you know what needs to be done, the question becomes 'should you write custom code in Javascript?' jQuery, as a library, contains an assortment of tools (read: many lines of code) which isn't necessary if you already know what you want. Even for the jQuery functions you are using, how many lines of code are there to handle certain scenarios you **know** you will never encounter. Vanilla Javascript will always be faster than a library built from it. Also, a question you should be asking yourself as a programmer is "Can I write this code myself?" The answer shouldn't be "no".
@sebmarkbage had some closing remarks on the [GitHub issue](https://github.com/facebook/react/issues/10191#issuecomment-323486580) as well.
What should he be using instead?
TLDR: use create-react-app or other boiler plates to avoid frustration in new projects. Not exactly revolutionary. 
it's not best practice, it's just a preference. don't know what GP is on about tbh. i argue that it's better to do `$(document).ready()` because it's more explicit and clear in intent than `$(function(){})`. as you just illustrated.
only if you don't have to support older browsers.
&gt;We have considered possible changes carefully, but we won't be changing our default license or React's license at this time. We recognize that we may lose some React community members because of this decision. We are sorry for that, but we need to balance our desire to participate in open source with our desire to protect ourselves from costly litigation. Any recommendations for React replacement?
Ha! Good timing I guess. 
Denounce and throttle are the two functions I use the most, since they have somewhat non-trivial implementations. But it KILLS ME to see some co-workers still use _.map, _.each or even _.sum And then there are things like _.get.... which I don't even understand why it's a thing...
Dropping react. Done. No more facebook anything from now on and never again.
I assumed every page load is from a new visitor. Most read one article and bounce. I wrote the article and the comment that is getting downvoted to hell.
Well technically .ready() is removed in jQuery 3.0. I will say I do agree with you 100% on readability reasons, otherwise, there is no real good reason to use it other than that. I suppose you could write your own 'ready' function if you really miss that function? https://api.jquery.com/ready/ &gt; deprecated as of jQuery 1.8 and removed in jQuery 3.0. Note that if the DOM becomes ready before this event is attached, the handler will not be executed. 
Moment.js and Lodash. Lodash is great when es6 is not an option. As others state though, es6 is becoming better. Babel can also help with es6 code. 
Can someone share an example of the kind of lawsuit Facebook is trying to avoid using this license? 
I keep hearing this one. Are we going to pretend that everybody is using the EXACT same version of jquery?
You realize the JSON liscense is also on this Apache list as well? Are you going to not use JSON? They’ve had this liscense for years...not sure why an internal policy decision at Apache would change that. 
Vue, obviously. You might look for a JSON replacement as well though because that’s also on this Apache list. 
What are your percentages like out of curiosity? Because one page view per visitor is not great from my understanding. That being said, /u/afineedge is correct that jquery is still widely used and the main download links for jquery are their CDN links, so it's reasonable to assume that a large percentage (&gt;20%, &lt;80%) of new visitors to your site will already have it. The only reason I'm hard on this statement, btw, is that if you're trying to analyze payload sizes, you HAVE to take caching into account. With your site it's super easy to see that it shouldn't rely on caching to offset jquery because it uses so little JS code. For sites that use a lot of JS code (any serious website developed in the past few years, the developers of which are the main audience for this subreddit), that's not the case and the statement you made is so ignorant that it might as well be intentionally misleading.
Are we going to pretend that users haven't visited a ton of sites and likely have a TON of versions of jQuery cached already?
Yeah but the marketshare of those browsers is dwindling rappidly and is already really low
I hear you, but I'm not making a single page app using jQuery. I guess choose the right tool for the right job.
It's not an alternative in the vast majority of cases for even new browsers unless the only things you use from jQuery are basic dom methods / ajax or whatever. jQuery does a lot of stuff and there are lot of 3rd party things that use jQuery that vanilla on its own doesn't provide. not saying you should use it, but saying that all of jQuery can be replaced by out of the box browser apis is disingenuous 
jQuery *did* make sense and was less typing for me years ago. now it's significantly more arduous than something like react
So the top one is to demonstrate interacting with the person and the bottom one is demonstrating a looping script (and beeping)
sure looks useful. the verbosity of redux is completely overstated though.. it's opt-in and designed to help teams debug what's going on with state. I'm hoping [freactal](https://github.com/FormidableLabs/freactal) starts to pick up more traction. it's the most compelling state library I've seen in the last little bit. kudos though! I'm all about more options
let's be real, not nearly as much as it used to be.
Right. But I don't know who wants to listen to repeating beeps. I am not one of those people.
&gt; You realize the JSON liscense is also on this Apache list as well? Are you going to not use JSON? Don't be ridiculous. JSON isn't copyrightable. [The JSON license covers the JSON _reference implementation_ and is widely believed to be facetious and very unfortunate.](http://tanguy.ortolo.eu/blog/article46/json-license) A lot of people have probably taken for granted that React's IP status was benign due to its permissive copyright license. This sneaky patent business subverts that. You shouldn't be surprised to see people jumping ship now that the ASF's brought it into focus.
Then when you use my script, don't call `C.Beep()`. Btw you can commit changes, I might accept them :)
Can I get an unminified version of this, please?
I haven't really been following along with all of this too closely, but it looks like shit's getting tense.
 const buff = Buffer.from("01101101 01101111 01101111" .split(' ') .map(byte =&gt; parseInt(byte, 2))); console.log(`Result: ${buff.toString()}`) // Result: moo Edit: removed irrelevant explanation (I thought you asked something different originally)
I haven't found JavaScript or the DOM to be the limiting factor when targeting back to IE 10 and 11. Perhaps if you go back further.
At the very least they should invest into offering a method that's self-sufficient, easy to use, and 100% consistent. Wouldn't hurt if it was also intuitive and succint. Everything we have right now has to rely on either third party tools or good knowledge of the language quirks. Personally, I tend to favor something that acknowledges dual classification. Something that can answer `true` to isFunction(f) as well as isAsync(f), isArrow(f) and isObject(f). And let people make what they want of it. Other than null pretending to be an object, the rest of JavaScript's dual classifications are benign, they hold true and you can use that variable as intended, eg. async, arrow and function really are supersets of the object features. 
For me the match syntax seems the most promising, as it could be applied to many more things than just type checking. It's one of the syntactic features that make Rust amazing and it would be great to see it in JS
Choo js is cool tiny lib that clicked for me as the first reactish one. Mostly because I had a chance to work on a real project with it. Still learning took me roughly few hours and concepts clicked right in for me. I can honestly recommend it
Patent trolls don't use React. Also the problem is that they use developers to not get sued.
Facebook recently created a platform where users can sell stuff. If you already had a platform like this using React, and Facebook decided to steal something from you, you either have to shut up, or sue them and rewrite your entire frontend. 
According to [this comment](https://issues.apache.org/jira/browse/LEGAL-303?focusedCommentId=16045188&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16045188) GPLv2 is not allowed either. I can't imagine React not using _any_ dependency with that license, so presumably they've been violating it already...
&gt; Use some of your presumed profit to strip react from your code base. Which if it is widely used in a corporation can become a multi-million dollar transformation too in the future. And things will only get worse if React manages to be so dominant that no other framework like e.g. Preact can keep up with being a drop-in replacement, so you also have to re-implement those features in addition to stripping out React. Also the patent clause exists in most recent facebook open source projects: React-Native, GraphQL, Relay, Flow, Jest. Exchanging those sadly isn't as easy as it is with React today.
I work for a huge Fortune 150 company and our lawyers said we absolutely cannot use React due to the licensing issue (even though we are a manufacturing company that doesn't compete in Facebook's arena at all). So we went with Vue. It has been tremendous so far. 
Eh, I get where you come from, but FLOSS is specifically about freedom being non conditional. It also creates an environment of surveillance that transforms users into hostages to the license. Obviously you could simply not use React, because there are similar alternatives you could turn to. But imagine this particular clause was used by the W3C on HTML. "Sue us and you'll lose the right to use this technology". Even if you are right to sue, regardless if you win or lose, you instantly become a pariah in the 21st century dev landscape. If you're a private company giving a paid service with plenty of competition and refuse to serve a client for any reasons, that's as bad for you as it's bad for the client. But if your product is (potentially) a de facto standard *and* you freely encourage its use, distribution, modification, putting conditions along the way is a really shitty move. If they were not doing anything illegal, why would they want to deter people from suing? It should be an easy win for them, right? Think again.
It does not have any GPLv2 dependencies. If it did it would not be able to be released under the BSD license 
Why not? Dependencies are not part of your code, you only incorporate their name in your `package.json`?
these bastards have built their whole company on open source software and now they are using React as a weapon. Scumbags.
&gt; Isn't FB's license just "if you sue us we revoke your rights to use any of our open source software"? No. It's "we grant you a right to use any patents we might have, but if you sue us about patents we revoke your rights to use them". &gt; So companies are given a choice: don't sue us or stop using react. Nope, you can sue them and keep using React. You can even sue them *about patents* and keep using React, but if you do so, and if Facebook actually has any patents covering React, they'll probably counter-sue.
Yep. Just use Vue and be happy.
Depending on an npm package is considered linking, and thus would make all code which depends on that GPL package also be GPL'd. See the [GPL2 FAQ](https://www.gnu.org/licenses/old-licenses/gpl-2.0-faq) or the [GPL3 FAQ](https://www.gnu.org/licenses/gpl-faq.html). Edit: If you search for "gpl npm module", you'll find "[illegal npm modules](https://samgentle.com/posts/2015-03-31-illegal-npm-modules)" and [this SO question](https://stackoverflow.com/questions/16274841/output-all-licenses-of-installed-node-js-libraries). Both provide tools which traverse your package (to ensure that you depend on no GPL'd code).
Okay, fair point. I meant simple as in the default use-case. Nothing out of the box. Sure innerHTML works great, but it's not easy to maintain.
I suppose it depends on the project and on how much of the moment API you're using. At one time Moment accounted for over half of my bundle.js, but I was only using four or five methods. Because it is object oriented, you have to create a moment date object with all of the methods before you can use just one of them. If you use date_fns instead, you can import only the handful of functions you actually need and drop the rest at build time.
Anyone got a link to an article about the issue? Canny be arsed trawling comments on a GitHub issue.
Good question, i was thinking about Preact before React Fibre came out (React 16 beta). I'll take the extra kbs for the magic fibre gives us. If you want small foot print use Preact, if you want decent perf React 16+. 
not only React, but also GraphQL, Relay, Flow and other awesome stuff :'(
That's the same reasoning that makes people think talking to cops is fine if you're innocent. 
Actually, what is removed in jQuery 3.0 is this specific way of doing it: $(document).on( "ready", handler ) I've never seen anyone use that anywhere, have you? It never even occurred to me to do that. This version of the "ready" function is fully supported in jQuery 3.0: $( handler ) And the other common versions are still supported but deprecated: $( various-things-here ).ready( handler ) The reason those are deprecated, as the page explains, is that selecting anything here is pointless, whether it is `document` or whatever. Personally I think this whole thing was a big mistake all along. Instead of overloading the `$()` function or doing useless selections, `ready` should have simply been a static function like this: $.ready( handler );
Okay, I am not saying I want to learn once and forever. Just whether Preact is good enough to replace React at this point in time. Asking this mostly because we are having issues with the licensing.
License is the biggest reason why I am thinking of staying away from react. Savvy clients get scared.
I work for a large nonprofit R&amp;D shop. Same deal here. 
They seem to be talking about making other libraries part of your application [through compiling and then distributing](https://www.gnu.org/licenses/lgpl-java.html), which arguably usually doesn't happen for Javascript libraries. But you're right, it definitely looks like the intent is to include depending on GPL libraries. Hmm, after all these years this finally makes me reconsider using the GPL... Thanks for clarifying, in any case.
Or. I infringe your IP. Then if you sue me, we revoke your right to use our software.
Note: that link is for the LGPL, not the GPL. You can link/use LGPL libraries in a non-GPL app. In any case: I'd talk to a lawyer if you ever need to go anywhere near GPL code. Every company I've worked for has been paranoid, so I'm also paranoid!
The Apache announcement changes nothing. You can tell them the JSON liscense is on the same list.
It doesn't matter. Someone will create a React-like workalike that everyone will flock to or, within three years, everyone will disavow React in favor of some other thing that comes along and this will all be old stuff. It especially doesn't matter to those of us who know how to write our own code. We just keep rolling along without a care.
Yeah, but coercing users against potentially rightful litigation is the kind of shit large corporations do (along with unreasonable NDAs, extreme no-competition clauses, progress blocking patents…), which is why we have FLOSS to begin with. Disclaimer: I'm not against business. I myself sell proprietary code and saas for a living. But I also have a lot to thank for to the FLOSS community, so sketchy practices is what could ultimately destroy it. Facebook is big enough to be lobbying against patent trolls instead of threatening users. But maybe that's against their own best interest…
JSON License?
Next.js, a huge production ready React framework has this in examples - https://github.com/zeit/next.js/blob/master/examples/using-preact/next.config.js I'd say it's safe to use
http://www.json.org/license.html Specifically, this part is what trips people up: &gt; The Software shall be used for Good, not Evil. Who determines what is good or evil? 
Re: graphql just use apollo
You biggest problem comes in with other module compatibility, they do offer preact compat which 2ill solve many of them, however there are other modules you may run into with a hard dependency. I swapped out react for preact with compatible in an existing react Redux app with a few extra bells and whistles and it was not even 5 min and everything works. However when 16 goes RC or prod I will be swapping back, licensing means jack diddly squat to us, I cared about to 40% reduction in bundle size. While fibre won't give me that much of a drop, I would rather the features. If you care that much about licensing you will need to make a harder break, using preact will still indirectly put you within your licensing issues with most other react ready modules not having pure preact alternatives which would mark react as a dependant putting react code in your preact code base as some point in the chain. If licensing if your reason, then you need to jump to Vue or something else they will have no possibly react dependencies at any point in the chain. I still have react and react dom installed in my app, they needed in part for module compatibility, to get rid of errors and I like jest for testing, and it's easier than rewriting all my tests again to something more preact compatible. If you like react and want a smaller bundle, then preact is your man, if you worried about licensing, then it will offer you no change.
if you are looking for performance, you should definitely check out InfernoJS.
Yep! Picked up Vue a few months back. Took all of 2 days to get going. Now all our new apps are built on vue and I don't think we are looking back anytime soon. Sometimes the idea of switching over seems more painful than actually doing it...
Elixir has something similar. They have their normal test files, but they also have a concept called DocTests. Inside your documentation for a function or module you can put: iex&gt; ThisModule.this_func(a, b, c) 123 This is then built into their documentation and also executed as a test, which verifies the examples in your docs are up-to-date and correct. iex is their interactive repl, so the docs are showing "If you put this line in the repl, this is the response you'd get back" and the tests verify that.
Hapi
This might be an unpopular opinion, but a lot of the solutions I see people coming up with for testing are because they're writing their tests after they write their code. And in my experience, testing after sucks and I'd rather not do it. I also find it less effective (in practice, not necessarily in theory.) I like the idea in terms of documentation, like I mentioned in my comment about Elixir, if you're building up public facing documentation. But in terms of constructing the function, I'll stick with doing TDD. At the end, the tests might still seem "boilerplate" but my efficiency has increased over the past 5-6 years as I've done TDD, to the point that the other benefits I see outweigh the concern of "is this test too boilerplate?"
Yes it's safe in production. If I recall, Preact is a more simpler implementation but if it fits what you need it for, yes it's production safe. 
That's not 100% correct. The important bit is if you had *patented* that platform in some way. Just building it doesn't give you any rights to sue. If Facebook violated a trademark or copyright, you would still be able to use React and file a suit against them.
Similar situation here, implementing Vue as well.
Thanks for the reasons! By 16, you mean react version 16?
Thanks!
You mean the apollo that is built on top of graphql.js which has the patent clause? Besides that, I also try to stay clear of apollo ever since their optics agent caused a memory leak for our services.
[Ramda](http://ramdajs.com/) no doubt. Start with just a few functions. As you're sucked into it more and more your love for it grows. R.curry() and R.pipe() are a magical combo, with just those two you can start composing functions. Remember, data goes last in functional programming, that's what allows you to pipe the data through. Honorable mention: [most.js](https://github.com/cujojs/most) (super fast reactive functional programming using streams) together with [redux-most](https://github.com/joshburgess/redux-most) ([redux-observable](https://github.com/redux-observable/redux-observable) fork for most.js) is my favourite way to do state management and side effects. Small example, this is how I log in on my firebase app. // function // (stream of actions) =&gt; stream of actions const firebaseLoginWithPopup = pipe( select(LOGIN_REQUEST), m.switchMap(pipe( action =&gt; m.fromPromise( firebase.auth().signInWithPopup(new firebase.auth.FacebookAuthProvider()) ), m.map(userCredential =&gt; ({ type: LOGIN_SUCCESS, payload: userCredential.user.uid })), m.recoverWith(errorAction(LOGIN_FAILURE)) )) ) "m" is most.js with all its functions curried, "pipe" is ramda.
kill it with fire
I guess Amazon has a lot of patents involved in their marketplace, besides the 1-click-buy, which will run out soon (there was an article about it yesterday, so that's fresh in my mind). If they were to use React, they would give Facebook an open entry into their field of business like no other company would have. So, as a result, they, and most other big tech companies will stay clear of it, fracturing the open source space in the process.
Same here! Vue is pretty awesome and I regret nothing. 
That's really interesting that you mention that your companies lawyers advised you to not use React. I know of at least one large company, which competes with Facebook in certain marketplaces, that has recently started using React, and it makes me wonder whether they ran the license by their lawyers. Really poisons the waters when you need to get the lawyers involved before you can decide on whether you can use a popular JavaScript library. Do you remember anymore details on what your lawyers advised you?
ok let's think about this pragmatically. Do any of us in our right mind think Facebook would use this opportunity to steal a patent from someone in broad daylight with the ENTIRE internet watching them? I said this on another comment, but we as humans operate in terms of probability. Most of us don't have an arsenal in our apartments to fight off 6 trained operatives on a mission to kill us... because the probability is low. The probability of Facebook stealing something from someone then using this clause in React would be unbelievably stupid in terms of the amount of immediate ire they would invoke around the web. We're talking them missing out of would be smart developers coming to their platform, some of their higher ranked developers that mostly are open source first, we're talking their framework that THEY benefit from massively dropping from the amount of people not willing to use it. Facebook is definitely a company that can't afford to fuck around with people willy nilly like this and have it not affect their bottom line. Is it impossible? No. But it's definitely not probable and jut doesn't even make sense.
This assumes they all come from the same CDN with the same naming scheme.
There's a react compatible library called preact now which is smaller and reportedly faster than react. Haven't tried it but apparently several companies use it in production already and didn't need to rewrite their existing react code.
We nearly ended up going with React. Had a large project coming up about a year ago. So I built three POC of the same app and ran our team over React/Redux, Vue/Vuex and Angular 2/Redux. They all chose Vue.js (1.x at the time). Took the PHP backender I was working with about 2 days to get up and running. Haha, I even had our tester and PM making changes to the Vue templates and validation rules.
&gt; is so ignorant that it might as well be intentionally misleading. This is learning for me too. I explicitly say I'm not an expert. I have a whole section on caching, max age, and fingerprinting.
All I'm saying is, that if I'm some guy cruising the intertubes, checking out repos, and I click on a demo link to see what this one, particular thing is about, I'm not going to stay around to play with it if it's beeping at me like that ;)
the jQuery's ready event is not equivalent to the native load event. it's more similar to window.DOMContentLoaded.
I work for a tiny company with hardware patents. We are building something cool. Would Facebook _deliberately_ steal from us, with the entire internet watching? Probably not. Could they purchase one of our competitors, who might have thought they could get away with it? Maybe. Could they purchase a competitor who accidentally infringes and forces us to litigate? That seems a bit more likely but it's still doubtful. Ultimately, I don't care about the likelihood of litigation. The responsibility of predicting Facebook's intentions and future moves should not be on someone who wants to use an open source project. Probable or no, it's not a reasonable demand and it has no place in the community. It's too broad, it's too one-sided. No one company should have all that power. 
Thanks!!!! Exactly what I was looking for :)
Let's not forget Immutable.js! Hope it's not one of your dependencies!
Correct, it's in beta now.
&gt; Really poisons the waters when you need to get the lawyers involved before you can decide on whether you can use a popular JavaScript library. My company requires any and every open source library we use to be approved first. It's usually very straightforward when it's a license they've previously approved (MIT, BSD, etc) which is &gt;95% of them, but any weird terms (conditionally revokable patent grants, or "don't be evil" cuteness) would likely make them pause. 