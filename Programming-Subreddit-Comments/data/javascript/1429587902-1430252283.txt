Something to do with a college introductory linked list, right?
My HR thinks javascript and oracle are the same thing. 
Check out this lib to benchmark perf - https://github.com/maxogden/require-times
I agree, that's why I put "20 lines of code" in quotes. Now I'm wondering if it's possible to do it in "0 lines of code" xD Here's a todomvc in 60 lines of code https://github.com/farzher/mithril-livescript-todomvc Which also includes all of the html templating logic ;)
Great question! (Very) short answer: UX! ;) Longer explanation: - Why selling cameras with batteries included, if the customer can easily buy them in the shop next door? Because maybe the shop is suddenly closed or moved or is too far away? The same with software. Make it easy to use, reduce the number of steps - and they will love you. Add more cognitive barriers - and they will go to your competitor :) Now made even simpler - no gulp installation at all! Have a look: https://github.com/dmitriz/gulp-automation
I'll check it soon. Thanks for the feedback! 
Their tiny fucking brains would melt
But javascript has classes now! Just like Java! Same language confirmed.
In 90's hipsters used to use Java.
You mean I can avoid fucking prototype chains?! Woooooooo!
In my entire life I have met exactly one good IT recruiter who took the time to understand the industry at even a basic level... and he doesn't work in the recruitment industry any more. All the others - *every single one* - could have been replaced with a one-line regexp scanning CVs for substrings. In fact the one-line regexp would probably have done better, because it would at least understand `\b`.
[Element.scrollIntoView()](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) Haven't done performance testing so I'm not sure that's faster, but it's more direct at least.
When everyone knows Oracle is a hero in Dota
The restriction of selectors to Level 1 instead of Level 3 + extras is what makes minified so small compared to jQuery. If you want more complete selectors, I invite you to have a look at my [m².js](http://atk.github.io/m2.js/). When I have more time, I'll even improve it further.
Those recruiters are seriously the worst. I have zero patience of dealing with their bullshit. Dumbasses calling me in the middle of a work day without having any kind grasp of even the most basic details. Why would I ever even consider working for a company - whose name they won't even tell me - full of people hired by these guys? They're more of nuisance these days, than those goddamn telephone salesmen who call you to try to sell magazines or whatever. Fuck them and the companies who hire them. Sorry about the rant. Feels good to get it off my chest. There are good recruiters out there, not all of them are idiots... Just most of them.
No, it's just syntactic sugar. The prototype chains are now disguised as classes.
This is really interesting..
I went to a drinks evening that a recruiter was putting on for their contractors over Christmas. One young recruiter said he had a law degree. So I asked him to name some basic court cases (I'd been to law school, too). He couldn't. The impression I get of most recruiters are that they are bottom-of-the-barrel individuals. Recruitment is not about getting the right person for the job - it is about getting commissions. Recruiters have no incentive to do the right thing by their "capital" (that's you or me, they don't care about the fact we are human beings). They will pitch you at a low rate because they often get fixed commissions or even a percentage - and they are competing against other agencies. It is better they get you in at a low rate then not in at all; and the lower the rate they pitch you, the more likely an employer will pick you over the guy from the other agency. If a recruiter low-balls you it is because they want a commission; they couldn't care less what you think you're worth. Remember that.
&gt;the two languages could not be further from the same thing. I like how people say stuff like this. Yes, they could be A LOT further than than being the same thing. They have quite a few similarities. They are pretty different. I wouldn't say completely different. 
Scalewebbers needed for node startup
Dear Sir, I have more than 10 years of industry experience in organic fair-trade enterprise javascript beans. We work with industry experts to source only the purest web clouds for our beans and we expand our beans horizontally across a multitude of verticals. Please consider our application, hope to hear from you soon.
No no it must be about pointers. I used to know all about those pointers. It's like an arrow that connects to the memory or something.
Minimum ten years AngularJava experience required, familiarity with JavaQuery a plus.
If you spell Oracle backwards it reads Illuminati. Confirmed.
So it is Unix-like :) If you live in Italy for 20 years and speak Italian perfectly but have no Italian citizenship, are you Italian? :)
And don't you dare to use any classes.
FYI: data.js is part of the test, as well as index.html. I haven't written them, I've only changed the minimum required to complete the task, which is the function update, nothing else. The logic would be ideally placed inside a closure to avoid global leaks, so you are correct, the code is dirty, but that's not the purpose of that code, so nobody actually cared much, me included. Hope this clarify a bit
Thanks; my code reading comprehension skills had taken a vacation (although it's a terrible way of writing that imo)
Yes. Citizenship is for the government, to keep track of it's herd.
It's not about the DOM APIs being fragile, it's that using those lower level APIs becomes more fragile, because it's easier to shoot yourself in the foot. Using an abstraction that knows what it's doing lets you focus on your application instead of having to worry about things like layout trashing and keeping your data model and the DOM in sync.
&gt; It's not about the DOM APIs being fragile, it's that using those lower level APIs becomes more fragile, because it's easier to shoot yourself in the foot. This is true with **every API**. Using a developer that knows what they are doing solves every problem proposed by a framework. &gt; instead of having to worry about things like layout trashing and keeping your data model and the DOM in sync For me, though, (and my teammates) this is not a worry.
That's a cache-busting thing that jQuery adds automatically. (See the [documentation for `$.ajax`](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings).) I'm not sure why it's being activated here, because the documentation says that by default it's only used when `dataType` is `script` or `jsonp`, and `jQuery.load` sets `dataType` to `html`, but maybe you're using an older version with different behavior. I can't comment on why the last parameter is being replaced. Step through it with a debugger and find out. 
A faster way is to find the node and get its offsetTop property (if it is a block and if not get it from the parentNode). This is fast. To scroll into view use the scrollTo method, which is also very fast. In IE and FF you use the scrollTo on the document.documentElement where in webkit you use it on the body tag. Easy and fast.
We need thousands of lines of code ASAP. Get me the fastest typing developer you can find.
If you're trying position yourself for the future, you should put your weight behind pushState. Imo, the biggest benefit that pushState has over hashes is that it's crawlable out of the box with no configuration (assuming every URL is backed by a physical page). 
That's one of the reasons I personally don't like that var declaration style. If you miss a comma, you've got globals. And it's easy to miss a comma, and difficult to see at a glance when you do.
&gt; To give a specific answer, anything that is asynchronous you can easily use promises and probably should use promises. Ok, but why? In my example above, I don't see anything that makes one better than the other.
I got to the point where I had to sit down with my wife and say, look babe I seem to know more than most of the people I'm interviewing, maybe I'm in the wrong job, or just on the wrong side of the desk. Hopefully it works out!
&gt; For example, with promises you don't need to create a mock event bus for testing; Since I'm using Backbone, I don't really need to mock Backbone's event system. &gt; and task functions do not need to specialized for a specific slot in a task chain. In my example above, this is not the case. task functions, when complete, trigger an event OR resolve a promise, and then it's another method that sets up the order of the tasks. That workflow method would be necessary whether I use promises or events. So it's still not 100% clear why one approach is better than the other.
 Achievement Unlocked: Creating the Legacy Code 
Dubstep to dub
I like the comments that say 'use tool x or do something different' rather than addressing the actual issue of whether require is slow or not.
Solid advice there. Thanks for that! 
Node Java is the hottest new craze, works well with my Mongo RDBMS.
As for my knowledge, there is no working router for angular 2 and that router that exists has pretty impressive bug list and is not near to be finalized.
Recruiters: Get a real job
This code is janky: var selected = $(this).attr('checked'); if(selected == 'undefined') { selected ="notset"; } undefined is a primitive, not a string, so it shouldn't be in quotes. Also as a style nitpick, just use single quotes consistently. I'd write this instead: var selected = $(this).is(':checked'); Selected will be set to true or false depending on whether the checkbox is checked. If you really need it to be the string 'notset' when the checkbox isn't checked, do this: var selected = $(this).is(':checked') || 'notset';
you mean you don't want a 3 month contract job in Texas working on ASP.NET?
Your example isn't the best for demonstrating the advantages/disadvantages, but in your case because most pub/sub implementations use a FIFO type queue for execution, it may work fine for what you are wanting to do. However, the order that it's added to the queue may not be consistent if the code triggering is asynchronous. If you want for sure to maintain that order, you can use promises and chain them together. If order doesn't matter, you can use $.when() which resolves when all promises passed to it are resolved. If you want a similar solution for bootstrapping, I have used https://github.com/caolan/async in the past. It's neither pub/sub or promises but more like a queue with a callback system. 
What's that? Java straight in the browser?
I get that all the time. My resume: Web developer with extensive experience with SQL Server. My offers: SQL Server DBA jobs!
Like what go-kart is to supercar. Fun but still a toy.
I am not into React, but the page has an awesome design.
Pork &amp; sage burger. Very delicious.
Thank you!
It's no restful api it just takes data from it
`invalid lvalue at 5++`
Too much West Wing.
Granted they have a somewhat similar syntax. (as all c-like languages do) - Java has class based OO, JS has prototypal OO - Java is statically typed, JS is dynamic - Java pre java 8 was not functional, JS is functional - Java is multi threaded Those are pretty major differences and the kind of code you write for both will tend to be pretty different.
&gt; You need to familiarize yourself with what the DOM Api is. I wrote [this](http://prettydiff.com/guide/unrelated_dom.xhtml), if that helps. &gt; It is considered, in the browser environment, to be 'vanilla Javascript'. No its not. You sound like you have very little experience with these technologies.
I vote for [ACDCScript](https://www.youtube.com/watch?v=FH0ja5mb-Mc). :D
I cannot stand recruiters. I had one call me on my work line. They must have called the directory and found me, because I don't even know my work number to post it anywhere. They asked "is this a good time to talk?" I said "no, actually, it's not". And they asked if there was a better time/way to reach me. I told them they could contact me on LinkedIn (equally as useless). They seemed offended that I didn't take them seriously. My job is fine, but a call like that could easily cost someone their job, depending on the culture. A manager could easily overhear the call and assume you were looking for another job, and decide to replace you before you can replace them. I had another recruiter call me on a Saturday and ask if I was exploring new opportunities. I told him I'm not, I'm very happy where I am. He asked what it would take for me to be open to a new opportunity. I said I'm happy where I am. He said, well, you would want to at least make more than you're making now, right? I said yes, but it's about more than money, I am happy where I am. He asks, well what's that number? I repeated, I'm happy where I am. He says well, would $X be enough? And I repeated, I'm happy where I am, it is about more than just money. I get when recruiters call be about Java positions. I understand their shitty search parameters pick up my resume because a search for Java turns up Javascript. I really don't understand when I get a call about a .NET position. A language/framework I've never touched, and it is most certainly not on my resume. Just as you said, there are good recruiters though, and one helped me find my current position.
And he should have at least 10 years of experience with HTML5.
I wonder how well a "rename javscript" campaign would fly...
? I was saying support for the wife meaning, she's going to have to understand the job comes first for a while. If you're single, there's no one to answer to.
If we came up with a great name, it just might work.
this is what I started with, however i want a new website to open when I click the link then fill the fields in that website. I have control over both the websites.
HTML5 is a crutch. I've been coding pure semantic HTML since 1994. If you just take a look &lt;img src="eyes.gif"&gt; at my &lt;blink&gt;resume&lt;/blink&gt;, you'll see &lt;img src="eyes.gif"&gt; that I have ample qualifications. Just ask anyone &lt;a href="http://codingplace.code/coming-soon.html" title="under construction!"&gt;I've worked with&lt;/a&gt;! I hope to see you soon! &lt;img src="eyes.gif"&gt; &lt;a href="codingplace.code/dev444/coming-soon.html"&gt;go to the next programmer in the programmer webring &amp;rarr;&lt;/a&gt;
I'm not intended to be political, what i meant is that what matters is what is at the heart.
The protypes are now diamonds!
I cast my vote for LiveScript. It's a cool name.
Instructions unclear, wrote in BrainFuck
Professional Javascript for Web Developers http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-3rd-Edition.productCd-1118222199.html
Found from this article: http://dailyjs.com/2015/04/16/jsorg-wallpaper/
The Good Parts.
You disagree that i think they are different?
I like it
The `Object.assign` was new to me. I use something similar which can be replaced when ES6 becomes available. Most developers, even JavaScript developers, are still using the semi-classical class based approach it seems with `new` and `object.prototype`. I prefer the pure object prototype approach described in the article. It leads to cleaner and simpler code and my prediction is that more and more JavaScript programmers will move in this direction.
Easier: Webscale.
Java is to JavaScript as con is to contract.
Could be, but this in the article may be true: "Class inheritance by virtue of its mechanisms create class hierarchies as a side-effect of sub-class creation. Those hierarchies lead to arthritic code (hard to change) and brittleness (easy to break due to rippling side-effects when you modify base classes)." Classes are static templates basically, while object prototyping is more flexible and dynamic. We will see how ES6 will be used. Probably in different ways depending on the application.
1 big class (maybe some additional) but without any interfaces and derivation.
That was just an example demonstrating the use of WAT. It was not reflective of the author's understanding of JavaScript.
When you read this and laugh but also double check it in case you'd missed something
I was supposed to do a university project in Java applet for a Java related course, I asked my professor to do it with canvas in JavaScript since no one is using applets anymore and he agreed because he tough JavaScript is another fancy Java framework Edit: and I didn't correct him
+1 for Babel, it's great!
Love it. 
&gt; I've seen it with only two people on the team. That is what code reviews are for. &gt; It is still way too slow for 2015. For what? For creating the next first person shooter at 4xHD in 300fps?
I recently built a React site using ES6 with Babel, and there have been mercifully few occasions where I've been reminded of the fact fact that I'm using a transpiler. You can use eslint with the babel-eslint package to parse source and lint it too, if that's your style.
Thanks for the suggestion! I realize I actually misrepresented the use case, the scroll to needs to work for a Range object not an element and it may be covering a small amount of text in a large element. The offsetTop is a great suggestion though and I might try to use it to optimize the 90% case where there is text insertion as well or maybe come up with a tricky way to always use it. 
True, so? If they are just syntactic sugar you could argue they are entirely unnecessary. Most of the TC39 thought this way.... except the demand for classes was way too high. There are a crap ton of Java and C# developers who want JavaScript to be Java.
Yes I do. That's why I will go for 10, yes ten, fucking **TEN** levels deep nested terninary, because why the fuck not.
Haha, I was expecting this argument to be much less one-sided, but great! Makes the choice nice and easy, and the answer is now in reddit history incase other people need to search it out.
[Jon Duckett's book](http://www.amazon.com/JavaScript-JQuery-Interactive-Front-End-Development/dp/1118531647/ref=sr_1_2?ie=UTF8&amp;qid=1429638893&amp;sr=8-2&amp;keywords=javascript) isn't terrible if you are a beginner, and are not easily distracted by artsy layout. But as /u/gdmno has said [The Good Parts] (http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/ref=sr_1_1?ie=UTF8&amp;qid=1429639005&amp;sr=8-1&amp;keywords=javascript+the+good+parts) is widely praised and rightfully so.
Don't tell them! It's a good litmus test for whether I want to read the e-mail.
Practical and precise but kinda crappy. I want my computer languages to have whimsical names. It gives me one more reason not to blow my brains out and I need every reason I can get.
EczemaScript.
Favorites change over time. Used to be 6to5, es-next and of course Traceur. Now it's babel.
I really enjoyed [Javascript Patterns](http://smile.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752/) a lot.
Redditors: Recruiters do not read your blogs. 
That's what coffeescript is for. 
Interesting. Yea, I don't even have a referral account set up.
The "massive multiplayer" feature is really difficult and the timing that'd be necessary near impossible... But that's today's mostly ES5 support with early asm.js adaption, so fingers crossed for the future.
So... Ham is made of hamsters?
Earlier this year, I had a recruiter try to talk to me into taking a 3 month contract in Pittsburgh. I live in Florida - what the hell would I want to go to Pittsburgh for?
There is no ES4: http://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_4th_Edition
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 5. [**ECMAScript, 4th Edition**](https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_4th_Edition) of article [**ECMAScript**](https://en.wikipedia.org/wiki/ECMAScript): [](#sfw) --- &gt; &gt; &gt; &gt; &gt; &gt;The proposed fourth edition of ECMA-262 (__ECMAScript 4__ or __ES4__) would have been the first major update to ECMAScript since the third edition was published in 1999. The specification (along with a reference implementation) was originally targeted for completion by October 2008. An [overview](http://www.ecmascript.org/es4/spec/overview.pdf) of the language was released by the working group on October 22, 2007. &gt;As of August 2008, the ECMAScript 4th edition proposal has been scaled back into a project codenamed ECMAScript Harmony. &gt;Features under discussion for a future edition (originally "ECMAScript 4"; now ECMAScript Harmony) include: &gt; &gt;* [Classes](https://en.wikipedia.org/wiki/Class_(computer_science\)) &gt;* [A module system](https://en.wikipedia.org/wiki/Modular_programming) &gt;* Optional type annotations and [static typing](https://en.wikipedia.org/wiki/Static_typing), probably using a [structural type system](https://en.wikipedia.org/wiki/Structural_type_system) &gt;* [Generators](https://en.wikipedia.org/wiki/Generator_(computer_science\)) and [iterators](https://en.wikipedia.org/wiki/Iterator) &gt;* Destructuring assignment &gt;* [Algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) &gt;The intent of these features is partly to better support *[programming in the large](https://en.wikipedia.org/wiki/Programming_in_the_large)*, and to allow sacrificing some of the script's ability to be dynamic to improve performance. For example, [Tamarin](https://en.wikipedia.org/wiki/Tamarin_(JIT\)) — the virtual machine for ActionScript developed and open sourced by Adobe — has [just-in-time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation) (JIT) support for certain classes of scripts. &gt;In addition to introducing new features, some ES3 bugs were proposed to be fixed in edition 4. These fixes and others, and support for [JSON](https://en.wikipedia.org/wiki/JSON) encoding/decoding, have been folded into the ECMAScript, 5th Edition specification. &gt;Work started on Edition 4 after the ES-CP (Compact Profile) specification was completed, and continued for approximately 18 months where slow progress was made balancing the theory of Netscape's JavaScript 2 specification with the implementation experience of Microsoft's JScript .NET. After some time, the focus shifted to the [ECMAScript for XML](https://en.wikipedia.org/wiki/ECMAScript_for_XML) (E4X) standard. The update has not been without controversy. In late 2007, a debate between Eich, later the [Mozilla Foundation](https://en.wikipedia.org/wiki/Mozilla_Foundation)'s CTO, and Chris Wilson, [Microsoft](https://en.wikipedia.org/wiki/Microsoft)'s platform architect for [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer), became public on a number of [blogs](https://en.wikipedia.org/wiki/Blog). Wilson cautioned that because the proposed changes to ECMAScript made it backwards incompatible in some respects to earlier versions of the language, the update amounted to "breaking the Web," and that stakeholders who opposed the changes were being "hidden from view". Eich responded by stating that Wilson seemed to be "repeating falsehoods in blogs" and denied that there was attempt to suppress dissent and challenged critics to give specific examples of incompatibility. He also pointed out that [Microsoft Silverlight](https://en.wikipedia.org/wiki/Microsoft_Silverlight) and [Adobe AIR](https://en.wikipedia.org/wiki/Adobe_AIR) rely on [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language\)) and [ActionScript](https://en.wikipedia.org/wiki/ActionScript) 3 respectively, both of which are larger and more complex than ECMAScript Edition 3. &gt; --- ^Interesting: [^List ^of ^ECMAScript ^engines](https://en.wikipedia.org/wiki/List_of_ECMAScript_engines) ^| [^InScript ^\(JavaScript ^engine)](https://en.wikipedia.org/wiki/InScript_\(JavaScript_engine\)) ^| [^ECMAScript ^for ^XML](https://en.wikipedia.org/wiki/ECMAScript_for_XML) ^| [^KJS ^\(software)](https://en.wikipedia.org/wiki/KJS_\(software\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqjyspg) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqjyspg)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Damn. And I was so proud of that joke.
I swear these recruiters are paid commission or something. I have never run across people who are so overzealous in my life. I'm looking for a job now, and at first I thought it was pretty cool (hey, look at me, I have marketable skills!) but now I realize I'm just being harassed by idiots
Babel is awesome :)
Probably wouldn't hurt to know both.
Hi :) Welcome to reddit! `gulp.dest()` targets a _directory_, not a _file_. So, you probably want: gulp.task('prefix', function () { return gulp.src('style.css') .pipe(autoprefixer()) .pipe(gulp.dest('dist')); }); In other words, put the 'compiled' files into a 'dist' directory (or assets or w/e you want to call it. You can even just say '.' if you want). Anyways, you shouldn't be trying to autoprefix a file and then overwrite the original file. Typically most people 'src' files from a 'source' or 'build' or 'src' directory in their project, and output them to a 'dist' or 'public' directory ("finished" files actually served to the end-user). Here is an example gulpfile for a static website :) I use LESS instead of SASS and I dont use that autoprefixer plugin, but it should hopefully provide some use :D https://github.com/erulabs/erulabs.com/blob/master/gulpfile.js Edit: You'll notice there is no `dist` directory in my repo - thats because it's ignored by ".gitignore" which avoids messy commits. On deployments, I simply `COMPRESS=true gulp` and get a highly compressed build! In development `gulp watch` spawns a development web-server with live-reload and uncompressed files.
 var gulp = require('gulp'); var sass = require('gulp-sass'); var autoprefixer = require('gulp-autoprefixer'); gulp.task('sass', function () { return gulp.src('./sass/main.sass') .pipe(sass({indentedSyntax: true})) .pipe(autoprefixer()) // pipe the result direct to autoprefixer to prevent read and write operations .pipe(gulp.dest('./css')); // put your destination here, if you want to rename it look out for gulp-rename ;) });
If you are interested in signing up (which I think I am going to do after poking around a bit) he's got a 15% off coupon on his twitter feed.
I've been learning a lot from Kyle Simpson's series of books called **You Don't Know JS** Available free online: https://github.com/getify/You-Dont-Know-JS
I think we're coming closer and closer to this. Websockets, webgl, asm.js really helps. Runescape already has a beta for html5 mode (webgl), it has better performance, larger view distance than their (old) java (software?) renderer and nicer shading/lighting effects.
i don't get it, this isn't anything new, and it's scrolling too slow.. but it's nice though
I hear ViScript is better.
Nice! will have a look at that. 
Thank you both so much! Reddit is amazing!!! (much better than the network with the S and the O...) Very insightful information! This fixed my issues and some future questions I had (especially the constants, amazing!). You both get a hug!
Turn your sound up. 
Yay! `const` and `let` are _very_ nice, but be aware they're not available in node.js. You'll need to use [io.js](https://iojs.org/en/index.html) for that. Incidentally, it has much better windows support too :)
I'm just happy when they remember to replace the name in their form letters. I get a lot with the first name of another person.
I know the feeling. I'm on LinkedIn. I post on a lot of tech forums. I keep a portfolio and a tech blog. A github account. My inbox should be full of spam! I get maybe one recruiter contacting me a year. I'm happy with my current employer. Haven't had any issues when I am job hunting with finding opportunities. But I wouldn't mind having someone call me to fluff up my ego once and a while.
what would you use instead? 
i hear now.. it's cute
How could this speed anything up? Or how do you use it? 
How does everyone pronounce this? Do you say "E-C-M-A script", or " ekmuh script"?
I haven't even clicked on the page but based on the error message alone.... Off the top of my head I'd say that "window" has been scoped or altered or scrollTo is used without two parameters. At least that's where I'd start before I jumped to browser version. **Edit:** It works for me too but looking at the code it's using an anonymous function, passing no parameters. I'm guessing it's not strictly necessary but I've also been in the habit of passing "window" into anonymous functions that use it. Perhaps it is required for some browsers? Anyone with more experience/expertise on anonymous functions may be able to shed some light but that's the only thing I can see that'd lead to window.scrollTo is not a function. I mean technically the line is window.scrollTo(0, easedPosition); easedPosition is a variable set just above. I'm not sure what the error message would be if easedPosition was 'NaN'. But I doubt it'd be 'not a function'. **Edit 2:** Technical term being: Immediately-Invoked Function Expression (IIFE).
Most worthless feature I'm seen in a while. Good job.
Unless you say "Doovdeh player", it's pronounced with ECMA spelled out, followed by the word "Script"
It depends on how much fluff is in your resume, where you decided to post it, and which recruiters you gave it to. For example, there's recruiters for recruiters. These guys who can barely speak or understand English, and they just harvest resumes, give them to actual recruiters, and then take a small cut. It also depends a bit on whether you contacted all your recruiters when you finally found a job. Make sure you do this btw.
Yea, thats how i pronounce it.
Works for me on chrome and firefox. I'd think that indicates it's a browser version issue. Maybe `el.scrollIntoView()` or whatever that rule is should be used instead?
Credit where credit's due. I started laughing hysterically at the office.
Well, I didn't mean to imply that the bug wasn't specific to a certain browser/version. I just meant that I doubt /u/kilkonie is using a browser where window.scrollTo is not a function. **Edit:** I really am not sure but my guess is still a scoping issue. var f = (function() {'use strict'; console.log(window); })(); I'm just not sold that 'window' will be what you'd expect in every browser here... It may be fixed if it was: var f = (function(window) {'use strict'; console.log(window); })(window);
Interesting, two different answers. Now to see which ones gets more upvotes.
From the Broccoli.js site: &gt; The asset pipeline for ambitious applications. So, I'm using it also for not-ambitious-applications. Even if you are just building a landing page, you'll still need to import third party files, use CSS preprocessors, minify etc. &gt;How could this speed anything up? It speeds up builds. That should be reflected as increased productivity. Some may say "I have Grunt, so..." and I'll tell them, Broccoli is a grunt plugin you still can reap benefits out of it.
This would probably explain it then. All my hires have been through one-on-one networking or via directly contacting a hiring manager at a company. I've never gone through a recruiter or seen a need for one.
I can't see any issues there... window will be window even inside the anonymous wrapper. 
That'll be tough on that test library.
Angular 2 hasn't been released. It's not stable for any development as of right now.
so you put an easing curve on a mind-numbingly-slow scroll to top and thought that was worth packaging up?
I'd just like to point out that while languages themselves are different, they both are moving in similar direction: creation of a platform. Quite a few languages target JVM and get all the portability and performance benefits while looking nothing like Java (e.g. Scala, Clojure, Ruby via JRuby, Python via Jython, etc.) Similarly, while I don't know of a case when someone targeted JSVM itself, more and more languages emerge that compile to JS, while looking nothing like it (e.g. TypeScript, ClojureScript, Elm). We see a good progress on asm.js from all engine vendors, so I think it's just a matter of time until we see JS officially becoming a platform more than a language.
Damn it - noticed in the stats that 50%+ of visitors were on mobile and tablets (I mean, I know I should have known that - but I didn't think about it for this toy!). So I added touch, and a weird ["exponential geometry removal"](https://github.com/mrspeaker/explostyx/blob/b1fe952c550bbee247e28e40e669c6d1056818dc/explostyx.js#L108) thing if CPU is having a hard time ;)
Heh.... I got the following on Friday: &gt;"We are currently seeking for additional workforce that helps propel our company onward particularly Company Nurse/Managers/Sales Representative/ Architect &amp;Mechanical Engineers/Funeral Directors/Scientist/Biochemist/Psychiatrist and IT Managers." If they are recruiting all those roles for the same organization, is it SPECTRE ?
Have any ad-blockers?
Have you checked your sarcasm detector? I think it's out of batteries.
I don't know what I was expecting, but it wasn't that. Many laughs had. Well played.
&gt; If they are just syntactic sugar you could argue they are entirely unnecessary. That indeed was my angle, yes
And now, they will negotiate your payrate....
Latest version of Chrome -- but it was an Ad Block issue. Strange how it manifests itself.
Very nice demo Matt. Maybe you could zoom it in a little though as most of my screen anyway was just empty space. Also, it would be nice if there were a little explanation of the techniques being used in the demo for those less familiar w/ them.
I fucking laughed too. Well done. 
&gt; my management is somewhat skeptical and prefers hashbangs. Why? Unless your project has to serve an HTML4 audience, I can't imagine why someone would prefer a hack over a standards-based approach. The HTML5 spec is stable now, so there's no worries about changes.
I would totally use this just for the comical value
Doesn't seem to work on IOS 6 Safari
Why using `run-sequence` with only one task?
This is really awesome, nice work.
&gt; I click the link **then** fill the fields in that website Pass it over as a querystring, pick it up on the other site and do the appropriate actions. Mostly won't be able to control the other site from the first using javascript, if across domains, frames or browser instances. With some caveats, pub/sub, websockets or whatever.
Timing wouldn't be an issue with websockets
Id say learn each of the components separately, then use them together rather than trying to approach the MEAN stack as a single entity. Check out all the alternatives for each component too, MEAN might not be the right combination for what you're trying to build. It's not a one size fits all technology stack. 
Instead of scanning the page for audio files, can't you just tell the player to play 'this' audio file? That way you only have to initialize the player once.
I was going to complain that it doesn't work on Firefox (*), but I'll give it a pass. It's really nice :) . ^(* It complains that the Soundcloud stream cannot be decoded.)
Yeah, I don't really make any real use of run-sequence there. I suppose it was a bit of a habit - as I commonly find myself needing it for more complex tasks (like upload after build, etc). You're totally right though, in this case, totally needless :)
I guess for your site it would be better to use an array of filepaths to sounds as the player queue. When a new song is loaded in your page you push it to the end of the array and when a song is finished playing, you pop it from the front of the array.
I never worked with .xls but if you have the new excel with .xslx then it's just a basic xml document and it becomes easy to read. Or convert it to csv
Firefox 37.0.1 on mac working and playing fine, 37.0.2 working too
I don't know that the built in functionality of this tool accounts for your use case. If you look in the source code for the init function you can find the section of the code that is populating the playlist using the elements of the page. You could hack around with this code to get it to modify the playlist without needing to start the player from scratch. EDIT: Btw, line 706 of the source appears to be where this work happens.
With the amount of data that would be streamed over the websockets, it would be. Websockets are nonblocking, yes, but the load from them alone is enough to make the browser too sluggish to render a 3d Azeroth.
Went until: broccoli serve # visit http://localhost:4200/ Nothing to see under the URL and terminal processes are running and don't let me stop with Ctrl-C! ???
Must be my setup then. Doesn't like MP3, it seems.
Mp3 is a proprietary codec so it doesn't come built into Firefox or chromium but will use the operating system's decoder. This will only cause issues if you're using an os that doesn't have mp3 support built in (Ubuntu, Etc...) but you should be able to download the decoders and it will work fine
Agree with a lot of this. I also think dependency injection paired with sinon stubs is often a better solution than proxyquire. Then you can easily stub something for just when you need it reset to normal immediately after. Not sure how I feel about mocking in E2E testing though. I'd like to think that E2E testing is the final step before shipping to QA or deployment. Otherwise I'd probably rather call it an integration test or something.
Haha, `new Egg`
No you don't need all the 15GB... but you'll surely need more than 1GB - and the next one when you start phasing into the next area, which is a bit of an issue for the client, if not for the CDN.
Nope, but you can convert the XLS to CSV and then parse by commas!
window would be part of the closure created when running that anonymous function, so it should definitely be in scope.
That is fucking lol funny.
The textures alone for a zone in Draenor are more than 30mb. Sure, you could optimize quite a lot, but there's still a lot of stuff, models, animations, icons, etc. Also, don't forget the phasing. Sometimes, there exist different models for the same zone. You'll have to have them ready if the player approaches the phasing zone. But anyway, I'm not saying it's completely impossible, just improbable at the current moment. I believe that a Linux client is much more plausible - yet. Wait 1-3 years and this picture might change a lot.
I quite like the idea of this. I agree that there's nothing wrong with jQuery as such and who knows what we ever did without it, but the biggest selling point is the selectors and chainable methods, which this has. I see this as being more suitable where you have a site with heavy DOM manipulation, where you would no doubt benefit from the performance improvements.
And after that, I'd recommend the excellent but seemingly overlooked [Javascript Allonge](https://leanpub.com/javascript-allonge/read) and [Javascript Spessore](https://leanpub.com/javascript-spessore/read) as ways of delving into some serious functional programming and object oriented programming.
That's a very different way of looking at it. While an interesting theory, you'd disregard the fact that authors are very different in the way they go about actually teaching the material; some better than others, I'd say.
So there is, in fact, a period on the bottom left, correct?
Do you have a specific question, or are you hoping someone will do your homework for you?
&gt; Egg.js is a simple JS library that has **no prerequisites** ..but it uses jQuery.?
lol
I'm a JavaScript developer but I believe it reminds to Java for two reasons. - TypeScript is very Java &amp; C# alike - InversifyJS is highly influenced by a popular C# IoC container (http://www.ninject.org/) 
&gt; This had better be worth it. It wasn't.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \^ That is the pattern OP is trying to make.
The correct pattern is below I posted from my phone so I'm pretty sure that is what messed it up.
My question is how do I do this. I don't want the code. I want for someone to explain to me how I should make it.
agreed, those lines look naked.
What part of the MEAN stack is even safe/worth learning at this point? NoSQL hype has died down a lot since relational databases are more reliable, can easily be faster, and the best of the best, PostgreSQL supports "documents" if you really needed. I've been seeing more new projects pop up using Koa and other frameworks over Express to ameliorate (to a degree) callback hell with generators and a different way to do the middleware. Angular is arguable a mess currently in its version transition and using React or something else with virtual DOM for your view layer is a more declarative, more performant, and has no garbage all over your mark up. With the fork of Node to io.js, how can you really feel confident in learning either for production code when the growing pains haven't subsided? /2¢
I like the emphasis on speed and lightness, but really the biggest reason jQuery is useful is for browser support. If this only goes down to IE10, why wouldn't I just use vanilla?
 var count = 0; for (count; count &lt;= 100; count++) { var value = count; if (value % 2 !== 0) { value = value + "!"; } console.log(value); } You could also get a little fancier var numberArray = Array.apply(null, Array(100)); numberArray.map(function(value, index) { value = index; if (value % 2 != 0) { value = value + "!"; } console.log(value); return value; }); 
 Array.apply(null, Array(101)) // because arrays are zero based .map(function(_, id) { var item = id % 2 == 0 ? id : id + '!'; console.log(item); });
As /u/spartantreyu recommended, what you want to do is create an array of songs separate from the loading, when songs load it adds them to the array. You're creating a collection of song models, or a playlist model. 
When working with RDF what query system do you use? SPARQL? I am curious to know if there are alternative query mechanisms for RDF out there.
The low bar of entry. Getting into javascript is easier than other programming languages. No compiler to download, no environment to set up, no ide, or cli to get familiar with. Just open up your note pad, save a file and point your browser at it. This, I find, to be both a good thing and a bad thing. Both sides for a lot of the same reasons. Easy to get started is great! But then you get a lot of people who don't know what they are doing asking things they should google of so sites. EDIT: decided to go on a bit more ------ The problem I have with such easy access is it produces a lot of JS devs that don't know JS as well as they should. This leads to a ton of stereotypes and assumptions about JavaScript and JS devs. u/achen2345 put it perfectly in some of his [bullets](http://www.reddit.com/r/javascript/comments/33hl9b/we_love_javascript_but_what_bugs_us_about_it/cqkypnp). 
Its indecisiveness about whether it wants to be functional or OOP. Or, maybe, to put it another way, the way OOP syntax is bolted onto a functional language. It makes it accessible to a wider audience, but also turns it into a Frankenstein. Do one thing and do it well...
 false &gt; 0 // false false === 0 // false false &gt;= 0 // true
Care to explain your throught process?
Why not do something like, take your current implementation and turn it into an extension which overrides the in-house jQuery functions. That way you retain the API as is, but it uses the much slicker and faster Sprint methods.
In case you're curious - this is as example of the classic type coercion 'feature' that lots of people bitch about. Use of any of the default comparison operators (`&gt; &lt; &lt;= &gt;= == !=`) in javascript will result in automatic type conversion. The two 'strict' comparison operators (`=== !==`) are special and they basically equate to shorthand for `typeof a == typeof b &amp;&amp; a == b`. You're basically asking... 0 &gt; 0 // false typeof false == typeof 0 &amp;&amp; 0 == 0 / /false 0 &gt;= 0 // true
Proxies might allow you to recreate some fancy OOP soon.
Weak typing, specifically with regards to function signatures. The fact that you can leave off arguments, etc.
/r/LearnJavascript or /r/learnprogramming is a better place for these kinds of questions. 
Have you ever used anything like [ring.js](http://ringjs.neoname.eu/)?
I'm a windows user and I 've uses grunt and bower and yo for the past couple months. I've never had a PATH error after installing globally, so...in what scenarios would I care to do this? Also, having to move globally installed packages each time you install something globally sounds like a pain in the ass...
* No native module system =&gt; reliance on 3rd party tools or (shudder) globals * `this` being bound to `window` in nested functions * No `Array.prototype.contains` * Syntax for prototype-based OO is verbose and ungainly * Type coercion gotchas (including how `==` works) * Optional type checking would be nice * Callback hell is a problem when you're doing a lot of I/O, no matter what js apologists will tell you. Promises/generators or async/await will hopefully help with this Thankfully the first 4 (and maybe the last one) are being fixed in ES6/7
jQuery is built like that to some extent already, though not down to the level of a "builder". It sounds like a great idea, but I suspect that it would be rather difficult in practice. I suspect that jQuery already runs as lean as possible, whilst still offering compatibility and supporting its plugin ecosystem and existing feature set. The author makes it clear that this library is for a different use case to jQuery and I can see how it may have its uses. 
Lack of a built-in unique() method. Easy enough to patch in, but why can't standard array library include it?
OSX comes with Python and Ruby preinstalled, that I'm sure of. However, VBScript and JScript cannot be considered good platforms to start learning programming from - they operate mainly on obscure COM APIs that don't have good documentation, and are also underpowered.
How everybody feels they need to reinvent the wheel by making their own library/framework. undefined is not a function
Makes sense. But looking at this code, I just dont get it. 
Project has been around for over a year, has 1000+ stars, but there are only 6 total issues (4 open, 2 closed, none of them code related) and no PRs? Either the code is perfect and bug free, or nobody is actually using it, not sure which is scarier. Either way, performance metrics look impressive. Surprised to see zepto behind jquery in a lot of benchmarks. Would be interesting to have an overview of what makes it so fast. It's gotta be more than just using newer APIs, since jQuery/Zepto can easily feature detect and use what's available...
People who code JS and insist on having private members to their classes. Unnecessary hacks. Python gets by just fine without hacks and workarounds to get private members. JS Scoping is counter-intuitive (and that's putting it lightly): var myClass = function() { this.x = 1; }; myClass.prototype.doStuff = function() { this.x += 1; console.log(this.x); }; myClass.prototype.startToDoStuff = function() { setTimeout(this.doStuff, 1000); }; var myInstance = new myClass(); myInstance.startToDoStuff(); console.log will output NaN. now, functions are first class citizens in JS, so what's happening is that you're passing an instance of Function to setTimeout, and *this* becomes scoped to that instance, rather than the instance of the class that called setTimeout. Various languages can either handle this scoping in an intuitive manner, or have specific constructs for this scenario. Javascript has people encapsulating functions within functions after assigning the value of the *this* they want to something called *that* or *self*. myClass.prototype.startToDoStuff = function() { var self = this; setTimeout(function() { self.doStuff(); }, 1000); } that'll do the trick. Annoying, ugly, counter-intuitive, but it works. *sigh*
Everyone's audience is different. A lot of my workplace's clients insist on support down to IE8, and some want IE7, based on their market segments.
If you find answers please let us know :)
I don't think Douglas Crockford has written anything about this practice specifically so I can't point to anything there, except for his statements that since variables have function scope instead of block scope you should declare all your variables at the top of the function to avoid confusion. My only criticism is that you're sacrificing readability for zero to minimal benefit. Although I've heard in other languages this style of for loop may be more common, so there may be cases where it's okay (if you're the only one looking at the code, or if the majority of developers in your team are familiar with this style). The rule of thumb is usually to favor code readability over very minimal gains in initial development or performance. I would think even if you're familiar with putting a bunch of stuff in one for loop, even for you it would be quicker to understand what's going on when looking at nested loops instead.
A cursory glance at the repo will make it pretty clear it was just finished. The documentation is brand new. It has 1,000 stars because it's been in all likelihood passed around a lot today and starred by anybody who sees it (like me).
I wish there was a comprehensive list of jQuery features (apart from browser-support) that are **not** handled by Sprint. I notice a distinct lack of ajax functions, and I only assume there are other major omissions. It *does* seem like this goes beyond just a *Sizzle* (jQuery's selector engine) replacement, as it has some event-binding and other utility functions. My impression is that this is pretty neat, but I would probably never use it. I'd use jQuery when browser support is important, for quick/dirty work, or where perf isn't a huge issue. Otherwise, I'd likely just use vanilla JS or write my own abstractions as needed. This source code would be a great reference for learning how to build such abstractions. I read through a bit, and its quite nice and understandable.
&gt; undefined is not a function (function(undefined) { //Your code here. Now undefined IS a function. })(function() {return "where is your god now?"})
Hacks Write good JS code, transpiling is just a clever way of not fixing real problems ;)
Sure, but I'm not sure how "strict typing" really relates to the "functional vs. OOP vs. a mix of both" question. You can always use Typescript if you want strictly typed JS.
I'm one of those people who believe that it's totally okay if the first language is kinda crappy. Even something like BASIC is totally fine. Variables, branching, loops, and "functions". Simple stuff. I did stuff like plotting a sine curve and letting you draw on the screen with a gamepad. That was fun. I then did a whole lot more of that with C. That was even more fun. Any language is fine, really. You can get your feet wet with any of those.
sorry, I must have misread your comment. But as for functional vs OOP vs a mix of both Better to be a master at one thing, than mediocre at many things.
I think Sprint benefits from taking out the code that allows jQuery to run on older browsers, and that's where a lot of the speed benefits come from. That and it's smaller file size because it does less.
It doesn't have to be a person new to programming. JS gets thrown into the hands of people who don't want it because of how quickly ( and essential ) is is integrated into projects. A common example of this would be a great Java dev, real good at his stuff, working on the backend of a web project. Java is his focus, but out of necessity he tackles some of the front end stuff. Easy to do, HTML is just markup, after all. CSS? psh, nothing an old google can't show you how to do. The next logical assumption, is JS won't be to hard to tackle either! Java dev does the best he can, and it turns out okay, now he is a JS dev too. Java dev's JS makes it pretty apparent he doesn't understand the nuances of the langue (nor the nuances of css/html, that is an even bigger pet peeve of mine) and since it works, he probably won't spend time trying too. After all JS isn't his focus, JAVA is. So another lack luster JS dev is spawned, one who will probably continue to use JQeury &amp; bootstrap for all the things because it works, is easy and he doesn't really want to focus on it any way. 
"No stack traces in a globally accessible location. If you want anything close to a stack trace you have to put a try/catch into every event handler, which is not acceptable." +1, i really wish there was async error handling in the browser (like domains) but also taken a step further so that you can do async error handling with something like a domain but not have to kill the javascript VM immediately afterward
JS was my first programming langue. There have been a lot of times I was grateful I started there.
Here is the most useless answer I came up with: for(let x = 1; x &lt; 14; x++) { console.log('* '.repeat(x &gt; 7 ? 7 - (x - 7) : x)); }
You can spare that hack (var self = this) by utilizing Function.bind? ever tried it?
&gt;We love javascript I think you're making assumptions there :) I dislike that it's the only option for 90% of what it does. If there were some alternatives, I believe the competition would vastly improve web development.
The Java name.
Thanks Gelus. I will look into these. I am sure there are likely helpful developer tools features to try to fill some of this gap that I am simply ignorant about.
I just started dabbling in transpiling with babel. I really enjoy the ES6 additions and cannot wait for the day when we don't need to transpile. I think coroutines are really awesome and implementing them in javascript seems like a great solution to callback hell
Defining multidimensional arrays. What a Kloodge!
&gt; undefined is not a function You should get something more descriptive in Chrome now: https://plus.google.com/+AddyOsmani/posts/DdWkiKsvbA2
I'm using coroutines (generator + promise) now with babel + bluebird and I think it's freaking awesome. I came from python where generators have been around for years so it feels very natural and awesome to me.
Speaking Javascript by Axel Rauschmayer. http://speakingjs.com/ One of the best programming books I've ever read.
Bind is prettier myClass.prototype.startToDoStuff = function() { setTimeout(this.doStuff.bind(this), 1000); }; "this" is pretty weird in JavaScript 
"A complete overhaul" implies you'll en up with a different language. Why don't you simply forget about Javascript and *use* a different language. there are hundreds to choose from, or you can create a new one. Good luck.
well, TIL bind is much more acceptable
To Gelus point you might be able to download and install Java easy enough. Then there is a compile process that follows a build process and dependency/check-in process. Any similar processes that exist in JavaScript applications are not required and are fairly shallow, when present, in comparison. I think you are getting downvoted not because you right or wrong, but because you have drastically oversimplified the comparative development ecosystems which really goes to entry barriers and immediate fulfillment. You are right that I can open a command line in Windows and execute cscript, which will execute JavaScript. Bam, immediate gratification. Can I just type code into a command line and just execute Python or Java into qualified output without a second step?
hah, not a lot of options, if you're working in the browser :P
No doubt, both of them are awesome but they are not a replacement for a good understanding of the languages. Don't get me wrong, I'm not trying to knock either product. 
There is a lot of talk about the pace that the whole ecosystem is moving at right now. Each new framework replacing the previous at smaller and smaller intervals. It is worth considering that if what you've got works for you, then maybe it is good enough.
Thanks. I've been digging through it and I think I understand whats going on, its just confusing how its pulling all of the links. When I load the site and look in console, it says that it finds x number of audio files.. Maybe im not calling the new function properly. 
The frameworks evolve waaay too fast. But the language itself never changes.
hah, bad developers aside then :P JS gets integrated into projects so easily that people who don't want to be doing Front end work get stuck with it out of necessity. I gave a decent outline of what I'm thinking of [here](http://www.reddit.com/r/javascript/comments/33hl9b/we_love_javascript_but_what_bugs_us_about_it/cql32c3)
hah, so you're one of the devs that was forced into it, that I was talking about before! I like JS a lot, ES3/5 included. ES6 is exciting and hold a lot of sweet new stuff. All the same I can't say I disagree about the tooling comment.
If it's just commas, you can just split by commas.
floating point arithmetic makes javascript completetly unusable for some applications. I wish ECMA would drive the introduction of DEC64 instead of classes.
I did this once when i was fucking tired of seeing that then forgot about it. a week later i see "lol dumbass" printed to my console and i was pretty confused...
Agreed :)
The ecosystem of build libraries is simply insane. Gulp and Grunt come all with thin layers on top of libraries like jshint or browserify instead of providing a means of using these tools directly. You'll face a plethora of NPM packages.
Me too, it's one of the things I like most with JS. Depending on what you are doing, you can go functional, OO, or (usually) a mix.
* Scope * Modules * I want a bigger standard library. Standard across browser and node.js. * I want real structures and arrays. Adding functional features is always good, but for me having access to lower level things is way better.
Your \n's need to be inside "" and you have a trailing " after email that shouldn't be there.
At the top you have `var txt;`. Then at the bottom you have `...innerHTML = txt;`. And if `result` is true, `txt` is never set, so the ultimate value to show up in output (even though it may have been set to the correct phrase earlier) is the value of `txt` which is undefined. You probably want the first set of output in your `result == true` block to be a `txt = ` instead.
&gt; Poor tooling That's a pretty broad brush. I've found JS tools to be a mixed bag. So, Bower is okay. Yeoman is convenient for some people, and overkill for experts, but overall its not a bad guy. Little tools like 'bowcat' are a-okay with me. NPM, on the other hand does alarmingly hacky things to resolve dependency graphs (spoiler: it does no such thing and nests libs inside libs instead) which raises questions about build repeatabilty, etc. My favorite is that when installing PhantomJS from NPM, it tries to *download support binaries inside its install script for you*; that's a giant no-no for software packaging even if it's convenient. Don't get me started on Grunt and Gulp. Edit: &gt; And silly things like having to add "'use strict';" While I dislike the lack of a more positive control (like setting an attribute in `&lt;script&gt;` or a flag on node) for what JS grammar you're targeting, I appreciate that there's at least some way to pull this off. What baffles me is that the use of a string in this way smells of backwards compatibility, yet its presence implies backwards incompatible stuff. Also, [introspecting strict mode at runtime](http://stackoverflow.com/questions/10480108/is-there-any-way-to-check-if-strict-mode-is-enforced) is anything but straightforward.
technically you don't want to use `var` again for `txt` since you already declared it at the top of your function. Also the extra `document.getElementById("output").innerHTML = txt;` isn't needed because you already have one at the bottom of your function (and I'm assuming your not meaning the one in your example above to be the same). The newlines are correct in the quotes as you have them. However, they are only going to affect your source code. If you want them to show up in the HTML you need to use html line breaks `&lt;br/&gt;`.
Worse than weak since its interpreted. No compiler, no help, it will fault at execution time instead of compile time which makes it all very hard to trust and guarantee a robust behavior 
JavaScript has some really awful corner cases: * `arguments` is not a proper `Array`, but it pretends to be one most of the time. * `this` isn't `this` on your function except when it is, but not unless you override it *anywhere else in the program*. * var hoisting, or scoping rules in general * bizarre truth-table circumstances * implicit conversion of `{}` and `[]` into numeric and boolean values This is all exacerbated by the lack of any kind of static analysis of a compilation unit outside of "does this compile as a valid ECMAScript expression?" So all of the above are not made aware to the developer until your code is already running, or you pile on additional tooling. The need for extra stuff (linters, transpilers, etc) isn't the problem; I use them just fine. The problem lies in that those things are *optional*, which can allow nasty (easily solved!) bugs even in well-used libraries. And the last one that the community kind of did to itself: * Heroic levels of JS tooling that solves problems that could have been met by adopting a newer version of ECMAScript in the browser. The level of effort that has gone into this ecosystem could have been spent on submitting patches to Mozilla, Chrome, or just forking it and proving things out with some high-profile experiments. We wouldn't even need to make existing stuff backwards incompatible, just add a new `type="text/baddass-js-version"` attribute on your script tags, and off you go. The same goes for node: just make the new one 'node6' or something similar. In the time I've seen `node` hit the scene, this could have been done at least three times over by now.
* it's particularly hard to track down memory leaks in long running node.js programs. * it's not really possible to make an asynchronous function synchronous. * too much tooling... npm, bower, grunt with plugins, etc. * some errors that a statically typed, compiled language would identify at compile time, can only be identified by brute force (100% test coverage in combination with static analysis tools like jshint). * there aren't a lot of standard ways of doing things (logging, errors, modules, unit testing, frontend frameworks, etc). It's different between different projects. Different libraries/tools are going in and out of fashion rapidly. This makes it painful going back to a code base you haven't touched in a year -- so many outdated patterns, unmaintained dependencies, or dependencies with API breaks. * major updates to node's v8 engine break the C/C++ bindings. You either have to constantly update your native modules or use macros from nan. 
hey thanks for providing a resource, I'll dig into this
Since promises are part of the ES6 spec I think you should go for a pure promise polyfill. The only thing I would add on top is a denodeify method for converting node methods into promise returning methods. If you are using io.js or transpile then I would also look into co, which is pretty much how async/await will work in the near future. 
And what is the objective here? To find if a boolean is larger than a number?
That Backbone story is a nightmare. But it would be just as possible to have broken behavior in a module where many other modules depended on the broken behavior.
There are other options. I recommend reading You Don't Know JS on [this subject](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes). 
&gt; That's a pretty broad brush. I've found JS tools to be a mixed bag. "Tooling" is a somewhat odd term which refers to the evidential "toolability" of the language itself. So, basically, the things existing IDEs/editors can do to help you. Things like call-tips, type inference, checking the supplied arguments, go to definition, refactor/rename, and so forth. As things are today, even if you add those bloaty JSDoc comments everywhere, you get very little in return. Even the simplest errors aren't identified. You also have to check the docs all the time, because your tools have very little to work with. One of the main reasons for having to check the docs is that there is no declarative way to specify optional named arguments. So, if you want to know which 30+ options can be handed to jQuery.ajax, you have to visit its website. ES6 unfortunately didn't fix this. While you can now use destructuring in the parameters position, it isn't declarative. The default values aren't compile-time constants. You can put entire programs there. It's completely useless for tooling. To make matters worse, the syntax is super hideous: function foo({foo = 'foo', bar = 'bar'} = {}) { ... } But it doesn't stop there: function foo({a = 1, b = 2, c} = {c: 3}) { console.log(a, b, c); } foo(); // 1 2 3 foo({a: 'a'}); // a 2 undefined foo({c: 'c'}); // 1 2 c Exhibit #2: function foo({length = 2} = 'foobar') { console.log(length); } foo(); // 6 foo({length: 0}); // 0 foo({x: 'x'}); // 2 Recycling the destructuring syntax for this was a terrible idea. Even these seemingly simple examples are a complete disaster. &gt; yet its presence implies backwards incompatible stuff. You will be able to use let/const and classes without the "use strict" pragma in the future. Having to opt-in like that is temporary precautionary measure.
The Python guys took the jump but the adoption push is still ongoing. It's a long and painful journey. I think compile-to-js (with sourcemaps) is a more likely path to eden.
I'm guessing this part &gt;Or, that time when I couldn’t even install a package because the file name for a file within the package exceeded the allowed length by Windows! but I've never experienced that or a PATH error. Windows users should probably be using nvm-windows anyway. You get to choose where to install the nvm folder and each Node.js version you install gets it's own folder inside \nvm So if you install into \Program Files the packages should be there too instead of \AppData\roaming Then you don't have to bother messing with the PATH variables or having to manually move a package each time you install globally. You might run into permissions problems (requiring admin level console each time to install -g) if you install nvm into \Program Files though
I guess the lack of a type system is what has forced the JS to embrace testing for everything which is, in my opinion, a better solution to catch errors when refactoring. I test everything now and it will catch more than just a wrong type here and there. Not that I wouldn't sometimes like the help of a type system.
&gt; The select statement generated by the .publish method will be the data used to populate the client. Once that data is published it cannot be modified until the server is reset. Any further pagination and or data modification will have to be done client side. I may not be reading this correctly, but how is this reactive?
Unordered lists are a bit more complicated. Assigning the HTML output to another textarea is minor. I updated the fiddle to createElement instead of using strings. It should give you an idea of how to proceed to make a rough prototype. http://jsfiddle.net/malwinsc/Lpc1uLeq/ Oh yeah , sign up for an account at jsfiddle.net and you can fork the code and have it for future reference from your jsfiddle dashboard. * edit Just realized you posted this under /r/javascript , should post in /r/learnjavascript in the future. It's more of a place to ask for help.
...I kinda like it.
Yes. If I'm playing music on the speakers of the computers, that would be the audio output.
This is a bit too convoluted for what I want. I'm simply trying to create an audio visualization from the computers output. 
to be fair, most languages have the same problem with floating point numbers. someone out there wrote a decimal library for Javascript though, look that guy up 
I'm going to have to disagree with you about setting up an environment if you want to do anything that's non-trivial. 
It does my heart good to hear this coming out of some one else's mouth. I continually find it isn't as common an opinion as I think it should be.
do you count pre-compilers as options? If so there are plenty of them!
This, I agree in every way imaginable on every plain of existence from all frames of references in all universes from any multiverse.
Really? What do employers generally expect of JavaScript developers?
&gt;its just confusing how its pulling all of the links It's right there [in the readme](https://github.com/zirafa/pushtape-player.js/blob/master/README.md). These are keys on the object passed into the pushtapePlayer.init method: containerClass : '', // If empty, scan entire page for audio links. If set, limits the scope of search inside containerClass linkClass : '', // By default, add all links found. If set, will only add links with this class You're not passing either of these into the init method, so it's finding all links on the entire page.
&gt; People get around this by using things like Browserify on Node.js/io.js, but the modularity produced by Browserify is then not a runtime compatible back to Node.js/io.js. Huh? Can you explain this a bit? My modules work fine in both Node/io.js and the browser. I would say the state of JS modularity and package management is well beyond that of most other languages. 
Based off some of the code I've inherited I would say sometimes it's as low as being capable of using a keyboard. 
/u/Rezistik and I have both pointed out the addSound method on pushtapePlayer, did you try using it?
What you actually want to get here is a type error. One of the operands isn't what you expected it to be.
People actually want JavaScript to be throwing more exceptions. Not fewer. If it looks like a type coercion, people don't want that kind of thing. Also in other languages people have started adding symbols to help with checking for null values like undefinedObject?["something"] And it would only continue to run if undefinedObject was not null. Or something. But I find it a bit unusual. I'm not even sure how to read code like that anymore. You could also use some kind of helper function to check for code that you find redundant. The JavaScript engines could inline the function's code so in the end it would not cost much performance. Basically that's what people do when they come up with languages on top of JavaScript.
Call and apply have different use cases than bind. Bind returns a function with the context assigned. Call/apply evoke a function with a provided context. You can't use call/apply to provide a callback.
They're faster because they're simpler - they do less normalization and support fewer edge cases. In other words, they're not equivalent, so you definitely don't want to directly replace jQuery methods with them.
&gt; rips off jquerys api Wait what? Are you suggesting that each library should try to make its API unique and original? That would make using libraries an absolute nightmare. I mean, holy shit, it would actually make all of programming substantially more difficult. ... or maybe you're just saying that it's unnecessary fragmentation, in which case I would say it's 100% necessary: its benefits (speed, small file size) are a product of dropping baggage that jQuery can never drop, not adding anything.
that dumb people do it because it is well paid and try to force 80's shit on us because they are over 30 and thus 'senior' 
That's the only way to do what you want in a browser (without the use of plugins).
fuck typescript. i like typed stuff for my models but i hate it for my views. especially from the sith lords of Micro$oft.
As long as the base is turing complete, you can always transpile. I have found Typescript does most of the stuff I want JS to do, without getting in the way if I want to just enhance my existing JS.
The big difference in native sort between Chrome and Firefox is that Chrome ignores return values of 0 from sort functions. The array sort method accepts a function where that function is expected to return a value -1, 0, or 1. If a boolean is returned it is coerced to either 1 for true or -1 for false. In chrome the 0 value is ignored even if explicitly returned. Proof: var data = [ 3, 6, 2, 9, 4, 56, 3, 12, 22, 3, 67, 3, 7 ], sort = function (a, b) { if (Number(a) &gt; Number(b)) { return 1; } return 0; }; data.sort(sort); //firefox - [2, 3, 3, 3, 3, 4, 6, 7, 9, 12, 22, 56, 67] //chrome - [3, 3, 2, 3, 3, 4, 6, 7, 9, 12, 22, 56, 67] To operate cross browser never return 0. Always return -1 or 1. The problem is when nothing is returned, for instance: var data = [ 3, 6, 2, 9, 4, 56, 3, 12, 22, 3, 67, 3, 7 ], sort = function (a, b) { if (Number(a) &gt; Number(b)) { return 1; } }; data.sort(sort); //firefox - [2, 3, 3, 3, 3, 4, 6, 7, 9, 12, 22, 56, 67] //chrome - [3, 3, 2, 3, 3, 4, 6, 7, 9, 12, 22, 56, 67] In this case if two identical values are encountered the sort function returns undefined which is coerced to 0, and so Chrome fails to sort. I always thought that perhaps this was intentional on Chrome's part to perhaps boost its numbers in benchmarks. Clearly my assumption proved faulty and too optimistic. This is clearly a bug and an opportunity for improvement.
word, Devtools has a ton of features. Using breakpoints and pause on exception you can see and explore the stack really well, and use the ajax checkbox to make it more robust. You can also blackbox libs so you don't waste time looking at them. All so so useful.
I've cleaned up a lot of code bases. Those "hyper-paranoid developers" aren't wrong. Those kinds of things do happen and it's not as rare as you might think. I've seen code like: undefined = 42; var x = new Array(mySize);//because "it initializes the array for me" undefined = void 0; As to == vs ===, using === improves performance on older browsers, new browsers before it runs 100-ish times, unoptimized functions (that include innocent things like closures or try..catch statement), or dynamic functions that take different arg types, because === bypasses a bunch of type checks that == requires. Coding standards exist for good reasons. It keeps idiots from screwing up unintentionally and keeps show-off users from making unmaintainable code. Some things may be inconvenient, but strict enforcement of "The Good Parts" is better than a dozen different ways of doing things. I'm very confident that I'm understanding the code when the coder followed these standards. I consider the general adherence to these standards by most larger to be one of the better parts of the JS community.
It was annoying for the entire team, but it was one of the top ten software companies in the world (by revenue). The larger department was huge and well established. It is better to be a team player and be cool about it than try to prove a point even if my small team was far more talented with client-side technologies.
Great points! ES6 will have modules. http://www.sitepoint.com/understanding-es6-modules/
In the future if I need help bsing my way through a job interview I'll let you know :)
Then maybe tell the reader to run it with Node 0.10 (and explain how)?
One reason I think is just that companies need to have different, compatible implementations of JavaScript, rather than to share a single implementation for everything. Imagine it if every browser shared the same implementation. Then it would have been easier to add stuff that all supported. But without that guarantee, they have to try for the lowest common denominator instead. With multiple competing JavaScript implementations, it's difficult to keep changing the standard on a as needed basis. If you came up with a great language standard that still caused some breakage when evolving it, it would be terrible for all the competing implementations to share libraries and so on. Also, plugins have been eliminated from the browsers. Which has made experimenting with new browser languages much harder. Browser vendors have decided that no one of them can come up with any new standard on their own. Anything they do must come from consensus. The moment one of them tries to be too creative, the other ones turn against them. Basically every browser vendor has sacrificed some cows in the compatibility altar so all of them have scars to remind them not to try anything too exciting on their own.
On mobile so you'll have to Google it for some code. What you are looking for is something called setTimeout. You can say 'wait three seconds and then do this thing' and in days thing you can just enough out the text. 
&gt; Those kinds of things do happen and it's not as rare as you might think. Well, don't take it personal, but I've heard such vague claims 1000 times before, and now that I actually have a few years' experience with JavaScript, it just seems like a myth that gets passed down from developer to developer. The good people at StackOverflow were unable to come up with a single example [when I asked about it three years ago](http://stackoverflow.com/questions/8783510/javascript-how-dangerous-is-it-really-to-assume-undefined-is-not-overwritten). If you can actually point to a repository that has this thing you claim happens, by all means add it to that question. You'll be the first.
hasOwnProperty checks. A big reason I use coffeescript is to avoid that boilerplate.
Exactly. And more importantly in my mind, `array.contains` better expresses the intent of the code as you read it.
This one[1] looks like a working driver with reactivity, but the OP has client-side sql. [1]: https://github.com/numtel/meteor-pg
I dislike JavaScript. I dislike it because it's the only thing that runs on browsers and that's the only reason why people are still using it. There are better languages out there. 
What is that amazing color scheme in the README.md !?
The transition was pretty smooth
Yes, at the very beginning of the article it says: &gt;Requirements &gt; &gt; Install Node and npm. &gt; &gt; node -v &gt; &gt; v0.10.38 &gt; &gt; npm -v &gt; &gt; 1.4.28 I think that teaching you how to install different versions of node is out of scope, but I guess I'll mention it just in case. I suggest you use: https://github.com/creationix/nvm
The choice of Bubble sort isn't Chrome's – it's in the spec. Also, bubble sort is optimized for the average case (an already mostly sorted list), not the pathological worst case. Merge sort performs worse in the average case because it has to iterate O(n log n), while bubble is just O(n).
There are a couple of problems with this I'd like to point out quickly: You can have a property name called object. It's done like this: const x = { "object" : "dog" }; Furthermore, while in statically typed languages **without covariance and contravariance** you can't make a heterogeneous list, tuples for regularly shaped data work great. For instance, (Dog, Is, Animal) :: (Subject, Relation, Object) ... is perfectly valid Haskell without relying on Typeable. But otherwise good paper! I've never worked with graph-data before and this is a pretty neat introduction. 
&gt; The choice of Bubble sort isn't Chrome's – it's in the spec. Huh? What spec, and where? The [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11) does not mention Bubble Sort. It says that the sorting algorithm is implementation-defined. Chrome, like other browsers, [uses a variety of sorting algorithms, including ones based on Quick Sort and Merge Sort](http://stackoverflow.com/questions/234683/javascript-array-sort-implementation).
That's not a bug. Returning zero is supposed to mean that the two elements are of equal order, so it doesn't matter how they are sorted relative to each other. Your comparison function returns zero for `f(2, 3)` but not for `f(3, 2)`. This makes in an inconsistent comparison function (it should return zero in both cases, or in neither). The [spec](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11) says that passing an inconsistent comparison function to `Array.prototype.sort` is undefined behavior: &gt; If *comparefn* is not **undefined** and is not a consistent comparison function for the elements of this array (see below), the behaviour of **sort** is implementation-defined.
Perhaps the post isn't clear enough - that the only case it's interested in is worst case. Edit: I've added a note that I'm only interested in worst case. "O(n²) ... and ... O(nlogn)".
It's not a bug as the spec clearly indicates that if 0 both values are considered equal. Mozilla doesn't respect this as this is technically undefined (but still expected) behavior. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
This is correct. The spec states that the values should be compared by Unicode code points. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
That is referring to the initial data set that is sent to the client. Once that data set to the client it will remain reactive, but it will be constrained by the data limitations you put on it. Let's say you asked for the top 100 results. Upon loading the page you will get the first 100 results, but any new results added will also continue to be added to your set, and any changes (updates, deletes) will also continue to be made to you set. This was provided as an option if you were looking to limit the data provided to the client. You can still make all the data available to the client at all times if you choose to do so and that data will be entirely reactive as well.
Smells like shit
&gt; Should Chrome be converting elements to strings, as the default behaviour? I absolutely hate it. The first time I got bitten by it, I was debugging this one issue for two or three days straight (it being a Heisenbug complicated the process, and the possibility that `sort` might behave so idiotically never entered my mind until there was no other explanation). But, unfortunately, the answer to your question is "yes". JavaScript can't change past behaviour unless some pragma instructions are added (similar to `"use strict"`), because the whole web might break if we start fixing the default behaviour. This right here is the sole reason why "JavaScript: The Good Parts" makes sense as a book - JS is not allowed to mutate, only to grow.
The bug is in your code, not in the browser. You're trying to use a sort function that doesn't work properly: it returns `0` instead of the correct value of `-1` when `a` is less than `b`. If you use a correct sort function it works in all browsers: var data = [ 3, 6, 2, 9, 4, 56, 3, 12, 22, 3, 67, 3, 7 ], sort = function( a, b ) { return( a &gt; b ? 1 : a &lt; b ? -1 : 0 ); }; data.sort( sort ); Similarly, your second example that returns `1` or `undefined` is invalid. If you want to provide your own `sort` callback function, you can't just make up arbitrary return values like this. You have to do it the right way and handle all three cases: greater returns `1`, less than returns `-1`, and equal returns `0`.
They're not the end of the world but I'd vote against them if I could.
I hate when these things spam my browser history. 
The greatest programming advice that I ever received was: "Don't be clever." I feel like the same should apply to this presentation. Sadly, the whole "full screen content with custom animations and weird non-native scrolling accelerations" seems to be a trend :(
&gt; if you want to know which 30+ options can be handed to jQuery.ajax, you have to visit its website. The jQuery guys could also just alias the ajax function with a range of more descriptive alternatives. They don't, I suspect, because of filesize though. Filesize isn't normally a constraint in API design.
More importantly for this situation, the issue is his sort is inconsistent: `sort(2, 3)` returns `1` but `sort(3, 2)` returns `0`, so the behavior is undefined and the actual behaviour depends on the sort algorithm. It just happens that Firefox's implementation yields a sorted array for this specific workload.
IE8 doesn't support `function.bind` Source: Waiting to not just drop IE8 support but also not care if our code breaks IE8. I've typed `.apply(self, arguments)` too many times in my life.
undefined is a function in Haskell. :P
Tools like Closure Compiler actually strip 'use strict', too.
The comparison behavior, not the algorithm.
It happens in every language. Remember "goto fail" and how it would never have happened if Apple used braces around every if statement?
Likely because the resulting language won't run in web browsers. Or if it will, then it will be trans-compiled into JavaScript, and will inherit some of JavaScript's weirdness (either by mistake, to simplify the compiler, for performance, or maybe to make some features possible at all).
&gt; For applications that work on both Node and in the browser I would rather just have giant monolithic files and avoid modules all together :( lol it is much easier to have isomorphic code with browserify/JSPM/webpack writing commonJS modules. It seems like you must have been doing something wrong. I have few very complicated libraries, which run fine on node/browser thanks to being written in commonJS module syntax. For [example](https://github.com/capaj/socket.io-rpc) Also this will get fixed soon with ES6/ES2015 modules.
I like a little sugar but when there are five ways of doing the same thing it can make the language more difficult to learn. 
Looks pretty cool. Seems to provide a better introduction thatn angular or react do.
&gt; The bug is in your code, not in the browser. You're trying to use a sort function that doesn't work properly: it returns 0 instead of the correct value of -1 when a is less than b. That is not the intention of the code. The code is merely stating that if one value is greater than another value sort higher or remain in place. If I had to specify a -1 for an alternate condition, such that one value is less than its comparator, I would be instructing the sort algorithm to move the value lower, which is not the intent. In the case of sorting numbers there is only a binary consideration: Is one number the same as its comparator or different. If different sort up or down depending upon whether the list should be ascending or descending. If I have to supply addition instructions beyond this then something has gone horribly wrong in the logic. In the case of my code examples Chrome failed in this regard. It incompletely respects the concept of similarity, which is a bug.
The [random noun] + '.js' trend gets a little annoying sometimes
_Mistakes_ happen in every language. You deal with them by having good linters and test coverage, not by avoiding language built-ins "just in case". Avoiding `undefined` in JavaScript just in case someone did `undefined = 42` is like avoiding `true` in C++ just in case someone did `#define true false`.
One could also presume that the result could be [4, 6] ;)
Indeed the blocks.observable() is heavily influenced by Knockout but jsblocks provides a lot more functionality than Knockout. You could build complete sites using the framework. Very important features are server-side rendering, debugging experience and its performance.
Scala is a delightful language. I'm glad to see more companies using it. It can even be used for frontend with Scala-JS. You can try Scala-JS at http://www.scala-js-fiddle.com
Also the fact that you CAN change `this` to make reuse of methods easy.
About the server-side rendering: No. You once go to the server to render the page and everything from there is handled automatically. Actually the http://jsblocks.com is build using jsblocks so you could check out the Network tab to see what happens. The Object.observe() question: No. The framework is not using Object.observe() and instead observables http://jsblocks.com/learn/working-with-observables-introduction. The reason is that observables currently provide a lot more flexibility and control over the code. This will change in future but the framework could be adapted to follow the best possible approach. The diff and Virutal DOM utilities: Yes. There is Virtual DOM which is really fast. Interestingly there is no diff algorithm yet which is awesome because after the implementation of diffing the framework will become EVEN FASTER.
Many people end up assuming we have classes and everything works similar to Ruby/Python and completely ignore the fundamental thing in JS which is prototypes!
some of them are super nice ...like this one :)
I like having JS frameworks pop up everyday, and especially when they take existing ideas and refine them. But it's hard to get excited about two-way data binding and microlanguages embedded in HTML attributes. And not being able to use plain old Javascript objects sure is a bummer.
&gt; Firefox will always yield a sorted array for numbers if 0 is returned as either the primary or alternate value. That's a side effect of Firefox using a stable sort. The standard does not require a stable sort. &gt; Chrome is just buggy. Chrome is not buggy, your comparator function is buggy because it's not consistent and as /u/mbrubeck noted the standard expressly notes that sorting with an inconsistent comparison function (which is what your comparison function is) is undefined/implementation-defined.
You posted this question yesterday... my comment remains. https://www.reddit.com/r/javascript/comments/33fyxo/whats_the_best_resource_for_learning_the_mean/cqku43d
Consequently, there's way too much code in my HTML for me to want to use this.
True, I haven't said they aren't but God knows how many frameworks we'll have to know in a few years if this tendency continues :)
definitely!
&gt; The code is merely stating that if one value is greater than another value sort higher or remain in place. That's not how comparison functions works. &gt; which is not the intent. Your intent does not matter. When you give the system incorrect instructions, the system is not at fault for producing nonsensical answers. &gt; In the case of sorting numbers there is only a binary consideration: Is one number the same as its comparator or different. Right. And your broken function tells the system that values are both identical and different depending on the order in which they're compared. &gt; If different sort up or down depending upon whether the list should be ascending or descending. And we're back to nonsense. If that made any sense, comparison functions would only need to return `true` or `false`, they wouldn't need to return one of three values. &gt; If I have to supply addition instructions beyond this then something has gone horribly wrong in the logic. The only logic which has gone horribly wrong is your own, please go learn how various sorting algorithms work. &gt; It incompletely respects the concept of similarity, which is a bug. The only bug is in your broken comparison function.
what?
Mmm. In general, I'm against using ids for anything except where explicitly necessary (since they populate the global scope), however I don't think there's a better solution here. Does `#article` in this case mean that it will be populated with a bunch of articles (as denoted by query.each)? Can I use a template for each of those children? Does jsblocks have the concept of a template (like in angular, `&lt;script type='text/ng-template' id='foo'&gt;`? There's too much I don't know about your framework to make proper suggestions, sorry.
&gt; Your intent does not matter. When you give the system incorrect instructions, the system is not at fault for producing nonsensical answers. But the instructions are correct. A valid sort condition is supplied that returns a valid value along with a valid alternative. This fully conforms to the requires according to the spec. I may very well be wrong, but you have yet to prove so. &gt; And your broken function tells the system that values are both identical and different depending on the order in which they're compared. The greater than and less than operators do not simultaneously allow for both similarity and difference the proper interpretation of which is up to the evaluator on which one, as I have so far demonstrated, is less complete. &gt; The only bug is in your broken comparison function. You have thoroughly run through your opinion, but you have not demonstrated a proof.
I placed #article because it could be CSS selector based. You will also be able to do something like: &lt;div class="article"&gt;&lt;/div&gt; queries: { '.article': query.each(articles) } Yes. There are templates: http://jsblocks.com/api/blocks-queries-template No problem. Is great to answer questions. :)
Sorry, of course, confusing. Protocol in the general sense: What course events is best in the creation of modal windows? Should I, for instance, have a &lt;div&gt; ready but hidden in the body element, and "show" it when I need it? Or should I have a javascript function set up to create such a div when needed, and append "children" elements to it - so I can use the same function with different "modal contents"? What I'm trying to do right now is create a modal div, append a child with the HTML of the specific modal (like Login Form), and then append a child button to the Login Form, which, clicked, is supposed to empty the modal &lt;div&gt; and hide it. But that button is giving me errors all the time, and I'm simply wondering if I'm not looking at this all wrong.
Yeah, sorry, confusing, see reply to ZyklusDieWelt below. And thanks!
How we can take into account performance comparison, if they don't say how many items is in model and how many elements was rendered on page?
 &gt; But the instructions are correct The instructions are not correct. The instructions could be correct if sort had completely different requirements for its comparison function. As things stand, sort has the requirements it does and the instructions are incorrect. &gt; This fully conforms to the requires according to the spec. No. &gt; I may very well be wrong, but you have yet to prove so. I proved so before I'd even posted the comment to which you've replied to [with extensive quoting straight from the spec](https://www.reddit.com/r/javascript/comments/33jlzo/sort_algorithms_and_chromes_shameful_secret/cqly5xj) expanding upon [/u/mbrubeck's original comment](https://www.reddit.com/r/javascript/comments/33jlzo/sort_algorithms_and_chromes_shameful_secret/cqlqjxn) to which you never replied even though it was posted 12 hours ago. 
To add to what /u/Rhomboid so clearly explained, a minor annotation: not even when the page is static can you really trust the `lastModified` property. Many people decide to send the current date as `Last-Modified` even for static HTML files, disregarding the file's actual date.
Backward compatible wasn't correct phrasing (though there are some breakages). What I meant was that it breaks all existing systems. ES5 pretty much just runs on ES3 browsers. Even when ES5 was first introduced, you could write code using it and expect the code to work. Today, 100% of all browsers are either ES5 or ES3. Not even *one* browser can execute ES6 code because the language design is fundamentally different (you can't just bolt on ideas like the "Temporal Dead Zone" or generators). To support current browsers, you must cross-compile ES6 into ES5. This process is literally no different than if we were replacing JS with Clojurescript (the alternative to cross-compiling is building an interpreter or bytecode on top of JS. This is possible with most languages, but seems extremely hard to do with javascript). The script tag allows for attributes. Maintaining existing code while introducing a new language is easy -- all you do is specify type="newLang" version="12.3.56" in the tag. The old browsers may try to use ES3/5, but if they try to interpret ES6, everything breaks anyway. Just keep the old ES5 compilers around in their current form for a few years. Since this process is the same in all cases, why not break completely and do things correctly.
It doesn't run. And also it shoud not use development version of react, cause it is not just bigger, is also have a lot of code for providing nice error messages, which is removed in production.
The bars show that jsblocks is the fastest and how many percent the other libraries are slower than it. The milliseconds actually are just to give you a relative idea and this is why they are with smallest font size. Actually this is interesting story. I have talked with designers and they said that people will understand it better if the bars for the highest performance is the highest. I said that we programmers will understand it but eventually followed the suggestion.
Check out [Mithril](http://lhorie.github.io/mithril/). It doesn't use a microlanguage (BTW, that's a fantastic way to describe it!) in HTML because views are written in regular JavaScript in a functional programming style. https://medium.com/@l1ambda/mithril-vs-angular-vs-react-d0d659c24bae. [React](https://facebook.github.io/react/) and [Mercury](https://github.com/Raynos/mercury) also have a similar philosophy, I believe, though I am not as well versed in them.
This is why I think something like pnacl is the answer. The browsers make low-level browser APIs and then they don't have to care about the language. They are willing to break the language, so Brendan Eich's talk about getting the bytecode wrong doesn't hold water (and that's before you talk about all the things wrong with JS that aren't being fixed in ES6). As far as implementation goes, the Webkit FTL JIT is fast and permissively licensed, so there's no reason a company couldn't use it instead. All they would need to do is say that ES5/6 is the "blessed language" if you want to use uncompiled code or you can use the type="pnacl-bytecode" version="21.4.3" and use whatever back-end language you want. This also solves other problems ranging from protecting source code to optimization of the bytecode before shipping to boost responsiveness and performance.
sorry for that. I really don't understand the previous comment. I really think that the "what do you need in a framework" is a really cool question that deserves a separate discussion here on Reddit and it will be very useful for all visitors :)
&gt; The fact that you can leave off arguments Strange, I consider this a flexibility feature and a _good_ thing. Weak Types and allowing coercion in general can be very powerful and shouldn't be dismissed as dangerous or bad out of hand - it just needs to be understood. Fun post by Kyle Simpson around that http://davidwalsh.name/fixing-coercion 
Actually, since it is a measurement of time regardless if you are using absolute or relative measurement, the JSBlocks bar should be shortest. Since you are comparing the other libraries to JSBlocks, JSBlocks is (1 * 100%) and the other ones are (X * 100%) where X &gt; 1, therefore they would still be bigger bars.
Thanks! :D I will probably post some more tech details at some point. 
This was a lot of shame for me. :( I have updated the project to work and use react.min.js and I will improve it further. Thanks for the valuable feedback.
&gt; The 0 value means do not sort one index relative to its comparator entirely without regard for the logic that returns 0. Here you are expressing a desire for a [stable sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability): &gt; if two items compare as equal... then their relative order will be preserved, so that if one came before the other in the input, it will also come before the other in the output. Is `Array.prototype.sort` expected to be stable? [ECMA-262 says no:](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11) &gt; The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order).
Yeah I get what you were saying but I can see how someone else might read it differently. I think the previous commenter read you as telling them to take the conversation elsewhere.
You are correct. I will think of a way to improve this. Thanks! :)
[image](http://hilton.org.uk/blog/javascript-frameworks-days.png)
I'm not sure, try posting over in /r/flash or /r/java
New v3 examples page as well: http://pixijs.github.io/examples/
Frameworks help you structure your application, especially if you don't have much experience w/ organizing large codebases, and they help you minimize the amount of tedious code. I'd recommend looking at Mithril.js. It's fairly free of "magic", it's relatively easy to setup and learn, and has a good amount of features out of the box, so you can focus on building things right away, rather than getting analysis paralysis over things like AJAX libraries and Flux implementations, or getting stumped by a huge learning curve. The tutorial in the website assumes a pretty basic level of javascript, and actually explores some of the cooler parts of Javascript in the process of introducing the framework. Unlike most frameworks that have a "come-for-the-sugar" feel, Mithril has a very strong "come-for-getting-shit-done-and-leave-with-javascript-chops" mantra to it, so you get a lot of reusable knowledge just by dabbling with it. The community in the gitter channel is very active and friendly too. There are some pretty high-traffic projects using it in production (Guild Wars 2, lichess.org, for example), so it's relatively battle tested as well.
Gitter channel is here: https://gitter.im/lhorie/mithril.js You can login to Gitter using Github credentials
I think adding something about modifying the object/function descriptor: enumerable/writable/configurable, freeze/seal/preventExtensions and isSealed/isExtensible/isFrozen objects/functions as a way to prevent a lot of exploits should be mentioned. It's not widely used, and I think most people consider it overly verbose, but it has it's uses.
I said in a more or less joking manner but it's always a good idea to remind yourself that JS was built originally to work with the DOM which is why it keeps assuming things to be strings when you allow it to. It's a crazy dance that keeps me on my toes!
This is definitely something I'd like to mention, but I'm trying to tailor it to beginners. That definitely does belong in a "part 2" though! Thanks for the feedback!
You'd think so, [but it's not](https://jsperf.com/object-keys-vs-for-in-perf). Once we get`for-of` the syntax will be a little cleaner too.
Compiled languages force you to have a build step. If you decide to introduce an optional build step for your Javascript are you necessarily worse off (assuming it doesn't the job you want)?
I'd rather use a data binding framework so I don't have to worry about IDs at all, actually! Have not used IDs since I started using Angular, and I prefer to keep it that way.
What about garbage generated?
&gt; The value 0 means "the values compared are equal" and nothing else: Not according to the spec: http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11 &gt; The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, **zero if x = y**, or a positive value if x &gt; y. &gt; A function comparefn is a consistent comparison function for a set of values S if all of the requirements below are met for all values a, b, and c (possibly the same value) in the set S: The notation a &lt;CF b means **comparefn(a,b)** &lt; 0; a =CF b means **comparefn(a,b)** = 0 (of either sign); and a &gt;CF b means **comparefn(a,b)** &gt; 0. Please note it is explaining what should happen for comparefn(a,b) relative to 0 and **not** a,b relative to 0. Therefore the logic of the compare function must be evaluated and its returned value evaluated against 0 **not** the comparison of arguments a and b. According to the spec you are wrong. Edit: Also, according to the spec since only the functions returned value relative to 0 is important it does not matter what instructions that function contains so long as it return value is comparable to 0. It also means that 0 must be an acceptable value to be returned from the comparison function without regard to the equality of a and b. The spec is pretty detailed about this.
It is logically consistent. If the numeric value of index a is greater than the numeric value of index b the compare function consistently returns 0 and consistently returns 1 otherwise. Can you demonstrate the inconsistency?
While I think building the page structure like that is cool, it always clashes with our workflow. A design, in our case, gets created and prototyped in plain HTML, which then needs to be translated to this. It becomes especially difficult if the designer iterates while developers are building, and changes need to be merged. But I should definitely take another look at these kinds of things for personal projects.
Liked this. Good callout that even I've noticed in many places. Hope you build a part 2 for more seasoned devs :P
So easy - I'm really finding that's useful when building apps in ReactJS. I barely used `Function.prototype.bind`before I started using that lib, but when you're heavily relying on composition (where you're more focused on the individual components, rather than just rendering a whole 'page'), bind is excellent for function re-use.
&gt; It does not mean a =CF b if a === b. I agree. This is correct. But I never claimed that. Let me break down my proof into further steps. **Theorem:** *sort* is not a consistent comparison function for numbers. **Proof by contradiction:** 1. Assume *sort* is a consistent comparison function for numbers. 2. Then *sort* fulfills the symmetry requirement: for all numbers *a* and *b*, if *a* =^sort *b* then *b* =^sort *a*. 3. Let *a* = 0 and *b* = 1. 4. *sort*(0,1) = 0. By definition of =^CF this means 0 =^sort 1. 5. By symmetry, if 0 =^sort 1 then 1 =^sort 0. Therefore 1 =^sort 0. 6. By definition, this means *sort*(1,0) = 0. 7. But *sort*(1,0) evaluates to 1. Therefore *sort*(1,0) ≠ 0. **Contradiction between (6) and (7).** QED.
&gt; My example function fully conforms to the requirements. No, your function does not conform to the symmetry requirement. Try to provide a proof that it does and you will see why.
&gt; Not according to the spec Yes according to the spec from which all my quotes come. &gt; Please note it is explaining what should happen for comparefn(a,b) relative to 0 and not a,b relative to 0. Therefore the logic of the compare function must be evaluated and its returned value evaluated against 0 not the comparison of arguments a and b. That's completely meaningless word salad. The first paragraph describes the behavior of *comparefn* with respect to its argument. And that paragraph isn't even relevant to the assertion that **your function is wrong because it's not consistent and the spec requires a consistent comparison function**. &gt; According to the spec you are wrong. According to the spec I'm right and you're getting seriously ridiculous. &gt; Also, according to the spec since only the functions returned value relative to 0 is important it does not matter what instructions that function contains so long as it return value is comparable to 0. That's completely wrong. The specification also requires that, as you've already been told half a dozen times, the comparison function be consistent. And it provides the definition for a consistent comparison function, which I have quoted, and which the function you provide does *not* respect. &gt; It also means that 0 must be an acceptable value to be returned from the comparison function without regard to the equality of a and b. You're completely insane, the first paragraph you re-quoted spells black on white that *comparefn* can only return *0* if its two parameters are considered equal (according to the comparison function). The whole point of *comparefn* is to spell out the relative ordering of its parameters. &gt; The spec is pretty detailed about this. The spec is pretty detailed, but you're pretty incapable of understanding it.
Thank you! If there's enough demand I think I can justify making a part 2; I've already got a lot to talk about based the feedback I've gotten so far!
Symmetry is not a synonym for consistency. Consistency only suggests that a given output will remain identical given that a set of inputs continue to conform to a set instruction in the same way. The consistent results may not, however, suggest one thing matches another. It is probably to always achieve symmetry without consistency provided an ideal set of inputs and incomplete instructions.
Interesting discussion ... this is a technique I use when I need maximum performance ... http://mparsonsvm.cloudapp.net/dbmonster It leverages CSS, which utilizes the GPU with close to zero DOM updates so it's very fast as well as has a very low memory / cpu profile. Plus it doesn't use any framework and is only a few lines of code. It's not for every scenario but it works very well in a large number of use cases like this sample.
&gt; It is logically consistent. It is not consistent according to the specification's definition of a consistent sorting function &gt; Can you demonstrate the inconsistency? For a comparison function *comparefn* to be consistent, ECMA-262 requires amongst other criteria that equality be symmetrical. That is for any two comparable values `a` and `b`, if *comparefn(a, b)* returns *0* then *comparefn(b, a)* must return *0*. js&gt; var sort = function (a, b) { if (Number(a) &gt; Number(b)) { return 0; } return 1; }; js&gt; sort(3, 2) 0 js&gt; sort(2, 3) 1 therefore your function isn't consistent, and using it to sort an array is undefined behaviour. Specification excerpts wrt using an inconsistent comparison function when sorting: &gt; If comparefn is not undefined and is not a consistent comparison function for the elements of this array (see below), the behaviour of sort is implementation-defined. the "below" part containing amongst its criteria for a consistent comparison function&gt; &gt; * If *a =^^CF b*, then *b =^^CF a* (symmetry) where &gt; *a =^^CF b* means *comparefn(a,b) = 0*
&gt; Functions are not word salad. Your words are salad, not functions. &gt; No, the first paragraph describes the sort method. I suggest reading the spec again. Let me quote it again: &gt; If *comparefn* is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, zero if x = y, or a positive value if x &gt; y. There is no mention of the sort method here, this is solely a description of the behaviour of *comparefn*, your assertion that this describes the sort method makes no sense. But again **that's not relevant to the issue at hand**, which is that the function you provide **is not a _consistent comparison function_**, and its usage as a comparison function is thus *undefined behaviour*. &gt; Conversation over. I suggest you learn more about functions. How cute.
Perhaps more importantly, even if you *do* provide a consistent comparison function, the relative ordering of *a* and *b* if *comparefn(a,b) = 0* is still implementation-defined (since both stable and unstable implementations are explicitly allowed, and the only difference between stable and unstable sorting is the relative ordering of elements whose comparison evaluates to 0).
Very cool, definitely renewed \#1 choice for intense canvas spriting. 
Please, please believe me on this. I'm a research engineer at Mozilla. I write and implement web standards for a living. Several of my co-workers sit on the ECMA TC39 committee, including my boss's boss. The developers of the V8 and JSC and Chakra engines likewise have both extensive experience and extensive compliance tests. They are not getting such a basic matter wrong. I don't mean this as an appeal to authority, but just a reminder that specs use some special jargon that can take a lot of experience to interpret correctly. For example "implementation-defined" which might sound innocent to some readers but in web standards is the equivalent of "Here be dragons!" &gt; Symmetry is not a synonym for consistency. Correct. However, it is a **requirement** for consistency: &gt; "A function comparefn is a consistent comparison function for a set of values S if all of the **requirements** below are met for all values a, b, and c..." ("The requirements below" are found in a bulleted list, which includes and defines "symmetry.") &gt; Consistency only suggests that a given output will remain identical given that a set of inputs continue to conform to a set instruction in the same way. Consistency doesn't "suggest" anything. Consistency is **required** to get *any* spec-defined behavior from `Array.prototype.sort`: &gt; "If comparefn... is not a consistent comparison function for the elements of this array... the behaviour of sort is implementation-defined." `sort` is not symmetric for all *a, b* ∈ `data`. Therefore `sort` is not a consistent comparison function for the elements of `data`. Therefore the behavior of `data.sort(sort)` is implementation-defined. It really is that simple.
I still think Riot.js is the best mvish one at the moment. 
I'm glad for this article, and glad someone is taking the time to give it away for free, and I know they do so hoping to indirectly generate some traffic and thus revenue, but does there *really* need to be 28 "Subscribe for more!" links on that page?
ES6 just defines the syntax for modules. To be able to load them in a browser you will still need a module loader -- either a browserify-like bundler, or a require.js-like script loader.
&gt; microlanguages embedded in HTML attributes That's one of the big reasons I love ReactJS - it keeps things vanilla to an absurd degree. React itself is primarily just a way to manage a stateful shadow-DOM, so you never find yourself managing arcane configs. The only non-JS part of it is JSX, which is just XML that gets transpiled still readable (though somewhat verbose) js; some people don't even bother with it, since it's really just for convenience and not a necessary part of the implementation.
Don't apologise. I just can't imagine a scenario where I would favour an espruino over a plain micro and c or even c++. What type of applications do you use it for, if I may ask?
What's your alternative? You seem like you don't like private members, but in my code I've got values that I want to cache and a private variable is pretty convenient for my library. Previously I was creating my object like this: var MyLib = function() { var privCache = {}; this.getThing = function(id) { if(privCache[id] === undefined){ var servResponse = get_from_server(id); privCache[id] = servResponse; } return privCache[id]; } } But in an effort to move things to the ".prototype" format it now looks like: var MyLib = function() { this.privCache = {}; } MyLib.prototype.getThing = function(id) { if(this.privCache[id] === undefined){ var servResponse = get_from_server(id); this.privCache[id] = servResponse; } return this.privCache[id]; } Both can be used like: var libInst = new MyLib(); libInst.getThing("myObj"); The second also exposes the privCache to anyone using the library, instead of the first implementation which doesn't let someone edit it directly. libInst.privCache = { "totallyCleared" : true }; That line would completely mess up the prototype-style's cache while the first style is totally fine. I've been looking for another way to have private variables, but I don't know of a good way to handle it. Any suggestions?
60k bunnies gives me 30fps - on my phone!
I'm not against private members, I am saying that they are not necessary in a language that doesn't support the concept. So why introduce messy scoping workarounds when you can just use the common _ prefix that tells everyone reading your code "hey, this is not part of the contract, don't rely on it". It's worked well for other languages (eg: python) so I'm not clear why I should mess up my code to implement language features that don't exist.
&gt; I don't have an Apple device handy, so I haven't checked Safari yet, but I expect similar results on at least one of these tests. &gt; navigator.userAgent &lt; "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/600.5.17 (KHTML, like Gecko) Version/7.1.5 Safari/537.85.14" &gt; var data = [3, 6, 2, 9, 4, 56, 3, 12, 22, 3, 67, 3, 7], sort = function (a, b) { if (Number(a) &gt; Number(b)) { return 1; } return 0; }; &lt; undefined &gt; data.sort(sort) &lt; [3, 6, 2, 9, 4, 56, 3, 12, 22, 3, 67, 3, 7]
&gt; Mozilla doesn't respect this as this is technically undefined (but still expected) behavior. Well it's undefined so returning a sorted array is perfectly valid if slighly misleading (it's most likely just a side-effect of their sort algorithm though, with differently broken comparison functions [other browsers return the "correct" result and Firefox is "broken"](http://stackoverflow.com/questions/21058441/sort-not-working-with-firefox))
I get faster at picking up each new one I learn. I try a new framework with each new project just to keep myself well rounded. At the end of the day, people are more likely to hire you for your ability to learn quickly and your general understanding of core coding concepts. Even if you stuck with just Knockout/Angular/React, you'd have plenty of job opportunities out there. Also, been using Meteor recently and it's been pretty mind blowing how fast I can develop.
dammit. I'm out of town this weekend. :( 
I prefer the flipped smiley when being a dick. (:
Does Microlanguage == DSL (Domain Specific Language)?
Yeah that's totally lame.
&gt; Actually it is really interesting how jsblocks compares to code length against other libraries. You will see the jsblocks code length is really small It's about as long as the Angular 2 version: https://github.com/angular/angular/tree/master/modules/examples/src/todo (This example includes a few oddities which make it possible to compile it to Dart. This isn't something you'd normally do.)
Yeah turns out I was running my firstrun() function before declaring the worker.... Whoops 8^)
galaxy s5. chrome cant render webgl and firefox shows differences to desktop version. back to apps :(
I don't know why it hasn't been mentioned before, but the answer is undoubtedly sparse arrays. Native map and forEach are slower than something like lodash map or forEach because of these edge cases. I see no reason why .sort() wouldn't have the same problem.
Protecting the client from itself is a losing battle.
That doesn't mean you can't take some decent measures to do so.
You can even click on the states and the meta data comes up in a tool-tip. Nice.
So what are the benefits of this over nw.js? What does it do better? What is worse? We are going to be building a desktop/web app soon and I'm gonna be the one deciding on the stack to use.
It seems like they are saying that Mithril doesn't include a DSL, which is obviously wrong because it introduces the `m()` utility-belt function in the same way jQuery introduced `$()`. Still not sure what 'microlanguages embedded in HTML attributes' means, though. If they're complaining about syntax, that should really be the least of our worries when we're investigating new frameworks.
Hey kind of a side question here...would this be a good library to start introducing my son (he's 9) to game programming? I was looking at this library last weekend and thought it was pretty cool. 
I tried hitting the free option on the pricing page, but it just loops me back to the page of the free trial. The fuck do I do? Edit: I'm assuming they're talking about the 7 day free trial. So I sign up then just cancel and won't get charged Im guessing. 
I thought this was stupid until I read the source code. JET ^FUEL ^^CAN'T ^^^MELT ^^^^STEEL ^^^^^BEAMS!
source was fun to read, nice work
Phaser.js uses Pixi for rendering but has more game stuff built in like physics engines.
Checkout my side gig at https://log4sure.com, test out the beta version and provide feedback
There's not really much performance cost. VMs are pretty good these days. And it's great to just basically run one command to get a project up and running, regardless of the language or stack. It's especially great when you have to swap between projects that depend on different runtimes &amp; versions of runtimes &amp; etc.
*Edit: Never mind, I misunderstood. The free weekend isn't the same as the free trial or sampler. For the free weekend, start here: http://www.letscodejavascript.com/v3/blog/2015/04/free_weekend* Hey there, host of Let's Code JavaScript here. The free option should take you to http://www.letscodejavascript.com/v3/sampler. Now I'm worried I screwed something up. Can you tell me exactly which button you hit on the pricing page? And yeah, if you sign up and then cancel, you won't be charged and you'll have access for 7 days. It's cool. (Please be nice.)
&gt; I was actually pretty amassed when Facebook announced React and I saw it had similar concept like mine That happened to the Ractive guy too: http://blog.ractivejs.org/posts/whats-the-difference-between-react-and-ractive/ &gt; React's first public release came about a month before Ractive's. I distinctly remember reading the post on Hacker News and thinking 'well I may as well give up' – so many of Ractive's ideas, which a day earlier had seemed entirely novel, had already been implemented by a team of engineers with the might of Facebook behind them.
*Edit: Never mind, I misunderstood. The free weekend isn't the same as the free trial or sampler. For the free weekend, start here: http://www.letscodejavascript.com/v3/blog/2015/04/free_weekend* The free trial includes downloads (all the videos are DRM-free) but other than that there's no difference.
Yeah, unless you're comfortable writing a rendering/physics/input loop, phaser is definitely the better choice of the two.
You're sitting on a goldmine Trebec! Thanks! This is just the kind of nudge I was hoping for!
Hey man, thanks for the reply back. I signed up, but never received my confirmation email. I actually just sent you an email about that w the URL. I'm in real need to learn JS so hopefully this can help me achieve this, thanks!
Got the email and responded :-) Thanks for signing up, I hope you enjoy it!
And if there's no such delimiter then you're fucked! It's better to do things the right way from the beginning and actually parse CSV instead of just blindly splitting.
This has certainly been an interesting thread. Look, every programmer makes mistakes. I've been programming for over 45 years, so you can bet that I've made a lot of them. Let me tell you about one of mine. Back around 2008 I figured out a neat way to optimize looping through a JavaScript array in the fairly common case where you know that none of the array elements are "falsy" - for example in an array of objects that you've generated where you know that none of them are null. It was such a great idea that I used it in all my code. I promoted it in a tech talk I gave at Google, I wrote about it in O'Reilly's *jQuery Cookbook*, I told all my colleagues about it. Only one little problem... Not only did this optimization trick not really make things any faster in the browsers of the day, it runs *much slower* than a conventional loop in modern browsers. This is because it tries to fetch an element just past the end of the array - which is perfectly legal in JavaScript, you just get the `undefined` value. But in modern JavaScript engines, this can cause the entire array to become de-optimized. If the JavaScript engine sees that all the array elements you access look like the same type (e.g. all Objects in the case I was using) it can create an optimized form of that array. But when I read the `undefined` value past the end of the array, the engine throws up its hands and says "this array isn't all the same type!" And then it goes back to the most general-purpose, non-optimized way of storing the array. I'm too embarrassed to post the actual loop code here, but you can see it in a JSPerf: http://jsperf.com/mikes-loops/5 Look for "Mike's Crazy Loop" and see the pitiful performance. :-) So don't feel too bad that you've misunderstood the requirements for a `sort()` function. It happens to all of us! But do listen to all the advice you've gotten here and understand where you got it wrong.
I think its mostly because the call itself is very resource intensive and the more listeners you add, the slower your app will be. But for some things its just impossible to do it another way around. Triggering functions inside other controllers, services or directives is otherwise a very difficult operation. The alternative would be to use rootScope itself but thats a no-go either (its like global variables. You don't want that). So keep the amount of broadcasts to a minimum but there isn't a big "you really shouldn't do that" argument against it. If it did, it would have left the code already. If you are just sharing data between controllers, you can just use a factory with a function to store from controller 1 and a function to get from controller 2. Some say that using parent/child controllers with sharing functions could be an alternative but that isn't as reliable as a broadcast (many have had issues where the parent function or variable wasn't recognised or wrongfully triggered) so i would advise against that. Just know that you shouldn't overdo broadcasts because the call itself is an expensive one, but other than that it should be no big issue. Unless somebody got another reason but i still feel this is a more clear and simple call than the alternative hacks (especially if you aren't the only one working on the code). Perhaps you could enlighten us with an example or problem you are facing
Hmm, thats a big difference. Could you share the snippets so we can see how the code works (and if it can be improved)
I linked to the actual applications. All I did was record the performance with the Chrome dev tools. To get the applications to the point with 1000 todos I modified the localStorage object in the console then refreshed the page.
Showing demo code in an auto slideshow which cannot be stopped (by clicking the dots, hovering over the code, whatever) is driving me insane. I was *this* close leaving the page at that point. Edit: It works with the charts slideshow.
This is shitty code even for late 90's/early 2000's standards. Ignoring the use of `document.write` for blocking page rendering only to shit out horrifically bad html, why the fuck is `TotalForTheWeek` (a scalar value) stored as an array? My mind is way too full of fuck from looking at this to want to make any sense of it and the desperate state of mind the original developer must have been in. *edit: methinks this is a troll*
 S to the P to the aghetti SPAGHETTI!
Yeah. I also face the same issue. Im running into a loop. Clicking on the "star free trial" button on http://www.letscodejavascript.com/v3/sampler takes me to http://www.letscodejavascript.com/v3/subscribe which again loops back to the 1st URL when you click on the free sampler button.
I'm reasonably sure the second one should be `compare(b, a)`.
I feel that putting up lots of parent/children is also not a win solution. Whilst sharing data is nice, you don't want to use global data on scopes too often. If its only about sharing data, then i would advise using Factories. But if you need to run a function when data changes (say your form is submitted and you need it to go through another function or separate controller), then broadcasting seems to be your only function. Mainly because running functions between controllers isn't the most reliable (if they are connected) or even possible (if they are not). I had to update a graph that wasn't sharing a controller upon data changes which also had to deal with various checks (if data is x then run exception y), then using broadcast is a much cleaner solution. Because the thing is, if you are using parent controllers to do various functions, knowing where your code (and data) is located can become a problem. Especially when not working alone or having to let somebody else continue coding. If your code isn't clear to others, you'd get Spaghetti-code as well, even though it might not be as performant
Sorry but I thought most of this was pretty pointless, you cannot protect data inside the client. You showed a few ways to obfuscate it away from the obvious access of console, but someone like yourself can just as easily edit the actual javascript and remove / tamper with the very "solutions" you mentioned. The bit about protecting server side information is about the only true part, but you didn't really give any meaningful information there either. Things like enforcing rate limit on the server and validating input are not common pitfalls, they are standard practices for any back-end developer. Thanks for taking the time but I felt the content was very lackluster.
They've posted about it a couple times in the past, FWIW https://github.com/blog/1528-there-s-a-map-for-that https://github.com/blog/1541-geojson-rendering-improvements
&gt; less DRY So more RY? 
don't care. Progressive enhancement is like building a car with a sail, because what if they run out of gas? they'll need the wind to push the car!
Yes and no. Most likely you should not care. It all boils down to your target users. If your site is big enough and serves enough types of customers, you need to think about fallback solutions and stuff like that... Most websites do not need to care about this. They should and need to care about JS performance and loading times, that is what you should focus your attention to. 
Thats pretty good, convoluted nightmare for what it does, but pretty good.
This is where i think the whole isomorphic aspect comes into play. It's important to have accessible content for users, screen readers, search engines, etc. I think having content that renders from html right away is still something worth achieving. Then have your JS on top to make the user experience better. It's difficult to build a single page app this way, but depending on what you're building, it can be beneficial.
Progressive Enhancement is building a car with wheels. What you're building is a solar-powered hover car.
http://i0.kym-cdn.com/photos/images/original/000/538/731/0fc.gif
Have a look at dragonbones: http://dragonbones.effecthub.com/
And yet, if you read the linked page, the author's point is that there are other situations in which someone may end up seeing a page without javascript.
They're not working for me either.
Pixi.js is essentially a renderer/rendering engine and not much more in terms of a game engine, you'll want to look at Phaser.js (it uses pixi.js as it's renderer/rendering engine). Although it will be some time before phaser gets updated to pixi 3. There'll be a lot of disagreement as to where to start someone in game programming at a young age. I started out with Klick &amp; Play (not around anymore), Games factory (not around anymore), Multimedia Fusion (not around anymore)... The takeaway is that I can't now use any of those, and the countless hours spent learning and using them is wasted as they weren't real programming and abstracted away to such a high level that I consider it (now) wasted time. Start your son off right with actual programming, even scratch/waterbear is a large abstraction away from just sitting and learning how to code. If you can, learn it with him. You'll have a great time sharing what has been learned, bouncing ideas off each other, debugging code... and just spending quality time together.
Why is it that not a lot of people make the same claim about progressive enhancement for when CSS fails to load? Sure, links are still clickable when CSS fails, and you can still read text, but most users won't think "Ah, it's just the CSS that hasn't loaded, this site is still perfectly usable!" but instead think that the site is either broken, been hijacked, or reverted back to what it looked like in the mid nineties. Either way, they won't be using your site in that state. It's incredibly easy to add an inline script that runs a check to see if an external script has loaded, and either try to reload the script, reload the page or just inform the user that it's broken, please try again later.
Give this a shot: Enable webgl in chrome for Android: http://blog.laptopmag.com/how-to-enable-webgl-support-on-chrome-for-android
Wow, thanks a lot!
Those are the same reasons one may not see the CSS effects or even get the HTML. Articles on this topic often forget that part.
From the Hacker News: https://news.ycombinator.com/item?id=9432384 &gt;z1mm32m4n 38 minutes ago &gt;If an image fails to load, the browser draws a little box with some alternate text describing that box. If the CSS doesn't load, your text and content is displayed in a weird font without the grid layout you were using, but if you wrote your HTML semantically (using &lt;h1&gt; instead of &lt;div class="title"&gt; etc.), the browser can still show most of your content, and you can still move around on the page. &gt; &gt;If the JavaScript fails to load and you were using it to significantly alter the content on your page, for example loading a news article asynchronously, the entire page fails to load. &gt; &gt;I don't mean to pick on this app in particular (I actually think it's really cool and I plan on using it and learning from it), but take a look at what happens to http://hswolff.github.io/hn-ng2/ when you switch off JavaScript--it's completely unusable. Now try switching off JavaScript on Hacker News--all the links and comments are still there. Funny how on both sites most commenters haven't even looked at the link.
That is not a valid flow chart. Everything is a start/end box. The start box does not connect to the next box with an arrow. There are no decision diamonds where there are questions. There are no yes/no labels. There are no yes or no paths to indicate a split in the flow due to a decision diamond. The comment boxes are using start/end boxes when they should be in braces {}. For flow charts, please use the appropriate symbols (and yes, there is a standard). http://www.edrawsoft.com/flowchart-symbols.php http://www.edrawsoft.com/flow-chart-design.php http://www.hci.com.au/hcisite2/toolkit/flowchar.htm The ANSI Standard symbols from 1970: http://it.toolbox.com/blogs/enterprise-solutions/ansi-standard-flowchart-symbols-20726 Here's a whitepaper from 1970. http://www.fh-jena.de/~kleine/history/software/IBM-FlowchartingTechniques-GC20-8152-1.pdf 
I found that one to be the *least* ridiculous.
Don't know about you but that often happens to me when browsing over 3G.
My favorite is the one where we have to be extra careful that our scripts don't interfere with plugins people may have installed.
It is. But it also depends on the content and reason for your site. If it's a portfolio site, and you want to show off, maybe you don't care about the minority people who disabled javascript. But sometimes, you want to provide content that's accessible as possible. If you have a small business who's website exists pretty much solely to give people directions to the physical store, then PE is probably a good idea. I can think of loads of sites that are quite heavy loading that use lots of scripting, which I only use to get an address or phone number off of. PE has the advantage of (generally) being lighter weight, and faster loading, and just generally simpler. To extend your analogy - it is like a car with a sail. If the car is for people who live in the city, then it's pointless. But if it's a car for people who live in a large flat desert with lots of wind, and care more about the car working robustly, no matter what, than they do about anything else about the car - putting a sail on it might not be such a bad idea.
With CDN, If your site isn't up, its game over. If their site isn't up it is game over. With CDN the odds of failure are your sites odds of failure * the CDN odds of failure. If your site is up and you don't rely on other sites unnecessarily, then game on. 
premature optimization? 
No, all the content will be free this weekend. It just hasn't started yet. It runs from midnight Friday to midnight Sunday, eastern time.
that isn't how CDNs are used. It is usually some server you have no control over, either uptime OR content. A bunch of servers that you are actively monitoring and have version control over is another animal.
Why this instead of an HTML Imports polyfill?
It's sad you're getting downvoted for advocating solid, defence-in-depth engineering practices featuring device agnosticism, declarative data and separation of concerns. FWIW I suspect it's only happening because it isn't trendy right now to build anything but client-side single-page apps that hide your data behind imperative programming code, make it difficult or impossible to extract and parse it in any way not explicitly allowed-for by the original developer, and require additional effort (anything up to re-inventing half of HTTP and the browser) to make that data appropriately accessible. Sadly, this happens every few years in the web-dev world - each new generation gets carried away with new technologies, starts massively abusing them left, right and centre and ignoring decades of hard-won software development best practices, then eventually discover their solutions don't scale, are inaccessible or make invalid assumptions about the way users, browsers or devices work, start disappearing down a rabbit hole of manually re-implementing most of what the best practices would have given them for free, and finally are forced to humiliatingly re-write their whole system the way it should have been done in the first place - following solid engineering principles and best-practices, optionally with a light dusting of whatever trendy technology they built the whole thing in to begin with. Twitter were the *absolute poster-child* for thick client-side applications when people started doing it - remember what happened to them not two years later? That's right - [a humiliating climbdown and substantial redevelopment of their entire client-side app](https://blog.twitter.com/2012/improving-performance-on-twittercom) in favour of a more progressively enhanced approach that pushed most rendering back to the server again. Sadly, people just stopped holding them up as a reason why entirely client-side development is the appropriate approach for many content-heavy websites instead of thinking about what happened and *learning the lesson* that Twitter had to learn the hard way.
I use my phone a lot while commuting. this happens to me at least twice every day, and it's *really fucking annoying*, especially if I'm trying to complete a long-running UI process (say, a wizard) in a client-side app and can't simply submit the form normally or refresh the page without losing everything I've entered up to now when I come out the other side.
The HTML is guaranteed to get through first as it's served by the site. Then, the difference between JavaScript and CSS, images and other (typically) remote content is that the lack of the later is handled gracefully by the browser and is often not critical to the user using the page. Whether the same applies to JavaScript is in the website designer's hand.
Sadly this is actually a reality for a lot of people.
You know, you're [completely, utterly wrong](http://www.reddit.com/r/webdev/comments/1xplrc/how_many_of_you_support_users_with_no_js/cfdkxg6). Progressive enhancement isn't even about "supporting non-JS users" (though posted article makes a fantastic mistake of buying into that fallacious framing of the issue). Progressive enhancement is about *good architecture* that embodies *solid engineering* and hard-won lessons regarding industry best-practice from the last few decades of software development. It's about ensuring device-agnosticism, clean separation of concerns, exposing declarative data (instead of hiding it behind imperative code that may or may not eventually return a rendered view of the actual data) in standard format(s) that can be automatically parsed and comprehended by clients agnostic to the specific site or system emitting it. It's about making things like search engines and automatic translation services easy (or even reasonably *possible*) to develop, making information atomic and easy to reference, making data easy to divorce from the presentation and simple to parse, aggregate and mash-up for a whole variety of purposes (many *not even thought of* yet) as well as making said data accessible to people and machines who aren't a graphical, desktop browser operated by a fully-able sighted person with a mouse and no co-ordination difficulties.
Does all the data have to round-trip through YQL? I think that by breaking cors via YQL/anyorigin might not be the best way to go about things. I'm probably wrong, but I think cors is there for a reason.
Ok I'll have a go. sortReps() takes a list, and returns an object keyed off the items in the list, with how many times they appear. So the example list returns { 6: 3, 1: 2, 4: 3, 3: 2, 7: 1 } the findMode() function (in this instance) take the list, uses sortReps to get the above object, then looks at all the keys in it, and keeps track of which of the items has the most iterations, then logs it out to the console. In this case it would log the above object as well as: [6, 4] Is there any part of the code that you would like better explained?
Many of his arguments centre around the speed and reliability of a user's internet connection. Moving to client-side templating in js has lowered many of the pages I had rendering ~1.5MB of HTML from one VPS, to ~600kB of JSON from my VPS and ~200kB for the JS of my app served from a CDN. The site can also load and render an empty template (shows the headers, some very basic content) and fill in the rest as it receives it. I really don't see how relying on a CDN is at all risky - most are exponentially more reliable than the connection any user is on to access my site. Using a CDN does, however, help to significantly improve the availability of my application's server as it now has less to do. The only progressive enhancement I need is a phantomJS running, which my web server will forward to if it's a request from a web crawler.
No pseudocode, since English is probably easier for you here. findMode finds the mode, i.e. the number that occurs most often (http://en.wikipedia.org/wiki/Mode_%28statistics%29). It has a 'callback', which means you can give it another function which it will run against the data before it gets the mode. sortReps is telling you how frequently each number occurs in the series. This is a somewhat poorly-named function, as it doesn't seem to be sorting anything. In js, objects (the thing num and freq are defined as) don't have an order, so it's not generally what you'd put a sorted result in. Anyway, I think this code kind of sucks. The functions aren't doing what they say they're doing, and it's taking a generically named 'callback', and doing something very specific with it (getting a 'sortedSeries', that's not even technically a thing that's sorted). 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Mode (statistics)**](https://en.wikipedia.org/wiki/Mode%20%28statistics%29): [](#sfw) --- &gt; &gt;The __mode__ is the value that appears most often in a set of data. The mode of a [discrete probability distribution](https://en.wikipedia.org/wiki/Discrete_probability_distribution) is the value *x* at which its [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function) takes its maximum value. In other words, it is the value that is most likely to be sampled. The mode of a [continuous probability distribution](https://en.wikipedia.org/wiki/Continuous_probability_distribution) is the value *x* at which its [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) has its maximum value, so, informally speaking, the mode is at the peak. &gt;Like the statistical [mean](https://en.wikipedia.org/wiki/Mean) and [median](https://en.wikipedia.org/wiki/Median), the mode is a way of expressing, in a single number, important information about a [random variable](https://en.wikipedia.org/wiki/Random_variable) or a [population](https://en.wikipedia.org/wiki/Population_(statistics\)). The numerical value of the mode is the same as that of the mean and median in a [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution), and it may be very different in highly skewed distributions. &gt;The mode is not necessarily unique, since the probability mass function or probability density function may take the same maximum value at several points *x*1, *x*2, etc. The most extreme case occurs in [uniform distributions](https://en.wikipedia.org/wiki/Uniform_distribution_(discrete\)), where all values occur equally frequently. &gt;==== &gt;[**Image**](https://i.imgur.com/KYJLany.png) [^(i)](https://commons.wikimedia.org/wiki/File:Comparison_mean_median_mode.svg) --- ^Interesting: [^Average](https://en.wikipedia.org/wiki/Average) ^| [^Guysborough, ^Nova ^Scotia](https://en.wikipedia.org/wiki/Guysborough,_Nova_Scotia) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqn5xqz) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqn5xqz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I am working on a similar problem. I would also like to see a working version of your code. 
I subscribed a while back and it was really cool. I just couldn't afford to continue and it wasn't completely related to things I needed to learn at the time. Totally worth checking out, though.
There's always going to be edge cases. The only way to accommodate most is to provide a shitty experience to everyone. Figure out who your main demographic is and cater to them. Then, if you find it makes sense, go after others. Unless it's a hobby, you should have a business reason to go after these edge cases.
Yup, it stores the previous tree on the Node itself. 
FWIW there is a site now: http://diffhtml.org
Hi, I am also learning JS and would like to join someone to share knowledge. I have done memory and another small activities in another languages, so may be we can share our knowledge with each other. let me know what do you think ?
I tried to browse one of my favorite pc shop sites today. In Firefox it works. But in chrome some JavaScript mid page load throws an error. As they pipe their pagination links through JavaScript functions, pagination does not work as of this. You never know what extensions the user has installed that modifies your website in a way, that could break your JS. And all the ad tracker and analytic scripts could cause problems, too. So ensure that at least the basic functionality works without JavaScript.
&gt; Why is it that not a lot of people make the same claim about progressive enhancement for when CSS fails to load? Google doesn't care when the CSS fails to load. Accessibility aides don't care when the CSS fails to load. When I'm on mobile, if I'm looking at an article *I* don't care when the CSS fails to load. If we're looking at a progressively enhanced site then none of these groups care when the JS fails to load. If the site is a SPA and the javascript fails to load and execute properly, the site is *completely unusable*. See the difference? &gt; It's incredibly easy to add an inline script that runs a check to see if an external script has loaded, and either try to reload the script, reload the page or just inform the user that it's broken, please try again later. And how many people bother to do that? I'd submit "basically none", so I don't see how it's a relevant factor in the discussion.
I don't think you have to provide a shitty experience to everyone, I think you just have to design with [Progressive Enhancement](http://en.wikipedia.org/wiki/Progressive_enhancement) in mind (like the author recommends)
&gt; The only way to accommodate most is to provide a shitty experience to everyone. The entire point of concepts like Progressive Enhancement (and especially advanced architectures like hijax, or a hybrid hijax/SPA architecture) is that this is patently untrue. You might not know *how* to provide a good experience with a progressively enhanced site, but that doesn't make it impossible. It's even funnier, because (for example) Twitter was the *absolute poster-child* for SPAs back in the day, until they discovered that no... actually their entirely client-side architecture had lead to a substantially *worse* user-experience and not two years after they first unveiled their trendy new SPA site were [forced into a humiliating climbdown](https://blog.twitter.com/2012/improving-performance-on-twittercom) where they went back and re-implemented everything with server-side rendering to get a faster and more responsive time-to-first-tweet. True story.
Absolutely! Point is, you'll be hard pressed to find anyone building a *new city* with narrow twisty roads.
Well let me rephrase this then: Without a lot of extra work and code to maintain, the only way to accommodate most is to provide a shitty experience to everyone. Rolling this up into a concept doesn't make it magically happen. If there's no business case for it, why do it?
is that any results added by the server and/or client. For example say I subscribe to the last year's worth of orders on an administrative part of an eCommerce system. If a user puts in a new order via server and/or client. The text implies in **"Any further pagination and or data modification will have to be done client side."** that the new order would be missing from the administrator's data set. Thanks for clarifying! :D
Solid point, and I don't disagree. However, as fewer and fewer web users actually use what we would think of as a "computer" rather than a "mobile device" it makes sense to think about the mobile experience first even with an SPA.
My original comment was incomplete. My point was, progressive enhancement isn't free so if there's no real business case for going after various edge case scenarios and devices, why do it?
&gt; Why is it assumed that the HTML will get through when the javascript won't? Because the HTML is always the first thing that loads. If the HTML "doesn't load" then it's a server error. (And clearly that means the JS isn't going to be coming any time soon either...) &gt; Why is it assumed the javascript and CSS are not served by the site? It's not. Hosting that stuff on a CDN is only one possible failure. Neither makes a difference if the user has JS disabled or a browser plugin blocks it due to the filename or whatever. &gt; Here's the problem with that whole train of thought. Barely over 1% of all visitors have js turned on and we have to do more work for the (how many?) times they can download only the HTML and the js fails for some reason. How often does that happen? 1%? So extra work for the 1% of 1% of the times that happens? Not following this. Firstly I assume you mean 1% have JS turned *off*. And where does the "1% of 1%" come from? The "js fails for some reason" part applies to the whole 1%.
It's not a flow chart at all.
You are welcome! Thank you for going out of your way to be helpful. That's one of the things that can make reddit great. Keep it up, and enjoy the gold!
Ok, thanks for the info! 
It's not always about the file loading. CSS is generally more forgiving of errors. If you miss a semicolon or mistype a property, just that rule is ignored. But if you make a mistake in your JS it's more likely to render the whole file unusable. No amount of reloading that file will fix that.
&gt; Given the URLs Just to point out, this means nothing. You can make a subdomain point to anywhere so they could be using an external CDN (though they are probably not).
&gt; Why is this difficult? Because it's not a blog full of content - it's a revolutionary interactive animated graphical UI paradigm which *merely happens* to deliver textual content to users. They aren't really on your site to read your article or check what time their train leaves - they're *really* there to marvel at your buttery-smooth, hardware-accelerated 60fps animations and 1337 client-side javascript skillz that mean you can browse the entire site without ever once touching the server after the first page-load... just as long as you don't mind that first page-load being 3MB in size, crapping out on unreliable mobile connections and taking whole seconds between DOM-ready and the UI actually appearing. But it's ok, because the ToDo app I wrote to test this approach performed pretty well with just me and my mum using it, and I don't care whether Google indexes it or not or whether blind people can see it because fuck them - they should just *get some eyes*, amirite? Likewise anyone who ever wants to consume my content on a device I haven't explicitly allowed for (or that isn't even invented yet) can just go *do one*. What is it about the word "web" that makes people think of interconnected nodes that all work across a common set of protocols and idioms and allow information to flow unimpeded from one place to another? Idiot hippies - they can consume my content in the way I decide they should or they can *fuck off*, yo. Because I'm a *professional* and nothing says professional like choosing a technology because all the cool kids are currently going "squee!" over it, rather than because it's a good solution that follows solid engineering practices and performs well in the specific problem space we're working in. Besides, if people bitch and whine about not being able to bookmark individual sub-pages I can just go out of my way to implement [ass-backwards hacks](http://isolani.co.uk/blog/javascript/BreakingTheWebWithHashBangs) like the hash-bang URL support (I know Google themselves advised against relying on it as anything but a hacky workaround, but what do they know, right? They only invented the technology), forcing the entirety of my routing into the Javascript layer for ever more. Because that's what we want, right? To force more and more legacy code and functionality into the front-end code we serve to each and every user for the rest of time, because it's *literally impossible* to *ever* route hash-bang URLs on the server? Sweet. Hell, having built my entire app on the client-side, if it turns out I actually need it to be statically accessible (not that that would indicate I've chosen my entire architecture *completely, absolutely, 100% wrongly* or anything) I can always just intercept the requests for an arbitrary subset of all the clients that might ever need static content, host a client on my server then run the client-side logic in the client on the server, extract the resulting static DOM and send it back to the *actual* client on the client-side. Then the only problems left are looking myself in the eye in the mirror in the morning and *ever again* referring to myself as a "real engineer" without giggling. Shit's easy, yo. I don't know what all you old grandads are bitching about with your "separation of concerns" or "accessibility" or "declarative data". Shit, I don't even know what half of those words *mean*. But I still know you're wrong, right? /s
[Are you sure?](http://blog.easy-designs.net/archives/the-true-cost-of-progressive-enhancement/)
Then your HTML should contain a script that does an ajax for the JS and injects it in a &lt;script&gt; tag so you can always detect real failures and trigger a response. In reality, if a person has a problem loading a page, they can hit the refresh button and get a "network unaccessible" error. That's the closest to foolproof we can get. I think focusing resources on the many infrastructure issues that happen frequently should be preferred instead of accounting for weird network failures that don't happen 99.99% of the time. 
~canvas spriting intensifies~
&gt; Without a lot of extra work and code to maintain Again, if you don't know how to do progressive enhancement well at an architectural level, it can look like you'd need to duplicate effort, sure. That's not necessarily the case, though. One interesting development here is the (old, and now new again!) idea of javascript on the server allowing for isomorphic javascript - the same code and same logic on the client and server. That should make DRY progressive enhancement obviously, trivially easy, as opposed to merely needing skilled framework developers to strike the optimal balance regarding responsiveness, server round-trips and duplication of business logic. &gt; If there's no business case for it, why do it? Because not having to rebuild your entire website every couple of years because you fucked it up the first time and it doesn't scale or requires ridiculous, fragile hacks to even make it accessible to Google *is* a business case - just ask Twitter or Gawker. ;-)
Because if you write semantic HTML instead of &lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;, the browser's default styles will make the page look reasonably presentable enough that you can navigate it and then hopefully the next link you click will succeed in loading the CSS and/or the JS.
If you go isomorphic you can have your client-side templating without abandoning progressive enhancement.
Ah yes, the tired old fuzzy "app vs. webpage" argument. Jake Archibald's [got you covered there too](http://jakearchibald.com/2013/progressive-enhancement-still-important/). From the article: *"App" is not an excuse* *"Yeah, but I'm building a webapp, not a website" - I hear this a lot and it isn't an excuse. I challenge you to define the difference between a webapp and a website that isn't just a vague list of best practices that "apps" are for some reason allowed to disregard. [Jeremy Keith makes this point](https://adactio.com/journal/6246/) brilliantly.* *For example, is Wikipedia an app? What about when I edit an article? What about when I search for an article?* *Whether you label your web page as a "site", "app", "microsite", whatever, it doesn't make it exempt from accessibility, performance, browser support and so on.* *If you need to excuse yourself from progressive enhancement, you need a better excuse.*
You're correct that most of the web is well served as a glorified document. This is a solved problem (let's face it, basic wordpress is fine for 90% of websites). Developers who provide all of these things additional features for basic CRUD sites are probably overbuilding. My abilities as a Javascript developer aren't particularly needed for these sites (these sites are still well-served by jquery), so I focus on parts of the web that aren't glorified documents and instead try to solve problems once relegated to desktop apps. As a result, the idea of progressive enhancement doesn't really make sense. I believe most /r/javascript users are in similar positions. 
I like you
No shit, Sherlock, but you missed my point that people are so concerned about properly loading javascript when the real problem is a temporary connectivity issue among a minority of people who intentionally turn their js off.
&gt; Because the HTML is always the first thing that loads. Not my point. People are talking about "What if the js doesn't load?" which makes me question why they aren't also concerned about the HTML and CSS not loading and, in either case, why isn't it loading at all? That's a network connectivity issue and an abnormality. As far as the assumption goes, the post I was responding to specifically stated the javascript and css not being served by the same site. The "1% of 1%" comes from my post where I said, "How often does that happen? 1%?" meaning, how often do 1% of all a site's users who intentionally turn js off also lose network connectivity.
 for(var x = -6; x &lt;= 6; x++) console.log(new Array(8 - Math.abs(x)).join('* ').trim()); One Line To Rule Them All
We live in 2015, if you run the web with no JS enabled, i say good luck. Really, the web and JS gets too much shit for "not working" and its just ridiculous. Imagine if you would need to teach your client how to install some obscure c-compiler from source, or Java with a browser plugin, or maybe we need something else with an runtime? With JS its basically install chrome/ff/etc and retry.
Well, the thing I came across that made me post was this little snippet from one of the (pixi.js tutorials)[http://www.yeahbutisitflash.com/?p=5666]. Frankly I don't quite follow all the way... function Far(texture, width, height) { PIXI.TilingSprite.call(this, texture, width, height); } Far.constructor = Far; Far.prototype = Object.create(PIXI.TilingSprite.prototype); far = new Far(farTexture, 512, 256); 
You can. Although there aren't many things which are properly isomorphic. I just found out today that Meteor isn't :(
It has everything to do with Javascript if *not* having Javascript means I can't view the content or interact with the page in a meaningful way. Something as simple as not being able to see your main nav because it's hidden behind a hamburger icon and you have it hidden even when js is absent can be a massive pain point to some users. And it's so easy to account for!
&gt; it's better to be in business with something adequate, than not in business with something half-built. That's absolutely true, but I would contend that if you do progressive enhancement *right*, at an architectural level, it doesn't have to cost you any extra development time compared to an SPA. If you need to rush to market you might just start with a simple hijax framework that renders all the content on the server, intercepts link-clicks on the client, makes an AJAX request for the changed content then dynamically inserts it into the page and uses history.pushState() to maintain restfulness. There's nothing more time-consuming about that than using a javascript SPA framework to begin with. The problem is that people often do PE *wrong* - things like naively duplicating all their business logic and templating system on the server and on the client in two different languages - and then assume that's the only way to do PE. It's not - it's just not doing it *well*. ;-) Equally, as you point out, there are plenty of use-cases where SPAs are perfectly valid - genuine "app interfaces" are an obvious one. The trouble is that like any *trendy* technology people grab a fantastic idea for a handful of use-cases (like app UIs with no meaningful public *content*, like games or enterprise apps full of private data) and start applying it to completely inapplicable use-cases, like product catalogues, blogs or social news sites. I totally agree with you that no one size fits all scenarios, SPAs definitely have their place and you should always choose your tool to fit the problem-space. In fact I suspect we just flat-out *agree* on the subject - I'm just emphasising the undesirability of SPAs in many situations because the context of my comments is a developer community absolutely in love with them and rushing to implement every new project in them as a basic starting assumption, regardless of whether its appropriate to the problem domain or even make sense. Also, notice that I wasn't claiming PE was the only right way to ever build a web front-end - I was correcting a comment implying that it **never** was.
Last I saw, [the plan for Phaser 3 is to separate from Pixi entirely.] (http://www.html5gamedevs.com/topic/11783-phaser-3-development-log-we-jan-16th/) So it's possible we won't see Pixi v3 in Phaser. The reasons they give are entirely understandable of course, but it's sad to see any project split in two.
I'd say for most designers/programmers, the intent and functionality of the program is made to suit the demographics. At the beginning, there's a few things listed that are just defined as error checking. At the end, there's things listed that one could try to error check, but are non-standard [whargarbbl](http://i.imgur.com/YZNNXfa.jpg).
&gt; document.getElementById("total").innerHTML(response); innerHTML = 'foo'; It's a property (with setter), not a function. See also: https://developer.chrome.com/extensions/tut_debugging http://stackoverflow.com/questions/10257301/where-to-read-console-messages-from-background-js-in-a-chrome-extension
How are you beating lodash and underscore by 6*? Are you memoizing the result? It seems impossible to beat already optimised iteration methods by this amount without cheating.
hosting on multiple sites has multiple issues, especially if it is the "grab a free copy of jquery from some 3rd party" variety. If ssl is involved it can be even slower, caching even from your own site is a no-brainer, and I guarantee %99.99999999 folks using cdn don't benchmark (or "pay"). You are adding costs and risk vectors that you are apparently unaware of nor even know if it is helping.
Open bookmark manager and create a new bookmark with this as the url javascript:window.location = (window.location+"").substring(0,9)+".editorial"+(window.location+"").substring(9);
Sounds like a bookmarklet, and although /r/javascript isn't really a place to make requests for code, I have a minute and this sounds fairly simple. So to be clear, it sounds like you want to turn something like this: http://foo.com/x To: http://foo.com/x.editorial ?
Node.js/IO.js _is_ JavaScript... no "conversion" needed. It sounds like you want to actually run the client side JS on the server in an attempt to restrict access to "view source" in the browser -- this isn't really possible because JS on the frontend/in-your-browser _needs_ to run in your browser to access things like the locally rendered HTML/DOM.
Yes - except it's not the end of the address. I would like to change nyhederne.tv2.dk/ to nyhederne.editorial.tv2.dk/ with all kinds of different articles after the / Does it make sense? :) And sorry for posting the wrong place - where should I go next time?
Yes. This has been badly worded and we are fixing the docs. If you are subscribing to the last years worth of orders, and new orders are coming in they will continue to be sent over to the client as they update. What that means is that if you are subscribing to this years order and you decide you want last years, then that won't be reactive until you refresh the server. Its a limitation we are currently working on solving.
The great part about this is that this site is usable with services like Readability because it's using good progressive enhancement practices: the presentation is an enhancement of a solid content layer, just as interaction is an enhancement of a solid presentation layer. Yay!
Yep, that was it. Thanks! I forgot about http:// so I needed 16 instead of nine.
I think true progressive enhancement and full functionality without JS is unrealistic and unnecessary with web applications, but keeping it in mind often leads to better results and avoids many potential pitfalls with both usability and search engines. For example, If you have any content that isn't accessible with unique URL that returns a complete document, it should be a decision you make, not something you just didn't consider. If it's something minor that doesn't have to be indexed, anyone isn't going to open in a new tab, bookmark, share and so on, sure, fetch if with AJAX after some JS event. But if you are dealing with meaningful content that the previous doesn't apply to, then the server should be able to render a complete document with it for unique URL.
I wouldn't call it a fad. One of the main reasons I avoid `new` is to reduce API surface area. When you work with many dozens of small modules that need to compose well together, it gets pretty annoying when some of them only work with the `new` keyword. It also causes issues with various functional paradigms (functions as first class citizens etc). Most of the time, it's an implementation detail that is not relevant to the end-user.
If you don't understand why progressive enhancement was much more relevant 8 years ago and not so much today, then I don't know what to tell you. The entire Web is completely different than it was back then. To reach every single person requires way more work than it's usually worth. So you pick and choose your progressive enhancement battles carefully. It's foolish to just say you should support every scenario because those scenarios take time and effort, which is money. 
I think bind is a primitive in Javascript, in that it cannot be recreated in the language itself. Apply and call can be implemented in terms of bind. I don't think what you're trying to do is feasible in the language without having access to the AST. Sorry. 
I totally agree!
I found his counter-argument a little weak. On one hand - one could view the content-consumption of Wikipedia as the 'website'. This is what most people land on, use, etc - and yeah, there is little reason to make it an SPA and /need/ JavaScript. The 'editing' / admin portion - this gets a little more into app territory. But, the interaction needs of wikipedia are simple enough that using progressive enhancement probably wouldn't introduce a huge extra burden, and could still be an 'enjoyable enough' experience. When you start getting into applications that are looking to replace native/desktop apps - tend to have a business-focused use case, etc and need to do far more complex things. You start hitting a point of which the extra effort of doing progressive enhancement isn't worth it, and even if you did go through the effort - the end user experience of the project would be such crap, that most people wouldn't want to use it.
in ES6 you can use the spread operator to do it like this.... var result = context.fn(...args); I don't know if its possible in ES5 code though...
I develop interactive visualizations and data analysis applications to be deployed over the web. The things I do can't be done as a series of linked, static HTML (or templated HTML pages). All applications have system requirements. One of my application's requirements is that it be run in a webkit browser with javascript. It's not worth my time and effort to create some halfway functional implementation to appease some luddites. The web is changing, the browser is a deployment platform now. The web is not just a series of interlinked pages (delivered through tubes) like you seem to believe. Sure, people overengineer CMS sites with all sorts of unnecessary garbage, and the single page app causes as many problems as it addresses. But you have to face the fact that highly interactive javascript applications are here to stay, and increasing in relevance and adoption.
This list ignores browser caching https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en
TL;DR: Search engines and blind people can piss off because they chose to be that way, and could chose to not be if they wanted. Also, solid engineering best practices, accessibility, separation of concerns, keeping your data accessible and declarative and client/device agnosticism can piss off too. And free RESTfulness, SEO-friendliness and accessibility are all pointless when you can just waste time going out of your way to manually reimplement all those things yourself. Still TL;DR: I think the debate around making JS mandatory to access the content of a site is about whether graphical desktop browsers support it or not, rather than about engineering best-practice and good system architecture to create a flexible, scalable and future-proof system. Still TL;DR: I've only grasped the most shallow, trivial aspect of a deep system-architectural engineering problem and as such am completely wrong.
&gt; One of my application's requirements is that it be run in a webkit browser with javascript Why webkit, exclusively?
Its true that it isn't truly global, but its accessible by not only the parent and child, but also every directive on the page. In essence if you have multiple children active for that same parent (like multiple states on a single page) then every child will be connected. Then it doesn't really matter if you'd use broadcast or a scope variable, as it will pass the same digest loop. The performance degredation for them will be very similar. As long as other people also understand what it is and why you've put it there, its solid enough to favor both as per personal preference.
I think that is a more fair assessment.
Yep. Now how do you apply the accumulated arguments to the function without apply? Functions are runtime opaque. You need a primitive like bind or apply to implement any of this stuff. If you can show me a bind implementation without eval, apply, or call I'll apologize. If you *can* implement bind, just reduce left over the argument list and call the result. That is exactly what apply is. 
Posted solution in question body
In this scenario, progressive enhancement was the right tool for the job and it was completely disregarded because it isn't trendy anymore. The web community keeps uniformly dumping on it for absolutely no good reason. I wouldn't use progressive enhancement to build Angry Birds, but it's still the right tool for the job for way more classes of web applications than a good chunk of the webdev community seems willing to admit right now.
Ah yes, the tired old "extra effort to do progressive enhancement" argument. Aaron Gustafson's [got you covered there too](http://blog.easy-designs.net/archives/the-true-cost-of-progressive-enhancement/). Good stacks prevent it from being extra effort.
As with JavaScript, you fail to see the point. Building your website with JavaScript required is akin to building an hotel with no stairs, only elevators. It's great when it works, but as your said yourself, "99% of the time it works". The other 1% of the time, people can't go up or down. New customers are blocked in the lobby. Your hotel is now useless. If you had built your hotel with escalators instead, people can still use your hotel like they could still be using your website even if JavaScript fails to load.
Yeah, that works for curried functions but literally nothing else. You could not use this with a non-curried function. Side-note: bind isn't currying. Having a function that takes a single argument and returns closures is currying. Bind is partial application and works on non-curried functions. 
Have an up vote sir, that was great and pretty much reflects my feelings on the whole FE side of things.
That's the thing -- prototypal inheritance is hard to grok, especially for those who learned classical inheritance first. People like using it because it reminds them of classical inheritance, but it does different things behind the scenes. Heck, even calling `new Foo()` in JS can do many different things, depending on how `Foo` and its prototype chain is defined. Why not avoid `new` if you can help it, and save the confusion?
I don't expect Inkscape to allow me to edit my SVG document when in Init 3 (or whatever textmode is called nowadays with your systemd's and whatnots). The only "tired old" here is that browsers are for websites. Besides, both counter arguments you linked to show categoric misunderstanding of what web applications are supposed to be (and that is: GUI applications, as in, Word, Photshop, that kind of shit), and prove my point with examples they point to which are: 1) a Wiki and 2) a Wiki...
This seems like a better argument for *embedded* JS rather than *no* JS. (and yes, I'm being facetious... mostly) Some of the things on that page fall in the category of "beyond my control" in my opinion. A train through a tunnel? It's true, but am I as the developer *really* supposed to worry about such things? A backhoe driver could cut the user's fiber too... not exactly my problem. ISPs messing with the content? Also beyond my control. Corporate firewall block? Ditto. A major backbone router going down in the middle of my transaction? Could happen. The argument being made is that they *aren't* beyond my control if I just use PE. While I concede there's some validity to that argument, it's a bridge too far in my opinion. You'd no sooner expect a car to work without gas then you would a modern web site to work without JS, or at least that *should* be the mentality. I think PE's an idea who's time has come and gone frankly and clinging to it is just making life more difficult for ourselves in exchange for not very much gain. It's a question of odds: if PE helps users 5% of the time, that's great, so long as the cost of that 5% isn't too high. My opinion is it usually is, in terms of the opportunity cost of other development that could be getting done instead at least. Now, just like driving defensively, that doesn't mean you shouldn't not code defensively where possible. If you can do little things here and there that doesn't introduce a heavy development burden then sure, go for it, that's good sauce. I'm just saying basing your entire architecture around all the what-if's and maybe's is kind of a waste of time, money and effort.
"JS enabled and working" is what I was describing with my first post. It sounds like the rendered HTML is *massive* and you can get some significant space savings by just sending the data and templates and letting the client do even the initial render. Doing progressive enhancement/isomorphic means sending the initial rendered HTML down even if the client has the ability to render it, plus the JS to do the rendering, plus the data if you're going to rehydrate client-side for some sort of rich experience.
Most of your points are true, and I agree with as I said earlier, if they apply to the situation but they don't apply in all situations and you are presuming all of your points are true in every page of a site. Such as assuming the javascript is being used to generate content.
In some corporate places they aren't allowed to download modern browsers. 
Not so worried about the animation as the scroll events firing unnecessarily. I have a project where I'm building animations to occur depending on where you are on the page. Many elements will have fixed positions so they will simply follow the user. Detecting the scroll, I can force a new animation or some function x to fire. I was hoping that waypoint and wow would have a clearly defined debounce to ensure performant scroll firing. I'm trying to build a micro-benchmark right now, I'll update the post if I complete it.
I think the question is though: should we care about claustrophobics? The web is now de facto javascript-required. So the burden has shifted from site-designers to site-users. Yes, someone has to care about not having javascript: but why, today, should that be the programmer and not the corporate firewall department?
I'm just trying to point out that the browser is shifting from being a document viewer to being a deployment platform for applications. A lot of the web works ok as pages with a little bit of JS sprinkled in... but limiting yourself to that paradigm when it doesn't fit well isn't a great idea. Furthermore, when you look at the bigger picture of trying to deploy an app to the web and mobile, the SPA approach can help keep a single code base and allow for offline functionality. (to add to my point about things changing)
It's a blog FFS, so it better be. If it were done as a SPA, lack of PE would be the least of things that were wrong with it. But it is interesting that someone with that particular choice of design would lecture people about what, essentially, is an accessibility issue.
&gt; Proxy browsers (like Opera Mini) with limited javascript support are still used in very large parts of the world. According to statistics I usually see, Opera Mini doesn't seem to be used as much as you say. Even in the third world country I was born and live in, people can afford a cheap Android phone with full support for javascript.
&gt; I think the question is though: should we care about claustrophobics? You've successfully missed the whole point of the discussion. It's not *about* claustrophobics - they're a tiny, almost statistically-irrelevant edge case. It's about what happens to **everybody** when the elevator or escalator breaks down.
&gt; The other 1% of the time I haven't read the article, but I would guess the real number is closer to "the other 0,1% of the time" or even "the other 0,01% of the time".
Some. But how many? There are DOZENS of them, right? I don't care about them. At all.
he has SEO in his name, maybe he is trying to render stuff server side so search engines can read it
When the elevator breaks down you're stuck for awhile. Just like when the car is out of fuel, or you're battery goes. When things break, they break. It will never be possible to eliminate failure... are we getting to a point however where failure-due-to-js is as acceptable as total failure? Well we're already here. We've added one more total-failure condition to the internet... what's the price? Well, an internet worth having. Who get's permanently left out? The claustrophobics. 
The article links another article: https://gds.blog.gov.uk/2013/10/21/how-many-people-are-missing-out-on-javascript-enhancement/ In a sense, you are actually right: 0.2% have JavaScript disabled. However, 0.9% couldn't run JavaScript for a reason or another (network problem, JavaScript error in browser, etc.) So actually more people may legitimately suffer from bad design than people knowingly disabling JavaScript.
Read this article while replacing JavaScript with CSS and you wont be able to take it serious anymore.
But wouldn't it be nice to have stairs when elevators break? Legs when your car is out of fuel? That's the whole point here. With your point of view, if you car runs out of fuel, you can't open the door anymore, or listen to music, or anything else. Your are stuck with a shitty car. Better cars let you open the doors, even when out of fuel. Look I'm out of comparisons here. I know it may be hard to understand the foundations on which the web is built (it's not actually) but don't count on me to use your inferior product. That internet is not worth having at all. We may as well go back to the Netscape/IE browserwar and incompatibility mess.
I had the same experience regarding nested views and models, and I was using marionette. Wouldn't recommend for anything non trivial 
A lot of applications are not possible without JavaScript. It really depends on whether you're building an actual application or a website. How would you build something like a a web IDE or a Photoshop without JS? Where does progressive enhancement fall into that? There's a TON of applications that fall into these categories. SEO is not a problem for a lot of applications, for example, a ton of applications are password gated. And even then, you can do isomorphic apps to pre-render on the server. And even THEN, AFAIK, Google and Bing have started running JS in their crawlers. You can have a restful api and a full JS client, which means that you can do whatever you want with the data. Best practices should be questioned, tested, and reviewed upon receiving new knowledge and experiences. What works in one project might not make sense for another project. 
I built a sizable SPA with Backbone and using Marionette made things a little easier. I agree that organizing nested views and models gets ugly. After playing with React + Flux I don't think I'll ever look back.
Saying that architecting with PE in mind costs no extra assumes that the one doing the architecting already has all the knowledge needed to do so. There may be plenty of valid reasons they have chosen to learn something else instead. Saying that CSS not loading is not an issue is pretty much ridiculous. Sure you can cherry-pick use-cases where it's ok for CSS not to be present, but is that any different from cherry-picking cases on the other side of the argument? I don't think so. You can choose your audience (and what to support) and you do not have to cater to everyone. Your ability to choose your audience probably varies based upon your situation. Most of the failures in the original article are network-related in some way...if network issues are occurring all bets are off and PE isn't going to save you unless you just happened to have loaded everything you wanted to look at (and no CSS is ok). How are you going to post your form if the network is out?
Then don't visit that site.
Ok, replace Inkscape with Gimp and SVG with PNG and stop being a smartass (I know about xxd and dhex already). My point still stands, and you missed it, perhaps deliberately, but that doesn't invalidate it. Or perhaps you know of a way to edit Google Docs in a browser without JavaScript, and in that case (unless it's a Java *cringe* applet) do share.
Except that works only in that particular scenario, which is what we like to call: hyperbole. And good luck editing that SVG tiger with vi - or even inferring it is a tiger from looking at "base data":.
Please explain what the content, presentation, and interaction layers are in google docs and how you would go about implementing them such that it works with progressive enhancement.
I couldn't take it seriously the first time.
Those 0.9% are likely NoScript users, which doesn't evaluate noscript tags. 
You didn't read the article too, didn't you? 
Feel like this really depends on your audience. If you're building a landing page for a large company, and need it to work always then, yes this is important. If not, meh, take it or leave it.
I'd suggest npm over bower. It has a larger ecosystem, better persistence and semantic versioning, and overall a brighter future. &gt; local repository What do you mean by this? Locally on your file-system, as in version control without GitHub/Bitbucket/etc?
Even car designers are about the business case, including initial and ongoing costs. THAT is called being professional.
&gt; IS THE CDN UP? Maybe we should just stop developing websites since our servers aren't up 100% of the time. 
Everyone has javascript and as long as your page is also handicap accessible I don't see why you should bother worrying about someone not having it. If the connection breaks down and your script isn't served then that's too bad. Same problem exists if the HTML was not served.
I used this same strategy, but the problem I had with child views was with events and passing data to them. If the view is nested one deep, it's ok, but three or four layers deep it's a nightmare. 
&gt; If you don't understand why progressive enhancement was much more relevant 8 years ago and not so much today, then I don't know what to tell you. It's every bit as relevant as it was 8 years ago, and 28 years ago. You may be too young to remember the time before the Web, but it was littered with a million extremely rigid and incompatible information formats, often embraced by the Compuserves and AOLs and Prodigys of the day. Which were sort of one giant mass of relative failure. And then someone had the bright idea that we should come up with a loose, flexible format for suggestive, non-prescriptive formatting, that would definitionally work with a million different clients that were not under the control of content creators or distributors. And the world was changed, and the entire industry that offers your livelihood was born. Now there are a bunch of kids who don't remember why these choices were made in the first place, and want to remake all of the same mistakes made in the past. And eventually history will teach them the same lessons it did everyone else. 
I did in fact read that article, and it made no mention of NoScript or the like. 
those are good suggestions though
I had the same experience. I've used a lot of frameworks on projects ranging from small to large and React/Flux has been the nicest to work with overall.
This answer is just so incredible. I'm half-way through and things are really starting to clear up. I urgently need to go to bed (early morning) but I'll get back after the weekend. So far – thanks a lot – and for the record, you're a brilliant teacher.
Yes, Marionette does tons of heavy lifting with regards to nested views, events, memory management. I wouldn't build a big Backbone-based app without it (or something like it).
Awesome, Thanks for clarifying :D
Two other extensions of Backbone to have a look at: Ampersand http://ampersandjs.com/ Brisket https://github.com/bloomberg/brisket
Actually, it is possible with the Filesystem + Source Maps if the server filesystem is mounted. On the other hand I guess he doesn't want to use the [Raw TCP API](http://www.w3.org/TR/tcp-udp-sockets/) yet as it's not yet there without shims.
It depends on the code, and you are ignoring maintenance.
npm allows you to install and re-use code from GitHub as long as it has a package.json. But usually when you start re-using a lot of code between projects, you will want to use npm registry rather than GitHub. You'll also start to see benefits in things like: smaller and more decoupled modules, independent versioning, etc. Some references: - [module basics](https://github.com/Jam3/jam3-lesson-module-basics) - [creating a module](https://github.com/Jam3/jam3-lesson-module-creation) - [module best practices](https://github.com/mattdesl/module-best-practices)
Thank you very much. I will probably use bitbucket (git) but I want to control which version I will use, maybe it works with the tag in commit, right? I already use npm but not like this.
Backbone is spectacular for organizing the front-end code of a backend rendered website, which is what it was built for. It can be used for Single Page Applications, but you're gonna end up writing a LOT of support code to do so (or lean heavily on something like Marionette). It actually pairs pretty well with React.
IMO nobody has an excuse not to test on IE8+ these days. Microsoft maintains and promotes [free virtual images](https://www.modern.ie/en-us) with built-in debugging tools that allow testing on any platform with almost no effort. As professionals, we should also be able to pay for even [better services](http://www.browserstack.com/) if needed, as well. But that's just in a vacuum with no real idea what your app does or what the userbase looks like, so I'm not trying to judge ya or anything.
Yeah sometimes pages don't load correctly so what? 
This is how I use it. Can build some nice things with it that are ultimately backed by server-side code without it trying to determine how things are laid out. Waiting to see how things shake out for something dedicated as a full-on front-end app. I think I'd use something more opinionated for something of that scale. Maybe Angular2? (Dunno yet, waiting for it to release before bothering to learn it.)
Flux definitely goes a long way - my first big React project took a more traditional MVC approach, and it ended up with some pretty long series of classes passing the same callbacks all the way down in order to implement some two-way data binding. Flux cleans things up immensely. Where I find flux really outshines alternatives like ember or angular is when you're integrating multiple, disparate data sources. Ember is quite nice when you have a basic MVC on the server-side (e.g. a Rails app), and an open socket that just exchanges JSON between ember and the server to keep your models synced. With react on flux, I have apps pulling from my server app, google fusion tables, the twitter + instagram APIs, and some stubs where I plan to use more services eventually. They map very readably to events that update my react component's state, and React's whole "render everything" approach keeps everything the user sees up to date and accurate.
I stuck to the core backbone framework. I thought marionette was an overkill for my application as there are not many cases where I use nested views. The few places I used nested views I wrote code to destroy them when the parent is destroyed. As for event propogation, I wrote a simple function which tells me whether the event was generated by that particular view or not, and re-used it across child views. And of course there is the initialize method and callbacks passed from parent views. 
This is the de facto-standard obfuscator. Don't know what JScrambler means by "protecting your JavaScript"...
[jsblocks](http://jsblocks.com) have MVC(Model-View-Collection) architecture inspired from Backbone. And it is really powerful and large scale application really well. [TodoMVC app build with jsblocks](https://github.com/astoilkov/jsblocks-todomvc)
Maybe you could humor us by giving us something that is a little longer than a 1 word answer.
Hi, former Marionette core team member here. Since a bunch of people mentioned Marionette in this thread I thought I'd point you towards my [Marionette Wires](https://github.com/thejameskyle/marionette-wires) project. For anyone wondering why I'm a "former" core team member, it's because I'm switching to Ember for many things (You'll see a lot of Ember inspiration in Wires). Also between being on the core team for Marionette and Babel my life was getting crazy.
js-obfuscator sounds quite stupid. You are trying to somehow "protect" your code but send it to some unknown server where it "may be viewed and/or stored". It's like being paranoid but trusting some random stranger who is even telling you he shouldn't be trusted.
When using Knockout I usually go for knockout-postbox (https://github.com/rniemeyer/knockout-postbox) for pub/sub functionality.
The only real way to use datatables.net is to load all records into it and let it handle everything. I cannot speak to AngularJS, I am too much in love with React. 
Yes, i have heard of those places, but i think they are more of an myth. The overall feeling i get is PC_LOAD_LETTER dating back to the 80s having a wacky tie day on the last Friday of each month. Still only allowed to use IE6? Yes, keep on working, because we really need those TPS reports done by Wednesday.
It would be nice to see the code on github, so I would give a custom valueOf() and custom toString() with custom data types a try. Might be worth seeing that null / Number in valueOf() will result in the fastest behaviour :D
Unfortunately the DataTables.net plugin doesn't agree with angular quite well. This component provides a single jQuery-like function and takes a javascript object array as a parameter, then internally constructs the table from it. Angular, however, expects us to construct a table using `ng-repeat` clauses and the data is in a backend controller, so how do you load all records into it? It cannot be done from the controller, as it is totally isolated from the jQuery and other objects.
I might try this if for no other reason than the documentation is great.
I really like Fullcalendar. Not sure if you can do the dragging you're speaking of, but should be possible. It's already responsive, you don't have to worry about that. I use SlickGrid for tabular data. It's very powerful if you want to display large amounts of data. Like a million rows. With grouping and many other very usefull features. It's very fast and very customisable. I haven't tried DataTables yet. I'm currently working on a project that uses it though, so will soon.
I actually used datatables to represent a horizontal calendar view (columns represented days, rows were events) in an application, and it worked out great for me. I don't have any experience with any other plugins, but it was easy to use, lots of customization and plugins available to get it to work how you want.
Is this the end of MVCs???
I actually wrote a previous version that used Redis for storing it like a cache, but I'm working on making it as dependency-free as possible. Hopefully sometime I can get it down to just straight Javascript and no longer require jQuery. Thank you for the input!
If you need framework components without the the whole framework, I'd consider ampersand.js. lo-dash split all its modules on npm, so you can search for lodash.whatever and get just that. Like lodash.each or lodash.every, etc... That's all I can think of. Best things to do would be exentisively search for tiny modules that do what you need, and if they don't exist... create them :)
I like the "roll your own" mentality but I'm not a fan of es6 class and static methods.
&gt; Just call the API from angular or vanilla JS. I'm confused where should I call that from? My controller.js is totally fortified from the front-end, so I can't call it from there. If I call it using front-end jQuery, then how can my controller.js know abt it?
Decent article, but seriously how many different blog posts are going to use the title "What the Flux?"
lol http://imgur.com/EqHTKm3
You would send an event that new data is available. That event gets fired on all listeners that listen to that specific set of data. Your input component listens to that data and disables the input when it sees the new data with the field that tells it to do that.
I feel like this was already posted a while back.
And? Reddit's been like that for years. In fact, it's improved significantly since they started using an external CDN. Edit: do you even understand what that message means? It means the CDN is working fine but the reddit servers aren't. So you've dug yourself even further into your hole of ignorance.
I have used both recently, and I will use them again. I found them very easy to customize/extend. The downside is that they both are quite big and you may find you need to play with them for a while before you figure out the way you need to extend them for your particular project. I can't speak to the backbone side, but I have used fullcalendar to make spanning durations bars as you describe. And fully customized the look.
I can recommend data tables. They are really flexible in terms of what you can do with them.
Lol, you are such an idiot. You have multiple network paths to contend with with CDN. If the CDN still relies on the server (or vice versa), then it isn't going to be more reliable but less. Of course you aren't going to see the whole picture, you are just a hack who is more afraid of being wrong than of understanding. Have you had ANY formal training? Or are you just another brainless hype parrot?
"flux is there for managing how events generated by the user and events generated by backend services can keep a view which represents the application state." I have yet to get started with React, but what you said makes it very tempting to get building. I'm assuming that it is far less heavy on the browser's resources than other frameworks?
Yes, it will work with git tags but you don't get the benefits of persistence and semantic versioning. If you are OK with open-source, I would suggest using the npm registry so you can take full advantage of these features. 
Although I rarely see it covered in tutorials, directives can have their own controllers with their own isolated scope, and not only will making use of this help eliminate clutter from your route controllers, but your app becomes more modular, so it's easier to recycle your code. In this case, it sounds like you could do something like this and import a service to retrieve the data and pass it along to DataTables.
Couldn't resist http://www.reddit.com/r/programmingcirclejerk/comments/33twcw/javascript_will_herald_the_return_of_jesus/
Did you *have* to use DataTables or did you just *choose* to? Is there any special functionality of DataTables you need that would be particularly hard to implement with plain Angular? I'm asking because developers today are often so used to using plugins that they sometimes forget how easy Angular makes it to do something like DataTables. I use very few plugins on Angular projects since it will often take me much longer to try and hack it into Angular than just building exactly what I need from scratch instead. A good Angular dev could probably make a table with sortable columns, search, pagination and visible number of entries selection, in a couple of hours or less.
Unfortunately, @cghio is right, you can't reimplement correctly apply or bind in js. You can't even really bind a context. The bind method is able to set the meaning of 'this' in your function without altering the given context, which is a big thing. Any simulation of it implies setting a new property on your context, which will not work for sealed objects, or objects having a property of the same name you want to use configured as not writable. //here is the closer you can go to native way of binding context without call, bind or apply (for functions taking only one arg) function bindContext(fn, context){ return function(arg){ //storing reference to property content in case it exists //can already be a bad thing if the property comes from a custom getter (cf documentation about object properties in js) var orig = context.fn; context.fn = fn; //will fail if object is sealed or property not writable var result = context.fn(arg); if(orig !== undefined){ context.fn = orig; //restore the thing if it was existing. } else{ delete context.fn; //delete it if it never existed on the object, to preserve behaviors relating on the object not having the propperty } return result; }; } //a simple function relying on context and one arg var myAdd = function(num){ return this.num + num; }; //so now, this will work var context = {num:10}; var boundAdd = bindContext(myAdd, context); console.log(boundAdd(4)); //14 console.log(context); //Object {num:10} =&gt; okay, looks unmodified //but this will then fail context = Object.seal({num:10}); boundAdd = bindContext(myAdd, context); console.log(boundAdd(4)); //context.fn is not a function =&gt; object is sealed, the bindContext cannot add context.fn on it //however native one still works boundAdd = myAdd.bind(context); console.log(boundAdd(4));//14 Now, for the rest, what you're doing is not applying arguments to a function. The apply method of javascript offers several guarantees: - as for bind method, applied context is working without modifying context - function is only executed once, to prevent any side-effects it could have to be repeated - works with any function, taking any number of arguments: given array is always expanded and given to target function, one shot Your version calls the target function once per given argument, and relies on it to be especially tailored to work with it. And even worse, your target function doesn't work standalone anymore and wouldn't work with the normal apply either: it's entirely tied to your 'custom apply'. So, you're really far from an 'apply' implementation... This kind of thing would be a bit closer, based on the previous bindContext: function customApply(fn, context, args){ //storing reference to property content in case it exists //can already be a bad thing if the property comes from a custom getter (cf documentation about object properties in js) var orig = context.fn; context.fn = fn; //will fail if object is sealed or property not writable var result; var length = args.length; switch(length){ case 0: result = context.fn(); break; case 1: result = context.fn(args[0]); break; case 2: result = context.fn(args[0], args[1]); break; case 3: result = context.fn(args[0], args[1], args[2]); break; case 4: result = context.fn(args[0], args[1], args[2], args[3]); break; case 5: result = context.fn(args[0], args[2], args[3], args[4], args[5]); break; } if(orig !== undefined){ context.fn = orig; //restore the thing if it was existing. } else{ delete context.fn; //delete it if it never existed on the object, to preserve behaviors relating on the object not having the propperty } return result; } //a simple function sum function var myAdd = function(args){ var length = arguments.length; var result = 0; for(var i=0;i &lt; length;++i){ result += arguments[i]; } return this.num ? result + this.num : result; }; //so now, this will work console.log(myAdd(3,4,5)); //12, ok, this is a normal sum //and this too var context = {num:10}; console.log(customApply(myAdd, context, [4, 6])); //20 //and this will not be broken either: context.add = myAdd; console.log(context.add(4)) //14 //and you can still use the true apply console.log(myAdd.apply(context, [3, 1, 2, 4])); //20 But that's not a scalable solution, as you can't give it an infinite number of arguments. The only scalable one implies the infamous 'eval', which can cause a lot of trouble, especially if you minify your javascript or if you pass unsafe inputs. Its use is not recommended. It goes like this: function customApply(fn, context, args){ //storing reference to property content in case it exists //can already be a bad thing if the property comes from a custom getter (cf documentation about object properties in js) var orig = context.fn; context.fn = fn; //will fail if object is sealed or property not writable var result; var length = args.length; if(!length){ result = context.fn(); } else{ var stringArgs = []; for(var i=0;i&lt;length;++i){ stringArgs.push('args['+i.toFixed(0)+']'); } result = eval('context.fn('+stringArgs.join(',')+')'); } if(orig !== undefined){ context.fn = orig; //restore the thing if it was existing. } else{ delete context.fn; //delete it if it never existed on the object, to preserve behaviors relating on the object not having the propperty } return result; } //a simple sum function var myAdd = function(args){ var length = arguments.length; var result = 0; for(var i=0;i &lt; length;++i){ result += arguments[i]; } return this.num ? result + this.num : result; }; //so now, this will work console.log(myAdd(3,4,5)); //12, ok, this is a normal sum //and this too var context = {num:10}; console.log(customApply(myAdd, context, [4, 6])); //20 //and this will not be broken either: context.add = myAdd; console.log(context.add(4)) //14 //and you can still use the true apply console.log(myAdd.apply(context, [3, 1, 2, 4])); //20 And this is the closer you can get to a true 'apply' behavior, for as far as I know. To complete the picture: ok, in current javascript (ECMAScript5 version and lower) you can't transform an array into an argument list without apply, except with the horrible 'eval' workaround. Developers have been complaining about this for a long time. And that's why we finally got the 'spread' operator in upcoming ECMA6 version. :) //this will work in ECMAScript6 :D var myargs = [1, 2, 3]; function addsThreeNumbers(num1, num2, num3){ return num1 + num2 + num3; } console.log(addsThreeNumbers(...myargs)) //6 =&gt; the three dots convert the array into an argument list, which is damn awesome However, note that it won't completely replace the apply method, because you still won't be able to accurately simulate bind. I think I've covered all I could about the subject and hope I haven't been rude in my wording. It's great that you're trying to masterize javascript's intricacies, and attempting to reimplement primitives is definitely a good way to do so. Don't hesitate to ask if you have other questions. Happy coding!
You really should look into clojure/clojurescript. I know I'm biased but the 'one language on both the backend and frontend' is much stronger than in the case of e.g. nodejs. 
&gt; I agree that organizing nested views and models gets ugly. Can you elaborate? 
I have a computer science degree, but of course that wouldn't mean anything to a retarded troll like you. I'd be happy to accept if I'm wrong. I'm still waiting for you to provide even a single sentence that shows you know what the fuck you're taking about. Everyone here clearly thinks you're wrong and your failed attempts to be elitist and patronising are pathetic.
Why not use Node.js child_process directly? This is such a [thin wrapper](https://github.com/isRuslan/shellby/blob/master/index.js) over it I don't quite see the point. 
Hi /u/swellboy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/newjsjs, this post is blogspam and has been removed. If you notice at the end of the article, it says: &gt; Originally published at www.infoworld.com on April 9, 2015. This is what makes it blogspam; please post the original link if/when you encounter this again. For reference, the original article was [posted here 15 days ago](http://www.reddit.com/r/javascript/comments/321tar/javascript_will_lead_a_massive_shift_in/).
&gt; According to statistics I usually see Sure, it depends on what/where your target audience is. Some stats: http://gs.statcounter.com/#mobile_browser-ww-monthly-201504-201504-bar For me those 10..30% of devices/users with weird browsers (with varying javascript support because they are old, weak or implement some kind of "data saving" a.k.a proxy-ing mode) are very important simply because there are many (millions) of them worldwide. That's why google search works without javascript, because there are literally "fuck-tons" of these javascript-unfriendly browsers and excluding them translates to "fuck-tons" of lost revenue. &gt; Even in the third world country I was born and live in, people can afford a cheap Android phone with full support for javascript. Yeah, but sometimes they probably choose a cheap/older/used Nokia which comes with Opera Mini these days (that has a proxy mode).
Would have loved for you to go more into depth on the unidirectional flux flow with examples
That third option needs a way to happen automatically. Reference a file and compile and the template ends up in your derived minified code.
of course. The same goes for network security. You know how to improve it? Don't use any network connection.
And in many cases that _is_ the right answer. It always comes down to a cost/benefit analysis of what you're actually getting out of the tool versus what downsides it introduces. I personally find that javascript always falls clearly on the realm of huge downsides and nearly nonexistent benefit. But I recognize that I'm not likely to win a lot of friends with that sentiment in /r/javascript . (I came over from the other discussion of this piece in /r/programming .) 
Still think string matching looks like a pretty stupid idea, even though this gets rid of the switch statement from hell.
&gt; how many different blog posts are going to use the title "What the Flux?" Enough to give a person reflux, no doubt.
Can certainly resize events and move them. I was doing that just the other day for a thing at work.
Hmm, for someone who comes from javascript to php. I would think there's maybe 3 people in the entire world who would do something like that and they would be horribly misdirected in doing so.
Why use jQuery when it's completely unnecessary? Quick and dirty: (function() { var elements = document.getElementsByClassName("wrap"); for (var i = 0; i &lt; elements.length; i++) { elements.item(i).addEventListener("mousemove", move); } function move(e) { var x = (e.pageX * -1 / 2), y = (e.pageY * -1 / 2); e.target.style.backgroundPosition = x + 'px ' + y + 'px'; } }()); 
Can't wait for this shitty parallax fad to die. 
It can be tasteful. But yes, people overdo it, just like every trend or style.
Yum!
Probably because they can write it in 4 lines of code rather than 10+ at no extra expense... it's a codepen demo. I'm surprised they're even using actual html and css... it's much handier to use jade and stylus/sass. 
I love it.
Ah,so that's how they made past schedules...I guess I can't do it myself...=[ Thanks for answering.
If you're using a CMS, jQuery is probably loaded already so you might as well use the library to save some time &amp; bytes.
 document.querySelectorAll(".wrap").forEach(function (el) { el.addEventListener("mousemove", function (evt) { var x = (evt.pageX * -1 / 2), y = (evt.pageY * -1 / 2); el.style.backgroundPosition = x + 'px ' + y + 'px'; }); }); 
http://jsperf.com/javascript-quicksort-comparisons Crossfilter has a better implementation of the Dual Pivot Quicksort, which uses a sorting network. https://raw.githubusercontent.com/square/crossfilter/master/src/quicksort.js It was ported from Dart's own implementation: https://code.google.com/p/dart/source/browse/trunk/dart/corelib/src/implementation/dual_pivot_quicksort.dart?spec=svn1556&amp;r=1556 Jason Davies also wrote a Radix Sort, which is supposedly 16x faster than native but it requires typed arrays: https://github.com/jasondavies/radixsort.js/blob/master/radixsort.js 
I think it's fun and easy to roll your own these days! I wrote a bit of a tutorial on it on my site! Hopefully no one hates for linking to my own blog, haha: http://seandonmooy.com/Developing_and_deploying_static_sites_with_GulpJS_and_the_Cloud - that tutorial is slightly old but the code is all updated and available here: https://github.com/erulabs/erulabs.com Enjoy!
I'm not sue how much I want to use Angular 2.0 when it comes out, it's just looks too complicated. So the question is not if it's would be easy to to update but if I can stay with Angular 1
&gt; document.querySelectorAll(".wrap").forEach "forEach is not a function". QSA returns a pseudo array (a NodeList), not a real array. You have to write some crap like: [].forEach.call(document.querySelectorAll('.wrap'), function(el) { ... });
&gt; [Angular 2.x] just looks too complicated It does? It's actually somewhat simpler and it requires quite a bit less code. The changes really do make a lot of sense. But don't take my word for it. Check the two keynotes. &gt; the question is not if it's would be easy to to update You still might want to write it in that easier-to-upgrade style. There are no downsides to it, as far as I can tell. &gt; can [I] stay with Angular 1 For the next 5 years, sure. For the next 10 years? Eh... you might have to patch a thing or two. Maybe. But in general, it will just continue to work fine like it currently does. Just like all those jQuery 1.2.x sites still work fine (apart from the browser sniffing they might have done). It's highly unlikely that browsers will introduce changes which would break Angular 1. Browsers don't even introduce changes which would break Dojo even though doing that would be fine since it modified built-ins.
And in es6 (or es2015) Array.from(document.querySelectorAll('.wrap')) .forEach( el =&gt; el.addEventListener('mousemove', evt =&gt; { let x = evt.pageX * -1 / 2 , y = evt.pageY * -1 / 2 el.style.backgroundPosition = `${x}px ${y}px` })) And in LiveScript for el in document.query-selector-all \.wrap evt &lt;- el.add-event-listener \mousemove x = evt.pageX * -1 / 2 y = evt.pageY * -1 / 2 el.style.background-position = "#{x}px #{y}px" 
For one reason, addEventListener and getElementsByClassName are IE9+ My main site is still 4.45% IE8 
Firebase is a bit more than just a websocket connection. It's a database that handles security, user authentication and real-time, serverless communication with your app. At incredibly high speeds, without you ever having to worry about reliability or scaling. They also provide bindings to all major client-side frameworks to keep you as a developer happy. So all in all Firebase offers incredible ease of development and a peace of mind you could otherwise never achieve. And that comes, rightfully so, at a price. Also, the 2.5k connections you're describing are concurrent connections. Your app will need to be incredibly popular to achieve those numbers!
It's very interesting to see those 3D demos &amp; that they are working as well as they are. Hopefully that will actually trickle down to the rest of us mortals eventually. I still can't get 3D to work under Chrome &amp; Linux.
It's not 4 lines though is it, and be honest how many sites/cms do you work on that aren't already loading jQuery?
How fortuitous! We're looking at using Knockout as part of various projects at Rightmove, and this was definitely a concern that we hadn't shook off. The timing of this couldn't be better. I'll share it immediately and try it out tomorrow.
2 things: first parallax is horrible for accessibility so make sure you have a way to turn it off, and second you don't need JavaScript. You can do it entirely in CSS.
http://microjs.com?
There are two ways to look at this: 1. Angular team was so bad at design that they had to make a lot of incompatible changes to make Angular 2 competitive. If so why use it? 2. Angular team doesn't give a shit about backward compatibility and will always be eager to move on to the next new fangled thing. If so, what happens with Angular 3?
There's a huge expense actually. jQuery is an order (or two) of magnitude slower than the native JS for many operations.
Some features, like Promises, can be shimmed. Others, like arrow functions and rest params, require syntactical changes to the language yourself. In other words ES6 can be seen as invalid JS in most browsers. A transpiler like Babel converts ES6 into valid ES5 so that browsers don't freak out. Then a few features like Promises are shimmed.
Shim are never gonna be the complete answer, IE8 is just too old and buggy, the only thing you can do is use the shims and test, test, hack, test, remove features from IE, test...stab eyeballs out and demand to know why your client requires IE8 compatibility when Microsoft has dropped support, test, test...(i think you get the idea) 
Except IE8 is an ES3 browser.
Absolutely not. Shim are hack fixes that can only reach far back to so many generations of browsers. 
If it's a specific API, you can check on [caniuse](http://caniuse.com). Also see [this](https://balanagaraj.wordpress.com/2008/05/07/javascript-differences-in-mozilla-firefox-and-internet-explorer/), [this](https://msdn.microsoft.com/en-us/library/ie/dn467851%28v=vs.85%29.aspx), [this](https://kangax.github.io/compat-table/es5/) (click "show obsolete browsers")
To know what it's not, you must first learn what it is, grasshopper. http://en.wikipedia.org/wiki/Parallax
No, its the end of two way bindings. There are too many developers transitioning to JS that are deeply entrenched in the MVC architectures of web frameworks. While MVC doesn't naturally adhere to uni directional data flow, it can most certainly be adapted for it. 
Thanks for the tips!
Also, React is defined as a library that is "intended to help developers build large applications that use data that changes over time." So, if I'm building a page that handles new data at a constant rate and therein requires the DOM to be manipulated, React would suffice to this. 
Thanks for those links. They're good resources for sure. But I'd still waste more time checking every time I do DOM manipulation. I don't really want to have to memorise all of that. So I'll use jQuery, Modernizr and any other shims/shivs, and if there are errors in browser testing then I'll look them up and fix them. 
It's a piece of code that runs on the server (an ASP.net server) for rendering a div tag's id This isn't javascript related
This is most likely data being passed to your HTML page by the server. Hard to tell what else is happening without seeing the source code.
It is server side code. Looks like an asp page. It is evaluating to a clientid of a server control, probably a hidden input field
ah, that makes sense. I have 0 experience with ASP.net so it didn't occur to me :)
What can you do to extend these objects that can't be accomplished by overriding methos in window.Array.prototype?
&gt; why your client requires IE8 compatibility when Microsoft has dropped support IE8 is the latest version supported on Windows XP (17% of the market). I wish MS would just bite the bullet and release just one more (IE) update for XP. That would finally bury the need for IE8. Edit: Downvote? I hate IE8 as much as the next man, but it's not my fault MS keeps it on 17% of computers. Edit #2: If you don't believe me, [read the numbers and weep](https://www.netmarketshare.com/browser-market-share.aspx?qprid=2&amp;qpcustomd=0)
why would another update do anything but extend the life of xp and ie8? without updates and support, xp users are pressured to update to current o/s and browsers.
&gt; fixed backgrounds He was trying to be a 'know it all' and it back fired.
But how many of these 17% of computers are actually running Internet Explorer 8 instead of Chrome or Firefox? Apparently IE8 is now globally used by &lt; 5% of users. Depending on what you're doing that's still a lot of users, but nowhere near 17%. Also you should check your own browser stats. For example, @dayjob we're IE9+ for sites and IE10+ for apps. Why? Because we're in Germany and have a tech audience. IE9 will get the axe soon, and IE10 will be dropped a couple of weeks after IE12 is released.
Sorry, champ, but he's right. You're taking the false position that because the background mimics the antiposition of the mouse, parallax has been achieved. That would be correct if the mouse was the observer, but it's not. Software implementations of things called parallax don't refer to the thing that you linked. You're accidentally engaging in amphiboly. What they refer to is the parallax effect and illusion, which are things about our depth perception mechanisms. Namely, you need two layers moving in a related but scaled way, to cause the impression of depth. Yes, there are two things with that name. Yes, you're implementing a misunderstanding of something with that name. Yes, everyone using that name means the other thing. Yes, they are correct when they tell you that you're botching the common expectation of this phrase, just in the same way that putting out a multitouch library and it turns out to be a music library offering three layers of what jazz drummers call touch timing would be wrong.
"at no extra expense" because jQuery is free, both in existence and in usage.
Personally, I think your time would be better suited picking a library that needs help and contribute. PR's welcome, expect code reviews.
Cool. So, set your laptop down. Look at it from the left. Now look at it from the right. Now from above. See how that isn't the parallax we're talking about, ever, on screens? (Pro tip: your mouse is not an observer.) Instead, they refer to "the parallax illusion," a function of depth perception, the effect commonly leveraged by animation, by which multiple layers moving at scaled rates give the impression of visual depth.
extract event handler into a separate function, call it in both mousemove and a new line for document.addEventListener("touchmove",...);
Creator of easyRouter here, please check it at https://github.com/rogerpadilla/easy-router. easyRouter is an unobtrusive, forward-thinking and ultra-lightweight client-side router library.
If your already using Node and Express, you might as well look at angular. Those 3 technologies are part of the MEAN(Mongo,Express,Angular,NodeJS) Stack. It is a very popular stack and has plenty of resources online.
[like this](http://keithclark.co.uk/articles/pure-css-parallax-websites/)
[About 17% of visitors use IE8](https://www.netmarketshare.com/browser-market-share.aspx?qprid=2&amp;qpcustomd=0). If you think it's less than 5%, I'd love to see the reference.
I've been following this series for some time now. I like the way that James brings modern rigorous development to JavaScript. I am not a web developer, but I find his approach valuable even in other contexts.
Depends on how much legacy browser support Babel has
doing a project with file upload and its a pita -- ill check it out and write a bit
This is the correct answer. You want to use a transpiler not a shim. Set up a build system so this happens automatically.
Use a large array. Normalize your individual words ( lemmatization ) and then use the array indicies as your inputs. 
First of all, Windows 7 came out five years ago. I don't count Vista as a viable choice -- plenty of people bought new computers with XP, rather than Vista, so the newest XP computers are five years old, and possibly four years old for the holdouts that didn't trust Win/7. Second, you can "should've" all you want, but at the end of the day you have to deal with reality.
[StatCounter](http://gs.statcounter.com/#all-browser_version_partially_combined-ww-monthly-201503-201503-bar) has it at slightly above 2% (with mobile) or slightly above 3% (without mobile) and [Wikimedia](http://stats.wikimedia.org/archive/squid_reports/2015-03/SquidReportClients.htm) at less than 2%. In the end this only matters if you want to write libraries you want to see widely adopted or have a website with a truly global audience, otherwise check your own stats for a breakdown of the browsers used.
Hmm. It looks like the stat I linked to is based on Google United States. I don't know how StatCounter gets their stats, it's not clear. Wiki's breakdown is interesting, but I would bet they have a higher income / higher education demographic, and it's also possible they have bots skewing the results, since Wiki is scraped quite often. As you say, the last word is your own web site, but I think Google U.S. is probably pretty representative of overall traffic, at least in the U.S.
Check out AngularJS or AureliaJS.
[Please, please, please, stop using "http", if you really want to include absolute URLs, start it with the "//" and let the browser figure it out](https://i.imgur.com/ABnO0Co.png) edit: Or just use "https" like the article /u/MrBester linked says. 
They ship polyfills for some ES5 features missing in certain older versions of IE. And while not yet commonly done, you can enable/disable all of Babel's transforms individually. So you could disable specific 6+-to-5 transforms to create a "modern" build to serve browsers that support the corresponding ES6+ features natively. So there's a little more to Babel's browser support story than just ES5.
Part of crossing each hurdle as it comes is using the resources mentioned. I understand the simplicity of using a tool like jQuery and if you're supporting older browsers (IE8 and below), then I understand using jQuery 1.11, but if you've moved on to jQuery 2.x then that's a different story. I feel many people use 2.x as a crutch because it's what they know, but without the backward compatibility you're really just hurting yourself in my opinion. It's better to learn the spec, or even dig into the jQuery source and see how it churns under the hood. You'll find a lot of your jQuery shortcuts really are simple native JavaScript that should be second nature to any modern dev at this point. 
ReactJS + Flux are also great. But Angular will definitely suit your needs.
Looks like a possible [Underscore.js](http://underscorejs.org/#template) template. 
You'll need a transpiler like babel to use ES6 features today for older browsers.
If you really want to use absolute URLs then make them available over HTTPS as the agnostic protocol is an anti-pattern. See update to http://www.paulirish.com/2010/the-protocol-relative-url/
XP is easy to pirate, so a lot of people in Asian markets still use it. I think that is where the 17% primarily come from. I can't confirm because I'm not subscribing to a website to get data that should be free. 
Actually I wasn't. I assumed you posted a scrolling parallax, which is what almost everyone refers to when they use that term in web design. Most people actually use JS to accomplish them as well. I was on mobile, so I didn't get a chance to look at your example (which as you now know isn't really parallax). Clearly you can't accomplish that using CSS only, but the scrolling variety you can. My first point still holds true. They are horrible for people who have cognitive disabilities, and even those who don't may find them hard to deal with. You need a way to turn them off. 
Understood :)
Good. =) Then I'll write it into my next tutorial.
Doesn't load right under HTTPS. That said, this code...I think a single glance tells the whole story. https://github.com/foam-framework/foam/blob/master/apps/todo/Todo.js I'd say it was a joke but it's just too convoluted to be one. I see everything I hate in programming on a single page.
Check if it is 17% of your market though.
https://github.com/kgrgreer He's playing the long con.
I don't think you're using the word "feedback" correctly; _feedback_ is a review that someone gives you. If I tell you that your app is awesome, that's feedback. If I ask you for feedback on my app, then I'm requesting that you review it and provide some [hopefully constructive] criticism. Also, there is no plural, so saying "feedbacks" is incorrect. You'd just call it "feedback", whether it's from one person or many.
It would appear that it's in use at Google already - Chrome App Builder and a calculator app on Chrome OS.
The homepage doesn't tell me what this is and the about page tells me about the same. Nested nested lists don't appeal to me as a reader, nor do large walls of text, and I have no idea what I just read. Show me some code on the home page so I can see why I'd want to bother spending time reading it. I can't place a finger as to why I find the syntax so repulsive. I feel like the architecture wasn't really thought through and you bolted on as you went, and ended up with this mess: { model_: 'ArrayProperty', name: 'history', view: 'foam.ui.DAOListView', factory: function() { return [].sink; } }, { model_: 'StringProperty', name: 'row1', view: 'foam.ui.animated.Label' } My hope is that this is a hobby project and won't be used in a production system. I'd feel awful for the engineer that has to take over the code when you leave the project. You'd be leaving them with some obscure system they'd have to learn just to get a basic UI component added. Because the ramp-up time would be long, and future engineers won't know the system, they'll inevitability rewrite it, wasting their time and the companies time instead of cranking out features. 
It's real and was revealed today at EmpireJS.
How does any of this relate to his question? Did you look at what his code does? It seems to contradict what you're saying. In fact, rhino is still being echoed even though clearly the a.something has been changed.
I'm not sure why it links to PreloadJS, but for me the best feature is http://www.createjs.com/EaselJS
I'm asking on behalf of myself and probably others, can you please write up a simple tutorial new post on this, I think it would benefit the community as a whole. Hell, even a grunt/gulp/browserify script that does this automatically would be beneficial to a ton of people. Legacy to modern conditional shim insert. Please and thank you. I'd be happy to work on it collaboratively.
This explanation is not really wrong, but it is problematic. First of all, strict mode is mentioned as an exception. It's better to think of strict mode as the norm and non-strict-mode behaviour as the exception: if `this` is `null` or `undefined`, outside of strict mode, the global object will be used instead. This is also true if you explicitly pass either of those values to `call`, `apply` or `bind`. Secondly, it's best to think of function invocations as syntactic sugar for `.call`: foo(1, 2); // is equivalent to foo.call(undefined, 1, 2); and my.foo(1, 2); // is equivalent to my.foo.call(my, 1, 2); This also makes it more obvious why `foo()` and `my.foo()` have a different `this`. The article also handwaves when it comes to `new`. The `new` keyword does two things: 1. Calls `Object.create(constructor.prototype)` 2. Invokes the `constructor` with the result from above as its `this` The `.bind` method is a little bit different, too. If invoked as a constructor, it discards the object created via `new' (see above) and substitutes the result of invoking `Object.create(innerFunction.prototype)` (where `innerFunction` is the function it is wrapping). The examples in the article also seem to assume they are running on the top level of the browser scope. If they were executed in a different environment (e.g. Node.js) or inside a function, they wouldn't work (because only at the top level of the browser scope does `var x = 5` mean the same thing as `window.x = 5`). So all in all, this is what you need to know about `this`: * `this`can not be assigned like other variables, `this = 5` is a syntax error * `foo(x)` is syntactic sugar for `foo.call(undefined, x)` * `my.foo(x)` is syntatic sugar for `my.foo.call(my, x)` * `still.my.foo(x)` is syntatic sugar for `still.my.foo.call(still.my, x)` * `foo.apply(a, b)` is equivalent to `foo.call(a, ...b)` (in ES6) * `new foo(x)` is equivalent to `foo.call(Object.create(foo.prototype), x)` * `var bound = foo.bind(a)` is a function with the following behaviours: * if invoked as `bound(x)` returns the result of `foo.call(a, x)` * if invoked as `new bound(x)` returns the result of `foo.call(Object.create(foo.prototype), x)` * in the global context `var x = 5` is equivalent to `global.x = 5` (in the browser, the global context is exposed as `window` instead of `global`) * outside strict mode, `this` if `undefined` or set to `null` will instead refer to the global context * outside strict mode, undeclared variables are also treated as properties of the global context
Very cool! Nice and simple.
I know you're far, far from the only person who does this, but since you're asking for feedback: what's with the inscrutable names? The average person learns nothing about your project from its name, except that it's written in JavaScript. It makes discovery and maintenance both more difficult. If you want to keep the word, then why not "Hemulen Forms" or something similar?
templates in js comments? smdh. no.
Use this all the time. Doesn't lock you into a framework and has some awesome functionality.
I saw the comments, was led to believe it was a joke, and totally believed the hideousness of the page was intentional.
I was passed over on a tech screen at HomeAway because I didn't use Moustache templates (which they included in the test packet) for 1 line of HTML outputted by JS. True story. 
Our software is used by banks worldwide... We provide financial software that pretty much every major bank uses. We still took a hard stance that we wouldn't be supporting those browsers. Honestly, I've heard little issues from it. I know there's the occasional company that claims that we must support the older ones, but I'm not sure how they handle it from a sales perspective. Our company-wide front end framework is based on Angular now, and there's 4000 devs around the world who will be associated with software that has an Angular based UI. IE9+, obviously. 
Any thoughts / tips on making D3 pie charts that are 100% wide and grow shrink proportionally based on container element width? I guess this question extends to SVG in general. Would love to hear how to make SVG flexible as well.
I think that some of the code formatting could be improved. I'm sure everyone does it a bit differently, but I like grouping enter/append and having separate lines for all attrs/styles. So instead of: g.selectAll('path.slice').data(pie).enter() .append('path').classed('slice', true).attr('d', arc) .attr('fill', function(d){ return $c.rgb2hex(255 - 40 * d.value, 100, 40 * d.value); }); I would prefer: g.selectAll('path.slice') .data(pie) .enter().append('path') .classed('slice', true) .attr('d', arc) .attr('fill', function(d){ return $c.rgb2hex(255 - 40 * d.value, 100, 40 * d.value); }); I believe that that is easier to quickly parse that, which is especially useful when providing other people example code. As a side note, the color of the links on your page is so close to the color of the rest of the font that it is very easy to not realize that they are links. I'm not sure if making the links bold, using a more contrasting color, or something else is best, but I just though that you might want to consider changing their appearance a bit.
For fluid scaling, the `svg` node needs the `viewBox` and `preserveAspectRatio` attributes set. Then all child nodes use some percentage of the viewBox width/height pixel values. http://stackoverflow.com/a/9539361/1243162 But because there are some d3 features (like d3.scale) that interpolate between scaling of pixels (range) or data (domain), a debounce function to detect changes in height/width is sufficient, where in you just redraw the chart with d3. The former is likely more efficient, but a bit more complicated.
Hover over that little "i" next to the printout in the console for more information
I've used this on a couple of projects so far and it's pretty amazing. Trying to upgrade to v0.7.3 mysteriously broke things, though. When I have the billable leisure time (stop laughing) I'll try it again. 
Now I can put the add and remove class in the &lt;script&gt; of my file with the text box? Do I need an if test in there? I have worked with JS very little. All the .this and whatnot confuses me.
https://www.reddit.com/r/javascript/comments/33y5uc/ Was posted earlier today.
We are providing Java Web Development Services which includes Java Mobile Application Development, Java Enterprise Application Development, Java Internet Application Development etc.
This is /r/javascript, which has nothing to do with Java.
Ah, missed that post, thanks!
good spot, thanks :) 
[**@wycats**](https://twitter.com/wycats/) &gt; [2015-04-26 21:22 UTC](https://twitter.com/wycats/status/592438740980760576) &gt; Can someone at @EmpireJS confirm to me that FOAM is a real announced framework and not a joke? ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Looks like it, but I'm still hoping that it's a really elaborate joke...
Yeah I'm trying to have a really open mind about this, but it's hard to read most of this stuff because of all the blood in my eyes.
From the about page: &gt; "FOAM is reactive, cross-browser andfast. But dirty checking scales badly and Object.observe isn’t cross-browser!" What about Angular?
Code inside templates inside comments!
Thanks god, I'm not only one hating. I thoughts I was bit "out-dated"
Just bought https://churn.io, thanks.
I agree that you should look into this. ui-grid (formerly ng-grid, I believe) worked very well. I have used DataTables.net before, and to be honest, I preferred ui-grid. 
I don't want to live on this planet anymore.
It must be Monday, time for a new JS framework.
The about page reads like Timecube.
For minimal JS usage, you could do something like [this](http://cssdeck.com/labs/kzyxtedn): /* HTML: */ &lt;input type="text" class="promobox" onkeyup="this.setAttribute('value', this.value);" /&gt; /* CSS: */ .promobox { color: #800; } .promobox[value="student"] { color: #080; } Thing is, people can easily find out all available promo codes by viewing the source. If this is a problem, you'll have to check the code server-side.
Yup, it's from Google. Was announced at EmpireJS a couple of hours ago.
What the motherfuck?
If it can autogenerate a hipster logo, an O'Reilly book and an EmpireJS talk then I'm sold.
Excellent, I will gladly contribute to this project if you set up a repo.
You dodged a bullet. Wouldn't sweat it.
Yeah. Definitely the context and scopes are hard to get used to. Have you tried using the [define](http://jsblocks.com/api/blocks-queries-define) data-query which could help a lot. Also you could join the discussion for the case [here](https://github.com/astoilkov/jsblocks/issues/1)
Yeah. Definitely. The caching of functions is already implemented. Once a function is created it is cached it becomes insanely fast. For the closures you are correct. It is not an easy problem to solve but it will be really interesting and challenging...and I love challenges!
You can start with this one: http://tiffzhang.com/startup Okay, it needs a little tweaking, but it looks like a good start.
Yes, I tried `define()` as well. It solves the problem partly, but if you're trying to access a context variable multiple scopes downwards, then you have to keep propagating the `define()` I suppose?
Why do you say that? Seem like very solid credentials. Waterloo teams won the ACM world programming contest [twice](http://en.wikipedia.org/wiki/ACM_International_Collegiate_Programming_Contest). Only 8 institutions in the world have achieved that so far.
it's more like knockout.js, if one must compare
I think it's quite similar to Lazy.js: http://danieltao.com/lazy.js/ (though it still a WIP!)
Templates inside comments. How does that even work? How can JS even read that information? Do you have to run a pre-processor or something?
Could you please mention a few deobfuscators. Can they deobfuscate: var _0xa3c9=["\x64\x69\x66\x66","\x70\x72\x6F\x74\x6F\x74\x79\x70\x65", "\x69\x6E\x64\x65\x78\x4F\x66","\x66\x69\x6C\x74\x65\x72"] Array[_0xa3c9[1]][_0xa3c9[0]]=function (_0x4068x1) { return this[_0xa3c9[3]](function (_0x4068x2) { return _0x4068x1[_0xa3c9[2]](_0x4068x2)===-1; } ); } ; To something readable/understandable?
yes, .toString() on a function returns the comment too. edit: here's a demo: http://jsfiddle.net/ck203vqr/1/
Use [getNodesByType](https://github.com/prettydiff/getNodesByType) to get all text nodes from the body element. Loop through the nodes using replace on their nodeValue properties. var body = document.getElementsByTagName("body")[0], replaceText = function (node) { var text = node.getNodesByType(3), len = text.length, a = 0; for (a = 0; a &lt; len; a += 1) { text[a].nodeValue = text[a].nodeValue.replace(/a/g, "b"); } }; replaceText(body); You can try this out on any page by copying the `getNodesByType` code and this example code into your browser console and then pressing enter.
Of course it echoes "rhino". That's exactly what I explained. If you pass "this.something", you don't pass "the attribute 'something' of 'this'", you pass "the current value of the expression 'this.something'". If the value is different in the future, that doesn't matter as the expression has already been evaluated.
Can confirm, it used to have a messy codebase but not it is all cleaned up and looking good. Great features, easy to learn, easy to use, and familiar mustache/handlebars templates (not jsx )
I would really love for it to have some Angular-like directives like "ng-repeat" and others so that is increases productivity and you can type less.
Thanks !
I'd just like to point out that your indentation makes your code a pain in the dick to read. I've seen a lot of indentation styles, and this one is new.
This is the indentation style recommended by JSLint/JSHint. What would you prefer instead?
Use `document.body` instead of `document.getElementsByTagName('body')[0]`
I zoned out till I saw the cool dragon animations.
Look. Just because people initially hated React that doesn't mean people hating your project is an indicator you're on the right track. Also, at what point did "let's write our own class implementation in 2015" sound like a good idea?
Yeah, I get that functions are for reusable code. Holy fuck, I haven't heard anyone say that particular sentence in 6 years. But if someone asks "how do I &lt;x&gt;?" you give them the minimal solution, because any more and you run the risk of obfuscating the solution with boilerplate. As to `var`s... that's a huge argument I don't feel like having. Suffice to say I disagree with you, and not because of vanity.
What's an angular?
While I'm not a doctor and haven't read the source code of the actual framework, my initial suspicion is that this framework is anything except fast.
plz Google or Google engineers [whatever] ... How does this bring something new / fresh to JS community ? I mean, React was kinda badass about how he was engineered and all the flux, virtual dom diff and stuff. But there are plenty tiny JS frameworks who does the same thing than this new framework actually. Teach people how to use frameworks in the way they like instead of creating framework who meet some weird programmer habit.
As long as you don't care about IE8 you can use [node iterators](https://developer.mozilla.org/en-US/docs/Web/API/Document/createNodeIterator) to loop through the text nodes. var iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT, null); var n; while (n = iterator.nextNode()) n.data = n.data.replace('a', 'b');
You should start figuring out that isNaN is defined to work only on Primitives, so isNaN(Number('5a')) works perfectly fine. Why is it this way? Because Number.prototype leads not to Object whereas Function.prototype leads to Object.prototype. So calling the Number function with new constructor (like in your examples) will have this behaviour: var x = new Number('2a'); Object.getPrototypeOf(x); // Number Object.getPrototypeOf(x.__proto__); // Object Object.getPrototypeOf(x.__proto__.__proto__); // null var y = 2; Object.getPrototypeOf(y); // Uncaught TypeError: Object.getPrototypeOf called on non-object
BS. Nowhere on Angular's site does it say "from Google" either. You're making things up.
At the bottom of https://angularjs.org/ it says "Super-powered by Google ©2010-2015".
@blocomputation The purpose of this project was not the features of the app (I agree with you - searching / displaying some Github profiles is not that impressive). It's the implementation of React and moreover with server-side rendering (in an isomorphic way). @kenman Maybe I used "Feedbacks" the wrong way (after all, english is not my first language) - but I hope most of the people who'll read the article will understand (most of them are like me, english is not their first language, they won't care for such a little mistake) - though it felt right to use "Feedbacks" here, since I'm not only presenting a project but mostly sharing an experience (things that could help other when they'll do the same kind of thing) - you could talk about feedbacks ...
EDIT : its only active on safari like that .. chrome and firefox are okay Cant, its closed project, i cant show it and u need account and stuff , so its complicated ... 
Thanks for catching that typo! I think there are 2 kinds of magic and they are different: 1. implementation detail magic (as in React) 2. magic in what's happening on the level we're using it (Angular) And I do agree, not all magic is bad :) I consider the magic bad magic when it takes away control from me.
I mean I understand every basic features of javascript and how to use them (oop,callbacks, closures...). I used jQuery to make some animations in websites and I made a simple game (a flappy bird clone) with Phaser.io. I didn't feel I needed a framework to do these things because they were rather small and easy. I never built a big real/complete application. What kind of application can I build with javascript only , can you give some examples ? Thanks
I think too much is made of the breaking changes from Angular 1 to 2, especially with 2 a very rough alpha. Software development has breaking changes, learning to manage them is vital for being a longterm developer. That being said, there are reasons to use our not to use a framework but future obsolescence isn't one of them. Learn promises, grunt/gulp, your editor, bower, other tools. The bigger question is what will you do with this knowledge? 
It's 10 lines of code, and very direct primitive imperative code at that. When reading 10 simple lines is the straw that breaks that camel's back then perhaps programming is not a person's *cup of tea*.
A neural network takes inputs as numbers and returns outputs as numbers . in your case you have words / sentences. So now the question is how do you convert this word to a number. The simplest possible way is to just use a map. A map from numbers to words . so for example in your map you might have 1000 -&gt; elephant and 1001 as 'from'. So when the nn returns another number as output you can use the same map to decode it. It's just a dead simple encoding decoding mechanism.
"Powered by" is not the same as "from Google". Powered by refers to what serves the site. **Nowhere** that I could find on your linked site does it say this framework is created by or is directly from Google. And let's not deflect, shall we? While Angular has dozens working on it, you're claiming FOAM is "from Google" based on the fact that the **one guy** who works on it works at Google.
Let's not deflect, OK?
Well, you can build pretty much anything if you include server-side JavaScript (Node.js). If you're planning to get a job, learn about forms, databases and (REST) APIs. It doesn't sound particularly interesting or exiting but those things are the foundation of most "modern" web applications. You could for example build a blog application with jQuery for UI and Ajax and [Express](http://expressjs.com/) REST API with MySQL/PostgreSQL/MongoDB database. This will teach you the basics and then try rewriting it with some framework.
Simply brilliant ! Will try it more intensively. If it really works as accurately as advertised, I'm impressed. Although it many not have application in today's simplistic and minimalist web sites, I certainly have worked on business applications where users simply just wanted to see 1000s of rows of data in a table.
Thanks for taking the time to write about your experience - interesting to see a working example.
Great! Would love to know what you think.
Definitely. I think it's much simpler in practice than it seems in the documentation. Demo is coming soon.
The first agi will actually be in JavaScript
I simply don't get why such functionality is crippled with a jQuery dependency. Don't get me wrong, **awesome work there**, but really, it could just be a string transformer and that'd make it easy to integrate to any kind of project (even with react-based ones with a little hack like `{_html: embed.parse(content) }`).
Because we need another one
Oh, do I was vastly over-thinking it. Thanks for the help!
Maybe you were thinking of this presentation? https://docs.google.com/presentation/d/1KQkRJOiEBDktgFSa3qlehLFwtogssKbnaHBrZ26mWtk/pub#slide=id.g38d220eec_01236
RactiveJS uses Mustaches to achieve the same results like ng-* directives in AngularJS. http://docs.ractivejs.org/latest/mustaches#extensions Regards, Harris
The way of presenting the example at the top is brilliant - really sells the idea.
I thought Tuesday was for new minimal CSS like syntaxes that compile to CSS?
Oh ho ho have I got the blog post for you. BOOM: http://blog.ractivejs.org/posts/whats-the-difference-between-react-and-ractive/ (short answer, yeah, kinda. React is cool too!)
In most corporate environments unless stated since the employee is under that company, the company generally owns it. Not saying curtains don't have developer rights like California. Most businesses say anything outside of work is theirs to keep.
Because javascript is a language for making frameworks which happens to have been adopted by web browsers.
You can read about common terms here (other sources may differ a bit... but I think Mozilla has it right): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript &gt; Class: Defines the object's characteristics. A class is a template definition of an object's properties and methods. &gt; Object: An instance of a class.
ah thanks, didn't know that
This is a good question and one I think a lot of people will have. I've written a short blog post explaining the name and will link to it in the docs when I release. Hemulens are characters from the Moomin series of comics and books by Tove Jansson. As a group, Hemulens tend to be humorless and abrasive. They're overly-attached to order and rules, and are notorious for being insensitive on those accounts. When I started writing Hemulen.js, I was working on a large project and was grumpy about client-side plugins that have side effects on application architecture, page styles, document structure, etc. Plugins of this type often attempt to do too much. In the case of drag-and-drop plugins, doing too much is the generation of a drag-and-drop UI and other features which are not core to the drag-and-drop file upload problem. I was trying to get work done and the popular drag-and-drop plugin I was using often made as much work for me as it saved time. Any plugin that doesn't save a developer time is suspect but this plugin was especially frustrating because it made more work of a worse type - managing side effects rather than writing good code. This made me grumpy and I often grumbled to my coworker (much like a Hemulen) that the state of affairs could be much improved. So I named the plugin Hemulen.js as a way of poking fun at my grumpiness.
Looking at the source code, there is extensive use of jQuery throughout — including various Ajax calls in order to retrieve details on videos. I can see how the author might want to avoid coding the Ajax calls themselves. The alternatives would be to write the Ajax calls by hand (tedious and prone to error) or require users to include a JS library *other than* jQuery in order for it to run. And once you're requiring another JS library, it might as well be jQuery, considering its widespread adoption. The code is open source… consider making a react fork?
Very nice. Seems to be a small bug in Safari Mac: When scrolling, sometimes the area is losing scroll focus and the whole page scrolls down, when I just wanted the table to scroll internally. Maybe the component needs additional internal buffer scroll height, to ensure the scroll intentional it never breaks out.
Thanks someone in the conmments on my blog pointed out the same thing about object and I made a correction. I was thinking about the class keyword which you can still use as an object property name, just not as a variable or function name. 
/u/andersevenrud has the all good stuff in the link posted (definitely recommended reading), but if you want the down and dirty it goes something like this: Classes are blueprints for making objects. &lt;object&gt; = new &lt;Class&gt;() *Technically* JS doesn't have classes, but they can be emulated through functions/prototypes and often people will use the term class when referring to functions they've created that serves that purpose. Recent updates to the JS language include a `class` keyword that can be used to define "classes", but it still refers to the same approach of using functions. It just hides it under a keyword that makes it clear that you want a certain definition to be used as a class and not something else. I won't hate on you for saying you have "classes" in JS. With others, you might catch some twitching in their eye.
Thanks for the comment, I'll deal with it as soon as I find a Mac :D Anyway pull requests are welcomed.
That works in two ways, good one!
There are others but SPARQL is pretty much the gold standard. I'm working with a NoSQL database called MarkLogic and they have implemented the W3c spec for SPARQL. I think it works well for most cases, my only gripe being that a different approach may be called for when dealing with billions of triples across many servers.
To be more explicit I would say that in most cases you can write faster code and substantially smaller code by avoiding OOP concepts altogether in this language.
&gt; Key features of Meteor &gt; &gt; You can write applications in pure JavaScript, or you can use syntax suggar like CoffeeScript or LiveScript. Wow sounds awesome
Lol, good one!
As long as it gets people away from PHP, I don't care about the level of bullshit hype it's propagating.
This is 100% correct for Google. I have a post above that talks a but about the process, though if there is a Google Engineer in the thread that can shine more light on the subject that would be great. I only have third party experience from working with some Googlers on projects.
I don't mean to be rude or anything but... Again? [It was less than a week ago...](http://www.reddit.com/r/javascript/comments/33cx5q/common_misconceptions_about_inheritance_in/)
That's pretty damn slick. Nice work!
Yeah, learned that when I tried to use Volley.
That still doesn't explain anything. Can you use this EXACT example please. Maybe in your head you are explaining this perfectly and to people that already know precisely what you're talking about this solidifies that knowledge but to people just starting it seems like you're talking about unrelated things. If you choose to explain further, can you use the exact example op did? Thanks
I feel if you really want JavaScript to look more like java.. just use java instead. Right tool for the right job.
SlickGrid
Try and build some small apps just using Javascript then. Maybe jQuery for simple AJAX calls or grabbing stuff from the DOM more easily. Understanding what stuff does and understanding how to put it together is a lot different. Personally I wouldn't get into a framework until you've built something in vanilla js. That said I've been really enjoying my time with Meteor.js so far. 
no that's Wednesday. Thursday is for new UI kits. friday is for giving up and going to a vanilla.js implementation.
That's a neat backstory and a clever name, but my criticism wasn't that it's not clever, but that it doesn't communicate that "this library does drag-and-drop uploads".
Looks like a really useful tool! Here are two things I found that should probably be fixed. Scrolling on a mac with the touchpad will break the scroll if you scroll quickly. By breaking it I mean that the browser starts scrolling the page instead of the div. This is in Chrome 42. EDIT: This is both with the div and the list example. Clicking "process step 1" on top also freezes the browser. (chrome42, osx).
&gt; Easy to get started When I tried Angular, I found it tough to get started. First thing you need to do in any project is include your code. Angular hits you with a custom module system that's not AMD or CommonJS, so you've got to learn that first. Next up it hits you with this WTF: Providers, Factories, and Services. After you maybe-kinda-sorta figure that out then you've got $scope up next, which is pretty confusing. I guess it's just difficult to reason about the individual parts of Angular without understanding the whole system, where as in Flux for example, understanding the wiring might be tricky, but each individual piece is simple and requires no knowledge of the rest of the app to work on.
I see it more as a description of how to write code that can be unit tested. I actually do not write a lot of unit tests (for shame!) but I still write code largely in the manner you outlined here, particularly the passage on null checking/defensive coding/real world coding. I passed that on to my team.
And, unfortunately, forever buried by the bug in reddit's hotness algorithm.
Preso.
All you have to do is take a cursory glance at some examples: https://github.com/foam-framework/foam/blob/master/apps/todo/Todo.js - Magic strings everywhere - HTML, CSS, AND JS in comments (...) - Enterprise-y namespaces, inheritance, etc - Global variables everywhere - Tons of framework specific syntax When compared to recently released libraries/frameworks, it just seems like a step backward in every way. Also looks like a maintenance and refactoring nightmare. CLASS({ name: 'Todo', properties: [ 'id', { name: 'completed', model_: 'BooleanProperty' }, { name: 'text', preSet: function (_, text) { return text.trim(); } } ], templates: [ function toDetailHTML() {/* &lt;li id="%%id"&gt; &lt;div class="view"&gt; $$completed{className: 'toggle'} $$text{mode: 'read-only', tagName: 'label'} &lt;button class="destroy" id="&lt;%= this.on('click', function () { this.parent.dao.remove(this.data); }) %&gt;"&gt;&lt;/button&gt; &lt;/div&gt; $$text{className: 'edit'} &lt;/li&gt; &lt;% var toEdit = function () { DOM.setClass(this.$, 'editing'); this.textView.focus(); }.bind(this); var toDisplay = function () { DOM.setClass(this.$, 'editing', false); }.bind(this); this.on('dblclick', toEdit, this.id); this.on('blur', toDisplay, this.textView.id); this.textView.subscribe(this.textView.ESCAPE, toDisplay); this.setClass('completed', function () { return this.data.completed; }.bind(this), this.id); %&gt; */} ] });
I honestly don't see how that would help. It would be foolish to sit down and just start writing code without any thought or planning ahead of time. (The exception, of course, is when you're just playing around.) The actual typing part isn't where you'll find the real action. There's a reason so many of those videos look scripted -- the are, to a large degree. The hard part is over, and all that's left is the typing part. Sure, in the real world, while typing you'll often find things that can be improved (there are no good writers, after all, only good re-writers) giving you the mistaken impression that that's where the work takes place. Beginners, naturally, spend a lot of time working out problems on-screen (as writing code is still one of the hard parts for them) further feeding in to that odd belief. The bit you're interested in doesn't take place on the screen, but in the head, on scraps of paper, etc. A good developer hard at work looks pretty idle, occasionally scratching down notes, playing with something on their desk, snacking, etc. 
I recommend you look up the word *Isomorphic* because you clearly have no idea what it means; hint: it doesnt mean something impressive
Terminology can certainly get in the way. Its easy to confuse an "object" as in an instance of _something_ with the function or "class" Object. And when people say something inherits from Object, they really mean Object.prototype since that is where what makes an Object instance an Object (its methods/interface) is stored. The use of "prototype" can also get confusing. Considering Object.prototype, who's prototype is it? Is it Object's? Or is it the prototype of the object instance I just created? Technically Object.prototype is the prototype of the instance, what `__proto__` points to. Object's actual "prototype" is Function.prototype because Object is itself a function, and the JavaScript object its linked to for finding properties on it when they don't exist on Object itself is the object defined as Function.prototype. Object.__proto__ === Function.prototype // -&gt; true The prototype property on functions (like Object.prototype and Function.prototype) could be named something like `theObjectToUseForThePrototypeOfInstancesICreate`. But that's too wordy, so its just `prototype`. You just can't think of it as the prototype used by the function its defined in. That function is just a namespace for that object - and makes it easy for that function to find the object when used with `new` to create instances. &gt; When a key lookup fails on an object, the lookup is delegated to that object's prototype simply means that any object (or instance) will delegate the lookup to whatever it's `__proto__` is pointing to. What that points to is that object's prototype. Its very likely that it could be Object.prototype, but doesn't have to be depending on how that object was created. var A = function(){}; var a = new A(); Here, A has A.prototype. A's prototype is Function.prototype (`A.__proto__` points to Function.prototype because it is a function instance - you can think of the `function` keyword doing something similar to `new` in that respect). a's prototype is A.prototype (`a.__proto__` points to A.prototype). a itself doesn't have an a.prototype. It has a prototype conceptually, just not as a property named prototype. Undoubtedly confusing. Lets round off this better naming with: // custom JS world: var A = function(){}; A.theObjectToUseForThePrototypeOfInstancesICreate = {}; // replaces A.prototype var a = new A(); a.prototype = A.theObjectToUseForThePrototypeOfInstancesICreate; // replaces __proto__ Prototypes are very similar to classes. This is why you're seeing such a class-like approach being taken with them, what with the new keyword and even now with `class` coming in ES6. The problem now is that you need to be exposed to the prototype object to be able to write methods that can be inherited by instances. The new class keyword fixes this by hiding it within the class structure. In the background its still objects linking to objects, but you don't necessarily need to know that. Classes are implemented as functions and instances of those classes link to an object nicely hidden away in a property of the function that you don't need to know or care about (hint: its called prototype) for inheritance. But, being object instances and not classes, they are much more dynamic. And if you wanted to, you could change your "class" definitions at runtime. And your instances are fully dynamic and can also change, not being tied to the strict structure laid out by its class. In JS object instances can be defined with pretty much any property you want, no matter how it was created. Why prototypes? Well the concept at its core is the linking - the delegated lookup when a property is not found on an object. Now another object can be used as an alternative for that lookup. The name given to this alternative is the prototype. And by prototype, its really more like having an object that another is to be modeled from. If you have an instance that has no properties of its own, it behaves exactly like its prototype. Why have &lt;function&gt;.prototype instead of just function? Technically, that could work, since functions are objects and can have methods of their own. But 1) Functions have an inherent difference from other object instances: they can be called. If you create an object that links to a function, it will have methods like call() and apply() that would simply fail because the object instance can't be called (`aa()` for example isn't going to happen). 2) Keeping the function (which is the constructor) and the prototype separate means that you can change the prototype to be something other than it was originally. The default prototype object is just a simple, empty object that has a connection with the constructor function. You can leave it that way, or you can change it to be something else, such as an instance of `Object.create(Animal.prototype)`, all without affecting the constructor because they're separate instances.
Haven't tried this, but right off the bat looking at the source code, maybe you could try setting the cluster number a bit earlier so that the DOM is updated a bit earlier? https://github.com/NeXTs/Clusterize.js/blob/master/clusterize.js#L106
good call, thx!
Mildly misleading title given that you cherry-picked a single question out of the survey entitled "What else do you like about Angular 1.x?". It also seems like the criticisms are cherry-picked as well. True #1 will not exist in the same form as today. However, #2 (POJOs) is a common trade-off, developer productivity vs performance. No one is saying functional programming or similar abstractions improve execution performance, but they do drastically improve how quickly and easily developers can write/debug/understand the code. I also find it interesting that while you pointed out that #1 will not be in Angular 2, you did not point out the *drastic* performance improvements to #2 coming in Angular 2. This post unfortunately seems a little skewed and trying to promote more dissent than a realistic discussion. **Edit** After looking at some of your post history, it looks like you either speak without researching the problems or are intentionally spreading misinformation about Angular, especially the upgrade path from 1.X to 2.0. I would encourage you to read/watch some of the material on how applications will be able to be upgraded on a per-module basis to allow for gradual upgrading rather than a drastic rewrite.
I just had a quick look at the deprecation guide (http://www.chromium.org/developers/npapi-deprecation) and it seems that you have to use a browser extension. More specifically, this: https://developer.chrome.com/extensions/messaging#native-messaging Makes it possible to communicate with native applications. This would require you to write a service, though. Edit: This seems to be chrome only, but there is something for Firefox https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes
The chromium blog has a [post](http://blog.chromium.org/2013/09/saying-goodbye-to-our-old-friend-npapi.html) which links to a few alternatives. Another alternative might be to have a native service/daemon that exposes the smart card resources via a REST interface listening on `localhost`. The browser could access it using an `XMLHttpRequest`.
I don't know how it's useful to believe JS doesn't have classes when it has a class keyword with semantics 95% the same as classes in other languages (static/non-static methods, get/set properties, newable, inheritance via extends). Certainly this viewpoint is not at all helpful for beginners.
Very nice! The technique is very reminiscent of the way Android's ListView works. I'm surprised yours is the first attempt I've seen to bring it to the web. Kudos!
&gt; There is no straight line from a question to an answer and you meander all over the place to things that have nothing to do with anything. Well, yeah. When someone drops into a comparison of FOAM with Angular with assertions that are patently wrong according to anyone that can read the header of Angular's website, then outright refuses to admit a simple mistake, conversations tend to turn into a mess. If you weren't blinded by it, you'd see that this whole conversation is difficult to follow because the thread is orbiting around your ego.
&gt; How do these clowns always forget that readability and maintainability are more important than shaving a little time off the initial development Because it's Google engineers and their response to maintaining things is usually to rewrite them entirely or shelve the entire damned thing?
I think I did something [similar](https://github.com/capaj/grunt-smg). I abandoned it, because the only right way to package single page apps is [JSPM](http://jspm.io/).
Is that how they operate? It makes sense sometimes to start over but in most companies and government agencies, that's just not an option except in rare cases.
First thing..... irrelevant. Make it ambitious and see it through How should you learn it? Learn functional programming, scope, closure, decomposition, and reuse. Having fewer instructions in your code will significantly ease your maintenance tasks.
Yes that looks similar! :) I am using usemin for handling of production builds and this plugin started as a custom inline hardcoded task in my build. I suppose switching to ES6 modules will be a next step but for now a lot of people are using usemin (because of yeoman's generator angular) so I suppose they may find this plugin useful.
I'm not excited. We're not excited. And the fact we're not excited is telling. On the surface, this should be a cause for tremendous enthusiasm: - it comes from El Goog, or at least someone associated with Google - it has stated design priorities - it promises to prioritize performance - it offers solutions for known issues (OOP) Our reaction to those points is interesting: - we don't see the Google attachment as telling, because it doesn't seem meaningful anymore, and because we're assessing code ourselves rather than assuming Google staff can hand us 'the one true way' - we reject the density of code because we feel that readability is more important than speed of development - we reject FOAM's Java-esque solutions to JavaScript OOP - we are cynical about the rate at which new frameworks are released You might read this thread and feel rather negative about things, but I actually think this is promising. If this Reddit thread is indicative of the community, then it tells us that our priorities are changing: we prefer stability over newness; readability over hacker-friendliness; demonstration and honest critique over appeals to authority ("It's by a Google Engineer, he must know what he's doing"); idiomatic JavaScript over bolt-on OOP solutions. It suggests something encouraging about the way the community has grown and matured. It's a little unintuitive, but I'm actually quite pleased to read this thread and see people calling out awful tech rather than gushing about Today's Big Thing.
60kb down the wire, minified and gzipped? That seems just far, far too large - particularly on mobile. I'm just not sure what I get with that payload that I don't get for 45kb less with Knockout. 
The stereotypical first thing to build is definitely a to-do list application. This is especially true when learning a new framework. If you build the following things it'll give you a decent start on Javascript. * Todo List in plain Javascript * Todo List using OOP in plain Javascript * Todo List using &lt;pick a popular JS framework&gt; I would also suggest checking out http://codepen.io and recreating some of the stuff on there. Look at the code if you have to, but give it a shot without looking first.
Yeah, sorry about that. I didn't realized that I have linked the PreloadJS section. apologies.
And you're right, too. None of that stuff in itself is out of the ordinary for a monolothic framework. Without proper tooling, though, you can't deny that HTML/CSS/JS inside of comments and all of these magic strings and other nonsense will eventually turn into a maintenance nightmare. The kind that keeps you up all night.
Shameless plug : http://fulmicoton.com/fattable/index.html . same thing with a more convoluted API, with async functionality and on two dimensions. 
Sorry If I didn't explain clearly my problem. The code works and temp has value correctly returned. Please compare console.logs in those two Fiddles: [Fiddle #1](http://jsfiddle.net/cachaito/4kLfckj5/) (bad behavior - temp is returned without timeout) [Fiddle #2](http://jsfiddle.net/cachaito/4kLfckj5/1/) (correct setTimeout proper order)
One downside is that native search won't work. Eg. scroll to row ~40K, ctrl+f 41329 = 0 results. Not trying to detract from the usefulness of this plugin, I'd probably willingly give up search for performance when dealing with numbers that high.
Yeah, I know some people that avoid using ID's due to the fact that it binds them to the global scope. Honestly I think that it's fairly silly and creates unneeded confusion. I've never looked much into its consequence.
I had to read Your second answer five times to understand the message. Now I see, that: var temp = console.info('job ' + num + ': ' + msg); outside timeout was just silly :-) Greetings [senocular](http://www.reddit.com/user/senocular)!
It was mostly a joke. Google is relatively notorious for killing projects (Reader comes to mind) and has been going a bit nuts completely overhauling UI (maps, gmail to a lesser extent).
Oh great pedant of reddit, despite my deep unworthiness, won't you please tell me what *isomorphic* means.
Interesting, but I think this would be more useful if it were a plug-in for d3 (a 3D version of a Barnes-Hutt force network). It could still use three.js for visualization.
&gt; functional concepts Could you please point SPA framework, which uses functional concepts, i.e. side effect free? 
If you weren't an idiot, you'd understand the point I was trying to make instead of being blind sided by what you wanted to read instead. But this is reddit where 80% of the posters are people like you.
&gt; why is anyone still using `getElementById` or `querySelector`? Because those can't get overwritten by random stuff like globals can. Defensive programming. As you said, autoglobals are a shitty, shitty idea - so most people don't use them any more. &lt;div id="globalElement"&gt; globalElement = undefined; document.getElementById('globalElement') // still works
Which piece, the decorator?
My sides are in orbit. Definitely showing my coworkers this.
News to me. Not good news, anyway. 
Got a pull request for you ;) : &lt;html&gt; &lt;body&gt; Your name: &lt;input id="yourName" type="text" onkeyup="updateName(this)"&gt;&lt;/input&gt; &lt;h1 id="intro"&gt;Hello Guest!&lt;/h1&gt; &lt;/body&gt; &lt;script&gt; function updateName(that) { intro.innerHTML = "Hello " + that.value; } &lt;/script&gt; &lt;/html&gt;
You realize that `document` is a global and that anything can just as easily do `document.getElementById = undefined` as `globalElement = undefined`, right?
Oh calm yourself. An idea not suited for production does not a shitty idea make. I use this frequently and exclusively while screwing around in the console, and it's convenient.
What would I need to change?
No, I just wanted to make the name of the Table "Meeting History"
Or just use Google Polymer (web components) and Core-List http://youtu.be/2UKPRbrw3Kk This concept is anything but new. 
&gt; http://codepen.io/anon/pen/KpwRVv Not gonna lie, there are a ton of issues with the entire page. You've got things like class as a tag (its an attribute), a "center" tag, a random closing form tag. Lets just start with making the html inside the lefty div valid. &lt;div id="lefty"&gt; &lt;div class="block block-menu" id="block-menu-2"&gt; &lt;h2 class="title"&gt;Menu&lt;/h2&gt; &lt;div class="content"&gt; &lt;ul class="menu"&gt; &lt;li class="leaf"&gt;&lt;a href="index.html" &gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="leaf"&gt;&lt;a href="aboutUs.html"&gt;About Us&lt;/a&gt;&lt;/li&gt; &lt;li class="leaf"&gt;&lt;a href="membership.html"&gt;Membership&lt;/a&gt;&lt;/li&gt; &lt;li class="leaf"&gt;&lt;a href="join.html"&gt;Join&lt;/a&gt;&lt;/li&gt; &lt;li class="leaf"&gt; &lt;label for="cbo-meeting-history" style="display: block;"&gt;Meeting History&lt;/label&gt; &lt;select id="cbo-meeting-history" name="meetings" onchange="window.location=this.options[this.selectedIndex].value;"&gt; &lt;option selected value="meetings2014_15.html"&gt;2014-15&lt;/option&gt; &lt;option value="meetings2013_14.html"&gt; 2013-14&lt;/option&gt; &lt;option value="meetings2012_13.html"&gt; 2012-13&lt;/option&gt; &lt;option value="meetings2011_12.html"&gt; 2011-12&lt;/option&gt; &lt;option value="meetings2010_11.html"&gt; 2010-11&lt;/option&gt; &lt;option value="meetings2007.html"&gt; Meetings 2007&lt;/option&gt; &lt;option value="meetings2006.html"&gt; Meetings 2006&lt;/option&gt; &lt;option value="meetings2004_05.html"&gt; Meetings 2004-05&lt;/option&gt; &lt;option value="meetingsPrior.html"&gt; Prior Meetings&lt;/option&gt; &lt;/select&gt; &lt;/li&gt; &lt;li class="leaf"&gt;&lt;a href="officers.html"&gt;Executive Officers&lt;/a&gt;&lt;/li&gt; &lt;li class="leaf"&gt;&lt;a href="contact.html"&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; I mean this in a non-offensive way, you need to grab a basic HTML book. I always liked the Head-First series (http://headfirstlabs.com/books/hfhtml/) 
It's been like this for a long time. Next time some QA testing team tells you that all elements need a unique ID for their crappy testing software, you can cite this as a reason why they can shove that idea up their asses. 
Thanks so much for your help! The original page wasn't too bad initially, but I kept messing around with it until I get it to be pretty bad. I greatly appreciate your help!
I don't really consider html/css programming. It's markup. JavaScript is the programming aspect of web development.
Sounds like a Silicon Valley quote.
this is called [quirks mode](http://en.wikipedia.org/wiki/Quirks_mode), it's been around for some time
Cool it. If you were going to post links to 11 videos maybe you should have considered a single consolidated post?
`&lt;input id="name"&gt;`'s global is a lot more likely to be overwritten than `document.getElementById`...
I believe it's unrelated to quirks mode, but it has indeed been around forever.
Hungarian notation to the rescue. `&lt;input id="txtName"&gt;`
I have to disagree with that. It almost freezes my browser after clicking the button. I usually close pages like that. But nice plugin.
I've never used it in real code, but that didn't stop it from concealing a bug and wasting my time once. I was trying to figure out why a statement of the form `foo.x = y` was apparently not doing anything. Turned out the intended "foo" wasn't actually in scope and it was setting the property on a DOM node that just happened to have id="foo". If not for this "feature", that broken assignment would have thrown ReferenceError and I could have fixed the bug a whole lot quicker.
... Since practically forever. It's not a new feature - it's a very, very *old* feature. I'm pretty sure it long predates IE6 (when you suspect it was introduced) - I seem to remember it happening (at least in IE) almost as long as JavaScript's been around in browsers. It long predates `document.getElementById()` - it was originally the *only* way to address DOM elements, and was used to target form elements by `name` (back before anyone even really use the name "DOM" in the web design community). Then `id` became the correct way to address elements (so the functionality was extended to cover `id` as well), and around the same time period we got the first couple of DOM specs that included `getElementById`.
Thanks for this suggestion .I understand that making this plugin dependency free will serve a bigger purpose and in the coming days, I will try to do that. Having said that I tried to code this in jquery because it was first made for a project that already had jquery. It would be great if you can help in that.
For the love of XSS, guys... -intro.innerHTML = "Hello "+that; +intro.textContent = "Hello "+that; ;-)
No, it's not.
The quality of Medium articles is declining.
Browsing the site on my phone so I haven't looked too far into it, but does it recycle DOM nodes as you scroll down? Facebook recently released a React component called FixedDataTable that serves a similar purpose. Edit: It just gets stuck at "inserting 10000 rows" on my phone :(
It isn't a good suggestion because forking and diverging doesn't make sense when you are perfectly fine making the library more modular. If author doesn't agree to this, then maybe, forking could be viable but why on earth some people keep on replying "go fork and do it yourself" to every suggestion they see improving some open-source code? It is dismissive and motivates duplication of efforts. Self-coding utility functions is something no one suggested. You are attacking a straw-man.
~~No problem .I am the original author of this plugin.Feel free to contribute whenever you have time :)~~ I will try to do that.
[**@stryju**](https://twitter.com/stryju/) &gt; [2015-04-27 08:25 UTC](https://twitter.com/stryju/status/592605356460810240) &gt; http://jsblocks.com/performance hm... interesting "working with data" stats cc @jdalton ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
"Isomorphic JavaScript apps are JavaScript applications that can run both client-side and server-side. The backend and frontend share the same code." from http://isomorphic.net The point of this app is to demonstrate one way to do server-side and client-side rendering of React components. The functionality (GitHub search) is just an example and could have been anything... probably the author was bored of todo lists :-)
Completely unrelated to the project itself but... why this trend of calling libraries "JavaScript plugins"?
Angular doesn't even want to use Angular. That's why we have 2.0.
Hmm, I guess.
Okay, sure. This is the code we have from OP: var a = { start: function () { setInterval(this.something, 2000); }, something: function () { console.log("rhino"); } }; a.start(); a.something = function(){console.log("elephant");}; a.something(); Let's look at this line-by-line. The first (logical) line does a couple of things, so let's break it down into individual steps: 1. Declare a variable in the current scope called `a`. Everything in the current scope that mentions `a` now refers to this variable. 2. Create an anonymous function with no arguments and the following body: `setInterval(this.something, 2000);` 3. Create an anonymous function with no arguments and the following body: `console.log("rhino");` 4. Create an object. In this case the object is created from an object literal. 5. Create a property on that object with the name `start` and the value being the first anonymous function. 6. Create a property on that object with the name `something` and the value being the second anonymous function. 7. Set the current value of `a` to that object. Notice that I haven't used the term "method" and that the property are just values that happen to be functions. There's nothing about a function itself that makes it a method. The next line looks much simpler: `a.start();`. But it's a bit more complex than that. Whenever you see a function call in JS, keep in mind that it invokes the internal `[[Call]]` method on a value. If that value happens to be a function, the internal `[[Call]]` method will execute the function. There are some other things than functions which have this behaviour (e.g. in older versions of IE the console methods aren't actual functions although they can be called as you would expect). For simplicity's sake we can just pretend `[[Call]]` is the same thing as the `.call` method all function objects have. In other words, `a.start();` is actually invoking `a.start.call(thisArg, ...arguments);`. In this case there are no arguments, but there is a `thisArg`. We didn't pass it explicitly, so we'd normally think it's `undefined` but it's not. Why? Let's look at a simpler example first: var foo = function () { return this; }; foo(); Assuming we're running in strict mode, the function will return the value `undefined`. That isn't too surprising: there's no `thisArg` anywhere to be seen, so where should it come from? If we consider that what really happens is `foo.call(thisArg, ...arguments)` the line `foo();` is equivalent to `foo.call(undefined, ...[]);` or simply `foo.call(undefined);`. Outside strict mode in the browser you'll notice that the function returns `window`. This is because outside of strict mode `this` defaults to the global object (i.e. `window`) if it is `null` or `undefined`. This is one of many reasons you should always use strict mode: less magic. Okay, so where does `a.start();` get its `thisArg` from? Magic! In JavaScript `a.start()` is actually syntactic sugar for `a.start.call(a.start, ...[])` or more generally: `a.b(c, d, e);` is equivalent to `a.b.call(a, c, d, e);` (or `a.b.call(a, ...[c, d, e]);` if that's easier to understand). This works at any level of nesting: `x.y.z(1, 2, 3);` is equivalent to `x.y.z.call(x.y, 1, 2, 3)` and so on. Back to `a.start();`. What does it do? 1. It takes the current value of `a` and finds the object we defined. 2. It looks up the property `start` of that object and finds a simple value: the first anonymous function we defined earlier. 3. It invokes that value's internal `[[Call]]` method with `thisArg` being the object itself and no function arguments. The code that will be executed for the function originally looked like this: `setInterval(this.something, 2000);`. This is what happens next: 1. The reference `this` is resolved to the `thisArg` we were passed, i.e. the object. 2. The property `something` of that object is resolved to a simple value: the second anonymous function we defined earlier. 3. The native `setInterval` function is invoked with two arguments: the anonymous function and the value `2000`. 4. That function interally stores a reference to the function and makes a note to call it every time 2000 milliseconds have passed. The next line looks like this: `a.something = function(){console.log("elephant");};` It's nearly as straightforward as it looks: 1. It creates an anonymous function that takes no arguments with the body `console.log("elephant");`. 2. It looks up the current value of the variable `a`: the object. 3. It overwrites the property `something` of that object with the anonymous function. The final line is this: `a.something();` No surprises here: 1. It looks up the current value of the variable `a`: still the same object. 2. It looks up the property `something` of that object and finds the anonymous function. 3. It invokes the function with `thisArg` being set to the object and no arguments. 4. The function's body logs the message `"elephant"` to the console. The end of the script is reached and the execution yields to the event loop. After roughly 2000 milliseconds have passed, the anonymous function we originally passed to `setInterval` is invoked.
&gt; I was responding to the guy FTFY: I was responding to the ~~guy~~ girl
&gt; You can always fork it, make the improvements, and then post a pull request So I shouldn't talk about possible improvements but instead just make those improvements in a fork and create a pull request? I kindly disagree.
The closest thing is probably Facebook React. I don't really use frameworks so I am not the right person to ask.
You could just write your own parser for CSV. CSV has a very simple and minimal syntax and yet it is extremely terse without ambiguity. This is a language parser's ideal starting language. You could even take a CSV parser I wrote as a starting point. https://github.com/prettydiff/prettydiff/blob/master/lib/csvbeauty.js
The only part of learning code at university that I miss was the face to face interactions. Stack Overflow / google university is great, but sometimes there's just big ass gaps in your learning that helps to have someone explain. 
When you use phrases like “language wonks” and “pedantic,” you disrespect the entire notion of studying our tools, understanding how they work, and appreciating the salient differences between them. Your claim was that classes in JavaScript are 95% the same as classes in other languages. This is the perspective of a language wonk: “If you understand a class in Ruby, you understand a class in JavaScript, because they’re 95% the same.” They are not. What you are now saying is that they are maybe 10% the same, but it’s the only 10% you care about. Which is fine. A `for` loop in JavaScript is not 95% the same as a `for` loop in other languages, but it’s still a `for` loop. But if you say it’s “95% the same as in other languages,” you’d just be confusing people who then go off the rails figuring out how `for... in` and `for... of` work. There is nothing magical about being a newcomer to the language that requires telling someone that classes in JavaScript are just like classes in some other language. If they have used another language and have an understanding of classes in that language, it’s critical that they appreciate the differences. And if they haven’t used classes in another language, telling them that classes in JavaScript are the same as classes in other languages does nothing to aid their understanding, and will only hinder them when and if they do go to another language and discover that no, classes in other languages are not like classes in JavaScript.
"To improve the performance of Angular, don't use any Angular functions!"
Ha as soon as I read this I joked in my head "I bet it will just suggest you don't use any of Angluar's features", turns out I was right. All you really have to do is follow the basic guidelines for Angular performance and you should be fine. If not, maybe Angular isn't the best choice for you. 
All javascript functions take any number of arguments. If you provide less than all of them, it only uses the ones you gave it. For reduce, if you only give it two arguments, it only uses the first two parameters (previous and current values). Most times you only need the values, and not the index or array, so you can leave those out. Just to reiterate this works for every single javascript function. function x(a, b){console.log(a, b)} x(5) // logs 5 undefined x(5, 10) // logs 5 10 x(5, 10, 15) // logs 5 10 You cannot skip arguments. So in the above example you cannot only set "b", you have to pass "a" as undefined and pass "b" normally: x(undefined, 5) // logs undefined, 5 Functions can, however, just not use arguments. In the reduce example it's perfectly fine to have the function declaration take all of the possible arguments and just not use them: array.reduce(function(a, b, i, arr){return a + b});
JavaScript does not enforce [arity](https://en.wikipedia.org/wiki/Arity) — you can call a function with any number of arguments, regardless of the signature used when it was defined. If the signature contained more arguments than are present when called, then the excess arguments are equal to `undefined`. The actual arguments, regardless of the signature, are available as the `arguments` pseudo-array. Example: function foo(a, b) { console.log('first argument:', a, 'number of arguments:', arguments.length, 'last argument:', arguments[arguments.length - 1]); } foo(1); # =&gt; "first argument:" 1 "number of arguments:" 1 "last argument:" 1 foo(1, 2); # =&gt; "first argument:" 1 "number of arguments:" 2 "last argument:" 2 foo(1, 2, 3); # =&gt; "first argument:" 1 "number of arguments:" 3 "last argument:" 3 
Well, in my case I have to use Angular. I wouldn't say don't use Angular anyway, rather use it wisely. With great magic comes great responsibility. Every framework has its plusses and minuses. 
&gt; Use ng-if instead of ng-show I've had cases where ng-show was vastly more performant. I've got an app I use to help me find minis for D&amp;D, and it loads up hundreds of images. I then use filters to show and hide them to help me find appropriate ones. In this use case, ng-if caused elements to be created and destroyed constantly, and when going from a small number of shown elements to many, it would take almost as long as the initial load. Ng-show solved that latency entirely.
I agree 100%. In this case ng-show seems like a better way to go. I did mentioned that there are some cases like that in the article. Do you think I need to expand on it more? Perhaps add your example?
Good example in favor of ng-show. On the flip side, I recently switched to ng-if because I had a single route which shared some elements, large relevant scopes, and never visible at the same time. Think "map view" vs "grid view". By using ng-if, I essentially lazy loaded the other scope which resulted in faster app boot up time (especially important due to using Ionic). 
wait a minute...
This is why you wait until a framework is mature before even considering it for anything non-trivial. But devs seem to love trends, (at least the young and inexperienced ones do) and anything new is automatically better than everything old so it must be great and should be used for every project!
&gt; If Angular 3 ever happens, there will be a much simpler automated upgrade path. That's... a bold statement. 
Here is the 12th tip: [use jsblocks](http://jsblocks.com)
I did not think I was going to read every word of this post, but I did.. because JAVASCRIPT
When asking for help with stuff like this, you want to try and remove any barriers preventing people from quickly helping you. I'd suggest you put a working example of your issue on [CodePen](http://codepen.io/pen)
I'm at work right now and that page is blocked, the relevant code is provided in the link. How could I get a 1 to 1 example on the web when I'm using DB values? I can get to jsfiddle, but like I said I'm not sure how I could replicate my code to get a working example when I'm using a DB 
Meteor seems to be pretty good for dynamic pages/web applications.
I'm no expert on this, but I think one way would be to use a template like [**Handlebars**](http://handlebarsjs.com/) and just set up headers, footers, and whatever else as "partials." I have only used Handlebars on the server side, but I love it so far. 
Thanks again, I updated the tip title to highlight that ng-if is not always the right tool to use.
[Jekyll](http://jekyllrb.com/) is pretty cool. I've used it on projects before and it is pretty simple to get up and running.
If you're using node, I recommend Jade because it supports template inheritance, partials, and is secure by default.
If you expect someone to write you a cross-compiler for something as difficult to reason about before runtime as an Angular JavaScript application, then you are being very blase about a very hard problem. This is not like ES6 transpilation, where certain constructs have fairly straightforward substitutions, and you can just run your code against a virtual machine once to create a string of mapped commands. You are talking about handling inline expressions, making two way binding work in an environment that doesn't do it naturally, and handling code that can modify its key data structures at runtime, addressing them dynamically. That's not the sort of work that someone's just going to knock together on Github in a few weeks' time.
Existing properties of the `window` object take presedence, and when some poor sod who doesn't know any better tries `location.textContent=":'("` they enter debug hell.
Unfortunately, this has nothing to do with quirks mode. Read the links posted around in the comments: The Mozilla and Webkit devs both chose to make it active even under standards mode, because there were too many sites using it despite adding a doctype which triggered standard mode. Sadface.
Specific requirements - so what class are you taking?
Sure, 'it shouldn't take too long' for me to pick some up.
It's proposed syntax for ES7, and is already supported by transpilers like Traceur and Typescript (and probably Babel too, by now). If you take a look at [this](http://aurelia.io/validation/#/), I believe it would be safe to assume the bottom syntax would transpile into the equivalent of the top syntax. The difference is that the logic will rest on top of the property instead of buried inside your constructor. It's really just syntax sugar. Useful sugar because it improves readability (in my opinion, anyways), but sugar nonetheless. Here is the actual code behind the @ensure decorator: [ensure](https://github.com/aurelia/validation/blob/master/src/validation/decorators.js#L40). Note that it is an exported function that returns a callback that sets _validationMetadata on the target. You can also compare @inject with the static inject() examples throughout the code. Similar transpilation is going on there.
you can use JSON to create an array to represent your DB data in jsfiddle or codepen. That would make it easier for anyone to help you. But looks like you've removed the question from stackoverflow.
Backbone views are basically DOM elements. So understanding HTML, CSS and jQuery and how these work together is crucial. However when it comes to Backbone, there are some common pain points. First off, Backbone doesn't force or even give any high-level structure like any framework (AngularJS, Ember.js, Ruby on Rails). So the structure varies from project to project and person to person. In addition to that, Backbone doesn't support nested models or views so that also up to the developer or external libraries. If you have existing Backbone code, try figuring out how things are done and be consistent in new code. But if you're starting from scratch, read guides like [this](http://pragmatic-backbone.com/) and use [Marionette.js](http://marionettejs.com/) if possible.
well, understanding scope, how views work, and what the hell I am doing generally. I am taking the course on Udemy and I dont think it does a great job explaining the framework. Take this chunk of code: onClickToggle: function(){ this.model.toggle(); console.log(this.model.toJSON()); }, render: function(){ this.$el.toggleClass("completed", this.model.get("isCompleted")); var checked = this.model.get("isCompleted") ? "checked" : ""; this.$el.html("&lt;input id='toggle' type='checkbox'" + checked +"&gt;&lt;/input&gt;" + this.model.escape("description")); return this; } I rarely understand where this is pointing to and how OO js works since it's without classes.
does marionettejs makes things easier? My company uses backbone.marionette on the frontend.
I've found Marionette to be a very nice framework that adds some of the things Backbone is missing as well as guiding the user towards a way of organizing their code. I've found the modular approach to be very helpful. A good book to read is "Backbone.Marionette.js: A Gentle Introduction" by David Sulc. During/after reading this I was confident enough to port an existing application in a little under a week.
"this" inside a backbone view will be the current view. [this.$el](http://backbonejs.org/#View-$el) is the jQuery object for the DOM element the current view is bound to. [this.model.get(propertyName)](http://backbonejs.org/#Model-get) returns the value of propertyName from the model bound to the current view. So the first line in your render method toggles the .completed class on the view's DOM element based on whether or not the isCompleted property of the view's model is truthy or falsy. With marionette, I generally avoid directly rendering HTML inside a view, and instead use a [LayoutView](http://marionettejs.com/docs/v2.4.1/marionette.layoutview.html) with a region to show another view.