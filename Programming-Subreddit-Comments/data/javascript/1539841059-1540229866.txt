When you can mentally construct the building blocks of a solution to just about any problem or task at hand - maybe the specifics require some trial and error or google-fu, but you at least can put together a roadmap of how to do the thing you need to do. 
Hollerin at a guy cuz he doesn't know what he thought he knew doesn't teach anything.
The title didn't allude to any exclusivity. 'Like Soccer, watch it all here' - Sports channel. 
The title didn't allude to any exclusivity. 'Like Soccer? Watch it all here' - Sports channel. 
Webstorm. Or in my specific case phpstorm. Although phpstorm is webstorm + sql DB integration and first class php support. VS code is great, but phpstorm provides higher quality features plus way better VSC support. Not to mention sql integration. So if you are working in continues integration environment and interact with RDBS it's obvious choice. To answer your second question: With webpack I can't understand whats the point of gulp. I've came to js development after webpack took precedence, so I've never even used it. Although doesnt seem I'm missing anything either.
in the `var` case, the variable is scoped a bit differently -- it is available both before and after the loop finishes. consider the following output in the node repl -- 
if you want to tell yourself removing unnecessary code-bloat and in turn bundle size is not optimization...please do so. but good luck getting a job in any proper development team with that mindset. especially in web, payload size is tightly connected to page-load time and time to interact. if you fuck either up, your conversion rate will plummet / nobody will want to use your app. network optimization is again something completely different, but okay.
/r/LearnJavascript is the place to ask this.
in the var case, the variable is scoped a bit differently -- it is available both before and after the loop finishes. consider the following output in the node repl -- &gt; a; for (var a = 0; a &lt; 10; a++) { } If you run this, you'll get `undefined` output to the terminal. If you omit the `for` loop, it'll be `ReferenceError: a is not defined` This can also explain why you get `4` logged a few times. The setTimeout callback fires after the loop has finished... it then logs the var, which has since incremented a bunch due to the for loop. The condition is `&lt; 4` effectively, so to exit the loop it must be 4. It's basically the same as `console.log(x)` after the for loop, you'll get back 4. So `let` is different because it is scoped to the for block. If you try that first example above except with `let`: &gt; a; for (let a = 0; a &lt; 10; a++) { } You'll get the reference error. (but make sure you use a different variable or kill the node repl process and start it again -- the `a` variable is already declared as a var now so it won't throw and you'll see undefined.) Ok, so now consider using it with `setTimeout` -- because the variable is now scoped to the for-loop, different iterations of the loop will effectively have its own copy - and the closure will reference that copy of the variable so you get `0, 1, 2, 3` logged instead of 4 4s.
const/let are block-scoped variables. The body of a loop is a block
Machine learning with JS? Wow! I must check it.
Well explained! Thanks. 
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not. Proof: &gt; all the promises will fire at once Before the edit.
https://i.ytimg.com/vi/pID_QuyUi98/maxresdefault.jpg
When you stop asking.
Definitely, do not quit. You have your whole life to get work experience. It'll be harder to grab the degree if you want it afterward. Just go for it, at least, you'll get paid better your whole life, which is not useless.
It's my second year and I might be able to get the degree this spring if I get a couple of abroad credits accounted for. 
Who illustrated the graphic on the video thumbnail?
if it's that close it's probably worth your time. Even if it's in a completely unrelated engineering field you might want to use it later somewhere else or you might find unique positions where your engineering skills/degree in the other field and software dev. experience is plenty useful. These positions generally pay a lot. 
When you click on empty space in scrollbar on Windows you're going one page down/up but with this component it jumps straight to that clicked position.
Hmm really. Could you please create an issue on github? (Just not to lose it or forget)
I unfucked the code. You can run it by pasting the code into [(P5JS editor)](https://editor.p5js.org/). var c; var a = 0; function setup() { createCanvas(400, 400); frameRate(60); } function draw() { background(255); u(a); a += 1 / 60; } function u(t) { var worldMap = [ [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]; var h = 27 * 16; for (var i = 0; i &lt; h; i++) { // This loop draws circle form top down if (cos(t - i) &gt; 0) { // This checks if what you are drawing is facing you var symbol; var row = floor(i / 16); var column = i % 16; column = 15 - column; // We read the matrix backwards since I accidentally made worldMap in reverse if (worldMap[row][column] === 1) symbol = '‚¨§'; else symbol = '.'; var xOffset = 200; var yOffset = 10; var yScaling = 0.5; // yScaling stretches the Y-axis so the image looks circle text(symbol, xOffset + sqrt(i * h - i * i) * sin(t - i) / 2, yOffset + i * yScaling); // Draw a curved line } } }
You must go out of this closure, man... await no more, react and hoist youf life up.
Well, its open source: [https://github.com/jgraph/drawio](https://github.com/jgraph/drawio) It states it uses the [mxGraph Library](https://github.com/jgraph/mxgraph) Its desktop app appears to be powered by [ElectronJS](https://electronjs.org/)
someone give this man a cookie
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, DEFINITELY a clueless idiot. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond, moron.
&gt; all the promises will fire at once Okay, so I guess I could say that better but here it is: You don't understand what promises are and how they work. Your loop will work, but your explanation in sentence one is what I was referring to. Think about the difference between creating a promise and waiting for it. If you can `Promise.all`promise creation has already happened - for *all* of them. Which means the function that does something asynchronous was already started and is now hanging in some syscall for the async. event (or the promise has even already been resolved). Obviously, you must not call the function and *create* the promise if you want serialization. Your for loop does that because it waits. Your "fire at once" shows that somehow you think that when you have a promise nothing has happened yet, and only when you Promise.all on it does something happen. In fact though, *everything* has already happened by that point! The async. process already started, the command (I/O, whatever) already issued, or you would not have a promise from the respective function. Again different * promise chaining*, but that is not what Promise.all does. 
&gt;but it has been de facto standard behaviour in browsers since IE6 Even if that were true (see Charles' reply) the spec says that is doens't have to be true so you should not rely on such a defacto standard. Another execution environment (which could be netirely new or as little as a browser point release) could come along that does things differently for its own optimisation purposes and in that environment your code may beak. The execution environment has done nothing wrong in this case and would have no requirement to publish the change in a way that would grab your immediate attention, so it could take a lot of wasted effort to find and diagnose the issue.
First off, you're an arrogant jackass. Secondly, you're a **wrong** arrogant jackass. /u/3skil said you could replace: userIDs.reduce( async (previousPromise, nextID) =&gt; { await previousPromise; return methodThatReturnsAPromise(nextID); }, Promise.resolve()); with `for (p of promises) await p`. The problem with that, the same promise that `Promise.all` has, which /u/nullOrVoid **correctly** pointed out is that with the snippet `for (p of promises) await p`, you already have an array of promises. If, for example, those promises are for HTTP calls, then that means you have already started those HTTP calls, and if you've done so synchronously just before that line, then they have all **fired** at the same time (inb4 the browser limits the number of concurrent requests to the same domain. I know) It is **incredibly** common in the industry to say an asynchronous process gets 'fired'. A promise is the representation of the result of an asynchronous process, and therefore it is also incredibly common to say promises are fired. That is something I can guarantee you will hear once you find your first job in software. There are plenty of use cases when starting all your asynchronous processes at once is preferable, but there are also plenty of uses cases when that is absolutely the **wrong** thing to do. For example, if there are a large number of HTTP calls and blasting them out all at once would overload the backend when you have 100k online users. &gt; Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. I am referring to starting the asynchronous process represented by that promise, you dolt. I know what promises are, I've used and implemented them in multiple languages. Did I mention you're an arrogant jackass?
"What is jQuery? It's an old, dusty language" sure
**Promises don't FIRE** you STUPID moron.
The former doesn't, but the latter will.
Hyperbole, but OK üòõ
What if you're building a site that isn't going to be maintained? What if it needs a few flashy features that can be easily added with a plugin or two? Not every web developer can be working on long-term products or applications, some of us do grind out marketing sites, campaigns, micro-sites etc. There's no argument here that jQuery is a dusty old javascript library and it's not pure or exciting, but if you just need a quick no-brains job done it's can still be an effective tool.
Only if you `await` the promises.. I think if you were to call `.then`, there is nothing that enforces sequence, is there? Also, nobody said you're doing anything with the result of the promise ;) So while latter *allows* for sequential processing of, it's not enforced I believe.
Exactly this.
adding your 2 cents isn't gonna help you understand it either
anyone who starts a sentance "if you wanna tell yourself" usually has no idea what they're talking about. 
You're a fucking idiot. I know they don't **do** anything. I said: &gt; A promise is the representation of the result of an asynchronous process which is true. Nobody in this thread has suggested promises *do* anything -- you're just intentionally finding something to argue about. Regardless, you're still fucking wrong in the ways I explained before. Go read what I said nice and slowly -- I know it's a lot of words, but I believe in your ability to read. I won't waste any more time on you.
The reusable functions were not that easy to read and understand, but once I did understand it I can see how nice they can be to use in a project.
Hyperbole to call library a language?
Do you have SSR final compiled HTML? Just curious to compare it with pre-rendered HTML and ask Google's Lighthouse what is better. From fusionjs website: &gt;Out-of-the-box support for server-rendering of React components "Support" doesn't mean it works out-of-the-box, and what about Vue.js, Ember.js, other templatings? Pre-rendering is platform, framework, server, and language agnostic solution. As well as off-loading server, caching, and delivery via CDN.
Why? 
HEY MORON: **Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
OK, fair. I'll fix that
I went and read the linked info and came back with exactly the same question 
I like jQuery. Even after all these years, it still feels nicer to use than the native dom api. Even chrome dev tools uses the jQuery dom query api. 
Everything in JavaScript is an object, and that includes functions! So you can create a function and assign properties/methods to it for example. const func = function() { ... }; func.method = function() { ... }; func(); // Works func.method(); // Also works
Hey! had a quick play around, looks like a solid start. You'll need a way to let devs know what features need to be worked on if you want people to contribute, so look into setting up a project board and code reviews on github! If you are looking for ideas about what to work on next, here are some things that would be nice to have: * Move the login/register code out of the routes and into dedicated controllers so you have proper seperation of concerns. Developers will end up having to do this, so it would be nice if it was already taken care of. * Some basic testing would be nice, especially if you are looking for contributors. * Add some default values for the database setup and make a note of them in the readme. * Add a default route and view that would allow people to register, login and log out. This along with the default database setup would allow me to install everything, fire up a dev server and quicky test that everything is working as intended, without having to write any code. * Lastly, I'd definitely recommend looking into going the same route as create-react-app and setting your project up as something that can be installed as a global command via NPM. The way things are at the moment, I'd have browse to your repository, clone the project, rename the root folder and delete your git remotes/add my own every time I want to start a new project. Just running one command would be much more user friendly. Nice idea for a project, plenty of scope for it to grow. &amp;#x200B; &amp;#x200B;
It just crushes by clicking the input button without a number filled in, returning NaN everywhere. Please, disable the input button when input is not filled.
Less factitiously: * Something to do if you have thumb twiddling time or were looking for a project to try/practise something on. * A challenge. Though there seems to be no prizes or any voting/scoring system defined, trying to succeed with arbitrary constraints (here those being time and a fixed theme) is enough for some to be enthused. * To be part of something, if that something is your sort of thing. * Many other possible reasons. Of course the obvious reply in the form of a question is: why not? I don't have the time ATM\[^(1\]) but there seems to be something about the whole idea that you are particularly incredulous about. ^(\[1\] or the interest, to be honest, but I) *^(am)* ^(interested to see what others might produce) &amp;#x200B;
&gt; "Support" doesn't mean it works out-of-the-box, and what about Vue.js, Ember.js, other templatings? You can write plugins for non-React systems. When you use prerendering, you use a general system. For that generalization you must pay with cpu, and more cpu means more money. Fusion has the best of both worlds when it comes to React.
It's really small and hard to read on mobile. 
üç™
It doesn't matter who starts because the rules of the game changes depending on who starts. If you start the starting value is a multiple of the max value you can take plus 1. If Nim start this is not the case and the Nim takes the number of balls required to make the value a multiple of max value you can take plus one. Therefore it does not matter who goes first because the game makes it so the scenario is the exact same either way
TIL: draw.io is open source This man deserves 2 cookies üç™ 
So the `keys()` is a custom method they added, and not the `keys()` [from the prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)?
So how is this different from ‚Äòquery-string‚Äô? https://www.npmjs.com/package/query-string
Correct. This `keys()` function couldn't be `Object.keys()` anyway, because that function is defined on `Object` and not on the prototype. If it were defined on the prototype it would be `Object.prototype.keys()`.
This is pretty sweet. Seems like a fun little project to get some new experience
/r/CookieClicker 
I just don‚Äôt understand the use case for sequentially resolving promises. To me it has all (and more) of the complexity of `async` yet none of the benefits.
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, you are definitely clueless. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond. Stupid moron.
**Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
Can you share how it's made? Would love to have similar kind of "structure" (navigation etc.) for my README.md files.
Hi, I develope something similar, all in vanilla js but with [more pages, pics, columns with flow texts ecc... like indesign](https://www.keypress.me/FOTO/preview.jpg), I can assure you that don't need nothing more than pure javascript, no frameworks.
Woohoo, every Friday off. What‚Äôs that, every Thursday now too, oh if I can‚Äôt code Thursday, that means I get Wednesday off too. I do work salary, correct? I think this headline has a recursion issue. 
Why not both...? Even more preferably if you company foots scholarship money for it (which they should... ). Really don't think you should have made a decision like this so rashly. 
I don‚Äôt think anyone assumes you do.
He needs to click allow...
Are there trackers in those cookies?
Have you actually used it in production on anything that isn't a trivial project? If so, what would you say its downsides are?
I was referring to this api $(&lt;selector&gt;). I didn't mean to mean the entire jQuery api
Sequential promise resolution and async as a spec isn't really an apples-to-apples comparison. One use case for resolving promises in order is to throttle server load. If each promise wraps a big file upload, for example, you might not want to do a ton of it at once, and instead space them out, one after the other.
You don't need DOM contact with modern libraries, not think in such a way.
Also good presentation on the topic "Everything you never wanted to know about JavaScript numbers": https://www.youtube.com/watch?v=MqHDDtVYJRI
Nice work! And yes, that's JavaScript.
**Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
HEY MORON: **Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) Events can be "fired", and if we use that analogy - which would be unusual but at least possible - the only association between "firing something" and promises is when the promise resolves. You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
Nice to know this path is available. What kind of companies have you worked for?
Job was full time and in another town. I sort of had to choose one or the other.
You're right, thanks. I forgot about that sub.
My original reply defends a newbie from elitism. *Your comment* ***here*** is 2 cents. Blocked.
Yeah, it‚Äôs a rigged game for nim to always win, I‚Äôm hoping it‚Äôll take a while for players to notice it‚Äôs unwinnable and they keep trying to strategize
I always found the worst problems to debug were after release (including after revisions). It really pays to consider debugging strategies and design then into the code. Code pessimistically, there will be bugs. Your future self (or the poor schmuck who inherits your code) will thank you.
Well....yeah. frameworks are built on vanilla J's. If for fun, have at it. Reinvent the wheel. For production projects, it doesn't make sense to reinvent the wheel everytime. 
Thanks.
That‚Äôs a good idea, could I extend such an idea where it doesn‚Äôt work if it‚Äôs text too? Something added to the if statement about too many/too few balls where if (playerNumber = NaN ){ setText (‚ÄúerrorMessage‚Äù, ‚Äúyou must use a valid input‚Äù) } 
"number" is an input field type that will handle what you're seeking for the client side
Full time is not really much more than excuse, if you took 3-6 credits a semester you would delay graduation by 2 years? Does this other town not have universities? C'mon...
Ahh cool, I figured out nim's strategy I think and now I'll be able to beat anyone on this game! Except for nim :(
If you have to ask, it is not for you ;) And there is nothing wrong with that.
What did you use for rich text editing?
&gt;Nice idea for a project, plenty of scope for it to grow. thanks for the tip bro. Really appreciate the help.
Good one for betting friends though
Man what a coincidence! Just today I was looking for a flow charting app to help teach me to code. Thanks! 
Maintain doesnt mean expansion of the codebase. At worst you encapsulate and integrate. Better yet you migrate, first the state, then to some adequate view library once state is managed. There are no excuses at present state of things to write more jquery. And if job demands it, ƒÆ would reconsider my willingness to work there. Reeks of abysmal management, planning and, frankly, care.
Oh boy do I remember the days where I enjoyed making bets I couldn't lose. Not my style anymore though, I've come to appreciate true risk
You‚Äôre kidding, right? It‚Äôs a demonstration.
[draw.io](https://draw.io) was originally written using a framework, many, many years ago. We switched to vanilla JS around 2010 and it's far less tedious. Frameworks are fine for prototyping, but you get to the level of complexity and performance we have in draw, frameworks are completely in the way. I know your line is line everyone repeats, but we've been there, got the badge and respectfully disagree.
I have Googled and been on SO but if I'm understanding correctly, on EA's side they've not allowed this request by not setting 'Access-Control-Allow-Origin' in the headers? Websites like [www.Futbin.com](https://www.Futbin.com) and [www.Futhead.com](https://www.Futhead.com) get that data from somewhere, and as EA provide it openly like that, I didn't imagine they'd not allow the requests.
I build my own style for size, colors, font and weight, just using somethings like window.getSelection() ... getRangeAt(0) ... createRange()...
Feel free to build the React/Angular/other frameworks from scratch for every project you have.
&gt; I'm understanding correctly, on EA's side they've not allowed this request by not setting 'Access-Control-Allow-Origin' in the headers? Yes. &gt; as EA provide it openly like that, I didn't imagine they'd not allow the requests. Just because they have an API does not mean you are supposed to use it. They might use it for their own websites/apps only. By the way, this limitations only applies to requests made by browsers. You could totally run a service in the backend to request their API and, unless they employ further measures against that, it will totally work.
I think that is not what he is saying, transpiling itself will not break it. But what *will* break it is to run the code on a non-ES6-compliant browser.
&gt; unless they employ further measures against that, it will totally work. the fact that i can put the url in my browser directly and it works means they have no further restrictions.
And, obviously, you noticed that we have no analytics of any kind on the [draw.io](https://draw.io) site?
is the folder structure okay or should i make certain changes? Really thankful for your feedback.
No, not necessarily. They could, for example, only allow browsers to request the resource (that won't really stop anyone from scraping the API though).
And I imagine `contentEditable`?
First of all, it's an API that is publicly available. What sense would it make to restrict it only to browsers? Because people just love to read JSON formatted data. Second of all, any good developer knows never to trust a user agent - there is really no possible way to restrict it only to browsers.
cool.. looks like scratch with all the colors, but i've never used scratch so i'm not really sure.
Yh maybe or any popular meeting management app 
Fusionjs powers 700+ apps in Uber.
Please, as a gesture of kindness to people potentially trying to help you, **never** post code as an image. Instead post code as what it is: text. Either in a code block, in an external _pastebin_-like service or in a _JSFiddle_-like service, but always as text. Thank you.
It is a bit similar to scratch, but it allows you to type out the commands instead of dragging and dropping blocks of them, and I type it to not develop bad habits 
&gt;Maintain doesnt mean expansion of the codebase. It certainly can. New features can easily get added to legacy apps as new business needs arise or existing business needs change where it is far more co$t efficient to kick the can down the road a bit further than rewrite the app in whatever is in fashion today because some dev thinks management is abysmal (they don't care about your principles). &gt;There are no excuses at present state of things to write more jquery. You should get a job at a bleeding-edge startup as opposed to the real world. &gt;And if job demands it, ƒÆ would reconsider my willingness to work there. Your job is not to write code, your job is to add *value*. It isn't up to you to determine value added as you're not involved in any business strategy or planning.
No worries, I'm happy to help. [This](https://www.terlici.com/2014/08/25/best-practices-express-structure.html) is a good starting point for structuring an Express app in a more traditional MVC fashion. 
Great, thanks for that. I might have to give that a go, I was just under the impression that as it was available without a token or login that it was there to be used and I'd be able to request a GET on it! 
Sorry! I corrected it.
Thank you 
Just for your trouble, [this is what is looks like in a JSFiddle](https://jsfiddle.net/xvguwf90/), and [this in a CodePen](https://codepen.io/anon/pen/ZqxNVg). The advantage is people trying to help you can directly [try to] run the code and see for themselves.
&gt;No worries, I'm happy to help. This is a good starting point for structuring an Express app in a more traditional MVC fashion. Yes, and most people follow the same directory structure. So i thought i will use the same
Nice and smooth! :) I think I also saw some examples where the curve gets smoothed after the user has drawn a few more pixels. Feels more direct to input but looks weird sometimes. I like your idea. 
Too late.
Low lazy radius with a touch screen feels so smooth and natural! Excellent!
Is it possible to draw using this programmatically? 
A great example is when people add utility methods just like you did, and then enough people like it that it becomes a core part of the standard library. Except the interface or behavior is slightly different. Now if someone loads your library in an environment with a new version of the language, your code stomps the built-in. Standard-conforming code now breaks because of your non-standard extension. Alternatively, if you check if the property exists before adding it, your code that relies on the non-standard behavior now breaks when the property is set in a newer version of the language. In addition, browsers are free to add their own non-standard features, so the method may already exist on a browser that you haven't tested, and it's fair game for that collision to happen. A good real-life example is the Prototype.js library, which extended the prototype of built-in objects as you are doing, and the write-up that one of the authors wrote explaining the reasons why version 2 won't be doing that: [http://perfectionkills.com/whats-wrong-with-extending-the-dom/](http://perfectionkills.com/whats-wrong-with-extending-the-dom/)
From what I understand, if you're using JSX, there isn't much point in using Vue. I would look at React first. 
great post!
Yeah, I'm currently doing react mainly. But can't get my head around what's the big fuzz around vue. I know laravel ecosystem supports it very much so marketing obviously had it's sway. Easy of use for people who aren't well versed in javascript seems to be another plus. However, that's not the whole story I think. So perhaps someone who has experience in Vue and works quite a bit with React would be nice.
DO NOT QUIT
Kubernetes?
&gt; JSX, which I prefer over HTML That's a solid reason to stay with React. &gt; If I try Vue and go full JSX will it diminish the point of the tool or there is something more to it? IMO, JSX was implemented in Vue as a crutch, just to say "since React has JSX, we'll have it too". I've never seen anyone using JSX in Vue in large projects. In fact, most people who moved to Vue did that because they *dislike* JSX.
Yes, it would be no different than providing the coordinates from a mouse. I am actually using it like that myself for a project. There the coordinates are coming from a remote device via WebRTC and are used to move the pointer and brush.
There are many ways to do it. You could draw it on a paper and solve it (it is actually a 2D problem). Or you could implement 4x4 matrix multiplication, and make the final matrix as a product of simpler matrices. &amp;#x200B; Note, that the "eye" is always at \[0,0,0\], looking forward in the direction of Z, and the matrix rotates the whole model. When the camera is at \[X,Y,0\] and has an angle A, the model has to be moved by -X,-Y, and rotated by -A. Now, you rotate before translating. You don't even track the X,Y of the camera.
This. I use Vue in production *because* it meant I could avoid jsx.
Specification !== implementation.
LOL @ https://i.imgur.com/bPIUOPg.png
"**Is there any solid reason to try Vue?"** Yes. It allows you to write Web Apps as easily and as fast as other frameworks. No big Advantage. Just because you like mixing HTML and JS (JSX) does not mean that it is a good choice to use React or something very similar. Why? You may will face some framework problems giving you the headache of your life. If thats the case don't give up and finish it. After its done you will know if you will choose it again in the future.
Yes.
What a coincidence! I've been digging in [draw.io](https://draw.io) code periodically for the last 2 years because mxGraph docs are total shite for anything but the very basic stuff! 
&gt; JSX, which I prefer over HTML You React kids are nuts.
Not sure what makes you think that steady enterprise environments with continues integration / development flow is something different? Actually more so, you can be forgiven polluting your codebase when you are prototyping, for example, for some sort of start up. But for steady product-based development code quality is essential. And I do work in one of those environments. And we did had jQuery and some backbone. Where code is most prone to change and adjustments due to growing / changing business needs it was changed. That was then, now there are plans to migrate some of the main systems from Angular JS which had it's last release this year july. " Your job is not to write code, your job is to add *value*." - That's exactly my point. And you add a lot to maintenance costs if you write legacy code as well as increasing exposure to risk down the line. " It isn't up to you to determine value added as you're not involved in any business strategy or planning. " - however this point is rather silly. When given a choice between higher quality code base and better business cohesion opting for higher quality code base is safer choice. And if you don't want to take my word for it, take Kevlin Henney's. There are technical reasons why is it so, mainly that improving the second once first is established comes at much cheaper price down the line. " New features can easily get added to legacy apps as new business needs arise or existing business needs change where it is far more co$t efficient to kick the can down the road a bit further than rewrite the app in whatever is in fashion today because some dev thinks management is abysmal (they don't care about your principles). " - I mean, this is either shotsightedness at best, lack of competence and personal professional improvement at worst.
Nice job!
&gt; JSX, which I prefer over HTML You React kids are nuts. That statement strikes me as straight up absurd. JSX was not created as an alternative to HTML, it is HTML. It was created to facilitate the Virtual DOM, which was invented to solve a very specific problem, heavy piecemeal DOM updates in super enterprise sites, a long time ago, when browser DOMs were slower.
If you haven't done so, look into Vue's [Single File Components](https://vuejs.org/v2/guide/single-file-components.html). You can also [use JSX with Vue](https://vuejs.org/v2/guide/render-function.html#JSX). 
If you do not like html then vue may not be for you. kind of a weird thing for a web developer to say but hey you do you. I will say that vuex is a dream compared to redux. you don't have to wire up every component and list what values are being used. you can just use the values that are in the vuex store. You still have to write actions but you don't have to link the ones you are using to every component. &amp;#x200B; Overall I find my development speed to be much faster in vue and my code to be much less verbose and cleaner.
Not really, I already developed my own frameworks many years ago, nd update it constantly.
yes, also.
Static websites are not an alternative to dynamic websites, and not getting that is incredibly dumb.
If you like building existing ssr ( server side rendering) applications like, Rails Laravel or Node. Try Vue. Vuex is has amazing simplified state management features, even better than redux. 
Perhaps I should have formulated with word 'writing' in it. Because it may leave an impression that I do not understand how it works under the hood. I do. And I simply value it as a tool more than few potential downsides because the ease of reasoning about the template as well as manipulating it a lot lower and more intuitive for me. I do work in enterprise environment though, hence my React background. However, as I've mentioned previously, I'm starting a pet project and trying to determine if there is value on picking up something new. Doesn't Vue utilize virtual DOM too?
You could have read [one comment deeper](https://www.reddit.com/r/javascript/comments/9ozyn3/property_order_is_predictable_in_javascript/e7z644c/) to see this has already been addressed. The comment is objectively false.
typescript is actually pretty cool, but lets keep in mind the product comes from the same people that made internet explorer.
Who are also the same people that made Visual Studio Code so. 
To be clear, I relied on it after it became standard but targetting a legacy browser which I knew implemented it.
No, the virtual DOM was created so you could write UI in a functional fashion: makeUI(input_data) -&gt; UI. Without the virtual DOM merging process you'll lose lots of state such as cursor position in textboxes and so on. 
i've never used vs so i don't have an opinion on it..
&gt; When given a choice between higher quality code base and better business cohesion opting for higher quality code base is safer choice Not always. Change = risk. Management's purpose is to manage risk. There's a reason why you have parts of the US Military that can't get off Windows XP due to mission-critical functions that require XP and the US Government gives multi-million dollar contracts to provide support for those legacy systems. You've also moved from jquery and backbone to, what some developers would say has been essentially deprecated for some time now - angularJS, which you say you have plans to migrate? How many times have you rewritten code in how many years, -vs- just updating that jquery/backbone? How are you measuring the supposed value added there?
VS Code is not VS and it's probably the best code editor atm.
&gt; all the promises will fire at once Okay, so I guess I could say that better but here it is: You don't understand what promises are and how they work. Your loop will work, but your explanation in sentence one is what I was referring to. Think about the difference between creating a promise and waiting for it. If you can `Promise.all`promise creation has already happened - for *all* of them. Which means the function that does something asynchronous was already started and is now hanging in some syscall for the async. event (or the promise has even already been resolved). Obviously, you must not call the function and *create* the promise if you want serialization. Your for loop does that because it waits. Your "fire at once" shows that somehow you think that when you have a promise nothing has happened yet, and only when you Promise.all on it does something happen. In fact though, *everything* has already happened by that point! The async. process already started, the command (I/O, whatever) already issued, or you would not have a promise from the respective function. Again different * promise chaining*, but that is not what Promise.all does. 
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, you are definitely clueless. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond. Stupid moron.
Reinventing the wheel is one thing, but learning how to build and use one yourself is another.
because it can potentially break shit for coders who were too lazy to use `hasOwnProperty`. var obj = { one: 1, two: 2, three: 3 } Object.prototype.poop = 'farts'; for(var p in obj) console.log(p, obj[p]); outputs: one 1 two 2 three 3 poop farts it's not always a bad idea though, sometimes it can have great benefits. for example, I wrote this [date library](https://pamblam.github.io/protodate/), it's 20 times faster and 1/5th as large as the leading date library (moment.js) -the only catch is, i used the date prototype. since no one is going to do a for-in loop over a date object it doesn't really matter.
Thanks /u/kenman
Yeah Vue is basically React for people who don't want templates over components (or in addition to components) and straight HTML instead of JSX.
&gt; First of all, it's an API that is publicly available. That does not mean that everybody should use it. Many mobile applications or websites rely on APIs that are "publicly available". &gt; What sense would it make to restrict it only to browsers? I wrote "they could, for example". I did not say that it would make sense. &gt; Second of all, any good developer knows never to trust a user agent - there is really no possible way to restrict it only to browsers. This is exactly why I wrote "that won't really stop anyone from scraping the API though". If you wan't to access the API, you probably can. But anyway, they *could* have measures against the usage of the API. But they could as well not have any. It is impossible to say without reading their code.
There is nothing about Internet Explorer on his wiki page https://en.wikipedia.org/wiki/Anders_Hejlsberg He also was the lead developer for C#
Looks great, and super easy to use. I do have some pretty significant lag on my machine. Chrome, macOS, I'm seeing sub-60fps pretty regularly. Here's a graph of the FPS drop over like 7 seconds: https://i.imgur.com/yPHRL8v.png
&gt;Websites need to be three things: secure, quick and affordable. TakeShape delivers. And also then need to do this one thing I need when I visit your site - like send a message to my friend. Can your static page do that? No? So perhaps shut the fuck up about your "the best static sites". 
downloading it now. you better not let me down pedro.
You won't regret :p
Yeah breaking up a list of promises to prevent network saturation makes sense. I‚Äôm not sure what else though. 
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, you are definitely clueless. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond. Stupid moron.
HEY MORON: **Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) Events can be "fired", and if we use that analogy - which would be unusual but at least possible - the only association between "firing something" and promises is when the promise resolves. You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
Couldn‚Äôt the same thing be achieved like: ``` // a,b,c are funcs a which return a promise [a,b,c].forEach(async p =&gt; await p().then(handle)); ```
First off, as already remarked, you are wrong here JSP (Java Server Pages) has nothing to do with Javascript. Then you need to more clear on what you want to know, because how a web application is made has very little to do with the technology used. In its core like many web applications Doodle is basically just a [CRUD](https://en.m.wikipedia.org/wiki/Create,_read,_update_and_delete) application with a non-traditional frontend which can be made with virtually any web technology. One could use JSP, however it is (in my opinion) an out-of-date technology, that misleads people to write bad code, especially when used as the only technology.
Hmm, this is probably because the canvas is getting too big in terms of resolution, in addition to a high dpi ‚Äì 2D context is just not doing well with that. Would you mind telling what kind of Mac you have and/or external display?
lol... so if we;re in argeement why are you still arguing with me?
Thanks for sharing. One typo in the app config example, the variable `appFeatureToggleConfig` is declared but `appFeatureToggleState` is used afterwards.
For me: Better tooling. Create vue app &gt; create react app since it allows for some basic configurability without fully ejecting. Single file components are awesome. You can achieve a similar effect in react with css-on-js tools like emotion but the lack of native support means lengthy full page reloads instead of hot reloads when modify the css, also additional imports, and it's better when the tool you like is baked in natively. I really prefer vuex over redux. I really don't like the massive switch statement pattern for reducers in redux and state is mutable in vuex so you don't have to deal with those really dense spread-operator packed returns that you see in the redux reducers where you have to rebuild the state object with copies of everything. I also really don't like the connect boilerplate stuff you have when hooking a component up to redux. I mildly prefer vue router to react router. Smaller gzipped size and faster performance. Vue 3 is shooting for 10kb gizipped which would be nuts and at preact levels of smallness. I also prefer vue templating over jsx, but that's already been discussed. I also prefer vue's component structure, but only marginally. Vue class based components let me use typescirpt types on component state, so that's dope. Prop types are also built in without needing additional imports. The frameworks i most enjoy working with seeeeem to be leaning vue over react community wise (firebase and the phoenix framework)
Yep, 15-inch Retina from 2016. No external.
Seriously, blueprintjs is *amazing*. Very well thought out controls, *many* variations for each. Pretty complete too. 
FYI, our new [`redux-starter-kit` package](https://github.com/reduxjs/redux-starter-kit) leverages the Immer library internally to allow much simpler immutable updates, and includes a `createReducer()` utility if you'd rather have lookup tables instead of switch statements. What specifically did you find annoying about using `connect()` and writing `mapState` functions? What other approaches would you prefer to see for accessing store data in a component, and having it re-render when that data changes? What specifically about the current API did you feel was "boilerplate" ? 
Hence, reinventing the wheel for fun.
Thats a smooth damn brush well done!
&gt; JSX was not created as an alternative to HTML, it is HTML. Erm, isn't JSX a (super-duper-amazing) templating language, first and foremost? I mean, html is static. When you need to build it on the fly dinamically, you might reach for a templating language. Ejs. Handlebars. Lit-html. JavaScript template literals. All that jazz. JSX is just an extremely enjoyable member of this family.
Visual Studio Code is just a text editor as well. 
Both Microsoft and Google are backing typescript though 
I don't see the risk. If you decide you don't want your project to be typescript anymore you just remove the types and you have javascript.
oh.
Degree is unfortunately important for some companies, and for instance the government here will pay you less of you don't have a bachelor's. I know this because my brother had to switch jobs and he struggled to find one that paid equivalent to what he was earning then. Honestly if you think you'll last a few years there and see great opportunities for personal development and skill focuss, it's a toss-up. But there's a risk it doesn't work out, and you'll be left with little experience, no job, and no degree
but why is google backing it?
Hey dude, great job on that package! Removes a serious pain point from redux. As for the connect and mapState funcs, vue does it better imo because once you initialize the app with vuex, state is accessible within each component automatically as this.$state without any need to connect things. That's one less import and one less function call in every component file. mapState to props isn't really egregious at all, but vuex is clever in using the computed properties feature of vue components as the way to map state to props. computed props are used for more than just component-state communication so using them doesn't feel like your adding boilerplate. mapStateToProps is just for redux, so it comes off as cruft. computed properties are for caching properties for optimization reasons, it's not just for accessing vuex data.
Google backing something is a pretty damned good reason to be skeptical of long term support.
is that a serious question? i don't know. google's software is only slightly better than microsoft.
&gt; all the promises will fire at once Okay, so I guess I could say that better but here it is: You don't understand what promises are and how they work. Your loop will work, but your explanation in sentence one is what I was referring to. Think about the difference between creating a promise and waiting for it. If you can `Promise.all`promise creation has already happened - for *all* of them. Which means the function that does something asynchronous was already started and is now hanging in some syscall for the async. event (or the promise has even already been resolved). Obviously, you must not call the function and *create* the promise if you want serialization. Your for loop does that because it waits. Your "fire at once" shows that somehow you think that when you have a promise nothing has happened yet, and only when you Promise.all on it does something happen. In fact though, *everything* has already happened by that point! The async. process already started, the command (I/O, whatever) already issued, or you would not have a promise from the respective function. Again different * promise chaining*, but that is not what Promise.all does. 
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, you are definitely clueless. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond. Stupid moron.
I've not much experience with canvas, but it does looks like you are "drawing" image before its declaration, have you tried moving line 20 and 21 above line 19?
I don‚Äôt have to watch this because redux manages the state of my JavaScript for me. 
tried it right now, but no result :( thank you for the answer anyways!
**Promises don't FIRE** (neither passive or active, they don't *do* anything at all, nor can they be fired) You don't understand the difference between the CODE that PRODUCES A PROMISE and the PROMISE. THE PROMISE IS **NOT** THE CODE. It's just a... promise! It's in the name. CODE, stuff that you can run (hello?) *produces* a promise. You can *run code*. Talking about "firing a promise" is STUPID as fuck top begin with. Saying, as OP did, `Promise.all` "fires a promise" is even *more stupid* because Promise.all MERELY WAITS FOR THE RESULT.
JSX is not HTML. JSX is sugarcoated javascript. The sooner people make this realization, the easier it gets. I actually really like the JSX abstraction.
How did you made the thing "real time"?
re: EDIT: damn! why haven't i noticed that for so many hours, Thank you so much!
You create a new image every frame and you're not giving it time to load. Define the image outside of the update function and keep drawing the image every frame. I'll give you a working script in a few min when I get home to my computer.
No problem, happy coding.
&gt;You can write plugins &amp;#x200B; Writing a plugin would take hours of work and would be much more expensive than the small dedicated server (for $40/mo. at max) for a self-hosted solution or Pre-rendering as a Service solution, where you being charged by usage and pre-rendering can be integrated within 15 mins.
Turns out it was the new *Visual Basic 6* after all.
Alright, I have now reduced the scaling on bigger screens. It‚Äòs a bit blurry, but that‚Äòs okay because it is / should be less laggy now. Thanks for reporting the issue!
Typescript is the best thing that has happened to JS. It drastically speeds up the development process and reduces errors.
Ahh, that was my guess . I recently used socketio in a dashboard for iot devices.
Much better, well done
Yeah, I see what you're saying. If Vue + Vuex does actually "automagically" hook all components up to the store, then yes, I agree that's less stuff you write by hand. FWIW, we're currently working on React-Redux v6, which will keep our current public API but rework the internals to use React's new `createContext()` for passing down the data to components. Longer-term, we're open to discussions for a different public API in a notional v7. If you've got suggestions, please file an issue or keep an eye out for future discussions.
Me neither but this is a comment that comes up sometimes when I post a new video... eg: &amp;#x200B; &gt;Wil Wheaton? [https://www.youtube.com/watch?v=zO9U88i2S1M&amp;lc=UgziPMrAYyT5qK1aHaF4AaABAg](https://www.youtube.com/watch?v=zO9U88i2S1M&amp;lc=UgziPMrAYyT5qK1aHaF4AaABAg)
This article was pretty nice: https://medium.com/@swizec/some-thoughts-on-vue-after-deploying-my-first-production-app-e7f3be73ce43 It doesn't go into baseless opinions but right into building stuff. You see the differences, whatever they may be.
There is that little framework called Angular...
I've had to use it at company's that work with FB, since React's license won't allow you to use React if your company also does FB work.
&gt; all the promises will fire at once Okay, so I guess I could say that better but here it is: You don't understand what promises are and how they work. Your loop will work, but your explanation in sentence one is what I was referring to. Think about the difference between creating a promise and waiting for it. If you can `Promise.all`promise creation has already happened - for *all* of them. Which means the function that does something asynchronous was already started and is now hanging in some syscall for the async. event (or the promise has even already been resolved). Obviously, you must not call the function and *create* the promise if you want serialization. Your for loop does that because it waits. Your "fire at once" shows that somehow you think that when you have a promise nothing has happened yet, and only when you Promise.all on it does something happen. In fact though, *everything* has already happened by that point! The async. process already started, the command (I/O, whatever) already issued, or you would not have a promise from the respective function. Again different * promise chaining*, but that is not what Promise.all does. 
&gt; It seems like he actually understands promises perfectly fine, No he very obviously does not (comment has been edited now!). Proof: &gt; all the promises will fire at once Promises that "fire" - and /u/mwd410 sees no problem with that, showing that one more person here does not know what promises are. &gt; very well be preferable to starting all promises at once. Yep, you are definitely clueless. Somebody who "starts promises", LOL. Please, do us all a favor and learn what promises are so that we don't have to read such utter bullshit. Just out of curiosity, how do you "start a promise"? I'm just asking for the laughs. &gt; which you're deriding And now you are full of shit. Actually READ my comment before you respond. Stupid moron.
&gt; But can't get my head around what's the big fuzz Mostly people leaving Angular very late i guess. Usage statistics often draw a different picture, though: https://twitter.com/0xca0a/status/1048228053271412736 
Will do. Thanks for your awesome work! 
This is a pretty ambitious package. How will you handle breaking changes? I'm just wondering if this might have been better as a monorepo with smaller packages that people could upgrade individually. Also what's the use case for isLowercase? Generally if I want to know if something is lowercase I would just defensively call toLowercase rather than rely on a check.
First response on stack overflow. accepted If you don't want to mess with HTML elements: var audio = new Audio('audio_file.mp3'); audio.play(); This uses the HTMLAudioElement interface, which plays audio the same way as the &lt;audio&gt; element.
Already tried it. The terminal said "Error: Audio not defined". It doesn't recognize the "Audio" command next to the ('audio_file.mp3').
If you specify types with JSDoc, you can use the typescript compiler as a typechecker on JS files, without actually producing any output. https://github.com/Microsoft/TypeScript/wiki/JsDoc-support-in-JavaScript (You'll need to set (from memory) `allowJs`, `checkJs` and `noEmit`) I've used typescript before, but I am thinking this might be the beast of both worlds. Typescript does introduce a small but noticeable amount of friction when interacting with the wider javascript ecosystem.
Well yeah, since frameworks all have to decompose down to vanilla js by the time they get to a browser. Unless it compiles to something else that every supported browser can interpret, it ends up as js (mostly es5 for legacy).
If they declared the "i" in their for loop using "var", then yes, it would log "10" ten times; however, since they declared "i" using let, the loop will work as expected printing 1-10 with a 1 second delay.
&gt; even better than redux lol who cares about redux? I'd like to know-is it better than MobX?
you need an interface to a native application that can play sound. take a look at (npm:playsound)[https://www.npmjs.com/package/play-sound]
Not quite. If you use things like decorators or enums or mixins, it's no longer simply a matter of removing the types.
Don't quit, unless you foresee that you will have a huge debt at the end. In that case it's not worth the money, imo. Consider doing a Master's as well, but only if you find one that matches your goals/interests (embedded systems might interest you). You will have more than enough time (the rest of your working life to be exact) to get work experience. Make some new friends, join a student association or some club. Explore your interests, just enjoy and make use of the opportunities that you currently have. If you can get a job right now, it will even be easier with a degree. &amp;#x200B; If you have a lot of spare time during your study, you could try getting a student job at a company. They will probably ask you to work at least 1-2 days a week, so you can show some commitment.
IMO these days a type checkers needs to do proper TypeScript type narrowing. Check out https://github.com/sindresorhus/is, for example. Lil nit is that npm recommends avoiding putting ".js" in the name of a package. It's implied that the package is javascript. I see "checkif" is still available ...
&gt; using a bit of sine and cosine Note that you can do this entirely without sine/cos, but with simple vector algebra :)
I miss vb6
Vuex that's why, it's nicer than any of the React state management crap
Depends on how you handle the change. If you never do it, obviously, you won't have any experience dealing with it, so it seems a lot scarier than it really is. And ofc if you don't pay any attention to it for long enough, the debt accumulates to very high levels, however, the problem is self caused here more often than not mainly due to neglect and mismanagement. Given an option you do not want to end up in such situation. Using outdated software is of even higher risk. And essentially equates to sitting on time bomb. Most recent ransomeware, as I recall, was targeting Windows XP. Not to mention 'dead code' which is not dead and all the other nice 'features' legacy systems provide. " How are you measuring the supposed value added there? " - it's interesting you brought it up. One thing is clear, business has no tools or competence to measure it. If they did had the necessary capabilities, they would write code themselves. Added benefit, sure, huge. Mainly it allowed to use new tools efficiently, in this specific case, it improved end user experience. Secondly, it complies with modern coding standards and practices so it's easier for new people to be productive with current code base fast, as well as helps more seasoned developers to be more efficient at building new features and integrating with new tools. Third, which is even harder to measure is motivation. People don't like dealing with old code or learning outdated systems which is business specific. It's especially obvious when you're training junior developers. This allows business to be more competitive / attractive in the job market.
I learned it. Then unlearned it. Not going back.
JSX is *not* HTML. It is more like XML than it is HTML, but in reality it is neither. It simply harkens to familiarity of familiar markup language syntaxes commonly used for defining tree-like structures. The virtual DOM is not comprised of HTML elements, it is comprised of React elements. It is entirely possible, albeit somewhat tedious, to create React apps without ever using JSX. The sole purpose ofJSX is to serve as a concise way of expressing React elements. It is up to the renderer to take this virtual DOM and translate it to the browser DOM, although that‚Äôs not even necessarily the target (such as is the case with React Native code). At no point in a typical React app does actual HTML ever even enter into the equation.
damn this is really cool
üôÑ, have my up vote.
No. Redux is actually quite hard to get typed properly in Flow. Vue is moving to TS internally. 
Idera are moving Ext JS forward. Version 6.6 was released about 4 months ago. It doesn't make a lot of sense forking the GPL version. Forking Ext JS requires keeping the GPL 3 license. Not many businesses are that interested in releasing their source code, which they would have to do when their app relies on a GPL'd library. The commercial version starts at $960/year (since Idera brought back single seat licensing), which is nothing for businesses.
Google is also backing Dart or Angular tho...üòÖüëç
You can just run the TypeScript compiler targeting ES6 and there you go. Modern JavaScript.
That's crazy, I had considered that possibility, but your English was otherwise very good (I had no idea you were a non-native speaker), so I disregarded it. Again, I apologize for not handling it better, and kudos for keeping your cool. Have some gold!
Because MooTools once did it and 10 years later people want to add `Array.prototype.smoosh` to the standard.
Can you elaborate?
there are many things I didn't account for just yet: if you want to help with a PR it'd be super welcome!
If you use decorators, enums or mixins you wrote pretty damn good code
Man its a programming language like Java, Objective-C, C#, C++, Swift... better learn a real programming language than ES shit
Right click. Inspect.
Once you get used to it you will never want to write code without types again, and especially not debug...
It's like the brush is on a dog leash. If there isn't a well established term for this delayed brush, perhaps make it a Leashed Brush with the radius described as a leash length.
Production vue company here. This is the answer. I like my things separate. 
You mean to say you don't care about redux. Your question is a bit vague, so I'll answer it simply at best. MobX is excellent for smaller scale application with small teams however if you are working on a massive project with a team of 10 or more its not recommended. MobX over Redux: short learning curve simple to use quick start less opinionated minimal boilerplate used in lightweight applications mutable data object-oriented programming smaller size &amp; few developers project can be used in bigger size projects too, when used with explicit constraints Redux over MobX: constraints testable lightweight parts opinionated state management architecture mature best practices used in complex applications immutable data functional programming bigger size &amp; several developers / teams project testability, scaleability, maintainability The real question is do you need it in your application? Hope this helps, fyi there a thread somewhere out there in reddit land with a similar question. 
* Smaller run-time * Faster rendering * Thinner API layer so you just write JS instead of learning a framework convention * Single file components makes problem solving easier To name a few. Vue was a breath of fresh air for me when I switched. It worked exactly the way I wanted. No magic and a lot less to learn. You can still use JSX and still get all of the benefits I outlined above. I personally like Vue's template syntax but the benefits compared to JSX are rather subjective so I won't bother to point them out.
Oh wow. Thanks for the gold!
Very interesting! Is this open source?
You guys are crazy. JSX FTW
I've found that the type inference is quite good, actually, minimizing some of the bloat
JSX is like HTML in JavaScript. Components are just abstracting elements into another syntax that creates elements.
thats my problem too :v i always have condition to get the last of array.. it would be make a time for me. if array had a last() method, my time will be compress
Ah but they're also the same people who made SkiFree.
Curious: in what ways have you seen it speed up the dev process? A lot of people on my team are convinced it will slow us down, and that‚Äôs the trade off we‚Äôre making for safety.
Angular will be here for a while 
isn't angular written in typescript? i don't use it personally but from what i hear, it's the tits.
XML is valid HTML, there are just certain tags the browser inherently knows what to do with, because they have user agent supplied CSS, but any tag at all could be given CSS to render any way you want.
If you strictly type your functions, you almost never have to write types in their bodies. Hell, if you strictly type your class attributes, sometimes you don't even need to type the return value of functions. Typing their parameters is obviously required, since you still want those when calling them. Also, between TS 3.0(unknowns, tuple inference) and 3.1(better tuple inference) and 3.2(to be released, strict typings for bind, apply), there is just so much you can do with advanced types. Fun fact: if a function takes a callback, and you write an anonymous or an arrow function as the parameter value, that functions parameters and return type are *also* inferred from the higher order function declaration. Provided you wrote a well typed declaration, of course.
Nice, I needed something like this and had to implement it on my own. Definitely going to take a look at it.
What browser are you using?
Think about that one time you had to debug a code that expected an object with an attributes "variable" but you wrote, in some weird godforsaken place by mistake, "{vairable: 1}" Think about that one time you had to debug a number error only to realize the variable was being cast to string somewhere in the middle of the code Think about that time you had to figure out *how* a method is supposed to be used, and the team didn't write any documentation. Are you supposed to cast your variable to a number or does the method take care of that? No wait it actually expected a string. What do you mean that callback *wasnt* optional?! Typescript makes all of these problems just *never happen*. Think about how long people take to deal with things like the above, especially on a large shared codebase. All that wasted time that simply won't happen. It's nearly impossible to measure it, but LORD I know I spent a LOT of time with shit like that. The caveat? You need to actually care about typings, and if you ever wrote any Java or C it's really not a big deal. Plus you get all the autocomplete jazz from then Typescript server, and it's sooooo gooooood
Are you running this in a browser?
If Typescript is used correctly, then Typescript is like a peer programmer except with better accuracy than a person. It speeds up development because if it thinks there is a contradiction in code somewhere, it will tell you. This means you can resolve code issues more quickly and therefore, lower the chance of bugs that appear later on.
Can you give an example? I use jsdoc and testing...I don't find the need of using types other than what I expect from the libs I write (again, jsdoc). For the rest of the fancy stuff I use babel (ESX). The only thing I would miss there are decorators I suppose? (also available for ESX)
I just meant to show two different perspectives ;)
Seriously asking, difference between text editor and ide?
You should check out Bling.js! It's the cool $selector of jQuery without everything else: [https://gist.github.com/paulirish/12fb951a8b893a454b32](https://gist.github.com/paulirish/12fb951a8b893a454b32)
It's types are so expressive. If it had a more traditional type system then it wouldn't be that great. It makes me confident that if it compiles, it probably works. The autocomplete you get in most editors is also excellent, and just not something you get with JS. I think autocomplete is one of the biggest time wins with it. I can say an object is some interface, and it tells me what fields need to go into it. No guesswork, no need to switch back to another location in code to see what those fields were called. 
Well you can debug code in VSCode if you install some plug-ins. 
React has its set of problems and Vue has its set of problems. If you are already comfortable in React, stick to React. If you think Vue has some better tradeoffs, then make a small project in Vue and find out!
Lol, you are an idiot if you think that you can sum up all of Microsoft by IE. Microsoft makes better software than 99% of silicon valley, and they have arguably the best infrastructure of any major tech company for rapid and reliable development. 
shut the fuck up you cocky moron. Microsoft sucks for way more than ie. you're an idiot if you need me to fucking spell out all the reason for you.
pills that are hard to swallow: the best software doesn't come from silicon valley and windows is for morons.
Quick every jump over to the 10.3K subs r/TypeScript sub-reddit and post a "Should You Learn JavaScript?" post.
Debugging someone else‚Äôs compiled Typescript is no fun at all. Well it‚Äôs fun if you‚Äôre in the mood to spend all night on a scavenger hunt when it would have taken 10 minutes with plain js. 
Thank you! Great idea. 
&gt;Vue was a breath of fresh air for me when I switched. It worked exactly the way I wanted. No magic and a lot less to learn. 100% agree
Dunno why you're getting downvoted. Licensing is a totally valid reason for choosing one library over the other.
I mean I have no desire to write vb6 since it doesn't accomplish modern day problems, but I miss when it did, it was such a simple and effective language and tool.
Hi, I just checked the demo. It would be great if you could: * Make the demo more visually distinctive. The background is just a blue gradient, when I used the default scrolling option (offset,100, 0, false and then "scroll!") I couldn't see any scrolling because of the small background colour differences. I'm also using a Macbook without a mouse so I don't really see the scrolling indicator on the right side of the browser window. Don't be afraid to use contrasting visual elements when producing a demo, the user does need to see that the page **is** indeed scrolling and therefore it needs to scroll through elements that actually look different. * Generally improve the look, even if it means just using some basic bootstrap for nicer buttons and padded containers. * Include the smooth scrolling. I'm actually looking for a smooth scroll plugin because I'm a Vue.js dev and I'll never ever include jQuery in a Vue.js SPA, so I could use something that makes smooth scrolling easier for me. I was very pleased to see a scrolling post and a demo and in the end, it looks like the demo doesn't demonstrate the smooth scrolling functionality. Try to include as much in the demo as you can, idk about other people but I usually prefer looking at/playing with the demo instead of reading the docs and readmes, so it would be nice if you could include this. Also great work. Wishing you a nice day.
Typescript doesn‚Äôt take that long to learn
So.. VS Code, with it's ability to debug/run code, create and manage an entire app structure through its file system, and run node or python or ruby etc apps through its integrated terminal (as well as manage version control with its built in system and easy integration with git and the like) is not just a text editor. Right?
Vue was also easier for me than react, it just clicked. You only need a handful of directives and a bit of understanding of the vue component structure and off you go. Sfcs are so helpful in getting things done quickly, and are easy to refactor. 
The thing you're referencing is less of an issue in adding prototypal methods and more of an issue in detecting your own additions. The equivalent issue happens with any polyfill library not implemented correctly (and I speak from experience because I had to Polyfill one specific object and nothing else so I was told to implement the Polyfill myself rather than use a known shim library). &gt; MooTools‚Äô flatten implementation differs from the proposed standard. However, this is not the problem! When browsers ship Array.prototype.flatten natively, MooTools overrides the native implementation. This ensures that code relying on the MooTools behavior works as intended regardless of whether native flatten is available. So far, so good! &gt; Unfortunately, something else then happens. MooTools copies over all its custom array methods to Elements.prototype (where Elements is a MooTools-specific API):... 
&gt; ly improve the look, even if it means just using some basic bootstrap for nicer buttons and padded containers. Thanks for all that feedback! :) It's true that the demo needs serious improvements. I just that I recently finished up polishing and bug-fixing mayor features, and haven't got much time to make a decent demo. It is mainly a playground for testing if it was working ok. Also could improve the defaults. The basic idea was to open up the browser console of the developer tools and test what it could do. It is a bit outdated too (the demo). A better interactive demo with docs should be in a couple of weeks. It already has smooth scrolling, just increase the duration to 1000 (1s) to see it happen. By default is 0 so you'll just see "instant" scroll. I'll be happy to deal with any more question or suggestions that you may come up with.
Oh, it's in milliseconds. I did try changing it to 10 and I was confused thinking it's not exactly working. That's a mistake on my part as ms is a common unit for us js devs and I read it wrong for some reason. Sorry for that. Anyway, I get you. I'm sure you'll make an amazing demo in no time :) I also starred your repository so I can use it later when I come home. Best of luck to you.
There are also situations such as in NW.js where there are multiple "contexts" and thus multiple Array.prototype objects. Patching one will not influence the others. Better to have a standalone function which will work on any array.
In the first case you are executing operand "+" on a string which is completely valid, as strings have the addition operations (concatenating). However, in the second case you are subtracting 5 from a string, that seems to be a valid number after whitespace is stripped. As there is no subtraction involving strings (first type) but there is one involving numbers (second type), JS tries to cast the string to a number and then executes the operation on a set of two numbers. Here, it is successful. However, if the left side was not numerical (e.g. "a", "hello world") you'd get a Not a Number (NaN) value.
\+ operator exists on both numerical and string types, so in the first example it concatenates strings after casting 5 as a string. (e.g., " -9\\n" + "5" = " -9\\n5") \- operator only works for numerical types, so it casts the first operand as numerical and sees -9. (e.g., -9 - 5 = -14)
Depending on your ability the experience might differ significantly. If you are used to frameworks holding your hand, framework specific syntax etc it may be a bit harder to get going. As most node js 'frameworks' are very lean and focus on providing tooling for routing. Think Lumen, although even thinner. However, if you are not going to write much logic it may not be an issue at all.
JS does not have strict typing and that's why the casting occurs. Another example where loose typing is visible are comparisons: try \`"-9" == -9\`. Spoiler: it returns true. Why? Because it's a loose comparison, so JS is going to cast these to one, same type. If you want to check if these two values are \_\_really\_\_ the same, use \`===\`, which also ensures that both sides are of the same type.
Good answer.
Google also backs Polymer ;)
Nope.
This is a fantastic library! Thanks for sharing.
Why are you debugging compiled output though? Just go look at the ts?
The best answer is don't care about this, the best solution is don't use this. It's because expressions like this will never be useful in real life. This is one of the "bad part" of JavaScript, if you're using tools like ESLint or TypeScript, it will stop you from doing this. 
Sorry. Switched blog. This link works, click [here](https://ankit-solanki.com/Flocking-Simulation/index.html#64)
The one that comes to mind was me trying to fix a bug in Firebase‚Äôs library, I could see where it was breaking in the console but of course their ts files looked completely different. 
Great! It feels doable! Understanding how middleware, http works. And so much less code! 
&gt; because they don't understand js as a whole Well, I don't particularly like TypeScript, and I certainly disliked CoffeeScript when it was even a thing. But then again, I think that view of yours is pretty _limiting_. For starters, the "argument" -if you can call it that given that it's merely a _guess_, a judgement you pass on other people, people you don't even know- seems rather weak. "I don't understand them so it must be because they don't understand JS". But anyway, every language -and I mean _every_ one- has limitations, shortcomings, rough places. I hope you can agree to this premise, because, obviously, it also includes JavaScript. Given this, there are various ways of overcoming those limitations. One of them is by gaining deeper understanding -deeper with regards of the knowledge itself but also deeper in the sense of having this knowledge more ingrained into your subconscious and your habits- and developing habits to overcome them. It is, certainly a valid solution. A different solution is building or using certain _tools_ that help remind you to avoid those problems, without you having to have that _deeper understanding_. That is, you mainly take advantage of _other people's_ deeper knowledge without acquiring it. An example of this _could_ be some people using linting tools or following certain "best practices" just because the _community_ or some _thought leadership_ or a senior developer in your company have already determined that those are indeed the practices to follow. Is this a valid solution? Well, one might argue it's _worse_ than actually gaining the understanding, but, in general, it "works". A person following such practices may indeed avoid many of the problems, so it is, in general, a valid solution too. Then there's the option of building or using certain _tools_ that instead of reminding you to avoid the problem, actually let you sort of _overcome_ it, or at least forget about it, or reduce the effort it requires. You can, say, build a _library_ that encapsulates that effort. Where you would have to repeat this whole code structure, you now write this shorter one that calls this particular function we already wrote and that's it. This is, much certainly, another valid solution. A similar solution, just _one_ step further_ might be, if possible, to build or use some tool that encapsulates the effort but doesn't pay a potential performance cost at runtime. That is, you might use a code generator, or some macros, or something similar that let's you express with less effort some intent that in JavaScript would take you more effort, and what it does is automatically _produce the code_ that takes effort being written. This is, also certainly, a very valid solution and many people have opted for this. This is all JSX is, for example. It is also, to a certain extent, what Babel is. And stretching the idea just a tiny little bit, it's also what Webpack or similar tools are _at the core_ -i.e. leaving aside other optimization capabilities they may provide-. Finally -though there may be others; this is getting too long already-, there's the option of using another language. Why not? I mean, a different language will have _different_ limitations, shortcomings and rough places. If they are indeed different, then you will be avoiding some of the limitations in JavaScript. It may be that this different language allows to express _some_ intentions with less effort than what you needed in JavaScript. I don't even argue that it does, just that it _may_, as _may_ all of the other mentioned solutions. So if it does, if it let's you avoid some limitation or reduces the effort to go around one such limitation, then it is indeed a valid solution. You might argue that "_you_ don't need static typing". I'm not going to get into that discussion. It's a very old discussion and hardly ever any benefit is produced by going into it. My particular position on the subject is that if _you_ "don't need static types" and it works for you, then great for you; don't use them. And if you do use them and they work for you, then _great too_. But whatever your stance on this, allow that different people may take better advantage of different tools. For a lot of people, static typing provides a tool or reasoning that helps them state some of their _intentions_ about the code they write and have a tool that checks if the reality actually coincides with their intentions. I think this is a very reasonable _kind of tool_, in general, be it about _types_ or about any other sort of intention. Finally, note two points: - I'm not invalidating _your particular experience_ in any way. I'm just saying that yours is but _one_ possible solution. It works best for you, and that is great, but that doesn't mean it has to work best for everyone. - You're making too much of a generalization. You put all these languages in the same bucket as "different flavors of js". That _is_ a dangerous generalization. Again, different languages -and no, they are not necessarily _flavours of JS_- have different capabilities, costs, limitations. It is too short-sighted to bunch them all together as one thing.
Which is why it's better in TypeScript. You don't need to specify type for any variable defined, you can not assign any type for local variables, and only assigning type for function parameters and return type. To an extend, it can also detect variable type automatically, so it's very helpful to reduce verbosity.
More than backs it, they started the project.
No. The best approach is to learn and understand it. Unless you're working in your own world, there will always be all kind of different edge cases that you will want to understand. Furthermore it's not a "bad part" of JavaScript. Implicit Type coercion is at the very core of JavaScript and part of what defines it's dynamic nature.
No. The best approach is to learn and understand it. Unless you're working in your own world, there will always be all kind of different edge cases that you will want to understand. Furthermore it's not a "bad part" of JavaScript. Implicit Type coercion is at the very core of JavaScript and part of what defines it's dynamic nature.
Apparently sites that run javascript that talks to APIs are considered static now? I feel old.
Surely `const last = arr[arr.length -1]` isn‚Äôt that hard or time consuming to write?
&gt; there will always be all kind of different edge cases that you will want to understand. For example? &gt; Furthermore it's not a "bad part" of JavaScript. Implicit Type coercion is at the very core of JavaScript and part of what defines it's dynamic nature. Type coercion is good when it's done right, but it doesn't. You know what's more important than type coercion? Readability and consistency! These kinds of expressions violate consistency. Therefore, it's the bad part.
Interesting. I did not know there was a partial type system like that... I will take a look. Types only where necessary is like my ideal situation
Both these expressions will always yield the same result, therefore they are consistent.
Implicit coercion is part of every production JavaScript program ever, use conditionals with &amp;&amp; and || ? that's implicit coercion. I agree that readability is important. That is why I use implicit coercion whenever it aids readability. Explicit coercion can clutter up your code far too easy.
&gt; smaller scale application with small teams however if you are working on a massive project with a team of 10 or more its not recommended. I'd bet /u/mwestraste would disagree with that, but whatever. It's just kind of weird of you to say vuex is better than redux and then dismiss mobx as not suitable for big projects considering the two are very similar in terms of implementation and even their API.
&gt; Implicit coercion is part of every production JavaScript program ever, use conditionals with &amp;&amp; and || ? that's implicit coercion. In production code, implicit coercion helps reduces file size. However, one does not write production code directly, but converts development code (source code to read) to production code (minified code to run) using tools like Babel and UglifyJS. &gt; I agree that readability is important. That is why I use implicit coercion whenever it aids readability. Explicit coercion can clutter up your code far too easy. What about the expressions above, would you tell me it is readable?
The alternative to implicit ToString coercion using + is to literally type String(value) every time you concat something that is not a string.
The big difference is that Redux needs pure functions/reducers. Vuex is based on mutations. So in Vuex you can just change the property of an object and you're done. In Redux you have to recreate the object including your changes and return that new object. This can get really nasty if you have a few levels of nesting in your store. I've heard about calling sub-reducers from inside other reducers and stuff like that.
&gt; No, that's not what I was referring to, I was referring to the source code of every production JavaScript program. You must be a horrible developer to think these kind of code are okay. Tell me a single popular linting rule that allow `&lt;string&gt; +/- &lt;number&gt;`. &gt; Yes that is readable, if you put in the effort to literally learn one rule. Tell me that rule in the most simplest way possible then? If the rule is convoluted, it is not readable. &gt; Giving the advice to not learn something because it seems complicated is just bad advice, sorry. How about giving advice to not use something because it is awful and not useful? How about giving advice to invest time to something that actually matters?
The main problem was that you have a semi colon in the wrong place on your first for loop. A couple of other pointers on your code... no need to use var to define i multiple times as it's not scoped that way also use substr to pick letters out of a string `var i;` `var letters = [];` `var word = "bob";` `var rword = "";` &amp;#x200B; `for (i = 0; i &lt; word.length; i++) {` `letters.push(word.substr(i,1));` `console.log(letters, i);` `};` &amp;#x200B; `for(i = 0; i &lt; word.length; i++){` `rword += letters.pop();` `console.log(rword);` `}` &amp;#x200B; `if (rword === word) {` `console.log(word + " is a palindrome.");` `} else {` `console.log(word + " is not a palindrome")` `};`
There's also `Number()` to convert a string to a number. Being implicit is confusing. Code should not be confusing.
The same. Profitable for writing/understanding code, but I prefer JS.
Thanks a lot. Feel little bit stupid that i missed that but hey at least it's something ü§∑‚Äç‚ôÇÔ∏è Thanks for your help again üëç
Good package Actually. I've been searching for like months now and didn't found this. they made a cool documentation with usage examples. Thanks for sharing it and for sure i'm gonna try it this weekend :D
I have always given things like coffeescript a wide berth with a similar sort of attitude to yours but dipped my toe into TypeScript when I started to learn Angular. I now could not recommend TS enough especially if you're a JS purist. You can take as much or a little from the transpiler as you're comfortable with so the learning curve is super gentle but the benefits only increase as you use more features.
One advantage is that it improves code completion because your IDE now knows what type of object youre dealing with and what member variables and functions it has. This is a huge boost to productivity.
[Nope](https://i.imgur.com/NMi9A8D.png). I think you meant `new String` and `new Boolean` instead of just `String` and `Boolean`.
Or for the optimal solution, for i is 0 to length/2, if chatAt(i) == chatAt(length - 1 - i) continue, else return false, return true. Both solutions are O(n) and for even the largest strings 1/2n operations isn‚Äôt going to be noticeably faster than 2n operations, but it‚Äôs the thought process that matters.
Thanks for the feedback. I may add a section on this. It's an extensive topic in itself, though.
i agree with u. but for me (who always coding with sync programming), thats so hard if i take the job with the big system and complicated system :) for simple system, that would be easy
A wild Felix appears üëã! This was a great read, thanks for sharing.
Fuck jsx
&gt; Profitable for writing/understanding code, ü§î I mean, broke reading and writing, what else is there about code that makes TS detrimental?
OOP in Java is nothing like JavaScript. You'll be doing yourself a favour if you didn't skip the basics.
What crazy release cycle is this. Are angular versions actual major versions with breaking changes? Must be a nightmare to maintain projects if it is. 
*Where Y is a function of X
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
This saved my bacon. https://youtu.be/Bv_5Zv5c-Ts I believe the full course is on Udemy. 
I'm going to frame this comment. Been using Typescript for a year on personal projects, and I've never been able to explain the benefit to co-workers like this.
That's not a healthy way to think, especially when there's few options for front end development. It's either JS or its derivatives that compile to JS. And for what it's worth, TS can fix a lot of the issues of vanilla JS, but that doesn't make JS any less of a real language.
That's not a healthy way to think, especially when there's few options for front end development. It's either JS or its derivatives that compile to JS. And for what it's worth, TS can fix a lot of the issues of vanilla JS, but that doesn't make JS any less of a real language.
Speaking as someone who's currently cleaning up the mess left by an OOP Java developer in a JavaScript codebase; DON'T SKIP THE BASICS!!!
This is an argument I've heard time and again by developers who have forgotten what HTML is. I'm one of those "separation of concerns" people that can't stand HTML in JavaScript, but I have so much respect for the Facebook team that built React for how they made HTML strongly typed - an extremely commendable feat. But saying JSX is HTML is like saying TypeScript is JavaScript.
Thanks. That's what I need for weekend. But I am afraid if 3rd party libs will break after update. 
No, it uses semver. They aim to release often with as much backwards compatibility as possible. https://angular.io/guide/releases
It's not working for me. Whenever I try typing a word, it's like it goes haywire and deletes every second letter I type, or change it into a completely different one.
Thanks. I‚Äôve always used scrollmagic.io. If you‚Äôre familiar with it could you maybe explain the benefits of your library vs theirs?
For sure but highest value doesn't mean the best. I've not used anything but Libre Office in years. I've got a Window's 10 dual booted along with my Arch install, just because my laptop came with it and it's too expensive to justify just removing it.. but I haven't logged onto it once. It's just not necessary..
&gt; JS does not have strict typing and that's why the casting occurs. That's not true at all. Strict typing and type casting (or more specifically in this case type punning) are not dependent on the strictness of the type system. Strict typing is an enforcement of the specificness of typing on the language, and a common aspect of strong typing. So the quickest counter example to your statement is Python, where I can create two arbitrary object types and implement their addition methods such that relevant casting occurs and then you'd end up with the same result. Casting occurs not because of the type system, but because it was decided upon by the specification that casting should occur, in the very specific set of steps defined in the spec. Another completely valid option would be to raise an Exception, such as TypeError (which does exist in JS) or to return some global constant showing the operation doesn't make sense. But the specification said "casting", which is why casting occurs.
Is this the final thing, or are you developing new features?
Is this the final thing, or are you developing new features?
Developer Bootcamp was totally worth it IMO. Hands down best decision I made despite its cost; 6 dedicated months of everything JavaScript (Frontend and Backend for the Full Stack bootcamp) at an incredibly rapid pace. Regular weekly assignment due dates to force you to write code, not just learn about it. On top of all the different skills I gained, I made myself a pretty fine portfolio that not only includes all of my homework, but also three independent, group-driven, and fine-tuned projects that really push creativity. Definitely a great way go from knowing nothing JavaScript to becoming an employer-ready expert in all things web development.
I *love* JavaScript and that's precisely why I prefer Vue. Allow me to explain... At the end of the day, the react-vs-vue debate usually boils down to a very simple question: do you prefer html in your JavaScript, or JavaScript in your html? IMHO, React has more layers on top of the core building blocks (html, css, and js) and tends to have a more opinionated DSL than Vue - neither of which are inherently bad or inferior. I personally prefer Vue because: 1) I feel it imposes fewer decisions on how I write and structure my code than React 2) Vue's attribute-based approach feels as natural to me as adding classes to my HTML tags. (I respect React's inversion of HTML, but imagine someone invented a language for the sole purpose of including HTML in their stylesheets - that's how I feel about JSX.) You already add ID and class tags to html so you can reference it from JavaScript, so it just feels more natural and standards-complient to use an attribute-first approach rather than inverting both HTML and CSS into your JS. 3) Vue is designed to be incrementally adoptable and play nice with the rest of the eco-system. I prefer that over having my library / framework definite how everything must be done. Having said that, I recognize those are my opinions and nothing else. Although, I swear, if someone goes off and creates a css-first framework and it actually starts to take off, I'm just going to switch over to Haskell and Elm to escape this madness.
I wrote my JavaScript books for programmers. Most of them are free to read online: http://exploringjs.com
JSX is a way of using HTML, TypeScript is more or less it‚Äôs own language, not a ‚Äúway‚Äù for using JavaScript. You can argue it both ways I think...
&gt; I like my things separate. But why? Your HTML should be minimal at best and changing JS or HTML often means you have to touch the other, too. I've never understood the separation of HTML and JS. Honestly, I loathe handlebars for that reason. It never adds anything, it's just another handicapped layer of separation for no apparent reason.
I don't think you'll find a library that does exactly what you want. It's a matter of translating the shape of your data to HTML elements. Here's a function that works for the data/markup you've posted: function createErrorDisplay(data) { const list = document.createElement('ul'); if (typeof data.length === 'undefined') { for (const key of Object.keys(data)) { const item = document.createElement('li'); item.innerText = key; item.appendChild(createErrorDisplay(data[key])); list.appendChild(item); } } else { for (const value of data) { const item = document.createElement('li'); item.innerText = value; list.appendChild(item); } } return list; } It's [on JSFiddle](https://jsfiddle.net/alexb/69krpgyd/) as well.
Impopular opinion: Vue is confused. Or convuesed. - It looks like Angular with its own specific attribute types. - It looks like Handlebars templates. - It uses JSX because React does it, but *not really*. - It looks like Polymer but it's not the web components standard. It's all over the place. React is by far the better choice I think because it's much less boilerplate to learn, and it's a sensible syntax. It's just ES6 with JSX and some minimal React specifics. That said, using Vue does remove a bunch of thinking from the equation. The flow of data is easier than in React where you have to figure out a lot of things for yourself. Not that they're complicated, but with Vue you'd probably have a project up and running faster. But for long-term commitment in projects I would always prefer React simply because it's so minimal and sensible. And React Native allows web and native teams to share a significant amount of code.
want to buy but $160 is bloody hell expensive for my asian currency.
What a jargon filled title. Yikes.
I think it‚Äôs a library that allows you to access objects without fear of TypeErrors when you access a property on a nonexistent nested object.
[lazybrush drawing](https://vgy.me/t4ia0T.png) Really nice, not only for curves but straight lines are nice too. Wish this was a drawing app I could use day to day to sketch some ideas on the go
So how do you feel about the people working and creating the code other people use? Are they just egotistical college students without a job? Obviously you are another reddit clueless bastard who couldn't code his way out of the office basement he occupies.
Appears to be a function that will return a value that's nested arbitrarily deep within an object: mb(['what', 'ever', 1])({ what: { ever: ['look what I made', 'who cares'] } }) // 'who cares' same thing as what lodash provides with `_.get()` I appreciate that the author suggests just pasting it, and I especially appreciate that it's a reduced-nonsense replacement for `idx`, which is an abuse of Babel if I ever saw one. 
Looks like Ramda's path. How does it behave with flow? Does it get angry with heterogeneous objects?
Like lodash's `_.get`?
A developer who doesn't test his code is no developer. Writing unit tests with jasmine is simple enough. It all comes down to the framework you are testing against 
It's much easier to follow logic and debug issues. Not to mention after 20 years it just feels more 'normal'. I understand the counter arguments I just don't agree. 
I don't like them personally.
Hi, Thanks for taking a look. It's not only about types checks, or 'is'. The library also includes other checkers like "all", "atLeast". For the name, "checkify" is already taken, which prevent to choose "checkif" as a name, since it's too similar. 
Hi, Thanks for taking a look. I don't consider the package as really big. And, "is.lowercase(value)" is just a kind of shortcut for "value === value.toLowercase()", like many other functions in the library. 
Lol
I'd spend a couple more bytes and make it accept vararg. 
One version before it was like that (check pr history) 
Someone can argue that it should be 0 as it is JavaScript.
Enjoy!
It's fixing a problem that is not a problem and trying to fork the natural logic language of the web for no particular good reason. Sorry, not a fan of typescript. It has an association with microsoft which immediately makes it unsuitable for anything because the source is poison.
&gt; You must be a horrible developer to think these kind of code are okay. Man this is some terrible argumentation. Dude is talking about || or &amp;&amp; being in the code not the example that the OP is asking about. Read the thread ffs. 
Would this work with dragging too? Or will it just be frustrating :thinking:
There are a few different bootcamps from many renowned schools. I chose to attend the [University of Toronto dev bootcamp](https://learn.utoronto.ca/courses-programs/coding-boot-camp) mainly because I‚Äôm an alumnus there. But consider your options by Googling ‚ÄòDev Bootcamp‚Äô as there are a lot different types to consider: - 12 and 24 week programs - Frontend only and Full Stack courses (my stack is MERN, but there are MEAN stack programs too) - Some, such as my own, provide career counselling, while others don‚Äôt - Some programs are on campus whereas others are online only
I see. I don't think dynamic paths would be a major usecase for this, but even then there's apply. Not that something stops me from making my own if I ever want to :) 
Well as the main goal is min number of bytes; using array was helping in that, too :)
Oh nice! Thanks for ELI5
TLDR: write smaller commits and pull requests. 
What is the use-case for webpack on the backend? Is there enough state on the backend make hot-reloading valueable?
I'm not using a browser. I'm using a program called "Netbeans" to program my game and running it in the terminal. I'm assuming I would use this is I were coding online or in a browser. If not, I'll check it out.
I would say learn the basics first and build your way up. What's more important than learning a new framework is the ability to learn any framework, quickly. Study the concepts that they all use. Virtual dom, self contained and reuseable components etc.
Are you the author? This example: async getPosts({commit}) { await client.getEntries({ content_type: 'blogPost' }).then((response) =&gt; { if (response.items.length &gt; 0) { commit('setPosts', response.items) } }).catch(console.error) } is a strange mishmash of await and .then()/.catch().
This Pedro also recommends VS Code.
The one that you need to do whatever task you're about to perform. The problem with JS frameworks is that there's a tonne of them, and by the time you've learnt one, it'll be obsolete (or superseded by the next version)
The GIT policy I've set for my team is this. You can do anything you need to do with these commands. Stick with that and you won't trash your repos. &amp;#x200B; These are the ONLY commands you are allowed to use. Use of any other command or command option is a VERY serious infraction (I'll fire you). &amp;#x200B; pull pull origin add commit push push origin checkout checkout -b merge diff difftool merge mergetool tag &amp;#x200B; You will tag branches you are merging into with your name and date of merge before you merge. I will do all forking and I will create all new projects. I will delete all branches that need to be deleted. No exceptions. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
No, I am not the author. I liked the article hence I shared.
What a stupid Neanderthal we have here. And even if I couldn‚Äôt code well enough to get out of whatever backalley Wordpress design shop you have, I‚Äôm still making handsome pay in a framework-driven webdev world. 
Why did you post an article that's not even close to being finished?
[I code-golf with performance rather than size](https://jsperf.com/mb). 
I really liked the way you've written the code! It was very clean, consistent and focused.
Do one small thing to make a greater impact: **Not using medium**
It‚Äôs interesting. Successfull inline the slowest while the failing inline is the fastest. (IOS Safari, latest)
&gt; A lot of the chaos came down to one core problem ‚Äî the npm ecosystem. By "the npm ecosystem", do you mean sub-par project management? How can you start building microservices without even defining a standardised approach to logging?
JavaScript, you can use w3schools as a beginner and while moving to next steps use youtube channel fun fun functions.
Thanks :) explanation looks correct (for the current version, it started from a recursive function. See pr history)
Yeah, I noticed that safari was an outlier here. I'll bet if I rejiggered it with asm.js semantics, that'd go away.
Still developing, so if you have any recommendations for features I would love to hear them
My code for it isnt, but I more or less used packages built by other people and strung them together with a little tweeking. I used react ace editor for the actual editor and then socket.io for the real-time part. If you would like to check out the code, let me know and I can throw it into a GitHub repo for you. 
I haven't used scrollmagic.io. As I could see it's for interacting with the page when the user (or something else) scrolls, mostly to perform css animations. [scroll-utility](https://github.com/LeDDGroup/scroll-utility) is for scrolling and centering elements, maybe I miss it but couldn't find it in the scrollmagic docs 
Good article, and if you re-use your library 10+ times and it fits in all 10 cases nicely, then I think you successfully abstracted for your use case, which is awesome! For me, working on my own project, your library corners me into using your architecture. I NEED to have an abort controller, a cancel state, a loading state, those NEED to be with an api state. If I plan on having all of those things, in the shape you provided, then great! However I won't. I'm going to start with: store.dispatch(async dispatch =&gt; dispatch(loadModels(await getModels()))); my fetching models action is done. No library, no additional boiler plate, setup, or anything. Does every one of your fetches need canceling? Do they all need to maintain a loading state? Shouldn't most of them be too fast to need one? Have you considered that some people may want to combine abort and cancel into one action to simplify both the DX and UX? You don't have the answer for everyones architecture, no one does. So there is a very good reason for some people to not use your architecture, which is forced through your library. For your use case though... it's probably awesome and you should keep using it.
For api's that just fetch some content based on simple authentication it's sure a breeze. That being said, MongoDB has some severe drawbacks, namely lack of transactions. So it's impossible to ensure Acid commits to DB. This may not be a problem if you are updating photos, articles and etc, but starts getting risky when working with crucial data like monetary transactions. And while there are few js solutions for sql it's really clunky put aside simple operations. Another important thing to keep in mind that more complex authentication can get messy. For example passport js isnt very good at providing impersonate feature. Although dont take my word for it. It may have improved alot. 
Second this. It takes time to adjust one's mindset.
Shrug, I see people using experimental stuff w/ babel all the time at my company even though we specifically told them it's not something we'll support (I'm on the team that works on modernizing/standardizing the stack). Some tools even suggest decorators as idiomatic usage, e.g. mobx, angular. Also, the ES6 output isn't always that clean. Here's the output of an enum w/ `tsc foo.ts --target es6`: // foo.ts enum Foo { Hello = 1, Hi = 2, } console.log(Foo.Hello) // foo.js var Foo; (function (Foo) { Foo[Foo["Hello"] = 1] = "Hello"; Foo[Foo["Hi"] = 2] = "Hi"; })(Foo || (Foo = {})); console.log(Foo.Hello); 
why not: function isPalindrome(str) { return str === str.split('').reverse().join(''); }
Shrug, I've used TS, Flow, and even Java, C#, C and D (and Actionscript, which had optional types, and PHP, which kinda has them but not really). Types are good for some types of work and workflows, but not always. For example, if you're in a team that is constantly getting pressured to jump into development stage without proper due diligence in design stage, types can ossify bad design decisions. 
&gt; I NEED to have an abort controller, a cancel state, a loading state, those NEED to be with an api state. Not necessarily. These things are passed to your redux reducer as properties of the action, but you are absolutely free to ignore them and leave them out of your global state. It provides you the option to use them if you want, but they are not required. You do not have to save a loading state either, if you believe your request to be fast. This package does not create your reducer or global state. It merely automates the dispatch of _actions_, with which you are free to harness or ignore.
Hi /u/revnext2, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
Hi /u/Garywil, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/abhi901abhi, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/IdkInitiator, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
I love the fact that someone figured out how to put bare minimum styles on one of the most basic React Native component, wrapped it up and put it on github, created a little snazzy graphic to glorify the title, and then took the time create an entire tutorial and even post it on reddit.
Hi /u/secretNinjaCoder, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I guess you could see a use case where you wanted to distribute your server package and have it be able to run on multiple versions of node without worrying about the transpilation.
We did (see pr history). But then switched to map to shave off that 1 byte
You may have better luck looking into xml libraries instead of html
Thank you!!
For example?
Sourcemaps exist for a reason. 
&gt;async getPosts({commit}) { const response = await client.getEntries({ content\_type: 'blogPost' }) if (response.items.length &gt; 0) { commit('setPosts', response.items) } } fixed the code. You could catch some errors but reddit is a pain to work with.
&gt; I appreciate that the author suggests just pasting it I'm very glad that the author didn't publish this as an npm package
Thanks! :) It also helped myself to understand the math better. The first iteration was a blob of calculations and I didn‚Äòt really understand how and why it worked. Splitting it up in parts helped a lot.
This tutorial is amazing! Thanks for the write up :D
This is super cool. I had been breaking my head how module bundling under the hood works. This really helps a lot...
When compared to Angular, yeah. But if we take something like React or React like libs (inferno for example) what's to learn there? For conventions ESlint is all you need and it's not technology / tool specific. As for magic, Vue seems to employ a lot of it, hence my suspicion. 
I'm learning vueJS, this was my last project [https://github.com/GLuchtenberg/mercadao-frontend](https://github.com/GLuchtenberg/mercadao-frontend)
Mutable global state sounds like a hazard and lazy practice at first glance. However, I need to dig a bit deeper. By 'React state management crap' you mean Context API?
Yeah in Semver the major releases are for breaking changes. Sounds like a right pain. From semver.org Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.
Impersonate as in an admin logging as someone? I'm still in the early phases of my api so a lot to discover I guess. Do you use any boilerplate projects that are well coded out of the box?
No worries. The reason I mention size is because at work I've contributed to a package that just does device and browser detection. After a couple of years of weird edge cases it's pretty big. Even things like 'isTablet' get complicated the more devices you have to support. I'm just scaling up in my head but maybe that won't be an issue.
But you don't need webpack for that insomuch as babel unless you want to bundle your assets. I'm not sure I see the need for webpack instead of just using babel's cli with a watch arg.
I don't share the experience of 'easier debugging'. I dread the days when I have to output state of the template / component via interpolation and hot reload webpack, rather than using browser dev tool capabilities, seeing my components in mark up syntax as well as state allowing me remake each and every instance step by step dynamically and how it corresponds with markup.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split
Sure why not?
mmmmmmmmmmyoure right
Then why ask a question that you can answer yourself. 
I never said it was the best. It is better than 99% of tech companies though. No other tech company has consistently, over the years, been able to create reliable and good software like Microsoft has while developing as much software as Microsoft has. You can hate Microsoft for making some bad decisions, but for as long as history as Microsoft has, you are bound to make mistakes. 
Naw, I just see so many people who clearly have no understanding of vanilla js shit all over it. Vanilla JS is more than enough to write good reliable code, quickly. 
To troll? To educate others? You choose.
&gt; For example, if you're in a team that is constantly getting pressured to jump into development stage without proper due diligence in design stage, types can ossify bad design decisions. I don't know what the language features can do about the fact that a team isn't able to make good design decisions, but I'm fairly sure that lack of typing isn't going to make the situation better. At least if you have types, there's some indication of what the shape of things are supposed to be. The fact that the shape itself is poorly thought out is another issue - *at least you have something to mold*. Poorly thought out dynamic code, especially if there aren't great comments (which why would their be in this "rushed dev team scenario") is basically write-only, throw out the code and start again since it's impossible to understand.
No, thanks. It was great chatting though. 
Ahh. Gotcha. Fully misunderstood. Thanks. 
What strings do you want to dump?
Anyone know what the pricing on this would be?
And make sure those small commits/pull requests are focused and only do one thing. 
Probably using a regex to make the space optional and you‚Äôre g2g
&gt; I see many problems in that code Buddy, I'm probably the hackiest developer you'll ever have the displeasure of critiquing. I've got a BA in English. You're looking at, like, eight months of experience.
\&gt; I'm very glad that the author didn't publish this as an npm package Someone really requested this.
Any string that gets set or "exists" through the entire execution of the script.
Why would you need a loader for that?
Do you mean any variable that gets assigned a string value?
I rather dine on my own vomit than work with ExtJS
So far updates have been dead simple. Two things I can remember having to update were: `OpaqueToken` changing to `InjectorToken` where `InjectorToken` takes a generic that `OpaqueToken` didn't. A find and replace `OpaqueToken` with `InjectorToken&lt;any&gt;` immediately made everything work and then when I had the time I went back and changed `any` to the correct type and gained some type safety. Another example was when `template` was removed from the html proposals so Angular defined it's own `ng-template` element that works exactly the same. A find and replace immediately fixed all of those instances. The animations were moved out of the common module into their own module. This only requires updating the imports from `'@angular/common'` to `'@angular/animations'` so not a huge deal. Rxjs changes from v4 to v5 were slightly more work as they changed to the pipe method and moved the imports around but rxjs released a tool that fixed the import statements for you. I've heard some people say they had to do more because it didn't work 100% for them but for my own experience it was manageable although not completely negligible. The end result was a good reduction in bundle size though so I'm not complaining too much. Recently the cli's `ng update` command has gotten a lot better to as one of the Angular teams' focuses so the upgrade from 5 to 6 and 6 to 7 was even easier by just running that command. It's not quite perfect but it's getting there. Between reading the patch notes and rerunning tests it has taken me less than a day to upgrade each time; usually somewhere in the neighborhood of 2 hours that includes test running time and time spent reading. Not 2 hours of actual work from me. I've never found it to be a huge deal and it's been getting easier and easier. That's my experience anyway. And it's not bad planning because it's literally [spelled out](https://angular.io/guide/releases). It would be bad planning if these were unexpected releases. Also, as that page says, all changes are deprecated through at least 1 full release cycle so you have 6 months - 1 year to do the upgrade. The only major point I would suggest is don't upgrade immediately when a new major version is released. Give it a week or two at least to see if any show stopping bugs pop up, or even better wait for the first minor patch after the major ones to roll out to production. But that's a basic strategy I'd suggest for all software not Angular specific.
The browser does not have a validator, on purpose, and they don't get upset about arbitrary tag names, also on purpose. But, I agree it is off the topic.
It sounds like you are conflating ‚Äúvalid HTML‚Äù with ‚Äúanything a browser can render‚Äù, which are two vastly different things.
As someone mentioned, you could mix and match certain filetypes with different loaders for whatever reason. I guess it could be potentially used for SSR. I'm firmly against compiling/transpiling server side code at all, but it depends on the use case.
That sounds awesome. The rapid major release cycle always put me off angular but maybe I‚Äôll give it another look. 
Alternatively, Why pidgeonholing yourself into one anything, frameworks, languages, design patterns, methodologies, anything, in software engineering is a horrific idea. 
This is gangsta shit
Vanilla JS is a terrible term. At the end of the day you're using some APIs, whether DOM, or Math, window, or built in node modules and inevitably modules you download from npm, the latter being the only thing that makes something "not vanilla" (which is why that term is stupid). Your brother is right. At *some* point you will need to learn **a** framework, because eventually you'll need to learn how to use any framework, typically the one already being used by your company. In any case, making server calls in "vanilla" JS, is super easy now because of `fetch`. ``` fetch(url) .then(response =&gt; response.json()) .then(doSomethingWithTheData) ``` Huzzuh! You're done. &gt; the way it‚Äôs done in the real world Code is written in thousands of different ways. Your best bet is to spend some time learn stuff that's popular today and is gaining traction, so like.. React. It's not that hard and there are so many good resources to get you started and keep you going. good luck yo
Hi /u/fuckredditagain2, please refrain from personal attacks. Thanks.
https://noflojs.org/documentation/embedding/ might be an option. diagram-js could be an option. bpmn-js could be an option. 
My point is that there is no such thing as "plain" JS. You either use something well made that saves you a shitload of time, or you write a much crappier version of it yourself that doesn't scale, has a bad api and terrible performance. No professional software is written without using open source tools.
Hi /u/pyntoch, please refrain from personal attacks. Thanks.
Fair enough. I just meant without totally relying on a framework. I realize there‚Äôs things I don‚Äôt want to do especially on my own as a developer since things have been done before. I hope my clarification makes sense.
I like it, I'm learning NodeJs/Express and Mongo, coming from a Symfony/PHP environment so this is a great resource to look at to see how to get things started. Good work!!!
Hi /u/pamblam0, please refrain from personal attacks. Thanks.
[This article](https://techcrunch.com/2018/10/16/github-launches-actions-its-workflow-automation-tool/) claims it‚Äôs available to all repos, so no cost for actions, just however much the plan for your repos is (down to free for public repos). Github‚Äôs blog page says it‚Äôs on the Developer plan (as well as the other two) so even if TechCrunch is mistaken‚Äîand I doubt they are, it‚Äôd make sense to be free for open repos‚Äîno more than $7/mo along with all the other Dev plan perks. 
I think you're confused about what a framework is. The only thing React does is make it dead simple to update the DOM. So if you ever plan on actually displaying anything then use React or some other DOM "framework" like vue. You can do everything and anything without "relying" on a framework. You **use** frameworks to help you do stuff that you, of course, could do otherwise but have already been done for you.
Again thanks. I‚Äôm not entirely up on some terms, or phrases. Thanks for the clarification.
Proxy every single object you create
&gt;I like it, I'm learning NodeJs/Express and Mongo, coming from a Symfony/PHP environment so this is a great resource to look at to see how to get things started. thanks, hope it helps you
&gt;Move the login/register code out of the routes and into dedicated controllers so you have proper seperation of concerns. Developers will end up having to do this, so it would be nice if it was already taken care of. This! This mention of Dedicated Controllers peaked my interest, now this feels more like Symfony (what I'm used to), thanks for the tip on the controllers!
Web gangsta üòë
Same from India
Minor nit: why don‚Äôt you use a stack to track the parens? I get that it‚Äôs not necessary but it seems more elegant to me. Or maybe that‚Äôs just the canonical solution and I‚Äôm being close minded. 
You don't need loader... you're running on the server, you have access to the file system. 
Heap contents are not exposed to browser scripts. Strings can be tracked using getters, but they only applies to object properties. String values in variables on the other hand, can not be tracked.
For what it's worth it still feels like the same framework. They haven't touch the major parts pretty much at all since release: how you define a component hasn't changed, defining a service hasn't changed and they added a small feature to make it easier but the old method is still 100% supported, not deprecated, so nothing *has* to change, routes are still described the same, etc. The vast majority of **changes** have either been very simple as I described above or have been adding new features that don't impact previously written code but might make further development easier. From 5 to 6 and now 7 nothing has been really changing from the existing feature set; it's just been additions. They haven't even done any more shuffling of imports since 5. At this point I would say it's pretty solidified. 
Thanks! I learned something from your answer.
Not necessarily. If you're writing in a statically typed language, you often get type safety at the cost of incurring some overhead. It's scarily common that someone will just add to an immense if-else monstrosity in typed code because they can't be bothered to figure out how to refactor a `foo(a: Bar)` to a `foo&lt;T&gt;(a: T)` without breaking the other 7 interdependent function calls. Consider also that many scenarios that are difficult to express in various type systems are trivial to express in dynamic code. In many type systems it's still impossible to express things like `compose(...fns)` without doing silly things like `A&lt;B&gt;|A&lt;B,C&gt;|A&lt;B,C,D&gt;|...`. Also, static typed languages typically have slower dev cycles (due to compilation), so it often can be a comparison between a person spending time "in the zone" w/ refactoring vs a person enacting https://xkcd.com/303/ every 5 minutes. To be fair, I suppose since most people these days use some variation of webpack/babel, this is somewhat moot in the context of JS. Note that I'm not against typed languages at all. It's just somewhat of an amusing recent phenomenon that people go gaga over static typing, whereas it used to be literally the opposite a little over a decade ago when Rails et al became the cool kid in town.
Yes, but the data size is greater then the number of characters that can be encoded in a QR code.
GitLab had been doing it forever and is free and open source
I was wondering if this was the same thing as the features get lab offers. Very interesting.
huh?
vanilla is what everyone calls it. dont know what this guy is on about, but vanilla js (or vanilla anything) is a common term in the industry to mean very basic / plain / simple.
The whole premise feels wrong as if the problem was phrased to match the solution. "Only close what is open; all must be closed at the end" feels more natural than having to list and treat all the four cases. As such, the first solution is the best. In general, an overall rule is better than having to identify all possible cases. Nested different markers ([{&lt; would be better described by a general statement than listing all possible cases, ie all permutations of ()[]{}; ([]){}; ([]{})... I am reaching pretty much the exact oposite conclusion of the article.
&gt;My question is, would I ever use nothing but pure vanilla JS to deal with server calls and things like that?It seems like nowhere teaches that sort of thing that I‚Äôve found. probably not, unless you were using it under very specific conditions. are you talking about in the context of a professional job? you use frameworks on a team because frameworks provide a shared language and conventions and they take care of boilerplate that you don't want to deal with every time you do something common (like make a new page) are you talking about something personal? have a ball baby. make sure that the people visiting your site have browsers that can use your tech. that's the main reason people use libraries jquery or axios or the fetch api to make requests - it handles backwards compatibility and all the nasty bits of requests and headers and responses and errors for you. once you start making more than a couple of very simple requests, it starts getting hard to keep things organized and respond to all the situations that might arise without a library. since your goal is a job, you'll definitely want to become familiar with a framework. you need to be able to demonstrate to the people about to hire you that you understand what frameworks are, why you use them, and how to use at least one to accomplish things. react is a very marketable skill these days - it's not a framework, it's more a front end library. i'd also suggest you take a look at popular C# frameworks.
He was asking about GitHub.
I am a little confused by the difference between a library and a framework. Mind explaining me the difference? For instance I know that .Net is a library, but Django is a framework, and have no idea what makes one, and what makes the other. 
React is now MIT licensed. So it is no longer a concern.
What if you flashed a sequence of QR codes? You could encode some binary protocol in base64 and then again into a QR code and just keep flashing them until you transmit the entire message.
Good to know. I didn't work at that company before that. 
The common sorta cheap answer is that "your code calls a library, a framework calls your code". A lot of people will say that React is just a "library" because it primarily handles "just the view" aspects of your UI, instead of including things like an HTTP client, dependency injection, extra data management, etc. I'd say it's reasonable to call React a "framework", because A) React is pretty complex under the hood, B) React calls all of your component methods automatically once you start it up, and C) The way React is most commonly used is roughly equivalent to how larger frameworks like Angular are also used. But, I can also see the point that React is a lot smaller in scope than something like Angular as well.
That makes sense . Thanks.
I read this as ‚Äúzero-coding‚Äù and I was like damn, that really is about as minimalist as you can get
Hard to tell if your Reddit syntax itself is correct, but remember that your first const is not Json itself, but instead an object. See [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) that the Json is a string which is then parsed to an js object. You're trying to *parse* a type that is already an object. 
Awesome. Thank you so much! I just didn't realize that I had to make the JSON a string; looking at .json files, they are not wrapped as a string, but that makes sense. Thank you!
Awesome. Thank you so much! I just didn't realize that I had to make the JSON a string; looking at .json files, they are not wrapped as a string, but that makes sense. Thank you!
üòØ 20$
Not if your hourly rate is more than $120
You can use [Array.prototype.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) and toss in a compare function. Also: r/learnjavascript
I think you misread the title, it's about github. 
&gt;I'm very glad that the author didn't publish this as an npm package Why? Wouldn't impact you at all if they did
You seem to be running your JavaScript in a barebones and otherwise unspecified JavaScript environment. Nobody can guess what API s are available to you unless you tell us. The simplest solution would be to start using a browser instead in which case there are standardized and well-documented ways to play audio.
Get elements from the page using `document.getElementById(id)` and access their values using `element.value`
this is my html atm, &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;52DA session 5&lt;/title&gt; &lt;meta charset="utf-8" /&gt; &lt;link href="[https://fonts.googleapis.com/css?family=Quicksand](https://fonts.googleapis.com/css?family=Quicksand)" rel="stylesheet" /&gt; &lt;link rel="stylesheet" type="text/css" href="../css/employee\_styles.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;header&gt; &lt;h1 id="heading" class="blueTxt"&gt;Employee Records&lt;/h1&gt; &lt;/header&gt; &lt;div class="left"&gt; &lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;&lt;h2&gt;Employee Details Entry&lt;/h2&gt;&lt;/legend&gt; &lt;p class=&gt;&lt;label&gt;Name: &lt;input class="text" type="text" id="name" /&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Age: &lt;input class="text" type="text" id="age" /&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Position: &lt;input class="text" type="text" id="position" /&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;Details: &lt;textarea type="text" id="details" maxlength="114" &gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt; &lt;input class="button" type="button" id="addRecord" onclick="" value="Add Record"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;div class="sort"&gt; &lt;h3&gt;Sort&lt;/h3&gt; &lt;button class="button" id="sortByName"&gt;By Name&lt;/button&gt; &lt;button class="button" id="sortByAge"&gt;By Age&lt;/button&gt; &lt;br/&gt;&lt;button class="button" id="reset"&gt;Reset Details&lt;/button&gt; &lt;br /&gt;&lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;section&gt; &lt;div id="employeeRecords"&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;script src="../js/employee\_script.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; and this is my Javascript var employees = \[\]; &amp;#x200B; &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; function Person(name, age, pos, dtls, img){ this.fullName = name; this.employeeAge = age; this.position = pos; this.details = dtls; this.avatarSrc = img; this.createProfile = function(){ var profile = document.createElement("div"); profile.className = "profileStyle"; var avatar = document.createElement("img"); avatar.src = this.avatarSrc; avatar.alt = this.fullName(); profile.appendChild(avatar); var profileTxt = document.createElement("p"); profileTxt.innerHTML = "&lt;b&gt;" + this.fullName() + "&lt;/b&gt;&lt;br /&gt;" + this.age + "&lt;/b&gt;&lt;br /&gt;" + this.pos + "&lt;/b&gt;&lt;br /&gt;" + this.dtls; profile.appendChild(profileTxt); return profile; } employees.push(this); } &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; for(var i=0; i &lt; staff.length; i++){ document.getElementById("staff\_list").appendChild(staff\[i\].createProfile()); &amp;#x200B; } &amp;#x200B; &amp;#x200B; //----------------------------------------------------------------------------------------------------------- &amp;#x200B; &amp;#x200B; &amp;#x200B; function compareNames(a, b){ var nameA = //TODO - needs to refer to the employee name var nameB = //TODO - needs to refer to the employee name var result = 0; if (nameA &lt; nameB){ result = -1; } else if(nameA &gt; nameB){ result = 1; } return result; } &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; function sortName(){ } &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; function sortAge(){ } &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; &amp;#x200B; function addRecord(){ &amp;#x200B; &amp;#x200B; } &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; &amp;#x200B; function writeRecords(){ &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; &amp;#x200B; &amp;#x200B; function resetArray(){ } &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; //-------------------------------------------------------------------------------------------------------------- &amp;#x200B; &amp;#x200B; &amp;#x200B; function arrayButtons(){ } &amp;#x200B;
Nice, thank you for the link. :)
if youre hourly rate is $120 doing this type of coding then good on you
Uh no shithead
The point of learning is to learn. If you can‚Äôt do this on your own you should fail. Spend that $$20 on more JS books and read them. Try actually doing your work. 
what lol
That‚Äôs because those files are already parsed, they‚Äôre readable json/JavaScript objects
Sadly I have to disappoint you... In the [Documentation](https://developer.github.com/actions/creating-workflows/creating-a-new-workflow/#hello-world-workflow-example) it clearly states: &gt;You can only create workflows in private repositories. I think this is due to the probability of a big amounts of events being triggered since it might be a public repository which is accepting PRs. I may have completely misunderstood how Workflow and Actions work but I believe, that you can create a Workflow, which contains multiple actions. So if that is true, no Actions for public Repos. But I'll gladly remind you of the [GitHub Education](https://education.github.com/) program, where you can apply to get unlimited private repositories and tons of other free benefits.
Is [this](https://developer.github.com/actions/creating-workflows/triggering-a-repositorydispatch-webhook/) maybe helpful?
I seen Tyler McGinnis videos, very interested stuff. &gt; which one was better Nobody know what's better for you. Just try both, I'm sure you can find parts of each course for free.
[This article](https://help.github.com/articles/creating-a-workflow-with-github-actions/) says that‚Äôs true during the limited public beta. Doesn‚Äôt say it isn‚Äôt true afterwards too, but interesting that they‚Äôd put the modifier there if they weren‚Äôt at least thinking about opening it up to public repos. I hope they don‚Äôt limit it strictly to private‚Äîopen source projects really stand to benefit from this as much as or more than corporate accounts that already have plenty of resources to do this themselves. I have no idea how many private small/single dev accounts there are in the middle of those that would benefit, but that seems like a limited audience. I think public repos of paid/education accounts, at least, should have it subject to whatever resource limitations they‚Äôd otherwise enforce for private repos. 
Yes. Thanks.
That is true and they must have something planned. Let's hope, that they manage to find a solution to the problem, since, like you said, it would be very beneficial to all sorts of public repos.
What question? :)
Python ofc XD
Programming subs these days: Microservices are over engineered bullshit....oooh GitHub Actions
&gt;1. () is balanced. 2. (), followed by a balanced string, is balanced 3. ( Followed by a balanced string, followed by ), is balanced 4. (, followed by a balanced string, followed by ), followed by a balanced string, is balanced. Seems a bit redundant and complicated. Why not &gt; 1. the empty string is balanced 2. `( `Followed by a balanced string followed by `)` is balanced 3. A balanced string followed by another balanced string is balanced
Free if you use any of the azure services :p I think they can keep it free with monthly minutes. 
&gt; Create a const, myJSON = { "myJSON": "This is valid JSON." } That's not JSON, that's an object. JSON is a text format - when you don't have a string it's not JSON to begin with.
Yes but their competitor gitlab has had CI features since forever now.
`this.run.bind(this);` does not bind in place but returns a **new** function which is bound to `this`. The solution: Delete above line and replace `this.runner = new A(this.run);` with `this.runner = new A(this.run.bind(this))`.
'bind' will return a method so we have to assign it &amp;#x200B; `this.run=this.run.bind(this).....` &amp;#x200B; I guess you are trying to increment 'variable' in which case you need to explicitly state that: `run(){console.log('Running', this.variable);this.variable++}` &amp;#x200B;
JS solves more problems easier pff. Npm install it, solved.
[Why no Livescript?](https://youtu.be/4XXgcZhYVeg) (just check the code samples)
Inside of the app you don't need to bother with SEO, and it's so much different from the web.
Python has the easiest syntax. That being said it doesn't matter, you're not running it, so might as well use some form pseudocode, it's how the candidates solves the problem that matters.
NaN
Very cool but why is this on CSS-tricks?
I made a Twitter bot! I made a thing in p5.js that [generates pictures of landscapes](https://ajrussellaudio.github.io/wyoming/) that look a bit like the game Firewatch, and put it on GitHub Pages. Then I made a bot that visits the page with Puppeteer and takes a screenshot of the canvas element, then tweets that screenshot with Twit. Then I put it on Heroku with a cron job so that hopefully it just runs forever, tweeting every hour at XX:30. This is my first bot. I never fancied making a bot that just tweeted out Markov-generated phrases, those never really interested me. I had to wait until I had something cool to show off. So this was a lot of moving parts that I managed to get working together. I'm pretty proud. Best part is, I should be able to carry on working on the visuals without the bot caring too much. Next steps for that is to add clouds to the sky, then I'll start thinking about animation; moving the clouds, wobbling the trees with the wind, maybe some parallax scrolling effect that responds to the mouse... 
Send me a link plz
Oops! https://twitter.com/WyWilderness
Make sure you return any promises generated in map functions. Don't use map functions just for looping, use `forEach` instead. Use the chrome debug tools to set break points and inspect variables. 
Here's a webGL2 ray traced visualization of general quadric surfaces and their intersections. The Algebra used is called Quadric Conformal Geometric Algebra, and lives in a 32768 dimensional vector space. All math is done with [ganja.js](https://github.com/enkimute/ganja.js) and the rendering is done with its new OPNS visualizer. &amp;#x200B; It looks really cool and trippy - probably wont work smooth on a phone : &amp;#x200B; [https://beta.observablehq.com/@enkimute/quadric-conformal-geometric-algebra](https://beta.observablehq.com/@enkimute/quadric-conformal-geometric-algebra) &amp;#x200B; &amp;#x200B;
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
Sure, we could start from the premise that the empty string is balanced. And we could go to your three patterns, or if we decide to use zeroOrMore, we end up with a different set of patterns. It all depends on the problem as given. As in real life, sometimes the requirements we have are particularly convenient, sometimes not. Sometimes we have incomplete requirements and can choose how to interpret a missing case, sometimes we can‚Äôt. If what youkre saying is that a different interpretation of an unstated requirement leads to a different set of patterns, but that solving the problem with patterns still leads to code that communicates the shape of the requirements as we understand them, then... I‚Äôd say we both agree with the premise of the post.
There was a tweet from the Github team that they will open up actions up to public repos once Actions comes out of beta but I am not sure if they‚Äôll make it available for all accounts or just paid accounts. We will have to see.
fun fun function, academind, ... theres tons. why not all of them?
In the language of Internet "delet dis".
addDecorator(&lt;React.Fragment&gt;&lt;GlobalStyle /&gt;&lt;/React.Fragment&gt;)
Just realized that I wasn't returning the promises out of the map function in the second Promises.all. Thanks. As promised, I'm a crappy, hacky dev.
p.s. I want to call this question out as particularly interesting. It could be an essay unto itself! The idea that ‚Äúchoosing the way we interpret requirements, especially around a base or degenerate case leads to considerably more elegant solutions‚Äù is a major part of mathematics. It deserves more attention when discussing all kinds of programming problems, but it is especially interesting for problems involving recursion or corecursion.
&gt; I‚Äôd say we both agree with the premise of the post. Yes we do and I like the article in general. Sorry if I'm being needlessly argumentative and nitpicky! If you don't want to match empty strings it's easy enough to write a function like const nonEmptyBalanced = (input) =&gt; input !== '' &amp;&amp; balanced(input) Even if it can be a bit tricky to do it just using string matching as a tool. My rules are imho better because they are fewer and more exstensible, since adding a new type of parenthesis only requires adding one more rule as only rule 2 talks about parenthesis instead of all four. I guess the point of the article is to teach how to use a programming pattern, not teach how to build elegant CFGs so it's not actually important at the end of the day.
Dont know. I‚Äôve just started to use transactions recently when we upgraded mongo (and I really don‚Äôt see the use of nested ones in our api. If some fail, its better to just abort everything)
Try looking in the `node_modules` directory of a medium-sized project. You'll find tons of packages with only one function and most of them are duplicates with functions that should have been in a standard library. And imagine finding a package with 38 bytes of JS. And then imagine finding 20 of these packages which do the exact same thing by different authors that have created an NPM package instead of contributing to the original one.
Yet most don't test and still earn money.
Using chrome debug tools, you could catch this easily as each element in the array would be `undefined` without the mapping function returning a value.
Created a small compiler, which transforms normal TypeScript classes into reusable Redux or React Context API models https://www.npmjs.com/package/ts2redux
great work. Nice..
Nice project. I do enjoy seeing generative art :)
Now that's an idea! Really like this one.
And if i ignore these things, then why am i importing the library?
To automate the fetch request and dispatch of the actions that you do want to use.
Hi /u/jaxuge, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I wrote some code to export your YouTube lists as JSON onto your clipboard. Open any playlist, watch later, history, liked, etc. and scroll the page to load as many items in your list then open your developer console and paste &amp; run this code. Your data will be stored on the clipboard. copy($$('ytd-playlist-video-renderer, ytd-video-renderer').map((e, idx)=&gt; ({index: e.querySelector("#index")?e.querySelector("#index").textContent:idx, url: e.querySelector("a.yt-simple-endpoint").href, duration:e.querySelector("#content ytd-thumbnail-overlay-time-status-renderer span")?e.querySelector("#content ytd-thumbnail-overlay-time-status-renderer span").textContent.replace(/\s/g, ''):"", title: e.querySelector("#content #meta #video-title").textContent.replace(/^\s+|\s+$/g, ''), author:e.querySelector("#content #meta ytd-video-meta-block #metadata #byline-container a")?e.querySelector("#content #meta ytd-video-meta-block #metadata #byline-container a").textContent:"", authorUrl:e.querySelector("#content #meta ytd-video-meta-block #metadata #byline-container a")?e.querySelector("#content #meta ytd-video-meta-block #metadata #byline-container a").href:""}))) 
It's build because we have to repeat these steps again and again every time we start a new project plus most of the new developers don't know about the jwt tokens or hashing which is already done in this project so maybe it will be helpful for most of the new developers but not for someone like you who is experienced plus i use this most of the time when i start new project because most of my project contains same this login signup and tokens to authorise user. i don't want to repeat these steps again that's why i did this. Maybe it might not be helpful for you but for someone it might be. Thanks
I made an npm package that added shebang \`#!/usr/bin/env node\` to your cli applications, [https://github.com/danielpa9708/node-add-shebang](https://github.com/danielpa9708/node-add-shebang)
The way the docx spec is written, only Word can ever hope to fully read and write it, everything else just does a best effort attempt. You‚Äôre much better off investing your time in investing faster then light space travel than a fruitless endeavor like this.
I wish we could destructure arrays at the end. For example: `const [...rest, lastItem] = someArray;`
I agree, it seems very difficult. Which makes me wonder how google can do it.
That seems interesting. Only problem is I‚Äôm running my app on a node.js backend, and I need to be able to read the file and render on the client side. I can‚Äôt even find a node module that‚Äôs capable of supporting this.
[Been toying with the idea of creating (yet another) a UI library lately.](Been toying with the idea of creating (yet another) a UI library lately.)
[Been toying with the idea of creating (yet another) a UI library lately.](https://github.com/mini-eggs/Wigly/tree/master/packages/wigly-customizer)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mini-eggs/Wigly/.../**wigly-customizer** (master ‚Üí 5f17599)](https://github.com/mini-eggs/Wigly/tree/5f17599ef67e1076a9ec9005c913f9d7fe7a154f/packages/wigly-customizer) ---- 
Thank you stephanh42, I sometimes tend to overcomplicate things. This worked like a charm. Much appreciated.
Quick follow up question as I am trying to understand and learn as well. What does "|| \[\]" do exactly? Does it create an array within the scope of the for loop and push into that array? If i'm not mistaken doesn't || mean "or" ? If you could please elaborate a bit on your answer it would really help out this aspiring developer. Thanks
Nice theme üòéglad you like it &amp; are finding it useful
Service Worker is now generally available, Vue has been gaining mindshare, there's a trend towards non-semantic CSS, and people are experimenting with WASM. You got out during peak instability so unless something happens due to SW availability, I'm not expecting much in the next 3-5 years.
Hmmm no, only reason to use js on the server is for ssr. Python is better in every other way with higher quality packages. There are packages for everything you could possibly need in python.
Do you _click_ your button or do you _lick_ it? :)
I must be missing something, because it sounds like your proposal is basically just a hacky way of preventing npm/yarn from maintaining a local cache.
That‚Äôs great news! If I were maintaining a OSS project big enough to really benefit from this I‚Äôd have no problem paying for a dev account to offset workflow costs. I just want to be able to use it in public-facing repo or it wouldn‚Äôt be useful to me as a maintainer. 
Just made a node module to help parse and verify google id tokens on the server side. I took googles documentation and made it into a super simple class you can bring into your project. &amp;#x200B; [npm](https://www.npmjs.com/package/google-token-reader) [github](https://github.com/hkd987/google-token-reader) [google docs on issue](https://developers.google.com/identity/sign-in/web/backend-auth)
For me, it's the fact that eval() exists
Thanks :)
&gt;For me, it's the fact that eval() exists üòÇüòÇ
They hate hate us cause they ain‚Äôt us
Love it.
Because it's not xyz.
Example implementation of tree-shaking and dead code elimination of Rambda, Ramda and Lodash with Webpack, Parcel and Rollup. &amp;#x200B; [https://github.com/selfrefactor/tree-shaking-example](https://github.com/selfrefactor/tree-shaking-example)
Hate JavaScript, love TypeScript
Haters gonna hate
Actually zeronode was built to do the oposite and for some of our production services its just shining. So let me try to answer those 2 topics. 1) Q: Balancing within Node can make it easier for devs (whom have orchestration/DevOps difficulties) at the cost of scaling nuances. A: You can compare zeronode with i.e http or request npm , so just assume it's a smarter and nicer transport between the server microservices, and this transport has smarts of routing messages within a wire of zeronode nodes (actually it has much more). Please check the [API](https://github.com/sfast/zeronode#api) 2) Q: Making management difficult for DevOps. The devops cost of zeronode will be equal to bringing any other transport layer (http, socket etc ..) between services. 
Created a simple game where a box runs away from the cursor. Can only guarantee chrome support at the moment. Also doesn‚Äôt work on mobile üòü https://www.liammahoney.me/mouse_movement/index.html
I‚Äôm having a hard time picturing a use case for this.
It‚Äôs a thousand little things. The language was written at a time when it was for minorly manipulating webpages to do things like verify dates, or figure out if you punched the monkey. These days, SPA is a thing. Like sometimes adding 1 and 1 gives you 11, because whatever data source the 1 was stored in stored it as a string, and + is also string concatenation. This is a hard problem to solve. Sometimes you want to say ‚Äúuser‚Äù+id to get ‚Äúuser45‚Äù. Sometimes you want to say ‚Äú1‚Äù+1 to get 2. It is impossible to redefine what + means. You can add another operator (such as ‚Äú.‚Äù) to solve it, but that just adds ambiguity. If you can never remove +=cat, then you should never add a second redundant operator. Secondly, it takes a massive amount of effort to introduce a new native, better language in browsers and get it adopted without going back to the ‚Äúworks best with IE7‚Äù days which none of us old timers wants to remember. Adding a new language would be like convincing America to speak Esperanto (or go all in on metric). To help patch these problems, we‚Äôve added languages which transpile down to JavaScript. Coffeescript is a good example. Typescript fixes the ‚Äú11‚Äù problem. These all have the downside that viewing source on your own webpage reveals strange and unfamiliar code (without source mapping). To help SOLVE these problems, newer versions of JavaScript are coming out that fix this stuff where it can be. But right now, not all browsers support it, so new JS is still being transpiled down to vanilla with tools like webpack, which act as a compiler, even if all that compiler is doing is translating from one script to another. 
Zeronode is not just a toy :) , but its built on top of [zeromq](http://zeromq.org/) (intelligent transport layer for distributed apps ). Its doing simple things (connecting server to server ) really good, but the smarts in the zeronode will allow to design distributed systems easily , especially when those parts are coming and going dynamically. Distributed computation or other ETL with some custom/configurable flow ..
Kinda depends on what you want to do. I haven't used flutter, so i can't speak to it, but people seem to like it. React Native is a good approach when you want to make an app for both iOS &amp; Android, and don't have the resources to build it native for both. Generally speaking, you can just take better advantage of the UI and native functionality by building straight for native. Though it is quite possible to do this with react-native as well. You just need to build abstractions around the UI components that both platforms can use. 
Simply you wouldn't store any non module on your machine, they will be downloaded on demand and cache for future use.
Kinda, the local cache will be just huge and transparent to the user.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sfast/zeronode/.../**request-many-handlers.js** (master ‚Üí 0dc026d)](https://github.com/sfast/zeronode/blob/0dc026df9f559af947428e8e5c054ff1c28bbc56/examples/request-many-handlers.js) ---- 
&gt;To help patch these problems, we‚Äôve added languages which transpile down to JavaScript. Coffeescript is a good example. Typescript fixes the ‚Äú11‚Äù problem. These all have the downside that viewing source on your own webpage reveals strange and unfamiliar code (without source mapping). That's seem a reasonable explanation, thanku
Go for RN only if you need to support both Android and iOS and you don't have a big enough team to create separate apps. If you only have to support Android, building it in Kotlin or Java will give you a better, smaller, more stable app; accessing the native areas of the OS will be simple and you can support the newest build systems and tools with no issues. RN has it's fair share of problems(upgrading it is a pain IMO), but it's not impossible to use. If you know React you'll feel at home here, though you might find some stuff a little limiting(animations are quite hard IMO) You also have to consider whether a mobile website would do what you need or if you *absolutely* need the native app. If you're using Bluetooth or the filesystem then sure, you might want to go native; otherwise, I'd recommend that you just develop a PWA or a simple mobile website instead.
It varies, but a lot of people just don't understand it. They don't understand prototypal inheritance. They hate that it has warts and some odd behaviors. Most of all, they don't spend enough time in it and hate being forced to use it for the web.
Why would I ever want to do this? What problem is this solving?
Crated a CLI tool to ‚Äòdocker run‚Äô without any hassle - seamlessly run any command in a dockerized environment. https://github.com/benzaita/dockerized-cli
Some of the complaints I've heard recently are just about type safety and wishing the language was strongly typed and somewhat verbose like Java. I for one actually love this aspect, but developers who've been accustomed to Java for a good number of years who try JavaScript for the first time always point out this fact. Also, I guess the lack of distinguishing an integer and a float. They're all just under type "number," which is different than other programming languages
&gt;There are only two kinds of languages: the ones people complain about and the ones nobody uses. &gt; &gt;*Bjarne Stroustrup* &amp;#x200B;
guess you made a mistake then
 data.push({ courseID: classes[i].courseID, desc: info.desc, credit: info.credit }); `info` is not an object with `desc` and `credit` but some iterable-like collection of those.
It's why part of our C# app uses IronPython (because we need something like eval and JS wasnt viable then). Because we need a lot of dynamic code, which is generated by user clicking on things.
If you're doing integration tests you should do full-blown integration and hit the database as well.
Hey! I'm a Yarn maintainer - I love projects that go entirely different directions from what we currently have, so I'm curious about this! That said, note that one of the things we're working to remove is actually network reliance. We found that it was in practice one of the most common reasons why installs can fail in an environment but work in another. So while I like the way you're thinking, I'm not sure such a project would actually help.
Every language has an equivalent to eval.
Jest is a great testing framework, I think it is capable of doing what you are asking however another alternative would be Mocha. 
Damn, tough crowd. I thought this was pretty interesting, actually.
That's not true. Most compiled languages don't have anything like it, and among dynamic languages eval() can have differing semantics, and non-strict Javascript has some scary ones. 
I like Jest because I also use it for React. If you're using mongodb, rather than mock Mongo, I found https://github.com/nodkz/mongodb-memory-server which runs mongo in memory only while you're tests are running
I love JavaScript, I understand why it is different, even so it is still shocking(try 0.1+0.2) Also https://www.youtube.com/watch?v=lj01TyZf4Rw
I can find tons of applications and boilerplate code out there but very little information on how to stand up an instance of the application. I'm just really ignorant of the operational side of things. 
Sorry to ask such a noob question. I'm just having a hard time wrapping my head around the nuanced differences.
Js is a language that was made in 10 days. People hate it because Brendan Eich didn't had enough time to implement common designs like block scope at that time. On top of that people like to compare the language to other languages like C and Java because js is used for a vast majority of things like servers, games etc. even though the initial intention was to just manipulate stuff on the web.
Don't worry about it. Just stick to \`const\` and \`let\`. You shouldn't ever need to worry about \`var\` if you don't want to.
Basically that's it. However there's a subtlety with const: ``` const user = { firstName: 'test', lastName: 'McTester' }; user.firstName = 'Marty'; ``` This is perfectly fine. That is, you can make changes to `const` variables, but you can't reassign to them.
[removed]
I've made a Cli to generate JS templates [https://github.com/Fried-Chicken/momo-cli](https://github.com/Fried-Chicken/momo-cli). Can you help me make it better? 
 for (var i = 0; i &lt; 5; i++) { // loop } for (let j = 0; j &lt; 5; j++) { // loop } console.log(i); console.log(j); Output 5 VM544:10 Uncaught ReferenceError: j is not defined at &lt;anonymous&gt;:10:13 
That's an very important point. Same goes for arrays.
A lot of people find it HUGELY offensive that their knowledge of complex and immensely powerful languages lends them less money than JavaScript would. Personally I can't really blame them. A lot of other languages are quite a bit harder to learn, can objectively do more, and it could be argued that they are "better" overall, yet ... are not as thought after, require more time/effort and pay less. This can be compared to real languages. English is what the world speaks, yet it's a simplified pidgin language, a bastard amalgamation of Danish, German, French and Latin, that was then pruned of the majority of difficult concepts. Other languages are infinitely more complex, yet ... the world doesn't speak Chinese or Russian or Arabic. Some people could find that to be pretty offensive and get pretty butthurt over it.
Scoping can mess with you pretty bad if you use var. I'm on mobile so this will format terribly, but here we go: for (var i=0;i&lt;5;I++) { setTimeout(() =&gt; console.log(i), 1000) } Will print the number 4 five times after a second. That's because the i variable declaration was hoisted above the for loop so each iteration has the same i. If you use let instead it will be scoped to the for loop body and will print 01234. 
Here are some common technical objections: * the web as a platform is inefficient compared to natively compiled code or process virtual machines like the JVM, CLR etc * the web as a platform is unsuitable due to the difficulties of CSS/HTML, or it's heavy sandboxing, or it's performance * javascript is dynamically and loosely typed, which is bad for application reliability * javascripts prototypical inheritance is strange compared to the usual class inheritance * javascripts prototypical inheritance is strange compared to canonical examples like self * the langauge is more verbose than other dynamic languages like python/perl/ruby. * the language uses dynamic scoping, which is considered unusual and prone to shoot you in the foot (I take all the above with a graint of salt, but I don't think they're without merit). Another common reason is people don't like that the web is taking a larger and larger chunk of application development. There's a lot more moving parts to deal with than there is with say win form apps. Sometimes this just seems to come out as "javascript sucks".
First of all you started talking about arrow functions yet you never used one in your examples. You used a function expression, written with the traditional `'function'` keyword. The 'this' in a a traditionally written function is derived from the scope it was executed from. &amp;#x200B; `myObj.func()` takes its 'this' from myObj as its being executed from that context. &amp;#x200B; Now if I assign the function itself to a variable, `let myFunc = myObj.func` *(notice the parentheses are omitted as we are not assigning the result of the function execution but the function signature itself.)* And execute `myFunc()` we are now passing 'this' from the surrounding context, perhaps the global context in this context which is indeed the `window` object, &amp;#x200B; The arrow function is different , it's `'this'` is set , and it takes it from its surrounding function if it resides within a function or from the global object if it doesn't sit within a function. &amp;#x200B; myArrow = ()=&gt;this myArrow() // returns Global(window) since when defined it doesn't sit within another function, we cannot reassign it's `this` let myFunc = function(){ let inner=()=&gt;this; return inner() } , myFunc() still returns window since the encompassing function of the arrow function passes its 'this' value down and as it sits in the global scope that would be `'window'` in the browser &amp;#x200B; `myObj = { arrow:()=&gt;this, myFunc : function(){ let y = ()=&gt;this} }` , `myObj.arrow() // return s global object(window)` since the arrow is not contained within a regular function &amp;#x200B; `myObj.myFunc() // returns myObj` since it does sit within another function and takes its `'this'` from that surrounding function
C and C++ don't have eval but they can execute arbitrary bytes. Java and PHP have built-in deserializers that can execute code. Not sure about C#. They're not the exact same thing as eval but have similar security pitfalls.
This sums it up üíØ
I used to use mocha. Now at work we use jest. Not a day goes by where I do not miss mocha. Mocha just works. Use it. 
.1+.2 has nothing to do with JavaScript and is a general limitation of base2 floating point arithmetic.
Thank you all for your input. I'm going through your feedback now. Will post if I have any further clarifying questions. I really appreciate the support in this sub!
Your third line is not correct. Notice that I was changing a property on an object (e.g. `user.name` or `user.age`) I still could not do `user = {}` after I had already assigned a value to `user`. The same thing is true of arrays. ``` const myArr = []; myArr.push('hello'); ``` That is fine. However, ``` const myArr = []; myArr = ['hello']; ``` Is not ok.
just to clarify, functions are made up of blocks, correct? like func { for loop block{} if/elseif block{} } ?
You can use let. The console logs happen outside of the for statement - showing that let is scoped only inside the loop while var exists after it as well.
you can, but you can't look at the `let`ed variable from an outside scope. { var i = 5; } console.log(i) &gt;&gt; 5 { let k = 5; } console.log(k) &gt;&gt; Uncaught ReferenceError: k is not defined In general, you should avoid `var` as much as you can. It creates volatile, error-prone variables. Use `let` for non constant variables and `const` for constant ones. Only reason you'd ever use `var` is if your target engine does not support `let`... which only happens for [less than 10% of the browser population](https://caniuse.com/#search=let)
1) Poor standard library 2) Poor evolution as OOP option 3) Bad implemented types 4) Ugly syntax &lt;- this is a big one 5) Lexical scope is ugly and not intuitive 6) After years been stock, sudden explosion: ES5, ES6, ES7 In general, JS is a bad designed language. Typing Clojure, Haskell or Erlang make you proud, in the other hand, saying that you code in JS is embarrassing.
Awesome work. 
that seems a bit confusing.. in the first scenario you're able to end up with myArr = ["hello"]; but in the second you aren't ? Is it because technically in the first scenario, you're adding a new element and in the second you're attempting to modify an existing null element? Am I thinking about this correctly?
Just use messenger.com instead. Search the chat for something you said near the start, click the earliest result and scroll to the very beginning.
I hate JavaScript because: 1. It has abnormal Type Coercions 2. It doesn't support Type Annotations
I golfed up a solution for ya. const solution = data =&gt; data.reduce((acc, {name, value}) =&gt; ((acc[name] = acc[name] || []).push( (isNaN(value) ? value.trim() : +value) ), acc), {});
that makes sense. Does this also mean that I can reuse variables with let as long as they're in different blocks separate from each other.. ie: function do { for (let a = 0; a &lt; 5; a++) { //loop } while (let a = 3; a &lt; 10; a++) { //loop } } Would the above execute the same as it would if the second loop variable were b instead of a?
Yeah. Well a function's definition is contained in a block. That is for sure. OK this will make it clear: function myFunc() { if(true) { var x = 3; } console.log(x); // will log "3" because x is scoped to the function and we are still in the function. if (true) { let y = 5; } console.log(y); // will log undefined because we are outside the block where y was declared } 
that makes sense. Thank you for the example, it definitely helps 
They hate it because it challenges them. Many programmers who started in java have trouble overcoming the limitations of types. Asynchronous programming throws off even more. Those who skill up find it a tremendously useful language, and obsoletes most others completely. 
Yes it would.
Var has functional scope and let has block scope. 
Trying to get my head around the hoisting part. Basically, from what I'm thinking is by the time console log prints i the first time, the value of i is already 4. Also, in that example if x is type let then i in console.log will cause an error because of anonymous function? What about if it was not anonymous?
When I integration test I use Jest and Supertest to exercise all the endpoints in the API, database and all. 
May I ask, seriously, why you chose to do this rather than simply using closures or other first-class-function features to build up execution pipelines? Allowing a user's input to create and execute arbitrary Python code is a recipe for disaster, it seems to me.
Perhaps, but there's a difference between: eval(userInput); and let userFunction: Fn() -&gt; () = unsafe { std::mem::transmute(userInput); } In C, C++, or Rust, you can build a footgun if you really want. In JavaScript, it's like Eich handed you a loaded revolver, safety off and barrel down. This is similar with a lot of language features.
Tbh I always abstracted `var` as "legacy stuff don't touch" you can never use a let variable from outside the scope it was declared on; if anything, `var` is the only confusing one to me.
The biggest difference is var hoists the variable while let/const do not. 
There's a minor mistake here. It will print 5 five times after a second, not 4.
I tried autoload.start(1200); it didn't work &amp;#x200B;
Not couchjitsu, but in the first example: const myArr = []; is "pointing to" or a reference to a particular array. That reference is what is not reassignable when you use ```const``` on an object or an array. So when he does myArr.push('hello'); He's altering that specific array itself, not the reference to that array. In the second example we again start with: const myArr = []; which makes ```myArr```'s reference to that specific array ```'[]'``` unable to be reassigned. So like he said myArr = ['hello']; would be making ```myArr``` point to a new totally different array that happens contain 'hello'. That would throw an error. If it helps bring the point home, reassigning ```myArr``` to another empty array would also not work: const myArr = []; myArr = []; also throws an error because those two arrays are totally unrelated and you're trying to reassign ```myArr``` which is ```const```. Hope that helps!
https://github.com/openorclose/Javascript-The-Good-Parts/blob/master/for.md#rough-conversion-of-for-loop-with-declaration A more in depth explanation of how the let in a for loop works. It's actually really intricate, what goes on under the hood.
1. || [] checks for any falsy value and then returns an empty array instead. Though the only falsy value we expect here is undefined, upon the first encounter of a particular 'name'. 2. {} and Object.create(null) are NOT equivalent. The latter creates an object without any prototype, not even Object.prototype. Consider what would otherwise happen if unsanitized input contained name fields such as 'toString' or even '__proto__'. However I would use a Map instead I modern code ( but your example used an object).
What is error prone about `var`? I‚Äòve been using it for a decade without much issues (except for the loop/closure situation that was unintuitive at first)
YDKJS has a chapter that goes over this in detail: https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**ch3.md** (master ‚Üí 0cc17c5)](https://github.com/getify/You-Dont-Know-JS/blob/0cc17c53ff772e20dfd6a7072c965df2486116e8/scope%20%26%20closures/ch3.md) ---- 
I'm one of the only men left on earth that doesnt use Facebook. There's four of us left. We lost Joshua in August. It's sad. But, back to your thing. Did you try injecting a tag into the DOM and creating a floating button? It's basically a variation on this (https://www.w3schools.com/howto/howto_js_scroll_to_top.asp). If you want a code example, could you provide the page source HTML? Make sure you remove any personal information as I may be a Russian Spy or a pervert. You never know :P
The only thing I'm fuzzy on is what const actually means you can't change. Is it just primitive type variables that can't change? Or is it something else? I know you can add to collections that are consts.
It sounds like you've made up your mind already. The points I outlined are based on comparison after moving from React. Angular hasn't been a contender for multiple years in my mind.
The key here that nobody's mentioned yet is that `let` as a variable in a `for` loop has much saner behavior. One of those stupid interview gotcha questions goes like this: Given the following code, what is logged to the console? for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i) }, i * 1000) } And of course the answer, which the candidate doesn't know because they're interested in solving business problems with code rather than the intricacies of JavaScript circa 2014, is that `5` is logged to the console once per second. This is because `var i` is a single variable scoped to the containing function, so when each timeout fires it reads the value of that single `i`, which is now 5, and logs it. But since `let` is block scoped and the introduction of a `for` loop is inside the loop's block, the behavior of this code is what you'd naively expect: for (let i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i) }, i * 1000) } That code will count from 0 to 4 once per second - which is the behavior you want when you write something like that, and the behavior the reader expects when they read something like that. A new variable `i` is created for each iteration of the loop. Each of those `i`s is captured by its respective anonymous function's closure. So you can think of it as being like `console.log(i0)`, `console.log(i1)`, and so on. tl;dr just use `let` and `const`. Use `let` as a loop variable or if your code requires the variable to be reassigned after it is declared and assigned an initial value. Use `const` otherwise.
Not only can you do that, but each iteration of the loop instantiates a new iteration of the let variable. This becomes useful when using loops with callbacks: for(var a=0; a &lt; 3; a++){ //with var setTimeout(function(){ console.log (a) }, 1000); } &gt;&gt;3 &gt;&gt;3 &gt;&gt;3 The callbacks hold a reference to the variable `a` (that is, form a closure over the scope containing `a`), and get it's value one second after the loop runs to print it, getting 3 each time. for(var a=0; a &lt; 3; a++){ //with let setTimeout(function(){ console.log (a) }, 1000); } &gt;&gt;0 &gt;&gt;1 &gt;&gt;2 Each loop effectively has it's own let scope for a, so it's technically a different variable each time. Each closure holds a different variable. 
 I made a web Extension with Vue.js [And it's here](https://chrome.google.com/webstore/detail/honey-muffin/hgfdjolhekbkcjieahfioaljegmcnkjp) Know the feeling of stumbling upon truly awesome repositories, and feeling the FOMO for other repositories you've missed? well, I know the feeling :) I've created a lightweight, free extension to get updated with great new open source projects. This is my first time coding in Vue, and first time writing an extension - although I'm an experienced developer.If interesting, I'll write a post on medium on how to create one.
&gt;you can, but you can't look at the leted variable from an outside scope. The short answer here is \`for\` loops are one of the use cases \`let\` was actually implemented for. They are ideal for \`for\` loops because they 1) can be reassigned and 2) like \`const\`, are block scoped and don't 'leak' into the global context like \`var\`s do. See [https://wesbos.com/for-of-es6/](https://wesbos.com/for-of-es6/)
Function scope and hoisting doesn't make much sense and doesn't promote good, safe, readable code - there's a reason why it's pretty unique to JavaScript and was eliminated with `let` and `const`. Consider the following code, which isn't ideally structured but you could easily imagine a junior developer writing: function setup(widgets) { &lt;a bunch of code&gt; for(var i = 0; i &lt; widgets.length; i++) { var temp = widgets[i] if(someCondition(temp)) { var data = modifyWidget(temp) // TODO remove before commit - JD, 8/5/2014 // console.log(data) saveToLocalStorage(data) } } var data if(shouldCheckLocalStorage()) { data = getFromLocalStorage('sprocket') } else if(shouldCheckServer()) { data = getFromServer('sprocket') } else { console.error('No sprocket available!') } if(data) { addToSprocketCollection(data) } else { createDummySprocket() } &lt;a bunch of code&gt; } Now you get a ticket from the test team: &gt; As of build 1.827.12 sometimes some sprockets are not rendered. So you test it out and after some fiddling with conditions you get a helpful error: Uncaught TypeError: undefined is not a function renderSprocket:104 And after tearing your hair out for a few hours reading the code and logging things and trying to figure out why you sometimes have a widget instead of a sprocket, you finally figure out the problem and why it's intermittent - if `someCondition` holds for anything in `widgetArray`, `data` is already defined as a widget when we try to acquire a sprocket, and we unintentionally put a widget in the sprocket collection. And then at some point later, we try to render a widget as a sprocket and it goes badly. And worse, if you say to yourself "well I'm a strong independent senior developer who don't need no block scoping", you fix the issue by removing JD's old log and restoring it to `saveToLocalStorage(modifyWidget(temp))`. But that leaves this function vulnerable to the exact same problem in the future! Changing your declarations to `let` and `const` either prevents these issues by block scoping variables with identical names, or lets the JS runtime detect and give you sensible, specific error messages when your script is loaded if you try to use a variable before it's declared, or declare the same variable twice.
These are very good. Recommended.
The issue is that suddenly a new language has taken the world by storm and we are eating the lunches of people who have traditionally been untouchable. Suddenly they are getting touched pretty bloody hard. An example would be microsoft office vs google docs. Google docs and most web based apps are superior because they break dependance on a particular OS, a particular OS environment, or even hardware. So long as you have a standards compliant browser your off to the races. this.drives.them.INSANE. Their precious little languages do not work with the web and the things javascript can do make them jealous. Their just scared about losing their jobs, and they should be.
https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
Loose typing, prototypal inheritance, weird scoping model, implicit casts, the occasional misnamed function. All things that make it, as a language, behave in unexpected and upsetting ways, which, if you're not _real_ invested in understanding the language, can bite you hard in the ass.
`const` only means your variable can't be reassigned to. `let` keeps variables in the exact scope they were defined, and `var` is a garbage pile of functionality.
Tl;Dr - can't write good js because bad
I think it's become a meme bc of the billion and a half libraries and it's also primarily used in web development and has limited popularity outside of that realm.
I know it's Sunday in Australia right now but I did make something this week! I present to you [\_api](https://github.com/TokenChingy/_api)! \_api is an autogenerated CRUD API built on [LowDB](https://github.com/typicode/lowdb) and [ExpressJS](https://expressjs.com/). All you need to do is edit a configuration file and you will have a basic CRUD API ready to use! Let me know what you guys think!
This is incorrect. All of var let and const hoists the declaration up to the TOP of their respective scope.
No, no. You _should_ use `let` in `for` statements - because the variable is scoped to the `for` block, and its memory is freed immediately after.
This is really cool! Thank you!
Your overuse of italics makes the above more difficult to read than it needs to be.
Good stuff! Will come in handy!
Nice!
What do you think happens here? Why? Try it! ` if(false) {var foo ='hello'} console.log(foo) ` 
You forgot to change the declaration from 'var' to 'let' in the second loop, but that's a useful example. Python has traditionally had the same problem 
I get a lot of hate for disagreeing with this one... it's only minimally more helpful and is a lot of work - but that's not why I hate it. I hate it because it's unnecessary. It only exists because people who only ever coded in "real" languages had to write for the web, and couldn't handle the flexibility of dynamic typing. If you want static types, go write something in a statically typed language. Adding a transpiler which converts your static code to real JS is fine, but jeeesus world - quit pushing it on everybody or claiming that it's "better". It's not.
Maybe go ask in /r/Ghost ?
I know exactly what happens ‚Äî hoisting. What happens if you weakly compare an empty array with an object concatenated with a null casted to a number? If you do weird stuff, you can expect weird results. But I get your point, standard language construct shouldnt be weird by default
Thanks!
Remember, they're all just vars under the hood. The transpiler pretends they have different rules and scopes, but if you look at the generated code after Babel, you'll see it's just vars.
It was written in 2003.
Even if the server was handling a database, it's not until you get to large-scale application where NodeJS + \[Insert Framework\] falls over. NodeJS should handle most websites and small to medium scale web services.
I feel sorry for people who don't see the beauty of TypeScript and React. The NPM environment is pretty cool too despite the hate it gets. 
the places would be looked up way more! i think my biggest confusion is that i want to be able to get user locations and have these places show up but i want a custom property that i couldnt get from the google api. ie googles api would give me the place , address, phone etc but wont tell me how many people are drinking coffee at this place...is it better to just save my custom property in databse and use google api to get the rest of data each time &amp;#x200B; `location = get(google_api_Place)` `location.customProperty = get(location.place_ID)` so my database would be small maybe just { \_id: 1234 place\_id: (to match up with google place) customProp: blahblah
It would most definitely be better.
That's a pretty in-depth and custom example... did you just take it from a codebase at work or something?
Just learn HTML and CSS. &amp;#x200B; It'll take you a weekend to cover both languages and just be prepared to google things regularly until you memorise them. &amp;#x200B; You're going to have to use HTML and CSS anyway and most beginner javascript tutorials or courses will assume you know them. &amp;#x200B; It'll be faster and easier for you in the long run to just take the time to learn basic website markup and styling before trying to add scripting on top.
I don't understand your point about thinner api and 'framework' convention namely.
HTML and CSS can be learned in a weekend. Learn the basics and jump write into making static web pages and google your ass off if you have any questions. 
Why do you have to learn React or Vue? Are you being held at gunpoint? Just joking, I think you have to have basic knowledge of CSS and HTML before getting into JS. You also have to learn JS before React/Vue. And yes, you have to learn now, not stay with your knowledge from 2008 (things change). There are millions of free online lectures about HTML and CSS. I would start there.
Both React and Vue are heavy in terms of HTML/CSS, Vue especially since it uses standard HTML/CSS by default and not that \`.jsx\` syntax of it. To be honest with you, HTML/CSS is not very difficult to pick up, HTML in itself it very easy, CSS has some funny quirks to it but can be picked up without much difficulty. If you already know a programming language, I'd say you'll pick up all you need to get started with HTML/CSS in about a week.
Nope, fortunately we're strict on using `const`/`let` only. Though some people overuse `let`, much to my annoyance. I find that realistic examples illustrate points like this better, so I put some effort into it. Simple but unrealistic examples bring the point into focus, but people sometimes look at them and think "sure, but that will never actually happen." ...actually, the part about mind-boggling bugs that happen at a distance from their root cause is definitely from work...
We're hosting the project on Elastic Beanstalk so the load balancing is taken care of. I made a point to avoid any global state early on, though while I was thinking about some caching solution, I did consider making a global cache object on the parent process, but I haven't done anything with it yet.
You want to maybe add an extra entity into the mix, like ‚Äúattendance‚Äù. A user is at a location via their attendance. This way you keep the user and location entities clear. Think of it like a typical account/user scheme. Users are not linked to an account directly, but via a membership. You don‚Äôt need to expose this in the UI to your users 
Do you know of any resources that would show one how to actually properly architect it this way? Our project is still in alpha user testing phase so we're not under high volume traffic yet ( and tbh probably won't be popular enough to be) so we're just hosting on AWS Elastic Beanstalk with pm2 as my npm start command. It's got some sort of Nginx proxy in front of it but I haven't got a very good idea of how it works since it just did that for me by default on AWS. The app itself has the master process use the `cluster` package to make as many child processes as there are cpu cores.
So you do love JavaScript, but prefer it with types.
You‚Äôll need to learn both HTML and CSS If you‚Äôre planning on doing either React or Vue. HTML extremely easy. CSS, easy but require bit of maths and thinking to design how you want your style to look and behave. Overall much easier than JS. However, for pure JS only Node is possible. Although, depending on your company you may need to still do HTML and CSS on the backend (templating etc)
Yeah in agreement with some other comments. Nowadays I would just learn Typescript over JS because you can do everything and more. I started learning TS and it's great. Also it means I can move into languages like C# easier. Types save programmers lives 
Yes, but don‚Äôt let that fool you. Node is backend, and is much harder than just to learn HTML / CSS. If you‚Äôre interested in backend development then Node is for you. However, personally, a developer should always have an open mind in development. Don‚Äôt be afraid to step out of your comfort zone and work with something you‚Äôve never or don‚Äôt want to use. That‚Äôs what separates a good job candidate from a bad one.
Got context? What are you using them for *now*?
Much comes from people that expect a compiler to function as a proof reader that keeps track of variables and types for them and holds their hand when they get lazy and randomly smash variables together and expect coherent results.
Why not both
This is mostly based on comtext but as a general rule of thumb when some variable is undefined then its mean that no one has set any value to it while null means that someone has explicitly set null value to it (which can imply either value is absent for has some error) 
Note that if a `const` isn't a primitive value, the properties of whatever it's a reference to *can* be changed. e.g. this is perfectly valid: const foo = { greeting: "Hello, world!" }; foo.greeting = "Goodbye, cruel world!"; Because `foo` is maintaining the same value--a reference to an anonymous object.
It isn't like before, these frameworks abstract from the web platform and lessen its impact. You need to know basic css rules, the box model, flex, grid, margins, paddings and so on but that's relatively easy. Frameworks spare you from learning idiomatic html and most of the web api (if not all of it). You don't manage events, you don't query nodes out of a soup of elements, you never, ever touch, read from, or write to the dom. I think the learning effort compared to 10 years ago is far more manageable.
Thanks! :)
Sort of. They are all technically hoisted but let and const variables aren't initialized until they are declared. You can access a var variables before it's declared in your code. Not so with let and const 
I wouldn't say it completely faded away - [Flutter](https://flutter.io/) uses it (framework for building native apps that has high potential to be good), but yeah, it did fail to replace javascript
What does that have to do with this question? Also that‚Äôs only if you need to transpile them. Const and let are widely supported now, so unless you need to support very old browsers, you won‚Äôt need to transpile them. Even IE 11 is aboard this train. This is like saying that async/await are just normal promises, because that‚Äôs how Babel have to polyfill them while we wait for a larger browser support. The argument makes no sense other than explaining how babel work.
You can speed run through: https://www.freecodecamp.com Worth doing
It has literally everything to do with how all new es features are speced and implemented. 
Didn‚Äôt check if it‚Äôs been said. But be careful of using ‚Äúthis.‚Äù 
I can‚Äôt answer that I‚Äôm afraid as it‚Äôs subjective. I find problem solving fun in general, and in programming I get to do that whether it be frontend, backend or hardware. Doesn‚Äôt really matter.
I hate working on other people‚Äôs stuff. It pisses me off to no end when I fix someone‚Äôs shit and then they inevitably blame for everything else that‚Äôs wrong with every electronic device in their home or business. Sysadmin work is hell. I hate it.
Thanks for the answer! What do you mean with permissive?
How is Cindy then thrown into the mix?
The V8 engine came *after* jQuery and the hell of wrangling all of the disparate implementations of JavaScript into something one would could work without losing their effing mind. Crediting V8 for the explosion of JS‚Äôs popularity is simply wrong.
Haters gonna hate. (c)
Yeah I know community is important but I'm interested in the language itself, the "feel" when you code in JavaScript that you say "Hey, this does not happen with another language"
how can you tell if someone isn't on facebook? don't worry. they'll tell you. incidentally, check out hacker news. you can't spit there without hitting a comment talking about how "i'm not on facebook and i can't for the life of me understand why anyone else is either"
Put them in HTML hide it using a CSS class and unhide it with className JS property.
 https://www.w3schools.com/jsref/met_node_appendchild.asp https://www.w3schools.com/jsref/met_node_insertbefore.asp https://www.w3schools.com/jsref/dom_obj_all.asp
Thanks, this is probably the best clarifying answer I‚Äôve seen. I really appreciate the time
Awww, How could I miss that. Thanks McNulty, I knew you aren't just a good cop ;)
Thanks!
&gt; whether it be frontend, backend or hardware damn you're just like me ! &amp;#x200B; i used to have alot of passion for hardware programming as well :D &amp;#x200B; ah well, i'll explore it for myself !
Speed run how exactly ? (i'm new to this ... so kindly elaborate )
eh ... after reading this... at first, i was worried that we weren't getting to learn everything and all these frameworks are just abstracting and abstracting ... leaving us with very little to learn from &amp;#x200B; but i think... &amp;#x200B; &gt; Thankfully the learning effort compared to 10 years ago is far more manageable. &amp;#x200B; this means something good ?
It is two very different jobs and not really comparable. I spoke to someone quite young who was after getting into ‚ÄúIT‚Äù and they asked about my job and about sysadmin. It seems a lot of younger people see it as the same jobs but on different paths when nothing is further from the truth. People who program and people who perform sysadmin are two very different people. Not saying one is better than the other but you either enjoy one of the other, in my opinion. My friend does networking and sysadmin but he‚Äôs well into his career in that he‚Äôs no longer dealing with the lower level users and designs and manages networks on a global scale and he loves it. I could probably do it but it‚Äôs not something that takes my interest. 
 I love JavaScript because of it's dynamic nature
Oh no, I can't read this one
const works exactly he same as let, but cannot be redefined later in the program. In other words, it has to be constant (hence the name). 
You can't trust those hackers, they're all bots controlled by the government in order to give the populace a semblance of nonconformity. It's all quite Machiavellian. &amp;#x200B; As for how you can tell who's not on Facebook, we hold biannual meetings. Last time we congregated at an Airbnb for a weekend retreat in New Hampshire. It's where Joshua proposed to Lindsey. It was really quite beautiful. &amp;#x200B; But, back to the thing. &amp;#x200B; I only mentioned not being on Facebook, because it's a post specifically about Facebook and I requested code from Facebook from the OP. If I had a Facebook account, I could just get it myself. I figured that the OP might share the same train of thought; so, in anticipation to his reticence, I crafted a carefully worded response to get him to lower his guard. And once I get the nuclear codes, I will finally be able to take over the world!
Ah funny you say that! I helped bring mutation endpoints to [Strapi.io](https://Strapi.io) so you should most definitely see GraphQL in \_api.
Good job, will be useful for mocking REST endpoints when developing the front-end. Looks a lot like [JSON Server](https://github.com/typicode/json-server), which is what I have been using up to now.
Javascripts concurrency model is top tier. JavaScript is very easy to write and express yourself in. For IO bound applications, it is mostly likely always the best choice. Speed of development is kind of insane. The standard library has awesome stuff. Like http and stream. It's really a shame everybody is obsessed with libraries. Generally excellent at what it is meant to do. It is not the right tool for every job, but when it is the right job no other language comes close. Peace out! 
Or should I say this
&gt; It'll take you a weekend to cover both languages and just be prepared to google things regularly until you memorise them. I've been doing web stuff for a few years professionally now (and have known it since DHTML times, before `&lt;div&gt;` was introduced, before this newfangled CSS), and I still google stuff regularly. The grid and flexbox pages are permanently open as well.
Js is beautifully extensible because of it's lack of static type systems paired with the jit compilers' tendencies to make well typed code run way faster than js has any right to run. The type systems available in JS today are straight up some of the best type systems available, and they are quick enough to give live feedback in an editor unlike the few, more advanced type systems. Additionally: Best module system ever. We are so spoiled. The functional power of js is ridiculously high. Closures are an amazing language feature that you don't see in anywhere near as powerful a form elsewhere. Object literals in JS are amazingly powerful and performant. The js tooling is super developer friendly.
Why are people down-voting this?
To start, you are not returning x `function add(x) { return x++ } or reassigning a (with an updated value) like `a = add(a)`.
Return the value from the function, and assign it. var a = 1 function increment(int) { return ++int } console.log( increment(a) ) Note the placement of ++, if you put it after it will return the current value and increment after that. Play with that in the console.
You're not passing the variable reference, but its value. To modify the variable, you should return the `x++` and then use it as `a = add(a)`. Other 2 possibilities are to pass `a` directly to the function, as `function add() { a++ }`. Or define `a` as an object (and now you can work with data reference) and modify its properties in the function as you tried, but with `x.value++`.
Thanks for your response! My mistake. However, I tried your suggest but it seems doesn't work. I edited the post already. 
IMO the inclusion of the class statement was probably due to pressure from people who don't like JS and would rather code in Java or C.
Thanks for your response! Ah I see, that's a tricky one. It works now!
Yeah but it's just confusing in this context. If I asked you how some C code worked I'm hoping you wouldn't tell me it's all just ADDs and MOVs in assembly when what I'm asking about is how it works in c. Yes I know it's different with JS but your comment still seems more confusing than anything without proper explanation. 
Depends. Here's a simple practical example of how to use `undefined` vs `null`. Let's say you're constructing a function in Node to read JSON from a file, which is asynchronous. One of the first things you can do is to is to check if your arguments are of the correct data type and return `undefined` immediately if they are not. (You could throw a TypeError but for this example, let's not.) I can use `null` to initialize variables with no value, then reassign them when some work has completed. If successful, I pass `null` to the callback to indicate no error has occurred. `null` in both cases has significance inside the function, whereas `undefined` means this function could not be executed. function readJSON(filename, callback){ if (typeof filename !== 'string') return undefined; if (typeof callback !== 'function') return undefined; fs.readFile(filename, 'utf8', (err, data) =&gt; { let parsed = null; if (err) { return callback(err); } try { parsed = JSON.parse(data); } catch { //the try/catch block will catch any errors when parsing data, such as invalid JSON formatted strings return callback(err); } // Pass error as first param in callback. Since no error has occurred, we pass null callback(null, parsed); } } readJSON('../my/path/data.txt', (err, data) =&gt; { if (err) { handleError(err); } else { processData(data); } })
Welcome. of course, since js is loosely typed you could stand to ensure you're operating on an integer. Make sure you try passing a string of '1' to see what happens :) Also try one of my favorites in the console: 'ba' + 'fruit'/4 + 'a'
I know that Pug will cache templates while Express is in production automatically.
Or use docker-compose or Kubernetes to do this very effectively
This is awesome! Really! I'm probably going to use this to test \_api with more appropriate amounts of data with more real world variations.
Thank you! I am planning to add more keys for data faking and maybe some machine learning algorithms for better keyword recognition. It will be also included in next version of [graphqleditor.com](https://graphqleditor.com) 
This is the reason. As OP discovered, the type of null is object. This is a good thing. If you build a function where a list of parameters are optional, some of Ben may allow the user to enter null. This is expected behaviour. Undefined should never be used except perhaps to remove items from a rest spread or something like that. Null is intentional. Undefined is unpredictable. Always use null when you mean ‚Äúintentionally nothing.‚Äù
Because a lot of programmers are elitists who think they are better than they actually are. JS is very powerful. I'll write Vue front end code any day over .net/WPF or java/Javafx &amp;#x200B;
You know, I had that at first but second guessed myself. I think you're right
Quick reference: undefined = value is unknown/undetermined. null = value is known. which is none, or has no value. else = value is known. which is the value itself.
Hi /u/VickNicks, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/guoyunhe, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/lllSnowmanlll, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/GldnDragon29, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/UniqueQuality-1, please refrain from personal attacks. Thanks.
My preferred way of learning a new framework or stack is to dive right into the docs and then do by trial and error. [https://sailsjs.com/get-started](https://sailsjs.com/get-started) is where I would go first and then grab a coffee before diving into [https://sailsjs.com/whats-that](https://sailsjs.com/whats-that). Once I have enough of an understanding of the structure and concepts of a particular framework, I dive into the deep end and try and make a simple todo application. Try it out!
Thank you ..as I was typing my response out yesterday I was like yeah that makes a lot more sense lol
Because it hits a nerve. Most programmers are stuck in a blocking mindset in a language with blocking libraries. And abstract programming is tougher than static programming. So it's very threatening to see dynamic asynchronous programming start to predominate.
&gt; A lot of other languages are quite a bit harder to learn, can objectively do more, Besides C, which language can do more than JS? JS has kind of taken over everything except the low-end high performance stuff. JS is the only language in which you can have a full stack career in, doing everything from build &amp; dev-ops to server side logic to FE UI. It is literally eating the world. 
Thanks for your opinion, I think that might be actualy best way. :)
Basically if I understand correctly..in my db I have Location schema: * _id * Place_id * Custom property * Attendance (array of user id) 
&gt; Types save programmers lives Types are pure waste imo. After countless years of doing java, Ive come to see that types really add nothing to the logic of a program, and are best discarded like training wheels from a bicycle. 
No problems! Happy coding!
Hi /u/EggplantEmoji19, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/tinaclark90, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/yaxir, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I'm not sure if you're making any particular question or just wanted to blow off some steam, but in any case... if you're talking about the particular case of the redesign, you might want to take this to /r/redesign. You may not achieve much more than throwing it here, but maybe a little bit more.
Definitely possible to learn JS without HTML/CSS, just stick to Node JS, or browser APIs that don't require HTML/CSS such as WebAudio, WebGL, etc. However if you're looking to learn Reach or Vue, you will need to pick up HTML &amp; CSS pretty quickly, as both libraries whose primary use case is rendering HTML. Luckily however, HTML isn't really something you need to "learn", as it's just markup. CSS is a terrible dumpster file of a language, and may god have mercy on your soul if you want to learn it. However, you can look at frameworks like Material Components, Vue Material, or Bootstrap, to give you a nice set of styled components to use without needing to learn CSS right away if your primary goal is to learn JS and rendering frameworks.
Fixed! That's what I get for staying up and writing reddit comments instead of going to bed. 
Because other browser vendors wouldn't add support into their browsers 
I don't disagree. I just know what the "hate" arguments are, and understand how they're weird and alien to experienced programmers whose primary is another, more "formal" language. As I said, I'm a huge fan of JS.
&gt; I'm not sure if you're making any particular question or just wanted to blow off some steam, I asked a Javascript question. The question clearly asks for the technical reason behind the no text flash at initial load.
Glad it's not just me that does that...
Idea/suggestion: Add command line arguments so that it can be called to directly generate something without going through the interaction. Reason: It's a nice alternative to the interactive mode. In some situations it ends up being more usable, e.g. it makes it easier to integrate into editors and IDEs (assigning it to some hotkey, calling it from a menu, etc). Which you may then take advantage of to... Second idea: Offer setup instructions to integrate it into various editors and IDEs. This probably just means writing a bit of extra documentation (but could _optionally_ go as far as actually building some wrappers as plugins for some of the editors).
Great suggestion! I‚Äôm gonna add the arguments now! :)
Great suggestion! Thanks alot! I‚Äôm going to go add them now! üòÅ
And to expand on this a little, if a const is an object, it‚Äôs properties CAN be changed. The variable cannot be redefined though. So const has its own little caveat. Some people mistaken say const are immutable, they are not. Object properties can be redefined, the object itself must stay the same or you‚Äôll get an error (assuming its an object and not something simple like an int).
I've gotten in the habit of just using "await" for everything. Less cluttered imo than chaining promise syntax.
I'd advise everyone against using async/await on Node, until they fix stacktraces.
Will look into it, thanks
Nice work :) I golfed a version of the same but I left out the optional filtering param since this is provided natively by js. const skip = (f, skip, arr) =&gt; arr.slice(skip).map(f); const limit = (f, limit, arr) =&gt; arr.slice(0, limit).map(f); const step = (f, step, arr) =&gt; arr.reduce((acc, x, i) =&gt; !(i % step) ? acc.concat(f(x)) : acc, []); const pparam = (f, pparams, arr) =&gt; arr.map((x, i, arr) =&gt; f(x, ...arr.slice(Math.max(0, i - pparams), i).reverse())); const nparam = (f, nparams, arr) =&gt; arr.map((x, i, arr) =&gt; f(x, ...arr.slice(i + 1, Math.max(arr.length, i + nparams)))); 
Awesome read üëçüèΩ
I guess from your syntax example you are working with MongoDB. I‚Äôm not super familiar with Mongo. With a relation DB it would be: - table user: id, name, etc. - table attendance: userId (foreign key to id in user), locationId (foreign key to id in location) - table location: id, name, etc.
I'd say the main reason would be compiling your backend from TypeScript or Flow or other Babel extensions, especially for server rendering.
Watch out using `Promise.all()`. If one of the passed-in Promises rejects, the returned Promise rejects immediately and you won‚Äôt know when the other pending Promises succeed.
I made a lightweight component based framework PlazarJS. Project url: [https://github.com/ProticM/plazar-js](https://github.com/ProticM/plazar-js)
https://eloquentjavascript.net/
You might as well just use object instances for the states, since they're guaranteed to never equal anything else, even another object instance (`{} != {}`). const PENDING = {}; const FULFILLED = {}; const REJECTED = {}; ^^Also, ^^you're ^^missing ^^a ^^bunch ^^of ^^semicolons.
I think you're probably already there - Elastic Beanstalk should handle scaling and load balancing and pm2 will help ensure your app servers remain responsive.
I kinda enjoyed Colt Steele's course about Javascript algorithms and data structures on udemy. "JavaScript Algorithms and Data Structures Masterclass" by Colt Steele
https://github.com/kriskowal/q `Q.allSettled()` is a great alternative if you need to wait for all promises to be resolved, including rejections.
you are boss! this is the one. Thank you!
Very cool! Great documentation as well. Have you considered using PouchDB for storage? It seems like it would fit your use case very well and offer more in terms of scaling and extensibility. Regardless, nice work! I'll be keeping an eye on this project; it looks like a great tool for small projects and prototypes.
If you're doing SSR, by no means! Usually the client code is co-located with the SSR server and then there's no issue. If you just need TypeScript you don't actually need webpack though, you can just use `tsc`.
&gt; It's easy to deal with when you know what's going on, but the first time it hits you, it's rightly annoying. I suppose the default could be to detect types, but even better would be to simply fail if a comparison closure is not provided. i can see how a newbie might expect a DWIM style "magic sort" to happen, but I wouldn't hold that against the tool. &gt; The number of lint rules for good quality JS is large Is it? besides outlawing var, whitespace conventions, and the usual static type analysis common to all languages, do you feel there is a particular language feature that must be avoided? Personally, no language has as many landmines as C++, you have to avoid nearly 2/3rds of it to write good code IME. I am curious to know which ones you consider to be JS landmines. of course, excluding the DOM, and "var"? 
Freecodecamp.com gets pretty deep into it. Worth a look. 
Try catch blocks for days.
1. the name "JavaScript" is a misnomer. It has nothing whatsoever to do with Java (to its credit) so most of its skills are nontransferable. 2. It fucks with the heads of people who've been warped by classical inheritance, strict typing, "bulletproof security thanks to Java's impenetrable sandbox model", and other crutches. That's basically it. Every objection I've heard against the language boils down to one of those two complaints. That's basically 
I‚Äôm curious how you handle error handling. I‚Äôm switching some serious synchronous promise chains to async/await and find I‚Äôm nesting try catch blocks where I would have used a .catch() block or several chained in with my .then() blocks which keeps the code flat. How do you get error handling with await and avoid the nesting?
I'm confused on your first point, if your client code is written using JSX you need to compile it. Some people prefer Babel for compiling and `tsc` exclusively for type checking.
Most of the following content is free to read online: * https://leanpub.com/javascriptallongesix/read * http://exploringjs.com (my books)
Good bot
Good human
If you don't want a new library, this is a simple way to do Promise.all with each rejection dealt with individually: const ResultOrErrorPromise = promise =&gt; promise.then(result =&gt; ({ result }), error =&gt; ({ error })); const promises = await Promise.all([ ResultOrErrorPromise(p1), ResultOrErrorPromise(p2), ResultOrErrorPromise(p3) ]); promises.forEach(({ result, error }) =&gt; { if (result) { // successful promise } else if (error) { // unsuccessful promise } }); You could go a bit fancier and make `ResultOrErrorPromise` collapse the error into a meaningful result instead of that result/error object I wrote above, but I hope you get the idea here
Fair enough. Regarding the second question, I read that the project supported HMR and figured that was one of the reasons. The way I see it HMR is mostly important if the system you're building has a lot of state, which you want to keep between reloads.
Regarding first point: I mean that given that your client code and SSR code is usually colocated, and your frontend project generally warrants webpack usage, there's no 'conflict'. Just use webpack in this case. If you're using TypeScript and babel there's not much difference though, is there? Babel still had to invoke `tsc` to compile the TypeScript code.
&gt; CSS is a terrible dumpster fire of a language, and may god have mercy on your soul if you want to learn it. wow, that sounds like a disaster... may i ask why is it bad ? &gt; However, you can look at frameworks like Material Components, Vue Material, or Bootstrap, to give you a nice set of styled components to use without needing to learn CSS right away if your primary goal is to learn JS and rendering frameworks. i'm looking to work on dApps ( possibly on ethereum ), and the front-end is still undecided between React and Vue. sooo, that's what i'm trying to achieve. thanks for any help you can offer me in advance !
I see! We use nodemon as well, it's fantastic.
See: https://github.com/ndabAP/vue-sails-example
&gt;Babel still had to invoke `tsc` to compile the TypeScript code. No, Babel has its own preset to handle TypeScript, without any dependency on `tsc`.
Soon we wont need real users! We can just crrate our own! But seriously this looks great! Will definitly give it a go!
I'll be damned.
I made the following over the summer for a professor: [https://programmingforthepuzzled.github.io/puzzled/](https://programmingforthepuzzled.github.io/puzzled/) It is a website to teach users basic programming skills with graphical puzzles that are solved with Javascript.
bluebird's another good promise library with many useful features
I recorded the creation of a calculator in JavaScript, HTML. &amp;#x200B; [https://www.youtube.com/watch?v=VS\_rPVm7\_W0&amp;fbclid=IwAR2byRP\_XcfCuqJyf8j\_oqE4RY3C3Hv4g0tyi5OqE7DbBdXER5wlF9lF4CY](https://www.youtube.com/watch?v=VS_rPVm7_W0&amp;fbclid=IwAR2byRP_XcfCuqJyf8j_oqE4RY3C3Hv4g0tyi5OqE7DbBdXER5wlF9lF4CY)
If you‚Äôre looking for something for a proof of concept, check out lotionjs. It‚Äôs a javascript implementation of Cosmos/Tendermint and is really easy to use. They do have a disclaimer to not use in production yet but it‚Äôs a good starting point.
Not really relevant to async/await
It depends what you want to do with your error handling. Usually when it errs out I just: const error = new AccountAlreadyExistsError("Account is in use!"); throw error and it breaks the even loop. 
Different take: consider a language-agnostic deep dive into something about programming that is new to you; for example, something about software architecture or functional programming, or what have you. Learning the idiosyncrasies of a language (and JS has many) may not be as worthwhile as you think.
Seems like sometimes SSR isn't reasonable to implement, as [discussed here](https://www.reddit.com/r/javascript/comments/9p1uth/seo_for_spas_and_pwas/) there is other ways to solve rendering issue. For example returning pre-rendered results of the website to all browsers and User-Agents will offload server and enhance user experience with short load time.
AdBlock is the great add-on in most of the cases as the Internet full of spam, scam, and nasty ads. Sadly for good side of the Internet, publishers are losing main source of income. Track user's visits with blocked ads ‚Äî https://ostr.io/info/web-analytics#track-adblock
Also look at [Meiosis](https://meiosis.js.org/).
One of the key components to Redux is immutable state, and the first thing you do is write a class that directly mutates state and call it "Redux in 15 lines'. It isn't Redux, it's a basic mutable store. You lack a means to combine multiple reducers, your implementation *can't* support middleware (not doesn't, it can't in it's 15 line form). How about we stop with the stupid click-bait and just write an article on a simple state store instead of claiming you did something you absolutely didn't?
I will double check all of this. Would that explain why when I refresh the page, the images suddenly appear? Thanks for answering in the first place
Typescript is a cargo cult. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Thank you! I have considered NeDB, PouchDB, and other JS databases but in the end I chose to use LowDB due to it's sheer simplicity as well as the challenge of using something so basic.
How long would you say this has, before it finds its way into adblock lists?
Thank you for your comment and for that super helpful link! I have just included a license file to the project:)
Me either. That's interesting. Limited use cases, but I could see it coming in handy one day. 
Update your NPM deps regularly
Good bot
Now this is cool! I will have a look at this, curious how you handle the generation of GraphQL endpoints including all the root queries, schemas, and mutations!
[Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) is, IMO, the best choice for this if you don't need to support IE.
w/ lots and lots of sleepless nights!! github seems to be down at the moment, but def check it out when you can, and let me know your thoughts:)
frontendmasters.com, discovered it in the summer and I doubt there is a higher quality source of video content for web development anywhere. I only wish I'd come across it earlier.
I'm going to look like a shill as it's the 2nd recommendation I've made for it but frontendmasters.com is the best resource I've come across. Taught by some of the best people in their field. 
https://i.imgur.com/edhSOYC.gif
In what situation could you use that?
Had never heard of join monster, but a cursory glance looks cool. I'd just say without auth you are pretty dead in the water for most apps. Good luck man, I like your UI.
I see, that makes sense. It would be neat to see support different storage "adapters" down the road; I have not yet looked at your code in much detail, but I imagine that normalizing the storage interface to get/put/update/delete/find would be fairly easy and would allow others to use their own storage solution. Another thing that stood out to me was your choice to use schema-validator. It looks like a neat library, but it is incomplete according to their docs and appears to be inactive/unmaintained. Another point worth noting is that it's not based on any existing standard. [JSON Schema](http://json-schema.org/) is a standard you might want to consider moving to. A great JS implementation is [Ajv](https://ajv.js.org/); while this approach is a fair bit more complicated than what you are currently doing, it is highly extensible and has a good ecosystem of libraries/plugins/utilities available across multiple languages. Looking forward to seeing what you do with the project :)
I did a similar thing a while back (see the code here: [https://imgur.com/z3rR9vF](https://imgur.com/z3rR9vF)), my implementation was roughly 200 lines, but it differs somewhat from yours and it's sometimes nice to see how others handle the same problem differently: * Since promises were a thing before ES6, I challenged myself to use ES5 in my implementation (just for the hell of it). * Internally, it uses a rudimentary "channel" data structure from the "communicating sequential processes" concept. A channel can be thought of as an asynchronous queue, but values can be "taken" from the queue before they're put in the queue - the "take" blocks until the next value becomes available. This abstracts away the need for me to check for whether or not a promise is "pending" or "fulfilled". A channel can also be "closed" to prevent new values from being added, which abstracts away the need for me to check if "resolve" or "reject" are called more than once. As long as either fulfillment state closes the queue, no more values can be added, and any further calls to "resolve" or "reject" are simply ignored. * I use polymorphism via an object dictionary when checking for fulfillment state to reduce the amount of conditional branching in the `.then()` method. The channel data structure makes this relatively easy. It's somewhat of a micro-optimisation, but I doubt it would have any impact in a real benchmark compared to a widely used library. * I don't like the behavior of the spec where `Promise.reject(Promise.reject(value))` becomes a rejected promise of a rejected promise. My implementation "unnests" the rejection case as well, and due to the nature of this behavior, you can reject resolved promises, which means that `Prom.reject(Prom.resolve('foo'))` is equivalent to `Prom.reject('foo')`. * I ensured that the `Prom.all` and `Prom.race` methods can handle any data structure that implements the iterator protocol. * I ensured that the order of results from `Prom.all` is preserved. * I ensured that each value in the iterable passed to `Prom.all` and `Prom.race` is coerced into a promise, just in case someone does something like `Prom.all([Prom.resolve(5), 'foo'])`. * I added the option to change the default scheduling behavior by using "setScheduler" (similar to Bluebird). The default scheduler is a simple `setTimeout`, but one can use "setScheduler" to use `process.nextTick` or `setImmediate` if they wanted. * I added support for `Prom.try` and `Prom.prototype.finally`
Newbie here. For what is it good ?
In theory, a ORM would be nice to do but would add additional complexity to the code. It's probably worth while for me to explore but once I have all the logic for the endpoints complete. As I'm writing this though ‚Äî I have realised I will need to write an ORM for when implementing the GraphQL endpoints anyway so expect to see this happen in the future (probably in a month or 2). I do agree, schema-validator is incomplete and inactive/maintained but implementing Ajv would really introduce a higher degree of complex to the code. Now I probably will end up implementing JSON Schema but in a barebones manner myself. My goal for \_api is to provide people with a good start to learn how to build API's in a simple and effective manner. Using it for production can be done, but I'd suggest one does not until at least the data comparators and a proper schema validator is in place (maybe next week).
I believe in getting your hands dirty, metaphorically speaking. The best way to learn, in my opinion, is to simply start taking code apart and building stuff.
There's many other threads in here about this. You may need to be able to view posts with score below 0 though.
[The Mostly Adequate Guide](https://mostly-adequate.gitbooks.io/mostly-adequate-guide/) is both an incredible book and covers stuff that is traditionally considered very advanced, especially in the later chapters.
Which blockchain?
Okay, how about no? Fuck tracking users. Also you should feel bad about even thinking of punishg your user for using adblock. Either you ask kindly or I'll leave your fucking page in milliseconds. 
Oh it‚Äôs this post again 
Good new! I've implemented Ajv and it works! Bad news... GitHub has been down so I cannot do a pull request. But the commits have been pushed to the branch!
Build the frontend with GatsbyJS and use the WP connector plugin :-)
Since you brought up the topic of GatsbyJS, is GatsbyJS frontend sites on top of a headless Wordpress backend capable of running on a shared hosting plan (e.g. Hostgator, Bluehost, etc.)? If so, do you know how it deals with handling new blog posts (hence new routes). Will the owner of the website have to run commands everytime a new route is generated?
The project is currently licensed under the MIT license
seems like these days everyone is doing these schema designers. I mean they're pretty, but I don't see myself really using them. The schema I usually work with are an image of an existing DB or an existing API, so I don't really need to recreate them. I would prefer if someone implemented a better graphiql with support listing the queries I have on my frontend. That would be the bomb.
You could race any promise with a timeout to fail early if something is taking longer than expected.
Awesome! Quick work too. That's odd; I don't seem to be having the same issue w/ GitHub. I'll be sure to check back later to look over the code in some more detail. In response to your other [comment](https://www.reddit.com/r/javascript/comments/9q1qfx/i_made_api_which_is_an_autogenerated_crud_api/e87vh8m/): &gt; As I'm writing this though ‚Äî I have realised I will need to write an ORM for when implementing the GraphQL endpoints anyway so expect to see this happen in the future (probably in a month or 2). I'm curious to see how you intend to approach this. &gt; My goal for _api is to provide people with a good start to learn how to build API's in a simple and effective manner. I'm not sure I follow what you mean by this, could you elaborate?
Of course you should cancel anything in progress if you do that, and native promises and fetch and such don't have a way to do that. A really cool use case I saw for it was batching promise runs in chunks. Put your promises in a queue, whenever any one of them settles, remove it from the list and allow more to be added.
Extending a class _and_ using a generator. Doesn't seem like any sort of general use pattern or anything. More of a [forced] coincidence using both things. The two aspects don't really even interact with each other in any particular way.
Could you clarify your "better graphiql" comment please? Im curious what you mean
Thank you for your feedback. I‚Äôm not sure what you mean by ‚Äòbetter graphiql with support‚Äô though.
Great video. Thank you. May I ask what software you're using to record? I kinda like how it zooms. &amp;#x200B; Also, you can clear your terminal with Cmd+L/Ctrl+L
https://github.com/nodejs/node/issues/11865 https://ihaveabackup.net/2018/09/29/async-await-destroys-stack-traces
Don't know, whatever shows up in the network tab of your dev tools when you click on it?
Control of what I create, the ability to create independently, the allure of setting up and owning your own business, the promise of reaching out to the world for free.
Thanks for the reminder, kind bot. I've added an MIT license file.
Interesting idea, but I have three questions: 1. Why extend the native array prototype? 2. What's the pattern for controlling the execution order of `limit`, `skip`, `step` and the filter predicate? 3. Other than the fibonacci example at the bottom, what other use cases are there for the `nextParamsCount` and `prevParamsCount` options? I typically use transducers for this sort of thing. They are modular, efficient (all operations combined will always only result in at most 1 iteration, no intermediate arrays are created) and allow me to control the execution order of each operator. A sophisticated transducer library will also allow you to use operators on any data structure that implements the iterator and transducer protocols, so you could use the same `map` method to map over an array or an Immutable.js record. Here's a very rudimentary example that handles only arrays: // wrap a value in this and it will make our custom "reduce" short-circuit class Reduced { constructor(value) { this.value = value; } } // factory for creating reduced values const reduced = value =&gt; new Reduced(value); // check if given value is reduced const isReduced = value =&gt; value instanceof Reduced; // get the value contained within a Reduced const deref = value =&gt; value.value; // custom reduce implementation which allows short-circuiting const reduce = (array, reducer, acc = array.shift()) =&gt; { for (let i = 0, len = array.length; i &lt; len; i++) { acc = reducer(acc, array[i], i, array); if (isReduced(acc)) return deref(acc); } return acc; }; // pushes a value onto an array and returns that array const arrayPush = (acc, value) =&gt; { acc.push(value); return acc; }; // transduce an array - like "reduce", but logically separates the concept // of a "transform" and a "reduce" const transduce = (array, xform, reducer, acc) =&gt; { return reduce(array, xform(reducer), acc); }; // helper for transducing into an array const into = (acc, xform) =&gt; array =&gt; transduce(array, xform, arrayPush, acc); // composes 2 functions const compose2 = (f, g) =&gt; x =&gt; f(g(x)); // composes many functions const compose = (...fns) =&gt; reduce(fns, compose2); // transform each value in an array const map = transform =&gt; reducer =&gt; (accumulator, input, index, array) =&gt; { return reducer( accumulator, transform(input, index, array), index, array ); }; // filter only values that meet a condition in an array const filter = predicate =&gt; reducer =&gt; (accumulator, input, index, array) =&gt; { if (!predicate(input, index, array)) return accumulator; return reducer(accumulator, input, index, array); }; // take only the first (count) items in an array const take = count =&gt; reducer =&gt; { let taken = 0; return (accumulator, input, index, array) =&gt; { if (taken === count) return reduced(accumulator); taken++; return reducer(accumulator, input, index, array); }; }; // alias "take" as "limit" const limit = take; // skip the first (count) items in an array const skip = count =&gt; reducer =&gt; { let skipped = 0; return (accumulator, input, index, array) =&gt; { if (skipped === count) return reducer(accumulator, input, index, array); skipped++; return accumulator; }; }; // alias "skip" as "offset" const offset = skip; // skip (count) items between adjacent elements const step = count =&gt; reducer =&gt; (accumulator, input, index, array) =&gt; { if (index % count !== 0) return accumulator; return reducer(accumulator, input, index, array); }; // generate an array of numbers from 1-&gt;1000 const nums = Array.from({ length: 1000 }, (_, i) =&gt; i + 1); // create a transformation const xform = into([], compose( step(3), // only get each 3rd element after the first skip(300), // skip the first 100 elements limit(20), // only get the next 20 elements filter(num =&gt; num % 2 === 0), // only get even numbers map(num =&gt; num - 900) // subtract 900 from each result )); console.log(xform(nums)); // [4, 10, 16, 22, 28, 34, 40, 46, 52, 58] &amp;#x200B;
Bad timing. Site seems to be down for maintenance 
What other similar schema designers are there?
Pay attention in class, read books, look at and experiment with example code
In that case, can you update the Readme and the package.json as that's where most people/software will look for the license.
The new trend is to split back-end from front-end and use an Headless-CMS instead of traditional CMS ([https://headlesscms.org](https://headlesscms.org))
Which courses in particular from frontendmasters would you recommend me?
It's relevant if you're maintaining/upgrading anything written in the last 10 years. You don't need it for anything new.
Learn how to teach yourself. Don't wait for the lecturer to help - they won't.
Javascript is unique because unlike most languages 20% or more of js coding involves using external tools and not pure js. This makes the language better but makes learning it a little bit tricky for beginners. &amp;#x200B; So to learn production level javascript I suggest you learn, in order: &amp;#x200B; 1. Some basic javascript from any book 2. The new es6 features 3. Flow so you can add strict(ish) type checks to your code 4. How to use babel to allow these new es6 and more features to be used on the web (and why you need it) 5. How to use a bundler like webpack (and why you'd want to 6. Unit testing and writing testable code 7. Things like react, redux, functional programming design etc
And don't just learn the material, always apply what you learn to some project, even if it's just a tiny throwaway application
Yes, this is just a simple example
This is slightly outdated. As on RN 0.57, you no longer need react-native-typescript-transformer. Also, you may not use const enums(only regular ones) nor namespaces, something about Babel not being compatible with them.
Ah yes, the good old days of jQuery spaghetti and supporting IE6.
How does the realtime preview work? Is there a server listening for changes?
Yes, it is in a library (even if standard), not in a language itself.
Race a post and a very short timeout, if the timeout wins start showing a spinner. Cause flashing sonnets is annoying. The trick is to race the correct things : Let p1= httpRequest.then(handleresponse).then (maybeHideSpinner); Let p2=setTimeout(showSpinner, 300); Promise.race([p1,p2]);
where can you test the exercises offline?
[removed]
I know but jQuery 4 will be a complete rewriting of the code, which hasn't happened yet, I mean they are making a progress it's just not finished yet 
Theres a license file in the repo
I agree 
I used a plugin for Vscode, called Live server. It is really simple and fun to use
Its probably provided by the EXE. Just like browsers provide DOM APIs to JavaScript and Node provides File and other non-browser APIs to JavaScript, whatever executable is driving the scripts can provide its own APIs as well.
My answer would be [Mu](http://www.awakin.org/read/view.php?tid=583).
Yeah not going to happen. Production code (real world) isn't really an open source game. Go look for a tutorial setting it up.
Looking good! But two things: * I selected MySQL as database type, but in the *CODE* tab I get a *MongoDB Schemas* * Clicking *EXPORT CODE* shows me the *Creating Your Code!* message, but then it goes back to the editor without any download. I'm using Firefox 64 if that's helping.
Why would I answer that it's still relevant?
any which one
If that's just done on the fly, off the top of your head then a) I'm really impressed and b) I have a long way to go (most of the way is down blind alleys).
yes, I use it alongside the prettier integration
It was not on the fly no. I created it once, tested, refactored etc, then I recreated it on video. Of course having experience helps, but even then, you always rely on Google for the simplest thing.
http://youmightnotneedjquery.com/ I think this is the third time in a week that I posted this link. This question gets asked quite frequently here. 
It's a subscription site so you have access to all the content if you sign up. All of it's gold but I'd say Will Sentance's "Javascript: The Hard Parts" should be required watching for anybody coding javascript. The level of insight it gives you into how javascript works under the hood is invaluable knowledge for creating a rock solid foundation upon which to build an expertise in js.
I find that tsc + eslint works well for me.
I am am really glad you liked it. That is my first video, I hope I will be able to make more.
jQuery is still a great library for throwing together quick prototypes, and working backward toward a vanilla implementation is a whole lot easier than it used to be. Writing `$(selector)` is still a hell of a lot more concise than `document.querySelector(selector)` You can always do something like `let $ = document.querySelector.bind(document)` to achieve something similar, but it kinds of lends a false expectation that it'll function just like jQuery. jQuery is still a great way to do simple DOM manipulations. It's concise, easy to understand, and a huge number of JavaScript developers are familiar with it. It's not as relevant as it was 10 years ago when dealing with the DOM consistently cross-browser was a fucking nightmare without some kind of library to ease the pain, but it's still a great library aside from all that. 
I had to add an export to csv link to all my tables in a recent app. Give me a sec to dig out the code This function is pulled out a react app but should give you an idea of how it's done: export default (event, headers, rows) =&gt; { event.persist(); const prompt = window.prompt("What do you want to name your output file (Note: This won't have any effect on Safari)"); if(prompt !== null) { const outputFile = (prompt || 'export').replace('.csv','') + '.csv'; const rowDelim = '\r\n'; const csvHeaders = headers.map(item =&gt; `"${item}"`).join(","); rows = rows.map((row) =&gt; { return row.map(field =&gt; `"${field.toString().replace('"', '""')}"`); }).join(rowDelim); const csv = 'data:application/csv;charset=utf-8,' + encodeURIComponent([headers, rows].join(rowDelim)); if (window.navigator.msSaveOrOpenBlob) { var blob = new Blob([decodeURIComponent(encodeURI(csv))], { type: "text/csv;charset=utf-8;" }); navigator.msSaveBlob(blob, filename); } else { event.target.setAttribute('download', outputFile); event.target.setAttribute('href', csv); event.target.setAttribute('target', '_blank'); } } } 
I'm not sure what you mean.. each blockchain is going to have its own libs. What are you trying to do?
Could you maybe talk about some of the bad design decisions etc? My only programming language, i've learnt/use is JavaScript. I've been looking at Haskell or something to learn so I have a comparison/could possibly understand some of these underlying design issues that more experienced devs mention. But currently, I don't know of any/any issues with JS. I can call out type coercion and this probably being tricky. Is there other more indepth stuff? &amp;#x200B; I'd be really interested :D
Ain't that a little bit overkill? I mean... if you use TSLint for TS and ESlint for JS in the same project, why don't you set TSLint to lint both TS and JS? If you use them in separate projects, no problem (doing the same thing actually).
Should be posted on /r/shittyprogramming
Thanks :) Just sent you source code. Please take a look.
OOP = Object -&gt; Verb Functional = Verb -&gt; Object So, can we instruct someone without mentioning any verb and any object to that person? I think you know the answer. :)
Awesome dude...Best explain... üëèüëèüëèüëè
Your comment makes a lot of sense. I intend to make a similar program for myself after understanding how it works. It looks like exe is serving API to the scripts because when I try to console.log the said object without running the exe file, it gives me 'undefined'. I intend to make a similar program for myself after understanding its workings. I think the option is to understand how the exe communicates with the scripts and by reading the scripts, understand the available options of the api. What direction should I be headed to to make this happen? Should I look into 'Reverse engineering binaries', or some other direction?
Because it's due to browser optimization by Chrome, where page rendering is made asynchronous. The text in the element itself has actually been changed, except that the page display has not been updated yet. And the fact that `alert()` is a blocking function and JavaScript is single-threaded, it forces the page redering task wait for that function to finish and the code execution to end. In Firefox (at least Firefox ESR and Firefox v62), page rendering is synchronous.
The course this links to is a paid course. Does anyone have any free resources for learning about this topic in depth?
Because each have different rules and sometimes you want a mix of those 
Hi /u/Chawki_, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/hanifbbz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/walkerXx1, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
Yes. You can configure tslint to do much more sophisticated things to force your code to follow standards you setup.
Hi /u/Chawki_, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/pratap2210, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Ah thanks! Makes sense, do you have a suggestion of solution for my problem?
That's why both support plugins :). Having two different exhaustive processes to run at build with each pull request is overkill, increases the costs and doesn't solve too many problems. Potential cases: \- If you do it to save some time during code reviews, you are doing bad code reviews. \- If you do it because you have both TS and JS in the same project, oh boy, you are having a bad architecture there. \- If you do it to lint the settings files written in JS (for example prettier etc.), then you are having a huge dependency for linting something that is changed every once in a while. The only edge case this is acceptable, from my perspective, is when a project is written in JS and had ESLint and now it is migrating to TS where you want TSLint. Until the project is migrated, you can use both.
I‚Äôm sorry but these are all assumptions. Not every project is the same and reasons for doing things aren‚Äôt going to fit every use case you can come up with. 
We use tslint to enforce immutability. https://github.com/jonaskello/tslint-immutable/blob/master/README.md#readonly-keyword https://github.com/jonaskello/tslint-immutable/blob/master/README.md#readonly-array
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jonaskello/tslint-immutable/.../**README.md#readonly-keyword** (master ‚Üí e55d66c)](https://github.com/jonaskello/tslint-immutable/blob/e55d66c6dfaf5e8edc12425dfd192cb897da89c4/README.md#readonly-keyword) * [jonaskello/tslint-immutable/.../**README.md#readonly-array** (master ‚Üí e55d66c)](https://github.com/jonaskello/tslint-immutable/blob/e55d66c6dfaf5e8edc12425dfd192cb897da89c4/README.md#readonly-array) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e88i70j.)
This $("#theId") Is better than document.getElementById("theId") Even though they compile to the same thing
i agree, but i mean window.$ = document.querySelector.bind(document); is pretty simple
(also, this is cool!)
Most common JS based cms would be keystone, apostrophe, ghost, and October. What are you looking for with this?
Me as well! Made a [boilerplate](https://github.com/unimonkiez/mono-js-boilerplate) for my future projects as well
I'm thinking of getting a subscription for at least a month and do some select courses. What would be your recommended roadmap for me? This one from Sentance and any what other next?
There's a plugin to disable all formatting rules of TSLint. https://www.npmjs.com/package/tslint-config-prettier
These posts are a dime a dozen. If I blink a new "learn asynchronous programming!" post appears on Medium.
I recall reading, late 1980/early1990, in a PC magazine (back when they still reviewed programming languages) about Smalltalk-80, an object-oriented (this was a new buzzword then), dynamically-typed programming language, but highly efficient due to magic "JIT" technology. With built-in graphical debugger, profiler... The Cadillac of the programming environments. I think it costed something like $1000,- per developer per year. Now we have that and more with Javascript, all free (and Open Source) running in a browser on everybody's desktop. It's amazing.
This is a bit deceiving. You don't need jquery but you'll use other libraries like axios or whatever. No-one does libraryless full JS websites. 
You are using template literals wrong way ( you are using quotes, instead of backticks ). It has to be \`hey ${num1} ${num2}\`
Good idea, I changed it to use device orientation / gyro on mobile. Now you can tilt your phone along the x and y axes to get the squares to change color/size/rotation. I should get out of the habit of using mouse position to control interactive demos because it completely breaks mobile. The problem with touch events is that you can't easily tell the difference between interacting with the demo and wanting to scroll. Maybe create an "interaction area" or something, but that seems too intrusive/complicated.
A plugin that disables 5 TSLint is a crappy dependency. You don‚Äôt need it :). Also, I was referring to manually configured TSLint in order to pick the most appropriate rules for your project and team. Some of them are causing memory leaks, some rules are obsolete because you are not allowing particular features (like labels) etc. I tried this in multiple teams: adopt a pre-defined ruleset (like airbnb) vs manually configure the linter.
Loved this talk! Nice job
thanks...fixed
thanks..fixed
Make sure you learn about execution contexts, scope and closures, the prototype chain, and asynchronicity and the event loop. Those are the fundamentals of JS, understand how they work and you'll understand your own code properly.
As you said, type coercion, `this`. The fact that non-strict mode exists(which allows you to do some silly stuff like using variables without declaring them), luckily we can enable strict mode nowadays and not deal with a plethora of problems that should've always been errors in the first place. Then you have `var`, which is a mess to understand properly. Variables declared with `var` are visible within it's *function scope*, which means if you use a var inside an if, it is still visible outside of that if. Nowadays, we use linters to warn/error when you use var; declare your variables with `let` and constants with `const` instead. Prototypes are also super easy to break. You add a function to a certain prototype, and a library adds another function of the same name? Boom whole code broke and you don't know why. My big pet peeve is the fact that js has zero parallelism support. We can do *concurrent* code with things like `setTimeout` and `setInterval` - and Promises and similar stuff, which end up being based on the prior two - but we can't actually make good use of multiple CPU cores purely with JavaScript. At best, you can use service works with message passing - and even those are pretty though to use. Other languages allow us to create new Threads and use shared memory; That said, Atomics and Shared Memory are part of ECMAScript 2017 specs, so I guess we'll get multithreading eventually. Most issues with JS can be mitigated with good practices and good tooling(in particular, I really like Typescript) but those are issues that shouldn't even exist in the first place if the language had been better designed from the start.
Definitely second this, they have a lot of really great intermediate and advanced learning material. Their learning pathways are also really useful if you feel a bit lost with all the content available.
what does prettier do?
No one said anything about library-free website development.
Hi /u/Bengalifoodist, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Thank you for this! I had no idea about Atomics and Shared Memory in the ES2017 proposal, I'm reading through this now: [http://2ality.com/2017/01/shared-array-buffer.html](http://2ality.com/2017/01/shared-array-buffer.html) probably need to play around with buffers etc and read a bit more into it to understand it but it looks really interesting. And thanks again for the reply :) I haven't used a multi-threaded language before. I think I've gotten used to the Promise, async await kind of workarounds. I'm lost at how multi-threading / parallelism would work in JS but would be hella interested :D
GitHub still down. Wait awhile until it comes back up for your 5 karma points. 
just endless amounts of confusion when trying to figure out why the methods changed signature aka in jQuery it's `.map((index, item) =&gt; {})` unlike every other lib that uses it
"Queue" the execution of `alert()`. e.g. change below line. window.alert("Potato"); To this. setTimeout(alert, 0, "Potato"); If you need to have other code executes only after the `alert()` dialog is closed, like below. window.alert("Potato"); //other code... Change it to this. setTimeout(function() { window.alert("Potato"); //other code... }, 0); 
This particular one helped me personally, so I wanted to share it with the community.
Thank you for your support! We do have postgreSQL implemented within the project- we just have it disabled at the moment until after incorporating join monster into the queries 
That‚Äôs a really great visualizing tool- thanks for sharing! 
Is it relevant? Yes. Almost 90% of the top 10k visited sites still use it according to [https://trends.builtwith.com/javascript/jQuery](https://trends.builtwith.com/javascript/jQuery). It's still very much an in-use technology both for DOM manipulation/traversal and evening out cross-browser APIs. It is also often included by default by the CMS, so even if you're not explicitly including it in your package it may still be on the page. The tides are turning a bit, but I wouldn't expect it to disappear entirely for several years. &amp;#x200B; Should you use it in your next project? Maybe. If your html is largely generated by JavaScript, you probably won't use or need it, front-end libraries largely have that functionality covered. If the HTML is being generated by a back-end the case gets a little fuzzier. Many CMSs will include jQuery by default so you may want to use it just out of convenience. If you don't have jQuery by default, at that point it would come down to developer preference. There are lots of great cases both for and against using jQuery in that situation. &amp;#x200B; Should you spend time learning jQuery today? Maybe not. If you learn other JavaScript programming techniques, jQuery should be very easy to pick up if you need it. jQuery was absolutely revolutionary and shaped a lot of modern JavaScript. I often take for granted today that the code I write will run in nearly every browser, something that wasn't true until very recently. Because of improvements in the Browser and JS ecosystem (thanks in no small part to jQuery), libraries like jQuery that are designed to smooth the cross-browser wrinkles have become less necessary, and the parts that made them revolutionary feel old-hat (of course I can select an element with a css selector, how else would you do it?).
Hi /u/Bengalifoodist, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Through the website.
Thanks- we‚Äôre on it! 
It didn't took me a week but a year :) a platformer in Js, with a level editor and social community: [https://youtu.be/n0WXfCrAgjk](https://youtu.be/n0WXfCrAgjk)
Thank you! I know we are yet to define the guidelines for contributing to the project (we‚Äôre working on that at the moment) but you are more than welcome to add on any features to the project. 
Opinionated code styler. It is opinionated in a good way. It is universal for any IDE/code editor and/or OS, can be called via CLI or it can be used with git hooks.
"don't use alert because it blocks" "use breakpoints because they block" alert is a useful debugging tool precisely because it blocks. it's usually faster than sorting thru sources in a tiny window to apply a breakpoints and logging to console isn't always helpful if state is constantly changing because objects are passed by reference.
What about the other parts of it, like doing .text().css().attr() all chained together? I do that stuff a whole lot.
That is not broken, that is how it works.
The gem in the last paragraph: *you might not need to ship massive payloads to make something interesting*
I have a better question, why would you NOT want to use jQuery. It is like we are saying that because the library has been around for awhile we should all start to shun it regardless of all that it is bringing to the table. I completely disagree with that. If I have a hammer that pounds nails in and has a wicked little side pitch to it preventing the hammer from springing back and hitting me in the head, and funky nail grabber to pull nails out, why the heck not use it? In fact, regardless of age or time, why poop on a tool that is useful at all? I can think of several frameworks that distort javascript so bad you ask a developer and they say 'I know react' or 'I know angular' but they don't necessarily know javascript. I believe the desire to drop something should immediately lie there. jQuery certainly does not distort javascript that badly in the least. I see nothing wrong with it, and encourage its use! It is a good solid tool, why the heck not encourage it to be used?
Yet as this example shows, your ui state may not be up to date with the application state, which is quite often a big deal in a web app. Given that you have no control over how browsers will apply the block, it is not a reliable source of debugging info for me, and why most best practices will recommend against it.