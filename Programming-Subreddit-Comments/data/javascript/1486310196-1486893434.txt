The Ackermann function, among others, is not primitive recursive, so it is a bit more difficult to rewrite as iterative. In fact, to do that, it requires the code include a stack, which is sort of like using recursion.
SharePoint surveys have some of this capability 
I also did a write-up on StackOverflow that covers a bunch of these with links to the spec, for those curious. http://stackoverflow.com/a/32830772
I wanted to say always, since that is taught, but I haven't seen the formal proof, so I'm hesitant to simply repeat it. 
100 KB minified though. As much as I hate doing layout with CSS, I'll do it if it makes for a better user experience.
Just use it as a function. `load(props =&gt; ({}))(Component)`
Dude I've been wanting this for so long. Its so annoying having to work with REST at work after having seen the light with GraphQL. Very excited to give this a try!
http://www.qnamarkup.org/ - QnA Markup (http://www.qnamarkup.org) is a simple computer language written for lawyers with little or no programming experience. It transforms blocks of text into interactive question and answer sessions (QnAs). These QnAs can be used as stand-alone expert systems or in the aid of rule-based document construction. Plus, they can be fun, and the entire project is open source. Among other things, that means free. http://docassemble.org/ - A free, open-source expert system for guided interviews and document assembly, based on Python, YAML, and Markdown. https://www.guideclearly.com/ - based on Drupal - Help website visitors find what they are looking for with user-friendly interactive guides. All are interesting projects gestated in the legal space where there is a lot of work being done on decision trees to give legal guidance. edit - also found this - https://github.com/hungrymedia/interactive-decision-tree which is more of a javascript-y thingee. 
Absolutely fantastic job, man. Every now and then, either this subreddit or Hacker News delivers some really great content. This is fantastic content . Thanks for sharing this
Why would you need the screenshot? You only need the latitude and longitude. Those two numbers are the location.
What he's referring to is, when c is not passed as a property of `obj`, and thus `c = []` defaults `c`'s value to the empty array, `obj.c` will still remain undefined. Precisely *because* destructuring doesn't affect the original value, which in this case is the opposite of what he wants.
UEIGpf2Juu* pmCT#XL:EiI![WRa]:#WM^&lt;] ,7Eip8[twGPecGk.0p7TbJ28~%kG&lt;zQhKVe4QIm&gt;T]NJIWWMq5aN;kp
The big problem here is that you're trying to combine multiple different constructs here, and they don't play well together. There's object destructuring, and there's assigning default values, and you want to preserve the destructured object as a parameter as well. My main question would be, why would you need to have this same data accessible in two ways (via `obj.c`, and via `c`)? I think the object destructuring was designed specifically with the thought that you wouldn't be needing a name for the object you were destructuring - after all destructuring lets you bind all the relevant values you're looking for into their own variables. So why would you still have the need to reference `obj.c` later? --- You do have some possible solutions, but given the issues mentioned above, no matter what solution you choose, you'd need multiple statements to solve this. Here's one approach similar to /u/Pantstown's suggested approach: function foo(obj = {}) { var c = obj.c = obj.c || []; console.log(obj, c); } // Test: foo(); // obj = { c: [] }, c = [] foo({}); // obj = { c: [] }, c = [] foo({ a: 1 }); // obj = { a: 1, c: [] }, c = [] foo({ c: [ 1, 2, 3 ] }); // obj = { c: [ 1, 2, 3 ] }, c = [ 1, 2, 3 ] foo({ a: 1, c: [ 1, 2, 3 ] }); // obj = { a: 1, c: [ 1, 2, 3 ] }, c = [ 1, 2, 3 ] Or a slightly reorganised sample which also includes extracting `a` and `b` from your `obj`: function foo(obj = {}) { obj.c = obj.c || []; var { a, b, c } = obj; console.log(obj, a, b, c); } So the default value for `obj` as a whole comes from the function signature. Default values for `obj`'s properties must be define with oldschool ES5 syntax. And the object destructuring is used to extract `obj`'s properties into their own variables. I think I'd personally go with this sample since it does make it fairly clear what's happening. Sure, I'd have loved to have done all that work in the function signature, but that's just not supported by ES6.
nice
How to Win Friends and Influence People, by Dale Carnegie has nothing to do with JS, but everything you need to know about communication and building relationships. 
I'm really glad that more and more people are seeing the wonderful power that the babel project has given us over our code. Even if all of the new ES6 features sucked, they'd be worth it just for the new parsing tools we got as a result.
&gt; package author's other pages were used significantly Which is true much less frequently when very commonly used functions are in the language rather than scattered across npm. The guy's got a point, a larger standard library would have likely postponed the shitshow. But is that even a good thing? The result of the fiasco was a serious design flaw coming to light and being addressed. Doesn't seem like something you want to put off.
There's no distinction between server-side and client-side code in Node and NPM. All Node understands is JavaScript. Node is what Webpack uses to bundle your scripts be it server side or client side, and Node doesn't understand ES modules yet. When you publish a library on NPM it must export to CommonJS modules, you can't simply import anything if it's not CommonJS. React, Angular, left-pad, axios, literally every single thing that's published on NPM right now.
You asked if you can select an element that way. &gt; can I use li:nth-child(2n) or something like that to select it with document.querySelector
This is basically a decision tree isn't ? or something similar. 
Dumping it into an array and sorting it there will be most likely faster.
this is impressive for a first project - what's your background in programming?
Any framework. We recently did something like this with Vue at work. I like Choo, which would work as well. But the question shouldn't be which framework will you use, it should be what data structure will you use.
Yeah, great question. At face value Redux-ORM looks like a more complex (and feature-heavy) version of https://github.com/reactjs/reselect. The aim of this sort of stuff (imo) is to: 1. Move data manipulation logic out of components 2. So that both components and data manipulation can be reused. The negatives: 1. You need to design state shape yourself (with normalizr, not redux-orm specifically) 2. You need to write actions and reducers still 3. You need to call actions within componentWillMount and componentWillReceiveProps (ie. if a route URL changes and the component receives new props - not being remounted) 4. Defining models here can be complex; you're writing a frontend relational database. Tectonic's aim is to: 1. Automatically write actions and save reducer state for you 2. Automatically load all of the data from an endpoint into your props. Right now, the hole that's "missing" is data manipulation; tectonic's going to pass down all of the models as an array or as the model itself into your component. The current solution to fixing this in Tectonic is by defining model functions (https://tonyhb.github.io/tectonic/api-model.html): ``` class User extends Model { static modelName = 'user'; static fields = { id: '', email: '', } getObfuscatedEmail() { const { email } = this; if (email === '') { return ''; } return `${email[0]}...${email.susbtr(email.indexOf('@'))}`; } } ``` This lets you do data manipulation using the model instances passed to your component directly. I like this because it colocates all data logic for a model **inside** that model class. It's not perfect, though - sometimes you need to merge and manipulate multiple models. There's an issue for this: https://github.com/tonyhb/tectonic/issues/26. I'd like the declarative API to be able to pluck and merge data so that you can write these transforms anywhere and have tectonic handle this so that the props passed down are exactly what you need.
You don't check unless you have to. I often do things like const fileSuffix = (a) =&gt; String(a).substr(-3); So even if a is, say, an array, _fileSuffix_ will return "". To return to your example, + is actually the only exception. Because + is both an arithmetic and a string concatenation operator, I would always cast the arguments const add = (a = 0, b = 0) =&gt; Number(a) + Number(b);
Ah so you don't actually care about having separate variables `a`, `b`, and `c`? That clears it up a whole lot! I think ES6 intends for you to do this: function foo({ a, b, c = [] }) { console.log(a, b, c); } However you don't want to make use of the destructuring, you want to keep the original parameter as the entire object into a single variable. That's where things go wrong, where your use case is no longer supported by the ES6 spec, and thus where you can't use a fancy one liner. So at that point your best option is to use ES5 style default values, unfortunately. function foo(obj) { obj.c = obj.c || []; console.log(obj); } Still, I'd definitely recommend for you to see whether the ES6 intended use case (the other code sample in this post) may be a viable option for you. It kinda depends on the context whether it's useful to have `a`, `b`, and `c` as their own variables instead of keeping them grouped onto obj.
I refreshed a couple times and it finally worked to where I was able to actually read the article. It seems like it was their subscribe nag overlay that didn't die very gracefully.
Must have been some Github cache. Thanks for taking the time to respond!
50ms is likely way too much if the UI needs animation during that period.
Any form of recursion that isn't handled properly by the language will eventually lead to problems. (solution is tail call optimization as mentioned already). The usual way around this is to rewrite recursion as a loop. UI animation will lag if you exceed the available processing time in between frames. A browser at 60 FPS has ~16ms at most, much less is left to you (conservative budget to guarantee stable 60 FPS is &lt;=5ms). If you exceed that budget you will introduce lag (frames will be dropped). To solve this you have to either offload the processing to a worker or to distribute it between frames with window.requestAnimationFrame (and optionally track your budget with window.performance.now()). This all depends on what you are trying to achieve. Of course performance optimizations will help too. 
`System.import` doesn't exist anymore as it's deprecated, this gist is old. However, it seems that webpack 2 supports `import()` https://webpack.js.org/guides/migrating/#code-splitting-with-es2015 I found it in the link above, webpack's 2 documentation itself still has require.ensure.
I'm that guy. Design, jquery before Javascript, copying snippets from stackoverflow. I'm a front end developer, but my focus has always been primarily on styling. This year I decided to do something about it. Did the General Assembly Javascript part time course, and aspects of this were my final project. I spent about two months after that getting it to what you see today. Ideally, I'd love to transition to a front end engineer, but that's looking like a huge mountain. 
Feedback is welcomed :)
What really would have postponed the shitshow is not having a central repository. Then there would be no trademark violation and removing a package is irrelevant if there are mirrors.
JavaScript the good parts. You can find free download a for it all over the web. It has a lot of the cool unknown nuances that many developers don't know. Edit: I'm lost about why this got a down vote. I'm a developer that is fluent in es5 and es6. Its a great book for es5.
&gt; Big four won't focus on JS specific questions. Maybe? Not always though based on my experience. In fact most of my interviews at both Microsoft and Apple were geared towards JavaScript knowledge than actual algorithms / CS topics. Granted those are still there but there was plenty of focusing. It's hard to generalize too much about tech company interviews. I've found techniques and topics ranged wildly just between departments. Same with Amazon, one group had me *only* deal with algorithms and data structures and the other group *only* asked questions relating to web development.
IIRC textareas are slightly odd in that they don't have a value. They have content. Remember, the syntax is different to an input: &lt;input type="text" name="firstName" value="Susan"&gt; &lt;textarea name="description"&gt;&lt;/textarea&gt; Try using `$('.new-comment-text').html()` or `.text()`. That might work better for you.
$('.new-comment-text').value = "test"
You're welcome
You're doing it wrong. Whatever you think you're getting isn't what you're getting. I just made a quick Codepen and `$('.textarea').val('some text')` worked perfectly fine. So did `.html()` and `.text()`. This suggests that the selector you have isn't correct. You may have a typo, or your selector might be getting an element you don't expect, or you might be getting an array of elements rather than a single one (for example). If you make a quick codepen you'd get better help?
[removed]
Simplest and oldest trick in this case
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [What are some quality JS interview prep books? Also, are there any good code challenge sites that specialize in JS (or general programming) interview code challenges and\/or preparation ? (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sb260/what_are_some_quality_js_interview_prep_books/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Does anyone know of a framework or library to generate a Webapp flow of questions which changes dynamically based on answers? (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sb25u/does_anyone_know_of_a_framework_or_library_to/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
hey cool! although a bit of a misnomer to call it your first JS project, heh. i'm in a bit of a similar situation, where i've been a 'just enough jquery to get by' dev, but i'm becoming proficient in React, and would like to be a freelance dev/engineer full time, but the industries i work in are more design-based, so i'll likely have to join an agency or partner with a designer friend
[removed]
Michael! Nick here. This turned out amazing. I knew you had great things in you. I was so happy when I saw this on the frontpage of r/javascript and r/web_design
I played around with these recently: you may or may not find it useful: https://github.com/dtipson/NELs (non-empty and circular lists are really darn cool for playing with comonads and things like cellular automata!) The main thing are the "walkers" https://github.com/dtipson/NELs/blob/master/src/utility/walkers.js which are generator functions that walk through lists a single time even if their references are all circular. Detecting that you've arrived back where you've started is obviously just a matter of strict equality (when the starting node strictly equals the current node, you've walked the list exactly once). I didn't implement sort, but there are a bunch of different possible algorithms. Also check out this dude's code: https://github.com/cweill/Sorted-Circular-Doubly-Linked-List/blob/master/sorted_circular_doubly_linked_list.js his lists are always sorted, period (it's a type guarantee!)
https://github.com/gajus/questionnaire
Awesome!
Well said.
&gt; It might use old syntax (module.loaders instead of module.rules) but will still work. Ah, you're right about that. I could've sworn that was one of the config keys that blew up on me when I bumped my Webpack version to 2, but didn't yet update my config. But, from the migration docs: &gt;For compatibility reasons, the old module.loaders syntax is still valid and the old names are parsed.
The most natural way to sort a Linked List is to use mergesort. The advantage of doing it over a Linked List is that it uses O(1) memory as opposed to O(n) when used on arrays. Here's an implementation I used a few days ago while practicing in LeetCode. /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var sortList = function(head) { if (head === null || head.next === null) { return head; } let prev = null; let slow = head; let fast = head; while (fast !== null &amp;&amp; fast.next !== null) { fast = fast.next.next; prev = slow; slow = slow.next; } // close first half list prev.next = null; const l1 = sortList(head); const l2 = sortList(slow); return merge(l1, l2); }; function merge(l1, l2) { const head = new ListNode(); let current = head; while (l1 !== null &amp;&amp; l2 !== null) { if (l1.val &lt; l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = (l1 === null) ? l2 : l1; return head.next; }
"progressive" means something more specific here: when you render markup from the server-side first and then when the browser code loads, it upgrades into doing dynamic updates.
Rather than global functions, you can go a couple of ways. As a very first step, you can group functions into objects, so each file only adds *one* thing to the global namespace. window.timeUtils = { getOffset: function() { ... }, makeLocalTime: function(serverTime) { return new Date(this.getOffset() + serverTime); } }; You can (and really should) wrap them in an IIFE. This also makes it easier to break it up into internal and exposed functions: window.timeUtils = (function(){ function getOffset() {...} function makeLocalTime(serverTime) { return new Date(getOffset() + serverTime); } // Decide what to expose return { makeLocalTime: makeLocalTime }; }()); If you use something like [RequireJS](http://requirejs.org), the scripts load a function in a private namespace, so there are no globals. You can set this up to load as individual files and move onto a build step when you are ready. It's perhaps the easier transition because the From there you can try [other module formats and loaders](https://addyosmani.com/writing-modular-js/).
Very cool. Reminds me of Ana Tudors Cube assembly thingy..... http://codepen.io/thebabydino/pen/eJjzXm/ ...and I made it just use no scss and calc and var instead.... https://codepen.io/PAEz/pen/EPpZQj/ You should stick this on codepen, they love this kinda stuff over there.
I finished this thing (mostly) and the last paragraphs state his true intention and it's a good one. I dunno man, can't we just conclude 'Nothing is perfect so don't let the search for it cloud you from things that are good enough'? Does anyone think we'll ever get to the point in development where we'll say 'Yup, code is DONE. This your stack for THE REST OF TIME.'
Webpack is powerful but using it is like staring into the eyes of Cthulu.
That's referred to as *good timing* and you should take advantage of it when it comes up.
have you read even the first paragraph? In the first para, the author linked to https://medium.com/@mattburgess/javascript-frameworks-are-great-2df4a3f0b24d#.ib6etcvl3 
It totally depends on what kind of front-end work you do. Some of us work in UX/UI teams and need to collaborate on designs and create interactions.
Bullshit doesn't stop being bullshit simply because it's openly bullshit. 
Programmers developing flows, wouldn't mind there being some work on creation of new ones. I'm happy to have the flows designed in code, not in a UI.
Not really. More a flow to collect data. 
&gt; I dunno man, can't we just conclude 'Nothing is perfect so don't let the search for it cloud you from things that are good enough'? I think most of us do, hence the constant complaints about how someone's pet technology / methodology didn't see any adoption, and that's clearly because we're all morons and can't even begin to comprehend the fact that we've been doing it wrong all this time.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Run The Same Function Right After The Other (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sdby9/run_the_same_function_right_after_the_other_xpost/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Spine looks fucking dope! Haven't done anything with animations yet, but that looks so straight forward. Wow!
1. Completely agree with you about synchronous file loading. But there was described rare situation, when some synchronous scripts are already used. It is a solution to solve a specific issue, not more, not an advice to write code in that way in further. As you see, the initial behaviour is asynchronous. 2. Sure, you may send details about current application version within http-requests, but approach above solves not only the issue with timestamps. You may configure a specific user storages, modify existing data by names (remove specific or even exclude them). It is client behaviour, cause that data is stored inside localStorage, sessionStorage or cookie. 3. Moreover, when application is loading and trying to get current version details due to http-request, it may take some unpredictable amount of time. So, the decision is using an appropriate loaders, spinners or something like that. When you get info from existing *.json file inside current application, it will be loaded in many times faster. See #4, #5 examples where were demonstrated cases for removing specific keys from specific storages and excluding keys. 4. Getting info from local *.json file solves the problems with cached data even if the application doesn't use http-requests. So, it may be a simple app without requests, without server-side, but with modified *.js files, styles or markup. You could use that script for each type of application.
Javascript frameworks will keep changing over the time, its the concepts that matter in the end
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Having troubles masking my input (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sdjn7/having_troubles_masking_my_input_xpost_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I love the juxtaposition. Shyness with a follow up of bombastic. I also thought most developers did this - way up what's needed for the job. I don't know how you can't do that? I don't throw a framework in for a simple site, just as I don't naively think I can build a SPA quicker without one. Tools for the job.
Glad to know that the post helped!
Could you elaborate on the sloppy format part? Would love to change whatever is required
Author here, I agree, the investment upfront to rewrite a whole legacy application can be huge! The app I've been working on is over a decade and rewriting the whole thing would be suicidal and wouldn't be worth the time. What I've tried to present here is a way to incrementally update parts of a web app while keeping everything else in tact. So you can carve off parts of the app to update to deal with tech debt, while also having a modern platform to build new functionality, and not breaking the old stuff!
Looks like somebody created a tool for this: https://apptransport.info/
'Trailing commas in function parameter lists and calls' I am not sure. This just seems to make reading javascript that bit more difficult. One reason given for the change is 'version control systems ' difficulty in telling if anything has changed. Shouldn't that be the problem with the version control system and not JS?
&gt;Latest commit 1078c4d on 23 Apr 2016 @JedWatson JedWatson Merge pull request #110 from akiran/flicker-issue â€¦
If you don't say your thing is a silver bullet thing to replace all other things, no one is listening these days. The result is thousands of tiny echo chambers where a tech provider and their users are bragging to be number one in the world. 
As a bonus it makes server side pages that generate and output JS arrays slightly simpler. You can just concat an open bracket, iterate, close bracket and it'll work. At the moment you need an end case for the iteration. 
AFAIK the isomorphic feature of aurelia is not a priority at all. Cool to hear that you've managed to make something similar anyway. What are you using for the initial rendering?
So here is what will happen in real life: There will be several weeks, maybe a couple of months even, of momentum by everyone because hey, new and shiny! Everyone loves new and shiny! So you take your existing project and start migrating chunks of it to a new platform/framework incrementally, piece by piece. Then something happens. A business requirement with absurd deadlines, customer escalation because marketing and sales oversold your project, a severe bug, whatever. It kills all momentum because the focus is on business needs, not satiating the desire of engineers to use new and shiny's. Now you are worse off than when you started as your project, which was maybe old but organised and predictable, is now some wishywashy mixture of this and that and the whole thing is a damn mess with gargantuan config files for your task runner of choice to deal with it all. And by the time you're ready to kick start that momentum again, there will be another new and shiny. And as this keeps going on, your project will eventually be some complete mess that no one can make heads or tails of. So you might just go and roll your own custom made framework to solve the problems for you, you'll decide to open source it, and then your custom framework becomes a new and shiny for other dev teams to ruin their long lasting projects with. Starting new projects on new and shiny's, is one thing. But trying to slowly move an existing project over to a new and shiny, at least in a business environment, is probably not worth the risk. Unless of course there is some overwhelming business need for it, but chances are that doesn't exist.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Framework agnostic HTTP library with unit testing support? (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sean0/framework_agnostic_http_library_with_unit_testing/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Do you want to build a **hybrid** mobile app with JavaScript or a **native** mobile app with JavaScript? Because you say hybrid, but mention a native framework (React Native). If you want hybrid (meaning you want to use HTML, CSS, and JS) and run your app in a webview, the defacto framework is [Ionic](http://ionicframework.com/). Upside is it's easy to get up and running (you are effectively building a mobile website with some native interactions when needed). Ionic has a strong community and is based on Angular. Downside is performance. Hybrid apps are limited by what the iOS/Android webviews have to offer (so scrolling lists and button taps will sometimes give the apps away as not-quite-native). If you want "native JavaScript" you should look at [NativeScript](https://www.nativescript.org/) or [React Native](https://facebook.github.io/react-native/). React Native leverages ReactJS of course. NativeScript (optionally) leverages Angular 2. With NativeScript you use XML for markup, CSS for styling, and JavaScript/TypeScript to wire everything up. With React Native and NativeScript you get fully native UI, so full native performance out of the box. There is some overhead with these frameworks in terms of app start up time, but barely noticeable. All of these frameworks are free and open source. Disclaimer: I work for Progress, the company behind NativeScript. So while I'm biased towards NativeScript there is definitely a use case for frameworks like Ionic and RN.
their software is perfect, no need for more development /s
Thanks for your answer! Actually I'm an intern (well this is my first day), my project consists of building a cross-platform app with Javascript, and my manager asked me to do a research, compare frameworks (performance, community support etc), and do a kind of report so we can choose what I'll be working with 
Congrats on your first day! IMO you can't go wrong with any of the three I mentioned. Ionic is going to have the biggest community, most examples, Angular 1 or 2 support, but biggest handicap in terms of performance. React Native and NativeScript are really neck-and-neck in terms of performance, but since they are newer their communities are smaller (fewer code examples etc). Let me know if I can be of any help!
&gt; Touchstone Do not bother with frameworks that have a tiny user base and no momentum.
Yes very fast, pretty much max acceleration I think :)
Here's an example which will highlight all paragraphs. It uses querySelectorAll, then loops through those paragraphs setting a timeout at 1second * index of loop we're at (e.g. 1st index will be 0seconds, 2 index will be 1 second etc) and sets the background color. var allParagraphs = document.querySelectorAll('p'); allParagraphs.forEach(function(paragraph, index) { window.setTimeout(function () { paragraph.style.backgroundColor = 'pink'; }, index * 1000); }); 
&gt; things that are good enough I don't know about others, but acknowledging that is the first thing I do in the Mithril framework comparison page (http://mithril.js.org/framework-comparison.html) &gt;The reality is that most modern frameworks are fast, well-suited to build complex applications, and maintainable if you know how to use them effectively. There are examples of highly complex applications in the wild using just about every popular framework: Udemy uses Angular, AirBnB uses React, Gitlab uses Vue, Guild Wars 2 uses Mithril (yes, inside the game!). Clearly, these are all production-quality frameworks. I think some people mistakenly think it's supposed to be some sort of competition. Of course, these projects are all striving to improve (often prodded by advances in other frameworks), but I don't think anyone is making obnoxious claims that they are the end-all framework.
Basically, through the [navigation guards](https://router.vuejs.org/en/advanced/navigation-guards.html). `beforeEnter` in particular. It's trivial.
Instead of going the router... route, you can make a higher order component (HOC) that does all the fetching/loading/etc before the actual component is embedded on the page. Essentially: Write a component wrapper that takes your pages as children - the wrapper uses `willMount` or `willReceiveProps` to check what needs loading, etc - upon loading, the wrapper drops the child component onto the page, with your data in store. HOC's are a little confusing at first, but it's much more React-y than parsing straight from the URL and all that
First explain why you feel you need a framework? Cause you read somewhere you were supposed to or can you list your reasons?
If you want to build a component that needs the current URL, use withRouter; e.g.... import React from 'react' import { withRouter } from 'react-router' const SomeComponent = props =&gt; { // withRouter exposes location information via props console.log(props.location) return &lt;div&gt;someComponent&lt;/div&gt; } export default withRouter(SomeComponent)
&gt; CSS or javascript animations can't be that good as native animations. Huh? CSS animations ARE native to the browser. And what language is more native language than javascript? There are plenty of tutorials to show you how to make smooth animations using both.
By more space between paragraphs you mean the line gap? Or splitting the paragraph into smaller paragraphs? Just confirming once
Nice first project, how much time did you spend on it?
Woosh
Oh no not again, I thought we would be over manipulating the prototypes of built-ins. That's how we ended up with array.includes instead of array.contains Edit: to be constructive: 1. Very cool that you got a one char lib-name! 2. Use it! Instead of manipulating the prototype, use z.matches 
Perfect. I understand alot better now and will go this direction. Thank you!
Keen to try this! I only use Atom for markdown and the plugins are unstable as fuck.
I had the same need and accomplished it exactly like this, simply have a loading component and a viewing component (that requires data). When doing it with redux on top it makes it even better. Also, to get around the render being called, I set it up to allow 2 options: 1. Wait until the async fetch is complete before ever showing your component that needs data. 2. Inject a new prop, which contains the current load state (fetching, success, failure) into the view component, and then check that object to choose what to show (e.g. "loading....") In your component. Having both really helped in the few cases where I wanted to do something special in the page while loading. 
I think it's important to note that moving parts of an application to React, or another framework, will be a case by case basis. What the author did here works for their team but not be the best solution for others. An example being that we have a monolithic application that we need to move onto a new codebase because finding developers for it has proven difficult (we've hired every coldFusion dev in our country). We chose to move to a micro service architecture and have separate applications for the different front end domains. These are written in React and are server rendered for SEO reasons. Nginx sits on the top and does the appropriate routing e.g. to our old app or the appropriate app for that page. Very close to what is happening here but subtly different for our use case in that it's server rendered and sat behind nginx. Although this is related to our architecture I feel it's good to point it out for those who may be new to this (as I was a few years ago).
Well ain't that a bold statement!
Use your gut. I feel there's too much text before showing any code or examples. And also the text is too close together. So, to answer your query, I'd say yes to both questions. More line gap and splitting one or more paragraphs into smaller ones. Just my two cents.
I have never done this and I only use ember. When edit is clicked from loads over the rendered test with the post data already populated. On submit it sends it back to the server and updates the post. This would create the illusion that you are editing it in the page. I'm not a expert by any means, but it could easily be done this way.
If you are using loaders, they will transpile
Hey that's pretty neat! I didn't have a chance to look into the code, but I noticed in the code pen that the mouse cursor changed on the second example but not the others. Not sure if that's intentional since, again, I did not look into the code. Pretty cool!
[stackedit.io](http://stackedit.io) is my go-to
I hear so many good things about Vue. Do you mind summarizing in a few sentences why you prefer Vue over React? Also, do you have a public example of something you made with Vue?
I also considered that approach, and I will probably have to use it, since there is no better way to do it. Still, it doesn't seem like a perfect solution to me. Or maybe I'm spoiled by other libraries.
You can try out the web version of the same. http://www.amitmerchant.com/markdownify-web/
One of the benefits of the [Revealing Module Pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript) is the ability to decide what functions can be overridden and what can't. If you have an internal helper function that lets you select elements, keeping it unexposed means nobody can replace your helper accidentally or maliciously. window.util = (function(){ // This is not exposed so it can't be replaced // without replacing the exposed functions that call it. function selectElements(selectorString) { ... } function manipulate(selectorString) { var myEls = selectElements(selectorString); ... } return { manipulate: manipulate }; }()); If, however, you want to make allow someone to override that function, you can intentionally build it that way: window.util = (function(){ function stillHidden() { ... } var module = { // This can be replaced externally selectElements: function(selectorString) { ... }, function manipulate(selectorString) { // This will call whatever is on the current object // Even if someone replaces the original selectElements var myEls = this.selectElements(selectorString); ... } return module; }()); This lets you choose what others can change if they need to [monkey-patch](https://davidwalsh.name/monkey-patching) your library.
Or just use yarn, that way there is no discrepancy and no need to run a et on your folder. It's known as the ultimate form of laziness, doing it right the first time, so that you don't have to do it over... 
Serious question, how so? How will React expose problems easier than [insert framework of your choice here]?
Learn it anyway. React Native is sweeeeeeet.
It is available. https://reacttraining.com/react-router/#withrouter
No it's there. gotta move up from alpha -&gt; beta though
What are the production issues that Yarn has?
Ah nice good to know. We're still using 3 in our production builds.
I've recently started using React with Redux for my job and I recommend the default tutorials, i enjoyed them well enough and they tend to be more up to date than some third-party sources.
My mistake, just checked and the pre/post install scripts issues have been fixed! :)
#1 is angular? Really? spam
so what are the legal ramifications of uploading copyrightable material to a third party?
You can't use git+ssh with : still.
Haha thank you so much, I figured it was something really simple like that!
**[Template Literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)** offer greater control over string concatination and they're quite simple to use: fullname.innerHTML = `${salute} ${fname} ${lname}`; Note that the string is not defined with single quotes, but with backticks.
Sorry to bother you again, but do you see what I did wrong here? I'm doing basically the same thing except having an employee's street address and then city/state/zip display on 2 separate lines function ShowAddress() { var street = document.getElementById("streetaddress").value; var city = document.getElementById("cityaddress");value; var state = document.getElementById("stateaddress").value; var zip = document.getElementById("zipcode").value; {document.getElementById("streetdisplay") = street;} var fulladdress = document.getElementById("addressdisplay"); fulladdress.innerHTML = city + ' ' + state + ' ' + zip; } &lt;label&gt;Street Address&lt;/label&gt; &lt;input type="text" id="streetaddress"&gt; &lt;label&gt;City&lt;/label&gt; &lt;input type="text" id="cityaddress"&gt; &lt;label&gt;State&lt;/label&gt; &lt;input type="text" id="stateaddress"&gt; &lt;label&gt;Zip Code&lt;/label&gt; &lt;input type="text" id="zipcode"&gt; &lt;button onclick="ShowAddress()"&gt;Display Address&lt;/button&gt; &lt;label id="streetdisplay"&gt;Street Address displayed here&lt;/label&gt; &lt;br&gt; &lt;label id="addressdisplay"&gt;City/State Address displayed here&lt;/label&gt;
*my new hot framework* is the new standard in web development.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [How do I get these elements to display on the same line? (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sg7qr/how_do_i_get_these_elements_to_display_on_the/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
That looks pretty, but overtime I've discovered the best methods are those that require editing the fewest lines when data changes, which also helps keep git diffs stay clean. let arr = [ &lt;-- could also go on the next line if you want 'red', 'green', 'blue', ] this way you can add, remove or rearrange items in the array without needing to touching any more than you need. In your example, if you wanted to swap red and green, you would have to move the bracket and comma around.
&gt; var city = document.getElementById("cityaddress");value; you have a semicolon before `value` - should be a period
Try Egghead, it's great learning resource. These lectures for instance were made by Reduxes creator, Dan Abramov: https://egghead.io/courses/getting-started-with-redux The React lessons are also nice. As for pure and impure, that doesn't need much explanation at all. This is a pure component: const SayHi = ({ name }) =&gt; &lt;div&gt;hi {name}!&lt;/div&gt; ... &lt;SayHi name="brett" /&gt; It's a function, nothing more. It takes arguments and returns layout. Provided the argument is the same, the result will also be the same, hence it's "pure." You use this for simple presentational components. The syntax is just basic ES7, using arrow functions and destructuring. It's the same as: function SayHi(arguments) { return &lt;div&gt;hi {arguments.name}!&lt;/div&gt; } A class on the other hand can be just as pure, but it can also carry internal state, react to events, lifecycles and parent context, which all could have a side-effect on its output, thereby making it "impure" which isn't to say it's bad. Here's such an example: class Echo extends React.Component { state = { text: "" } onChange = event =&gt; this.setState({ text: event.target.value }) render() { return ( &lt;div&gt; &lt;input value={this.state.text} onChange={this.onChange} /&gt; &lt;span&gt;You wrote: {this.state.text}&lt;/span&gt; &lt;/div&gt; ) } } As you see, the logic is within the class, it reacts to your typing something. It isn't a big deal, you could use regular classes all day and nothing will happen. Sometimes it's just more convenient to put really simple components in functions.
I think this is a great litmus test: The group of people who complain about this article are the people it's about. The group of people who laugh at it are the one's who are tired of the first group's bullshit.
ok yeah I fixed that and it's still not working
When everyone stops winking at each other and nudging each other, may you notice you've been fooled into reading one or even two articles completely void of useful information, where the author **argues with himself** and has an **unintelligent position on both sides**? If the "woosh" is the point, if you're reading pseudo-articles for the punch line, the high concept of it, fine. But to me that's basically spam when posted here. This is not /r/writingprompts/
Yah... Only found out just now. It's unfortunate.
I bet someone already mentioned this, but just look at udemy they have tons of courses covering pretty much anything.
I have a lot to say on this topic, but in the fewest number of words: React promotes linear code. You can't arbitrarily draw lines from one part of your app to another, unless you're specifically trying to break out of any React conventions, but then in this case it would be easy to spot the bad lines since it would be so out of place. When you're debugging something in a React codebase, you only need to look up. Either the problem is in a parent component / state, or its higher up in the middleware stack. It's not impossible to write this unidirectional code in other frameworks, but React was the first big man on the scene to really push that idea. Yeah sure you can write bad code anywhere, but it's contained in a better architecture (than say, Angular)
The problems you are having should be apparent in the developer console. For example: {document.getElementById("streetdisplay") = street;} It should tell you this is an invalid left-hand assignment. (I'm guessing you want to add `.innerHTML`) It will even tell you what line the error is on.
&gt; There is one big minus for me - animations. CSS or javascript animations can't be that good as native animations. True, except for simple animations like opacity and transforms.
Check out Tabris.js!
minor nitpick: 'swapped' is set back to false on *every* iteration, not just the last. it's just that on the last iteration, the *if* statement doesn't evaluate to true, and thus swapped remains false
Thanks! What about the community and help? Since React native is relatively new, would I find less people that can help and more bugs? 
Not sure if you're looking into alternatives to PhoneGap, but if you do: Ionic Framework (https://ionicframework.com). Huge library of native-looking user interface components, focus on optimizing performance (yet, still WebView-based), great community with tons of resources, and Ionic Native for wrapping Cordova-based plugins into using promises.
The author of this seems like a little sheep biatch. I think this is a great step forward for mobile web. If only apple wasn't so invested in their app store and allowed these features into safari. IMO, iOS holds back the mobile web quite a bit.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Favorite library for pdf generation (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5shbzx/favorite_library_for_pdf_generation_xpost_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
more like 2013
I think from their report that's clearly documented. 
I did spin up a small backend service that uses http://wkhtmltopdf.org/ and it has been a godsend. Before i was using window.print() and a good amount of css `@media print`, but client browsers were crashing when generating too much data. 
I hope that they will make promises faster than bluebird and other stuff like this. It's so sad to see devs needing to change native Promise implementation for performance...
There is. But don't do it. Look into the [Instagram APIs](https://www.instagram.com/developer/) to see if there's a supported way to accomplish your overall goal here.
Why can't they plan both at the same time? Especially ops and frontend, those are largely independent. 
&gt; 1. Rewrite only what you need to &gt; We are not rewriting GitLab's frontend entirely in Vue. That would be a very bad idea. It's not a bad idea for everyone, but it's a bad idea for a startup. It would cost a tremendous amount of time and money. The existing jQuery code (although some say is uncool) has been tested and works very well. There is no need to rewrite functionality that works well, unless there is going to be a major gain. This never ends well. Just re-write it, or leave it alone. This sort of approach just screams out "I'm bored and want to use something new on my old code-base" than "I'm solving a real engineering problem." Or just go ahead and have fun - but don't pretend you're doing future engineers, including yourself, that work on the project any favors. 
The standard advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful. Don't over-complicate the learning process by trying to learn many different things at once. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics.
I'm guessing they want you to attach an event to the select box (onchange) that will apply the selected color to div. Your code doesn't handle any events, so nothing will change when you select a different value. Here's some pseudocode: select.onchange = function () { box.style.backgroundColor = this.value; }
this part: if(colors.value == 'red') { console.log('red'); } is only processed when the JS section is loaded. What you want to do is listen for the user selecting an option, and then change the color of the box with backgroundColor. Updated fiddle: https://jsfiddle.net/v3op9jqy/2/
This is just plain not true. A new technology used strategically in certain areas of new development can be used as a beachhead to "prove" the benefits of the new technology and see how it is going to be used in a new system. At my work right now, we are in the process of converting an old Backbone app to React. We first started by switching over and doing all *new* development in React and getting the architecture stable for that, and now that we have proven the technology and the developer productivity gains that came with it, we are proceeding with refactoring the whole application for the next major release. There is no way we could have gotten buy-in from both the managers and all the other developers on the team without this phased approach. It's not just "new shiny". It's genuinely better in every measurable way, with fewer bugs and regressions. And by doing it this way, we have the data to prove it.
Glad I'm not the only one who was thinking that, thought I must be missing something. Unless I *am* missing something, there's nothing special about a linked list if you intend to replace the links. So yeah, dump the items in an array, sort, rebuild the links. 
And the key to never rolling out the new website on a timely schedule is to insist on a total rewrite.
I played around with the beta, using it to log sensor data. Chrome prompts the user when connecting, I don't think you can backdoor access to a device. It's a very useful feature.
https://www.instagram.com/developer/endpoints/comments/
I recommend using create react app, then ejecting, then looking at their webpack configs. You can learn a lot. They pretty much setup most things you'd typically use.
I've had just about enough of everyone blaming and shitting on GitLab for the recent problems. For all you know this happens in other companies, but they were open enough to admit it and were fully transparent. These are the good guys and give you a lot of stuff for free which they don't have to.
Filled out the form :)
&gt; give you a lot of stuff for free which they don't have to I'm not saying they're not good people, but IMHO to compete against GitHub they do have to give a lot of stuff for free.
No they don't. Gitlab CE which doesn't lack anything and is actively supported is fantastic and is better than GitHub. The CI/CD features they have have no equivalent.
I like angularJs and Its is not compulsory all like it. Mainly depend on the level of skill set one having, ease of understanding and type of project. **I read this blog thoroughly and claim that it is not spam but well-written blog. Apart from saying this, NOT AGREE with NODE.JS at the #3.**
Yes you Right. But what we can do the frame work technology not much change from 2013. It changes so and so but not drastically 
Found the code: FEBUDEMY to get any Udemy course for $19 this month (Above course is normally $180).
what we really need is an ability to select contacts like selecting files so that web apps can work without third party address book lock-ins. RIP https://www.w3.org/TR/2014/NOTE-contacts-api-20140114/ why did this proposal die? i suspect none of the big players were too happy with such easy exporting of contact data. a lot of native apps would no longer be necessary or need to be locked into an app ecosystem.
 function labeledCheckboxes(proposals, answers) { return _.map(_.zip(proposals, answers), (item) =&gt; [item[0], !!item[1]]); } ðŸ˜œ Here's a readable but still terse version: function labeledCheckboxes(proposals, answers) { const result = []; for (let i = 0; i &lt; proposals.length; i++) { result.push([proposals[i], !!answers[i]]); } return result; }
I also stumbled over the problem of the implicit timeout value some time ago. On the mdn page one can read about the timeout even if one passes 0 and there is also a workaround described how to implement a way without the delay. https://developer.mozilla.org/de/docs/Web/API/Window/setTimeout#Minimum_delay_and_timeout_nesting
Good article but the thought that full stack developer doesn't know how to use Gulp seems funny. 
Seriously this is a bad idea, they'll end up with a horrendous non maintainable code base
[removed]
Well if you want web components then I think one should go with Polymer route - not vue. They are both similar in my opion but can vue produce web components? I know Angular 2 can but I haven't tried it in production.
What plugins do you use that are this unstable? I'm asking as a developer of Markdown-related stuff for Atom.
It was a mistake, and much much worse had happened at many companies. They are getting more heat than companies who willingly compromise their users privacy, for example. But you won't find many companies willing to be this transparent, at three very real risk to their business and revenue. That shows who they really are.
20 years. started programming with javascript....did a bunch of other shit....ended up programming in javascript again.
Sorry - but you are wrong. Have you ever worked in a bigger company? To me it looks almost like publicity stunt - especially because they streamed their recovery online. If you would be recorded all the time you would be working a lot slower because you would be thinking how to work to not show or say something that is not meant for public. (not to mention additional stress) Also again - the mistake is not a problem (yes it happens all the time), not working backup solutions are the problem - which is what most people often do not understand. Would you be saying same thing if they wouldn't be able to recover the data, I can already see it "they erased all my data without backups, but they were so open about it - I love this guys". Really? And to put things in perspective - peoples work (gitlab employees) depend on those backups, some of them have kids, loans, mortgages etc. Depending on the type of failure lot of them could lose their jobs over a problem like that so please don't make it sound trivial. The fact that other companies are also doing bad things makes this good how? I hate when people raise this kind of arguments.
What would you write in Vue that would replace jQuery stuff? It's a view library and jQuery is a set of utilities
I recommend you to start looking at vuejs.
I would have appreciated something in the comments about the "intent" of the function. In this case something like a type signature might have been enough. Also, applicative programming is all well and good, but this is not a good example of it. You can "zip" without calling zip: ``` const proposalsWithAnswers = (proposals, answers) =&gt; proposals.map((proposal, index) =&gt; [proposal, answers[index] ? true : false]) ``` if you want to use zip: ``` _.zip(proposals, answers).map(([proposal, answer]) =&gt; [proposal, answer ? true : false]) ``` 
PhantomJS is buggy by design. All the time something else does not work. Why should anyone use a testing-framework which was build around this? You should choose electron.
The problem has been solved. Thanks for the help.
I'd be more worried if they had their front end devs working on ops. Ops is a specialist field and at GitLab's scale you need that stuff done by specialists 
~14 years. - Started out because the programming job market was quite lucrative - C++ / Java (mostly, financial software for investment banks) - JavaScript (since 2009-ish)
Ah, there seems to be an issue with NPM. I can't publish my latest package which contains install via npm. I'm on it
Vue is an Angular-like coating on top of React. Slightly less complex than Angular but a complex abstraction over React. Neither Vue, nor Angular nor React have anything to do with web-components. You can use them for encapsulation, but that's on you.
roughly 10 years. 5 of those professional. started out with C/C++ in school, currently doing JS / Java for the banking industry. 
https://en.wikipedia.org/wiki/Strong_and_weak_typing
IMO, if your good front end talent can only work with angular 1 / react, then you are hiring bad front end talent.
JQuery for the most part is also a view library, built for dom manipulation. People use it for a ton more than what it should be, but you get that with anything, really. Edit: jQuery is a library for the view layer, not a fully-featured view library.
&gt; Why add complexity? Redux doesn't add complexity - it simplifies things by storing the entire state in a single place, and enforces simple practices of performing any modifications to it by dispatching appropriate actions served by reducers. This gives you a very straightforward flow, even if the codebase may look complicated at first. I can't answer the rest of your questions since I'm still only learning react+redux as well, so my only answer would be "yes". There is very much a place for a database and an API, what I noticed though is that both react and redux are still so young that they don't provide one best way to do that. As in - sure you get an appropriate block on a flowchart, but you don't get an implementation - you pick one of the many the community has so far come up with.
Yes! yes! finally someone else also thinks this is all a PR stunt. Could all of this just be a genious marketing stunt?
What annoys me the most about the current solution that if you have recently visited a page, it takes *forever* to load the same page you have visited before.
Fuck guys guy tricking me into thinking there's discussion to read 
So does that mean that just using react with cordova is easier than react native? Do I need to know Android/ios native features and is there a difference in developing the same app for the different platforms? Is it worth it to use React Native instead of just react js + cordova, in terms of developing costs (considering I don't have much time) Thanks a lot 
Do I need to know Android/ios native features and is there a difference in developing the same app for the different platforms? Is it worth it to use React Native instead of just react js + cordova, in terms of developing costs (considering I don't have much time) Thanks a lot
Amazing so far, through it's still early for production use.
So react/redux application just sends RESTful requests to a server and this application still gets data from a database? Is that right? Does it mean that there has to be 2 applications, 1 client and 1 server?
Ok i got it to work the way i wanted what i wanted is hard to explain but i got it thanks
Yes, but the application is a single page, it's not steered by a backend. You connect to a database, json api, http endpoint, local data, browser cache, anything really where you get what's needed. This goes into the redux state machine and your visual app builds itself around that.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Why redux-saga uses generators? (X-post from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sl2hh/why_reduxsaga_uses_generators_xpost_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
My first (reluctant) encounter with programming was in 1998 when my partners and I decided we wanted the exact same effect as some random site on our own site. I already built the entire thing entirely in Dreamweaver's "WYSIWYG mode", carefully avoiding anything remotely "code-like", but adding that feature was too important for us so I had to look under the hood of both sites to "borrow" their stuff and adapt it to our needs. It turned out to be a lot easier and funnier than expectedâ€¦ and I was hooked instantly. If only I remembered what feature that wasâ€¦
Correct. It was html &gt; pdf. The advantage of this solution is that you get to use any html templating to draw your page (from handlebars to react if you so wish), you get to see it before the rendering, which speeds up development quite a bit. Otherwise, you can check PDF.js by mozilla, jsPDF (parallax) and pdfkit. 
I wrote HTML for the first time in 1997 and eventually learned CSS. In 2007 I was hired as a designer at Travelocity. A couple of months later was involuntarily re-tasked to a development role where I had to learn to program for the first time. JavaScript is my first programming language and I have been doing it ever since.
In the same way as Angular, React, or Vue? None, it's a DOM Manipulation library. Maybe I mis-worded that, but compared to just vanilla JS, JQuery is made for manipulating DOM elements in a view. So it's not a full-featured view layer, like the others, however it is still part of the view layer, and at least for myself I can say that most of the uses I had for jQuery was to do similar things as the view libraries, so I, personally, would be able to just drop in Vue and take out huge swaths of jQuery code I had written as observers and just replace it with the out-of-the-box functionality that Vue offers. So to answer your question, I meant it more as jQuery is a library built for the view layer, and not specifically a full-featured view library.
or `__defineSetter__` before that
I think it's a very interesting project, but personally I wouldn't use it. One reason is technical: lack of keys (so basically, you can't re-order the dom correctly). The other reason is subjective: the author is also the author of Ractive (as well as a Buble and Rollup), so I don't believe that Svelte is going to be as heavily supported as some of the many alternatives. The third reason I wouldn't use it is that I'm obviously biased (being the author of Mithril), but even if I weren't, my assessment would still be the same regarding the other two points.
Looks like the link pointed to something on someones local machine. Looking at you /u/mutaharte 
Nice, like these little helpers. One small suggestion though, you might want to add things that are states inside official countries. E.g. Having United Kingdom but also having England, Scotland, Wales and Northern Ireland. These can be useful in some sporting contexts where they are counted as independent countries.
one year. Did art in college and when I finished I figured that I dont wanna do that. So went back to college to do an intensive year in ICT skills, now I'm sitting in my first tech job going to be doing a project with SQL and C#. Loving the puzzles. Java
Honest question: why would anybody need this? I mean, given that we're talking about web browsers here
We need that for performance. Now we can't share variables in web workers. So only we could is serialize/deserialize json object. But that is not good solution for performance, so Ecmascript2017 make it more efficient to introduce SharedArrayBuffer that is sharable between web workers. But shared vars introduce some troubles, race condition, visibility issue, etc... Atomics solved that probrems.
pretty neat. how do you automate this to ensure that the information is always guaranteed to be up to date? 
NativeScript has a [module system](https://docs.nativescript.org/core-concepts/modules) that abstracts all of the native iOS/Android functionality into one cross-platform package. So for almost everything you are just programming against one API for both platforms. In the case that you need to access iOS or Android-specific APIs that don't have a NativeScript module, you can always [access native APIs directly](https://docs.nativescript.org/core-concepts/accessing-native-apis-with-javascript). NativeScript touts "write once" (which is true for 90-100% of your code, depending on the app). RN touts "learn once" and write a new app for each platform. Hybrid apps with Cordova are always going to be faster to finish the first 80% of the app. The problem is finishing the last 20% can also take another 80% of your time :)
How long: 28 years (started at 6 years old). What? BASIC. Why? Because I needed to write BASIC in order to launch Microsoft Flight Simulator 1 on my TRS-80. 
Yeah arrow function's `this` context is different. They behave differently and don't bind it as you might expect with the classic syntax. See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions 
Arrow functions do not specially bind the value of "this" to their scope, which means that "this.events" probably here refers to window.events, which doesn't exist. If you want to use the "this" in a functional prototype function, you MUST use the old syntax, afaik. You can't even bind the function a specific "this" later with arrow functions: they simply don't offer a way to bind. "this" will always refer to the value it referred to in the place it was written/executed.
Thank you. 
Professionally for 4 years. Mainly .NET (web services, ASP.NET MVC web apps, random ass services and occasional WPF desktop app and now Orleans - Akka (or Erlang..) clone) with some JavaScript on the side - Angular/React for new kewl SPA web front ends and some Node.js on the backend (EcmaScript 6 is not that terrible and kind of okay, too bad runtime - node - blows royally in the speed department if you need to do anything more "advanced" than passing messages via web sockets from MQ). What got me into programming was Quake 3. Illegal copy was preinstalled on my first computer and I played the living shit out of it against bots. And wanted to create something like that because it was the coolest thing in the universe. And the answer was programming. C++ tutorials in english were too hard for my young mind, but I've found PHP tutorials in my native language. Had HTML basics from school and first time using query parameters (localhost/index.php?name=Bob) and generating `Hello, Bob!` HTML blew my mind. Dynamic web page. I did it. I felt great and a total bad ass hacker. Then wrote simple guest books/forums (with txt files instead of database, because hosting with MySQL was too expensive :D), RPG games. I enjoyed creating and making computer do things. But after two years I gave up on programming - was using Linux (Debian, then Slackware, then Gentoo and then Arch, because XP and Vista blows) and PHP wasn't that good (I didn't knew it wasn't good, I just disliked it, because of no experience), so I've decided to be a sys-admin. Went to the university still with the thought about being a linux sys-admin, was writing bash and python scripts, all was good. But then Windows 7 got released. Tried that - and oh my god, what a good operating system. Was using Windows 7 more and more, decided to try premiere Windows IDE - Visual Studio. What VS is good for? Mainly .NET. So downloaded C# for beginners pdf. Basic syntax usage and then straight to WinForms desktop applications. Oh my god. Spent entire night drag and dropping UIs with progress bars, dialogs, etc, it was so friggin cool and easy. And I liked C#. Downloaded Pro C# pdf, C# blew my mind with lambdas, anonymous types, generics that don't suck, parallel library, dynamic objects, LINQ, delegates. Was taught Java in uni, and compared to Java, let alone PHP, C# just seemed bees knees. And WPF compared to Java Swing, oh my god.. Fell in love. "Screw linux sys-admin plans, I'm going to be a C# developer!". And now I am. For 4 years. C# is still the greatest, only Scala (but it wants to be a jack of all trade, really lacks direction and good design) and Ruby (ehhh, slow and dynamic /pass) come close. Got a bit bored of Microsoft ecosystem, I was starting to miss unix, but lo and behold - .NET is now opensource. Immediately purchased MacBook Pro and now developing all my hobby projects with C# on macOS. And Jetbrains, the ReSharper guys, have C# IDE even - Rider. So yeah. C# all the way.
Yeah, I understand what it does at face value, but performance in what scenarios? Like, what kind of payloads are so CPU bound that can't be done in the main thread, and also so detached from UI that we can afford the overhead of serializing in and out of the WebWorker whenever that needs to happen?
Other then the timing of the announcement. Not blaming them, but when the press is full of your screw-up, you look around for something to announce.
Started in around 2001, building shitty flash games with actionscript and putting them on Newgrounds. Actionscript was based on an ECMAScript specification that was never actually made a standard. I've used other languages, but I work as a node.js dev now and using Javascript is quite comfy.
Its pretty much the same but instead of returning html you return a json object, string etc. So normaly you do something like res.sendFile(path.join(__dirname, 'index.html')); But in this case you want to do res.json(myJsonObject);
Did you just like webdev better or are you planning on eventually starting the buisness? 
He didn't say they were going to hire people that can only work with "angular 1 / react" - that's a strawman. 
Hi /u/MariaWTB, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Ouch, -35... I'm sorry but you're wrong. There are many companies who transition to a new technology gradually. In my industry there's a monolithic Java application (with Java Applets) and they've been successfully and slowly migrating everything to HTML5 over several years. I imagine this approach is used in virtually every industry and while it can fail, it can also "end well".
If 3% is considered slower, I want to see multiple runs and standard deviation, not just multiple iterations. However, I do agree with the message. Do not make assumptions about tools and benchmark. But, that also means benchmark well. 
Basic on an Apple II+. Don't ask how old I am.
When I was around 8-9(?) my Dad bought a PERL book so that he could teach himself the language that was needed for a job he was interested in. As he was studying, he would have me read the quiz questions from the book and compare the answers he gave to the ones in the book. I didn't understand anything he was doing or what the book was saying, but I just read the text and compared the answers he told verbatim against the book. I didn't realize it at the time, but that was the first memory of me having any interest in computer programming. I had no idea what it actually was, of course, but I was interested nonetheless. While I didn't do any actual work myself, my Dad later built me my first website. He taught me how to use Frontpage 97. I quickly bumped into my limitations in understanding how things worked so I began to get curious about source code. It was around this time I started to dabble in some pretty basic HTML. Fast forward to when I'm 14 and I ended up learning CSS, Macromedia Flash MX, ActionScript 2.0, and PHP 4 and 5. I was able to learn all of this stuff because my Dad was more than happy to buy me books and answer questions that I had. I eventually reached a point where the subjects I were researching were outside the scope of relevance for my Dad and his job. At this point I began joining tech forums like Tek-Tips, Ikonboard, and others. My first real project was integrating a portal "hack" (like a plugin for a system that didn't have plugin support) into Ikonboard. That saw heavy use until Ikonboard was retired. I remember having a lot of fun and having great admiration for a lot of the forum hackers back in those days. Now I'm almost 29, and I just started going to a University so that I can pursue a Bachelors in Computer Science. *Edit:* I just realized that I'm in /r/javascript. I learned JavaScript at around the same time as ActionScript 2.0. I started off by just copying and pasting a lot of those free JavaScript snippets I found online. Then I became unsatisfied with how some of them worked so I began tinkering with the code. I'm realizing there is a pattern here. I'm either curious or unsatisfied about some code and then I learn it.
I don't know why it's that hard to come up with scenarios. Basically everything that needs shared-mem natively needs this, the web is way past text+images. Example: we're transferring a CAD system from native to the web. We use workers so loaded models can be parsed on all cores, made a huge impact already. But writing data back to buffers and then to the gpu still causes frame drops currently. Shared memory will allow us to write straight to buffergeometry, which will eliminate the last hint of lag. I could imagine that shared mem also has implications for v-dom diffing, constraint or physical systems, etc. Overall it's a nice development along with webasm and other technologies coming out now. These are the only things that still hold the web back. On other fronts, like managing visible view and frontend, the web eats native alive already so this will naturally result in very powerful cross platform apps and the web just plays a part in hosting them, as it should without drawing distinctions to native counterparts.
I did multiple runs of multiple iterations each. Results do not differ by much. Although I could've tabulated the results, chart and get statistics, I couldn't be bothered spending more time. Wanted to reach to a quick conclusion and break the promise that it actually optimizes and makes code faster.
&gt; IMO Vue is the less complicated better organized frontend framework (though not a complete framework, also IMO) When I start a project with my company, we figure that future talent needs to be able to decipher the code. With NG1,NG2, and React we have already run into problems with lack of good resources. I cant spend 150k per developer to ensure that I am getting my projects done on time. I can spend 100-120k to make sure I get a good JS programmer and only have a short training period with vue. I hope this makes sense. 
Good point. This was actually one of my initial reservations as well - until I saw that it was possible to export your entire database at any time to a JSON, ready for importing in to another database program, like MongoDB. After discovering the export functionality, I began to view Firebase in a similar regard to other services I was using, like Sentry for logging, or Sendmail to manage the transactional email reminders. I think the question then becomes, why should database-as-a-service be treated differently from logging-as-a-service or transactional-email-as-a-service? 
Would be interesting to know your use case.
I don't know why the downvotes. While I appreciate the time the author took to write this, I was hoping to see a longer list and how those methods looked in the console, not just the code.
A client of mine made a custom JSON format to handle an history of changes on some data they display and edit on their frontend. It is not the first time I see something like that. Based on that statement, I was wondering why there is no git like system for this. So I gave it a try the last week-end and it was really interesting to do it because I realized that git is as simple as it is powerful.
I think the advanced optimizations are where it gains speed, since it eliminates code. I'm sure nobody would claim the basic compilation, as shown in your example, would make much difference in speed. Essentially it just converted everything to vars and made an if...then into a ternary.
&gt; I don't know why it's that hard to come up with scenarios Well, I just hadn't come across them, so I was wondering. Not saying they don't exist. Loading models for CAD systems does seem like the sort of thing that would benefit from this, yeah. Thanks Re: v-dom diffing, some folks were doing some experimentation with this a while back, but the need for constant serialization was adding a considerable amount of overhead, so those efforts have mostly been abandoned.
I think Grunt maybe larger (if you include outside of pure JS usage by other web programmers LAMP, Ruby, etc) in terms of usage and libraries. I don't have the numbers, but based on finding libraries, etc. I am more likely to find a Grunt version than a Gulp version. Granted I like Gulp and it is maturing into a great tool.
I want the rendering to happen behind the scenes. Isn't electron for desktop apps? Are there any other frameworks you suggest I can use? 
Up vote this hero
I like it. Combine this with Knockout and you have a SPA. SammyJS seems a little overkill to include just for the routing feature.
Younger than me if it was a +, but those days were brutal. 
11 years, started when I was 15, wanted to be a hacker, read that to be a good hacker you needed to know how to program so I took a PHP and MySQL course. 11 years later here I am :)
It's not about being _able_ to, it's about wanting to. If they're using a framework geared towards beginners- or even, have a workflow geared towards beginners, that'll make it a less attractive place to work for more experienced developers that'd rather not have designers dictate their front-end setup.
Because that wasn't the only consideration?
Good question. You're fully allowed to update tectonic's internal state. Right now the current way you manipulate models stored in the reducer is by making external queries. For example, if you do this: this.props.query({ queryType: 'UPDATE', model: User, modelId: 12, params: { id: 12 }, // params in your API source definition body: {...}, // new dataOtherwise, any re-rendering by react would }); Tectonic is going to look for an API endpoint that allows you to update the user item (with the given params in query). If this query is successful the internal state of the reducer is updated. So, if you have a model that you want to update without an API endpoint you'd need to make a new "driver" that returns "OK" for the query. All API endpoints (source definitions) are mapped to a particular driver, so by default this uses superagent to make requests for each query. It's really easy to make a mock driver to return fake data during development, then swap out `manager.drivers.superagent` for your custom driver. That's a way you could make this work. Alternatively, I could build out an API that lets us update the internal state of tectonic without hitting any API endpoints. What's the use case for this, and what do you think?
I was originally going to mention this as well, but upon digging into the advanced mode more, the documents only address advanced mode's ability to achieve [aggressive] minimization/compression, with no mention of performance. (https://developers.google.com/closure/compiler/docs/api-tutorial3) Dead-code removal will only remove unused code, and this will save on space--not performance. It does perform function inlining for small functions, which may have a performance impact. However, the documentation implies this favors space over performance: &gt; ...but the Closure Compiler determines that in this case inlining is safe and saves space.
They can't hire good front end talent because they pay absolute dog shit. They provide a calculator on their site, and the ranges for anything in the US is laughable.
Thanks. There is working example using `nanomorph` and `bel` so some tiny wrapper could be done and you have full featured "framework" without the framework, in 1-4kb min+gzip (zopfli)
How feasible is it to implement a library like this with a website which is already built? I imagine that the real page would be fetched using Ajax when the router intercepts the URL.
Nope. Typescript and/or always use latest vanilla ES features and transpile to your browser targets.
- 13 years - taught myself action script during my graphic design thesis - built flash games for years using actionscript and some javascript - moved into web development, learned more javascript, markup languages, pre-compiler languages, build processes - started getting into data visualization - d3 - moved back into games but with javascript - started getting into coding for art sake - super collider, p5 - now looking to learn C# and C++ to move into 3d gaming
Right. That's what I was getting at, and you did word it wrongly. It most certainly is not a view library.
2 years full time, 3 years at uni. Started out doing C++, C# and Java at uni while studying computer science, moved onto full stack JS work after graduation
What do you consider adapting? Writing usable code? Sure. Writing code in a new framework that won't need a refactor asap? I highly doubt that's possible. At least in terms of angular 2, I still find ways to improve stuff couple months in. Also frameworks change rapidly as they go, so you have to be on par with that as well. Anyways what I am trying to say is the basic knowledge of the framework is a matter of a day, adjusting to a new ecosystem and understanding it in-depth might take months.
What do you guys think about the self hosted parse server? How does it compare with Firebase?
I personally think Visual Studio Team Services cloud based CI/CD is the best out there currently (you can use it with any stack not just MS). To each there own.
Alright. I have zero experience in server-side javascript, but a relatively strong command of how to build MVC systems. Can someone ELI5 (maybe ELI15) what this is for? Googling 'UI Router' is less than helpful. This is... a tool for determining routes when using a framework like Angular? Maybe give a usage example?
But you are a single developer right? Then it makes sense to get this much value for so little time/money investment. But companies don't really like to have their data outside, and definitely not spread out of multiple different service providers. If you build using all external services your business has a ton of failure points outside your control. You can make assumption that firebase or whatever will notify you of issues or end-of-service so you have time to export and migrate but what if you come at the office and all data is gone? Does you customer care you relied on third parties? No, they will look at you. What if you depend on your Sentry or logging history to triage stuff and it is gone? Send angry emails? How is that helping you fixing production? 
If you mean the background, you are looking at a widget.
Doesn't work for every company and product and even when it does, massive quirks in using firebase at scale. DevOps is safe for now. 
I'm a little confused. This lib acts as a JS object repository in memory? I think the Git and JSON parts maybe misleading. FYI - I saw failing tests when I pulled Master.
I might be over-egging it slightly, but it was "issues, merge requests, users, comments, snippets, etc", so hundreds of thousands didn't seem an unreasonable estimate for the total number of lost records/updates to me, though obviously YMMV. Even worse though, the only reason they only lost 6 hours'-worth of data (rather than the full 24) was because the guy who accidentally nuked the entire production DB *by sheer dumb luck* happened to have randomly done an ad-hoc manual backup of the production DB six hours previously.
We thoroughly enjoyed coffeescript, but are porting everything to ES6 now. There's just too much goodness in terms of syntax as well as ecosystem (eslint, prettier) to justify keeping things in cs. Not regretting cs at all, but at this point I would not recommend diving into it anymore.
As a relatively new front-end developer (&lt; 1 year), I freakin love firebase. I can focus on interesting UI/UX challenges, while solving OAuth, db, and deployment concerns with one service. It's been super educational to be able to visually pick through the db, and not waste so much time on `heroku logs --tail` when trying to get something deployed for prototyping, proof-of-concept, showing off to friends and family, or practice's sake. It's kind of a dangerous crutch for a learner though. Now if I try to hand-roll auth, or set up a 'grown up' db, or struggle with deployment errors, I default to thinking 'ugh, I should've just used firebase again.' 
If you can use React you can jump into RN and pick it up as you go along. You don't need to know the native features before you get started as you'll find them as and when you need them, that's the way I approached it and I had no iOS or Android experience. &gt;Is it worth it to use React Native instead of just react js + cordova If it's mobile only, use RN. If you need a browser app as well then use Cordova. Cordova = web, Android and iOS. RN = Android and iOS.
&gt;DevOps is safe *for now.* Exactly What sort of quirks does one run into at scale? I've only used it for small projects.
32 years ago. The company I was working for needed to generate mailing labels from their custom-built manufacturing control database. I found the manual for the programming language in a storeroom and spent a few days learning Business Basic &amp; building a print map for our chain printer. *et voila!* I've changed my primary focus a few times (Business Basic, SAS on mainframe, SAS on OS/2 at another place, Powerbuilder, Java, PB again, C#/Javascript for a bit), and am now supervising customer-specific mods to the product my current company sells. These custom implementations involve SQL, C#, and PowerShell mostly with a couple of homegrown tools involved in delivery.
That's interesting, to me, React is just as simple, but that may be because I'm experienced with it. 
Yeah... Our company is scaling pretty quick, but we don't have plans to bring on a full time devOps engineer because of services like AWS that makes scaling second nature. It's still valuable, but devOps is quickly becoming a niche. [edit]: We don't have plans to bring on a full time devOps engineer *soon*.
Just to be clear, these are interview questions for a job you didn't get, right? You're not taking our answers from here to go get a job, I hope. If you can't do this, you **will** be in over your head immediately. --- function charTally(input) { return input.split('').reduce((acc, char) =&gt; { acc[char] = (acc[char] || 0) + 1; return acc; }, {}); } * The `split('')` turns the string into an array of characters. * `.reduce()` will then walk each character, using an empty object as the initial accumulator * `acc[char] || 0` gets the current count, or 0 for letters that haven't been found yet 
But, if you keep following up like this, and work to understand, then eventually, you will. All the best!
That's great your company is growing quickly, and AWS does certainly make things a lot easier, but I'll be surprised if, as you guys continue to grow, you don't eventually need to add a full time devops position. Firebase does one thing really well, but AWS encompasses so much that it's far more complicated to maintain than simply uploading code to firebase.
Yeah would be awesome if something like that just works out of the box, but multithreading is never easy
Why would you want to webpack a backend?
For example games? HTML5 is VERY suitable platform for GameDev and allows to create a game and deploy it to website, to all mobile devices, as desktop game etc. However it can become very tricky when you for example need to find A* path on large distance in complicated scene without hogging up framerate. However I wish Node would share the same feature with native worksers and shared buffers.
If anyone is interested a while back I made a little module that extends the console object to allow for functions to execute before the log. I needed it at the time for an easy way to have my own logging in a big group project that I could turn on and off https://www.npmjs.com/package/console-extend
Thanks a lot! Now I understand.
ajax is async, so your return statement doesn't have the data. the function is returning before the ajax request has completed.
To use ES6.
I'm using TypeScript with Immutable but just use Map&lt;string, any&gt; and then convert to a typed object if I need to later. e.g. const { prop1, prop2 }: Foo = foo.toJS(); I saw a post somewhere about someone who created a class around a typed Immutable.Record... sorry, don't have a link for you. Try Googling for it.
Most features you want from ES6 are already supported by node. If you're looking for something further along the line, like ES 2017 support, then you'd need to use a transpiler. http://node.green/ is a good resource to see what is supported by your version of node. Webpack is only providing ES6 functionality via babel. If you do still need transpiling, I would recommend just using babel directly. https://babeljs.io/docs/setup/#installation Either use the cli, or the Require hook. The require hook is not considered "production ready", but is very easy to get started with.
Yeah he sounds like he has no idea. 
Types don't really go out of the window just because you use immutable, it has an associated type definition. You can quite easily `Immutable.Map&lt;string, SomeModel&gt;`, `Immutable.List&lt;string&gt;`, etc. The react app i currently have my hands in uses this heavily. In fact, the only place we lose type information is redux (sometimes). I would say, though, don't overuse immutable. Use it where it actually helps rather than a full replacement for all your state.
You seem to be confused about Javascript's asynchronous nature. [Here's](http://rowanmanning.com/posts/javascript-for-beginners-async/) an article about it. By the time `success` is called, `ajaxGetData` has already returned. If `ajax` was synchronous, it would simply return `data` rather than taking a `success` callback.
Vue isn't geared toward beginners, it's geared toward a different kind of stack where the library used for DOM manipulation is much less opinionated about everything else. 
I'm afraid I win. I started programming in 1966 at college and I'm still going strong today. We started with a made-up interpreted assembly language that the previous year's class had developed. It was called "SexaTac" (Sexadecimal [base 16] three-address computer--would have been hexadecimal today, but we were in college and too cool for that shit), and it taught us the concepts of registers, memory, looping, etc. We moved on to Fortran and real assembler (IBM 360) the next semester. Remember, this was when there were no terminals. We worked with punch cards. We had to submit a job to compile; wait to get back a deck of object code; and then submit that deck (surrounded by JCL--job control language) to run the program. Total turnaround time was often a day, so we learned how to patch our programs by writing fixes on our listings, assembling them in our heads and on paper ourselves (into hex), overlaying a goto to the new code at the end of the deck and then a goto back to the statement after the mistake we were fixing. Punching object code into cards involved multi-punching--holding the card (with a keyboard key) stationery while we multi-punched the correct rows in the current column. I've programmed in (sure I'll forget some): PL/I, ALGOL, Smalltalk, C, C++, C#, Java, Lisp, JavaScript, Pascal, and I'm sure a half dozen or more others. I've stayed working in IT for the whole time--almost 51 years now. I still work on startups almost seven (now shortened) days a week--maybe not full days. I always have 2 or 3 companies' irons in the fire. I've started, managed, designed, architected and programmed. Now I just program full-stack using Node and JavaScript.
I also came here to make a low effort post about the low effort posts.
Like theodore_q mentioned, you can use tombstones to mark code you think might be dead in your codebase and then use something like error reporting / monitoring to verify if that code is actually dead. Blog post: https://blog.bugsnag.com/javascript-refactoring-with-bugsnag-and-tombstones/ 
You can still pass in context though. Wrap your () braces with another set, and voila.
Well, the equivalents of polymer polyfills in vue or react are their custom virtual dom/component implementations, they serve exactly same puprose - to render the dom. (you know that react source is a lot bigger than polymer with polyfills?) I think if you look at it this way it this way it makes little sense to complain about polyfills. Also css encapsulation IS polyfilled - its not perfect but the styles from element get prefixed and don't leak out outside. You can use polymer on IE's that are supported by MS (Hell I even got our enterprise application to work on IE10 just fine) - I fail to see the problem here - you might not even know you use it on EA sites, or youtube or google properties :-) ING banking uses it so I think if "conservatives" like that use it I think your worry too much about it. You can read tons of misconceptions about polymer on the web but almost always its by people who never used it in production. Probably most people here on this subreddit use polymer one way or another since its used... in Google Chrome UI.
How does this differ from something like mongodb or couchbase?
With things like horizon.js and rethinkDb it is scary, i've replaced backend me, can now scale like never before with stateless server connected to easy clustered rethinkDB. I'm more efficient now than a whole team of me 3 years ago. I too am scared in the long run. 
This seems like just standard WebWorker stuff though. Why would you need atomicity/shared buffers for path finding?
Indexing through strings is a path to the dark side. It's 2017, learn to let go of your hate, and embrace the fat arrow. ;-)
This is actually my least favorite part about redux-saga. The testing ends up being so highly coupled to the code written it's almost tautological. 
You can try: Callbacks: function ajaxGetData(formId, callback) { $.ajax({ url: "/FormController/GetDataFromDb", type: "POST", dataType: "json", data: { id: formId }, success: function (data, status, xhr) { callback(data); } }); }; ajaxGetData(123, function(data) { console.log(data); }); Or check Check examples for [jQuery ajax](http://api.jquery.com/jquery.ajax/) with [Promises](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise) $.ajax({ url: "/FormController/GetDataFromDb", type: "POST", dataType: "json", data: { id: formId } }) .done(function( data ) { console.log(data) }); 
In the city is insane. If you're up for a 30-40 minutes commute you're looking at ~$2000 for a 2-bedroom apartment, but that varies depending on which direction from Seattle you travel. I haven't checked, but I'm willing to bet the bay area is much worse. 
What is the browser support for the fat arrow? Except for my current job, I've had to support IE8+ (blech!) and before that IE6+... Fucking corporate SOEs...
How do you serialize 10,000x10,000 fields dynamic map to web worker without noticeable delay for pathfinding purposes? You cant do this once because map is changing during runtime.
I couldn't find anything either. It sounds like a lot of popular bloggers in the JS world got together and agreed to tell everyone React/redux won the battle of the UI frameworks and jQuery/angular/ whatever you could possibly be using is dead. Also if you're using react/redux you're already behind, you should be using Elm by now get with it, old man. P.s. Vanillajs with every possible nonapproved ecma6 proposal in it transpired by babel is a necessity.
And what happens if you have a requirement to reverse that relationship or report across all users later on? For the love of god, use a relational db. "the extra hassle figuring out how to store your data in a way that makes it queryable" is a horrible idea.
As /u/tech-ninja shows, it's perfectly possible to apply efficient sorting algorithms to LinkedLists, making it just as fast as sorting arrays.
You're right it is not clear enough. The purpose was to get a lib which work on the frontend like a react application. And about "why I should be using this?", it was more like an "experiment" to see if this is possible, is it reliable and fast enough. As it is working great, I want to share it.
I live in New Zealand and in an expensive city (for NZ anyway). The pay that GitLab provides for that frontend job as a beginner is about $14,000 USD more than you would get from most jobs at that experience level when working here.
That is the exact computer I took apart when I was about 8. Been tinkering and programming since.
came to say something along those lines, but now i do a bunch of other shit, including javascript -&gt; but the javascript is much better :D 
If the bottleneck is in serialization, certainly not via multiple WebWorkers, since you'd be blocking the main thread regardless... The CAD example seem reasonable, but this seems like a stretch, sorry, no offense.
Do you use redux or something else to manage state? I think that might just have a bigger impact than the typing system or immutable.js. If you do happen to use redux then by all means you are already using plain immutable state, shallow copies that bubble up, re-using unchanged nodes so attached components don't render. It isn't black magic, a simple javascript reducer does that without breaking a sweat. React-redux btw. employs reference equality checks by default, you shouldn't normally have to deal with shouldComponentUpdate. So i'm not sure if there's any gain. Besides, there are downsides as well, immutable grows through a codebase like a fungus, everything it touches has to adapt to its way or pay the toJS/toObject penalty. Though if your circumstances still demand it, you'll find good information over here: https://github.com/markerikson/react-redux-links/blob/master/immutable-data.md
haha. for real. now i'm building full blown apps and apis. not just image rollovers.
[removed]
&gt; that eveything is an 'element' Well it is only element if you want it to be - I actually grew to like it - it allows for nice combinations with binding system, but everything is possible with imperative style also. Btw. you can use unflow-polymer or polymer-redux (or others) with it too, its possible, I really like the interoperability of it - I even used it in some of our legacy jquery applications. Reference: https://github.com/google/uniflow-polymer/tree/master/todomvc Yeah the Amsterdam Summit was great, I really like that big enterprises are adopting polymer as their solution - it is part of web platform API's so eventually we will all benefit from this, even when people will use some other solutions that will switch to web components under the hood.
[removed]
Wat?
My thoughts: Authentication is great until you need to support multiple environments. You can't administer users or specify their uid as part of the auth flow. This is necessary to store/link to user data in the db. I had to offload auth to a third party service. My database is about 600kb in a gzipped auto backup, and the firebase console is now nearly unusable. Soon I will have to administer/query it via CLI or a thin app. Rules are difficult to implement. If you give read access to a node you can't revoke it further down the tree. You have to denormalize your data a lot. Firebase is great, I'm using it in a small business in production with 6 figure revenue but just be careful before you jump in.
Yes, a big difference. Look at the provided examples more closely. A hint: map will return the same number of elements as the list you provide and filter won't.
Using rollup with my modules defined using es6 format is definitely effective, because the code is designed to be partitioned. Individual private functions within the modules are not included if I never import a function that uses them. However, I still have to bundle my libraries using an older method because I am using older versions. In the future, I will be able to include only what is needed, reducing the size of my lodash and ajax libraries. React and other libraries I suspected can't be shaken much as they are pretty wholistic. Perhaps some future react could make the proptype checks and the class model system function-based, rather than object or class based. If so, whole parts of the api could be excluded.
Is something not clear?
I hate noSQL, but I love firebase. You are 100% correct that its a huge loss compared to an SQL database, and I always use SQL at work, but with firebase you have to manage nothing, scale nothing, reset nothing, bootup nothing, and backup nothing. If you're a large team, that's almost valueless, if you're a small team that's _amazing_
Very interesting. Thanks for sharing!
`console.group()` also has an argument (on some browsers) to name the group. `console.groupCollapsed()` does the same but with the group already collapsed.
It's unclear what use cases DOP is targeted for. What kind of problems it solves *better* than other solutions? Saying "can you imagine the possibilities" is not enough. I can already imagine not only the possibilities, but I can whip up myself a basic CQRS solution with commands and distributed state views in under an hour, ending up basically with what DOP is. Also, it's always suspicious when a library like this doesn't talk about consistency. What happens if a non-owner node sends a command that conflicts with another node's command? What happens if the connection interrupts and resumes later. How can I persist these objects without losing all the implicit wiring they have to subscribers and owners? Any mature library of this kind would have some story for these aspects, otherwise it feels like a toy. BTW, the entire site is made as if DOP will support N languages, but the only thing that's supported is JavaScript. It makes the site look awkward. And with the way everything is tangled with JS object proxies, properties and method calls, the idea that this will be able to be exposed naturally to other languages are slim. And purely from a design perspective, why should a non-owner node two times removed from the owner send commands through a chain of nodes, instead of directly accessing the owner? The additional hops seem unnecessary, except in the edge case of the owner not being directly accessible (which it often will be).
Right, so if pressing enter in the input triggers their JS, then mimic this behavior when you want to programmatically submit your comment. Unfortunately for us, [MDN's KeyboardEvent docs](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) don't contain proper examples for manually triggering your own KeyboardEvents. Still, this documentation does explain the various properties the event will have. Whatever code instagram is using, as long as it triggers off a KeyboardEvent then it should be looking at some of these event properties. Google does provide some useful results on how to make your own KeyboardEvents, for example see [this StackOverflow answer](http://stackoverflow.com/a/11885974). You'll have to look into exactly which type of KeyboardEvent is needed: keydown, keypress, or keyup. You'll also have to set some other event properties, such as `key` and/or `code` (and perhaps others) to properly show that this event represents an enter key being pressed. The key (pun intended) is to get your custom event as similar to an actual KeyboardEvent as triggered by pressing enter in that input box. You could even attach a temporary event listener to get a sample of how such event object looks like.
&gt; transpile And I thought IE8+ was bad ;) but really... another wrinkle in the deployment process? I've avoided it just for this fact. Plus [fat arrows are ugly obtuse bastards](https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/)... but it's what all the cool kids are doing now and it keeps my backend programmer buddies away from my job so, when in Rome...
I'm going to include this in my newsletter tomorrow, thanks! :)
&gt; Bob did the changes 100ms later. So John will receive the changes too. Even if they are a random nonsense. You completely ignored the problem here... the article was lost. These types of issues are important in distributed computing, you can't just wave them away, just because they kind of make sense at the low level due to how the protocol works. I.e. "it works as written" doesn't mean "it works correctly". &gt; Without use cases, people can't understand. I though with the slides was enough to get the big picture and to understand the concepts. But is not. I need to write use cases and examples. I just want to add, I don't mean to discourage you, or anything, but distributed state is an incredibly hard problem and no silver bullet exists for it AFAIK. Lots of specialized solutions that have different pros and cons. This is why the use cases are important.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
I thought that newer versions of DevTools etc took care of this? I agree this would be a big point.
http://frontendfocus.co/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Why 'const foo = () =&gt; {..} vs function foo() {...}' ? (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sq6jg/why_const_foo_vs_function_foo_from_rjavascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; I didn't understand the problem here then. Are both online/connected to the server? How is the architecture? John is connected to Bob directly or there is a server in between? Could you explain better? There is a server, and there are two users with their browsers. If both update at roughly the same time, one of the user's update will be dropped and lost, and that's not a good idea, especially when the user might have expended significant effort in getting their update done (hence the example of an "article"). This is a basic CMS use case question, which applies to lots of situations where users do complex manipulations of the domain, where it's not irrelevant that you might just "lose" their updates casually. To allow people to model more complex resolution schemes, you must at *the very least* support user auth for each node, so it's clear who the command is coming from. Does DOP support user auth? &gt; I appreciate the feedback, really :) I know is difficult but with a unidirectional architecture there is only one source of truth so there is not conflict resolution or problems of synchronization (except for arrays). Is as simple as, the one that came later wins. I'm sorry, but I get the feeling you don't understand the issue, because you need to research the issue further. "The one who comes later wins" doesn't mean there's no conflict, because "whoever comes later wins" describes almost no real world domain that those objects would use. I already gave an example of an order that is canceled, then marked as completed. In this case who came earlier won, but sometimes it's possible that no matter who comes first and who comes later, when their updates are combined in the domain, the domain reflects neither's intent and so nobody "won". I gave a few examples of this, but you only seem to notice the issue with arrays. Well, the issue that prevents reliable update of array item order is the *exact same issue* which can cause lost updates, or running command on non-existing objects, loss of data, corrupted data and so on. A system like DOP implements, would permit "read skew" and "write skew" which are consistency issues, ones which can mess up the state of a system in a big way once you start looking at state consistency across objects. There's also the issue of "atomicity" i.e. that two objects who receive related updates, might receive them in the wrong order, or separated in time, leaving the system at the non-owner nodes in inconsistent state. You will understand more how this occurs as you try to model real domains with DOP. Not toy examples, not simply chat systems, but something where objects are interconnected, and you need some sort of reliability about consistency and you need good UX for the user.
Looks like excel
Yeah, it sounds like Tectonic currently has pretty full support for updating those models via a server round-trip, but not for directly modifying the models on the client (strictly in-memory). If you read through the "Practical Redux" series I linked above, you can see my description of how use Redux-ORM for client-side data handling in my real app, as well as the ongoing sample app that I'm building and writing about. Lots of use cases overall, but to pick out one one specific use case: managing the creation and editing of a new item in memory, with its relational data, before actually sending the creation request to the server with the completed values.
And hoisting! 
There's not much up-front difference, but once you start using these a lot in development you find some major advantages to writing semantic code and various binding/scoping scenarios. In your example, you can shorten it even further... (you only need to scope when you want to explicitly return an evaluated expression or an object that would confuse a compiler.. similar to how in a case statement of a switch you need to scope the evaluation if you define variables, etc) const render = () =&gt; 'hi' // however, to return a js obj const render = () =&gt; ({ anObjectProperty: 'hi' }) Other benefits include the ability to redefined the function (e.g. let vs const vs var) as needed. It is more semantic as well (e.g. const someFunction lets me know immediately that is a static function that will not be redefined). Now, you should also consider binding this in ES6 format vs ES5 (so, nesting/scoping function vs const someFunction = ()... will matter significantly). With all this in mind, there are various/more-optimal scenarios to both use function vs es6 definitions.
Sequelize is my favorite so far, although to be honest, I use it more as a query builder than a fully fledged ORM. Haven't heard of TypeORM. I really like the syntax, though. Looks heavily influenced by entity framework. I like that the models aren't explicitly linked to the database methods. I think I would sorely miss the declarative query syntax, though, compared to [sequelize](http://docs.sequelizejs.com/en/v3/docs/querying/). Query builder syntax is nice, but complicated to hook up to an API compared to a query you can define in json.
&gt;What do you consider adapting? Writing usable code with appropriate abstractions, so that it can be refactored in future with ease. With code reviews and more experienced developers at hand, this can be accompolished faster than others misght think. &gt;Writing code in a new framework that won't need a refactor asap? I highly doubt that's possible. That is not possible regardless of technologies or languages. We, programmers, are constantly learning new things. So any old code can be improved by better docs, naming or tests. &gt;Anyways what I am trying to say is the basic knowledge of the framework is a matter of a day, adjusting to a new ecosystem and understanding it in-depth might take months. FYI, I totally agree with your statement. But my perspective is somewhat skewed because of other factors I have not mentioned.
&gt; That's why you ask about Auth. [...] Yes but you need to develop your own conflict resolutions for your use case like the shared document. To develop my own strategies I'd at need to at least know who the remote call is coming from. Does DOP have auth? It'd be needed for many other reasons as well, like security etc. And the problem with developing strategies on my own is that this is where the bulk of the work is. Not having some pub-sub over sockets. &gt; That's not possible in dop. Imagine mutation 1 and mutation 2. Mutation 1 is lost and the client never receives it. But receive mutation 2. The client will notify the server that mutation 1 is missing and the server will send it again. That's not what I'm asking about. Let's say I send a command (RPC) to the "owner" node. This command results in N mutations across M objects. The client must apply all-or-nothing in that set of mutations, or otherwise it'll wreck the client node state consistency. In other words, atomicity. Does DOP have that?
&gt; And the problem with developing strategies on my own is that this is where the bulk of the work is. Not having some pub-sub over sockets. I agree, but there is no panacea for conflict resolutions and dop don't try to solve the problem of a shared document. Dop helps you to manage your state that's it. Implement a shared document is up to you on the same way that you would do with vanilla javascript and WebSockets. &gt; This command results in N mutations across M objects. The client must apply all-or-nothing in that set of mutations, or otherwise it'll wreck the client node state consistency. I assume the client is subscribed to multiple objects from the same server. So yes, if you collect N mutations of M objects and you emit them at the same time. The client will receive all the mutations together. But is just a merge like lodash.merge (if are arrays involved is more complicated). I don't see your concern. Give me a specific example and I will tell you the solution (Without arrays because is the next chapter). 
Hi /u/mikeptweet, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com](/search?q=%28and+site%3A%27medium.com%27+author%3A%27mikeptweet%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|13|93%
I'm going to try it this afternoon, but I already tried to catch it by this command : "document.querySelector('textarea').textContent" but it return null.
It does for functions assigned to variables. http://stackoverflow.com/questions/27977525/how-do-i-write-a-named-arrow-function-in-es2015/37488652#37488652
TypeScript guy here - in 2.1 we introduced `keyof` and index type queries. Check out the example [here](https://blogs.msdn.microsoft.com/typescript/2016/12/07/announcing-typescript-2-1/) on the `get` function. While that doesn't entirely get you what you want, I think you can easily wrap Immutable.js to work with the types you need. Going forward, I think we'd like to try to get to the point where Immutable.js can serve users who want both immutable objects as well as immutable maps, which is, as I understand, the current issue that makes things a little harder.
Who are these people that work with HTML and CSS that refuse to learn JavaScript? 
Well, tree shaking with lodash is known to not work for a year. See the [webpack issue](https://github.com/webpack/webpack/issues/1750) and the [rollup troubleshooting section](https://github.com/rollup/rollup/wiki/Troubleshooting#tree-shaking-doesnt-seem-to-be-working). The problem is that lodash modules contain a lot of code besides the imports/exports and per TC39 spec this code must not be eliminated.
How can you justify to your client that some services shut down and they have to pay you like x days of work to migrate to another service to keep their app running ? 
`=&gt;` binds `this`which makes it quite attractive when you use it inline. The following for instance just wouldn't work: class { constructor() { this.offsetX = 0; document.addEventListener('mousemove', function(event) { this.offsetX = event.offsetX; // `this` points to the global `window` object }); but this would: document.addEventListener('mousemove', event =&gt; this.offsetX = event.offsetX); Also it's shorter and less verbose. Especially if you use it with JSX `=&gt; &lt;div&gt;...&lt;/div&gt;` or Redux `@connect(state =&gt; ({ time: state.globals.time }))`
Designers. If they're good at css and markup it's not even a bad thing, then it's just sprinkles of logic and bam, you're done. They're my favourite kind of designers for the web because they understand the intricacies of their medium. 
Here's mine: const test = 'a string with different characters' /** * Returns an object mapping characters to the number of appearances in the string. */ function countCharacters (testStr) { const charArray = testStr.split('') let charCount = {} for (let i = 0; i &lt; charArray.length; i++) { if (charCount[charArray[i]] !== undefined) charCount[charArray[i]]++ else charCount[charArray[i]] = 0 } return charCount } console.log(countCharacters(test)) It's fun how everyone has such different solutions!
TIL about reduce haha.
For anyone who needs a great package for use with React and Firebase. I highly recommend [Re-Base](https://github.com/tylermcginnis/re-base)
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/keithwhor [Build an Alexa Skill in 7 Minutes Flat with Node.js and StdLib](http://np.reddit.com/r/node/comments/5srmb5/build_an_alexa_skill_in_7_minutes_flat_with/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
You could use `Object.prototype.hasOwnProperty`: myString.toLowerCase().split('').map(v =&gt; { (!obj.hasOwnProperty(v)) ? obj[v] = 1 : obj[v]+=1 }) But don't worry - There are tons of opportunity for You!
personally, reusability with react, 99% of the time, means you can do: {Object.keys(obj).map((k) =&gt; {return &lt;MyComponent key={k} /&gt;})} to accomplish reusability between projects just doesn't seem worth it.
That looks awesome. Think I would have saved a lot of time if I had heard about it sooner!
AWS still need DevOps once you use it at big enough scale or enough services. From what I've seen Google Cloud is much closer to a true NoOps environment.
I just found out that you can directly `copy(obj)` an object in Console. When you paste, the output is even well indented. No need to `JSON.stringify(obj)` then copy carefully with the mouse and then re-indent in a text editor. Really convenient when dealing with large objects.
Webpack is kindof useless in that case. Just use Babel directly with the stage you want.
If they're creating my HTML+CSS, then they're interfering enough with my work for it to become annoying, I think.
You should definitely use API Requests with HTTP Methods such as: * POST - create an object * GET - read (this is already standard) an object/list/etc. * PUT - update an object * DELETE - (quess what) delete an object In your example, you mentioned routes as */foo/:id/edit* which would be a view ... so send a GET Request to get a form or something. If you submit the form anyhow, make sure it's a PUT Request, since you want to update your specific foo. Same goes for POST and DELETE. These aren't pages the user could see, they are part of server-client communication. I hope you got the idea. :)
Wouldn't have to, originally WASM wasn't meant to interact with DOM although that quickly changed. It'll just be something else you could do, I don't think Javascript is going anywhere anytime soon. Even so, I imagine someone would make a Javascript -&gt; WASM compiler.
Use Karma to run your tests in chrome. [Here's an example running tests in Karma](https://github.com/eddyerburgh/avoriaz-karma-mocha-example). There's a bit of config, so you should find a tutorial.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [This is quite embarrassing but, can someone ELI5 how to test front end JS? (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5ss7fg/this_is_quite_embarrassing_but_can_someone_eli5/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
edit: If you just want to get jquery working you probably have to assign $ to the window object of jsdom. I would still recommend that you mock $.getJSON to avoid network traffic in tests. I know this might be a bit controversial, but personally I would not test DOM manipulations directly because that is often finicky and prone to breakage when you change the DOM. I would rather try to separate DOM and business logic (that is, make the `getData()`method only return a promise for the json-result and move the logic to set the text of the header to another method). Having said that, you can [run mocha in the browser](https://mochajs.org/#running-mocha-in-the-browser), and if you need to run it headlessly you can use [phantomJS](http://phantomjs.org/) to do that so that you don't need to mock the dom. If it is a requirement to run the tests headlessly and you feel that is too much work to run it in the browser. You can mock the button and h1 jquery objects. I assume that is how jsdom works. Call `new Foo(...)` with objects which has just the methods you need to test the `Foo` class. You also need to mock any globals: // in the setup method // mock $.getJSON (not sure if this works) global.$ = { getJSON: (url, cb) =&gt; cb('result') } // in the test // mock the jquery button element const button = { on: (evtType, callback) =&gt; { // You can set some variables here to verify that this is called correctly this.callback = callback } } // mock the jquery h1 element const h1 = { content: '', text: newText =&gt; this.content = newText, } const foo = new Foo(button, h1) // Test foo.getData() foo.getData() assert(h1.content === 'result') // you want to make this into multiple tests instead of resetting h1.content // Test foo.start() h1.content = '' foo.start() assert(h1.content === 'result') assert(typeof button.callback === 'function')) // Test event listener h1.content = '' button.callback() assert(h1.content === 'result') This might become a bit cumbersome to do, but it might be feasible if the DOM manipulations are simple. It might help to use a mocking framework like [sinonjs](http://sinonjs.org/). Note that the code sample is not tested, so it will probably break someplace :)
no designer touches html or css, that's a developer work
&gt; Mootools was really ahead of its time. No it wasn't. Why do people say this phrase everytime they just mean "it was good" ?
Also defining a named non-arrow function in a conditional block is a strict mode violation
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Beginner help (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5ssfhz/beginner_help_from_rjavascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Care to elaborate? I agree with the post; these are all terrible practices.
it was a dilettantic world. a bad and inconsistently implemented version of JS, no modularization, and global variables per default. as said in the article: that bundler was hot shit back then, and some languages have had real modules and namespaces for years or decades. it took a long time for the JS world to catch up to what was other languagesâ€™ state of the art in the 1970s.
What is nowjs? Maybe www.now.sh?
was going state that as well...
This looks great. What happens at the end of the session? I did not see a way to restore, maybe repository.tree = savedTree?
its*
&gt; Breaking out of iframes is something I think more websites should implement, &gt; actually, if only to prevent the â€œOMG!!!! Look What this Kid did to his School &gt; after being Expelled! â€ scams that all of my friends on Facebook keep falling for. What have framebreaking iframes to do with shared clickbaits?
Wait, did the C64 ever have a C++ compiler? That doesn't sound right.
You can export the full repository by calling toJSON() method and then give it back to createRepository() to reload it. It is explained at the end of README.
Thanks a lot I will give it a try. Currently leaving work will test it from home in a bit. 
Thanks for implementing every boss's wishlist
Needs `onbeforeunload`
If anything, programming has been motivating me more to start my bussiness. I am afraid I qualify as the type of person who dislikes programming,
Something like this was brought up on esdiscuss not too long ago, but got no traction https://esdiscuss.org/topic/shortcut-for-call-of-a-method
It means that it was good, but not super popular as front-end development was not nearly as big as it is today. Demand for front-end frameworks grew exponentially *after* Mootools' peak. Thus, "ahead of its time". 
But it didn't.. the demand didn't grow after its peak. jQuery happened is why demand fell.
That is really cool, but I noticed that it doesn't mix paints that come in contact.
http://www.js-data.io/docs/home has been good for us (using @3 rc). But, we're only using it the browser. It has adapters for a lot of DBs and other forms of persisted storage.
You could make a babel plugin or something to do this if you're using a transpiler already, otherwise it's a bit of overkill.
Cant u simply do ({ id }) =&gt; id === 1 ?
add to array and then .join(",")
This is kinda shortsighted, for example, it doesn't play nicely with closures: a.find(list =&gt; .find(function(item) {return .length}) // length of what? ) If you're that lazy, you could do `arr.find(p =&gt; p.id === 1)`, but frankly, you're writing code to be read later, so just take the extra second to type things properly.
One other option would be to create a function: function propEqual(name, val) { return obj =&gt; obj[name] === val } And then use it like: arr.find(propEqual('id', 1))
It's shorter in Scala... arr.filter(_.id == 1) 
Testing this should be fairly easy once you know what you need to do. We could even test this in nodejs with fairly little effort. The basic idea would be to consider your code as inputs and outputs. You have some inputs that go into somewhere, and then some outputs that happen as a result of those inputs. In this case, one thing we could test is that when a user clicks the button, the text changes. So we would consider the click event an input, and the text changing the output. What we need then is a way to make that input happen in the test, and some way of verifying the output happened. Here's a quick example, this should run in mocha: var sinon = require('sinon'); describe('Foo', function() { beforeEach(function() { global.$ = { getJSON: sinon.stub() } }); it('should change h1 text to fetched cat name when button is clicked', function() { var button = { on: sinon.stub() }; var h1 = { text: sinon.stub() }; var expectedText = 'this should go into the h1'; global.$.getJSON.yields({ catName: expectedText }); var foo = new Foo(button, h1); button.on.yield(); sinon.assert.calledWith(h1.text, expectedText); }); }); `global.$` should make the fake getJSON available under `$` in your code. Though it might work better if you use `var $ = require('jquery')` in your code, and then instead of `global.$` in this test, use `sinon.stub($, 'getJSON');` instead (and revert it later) The way the test works is since we only need those specific functions on the button and h1, we can easily create fake objects which pretend to be those elements. Yeah, it does couple the test to the implementation somewhat, but frankly, testing DOM manipulation like this is generally a bit problematic regardless of how you approach it. We can pretend to trigger a button click by using `button.on.yield`, which makes the callback for `button.on` get called. Lastly it just checks the result. Let me know if you'd like me to explain this in a bit more detail :) (ps. if you're interested in learning how to use Sinon.js better in cases like this, I have a free sinon.js ebook [here](https://codeutopia.net/go/sinon-pdf-download-page/), which has a number of examples for different scenarios)
If you're going to publish a satirical Javascript library these days it needs to be published on npm so you can see how many dependant projects it can get.
Yeah, that's the US for you. Their base is $84,000 in NYC, which is fully $20,000 below the new grad salary for NYC. US salaries are just way higher (regardless of COL) in the US then anywhere else. Supply and demand I suppose. The downside for Gitlabs is they literally end up ignoring the largest sect of skilled software engineers in the world by paying what they do. 
No, seriously, it really is about performance. It is about providing a format that closely matches features and properties of modern CPUs and allows the code to be compiled directly to efficient native code. 
A marketers dream library
I'm so sorry. I have not seen that this article is 6 years old. Yes, back in that times this was a legit threat.
JS ran out of funky characters. Only '#' is left and that one will most likely be used for privacy.
Yeah, that's the main argument for ORMs. In my experience, basic queries that ORMs are good with happen a lot at the beginning, but as time goes on, new queries become predominantly complex (since there's only so much basic CRUD stuff, but exponentially more possible relations). Eventually you have to deal with something like roles, or model composition, and then the ORM just starts to get in the way. &lt;/2-cents&gt; &gt; DTOs and ORMs are not mutually exclusive You're right, they are not. I'm just saying I prefer foregoing a step (i.e. often you need some sort of transformation between what comes out of the ORM and what you want exposed as a DTO, and denormalizing on output is something SQL is good at)
I case anyone is interested, I wrote a little tool that allows console statements to be printed on-screen. This could be useful for mobile development where the console isn't easily available (among other uses). https://github.com/jonbri/ticker-log
Hi /u/creativedrewy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
You might try /r/ProgrammerHumor instead.
I miss old Opera where onbeforeunload existed but was never fired :-/
I've also been using Firebase the past 2 years for a startup I'm working on (shameless plug: [Tokk](https://tokkapp.com)) and it's been absolutely amazing. I originally started building the app with CouchDB/PouchDB (self-hosted) but quickly realised that the DevOps side of things would take up way too much time and attention, so that's why ultimately I chose Firebase. And I haven't regretted it since. It's really easy to get started with and, like the blogpost mentions, the documentation and general developer-experience is great. You can tell the team at Firebase really puts a lot of effort into getting this right. But what's by far the best thing about Firebase is that you don't have to worry about scaling your database and making sure it keeps working properly, and that provides a huge amount of 'peace of mind'. Also, because the Firebase real-time database is all about pushing data, it works great in combination with an FRP library such as RxJS. You can create observable streams for your Firebase endpoints and compose those streams. What's interesting about this approach is that it provides an alternative way of joining and querying your data on the client-side. Which largely solves the problem of the limited query capabilities Firebase offers out of the box. All in all, I can definitely also recommend Firebase!
Webpack can handle ES2015 syntax, but it doesn't convert it to ES5, so if you want to support a browser that doesn't have ES5 support, why wouldn't you use the babel-loader? Sure, you could `babel` as a separate build step after doing webpack, but that seems more complicated for little-to-no gain. Part of the beauty of webpack is that it can turn a multistep build process into a single step; I'm not sure why you'd deliberately go the other way. 
&gt; While I like the ES6 class pattern, I dislike how all the components inherit from the React.Component object But... you're *still* inheriting from React.Component. That's what Object.create is doing. You're manually doing what the "extends" keyword was doing for you automatically. And, much worse, you're manually doing what the React.Component constructor was doing. The reason that's much worse is because React.Component has every right to change how its internals work, and if it does, then your reproduction of the constructor's logic will be out of sync and probably fail. In other words, where you could have invoked a function, you chose instead to copy-paste the function's logic.
So... Scala.js?
Genius! I think the best is the one for avoiding errors. I could have been writing flawless JavaScript that was 100% error-free all these years, I don't know why I didn't think of that before! Oh, yes I do: because I'm not an asshole.
Mern sounds very cool. Thank you!
Because it runs individually on every input file, massively slowing down the build. You don't need to run it as a separate build step, there's a webpack plugin that runs babel on the output files the same way the uglify plugin does. You wouldn't minify every file before bundling, it's the same thing. 
Yeah, I hear ya
2011 !!!!
Can you link me to the webpack plugin that runs on the output? I'm not finding it.
&gt; Pre-rendering to an offscreen canvas: Is this necessary if it's just a single HTMLImageElement, or is it redundant to cache the image in a canvas to be rendered onto another canvas? Drawing to an offscreen canvas is only worth it if the drawing operation is somewhat expensive. E.g. if it's an SVG or if it takes many draw calls to produce the final result. Drawing the offscreen canvas itself is exactly as cheap (or expensive) as drawing an image of that size. &gt; Would it be more efficient to directly change the canvas' pixel data, [...] No. This stuff is hardware accelerated and you got plenty of fill rate to spare. &gt; I'm more curious about translations and rotations Transformations are fairly cheap. &gt; For context, I'm writing games in Javascript and looking to keep my framerate high before it becomes too much of an issue. Well, just try drawing roughly about as much as your game will need and see if the performance is acceptable. WebGL is also an option. Pixi and Phaser (which uses Pixi) make this fairly easy. They automatically use WebGL if it's available.
Thanks for the response! Sounds like I'm on the right track, then. I'll be looking into implementing Pixi.js soon, it seems well written and easy to implement.
It's babel-webpack-plugin. There may be others, but that's the one I wrote (that's why I have such a bee in my bonnet about it)
In my defense, I wrote this article in 2011 :)
Have you raised an issue with webpack, to get them to change the documentation? Most people are using the `babel-loader` because that's what the [webpack documentation](https://webpack.js.org/guides/migrating/#mixing-es2015-with-amd-and-commonjs) suggests. Either you're right and they should change the docs, or there's some caveat that you're not seeing (that I'm not seeing, either)
You can run https within your local server with a free LetsEncrypt certificate. If you're only serving static web pages, they even have a web server with Lets Encrypt handling built in.
How does that work? Does having `{id}` as a function parameter automatically convert `userPost` into `userPost.id` ? Never seen that before. 
Yes! I kept trying to figure out who he was replying to!
Open source?
Works in OSX - Chrome 55. Very cool. Can anyone break down the Math behind generating the bristle vectors?
 let output = JSON.stringify(obj, null, 2) Ever tried this before?
Time for part 2!
Component playground link: https://opensource.appbase.io/reactivemaps/playground, and more formidable examples can be viewed here: https://opensource.appbase.io/reactivemaps/examples.
Thanks for the explanation, I've fallen a bit behind with the new JS features. I've seen the splat operator in other languages though. 
It was a lot more hands-on creative back then, with less browsers to worry about. Just IE and Netscape, everyone complained a lot but looking back it was easy-mode compared to the device testing shitstorm we have now. You kinda could do most things we do now, except much slower. We even had proto-ajax using cross-frame scripting, it was awesome and browser security wasn't a thing. Also there was a time when everyone had Flash as functionality breakout. Sound, sockets, printing etc you could call into some hidden SWF.
Here's a simple implementation in vanilla JavaScript: http://codepen.io/anon/pen/xgyKPX?editors=1011 For robust solutions, I recommend TypeScript (for OOP) or FlowType (for FP)
Some of the things that using the class pattern causes is the `constructor` method that, after creating hundreds of components, forces me to pass all parameters to `super` and then create state or bind functions. Ignoring the passthrough of parameters, those can be done in a lifecycle function. I believe React.createClass does essentially the same as the above, polyfilling where Object.create and Object.assign may not be available. Since most of the projects where I use React also have a transpiler and webpack, I see no need for such obsfucation. Therefore, I am in agreement with you about the React.Component having rights to change internals, which it does and continues to do without my need for a passthrough constructor. I am creating clones of the React.Component constructor class and composing on top the changes needed for my functional needs. This I feel is stable until such time as a change in React forces abandonment of React.createClass or React.Component is no longer treated as a constructor (as a first class blank component that renders null by default)
I was going to write some example with curried propEqual, but eh. OP, read here or something like it http://fr.umio.us/why-ramda/ 
I once made a global console.log function on a project that would add "poop" to every console log just to mess with my coworkers. God that was fun.
I read your name as real pubey. 
For my local environment, I ended up making a self-signed certificate...But I also have a free Amazon VPS with a bunch of test domains on it, and let Letsencrypt switch them all over to HTTPS... For some reason I was worried it would break stuff, but it didn't! 
I like how people pretend that jQuery/MooTools had the _wrong idea_ about how to do things like updates and animation even back then, as if the 1MB webpack bundles and dom diffing would have even run on the the mobile or even desktop browsers that were around 8 years ago.
I'm only stating the goals of the WebAssembly project itself. I'm not going to state that performance won't be a side-effect of its development (it probably will be), but as far as I know, performance is not a stated goal. I'm more than happy to rescind my comments if you can point out where this goal is stated.
I'm just thinking it would be a rather small but practical change that builds on arrow functions, instead of dropping them for something else entirely
That's actually brilliant, I never considered that
jQuery? In CURRENT_YEAR? Not on my watch.
As FullKappa said, you can use destructuring to get what you want. That pretty much overshadows my proposal, but, in my proposal you still name the object which allows the function to be used just like any other arrow function. It's also pretty helpful when reading the code
&gt; Pre-rendering to an offscreen canvas If you do complex transformation on an image, do it once in a canvas and copy that. Double buffering is not necessary for simple image draws. &gt; Batching canvas calls Use window.requestAnimationFrame and make sure the necessary work can be done in one frame. For 60 FPS 8ms processing time at most. &gt; Canvas state changes Haven't had issues with that. The actual drawing is slowest so that should be your main concern. The article is quite old, maybe checkout something newer. It also depends what browsers you are targeting.
Hi /u/nikespoko333, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you. Also, please use a post title that appropriately describes your problem and/or question. Thanks!
thanks for this! I'm gonna play around with this sometime soon, I only recently got an Echo
Very nice. I might have to steal this from you :)
Read the block "Efficient and fast" at http://webassembly.org/ . It is right there. 
Just to let you know that there's nothing embarrassing about wanting to know more and asking questions. Keep it up.
this is magnifique does it have types for TS?
I blame it for influencing JavaScript's spec (which is true). Mostly I'm upset ECMA was too worried about sites breaking because they used mootools.
Fair enough, not sure how I didn't see that. Still, I think stating that WebAssembly's purpose is for speed is a narrow view. I'll agree that it's a goal though.
You can setup a local proxy server, e.g. using [Caddy](https://caddyserver.com/). You will need the [config syntax](https://caddyserver.com/docs/caddyfile) and the [proxy directive](https://caddyserver.com/docs/proxy).
We may be talking about the same thing here, but in different terms. In either case, I don't think we're stating anything in opposition. Specifically, WebAssembly is a bytecode format, and the runtime can compile as necessary. The machine code is not pre-compiled and loaded into the browser.
What does Flow do for FP that TS doesn't?
You're doing excellently at using faulty logic.
Wonderful. I can go on being ignorant forever. :)
Funny how the complicated stuff is simple and the simple stuff is complicated.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [What is the difference between the W3C and the WHATWG? (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5swplw/what_is_the_difference_between_the_w3c_and_the/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It's just the frontend. The current frontend is base HTML, CSS, jQuery with Razor. It's about as simple as it gets but the company is growing, which means more clamor for the software development team to do grander things. We plan to shift our backend from ASP.NET 4.6 to ASP.NET Core in 2018 and overhaul our simplistic frontend altogether and actually use either Angular 2 or React. We plan to wait until Q4 of this year to see how the trend of both platforms go. My guess we'll go with Angular 2 but if it doesn't take off as this year goes on then it'll be React. Personally I just think React on the front + ASP.NET Core on the back sitting on top of SQL Server is just weird. I've my fingers crossed it's Angular 2.
https://jsfiddle.net/uhtgvjmy/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [New to JS, question regarding how to use JS to change CSS. (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sx163/new_to_js_question_regarding_how_to_use_js_to/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
While you probably could modify it this way (using something like style['animation-name'] instead, I'd guess off the top of my head) you're better off by adding and removing classes, IMO. You could also (either this way, or with classes) add a transition to the CSS and then just change the background color of the element and have it handle the change without keyframes and such.
Very nice. would love to see it in React Native.
Try reading this documentation - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style In general MDN is a good place to start for your questions
I apologize! I'm going to message you here directly. I deal with a really high volume of e-mail and sometimes forget to leave inquiries marked as unread when I can't get back to them in time. It was not an intentional snub.
Why not Javascript everywhere and node ? Do you think learning C# and .net in general today is a bad idea since you can do Javascript backend now ? its possible to have a great career doing JS with node, react etc ? I mean without touching C# or JAVA etc
There are some defects in your code. `day` and `night` in your assignments are references (as opposed to strings), but you haven't declared such references. Make those strings instead of references. 
I've read that annoying slide show (seriously why can't he just make it a normal freaking page of text with examples) twice now. It's even been updated for ts 2.0 so that's nice. But I don't see anything in there that supports the proposition that flow is fundamentally better for functional programming over typescript. What is it that you think flow is doing that ts isn't that benefits fp?
I'm following your idea of mocking the HTML elements instead of relying on a framework for faking a DOM environment. I think I'm making a lot of progress, but my real Class (i.e, not Foo) involves a method like this: ..... retrieveQuote(){ $.getJSON("long.api.link/json") .done( json =&gt; { if (this.isDuplicate(json)) this.retrieveQuote(); else this.parse(json) }) .fail( () =&gt; { this.parse(this.errorObject) }); } I have this on my tests file: // API Stub const randomQuotes = require('./randomQuotes.js'); // Mock the $.getJSON function global.$ = { getJSON: (url, cb) =&gt; { let randomIndex = Math.floor(Math.random() * randomQuotes.length); cb(randomQuotes[randomIndex]); } } Mind showing me how to update my mock `$.getJSON` function to have those `.done` and `.fail` methods? Thanks a lot! :D
I chose to mock the HTML elements myself instead of relying on a framework to give a fake DOM / Browser environment. Is there a disadvantage on my approach?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Tired of learning, what are some beginner JS projects i can do, to get my skill level up. (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sxs05/tired_of_learning_what_are_some_beginner_js/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Interesting approach. The uni-directional syncing and RPC is a good solution, balancing potential security and ease of use. I also like that you've put together a nice web site and docs for your project. Hope to see some demos / examples, though. Great work!
Depends on what your other hobbies are, or what kinds of software you'd personally find useful 
Change `.style.animation-name` to `.style.animationName`, and do the same for `.style.animation-duration`. Camel case is used in JS, kebab case is used in CSS.
Some of the most in depth learning sessions, for me, was to look at a small, simple jQuery plugin and try to roughly duplicate it in vanilla JS. You learn a lot in the process, because you're constantly looking online for help, while still having the jQuery as a kind of road map. I dunno. Worked for me. ðŸ‘
Ah, so buggy... `ReferenceError: preventBack is not defined` Also the script as provided doesn't really do anything but throw a reference error saying Annoying is undefined. One needs to declare Annoying itself as an object or make the function return and pass in an empty object. Anyway, cool script. I would love to see a button entitled 'enable on this page' to see how really annoying it is.
Try making these without using a framework: * A rich text editor, using html tags to apply formatting to highlighted text * An app that adds editable meme captions to user-provided images, and lets them drag the captions around (make sure it works on mobile!) * A game of Snake running in a &lt;canvas&gt; that uses WASD to control and has its own music and scoring system
keyframes are an unnecessary hassle. just set a 4s transition. &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; #ex { height: 100px; background-color: #004; transition: background-color 4s; } #ex.day { background-color: #cfc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="ex"&gt;&lt;/div&gt; &lt;input type="button" onclick="document.getElementById('ex').classList.toggle('day')"/&gt; &lt;/body&gt; &lt;/html&gt; 
among your mistakes: 1) you're trying to pass functions as event handlers, but you're actually passing strings with the names of functions inside them 2) javascript uses `camelCase` for css, because the hyphens are misunderstood as subtraction 3) that's not how `animation name` works 4) css animations in general are gross, whereas css transitions are straightforward (and work reliably in older browsers.) avoid css animations wherever reasonable 5) that's not how you name keyframes 6) you toggle by adding one and taking the modulus? 7) colon doesn't do that in javascript 8) the names of your animations should be strings, not bare literals 9) you didn't declare the language of your `script` or `style` blocks
Btw here is the first example https://github.com/DistributedObjectProtocol/dop/tree/master/examples/drag
I agree with you, most of my rant was mainly focused on Rails which IMO defines the whole language, and I think is quite flawed. I was about to babble on about Composition and Closures which I think is a big part of Golang(which I like a lot) and other more functional languages, and how I they share the similar design patterns. I mean it just makes writing multithreaded/concurrent programs so much simpler, and you can take advantage of things like elastic AWS services. 
The new features added by ES2015 are improvements but I don't agree with your premise that the language was crappy before this version. The language is a tool and good craftsmanship is about knowing how to use the tools available to you.
It is written in ES6 + babel plugin for object-rest-spread. We are planning to migrate to TS someday
don't scrolljack.
yeah I got it, but Google is shutting projects too. For example google reader was shut down. So what ensure you that this project is not going to be abandoned one day? That day, your client will have an old app running for several years with a really tiny budget only to support critical bugs (because thats what a lot of company usually do). And your are going to come and say, ok your database is going to be shut down, we need 1 week of work to migrate. That's like the budget they allowed for the whole year ! You have to justify that. So I understand why a lot of companies still have their own "production team" for handling that kind of services. Apart from that, you saw what happened to gitlab team recently? Go justify to your client that their whole production site is down because someone from another company deleted their database and you need like an afternoon or a day to restore the service. So yeah that's quicker for starting, but you have to pay back later and customers hate to pay back later.
Dude you asking this in /r/javascript...
I haven't. But keep in mind that this example is a little bit stupid. Your question is more about low latency, which is necessary on games. I assume that having a good server and clients with low latency the effect is still smooth. But games is a difficult world. On that example, I wanted to show how easy is to make a real-time app. To optimize it I would add a 10-50ms delay for the movement of the circle before I send to the server. But it depends if you want a low latency or not.
What jQuery plugins do you recommend? Wanna give it a try
You still sort of *need* a good linter to ensure nobody on your team uses any of Javascript's legacy functionality, because it's possible to write some hideous code in it and even as team lead you can't always check every line that gets merged. Fortunately, linting is so exceptionally good on JS that this is hardly a problem. I wish we had something like [ESLint](http://eslint.org/) for all languages.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Webpack use cases for backend development (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sz54w/webpack_use_cases_for_backend_development_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rcbredditbot] [Whats the most "out of the box" front-ebd framework\/library is out there? (from \/r\/javascript)](https://np.reddit.com/r/RCBRedditBot/comments/5sz54y/whats_the_most_out_of_the_box_frontebd/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Not really. Is more for state management. Dop makes very easy build real-time apps such a chats, turn based games, something like Trello or collaborative apps. You can build games of course, but if you are making a shooter game that needs a very low latency you would like to send the minimum data possible. The protocol is very lightly, but imagine you want to send the position of one element. With dop you would send something like this: `[&lt;id_request&gt;, 5, &lt;object_id&gt;, &lt;version&gt;, {x:25, y:50, z:75}]` e.g. `[1,5,1,1,{x:25,y:50,z:75}]` but instead of send that you would send the raw position to save bytes `{x:25, y:50, z:75}`. But again, if you need a very low latency for your game dop wouldn't work. And I think WebSockets either if you want to build a Overwatch experience latency.
Replace the word "JS" with "PHP" and remove "ES" then you'll have thousands of answers to this question.
Numerous things, some of them very integral to the language. In part, these are things defined in older standards, and also things implemented by browser vendors that never made it to standard. Like `for...in` or `for each...in`, pre-proxy observers like `Object`/`Array.observe()` in Mozilla and Chrome, or mundane features like `RegExp.compile()` and static group properties `RegExp.$1` etc. Some more obvious ones, like the `arguments` array. There are tons of these, and it's not always easy to keep track of them, which is why ESLint is great because it can help keep a codebase free from legacy features even if unexperienced developers touch it.
I thought JS was a terrible language back when I first started programming and used PHP mainly and JS where I couldn't use PHP. After actually learning JS I changed my opinion about it, I think it's a beautiful flexible language that has a lot of garbage from the past in it. Most issues come from it being rushed in the initial release and being stuck with mistakes made in the past thanks to backwards compatibility. As for coworkers writing crappy js code or bullshit jquery where none is necessary. Make sure you're using strict mode and do code reviews for those who aren't comfortable writing JS
&gt; Fortunately, linting is so exceptionally good on JS that this is hardly a problem I'm not sure I follow. Are there any languages where the linting is worse? Have you seen the analysis compilers can do on static languages? They make the JS linting look laughably insufficient and lacking.
JS is in many ways the new LISP\*, and suffers all the same problems as a consequence. And it's also a "trendy" language where key players are constantly trying to fit all the latest kitchen sinks they can find, with the obvious identity conflicts that results in. (Hello you fellow prototypical object-oriented functional concurrent assembly-capable language!) It's clearly evolving for the better, but compared to more opinionated languages which actually has a working and functional standard-library with established patterns and conventions, it's still messy as heck. \* I said many. Not all. Please keep your pitchforks back!
I think you have it right. A closure consists of: * A function * A context for the unbound variables of that function Since JavaScript lexically finds the context for unbound variables for you, every function (in JavaScript) is in fact a closure. The variables don't have to be passed through an IIFE, and they don't have to be static. ## Example 1 let z = 1; // f is a closure, since it is "closed" over @z function f(x, y) { return x + y + z; } console.log(f(1, 1)) // 3 z = 10; console.log(f(1, 1)) // 12 ## Example 2 let user = { age: 20 }; // g is a closure since it is "closed" over @user function g(x, y) { return x + y + user.age; } console.log(g(1, 1)); // 22 user = { age: 10 }; console.log(g(1, 1)); // 12 user.age = 100; console.log(g(2,2)); // 104 ## Example 3 let utils = (function() { let user = { age: 20 }; // The methods are closures since they are "closed" over @user return { update: function(age) { user.age = age; }, setUser: function(newUser) { user = newUser; }, add: function(x, y) { return x + y + user.age; }, addToZ: function(x, y) { return x + y + z; // references the @z from Example 1 } }; })(); console.log(utils.add(10, 20)); // 50 utils.update(100); console.log(utils.add(10, 20)); // 130 utils.setUser({ age: 0 }); console.log(utils.add(10, 20)); // 30 console.log(utils.addToZ(10, 20)); // 40
you're correct, but sometimes the tools given to you are a spongy hammer and a picture of a dog. your bookshelf is gonna be shit.
Do a simple image carousel, for example. It should be enough for a start.
I dont think so. * loaders - why? (node have native imports and fs package) * handling css/fonts/ - why? (aside from serving them as-is to browser) * bundling - thats browsers thing 
I grew up with c/c++/c#, a bit of java. Never cared so much, as long as it leads to productivity. I write in js/node pretty much full time now and i see myself doing things that i wouldn't know where to start with the others. Our node backend took a single day in its first stage with maybe 10x the functionality the old .net app had, for which i needed weeks. A big chunk of that had to do with community support and availability of tools and components. Currently we're transferring a huge C#/XAML monster into the web front-end, and the gains are staggering all the same. It just clicked that Javascript is not so bad after all. It may not be the "best language" whatever that means, but its community is at the forefront for sure. While some do say it's crappy still, i think they're not used to a language that flexible and with that big of a community. Also something i observed personally in the field i'm working in: devs coming from java and c# usually do not give in to the language, insisting on doing things the way they were used to, using their old tools (visual studio, nuget, no npm, no node, no webpack, no babel), treating javascript like it's 2005 with script-tag includes and so on. Then, yes, they have a point.
I agree, in fact I feel the exact opposite to OP's premise. ES3/5 had great syntax. Of course it also had some very sore points and lots of gotchas but as you say, much of this was about knowing how to use what is available to you. ES6/7 introduced some great features, and some of them mesh well with existing syntax, but a lot don't - especially when backward compatibility needs to be maintained. Ruby (and in some senses even Python), on the other hand, has fantastic syntax and I've always found it very intuitive. Strange how much opinions can differ.
You sure are brave asking /r/javascript if they like Javascript... Try it on /r/programming and get ready for everyone to spout 20 years of "javascript is bad" memes at you.
See the 'export default **class**' at the start of that declaration? This *is* a class. 
Scrolljacking is bad, m'kay?
[removed]
propTypes is class static field, it's a feature that's still ECMAScript proposal, currently on stage 2, see: https://github.com/tc39/proposal-class-public-fields
THIS IS A SCAM, DO NOT GIVE THESE IDIOTS MONEY
[removed]
Any general forum for programming is going to be full of negativity and shit talking trolls. Considering Javascript is one of the top 3 most desirable languages right now across the Web Development spectrum, what individual developers opinions are and what the actual corporate development environment wants are 2 different things. Unfortunately the Internet has allowed the loudest to be the most heard, for better or worse. Javascript is getting stronger by the day and the fact is is that every single Web app you make is going to need to use Javascript at some point, whether you like it or not, so I just embrace it. Node has been a joy to work with and being able to code in the same language everywhere, deploy apps in a fraction of the time compared to other languages, and gives you the flexibility to be as strict or not as you want are all huge reasons why I think Javascript is awesome, despite its few pitfalls, which are all honestly being worked on. Don't let the negativity get to you. Just look on any job forum and realize it's one of the most desired languages out there and companies are dying for more developers in it.
Thanks for the help!
I know people like to pick up on PHP, but the language has had a code formatting standard for years now. JavaScript could seriously use something like the PSRs or PEP 8. Similarly, it is much easier to breakup up code modularly for procedural coding in PHP than it is JavaScript.
X-Post referenced from [/r/webdev](http://np.reddit.com/r/webdev) by /u/onatcer [Make AJAX-Requests Great Again: Perform requests with the Fetch API and Async/Await (ES2017)](http://np.reddit.com/r/webdev/comments/5t03lg/make_ajaxrequests_great_again_perform_requests/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Nothing changed in this matter.
For me, the answer is still yes. The package system isn't still a bit frustrating to use compared to PIP and Composer, maybe yarn will be the last one. And I miss features from PHP like traits and static typing (JetBrains compensates well, but still...) Modules are fine, but I'd still like an `include` type syntax. I also think the language needs a formal style guide, like PEP 8 or PSR-2. I don't think it is a strong enough of a language not to be replace the moment a real alternative comes along. Many of us use typescript because JS isn't what we need in the domain JS is supposed to be strongest yet. It is getting there though.
JS has tons of community code style guidelines. Imo there's no need to restrict any functionality in the language, anything that is bad usually gets deprecated.
Yes, of course it's helpful for universal (isomorphic) applications. But I don't think that really qualifies as "backend".
Have you checked out Elixir? I've just started looking into it, and so far it feels like the best of JS / Ruby combined together. Functional programming + clean language design, without the horrible performance of Ruby
&gt; deploy apps in a fraction of the time compared to other languages Do you mean time to code up an idea, or time to get your new code running on servers? I don't think Node would claim to be either... Also want to point out, criticizing a language does not immediately make someone a "shit talking troll". JS has plenty of flaws (and strengths), and it shouldn't be a religious debate.
I use static languages during my commute to work and always sigh when I make the switch back to JS. I have no confidence I am calling my functions with the right params until I write tests for everything.
Why don't you use typescript or flow?
just for reference, this also works for local `state` and saves you from binding callbacks manually because classproperties + arrow functions autobind `this`, so you can use them in regular events. state = { text: "" } onChange = event =&gt; this.setState({ text: event.target.text }); render () { return &lt;input onChange={this.onChange} /&gt;
Ruby lends itself to _many_ different approaches, some more functional feeling than others. Ruby makes a terrible LISP but [you can fake it](http://www.randomhacks.net/2005/12/03/why-ruby-is-an-acceptable-lisp/). If you want something more usable that still feels like idiomatic Ruby, it's easy to avoid instance variables that aren't defined in the constructor, avoid disgusting state changes by just _choosing to avoid them and instead write pure functions_. It's easy to isolate side-effects, limit the use of magic occurring in callbacks. The issues you're describing mostly just sound like a bad Rails app, which, to let you in on a secret, is just as bad as a terrible React app that uses all the new ES bells and whistles. Languages and libraries are tools. All tools have their strengths and weaknesses. You need to evaluate a tool's merits for a given job, not try to say "a hammer is just BETTER than a screwdriver." Ruby, as a tool, is hard to beat in its flexibility.
Yea, that would be special case probably, OP wanted "just API" (REST? GraphQL,....)
Maybe it is just me and my browser, but I do not hear any sound. I see the soundwave animation, but no sound. Any idea on how to fix it?
Nice response! I think we're just looking for different things from out languages. It's seems you're looking for a language that restricts (I don't mean this in a negative sense) the developer to prevent them from doing Bad Things^TM. And I get that, it, in the end keeps things consistent and I can't deny it improves quality and experience. However, I still don't think the lack of built-in restrictions is a problem...I think it provides flexibility that I've taken advantage of in the past. Now as for Elm, I might be missing your point, but using TypeScript + Webpack has had similar effects--I can't remember my last runtime error. I guess I just don't think because we each have preferences that differ that it makes either one bad, just different. However, I'll never deny that JS doesn't have bad parts, because it really does.
This is awesome. Never seen tone.js before :'D 
Hi /u/malyw, please link to the full article. Thanks.
Php is in many ways better than JavaScript. \#1 reason php is willing to introduce breaking changes.
are you implying that ajax wasn't great before ? does this mean we're building a wall between javascript and css ?
That's why I liked it when we could use VBScript in a webpage.
&gt; Javascript *had* an relatively small API 
Most of what people are using lodash for (forEach, map, reduce, filter) are built-in or becoming built-in (like find), but to something like Promises, I hadn't investigated the performance versus someething like $q, so I'll take your word that it's less performant. I also haven't had much experience with partial application over huge datasets, so I can't argue your point there. As for the better tools, yes, tooling JavaScript is not possible out of the box because of its flexibility. But, in my experience with TypeScript I get just that sort of experience. I know it's a trope at this point, but JavaScript has become like the assembly of the browser to which all other languages compile. These languages (Elm, TS, Babel) we've created on top of them are the improvement to the experience that C, Java, etc. were to assembly. EDIT: btw, thanks for the discussion! always fun to debate, right?
&gt; functional design always seems like a warren of unpredictable function dependencies. I wouldn't say so. You can write functional JS just by writing pure functions (using map, filter, reduce), maybe some extras from Lodash or simmilar library.
In the example above, you misspelled `output` as `ouput`, in the selector, which would cause the error you describe.
Great! Looking at the list of breaking changes in the past releases, I figure it will only take a couple hundred more major releases until it has less garbage than JS. Rejoice! /s
for...in is alright if you need to have a fast iteration over Object's keys. If you're iterating over arrays with it, you just want to see the world burn.
Elm might be that. Super opinionated syntax with a narrow focus. You have to basically go out of your way to force a runtime exception.
From someone who has developed large applications using both OO JS and FP JS, I can easily say that FP JS is not only much more predictable, it is also obscenely easy to test. As far as "unpredictable dependencies", I use a fractal directory structure that always contains the same files for my constants, action creators, action handlers, and reducer. Each file should have the same general exports in it.
&gt; It's more we have an extensive toolbox that has a balanced hammer, super sharp saw, and a powerful drill with every bit you need. Except the hammer's head is smaller than it should be, the saw is a jigsaw and that powerful drill, has half the RPM it needs to be useful. huehuehue
Because most companies don't like change, plain and simple. Even though you can introduce flow gradually (and to some extent, Typescript as well), it's just more change than most places are looking for. I've tried at my current job to explain (and even demonstrate) the value of static type checking for a project that's likely going to take a few years to build, but nope - Babel and ES6/7. Wheee
Thats what a closure is? A function grabbing an object that was declared outside of the function scope? Jeez, I see closure mentioned all the time and just assume it some weird new JS thing that I dont need. 
Edge has sound btw
Time to code up an idea and get it running on a server. Perhaps it's the wealth of resources and the community, but everyday there's more and more tools to help streamline the process of development AND pushing to a live server. Just compared to my years working in PHP and PHP Frameworks, I just like being able to code everything in one language and promotion to production just feels markedly faster, to me. Also, I meant to make a point between constructive criticism and blatant shit talking. Nothing wrong with people pointing out flaws, but I'm sure you all remember that article a few months ago from an open source developer who got fed up with all the thankless negative affirmation from the community and just quit. We all know how toxic the internet can be and have all worked in jobs where you do 999 things right but you'll only hear about the 1 thing you did wrong. Feel like the community should give credit when and where credit is due but more often then not, people just default to anger and frustration.
Thanks, helpful ðŸ™„ in my defense though I was talking about vue/react/angular once they have been put into the context of being an all singing all dancing application (which, you are right, react does not do on its own)
Yeah, it looks like that guy jumped from assembly straight to javascript
the result is the same. the difference is performace. you can check it using console.time and console.timeEnd ;) 
Reposted due to the /u/kenman request : https://www.reddit.com/r/javascript/comments/5t0gs7/native_ecmascript_es6_modules_are_implemented_in/
A templating engine, like Handlebars? 
Reposter due to the /u/kenman request: https://www.reddit.com/r/javascript/comments/5t0gs7/native_ecmascript_es6_modules_are_implemented_in/
https://www.imgix.com/solutions
[removed]
Some people want you to argue both sides while you defend your position. Less work for them, you see. It's like some kind of bullshit guessing game. All they have to do to shoot down your points is say "no that's not why it sucks, keep digging."
You should be able to paste this anywhere: &lt;script&gt; var bgs = [ 'http://fillmurray.com/800/600', 'http://fillmurray.com/900/600', 'http://fillmurray.com/800/700', 'http://fillmurray.com/1000/600', 'http://fillmurray.com/1200/500', ]; window.onload = function () { var n = Math.floor(Math.random()*bgs.length); document.body.style.backgroundImage = 'url(' + bgs[n] + ')'; } &lt;/script&gt;
I noticed the crackle as well, it is unfortunate. It would be neat if there was a way to render to an mp3 on the fly and stick the entire thing in an &lt;audio&gt; element or link for download.
Hi /u/ForgeableSum, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
yeah, oo js is unmanageable. we use typescript and enjoy it quite a lot. do you have a github repo? or something else that demonstrates the patterns you're talking about? i honestly think i just haven't seen real functional design.
Whenever I want to learn something new, I identify a problem I want to solve, that has no solution that satisfies me. This works for just about any skill you want to acquire. For example, I wanted an mp3 player that reacts to conditions inside a video game. So I learned C++ as this came off as the most viable, cross platform solution there is (also because of Qt which is a great framework). Then I got a paid spotify subscription, so I learned how to write chrome extensions so that I could trigger spotify playlists instead of playing MP3s. I wanted my living room lights to dim when I started playing a movie. There were no wifi-enabled light bulbs at the time, so I bought an arduino and learned a bunch of stuff regarding electrical engineering. Not enough to be a professional, but enough that I wouldn't burn my home down. Now I want to build a particular kind of lute so I will have to learn a thing or two about woodworking. Basically, learning requires motivation, and I can't think of anything more motivating that creating something you actually want to use.
handlebars or nunjucks
This seems like overkill. Why not just use string.indexOf? Or, failing that, a very simple regex?
I do sort of "curried functional" programming in Ruby using simple classes. The instance variables are the arguments to the function, and some method gets the result. Very testable, very easy to use, very clear. No mutable state unless needed to avoid repeating expensive operations. Callbacks have their place, but this is what you need for expensive operations involving orchestrating multiple tables. Alas, many rails developers do it all in callbacks and make a mess. A big Rails app often needs a serious domain logic layer on top of ActiveRecord to keep development sane rather than what OP got. OP just sounds like he got a nightmare app, and I've been there too. However IMO JS is even better than Ruby at propagating stupid mistakes way down the call stack to the detriment of the customer experience, so I will take a statically typed language over either for a huge code base.
I feel like I've heard of this before...
People think it's scrolljacking because 1. they didn't actually look into it, and 2. the title is missing a word maybe: &gt; Scrolldir is a 0 dependency JS library for *detecting* vertical scroll direction without jitter 
Really useful video! But christ, drink a glass of water! *shudder*
In the first iteration of the loop, k == 1 and it adds that to i, which is 1. On the second iteration, k == 2, and i == 2, etc. For each iteration, it adds the values, then increments k for the next iteration. If, k&lt;10 is false, then it stops the loop and does not perform the addition. If you want i to be the sum of all numbers from 1-9, you should initialize it to 0.
 i = 1 k = 1 1st loop: i + k = 2 K++ means increment value of k by 1 each loop so k now equals 2 2nd: i += k = 4 increment k = 3 3rd: i += k = 7 increment k = 4 4th: i += k = 11 increment k = 5 5th: i += k = 16 increment k = 6 6th: i += k = 22 increment k = 7 7th: i += k = 29 increment k = 8 8th: i += k = 37 increment k = 9 9th: i += k = 46 end loop because k&lt;10 i ends up being 46 Here's a [jsfiddle](https://jsfiddle.net/ryu4cjrb/) with an alert during and at the end of the loop.
Does it compete with Gulp?
Hey this is the bit that I am finding really confusing, if I removed `let b = a` wouldn't `showMeTheClosure` break because of it's internal reference to `b` which references `a`, are you saying because `b` is just a reference to `a` that is *not* closure?
Thanks! I am doing anything with zeit's now which is just AWESOME. 15$ for 3000 deployments a month (which is A LOT). You are free to use any free *.now.sh subdomain or alias/link to your domain. https comes for free! You can literally trash 80% of your server rents and replace them with now. One thing to note: now deployments are stateless / immutable -&gt; no DBs. You need external DB providers. PS: I don't work for them ;)
It's actually not that hard to do that, see [example](https://higuma.github.io/web-audio-recorder-js/). Thing is, I'd have to set up an inline worker for it or move it away from a fiddle, which is kind of a pain... Maybe version 100 ;)
Okay, I'm completely with you now. This is actually exactly the direction I thought it was supposed to go at first, but I didn't take it all the way to the end so when it output 46 I thought it was outputting the 1st loop as 4 and the second as 6. Thanks so much for the help!
No problem. Never hurts to throw an alert into your code and see what's going on with your variables that way.
Fair point! Thanks for the note! This will be considered. ðŸ‘
Haha, don't worry about it my friend. We all experienced this sort of thing many times before it became intuitive. Don't hesitate to ask questions because you might sound stupid. Asking questions is how you get better.
You're welcome!
Yeah there _tons_ PHP and Python essentially have one. Things like ESLint and the like become unnecessary when your editor can enforce those rules by default, and you know that all code will look the same. It doesn't have to be enforced by the language itself, but I'd argue that it is an important feature, and is something the JS community lacks.
It's not even fair to compare JS to another language. Other languages have actual libraries and SDKs, not four different modern out of sync browser implementation + the "vanilla" JS version. And to even use the newer JS version in a decent size codebase, you need to pick a module system, a task runner/bundler, a linter, etc. etc. It's a bunch of competing standards, a mess of dependencies, just a mess in general compared to most other language. It's the nature of the beast given that there are different browser vendors and different JS engines, each of which with their own scruples and agendas. The conflicting HTML/CSS browser problems are largely gone, replaced with this wreck of an ecosystem that is JavaScript. There's hyperbole in here, but I think too many people start off with JS and think all this shit is OK or even normal.
It will happen again and again. 
Got my upvote from the name alone.
Every section cites two large surveys of several online developer communities, such as HackerNews, Reddit, Twitter, and other sources.
thanks!
When I first saw the web audio api i looked up some basic tutorials and was super excited about it, and then when tone.js was announced on here a while ago I was even more excited. Issue is i don't have an audio/music background, though I love music. Where could I go to learn the fundamentals (without having to learn a music software) such as ASDR, envelopes etc
So, does this mean things like browserify and webpack will just die off?
Since there are two general senses people use the word "prototype" it can get really confusing. Here are a few general rules: - EVERY JavaScript object has an internal prototype property (either `__proto__` or sometimes denoted `[[prototype]]` ) - when invoked with `new` the internal prototype ALWAYS points to a `.prototype` property (the other kind of prototype, which is itself an object you can attach methods to as properties). (if it is just a simple object and not a constructor function then it won't have a `.prototype` property on it. You can still have other objects use that simple object as their prototype though, with `Object.create()` or directly setting the `[[prototype]]` / `__proto__`.) - the `.prototype` property (not the internal one that all objects have) is generally on a constructor function, which is capitalized by convention (there is also a `.constructor` property mixed up in all this but let's leave that out for now. The link i will add at the end will discuss this too). That's where all the useful shared methods are stored. So if you have a `MyObjectMaker` function that you use to make other objects then you add methods onto the `.prototype` object (`MyObjectMaker.prototype.coolMethodForAllInstancesToShare`). The reason all instances share those methods is that their internal `[[prototype]]` points to the .prototype property of the function that made them (since new and object.create set the internal `[[prototype]]` to whatever function you call it with. Definitely check [this](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#constructor) out. It is hands down the best series of posts explaining it. I liked to the most relevant part but the whole series is well worth reading. 
I'm not aware of any third party deps, but that doesn't mean they don't exist. Regardless, I think flow shouldn't be that hard to integrate gradually. I'm sure you're familiar with the fact that flow only checks files with `// @flow` at the top. So my advice would be that you do that only file by file, and not all at once. Moreover, the import errors only occur when either your node_modules doesn't contain your deps, you're deliberately ignoring node_modules in your config, or you actually don't have something you're importing. I don't know why else they'd occur. Regarding any other errors / things that are hard to do types for, you can just cast mark them as `any` types, and then all errors related to them will be ignored. With flow you *don't* have to assign types to everything. It'd be hard to offer any more advice without knowing your specific situation more, but I hope that helps if only marginally.
Browserify does more than bundling?
I think I've made it clear where I got that idea. It's the first statement on their website, and is a clear goal throughout much of the literature. As for the talks and articles, I agree - they are mostly focused on performance. However, third party focuses don't indicate anything about what they're focusing on. I chalk it up to performance being more interesting to talk about. If we go all the way back to my first comment, I simply state that a goal of WebAssembly is to have a standard bytecode runtime in browsers, and to keep it in mind. This is not false.
OMG I meant to use `b` in the return i.e. `return b + c` now I see what you are saying! Yeah I just finished reading the YDKJS one (I brought the paper backs they were so good) and then the other dev made me second guess myself so I was like that's it to reddit I go they will help clear it up. On a side note I see that using `b` in the return the value doesn't actually change even when I change the global value of `a` meaning that `b` is essentially static and not a reference to `a`? Sorry I just can taste how close I am to understanding this :)
 body { background-size: cover; background-position: center center; }
Both of those are pretty great experiences. Or Purescript. Transpilation is going to change everything really quickly!
&gt; JS was widely regarded as a pretty shit language(which it kinda was) I disagree. I am off the premise that if you need classes, Babel, and webpack to enjoy this language you probably never really figured it out. You are an imposter who needs to go back to Java, C#, or whatever.
Thanks for your notes @ishouldrlybeworking ! I updated the lead descriptive language ðŸ”§
In JS, primitives are passed by value, so when you say `let b = a;`, that's functionally the same as saying `let b = 1;` ðŸ‘
Yeah, I loved dynamic web frameworks at first because I could do so much with so little code so quickly, but I now have had the experience of paying for it later in maintenance several times. There is no reason they can't stay maintainable, but organic growth and changing requirements always causes some hairballs to be created, and those would really benefit from static typing to reduce mistakes. I don't see that JS is immune to this over any other language, and instead is *more* dynamic than most other dynamic languages.
Yep duh :) okay I think I have them! :) thank you for the detailed responses!
No prob ðŸ™Œ
Great!
But I actually think that is not the case, I don't know where gitlab gets those numbers.
You're my best friend haha There's one more thing :3 The images are now centered, but they tile vertically
That's just because you don't have any content expanding the height of the page. It won't do that once you have content, but you could set a height to solve the problem too: html { height:100%; }
No problem. Thanks for the gild!
ok. than maybe this does not suite your needs very well.
ðŸ‘ any time 
All mocks lead to tautological tests. redux-saga just makes mocking easy. Do you have any other option, except for running integration tests? I used to hate the tight coupling between test and implementation in redux-saga as well, but it has grown on me. It works as dual entry bookkeeping.
No idea. I found it a couple weeks ago and posted [this](https://www.reddit.com/r/learnjavascript/comments/5pz4uo/incredible_resource_for_more_advanced_javascript/) because it is really awesome haha. 
&gt; Instances have their own properties which reference the object from which they inherit called `__proto__`. Don't they actually inherit from the `.prototype` object of the constructor function which is *referred to* by `__proto__`? I could be confused though. I thought `__proto__` / `[[prototype]]` was just an internal reference to the `.prototype` object/property the chain should follow. (this is really confusing stuff sometimes haha..)
Check this [video](https://www.youtube.com/watch?v=DqGwxR_0d1M) . It helped me a lot :D 
My company does. I curse it daily and it sucks enough to consider looking for a new job unless I can convince them to move to something modern and better written. A framework that wraps a list of form inputs each in it's own nested tables(!) shouldn't exist, imo.
Nothing makes me not want to try a product more than this kind of marketing.
It's [kripken/box2d.js](https://github.com/kripken/box2d.js) v. 2.3.1, ported straight from C++ to Asm.js using Emscripten. It's nice performance-wise, but there are some issues with memory leaks.
As opposed to something that is at least twice slower (http://vanilla-js.com/)
Is my voice too rought?
I know this talk, everything he says still exists in javascript. The examples he gives aren't anything you should ever run into anyway.
was a bug with one of our styles, will be updated shortly.
I thought the whole reason this took so long is because the standard for loading modules over a network was unspecified. Is that resolved now?
It was nice at the time, but it was too OO for my taste and I am happy JQuery won
Impressive
Crackly for me even in the foreground, my PC isn't *that* old, is it? (Core 2 Quad)
Then comes ES7 and everything starts all over again.
And the fact that it does these things is really, really bad. If you write a "JS module" that imports an image, then you're written something that can't be loaded by JavaScript VMs. You've written a Webpack module, but not a JS module. I wish tools didn't support this type of thing. They make themselves non-optional and a slightly separate platform.
A lot of small modules has a higher IO overhead and worse compression (each file needs it's own compression dictionary, rather than sharing one). Still, bundling should be completely optional soon and not needed for development.
I agree with pretty much everything you wrote but I'll just want to pick on one statement. &gt; a task runner/bundler, a linter I don't actually mind any of this because I'm just so used to build systems being a necessity for any professional project. Even back in school they taught us about the build-chain to get C++ going under Windows or Linux. Comparatively, Python/Ruby (and maybe Go?) are pretty easy to get started with for simple projects, but you still end up needing an asset pipeline, and build orchestration anytime you're doing something complex. So for most people working at a job, the tool complexity is there no matter what you choose. 
It competes with WebPack.
It'd be still great for development. If Firefox can load JS faster than Webpack can rebundle, it's a win.
Vue is pretty damn nice without any build steps. Just add the vue.js and you can get straight to writing with components. I especially recommend using template literals for the HTML templates of the components. If you want to build an SPA, then I do guess you'll need to add in Vuex and Vue-router. Nevertheless you can get a lot done with Vue itself.
Well you know the quote. This is the worst programming language of all time, except for all the other languages.
Wake me up when they fix '1000' == '1e3'.
ES7 (2016) and ES8 (2017) are already being implemented or are fully implemented in all browsers. Their spec is really small.
Which parts of PHP do you find to be inconsistently designed? When I hear this argument it usually pertains to the argument order differences between the very old string and array functions.
&gt; Languages and libraries are tools. All tools have their strengths and weaknesses. You need to evaluate a tool's merits for a given job, not try to say "a hammer is just BETTER than a screwdriver." Ruby, as a tool, is hard to beat in its flexibility. Some tools are just shittier than others and since programming languages are usually used with a specific goal then there are languages that are just plain worse.
What have you tried?
If you specify a folder, as opposed to a file, it will look for a file called `index.js` // index.js import MyComponent from './my-component-a.jsx' export default MyComponent Then you can import it exactly as in your preferred example. I *think* it's possible to write the above example in one line export default from './my-component-a.jsx' While we're here, I've found that using a `node_modules` folder to store *your own components* somewhere above your root project, you can get rid of those pesky relative dot dots. node_modules/ &lt;--- for npm stuff src/ node_modules/ &lt;-- *your modules* /components /my-component index.js my-component.js Then whenever you want want to use `my-component` you can simply write import MyComponent from 'components/my-component' no matter which file you're in, which is great.
Your voice is smooth, I think he may be referring to what sounds like lip smacking at some points, like you have cotton mouth. It's not super obvious, and honestly, if he hadn't said anything about it I probably wouldn't have noticed... but if/when you do notice, it's pretty distracting.
It's in no way the new Lisp, Common Lisp has features that no other dynamic language even comes close to. JavaScript doesn't have any advantages over Python or Ruby other than it being the default language in the browser.
Couldn't find a link, but the module loading spec was finalized later last year or earlier this year. AFAIK, it even is already implemented in the later builds of V8, the rest of the work is on the Chromium side now. For now, Safari, Edge* and now Firefox support it. Chromium will probably support it in canary builds soon.
ah very neat. i've used lodash quite a bit, but value last and automatic currying changes the game quite a bit. thanks for the link! 
is there anything polyfill-esqe for browsers?
Eh /r/javascript isn't really composed of all JS fans. I feel like JS is a language forced on people and people get pissed. 
&gt; New features can keep coming out. As we can see from ES2017, there probably won't be another huge explosion of features like in ES2016 Do you mean ES2015? ES2016 was just the ** operator and Array.prototype.includes().
What version are you using? I haven't dealt with extjs since v4
Well you could use a javascript vm compiled to javascript (don't ever do this for actual work, the result would be terrible). But transpiling your es6/7 code down to the older es5 standard is best practice for now.
Thanks! 
Furthermore, by doing it with `node_modules` there's no behind the scenes magic to figure out where the module is resolved from. Just look up to the nearest `node_modules` folder and you're done. If you use webpack config, then try to figure out where a module is being resolved from, you *have* to look at / be aware of a webpack config vs just knowing how node does its thing.
While we're here, also worth noting the ability to rename while destructuring. To repeat the above ({ id }) =&gt; id === 1 Doesn't much matter for short stuff like id, but say you had a longer property name like 'thisIsAStupidlyLongNameForAProperty' ({thisIsAStupidlyLongNameForAProperty: x}) =&gt; x === 1 Definitely saves on some clutter and repetition. 
I've been a bit behind on the development of this but have they figured out how to make CommonJS play well with ES module in node?
Well, the main reason would be that it requires you to actually put everything into a `node_modules` folder, _instead_ of having your source code live under a folder like `src`. The OP didn't say, but I would assume that their `components` folder is probably actually located at something like `$PROJECT_ROOT/src/components`. What I really want in that case is to treat `/src` as the resolution root, so that I can declare imports with that as the base.
NaN is definitely pretty crap, but I honestly love the undefined and null separation. I mean to me null is a value/a defined property that just so happens to hold null, were as undefined is straight up whatever you're trying to reference has never been declared. like in Ruby **user = {address: nil}** both **user[:address] and user[:name]** will be nil.But in JS I will know for sure whether the user just has yet to fill in his/her address or if it's even a property on the object at all. 
Webpack and/or browserify are still going to be important for including anything in node_modules. When you say `import _ from "lodash";` there needs to be some repacking, or at the very least organising files, so that the browser will find lodash when it requests it.
Ill actually start using es6 once node and chrome have it.
Still has overhead to fetch potentially hundreds of modules from the HTTP cache. Not using a bundler is fine for smaller cases but you'll need bundling if the application grows.
I'm unfamiliar in the world of packers. Is that similar to using ASP.NET Bundling and using gulp with gulp-concat?
I think the point is more that if you use Webpack and import images and other resources you can't move away from Webpack that easily because other bundlers / task runners wouldn't necessarily know how to deal with the syntax.
Refactoring AngularJS 1.x app to migrate to Angular 2+ may or may not take some work depending on how it was written initially. You need to write angularjs 1.x in a different way than you are (probably) used to. Here is a list of things you should do to have an easy time: -No .controllers. -Only use .directives and .components. -Only use .directives with isolated scope. -With components/directives (parent-child relations) pass data down send events up. -Use services for inter-component/directive communication. -Do not use $scope, at all. -Limit the use of $timeout as much as possible. -Use ng-if instead of ng-show/ng-hide. -Use Typescript I suggest that you read this: https://medium.com/@vascofernandes/the-road-to-angular-2-refactoring-angularjs-1-x-applications-for-smoother-upgrade-69c91364bc4c#.m3qo2m66v 
Thanks a lot for sharing the topic, it really helped me a lot.
You should look into Math.random 
Yeah. The whole ES6 - ES2015 thing still messes with my head :D
Really good article and well explained!
Lodash also has FP 'mode' for iteratee first - data last methods. You can find it here: https://github.com/lodash/lodash/wiki/FP-Guide I'd say pick what you like more :)
Furthermore, it's unlikely you want the entire lodash lib. Why would you? If you need `memorize` why would you bundle the entire lib? Today we set up lodash so that we can import single functions like `import memoize from 'lodash/memoize'`. This takes special code separation and feels kind of forced. What we'd like is for `import {memoize} from lodash` to only import the single memoize function, plus any dependencies. 
[removed]
[http://www.w3schools.com/code/tryit.asp?filename=FCLHNBUAL5B6](http://www.w3schools.com/code/tryit.asp?filename=FCLHNBUAL5B6)
learned a lot about map and reduce in a really short article, thx
Which one is faster? Do you know what that type of micro-optimisation makes to your codebase?
How I have done it: var obj; function decode_json() { var files = document.getElementById("Uploader").files; if (files.length &lt;= 0) { return false; } var fr = new FileReader(); fr.onload = function(e) { var result = JSON.parse(e.target.result); obj = [ result ]; console.log(JSON.stringify(obj)); /* or */ console.log(obj); } }
Thank you, but I dont want to use global variables. I appreciate your answer! I just found the solution, may I broke something, but it works so far: I set the asynchronous paremter to false //old hr.open("GET", "mylist.json", true); //new hr.open("GET", "mylist.json", false); Now its working! :) function getDecodedJSON(jsonFile){ //Get JSON var hr = new XMLHttpRequest(); hr.open("GET", jsonFile, false); hr.setRequestHeader("Content-type", "application/json", true); hr.onreadystatechange = function() { if(hr.readyState == 4 &amp;&amp; hr.status == 200) { //Parse JSON data = JSON.parse(hr.responseText); } }; hr.send(null); return data; } getDecodedJSON("mylist.json"); 
A better solution that allows you to write asynchronously would be to utilise promises and/or async/await. If you use `fetch` then I think you can return that directly to behave as a promise. e.g. (not tested this): function example (url) { return fetch(url) } const data = example('http://example.com/api') .then(res =&gt; res.json()) .then(data =&gt; { console.log(data) })
You can put the *var obj;* just inside the function but I personally use it global.
I will look at it, thank you!
 function map(f, a) { if (a.length === 0) { return []; } return [f(a[0])].concat(map(f, a.slice(1))); } &gt; The recursive solution is quite elegant. Just two lines of code, and very little indentation. Smashing code into one line does not make it elegant. This code is difficult to understand because, as with almost any recursion, you have to visualize how it unfolds. Unless it's a tail recursion in which case it unfolds flatly (this isn't because map happens before concat). So there's an unnecessary call stack involved in constructing the output. With the loop method, the construction of the array is plain as day. I'm not saying recursion is bad, but if you're not careful, a subtle misunderstanding can cause you to incur serious performance penalties. This function is actually constructing an array backwards. So the question has to be answered, does concat make a defensive copy? From the documentation, it appears it does. This means you're making *two* brand new arrays for each element (one to wrap the individual element on the left hand side and a new one from the result of concat). That is just obscene.
&gt; crackle It crackles for me even in the foreground too! Could that perhaps be alleviated by changing buffer size?
Haven't really used Angular 1 or 2, but if I were to start a new project with Angular, I would start with Angular 2. It is where the product team has their focus. In terms of new features in core, Angular 1 is a dead end. But make no mistake - you can still go for Angular 1 and have a stable and functional development environment for many years to come. A lot of React devs are shitting on Angular, but my take on this is just: Decide which framework you want to go for, learn it properly, and stick to your decision. Angular can serve you well. React is more of a UI library than a framework. You have to decide and pick your entire ecosystem around the UI library itself. It takes some experience and time to nail this properly, but there are a lot of boilerplates you can sift through to help you decide. If you prefer a total package, go for Angular 2 or Vue. We use React and Vue at work. In my mind, Vue is kind of a mix of both worlds (React &amp; Angular). You can use it as a UI library only (like React), or you can leverage their entire opinionated framework environment with templates, build tools, directives, mixins etc. Here's a segment I wrote on Reddit late last year about Vue vs React: &gt; We use both React and Vue 2.0 at work. We're a tech company of 40 people and I'm the CTO. I can definitely appreciate both approaches, but I lean towards Vue as a personal preference. &gt; I like their flexible but opinionated way of connecting to the web ecosystem. If I want to use mustache, pug or JSX as a template engine, I can. CoffeeScript, ES6, ES5 or TypeScript as scripting language? Sure. CSS, PostCSS or SASS for styles? Yup. They all fit right into vue-loader and are first class citizens in Vue's dev tools. This is a huge plus in my mind. &gt; You can still do much of this in React, but it definitely requires a lot of configuration and you don't have to wander far off the main path to get in trouble. &gt; I think Vue hit the sweet spot out of the box with Convention Over Configuration, by offering clear conventions while still leaving a lot up to optional configuration.
Since you are still learning, I would recommend not to start your own project from the start. You might be disappointed from the results and quit all together. There are plenty of sites with code for simple apps you can play with till you feel confident enough to start something from scratch. There is one site in particular I can recommend, since I took part in its creation, that is completely free and has free lessons with quizzes on the end of each of them. [Academy of Code](http://www.academy-of-code.com/) it also provides with an online app builder with the code for some sample games you can play with [Game Builder](http://www.academy-of-code.com/en/webpage-builder) You can also try the demo of [TEST4U Javascript](https://www.test4u.eu/en/e-tests/javascript-en) (or buy it, if you feel like it)
And recursion is expensive in terms of memory because each stack frame is saved till the function is complete.
vue
I created a codepen where you can try it: https://codepen.io/anon/pen/Kargex?editors=0010#0
ok, understand &gt;I learned that writing short code is not the same as writing easy to understand code. Short code is not always the same as easy to understand, but very often it is! &gt; At the end of the day, I always prefer explicit code over implicit. It is good to choose adequate level of abstraction to current problem. When you are solving really complex one, you can choose low level of abstraction and very explicit code to improve performance and make debugging easier. But I bet more often our problems complexity is lower and this allow us to use tool at higher level of abstraction, and this will be very successfull investition in maintenance and readability. Talk to person who is new to programming, and explain mapping array with this two pieces of code: js imperative map function map(f, xs) { const result = []; for (let i = 0; i &lt; xs.length; i++) { result.push(f(xs[i])); } return result; } haskell recursive map map :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = f x : map f xs Which would be simpler to explain to this "see code first time" person? 
Very often performance is not your priority, but readability and cheap maintenance is.
I've been on a few code learning sites including codecademy etc and they're all really good. Found freecodecamp.com has a great range of programming challenges. Particularly the algorithm sections and is fairly heavily focused on JS. Have found some really helpful people there. There's a great range of people there too; from novices helping each other to more experienced programmers helping everybody that wants to learn. Great community of people. I'm learning too. Just my 2 cents. 
Unless your language implementation supports tail call optimization (and your algorithm can be written in a way that takes advantage of it, which is AFAIK always the case).
Am I the only one that learned it myself? I learned JS by looking a lot around the internet and I slowly learned how to use JS. I am working on this website: https://builder.xtclabs.net/ and I made everything on my own. In the beginning I had to look on the internet way more but now I am able to manage everything on my own.
[removed]
I think the difference here is pretty clearly one of language, not of pattern, though. Haskel is, in some sense, _designed_ to allow you to express things like recursive unfolding in a terse, very direct way without almost any boilerplate. Javascript is... not. That isn't to say that simplifying code isn't ever good for both explicitness speed and readability all at once. Often it can be, especially when you find some abstract core operation (like map itself) that is actually generalized and can be used to cleanly express a bunch of random imperative stuff. It just requires seriously questioning, always, whether an abstraction is really just a form of obfuscation vs whether it's truly serving the DRY principle to cleanly separate out all the intelligible parts and then describe how to sequence them into a particular behavior.
Seems to be free [from what I can find](http://www.dafont.com/gabriele-ribbon-fg.font).
ok, I could be wrong, seriously questioning - cure for all evil ;D
You can use https://github.com/lodash/babel-plugin-lodash to achieve this
[removed]
Breaking out early is definitely a thing in HOF. JavaScript's built in ones include find, every, and some.
`.slice` also makes another array. This is the problem when you take idioms from Haskell (a language with extensive support for pattern matching and TCO), and then try to shoehorn it into Javascript (poorly). You end up with a monstrosity that is neither idiomatic, elegant or efficient. And the whole "without loops" claim is quite silly, since it does end up using a loop somewhere in the native code. It's kinda like claiming you can parse XML without using if statements and then proceeding to use the DOMParser API. Use higher order array methods if it help increase clarity or reduce bugs (e.g. related to var and closures), but don't just gratuitously use them if a loop statement is clearer.
I am trying to do it on my own too. Just following some steps cause I think I would be lost to go looking around net. There are sooo many terms I wouldn't know where to start. 
No you're not, but some are trying to shorten their learning curve. I learned on my own as well, and wish I would have done something like freecodecamp. Nice site btw!
The main problem is overhead. Has ES improved the efficiency of these new loops? I tend to default to a cached for loop when dealing with large amounts of data since it's proven to be the most efficient.
I have some experience with contractors. But none good. It is really hard to have good help unless everyone is in the office with you. Otherwise it's a lot of back and forth which costs time that could be spent just doing it the way you wanted in the first place. Sorry. 
&gt; any advice on a professional setting What's your experience level and whereabouts are you? If you're junior and/or not in SF, focus on ng1, and learn at least the basics of React. A lot of companies are either in maintenance mode for large ng1 apps or slowly transitioning from it to something else, so demand is high. If you're intermediate (e.g. have work experience in other languages), you'll want to have mastery of at least one framework (doesn't really matter which) and be at least familiar enough to be able to talk intelligently about the rest. Sell yourself on your engineering/architecting skills. I know vue has been getting some traction around online tech communities, but honestly, I don't see it come up much in job seeking contexts. If you haven't already dabbled with it, then don't bother for now. 
The recursive map is easier to read, but if I was introducing programming logic to someone, they should understand what is going on, which is easier to see in the for loop. For loop is much easier to debug IMO. The map is nice for straightforward, mundane stuff. 
What "ultimate" version? That's the last snippet I see where he defines map. I know I'm cherrypicking from the article, as it's not just about recursion, but it grinds my gears when this is called elegant.
I feel like this is a troll, how is that elegant in the least bit.
Find a mentor, that's what I did. I just launched my first node js app on Monday. This was the first big project if ever 'finished', and boy was it exhilarating. 
[removed]
* Study related things that aren't directly about code like: semantics, accessibility, security, AI, automation, human-computer interaction, usability * Study other technologies that define the foundation: DOM, XML Schema, XPath, namespaces, RDF, FOAF * Write software that defines how these technologies work: parsers, static analysis, accessibility analysis, node graphs, event interaction monitoring, code beautification * Focus on the foundations of JavaScript: scope, data types, performance, code organization, data structures
thank you very much for this input. I will definitely check it out. 
No worries, wish you the best. Practice and research. Cheers.
These aren't official Redux bindings, they are official json-git bindings to Redux. Big distinction as I initially thought this lived under the Redux GitHub org...
Last I checked they were still horrendously slow compared to a for-loop. So they're still useless for anything bigger in scope or if you care about performance.
who cares? weâ€™re so deep in academic language theory code that an obsolete browser is really off-topic
one question. I am almost over with Bootstrap on freecodecamp.com. and I thought about one thing. There I am currently building web page. lets say "normal" web page. Is anyone even using it anymore? or only WordPress and such themes? Should I (once when I know how) build WordPress themes or my own "normal" web pages? Sorry for the word "normal" I don't know if there is some other name for them. I was building for few years web pages in WordPress but only long long time ago something like that "normal" pages in Dreamweaver.
A for loop and while loop are the fastest types of loops in Javascript, and least likely to break due to environment issues. A recursive loop can get complicated when you have to pass more state around, or they have to use variables outside of their scope to track iterations if you want to break early, using an if statement to check the state of the loop. They can also cause "call stack size exceeded" errors if the number of recursions is greater than the call stack size. Memory is also an issue as every iteration will add new code and new data onto memory, so it's easy to get "out of memory" exceptions with recursion. There's a use for recursion, but it's not to replace a simple for loop when you think the for loop is too verbose.
Which browsers have implemented that already? The spec is cool and all, but this is a feature that, like Proxies, can't be polyfilled/transpiled.
Indeed you're right! Misunderstood myself.
I'd be amazed if you could show me that 1% of recursive functions that are more performant. I'd say that number should be 100%.
Of course what someone already knows is easier to understand, that is absolutely irrelevant to the question. You should compare the readability for someone who understands the primitives used, otherwise the status quo will always win and this debate is pointless.
Thanks!
I'm not at all an expert either, but think the core problem is more that Haskell and other functional languages: 1) treat functions as first-class _syntactically_ as well as literally (javascript has the literally part down, which is why it's so flexible and why it can express and represent FP in practice) Javascript would need a complete syntax rewrite to achieve that, I don't think any amount of sugar could help without "breaking the web." That is, they're never going to/going to be able to make `succ 1` a valid string of characters in javascript that executes some behavior. 2) ensure safety and make abstract guarantees right in the language that javascript cannot do by itself without basically being another language that compiles to javascript (which is, in fact, exactly what a lot of people are moving to these days) Being primarily a javascript programmer who has been learning bits and pieces of Haskell, it's _still_ hard to my head around how different things are, from the ground up, in these languages. They're based on some very powerful laws and guarantees that allow for abstractions in a way that's hard to make sense of in javascript terms (though they _can_ in fact be written to work, they just have to be written out). Like, if a type like an Array (in any language) implements what we know as .flatMap (i.e. transform an Array by using a function that takes each value and returns an Array, but still return a single Array of values in the end) and also what we know of as Array.of (put a single value into an Array), then we know _in theory_ that your Array type _doesn't *really* need to write an implementation of .map_ because that operation can just be generalizably derived from those two things for ANY type. But in Haskell, that's not just a theory: you can literally tell the language to just derive .map and never even have to write it all. And again, these are [things that you can write _in_ javascript](https://github.com/fantasyland/fantasy-land#derivations), ultimately. They're just not logically at the core of the language and can't really be. Because Javascript values and types just aren't written from the ground up with all these sorts of guarantees built into everything.
exactly. this is an academic discussion far away from practical considerations, so i brought that up
While a bunch of folks are marveling at the "elegance" of their code which arbitrarily excludes various language features, like loops, ifs, mutable variables, others are hard at work writing code that matters. And the world keeps turning.
I use map, reduce etc myself. But I would use a loop over vanilla recursion unless there was some particular need not to.
I've had the best luck with contacting people from the hacker news monthly freelancer threads. I've been mostly pleased with the quality I get, but it's never cheap.
&gt; x is more readable because I know what both x and y mean and I deemed x to be more readable Read again. I claim that it is more readable because **anyone** that understands **foldr** can get this implementation quicker and faster than someone that understands **for** can get the alternative implementation. Moreover, by avoiding mutation and loop indices you are considerably restricting what you can do, which makes the implementation simpler and considerably less error-prone. You avoid off-by-one errors, you avoid index out of bound errors, you avoid the very error that is one of the leading causes of invasions because of memory leaks. Programming defensively makes your code more robust and, yes, your team more productive. There is one, and only one reason to use for over foldr: laziness to learn. So, yes, your attitude isn't the one helping the team, it is the one costing the company a lot of money and causing your team to spend hours debugging unnecessarily complex code because, yes, you are too lazy to learn proper abstractions.
Oh shit this is really cool! I'd love to try it when it's done!
Personally I would find the following a lot more explainable than either of those: (I also like my variables to be descriptive). const result = exampleArray.map((row, index) =&gt; { // modify the rows here return row; }); 
Thanks! There's a ton of stuff I'd like to add like comment sentiment analysis, karma over time, recent/trending interests, etc. I'd also like to give it a more human element like "User xxxx recently became interested in the r/yyy subreddit" or whatever for certain sections. Unfortunately the reddit API limits comments &amp; submissions to 1000 max so very active users don't get to see their full account history.
Those all sound like really cool great ideas. I do have to wonder if there's some way around the 1000 max issue though...
You can pause and slow down webm's I'm pretty sure?
That's the issue. I can't depend on experimental features, especially when what I'm trying to do can be trivially done with a loop and interpreted by older browsers no problem.
The reason I put "elegance" in quotes up there is that the code in this article is not elegant, it's quite horrible actually. Elegance is measured relative to your goals. Things like product defects, product performance, product ease of maintenance, flexibility to refactoring and so on. I highly doubt that "product code written in JavaScript, but trying to pretend it's Haskell, even at the risk of terrible readability, horrible performance and high risk of stack overflows" is among those goals. If someone like Haskell, that's great, they can write Haskell in Haskell, not use their work as a playground for their shitty experiments. Of course, in this case, the product is a blog article, and the goal is that it's interesting enough so it reaches an audience. The author of the article isn't the sucker. But the people reading the article, and then trying to implement this advice in their *work*, that's who the suckers are.
I agree. This article doesn't really seem to do anything other than make a point that you can write code without normal loops, but should you? Probably not. This is what happens when you run a blog and need to keep putting out content regardless of its quality or importance to the overall community.
&gt; weâ€™re neck deep in theoretical language design stuff I don't know what gives you that impression. The article states this in the first paragraph &gt; Our goal is to write less complex JavaScript. and then proceeds to talk about map, reduce, filter, and find, which are all real Array functions used in everyday code. You can't get more practical than that.
Coo. Like I said, not intending to deter you from your project. Lookin' forward to a demo.
i like your ui a whole lot better than snoopsnoo's
Not too hipstery, that is the only option I came up with and was considering, just hesitant to give it a go ;) 
Release early, release often...
I think you meant pure functions, not idempotence. Idempotence means you can pass the result of a call back into the function and still get the same result. [A function is idempotent if, whenever it is applied twice to any value, it gives the same result as if it were applied once; i.e., Æ’(Æ’(x)) â‰¡ Æ’(x).](https://en.wikipedia.org/wiki/Idempotence) // Pure but not idempotent const addOne = (x) =&gt; x + 1; addOne(addOne(7)) !== addOne(7); // Pure and idempotent const timesOne = (x) =&gt; x * 1; timesOne(timesOne(7)) === timesOne(7);
&gt;basically imagine working in a big enterprise and all those young/small employees talk to customers, but customers are only talking back to the company CEO, which then relays to the entire chain of command back to the employees. That would be super inefficient for people, but it's not for a computer :) Computers do this very easily. And the benefits you get from one-way data flow are numerous, but the main benefit imo is that you'll have a single source of truth for your data on the front end. I know the back end has the golden copy, which is great, but I'm talking about in javascript memory, you don't want multiple copies of the same data, because it's a terrible pain to keep them in sync.
So according to your best scenario, you would have n times however many functions per for each sub-component. The result is A becomes huge. Do you find that OK? Also, imagine your single source of truth is an Object or an Array with thousands of items. Now, modifying any one of these in D would trigger the computation/transformation in the whole cascading chain A&gt;B&gt;C&gt;D, so you lose the snapy-ness of React. Even if you were to implement shouldComponentUpdate, you are essentially telling it when a component, supposed C2, or B3, should NOT update when D changes.. that much worse than situation 1 IMO.
In JavaScript, they're extremely arbitrary. The fact language X can't express loops, because it has no mutable variables, doesn't mean JavaScript has to **arbitrarily** abide by the limitations of X and follow its conventions. People seem really, really confused about why functional languages are elegant. It's a long story, but the short story is that to program in a functional way end-to-end, 100% of the time, no exceptions, you need the whole package: a functional problem, in a functional language, with a functional runtime. I don't have to explain that JavaScript doesn't optimize tail recursion (yet), while every functional language does. So it's very simple: JS has mutable variables and no tail recursion, ergo use loops. Haskell has no mutable variables and optimizes tail recursion, ergo use tail recursion. See? It's so simple, and kind of boring actually. Turns out removing loops and ifs and so on from your code doesn't make your code magically better, instead these styles are born out of the abilities and limitations of the language semantics and runtime. Go figure! Using high-level call like map() or search() or reduce() in place of loops is usually fine. But avoiding loops at all costs, including when *implementing* such high-level calls, is borderline idiotic.
It's efficient if your props are perfectly cascaded down to the subcomponents, but when the single point of truth in the master component changes and at each level, some transformation occurs on the props and when you have hundreds or thousands of subcomponents, the performance degrades, thus making it inefficient. btw, why the hell do i get down-voted so much? is /r/javascript the /r/politics of programming?
When dealing with a form using data coming from an API, that data has to be provided by _something_ and you need state changes tracked _somewhere_. If you were to be extremely dogmatic in your reading of the recommendations, you'd trigger Redux updates every time one of your form values changes, which I find excessive and extremely unpleasant to deal with. My interpretation of the anti-pattern portion of this guideline is a warning about losing your single source of truth. By duplicating props, you have two copies of the data floating around in the same component. It could become easy to lose track of what is being presented or why the component is/isn't rerendering. I'd argue that your approach is fine as long as you are careful about _only_ relying on the component-state-owned set of data within that component.
The year suffix is the official one
Thanks for the kind words! We're always interested in trying to find ways to make the specs more accessible for web developers. For a long time one of the community members maintained a [version of HTML for web developers](https://developers.whatwg.org/) with a lot of the implementer-facing stuff cut out, but unfortunately that's fallen behind the current spec and as such we don't link to it much anymore. Hopefully we can revive that effort with some community help in the near future...
As I think about it, I think maybe consistency isn't precisely the problem, at least at the language level, or at least not in an easily identifiable sense. The general experience I have with using PHP is that I find it very difficult, compared to other languages, to predict what's going to work, and what isn't. Maybe a better word would be "compressibility". How many special cases do I need to keep in mind to figure out what's happening. For a _totally_ unfair comparison, take Lua. Lua is extremely "compressible" in this sense. You can learn basically all of the top-level concepts in a day or two, and then everything else is patterns for composing those concepts. PHP is the opposite at multiple levels, and in this way it shares many problems with C++. As a result, in the thankfully rare cases that I need to use it, I end up restricting myself to some tiny subset of the language. At the API level, "inconsistency" begins to be more the right word. My favorite example is the mysqli API. Basic client functionality will be present or missing depending on which driver you're using, which is an insane perversion of the entire _idea_ of an API layer. For example, do you want to fetch a row from a prepared statement? Well, if you're using the native driver, you have a number of options for doing that. If you're not, (afaict) you _have_ to bind the columns to local variables. Why, PHP? Why are you forcing me to use this pass-by-reference anti-feature for something so basic? Of course, you can implement fetch_assoc yourself, but as I said, the whole point of an API is to abstract away low level differences. Errors are a complete clusterfuck, both at the language level and the API level. At the language level, some syntax errors contain meaningful information to tell you where you screwed up. Others, for sometimes marginally understandable reasons, just shrug and say "syntax error" and leave you to manually scan your entire file for a mistake. At the API level, everything has its own arbitrary choice of to throwing an error, returning an error code, or returning null and tracking errors in a global variable (`json_decode`, I'm looking at you).
You're ignoring the vast majority of the problem domain. You don't avoid mutable variables so you can do maps. You avoid mutable variables so that you can utilize the composability of functions. Which allows you greater control over the data. Particularly data of indeterminate size. See rx.js and cyles.js. Also, tail call is in the ES6 spec. It will be here. So, you will be able to use both. These folks are just adapting the styles now. I'd go a step further and say that in functional reactive architecture. You're doubly prepared for working with highly interactive programs in a very efficient way. Which is the problem domain most UI developers find themselves in.
I'm new to JavaScript, and have tried to see where ES6 modules are referred to in the following compatibility table, but can't figure it out. Could anyone please offer any pointers on where I'm going wrong? http://kangax.github.io/compat-table/es6/#tr
Hang on, does `for...in` work? I thought that iterated over object keys, and `for...of` was the way to iterate over array items. I haven't tested it myself but I've been told that `for (let i = 0, i &lt; arr.length, i++)` is quicker than map etc. Doesn't make a difference in most applications, I'm sure, but sometimes it does.
absolute value is probably a better example for idempotence. `Math.abs(Math.abs(-1)) === Math.abs(-1) === 1`
How else does one create a zip file if not programmatically? 
&gt; You avoid mutable variables so that you can utilize the composability of functions. OP's article implements map() by avoiding loops. The interface of the function is exactly the same as map() implemented with a loop. Now, defend your statement and tell me what's the difference in "composability of functions" depending on which implementation of map() I use. Considering they behave identically, except the loop-less one is much slower, and might cause a stack overflow. &gt; Also, tail call is in the ES6 spec. It will be here. Right now, it's not here: https://kangax.github.io/compat-table/es6/ It "will be here" means absolutely nothing. When the day comes when it "will be here" then articles probably "will be written" taking advantage of it. Right now, today, you can't deploy your code on hopes and dreams, so you have to deal with the language as it is. &gt; I'd go a step further and say that in functional reactive architecture. I'd go a step further and say that in functional reactive architecture. You're doubly prepared for working with highly interactive programs in a very efficient way. You know lots of neat buzzwords, but you're very poor connecting them to your argument. Throwing a loop here and there, when a set of items calls for being processed, doesn't prevent you from composing functions, or writing reactive code. You'll have to support your argument, if you'll claim it does.
I don't know for sure why you're getting downvoted, that SUCKS. This is genuine conversation. I THINK you're getting downvoted simply because you don't understand something :( &gt;the performance degrades, thus making it inefficient Are you speaking from experience, or are you just worried? I think if you try it out it will blow your mind and you'll be like, "WTF how is this SO fast and SO efficient?!"
I looked at the code on github and did not see anything related to ZIP file creation. It looked more like organizing some items into a package to be zipped on the server. I have seen zip libraries written in JS of varying completeness/quality. When I need to create a zip I have leaked instructions to a node child process for the OS's native zip utility to create/unzip the zip file.
thanks!
That Haskell example is an excellent example of keys saved not meaning time saved `\` is not explanatory.
&gt; anyone that understands foldr I think you're the one missing my point. Anyone that understands `foldr` would understand `for` just as easily, if not more easily. For the sake of argument, let's talk about `fold` and `scan`. Anyone that understands `scan` certainly understands `for`, but not everyone that understands `fold` knows `scan` (or vice versa). And to begin with, why do we keep saying `fold`, that's not even what it's called in js! &gt; There is one, and only one reason to use for over foldr: laziness to learn. Laziness? lol, that's just elitist. There are nearly infinite things to learn and learning takes time, you can't expect people to just know [insert random thing here]. Many people are even eager to learn, but they haven't "leveled up" enough to really get FP. It isn't even about attitude. Also, most workplaces are not Google. It's much more common that the one "rockstar" using intermediate/advanced FP effectively becomes the only one able to maintain the code at all, than that same person writing `for` loops does so with so many off-by-one errors or whatever that no one else can maintain it. Especially considering the vast majority of for loops are literally `for (var i = 0; i &lt; foo.length; i++)`. Also, we could be here all day naming very smart people using for loops very deliberately in perf-sensitive inner loops. I don't think laziness plays any factor there. Enumerating the benefits of map/filter/reduce over loops is neither here or there. Of course they're better at what they are better. Loops are good at performance, so what? I use what makes sense, sometimes it's loops, sometimes it's higher order functions (yes, I use reduce rather frequently at work, surprise!). And for reimplementing `map`, I find the loop easier to understand.
`[f(a[0])]` is particularly hideous.
I'm just hoping for 'JavaScript without JavaScript' ;) (And no I'm not talking about TypeScript or Elm or whatever).
http://www.dictionary.com/browse/luddite https://www.merriam-webster.com/dictionary/Luddite
With no disrespect intended to anyone, I doubt that most of the people with dogmatic opinions about this sort of thing have built anything non-trivial. If they have, I somehow doubt that the apps are pleasurable to work with or quick to adapt to changes. The "PUT IT IN ALL IN REDUX" approach creates so much sprawl and turns simple tasks (forms, in particular) into multifile ordeals. Gross. The community's impulse to avoid local state and keep things purely functional comes from a great place and is an excellent starting point, but you need to prioritize shipping and your own sanity over the purity of the ideal.
Lmao
if you're going to create n objects, what's wrong with O(n)?
This is the first time I've seen :: in Javascript. What does it do? What's the name of it? Google showed nothing relevant. :)
Oh, I didn't mean it derisively. I actually meant that is their main selling point.
When I said "other", I meant other than your map and filter methods. In your OTHER methods, are you doing some kind of inefficient operation that makes your app slow that you're blaming on react?
Oh yeah, that's true but if the rendering ever gets too crazy then I would split these up. 
This comment made me laugh out loud 
you don't need any other methods. simply evaluating cascading O(n) render functions will be enough for performance degradation
It's backwards.
itâ€™s the bind operator, and i linked the proposal above. itâ€™s stage 0 still after quite some time, because people are unsure if they rather want the pipeline operator `|&gt;`. what it does is being able to call a standalone method as if it was bound to an objectâ€™s prototype. assume we want `takeWhile` as array method. we might subclass Array: class TakeWhileArray(Array) { takeWhile(predicate) { let stop = this.length this.some((n, index) =&gt; predicate(n, index) ? false : ((stop = index), true)) return this.slice(0, stop) } } but this returns a regular array! and weâ€™d need to convert any array to a TakeWhileArray to use the method! so instead we use `::` to call that function *as if* the object on the left hand side of `::` had it defined as a method: function takeWhile(predicate) { let stop = this.length [â€¦] } const digits = '123456'.split() const even = digits .map(Integer.parse) ::takeWhile(e =&gt; e % 2 === 0) and `|&gt;` is the same thing, but it uses the first argument instead of `this`, so our code would be function takeWhile(array, predicate) { let stop = array.length [â€¦] } const digits = '123456'.split() const even = digits .map(Integer.parse) |&gt; takeWhile(e =&gt; e % 2 === 0)
Why not fetch the CSS, modify it into valid CSS, and create a style tag with that? Creating a custom style tag *is* the browser's parseCSS() function.
Props and state are not really the same thing. A component should manage its own state, but it should not manage its own props. Props is essentially "state that is managed by the component owner." That's also why props are immutable. For example, if you happen to have a dropdown menu component, you want the component *itself* to have a click event and open itself up to show its contents. That's part of its internal, self-regulated state. You would not usually make a `menuState="open"` property and put the responsibility of listening for clicks to the containing componentâ€”for one thing, that would lead to a lot of duplicated code. However, the children of such a dropdown menu would *need* to come from the containing component. They are props. Confusing state and props leads to an application structure where it's unclear what component is managing what data.
I don't think you're expressing your problem very well. Also, the example with hundreds of subcomponents also seems to be an exaggeration of your actual problem and distracts the conversation. If you end up in that place somehow you may want to look at how components and data are split up, shouldComponentUpdate, etc. If a lot of transformations need to be applied then it should be done by whatever retrieves the data (the call to the backend or the reducer). Now, if I understand your initial problem I think your issue is that your application reloads all state which of course forces all other components to refresh. Your application should only change relevant state when it does an action.
What kind of horse are we talking about?
Well, I apologize if that sounded patronizing, but to me the corollary to the above is that it's very confusing to a component user if immutable props are mapped to mutable state. After all, you instantiate a component, give it some props, and then you expect those props to be respected forever since they are immutable. The component should never disagree with its props. But if you map props to state, say as a one-time operation at the beginning, and then modify that state, you get an apparent discrepancy.
instagram is a react app, so it doesn't work directly off the DOM. when you write text manually (as opposed to programmatically) you're triggering a synthetic event system in react's internals that updates the relevant properties tracking that input. for your use-case, you might want to consider doing code injection using a browser extension, but the effort you'd expend might not be worth the benefits (aside from the lulz, of course :) ) tl;dr: your strat (probably) won't work as-is because of how instagram is built
good to know, this thread makes a different impression.
Apparently, it's really really bad to do any kind of DOM manipulation in the Transport callbacks... I moved it to a Tone.Draw.schedule() callback, but [it](https://jsfiddle.net/5xzrsjg2/85/) doesn't seem all that much better.
Okay I THINK I see where your misunderstanding comes in. Using your example with A, B1-n, C1-m, D1-p. If something in Dx triggers a change in A, you DON'T have to write code to handle shouldComponentUpdate in B, C, and D. Let's say.... * A has a huge array, items * B displays all those items as rows in a table * C displays all those items as inline-block divs * D displays all those items as options in a select. A's constructor: this.state.items = ["one", "two", "three", ... , "one million"]; A's render: render() { return ( &lt;div&gt; &lt;B items={this.state.items} /&gt; &lt;C items={this.state.items} /&gt; &lt;D items={this.state.items} /&gt; &lt;/div&gt; ) } B's render: render() { const rows = this.props.items.map(function(item) { return (&lt;tr&gt;&lt;td&gt;{item}&lt;/td&gt;&lt;/tr&gt;); } return ( &lt;table&gt;{rows}&lt;/table&gt; ) } C's render: render() { const divs = this.props.items.map(function(item) { return (&lt;div&gt;{item}&lt;/div&gt;); } return ( {divs} ) } D's render: render() { const options = this.props.items.map(function(item) { return (&lt;option&gt;{item}&lt;/option&gt;); } return ( &lt;select&gt;{options}&lt;/select&gt; ) } Then, in some method in A, if you do: const items = this.state.items; items[0] = "ONE!"; this.setState({ items: items }); B, C, and D will re-render with the new "ONE!" instead of "one", automatically. You don't need to write any code in any `shouldComponentUpdate` method. By doing (in A) a `setState` and setting the `items` key, and since you're passing `this.state.items` to B C and D, B C and D know they need to re-render and so they do. Also B C and D don't repaint the million items in the DOM. React uses a virtual DOM and so it will update the 3 necessary elements--one &lt;tr&gt;, one &lt;div&gt;, and one &lt;option&gt;.
And very often recursive functions won't help with the latter two.
Caching arr.length is almost always going to be a microoptimization. You'd have to be doing crazy things for this level of optimization to be worth it. Certainly it's not worth thinking about until you actually notice a problem, at which point it's trivial to change (but again, I highly doubt that's where the bottleneck will be)
&gt; doesn't seem all that much better. Are you kidding? It makes day and night difference for me. With version 85 the crackling is virtually fully eliminated. Thanks for making this change!
I think that's a fine use of local state, if you just need to update a field's value or a checkbox's boolean, and only want to update that data in redux/db on a 'submit' event or something. But how is that an example of the props-&gt;state antipattern? It sounds more like keystroke-&gt;local state-&gt;db/ redux props-&gt;back to the top and the app updates all the way down based on the new props/db data. Isn't that how it's supposed to work for small things like input fields, unless you need to live update a bunch of components based on keystrokes? So I guess I'm agreeing with you. I don't think that every user typo on a form has to go all the way around the circuit to be reflected on the dom. In my mind, for a form, the data becomes 'props' once the user is done changing their mind and submits it, and until then it's local state only unless there's a good reason for other components to know about it.
Exactly! people are completely missing the point because they found a couple of functions that were harder for them to understand instead of trying to understand the concept under them. The trend seems to be that people who doesn't understand/get functional programming start to bash on it because it's not clear enough. When obviously not clear for them means they haven't taken the time to understand the concepts. When I started to learn FP I didn't do it because I thought it was cool or easy I did it because I could see all the advantages. After a few months playing with it and and using its ideas on my job I find it easy to understand most FP patterns. It's a long road but you can feel and see the advantages of doing so.
I find it to be elegant. Actually when I write a for loop I don't feel good doing it. The only time I'm ok writing for loops is when I'm writing algorithms and I want to update elements in place to save memory. 
Coming up with a definition !== coming up with an implementation. Cheers for the author coming up with an implementation to explain how map works under the hood. Granted, the implementation might now be the most optimal, but again, besides the point. What the function "does" is the point.
It does the first 2/3 times they see the code after that it's all good. My team did it to me and I couldn't be happier for that. They forced me to see the world from a different angle and I consider myself to be a better programmer because of that.
Why
I can't use that for some reasons. my choices are between CEF and electron.
Also I'm surprised compilers don't do that already...
The point of this article is to showcase the built in array methods that are more expressive in fewer lines of code. If you see map, filter, or reduce (although reduce can definitely take the longest to get used to), you immediately know the intent. A for loop with temporary arrays and a counter requires reading all of the code to understand it.
You are right, using for...in in an array is discouraged https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in
In our company we had to support the exact three you mention, it's a library that has to run in several frameworks. We went with a slightly different route. All the complex logic, server interaction, interaction itself, it lives in Redux. That way we can plug it into everything. The dress around it isn't that much work if the state is properly abstracted (actions, thunks, reselect, etc). We have customers that use it now in React, Angular and Vue. The former two have well maintained redux bindings available, writing bindings for Vue was easy: https://github.com/vuejs/vuex/issues/450 Though if you are already divided internally, i think you should find an agreement. It's a waste of resources if you cannot share components, or not even the store.
Thanks a ton! I've definitely encountered some of the issues you mentioned (like arguments "array" or NodeList). It really helps to see some of these "criteria" for good/bad APIs explicitly stated. I feel so bad asking one more question but you have been so helpful I feel like I have to chance it. As a self-learner and relative beginner I look at all the web APIs available, and all their interfaces, and it can be a little overwhelming how many there are. Also, it seems like most of them are abstracted away from us in the form of frameworks and libraries (or at least I haven't seen any of them in all of the common web dev curriculum material out there right now). I'm currently working on understanding the DOM API better (usually tutorials stop at `.getElementById` and `.querySelectorAll`) and after learning XHR I spent some time with Fetch, since promises seem really handy. What APIs do you think a relatively inexperienced web developer could benefit the most from learning? Outside of vanilla JS, the DOM, and AJAX I haven't yet explored many other web APIs that aren't frameworks or libraries. 
&gt; const strongestHero = heroes.reduce(greaterStrength, {strength: 0}); &gt; const combinedStrength = heroes.reduce(addStrength, 0); Why would you traverse the collection TWICE? With a for-loop this is easily solved by just going over once, calling both functions per iteration. const greaterStrength = (champion, contender) =&gt; (contender.strength &gt; champion.strength) ? contender : champion, addStrength = (tally, hero) =&gt; tally + hero.strength; var strongest = {strength: 0}, combined = 0; for (hero of heroes) { strongest = greaterStrength(strongest, hero); combined = addStrength(combined, hero); } It's not a two-liner, nor the best example, but it is more extensible. And you can add as many aggregation functions as you want in the loop, and get all the results for the cost of a single iteration of a collection! Edit in advance: I like map/reduce/filter, but I wouldn't try to use them just for the sake of using them. If I can filter a collection, then pass the filtered objects to a map, then use reduce to process them into a reseult, so be it! But I'm not going to call reduce on the same collection with different callbacks 3 times when I can do the same thing in a for-loop for less cost. Advance edit #2: I didn't miss the point, or just take this away. It's just I don't have anything new to contribute opinion-wise, and this particular example stuck out and annoyed me.
I don't disagree with the point that the built in functions are much nicer to develop with. I also acknowledge the idea that they use more memory or time to execute. You just have to know what they do and make the choice for the approach that's best for your circumstances. Thanks!
If you read further down in my comments, I stated that it shouldn't even matter if you're not working with interables of any significant size, for me, it's just my personal preference to optimize as much as possible, even if it's trivial just because I like the challenge.
What /u/DomenicDenicola wrote above is quite accurate. I would add that at a more philosophical level, the difference between the two groups are quite profound. The WHATWG values technical precision most of all, leading to cases where even though almost everyone wants one particular outcome, another outcome is chosen. For example, a [huge number of people](https://lists.w3.org/Archives/Public/public-whatwg-archive/2009Jun/0599.html) wanted the HTML spec to require a non-patent-encumbered codec for the &lt;video&gt; element, but the reality of the situation is that such a requirement would have been ignored and this would have led to the spec being imprecise. Another example is with issues relating to accessibility, where sometimes the reality of the situation differs from what accessibility advocates would have people believe, and so the WHATWG spec goes with a politically inconvenient solution that actually solves the problem. longdesc="" is a great [example](https://blog.whatwg.org/the-longdesc-lottery) of this. The W3C, on the other hand, is an organisation supported by large annual fees from large companies, and its primary organisational goal is to ensure these companies remain as paying members. I have multiple times seen arguments be won by companies implying that if the decision didn't go their way, they would leave the organisation. I have seen contributors turned away because their company was overdue on their fee (regardless of the quality of the contributions so lost). Oddly, for a group with "Web" in their name, this often means that disproportionate influence is given to organisations that aren't browser vendors. This is because realistically the browser vendors can't leave the W3C, there is too much going on there for them to leave, while other organisations tend to only be there for one specification or working group and so if they aren't getting what they want they can just quit without losing much. The biggest evidence I've seen of this difference is around DRM. DRM is a technology that is literally impossible to implement. Any DRM solution will always be broken, because there's just no way to simultaneously let someone decrypt content and prevent them from decrypting content, however much you obfuscate the keys. The W3C, however, is all-in on DRM, because by doing this they got a bunch of companies to join as members who wouldn't otherwise have had a reason to join.
Right, and I'm saying this is not a good thing, because it's not beneficial to anybody. You end up with less readable code, which may or may not end up having to be read by somebody else, and there is no positive side effect. By all means, write your microoptimizations, but I just don't want you to have any illusions that what you're doing is good. It's almost certainly a bad thing.
If you are actually interested in compressing or extracting files from within JavaScript, there are libraries out there, such as [zip.js](https://gildas-lormeau.github.io/zip.js/)
I'm not super familiar with react's internals so there may be a way of doing it from the outside, but as far as i know react components need to explicitly register their upstream data sources. this is because a big part of react's design is to ensure that you can easily trace what's affecting your component's rendered content by preventing external side effects. 
THOUGH DOTH NOT INCLUDE THEE EMACS?!?! HERESY!!!!
Brackets.io Less configuration than Atom but just as powerful in the plugin department. Good for visualization of results with its preview systems.
If you're looking for a somewhat-complete overview I find https://platform.html5.org/ helpful. Of specific APIs... - Fetch is definitely a good one. - Canvas could be fun if you want something rather different from the rest of the platform and that allows you to make cool graphics. Definitely "optional" though. - Custom elements is a neat newish technology for creating your own HTML elements - Knowing the basics of web workers allows you to do work off the main thread, which is quite powerful. I wish I had used more web workers when building business apps. - Service workers are a gamechanger technology for building serious web apps that load fast and work offline, like native apps. They're fairly complex, but I think they have a good learning curve; for example [this codelab](https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0) or [this small service worker I wrote](https://github.com/whatwg/streams/blob/master/service-worker.js) give an intro to the basics. It's such a wide field though... in the end you kind of have to just wait for problems to come along and then see if there are good web platform APIs for solving them. E.g. maybe you need to [display desktop notifications](http://notifications.spec.whatwg.org/) or to [gather telemetry on what is causing your page to jank](https://github.com/wicg/longtasks). Who knows!
I think you should read up on Redux a bit. You're missing the entire point of the unidirectional flow, of the purpose of reducers, and of the power of middleware. I'll say this from experience: having your components make direct calls to the back-end just leads to spaghetti.
&gt; btw, why the hell do i get down-voted so much? What you call "aesthetic merit" is of great importance in Javascript development, and labeling it this way is dismissive. I'm still trying to get used to it myself, but the often-lampooned state of Javascript development is one that greatly values programmer time over computer time. This is nothing new; that balance has been shifting at least since the advent of assembly language (*What?!* You want to use valuable computer time to *write computer code?!*) but it is difficult to appreciate just how *far* it's gone, to the point that it's common to sling large data structures around and let the other end take what little part (often &lt;1%) it needs and throw the rest away. At least, that's why I think I get downvoted when I criticize the memory or network efficiency of common Javascript practices.
Form fields are an exception, because they can be either controlled or uncontrolled, although the latter is more for legacy purposes and isn't a recommended practice. If a form field is controlled, it follows the aforementioned model just as well. The field doesn't update the master component directlyâ€”it fires a callback function (which lives in the master component), and that function updates the master component's state. You're not actually typing into the DOM. If your form fields are uncontrolled, then you're reading information directly from the DOM. But in that case React won't interfere with the DOM either, so the prop you set for the field's value won't work anymore. It's not a very neat solution but it helps interoperability with e.g. some jQuery code that also lives on the page.
Personally, I would definitely prefer the `|&gt;`. The fewer `this` references I need use, the better. Especially since I have no idea how `::` would work with arrow functions. If it would. Maybe it wouldn't. `|&gt;` would really go better with currying, though, which is yet another can of worms.
No. I did say anyone who understands map/filter/reduce understands for loops, but I didn't say you should always use for loops. I very clearly said "use what makes sense". Also, what I said is that in the specific example above, the for loop implementation is clearer than the foldr/cons example (for all the reasons I mentioned). Btw, did you guys notice that the foldr/cons impl of map does not actually work? (and CANNOT possibly work: wrong signature, nonsensical usage of cons,...) // original function map(f, a) { if (a.length === 0) { return []; } return [f(a[0])].concat(map(f, a.slice(1))); } //teh awesomesauceness!1 map = f =&gt; foldr (x =&gt; cons(f(x)), []) map(x =&gt; x * x, [1,2,3]) // go ahead, try to make this work LOL, seriously use the for loop version.
That looks pretty nice. Every time I see the `|&gt;` syntax I can't help but think of how well it would work with the FP flavor of lodash or ramda, but I'm also not sure that the ecma committee would be big on adding an entire language feature that really needs a library to take full advantage. I did really grow attached to `|&gt;` in my brief dive into F#, though, and I find myself missing it.
I am planning to clean up my code next week.
What part of the article has to do anything with Haskell? just because they used FP concepts doesn't mean it's trying to be something it isn't. Also, the whole point is not how to implement the map function, which is not a performant implementation, is how by applying these abstractions it lends to a cleaner and more concise code. Let me put it another way. You need to implement map once, and you use it ten times, but those 10 times by using it, the code is more concise and clean.
ah, yeah, true. sorry! well, this makes me like the pipeline much less suddenly.
Thanks. It's good to know.
&gt; I did say anyone who understands map/filter/reduce understands for loops [Citation needed]
&gt; Loops are good at performance, so wha Wrong again, why do you bother? function doubleAll(arr){ var result = []; for (var i = 0; i &lt; arr.length; ++i) result.push(arr[i] * 2); return result; } function squareAll(arr){ var result = []; for (var i = 0; i &lt; arr.length; ++i) result.push(arr[i] * arr[i]); return result; } squareAll(doubleAll(array)); Versus squareAll = map (x =&gt; x*x) doubleAll = map (x =&gt; x*2) squareAll(doubleAll(array)); Your gorgeous version using loops will allocate 2 new arrays and iterate twice, no matter how smart the compiler is. When you compile the `foldr` version, any decent compiler, even C (not functional) will inline both calls, which will cause an effect called fusion, which in turn causes it to only iterate through the array once. In other words, the functional one is compiled to the equivalent of: function squareDoubleAll(arr){ var result = []; for (var i = 0; i &lt; arr.length; ++i) result.push((arr[i] * 2) * (arr[i] * 2)); return result; } Try it in C and check the generated ASM. Even if you use a mutable version of the imperative `doubleAll` and `squareAll` (i.e., modifies the original array), you still iterate twice, VS one on the functional case. Accumulate additional transformations and you get code that is 2x, 3x, 4x and so on times slower than the simple functional solution. Why? Because you're at the wrong abstraction level, a for is way too powerful and can do pretty much anything, and thus the compiler has no guarantees at what you are doing and can't do its job properly. You claim that `foldr` is harder because you don't understand it, but you don't realize that you had a whole life to learn and understand for and you spent at most 30 minutes with `foldr`. 
[removed]
What if the API changes at some point? You'll have to also keep your integrations up to date even if it isn't that frequent compared to libraries. In some cases a library can be the better alternative if, for instance the API you're using is shut down. 
Great article for beginners to gain some intuition about the power of abstraction and expressiveness that come with higher-order functions. Thank you.
Why not generate a url in an input field and have a button that can copy it to the system clip-board? Also, next time youwrite the page, use a router and do #search/term1|term2|term3 with client ajax on page load. 
Are you really asking what the point of polyfills are?
Those specific cases are very valid. The API-level issues are unfortunate due to backward compatibility but the error issue has been improving as more things move toward throwing as a standard. The main flaws I find with the language are holdovers from previous versions.
beat me to it X-| imo, for loops are the best, but i'm not really sure there's a "wrong" answer. 
If the point of the authorwas "let's use a map more" he wouldn't implement map itself in this backwards manner. Also, JavaScript already has a map function.
This is javascript... shouldn't `foldr` just be called `reduceRight`?
Thanks! I purposefully try to keep it "light" and I try not to get into the weeds too much (Besides that would take too much of my time). Hopefully it can provide some exposure to what employers are expecting JS/FE devs to do every day.
But `Math.abs(-1) !== -1`... or am I missing something?
Absolutely. However, for your first project, I think it's very helpful to have a functioning template to work with. Or if you are organized and already have the entire thing brainstormed -- more power to ya! Many people do not, though.
Yes on standards. Stick to 1 framework. Growing organizations often run into the problem of not having competent leadership as people are promoted from within, but don't have the skills required to manage larger orgs. It's often easier and politically less troublesome (in the short term) to let individual teams do whatever they want. THIS ALWAYS ENDS BADLY. I've lived through it. Best case is you have siloed teams that can't work on each other's code. Worst case it takes forever to add the same feature across multiple frameworks, performance optimization is extremely difficult, and everything costs 4x too much. The autonomy/standardisation split is a very fine line and you need quality leadership with the respect and authority to get your teams to concensus. 
I've had the best luck with local firms where we can meet face-to-face.
I like Falcor a lot, but the project seems dead at this point.
Anyone know why this would get downvoted?
This is how we build our containers as well. Containers get mapStateToProps functions, binding to state in appropriate places, and sub-components are "dumb" and just get props passed in.
[removed]
? Wanting to pay for support is a very legitimate requirement and Aurelia fits that bill very very well. AFAIK Sencha is the only other game in town for paid support, but Aurelia is far closer in design to other popular frameworks.
I didn't change `(a,b) -&gt; x` to `a -&gt; b -&gt; x` because I thought it was OK, I changed `((a -&gt; b), [a]) -&gt; [b]` to `(a -&gt; b) -&gt; [a] -&gt; [b]` because it was an example, that is a more flexible solution and I was trying to show that. Please do research how type signatures work, I have no idea where you got `(a,b) -&gt; x` from or what that is supposed to mean, but notice that is the type of functions that receive a tuple, ignores it and returns always the same element of type `x`, so pretty useless. Yes currying is an absolutely basic concept and the reason some languages don't have it is that humans are just bad at programming in general.
You're trying to reinvent the wheel. Don't. Try [this](http://stackoverflow.com/questions/10585029/parse-a-html-string-with-js) instead.
What minifier and concatenation tool do you use?
[removed]
Thanks for this - had to drill down quite a bit since it's buried so deep, but the generator approach is an obvious choice. 
I second this. `for-of` allows you to break the loop, which might come in handy. 
&gt; Try it in C You do know that's not C syntax, right? Speaking of C, it doesn't really support currying AND it's a language where manual memory management, in-place mutations and pointers are idiomatic, so how exactly that foldr/cons snippet is supposed to be implemented and how it compiles to more efficient ASM than idiomatic C is beyond me. Are you talking about [this paper](http://asg.unige.ch/site/papers/Dami91a.pdf)? Maybe you missed it, but it says "we can estimate a curried function call to be approximately 60 times slower than a normal function call." Do you honestly think you could go over to comp.lang.c or whatever and say "hey guys, I found a more efficient way to do some types of loops using curried functions"? No offense, but that's the sort of thing that would make Linus Torvalds eat you alive. Besides, I don't care about some imaginary "sufficiently smart" compiler that doesn't exist. We're talking about js, running on browsers/node.js. And last I checked, loops are faster than higher order functions there. &gt; You claim that foldr is harder because you don't understand it Dude, stop assuming you're the only one who knows Haskell, and just accept that some people know it but don't like it/don't care for it/would rather use other languages. Pick any language that you can find on a job site. Can be python, ruby, go, I don't care. Go find any tutorial for it and tell me which comes first, loops or `fold`. Chances are, you'll have to find another one that actually mentions fold at all. `fold` isn't even that hard, but it *is* less known, which was my point.
It feels odd to see an article start saying "a loop is an imperative control structure thatâ€™s hard to reuse..", yet the words "declarative" or its relevant subset "functional" never turn up anywhere in the article. I mean sure, you can say a loop introduces complexity, but it's not really complicated -- it's just applicable to a paradigm which may not be the best fit for what you're trying to build. One of the biggest places we've seen a huge uptick in the utility of `Array#map`, `Array#reduce`, and `Array#filter` is in the most natural fit for declarative programming I can think of: templating. The #1 offender for sloppy legacy code I deal with is old imperative templates, usually in the form of long for loops that have a variety of `$.fn.append` calls putting long run-on HTML to various elements using jQuery. The declarative nature of functional programming really shines here, since thinking in those terms you can componentize your html-rendering code into a reusable format. This is a big part of what's driven the popularity of React, vue, etc., but you really don't need any third party libraries to start thinking declaratively about your templates. Simple html-rendering component function: const Item = ({ url = '/', img = '/blank.png', title = 'no title', price }) =&gt; ` &lt;a href="${url}" class="ListGroup__item"&gt; &lt;img src="${img}" /&gt; &lt;p&gt;${title}&lt;/p&gt; &lt;p&gt;$${price} USD&lt;/p&gt; &lt;/a&gt; `; Now we can simply map arrays of item data objects to render them as HTML, e.g. assuming we're on an old jQuery site and unravelling the clunky imperative loops, our old loop could become: $('.list-items').append(...[ { url: '/hat', img: 'beanie.png', title: 'Head-thingy for your head', price: 500 }, { url: '/gloves', img: 'mitts.png', title: 'Nice thing for your hands', price: 400 }, ].map(Item)); Where you really see this take off is when you can have filters and maps to give different representations of the same dataset, e.g. const expensiveItems = items.filter(({ price }) =&gt; (price &gt; 400)).map(Item); const lastViewedItems = items.slice(0, 3).map(ItemSummary); I think too often, tutorials take the form of chiding some bad behaviour, which isn't really very useful. There's an infinite number of things I shouldn't be doing, but just saying loops are bad because they're complex isn't really enough. If you're going to talk paradigms, you should compare them, and show that imperative isn't absolutely bad or more complex, but it's not always a good fit for what you're trying to do.
Are you importing/requiring B in some way or just counting on it being higher up in a bundle file? Chances are your bundling tool works based on dependencies, so you'll have to use some form of import or require (depending on the tool) 
Okay well this led me to the realizing that I hadn't considered using sprocket's require command to force files to be ordered in a particular way. Don't know if it's standard practice to use //= require in such a manner, but rewriting A.js to this works: //= require same_dir/B.js class A extends B { ... } Thanks!
Aye, the other guy's remark led me down a path ending in your answer. Is there a standard practice for requiring other javascript files? Right now I'm just using rail's 'sprockets' gem. But I wonder if there isn't a better way to say, initialize a javascript module manager client-side which then properly parses all the other javascript files in the logical order. This way, if I wanted to switch server-side code, I wouldn't have to go through replacing all the sprockets require commands with whatever the new server would expect. Thanks.
Webstorm 
they're basically monkey patches but JavaScript is currently under he misguided impression that they need 5 build tools to be a big boy language. i am guessing the rise of nodejs mad JS developers jealous of pther devs who took coffee breaks during compile time. anyway, they're either shims or monkey patxhes
Again, polyfills are a specific use of monkey patching. Monkey patching is changing the API of an object during runtime. Shim is a library that replaces or intercepts API calls in order to change them or mock them entirely. Polyfills is a shim that implement a standard API that is unsupported by the browser. I'm not making those definitions up. 
Not a text editor.
atom vim mode has the best of all worlds for me. the vim mode isn't complete, but the simple vim controls + atom plugins and features makes it a winner. i switched to atom after emacs, and before that, vim.
**this is a feature.** If you are a big company using a js framework in production, you are already spending money on developers. In case you hit you a roadblock, it would be better to consult core framework developers than letting your programmers experiment in production. If nothing else, the option of *throwing money to solve a problem quickly* is quite good from a business perspective.
Probably because your opinion doesn't carry a lot of weight there.
1. `for .. in` has a lot of caveats associated with it. For POJOs you're generally okay to use it, but as soon as you start using `new` or `Object.create` around it, you need that `hasOwnProperty` check as you've shown. This just seems messy and superfluous, and there's a lot of implementation-specific behaviour. I would say **avoid**. 2. The pattern you've shown here is obsolete now with `Object.entries`. `Object.values` is there for values-only. Use `keys` only if you actually just need the keys. 3. DO NOT DO THIS. Mutating builtin prototypes is always a risky move, and that risk increases the more common the prototype is, with `Object` being by far the most common. The only time a builtin prototype should be extended like this is if you're shimming in a function so old browsers can use it. While I can see that assigning an iterator function would be useful, it risks colliding with a new iterator later on if one is introduced, and may also be inherited unexpectedly leading to some very weird errors you'll have trouble debugging. `Object.entries` is normally my first thought, and generally I'll look for ways to `map`, `reduce`, `filter`, `sort`, and/or `find` from the returned `Array` before I dive right in to simply iterating with `forEach` or `for .. of`. Where appropriate, I'll also think about using a `Map` or `Set` instead of a plain `Object` (or similar collections, e.g. their immutable equivalents from immutable.js).
If you're gonna write your fetch polyfill using XMLHttpRequest, why not just do the thing with XMLHttpRequest anyway?
webstorm. I'm a sucker for breakpoint debugging in node.
Sublime, tried atom and wasn't impressed. I find sublime easy to use and love the built in shortcuts 
SPAM
VsCode. Sublime isn't free. Atom, like VsCode, is also based on Electron, but is slower and has less features. WebStorm isn't free and is not lightweight. VsCode is a full IDE, not just an editor, it really shouldn't be compared to Sublime/Atom. VsCode has so many nice features, is developed actively, and keeps improving.
[removed]
And why I hate it. I much prefer the Python ethos that while there might be more than one way to solve a problem, there's an obvious and preferred method. Anarchy is fun when you're 19, but as a professional dealing with a large codebase with generations of developers coming and going it gets real old, real quick.
You're right that this would make the app a little bit inefficient! But inefficiency can make app development easierâ€”so, until the inefficiency becomes noticeable, it's a good trade. It's important to remember that, as an app developer, you have exactly two performance goals: 1. The app should visually keep up with the device framerate. 2. The app should match the user's battery life expectations. So, if a redundant computation doesn't noticably affect framerate or battery life, then it doesn't matter. Mapping over a thousand-element array is usually actually very fast: 1000 is a small number of operations for a computer. For almost all apps, your users are guaranteed to not notice. That said, some apps *do* require a big slow computation to generate the view from the single source of truth, in which case it becomes appropriate to add some caching. `PureComponent` is lightweight and often sufficientâ€”but, if you need more control, then go ahead and write the lifecycle hooks for caching stuff in component state. It's just wise to avoid all that work until you *need* it.
https://media.giphy.com/media/3kIcyN7fUtlUA/giphy.gif
Object.keys().some() can do it too
Vim because i can a) do almost everythi,g with it, b) use it on a server with ssh, c) can have my configuration inside a git repo that I check out where ever I need to work, d) its fast and I love vim bindings
oh sorry. Yea, I'm constantly dehydrated, no matter how much water I drink. I kid you not, but I always have a gallon of water next to my chair. I'll see if there is a way to limit the sound.
Obvious doesn't mean always. What if his use case requires the data type be serializable? 
CSS polyfilling would be useful for the same reasons - you get to use new APIs and new syntax without having to worry about support from every single browser. For example, vertical centering has never been straightforward until flexbox came out. Isn't it compelling to write simple flexbox CSS rules and let a polyfill take care of compatibility?
You can't simulate random with a preprocessor. Random means that every DOM node that the rule applies to gets a unique random value. Recompiling on every request doesn't help - first of all, the stylesheet is only requested once on each page load, and second, you'd still have just one preselected random value applied to each DOM node that the rule applies to.
Tl;dr: Angular.js React.js Backbone.js Vue.js Ember.js 
vue.js is my favourite out of the lot. 
Why the downvotes?
When I need to parse HTML in my App Script projects, I tend to do look at [YQL](https://developer.yahoo.com/yql/) as a possible solution first, and then just parse the resultant JSON. Using xmlService.parse() to scrape web pages can be a bit of a ball ache.
For what it's worth, those "text editors" do *way* more than early IDEs. Nowadays, we pretty much go by looks alone. If it uses a classic Multiple Document Interface (MDI), we call it an IDE - even though you could just move all the panels out of the way an make it look really simple. Technically, if your "editor" supports things like run/debug, build automation, context-sensitive auto-complete, renaming, go to definition &amp; find uses, and Git (or whatever), it's an Integrated Development Environment (IDE). You can do anything you need without leaving this environment. Everything is integrated.
Just like Python 3 is preferred and everyone uses 2? Don't idealize Python. It's a nice script language with a bunch of issues, so is JavaScript, but the latter exists through multiple independent implementations, without an official one, and is the backbone of browser development. It doesn't have the right to be even as good as it already is. Yet it is.
Wow that website is awful. 
The only correct answer.
`some` is just a method on array, can be used for anything.
He's trying to summon cthulhu
&gt; fold isn't even that hard, but it is less known, which was my point. You gotta be kidding me, that is **my** point. It is not hard, it is just less known yet superior in every other aspect. Are you even reading what I'm saying?
Wow. This is quite poor... Seems like Angular is on the backfoot and looking to say its the same as React...
[removed]
I would not recommend this: `JSON.parse(JSON.stringify(obj), console.log)`
Who the hell is talking about iterables? `foldr/cons` implementations are not supposed to work with iterables and other badly abstracted garbage that comes with JavaScript. I am not talking about JavaScript. I'm not saying you should program like that in JavaScript. I'm not claiming `foldr` is superior in a language based around `for`, or for people used to use `for`. Why do you not get that? I don't use `foldr` on my JavaScript code. I don't even use `map`. I use `for` exclusively, because anything else is much slower **on JavaScript**, and I like my programs lightning fast and my clients happy. I am claiming, though, that, in a language built around functional concepts, `foldr` beats `for` in performance. I'm also claiming that, for people that spent some time to learn `foldr`, its use beats `for` in readability, code robustness and maintenance costs. &gt; yeah, your code doesn't work for those types Thanks for noticing. &gt; foldr/cons implementations of map that employ slice/concat are supposed Again it was an example, do not ever use a `foldr` like that, using `slice` and `concat`, that is stupidly slow and pointless. &gt; You have also yet to demonstrate how it's "more performant" Again? What part of it you do not understand? Multiple folds chained together can be compiled to a single tight loop. The same can't be applied to `for`. It is not about a sufficiently smart compiler, all you need is inlining and nothing else. Any fucking dumb compiler can inline. Do it by hand if you want. What else do you need? Citations, papers, examples? Chain a few dozen `map (* 2)` on Haskell, compile it, then benchmark against a few dozen `doubleAll` programmed with loops in C, JavaScript, whatever. At a point the Haskell version always becomes faster because of the fusion. The only way to get similar speeds to the Haskell version is by manually fusing your loops, like, programming a `doubleSquareFilterAll()` function which does it all, but then you lose modularity and gain code repetition. Maybe look for any paper on `foldr/build`, `unfoldr/destroy`, stream fusion, deforestation. Whatever. It is 20 years old knowledge, should be common sense by now.
I agree with this definition and upvoted. At the same time I still feel it's needless jargon. We don't need a new word to represent " a subset of shims that are specifically targeted to standards not yet implemented in the platform". If I had a library that added C++ 14 support to a C++ 98 compiler, I wouldn't call it a polyfill, because nobody in the C++ world would know what that means. I'm not a fan of the word 'transclude' either, but maybe it's because I'm old and grumpy, get of my lawn, etc. 
Agree with avoiding `for-in`, itâ€™s just not worth the trouble.
Serious question: do most programmers read books about it cover to cover, or just as a reference guide? It's rare that I see books mentioned at all on SO, and I can't help but think that online resources are usually more helpful by virtue of being quickly searchable.
You haven't heard of my fine line of artisinal, hand-crafted zip files?
Well, Angular has been here for more time and it's the framework that popularized frameworks (even tho it's not the same framework anymore), that's probably the reason. But it's not like there are few React Jobs, and I think React market is growing more with time. I'd say learning React and Redux is a better investment if you ask me.
Invest on Angular2 (just Angular) over ng1(Angularjs). As ng2's popularity rises, Google will start withdrawing from ng 1. Angular offers you everything you need from a modern framework:- 1. A CLI tool that helps you scaffold an app quickly and grow your app in a very efficient way with some cool build and testing tools. 2. Components to separate your app into different parts that achieve specific tasks 3. Typescript (TS)- superset of JS that is great for building big applications. 4. A Great Dependency Injection system that helps a lot in preventing code repetition. 5. Great performance.
I think this would be more useful if they bound their analysis to the last 18 months. Stackoverflow has been around for quite some time and interests change quite rapidly in the world of programming.
[removed]
Do you need to do hasOwnProperty checks on that or is it just the array of tuples that you want?
Emacs is a great operating system. At least you can run Vim in it.
Lol I remember this comment back when I was trying to create a good way to parse HTML, that person is a legend.
I'd modify #1 to: for (let key in myObj) { if (Object.prototype.hasOwnProperty.call(myObj, key)) { let val = myObj[key]; // do something with key and val } } So it will work with objects created by `Object.create(null)`
Suggestion: as these appear weekly (in my RSS feed), and new threads are basically empty -- give or take a few submissions -- could @AutoModerator also provide links to past "Showoff Saturday"s, when posting these? That way, we could easlily look at the submissions, over the previous week(s).
I made a react app that you can use to create your own "interactive fiction" game from a youtube video and share it with others. I had been splitting my time between that, other open source projects, and looking for a job (which should've been 100% my focus, lol) so I haven't created any adventure games for others to play yet. How to make your own is pretty self-explanatory but I'm still kinda working on a tutorial for others. Site: http://www.chooseyourtubeventure.site/ Github: https://github.com/vlmlee/choose-your-tubeventure
They do and have done for years. Caching `length` manually is less efficient.
[removed]
try ``` const gallery = require('./galleria'); ```
I think this does only involve their mobile site - their desktop site seems to be built with something else.
Hmmm...there is "__REACT_DEVTOOLS_GLOBAL_HOOK__" on the window but React devtools never loads. It just says "Looking for React..." Anybody, able to connect on the main site? Just curious why it doesn't work. 
No help. Or maybe i just don't know how to acces this.
&gt; Is there a sane way to use flow in a large application that (gasp) depends on third party npm deps? Yes. Use TypeScript :) In TypeScript static typing is strictly optional, and lots of NPM libraries comes with TypeScript type-definitions (which mostly are automatically imported) even though the libraries themselves may not have been written in TypeScript. Not only does this provide you with better type-safety without doing a single thing on your own, but it also helps your editor suggest useful (and correct!) auto-completions almost everywhere. All you do to have your valid JavaScript become valid TypeScript is change the extensions from .js to .ts. The compiler will infer types where possible and warn about errors, but it will by default always emit the resulting JS anyway. And from that base you can start gradually improving the type-safety of the codebase, almost without anyone noticing. It's win win. Seriously. TypeScript all the way. Give it a spin.
&gt; module.exports Oh no i try it tomorrow :) Also i found this: https://www.sitepoint.com/understanding-module-exports-exports-node-js/. Thanks i have googled around that alot. I think this is it but im not coding atm so i can't test. EDIT: Actually i tested it fast and i get Uncaught TypeError: navbar.changePos is not a function. BUt i will tinker around whit it.
We need more , so many more that people should start getting confused when they look at the syntax and try to guess the framework :D
They're all terrible, I'm just saying that we actually need a public conversation on what a solid approach is. Instead of optimizing for fancy one-lines and synthetic benchmarks, I'd like to see discussion on designing maintainable libraries for instance.
Angular died with angular 2. Its too intense for most front end development and seems to be targeted towards enterprise.
Like this: /** * Cause gallery runs over vex popups we need to configurate it */ var vex = require('vex-js') vex.registerPlugin(require('vex-dialog')) vex.defaultOptions.className = 'vex-theme-plain' /** * Gallerys logic */ exports.gallery = { galleryEl: document.getElementById("galleria"), addListeners: function() { var albums = gallery.galleryEl.querySelectorAll('.album'); for (var i = 0; i &lt; albums.length; i++) { albums[i].addEventListener('click', gallery.openAlbum); } }, openAlbum: function(id) {
"they are all terrible" seems a bit extreme... but fair enough, let's have the conversation
&gt; They're all terrible [Hmmmm sure](https://imgs.xkcd.com/comics/standards.png)
[Original Source](https://xkcd.com/927/) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4210 times, representing 2.8419% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_ddmi6bx)
Here's the entire game of life written with pure comonadic generation of states: https://github.com/puffnfresh/game-of-comonads.js
Thanks for bringing up the licensing issue. I didn't know about that, and it's something I might need to bring up at work. Separately, please post those sources on Angular 2 vs React job opportunities! I had a similar discussion with the experienced devs at work who feel that there's more job opportunities with React, but they could be wrong.
[removed]
Why do people keep saying that Angular 'takes over everything'? I have had NO problem using it at the component level in an otherwise PHP routed and rendered site. I don't feel like it forces any architectural constraints as people suggest.
jsdom &gt; cheerio
thanks man, good luck on your project.
Anybody who is using one of NG2 / React / Vue and not this is obviously a special kind of an idiot (an outdated idiot). I have some candidates lined up for interviews next week - if they're not intimate with the inner workings of StemJS and are not able to explain why it's the BEST framework ever and why other frameworks are WRONG.... well, no hire.
[removed]
Where are you linking the JS file? Make sure it is at the bottom of the document ( before the closing body tag ). If it's at the top, your script will be executed before the HTML element ( portfolio-1 ) is parsed. In addition, it is considered best practice to register event handlers using the the built-in addEventListener method. Assigning a function to the special onclick property restricts you to assigning one function for that particular event. Plus, you run the risk of overwriting previous event handler functions.
Well that makes too much sense now doesn't it. That was the fix I needed. Thank you!
don't use div. use `a`
radeon hd 6310, I think the drivers were automatically installed when I installed Elementary OS
Tell me why~~~ 
Stack traces for async sequences is pretty epic, I've never seen that before
I could not disagree more. Learning a pseudo-jQuery scripting language instead of using vanilla javascript is just too silly for me to bear. You can make the case that it *runs* faster (linearly, btw), but that's only a perk if you don't value *your own time* spent learning a new syntax, or if you never learned vanilla JS document functions. 
Yeh I have completed Practical Javascript! But what do you do after? I think I can split a program into steps, but to really understand what I need to code, is where it goes wrong
I will do that! Thankyou! But what to build for beginner JS devs?
I like the part about TypeScript being a first class citizen; with webpack, piping stuff through ts-loader seems like things get lost in translation, especially around optimizations. Does this support tree shaking?
I didn't know so many people hated Array.prototype.map
FreeCodeCamp is a great place to tackle projects. You have probably come across them in the past, but if you haven't, FCC is an amazing source to practice your project building skills. Some of FCC's projects include Tic-Tac-Toe, Weather Application, a Twitch app that interacts with the twitch API, a Simon Says game... there are many. You can also make a list of things that you like ie: movies, books, video games, fitness ... etc. Review the list and see what apis exist for them. Write an application that asynchronously retrieves JSON from the api. Then, display that data. 
Pull requests and code reviews will be welcomed with open arms :-)
Agreed. There's some classics in there for sure, but it would be awesome to have a slider to set the time range to see what's trending. Clever Amazon affiliate marketing tool though. Probably making some decent money.
Make sure they have at least 4 years of experience with StemJS, you need to make sure they know what they're doing. 
So much filler ungh
&gt;All of the code is written from scratch just because I've seen too much poor quality code even in industry standard Javascript libraries, and everything is designed from the start for interconnectivity. lol, that is how perfect code looks like: https://github.com/mciucu/stemjs/blob/master/src/ui/UIBase.es6.js And I guess, tests are also for idiots who doesn't know how to write bug free code like this :)
Ideally the store is never invalid and you catch every case during development. Unit tests catch the cases you know of. That should be the first line of defense. The second is just looking at the action before changing the state (if I have a setTime function, should check data is a valid timestamp). Protecting against invalid stores with this method is kind of a last resort, but I've found that bugs of this nature do occur in a large app.
W3 schools is pretty helpful. The tutorial is self guided and let's you play around with the code. it moves at a comfortable pace for beginners, check it out. http://www.w3schools.com/js/
imo, it proved it could be solved with DOM functions, lol. But I agree no libraries would be better, if there were an easy way to parse HTML in node natively, I'd suggest that (but i'm unaware).
Obviously it's possible there's something wrong with my code, but you actually have to say what it is. I'm actively trying to get good or bad feedback, that's what I actually want at this point.
In addition to moving your JavaScript to the bottom of the body, you might want to guarantee the DOM is rendered before running your code by doing something like the following: document.addEventListener('DOMContentLoaded', function() { var div = document.getElementById('portfolio-1'); div.addEventListener('click', function() { alert('alert'); }); });
I may have been too dismissive in that blog post, but if given a chance I would actually have a detailed list of issues, and not just beat around the bush. In essence, I want to say that extending the native DOM nodes through composition is more robust and maintainable for developing a complex codebase than using a virtual DOM. I said I've reached this conclusion (among other reasons) because this allows the developer to choose for each component how much behavior he want from the base library and how much he want to handle himself.
&gt; If you change an attribute on a DOM node for instance, it's a call to a C++ function where the browser can optimize if nothing changes. There's vastly more to it than that. Accessing any of an elements `el.client*`, `el.offset*` `el.scroll*` causes a reflow. And that's just accessing *properties*, there are a number of DOM methods that cause reflows as well. Reflows require a recalculation of an elements position and dimension. A Reflow on a DOM element causes a reflow on its ancestors, children and all siblings that appear after it. This is ENORMOUSLY expensive. &gt; Browsers are getting better and better and can optimize and batch redraws and DOM changes by themselves. SUV's are getting better and better gas mileage, but that doesn't mean we should *only* drive SUV's. You can't "batch" a Reflow since it's literally a calculation on the elements dimensions and position. &gt; I don't see a reason why we shouldn't try to work directly with the browser, offloading to native code what we'd have to do in Javascript That's because you don't have a clear understanding of how Reflows/Repaints work or why they are expensive operations. If you did understand that, you'd know that avoiding reflows at the expense of additional space is a HUGE benefit. But feel free to post a benchmark of your framework, so you can get an idea of just how bad it's going to perform relative to literally everything else. Ember, React and Angular 2 are *all* using diffing algorithms to avoid DOM calls (in different ways). Pretty smart people on those projects, you honestly think they are ALL wrong?
Can you show any real use case that you can't solve efficiently with "Virtual DOM"?
glad to hear you liked it!
If the new value of a property is the same as the last one, I'd expect browsers to detect that and not trigger a redraw. And if it's different, then any vdom has to also change it himself and trigger that reflow, which by itself is the more expensive operation. Your SUV analogy is not really appropriate. Browsers are more like the automatic vs manual gearbox in this case: Using a manual got people better mileage when automatics were still developing. Now they're getting better and better though. And honestly, unless performance is &gt;5x worse, I don't think it really matters, since it wouldn't even be felt unless you have &gt;10000 elements, and you could manually optimize your components in that special case. Code maintainability and flexibility I think are way more important than synthetic benchmark results.
This sounds really interesting. I've been dreaming of being able to run sandboxed code from different languages in the browser.
morphdom [1] tried to ride the "you dont need no stinkin expensive vdom, the DOM is fast enough" tagline until it got decimated by vdom libs. not all vdom libs have crappy APIs, and these "synthetic benchmark results" translate into very real results. you need to stop arguing with multiple authors of provably fast vdom libs and start putting benchmarks [2] where your mouth is. if you think we don't understand the tradeoffs and performance profiles *extremely well*, you're in for a rude awakening; we're not all just a bunch of delusional idiots. [1] https://github.com/patrick-steele-idem/morphdom [2] https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html
[removed]
Assuming you mean something like ``` function timeout(time) { return new Promise((resolve, reject) =&gt; { setTimeout(resolve, time) } } ``` then you can shrink it to something like: ``` const timeout = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time)) ``` I also wrote a couple simple `sweet.js` macros for making it syntactically simpler: https://www.reddit.com/r/sweetjs/comments/59s5uq/promisify_callbacks_inline/
Different frameworks optimize different things. I'm the author of a commercial framework called Cx and my ultimate goal was to make view code as simple as possible. The framework does a lot of magic tricks behind the scene, but the views you write are simple and understandable. https://cxjs.io/examples 
Async functions exist in ES7. Here are some examples that are equivelent but require less code. const MyFunction = async () =&gt; 'Hello World'; or async function MyFunction() { return 'Hello World'; } 
I am getting more and more disappointed by the disconnect between node, babel, the standard, common sense, and developer friendliness. I am *very* happy with how commonjs worked, what was great for node development has seemingly gone out the window. All I ever wanted was sugar around require, and somehow we get this.
 async function MyFunction () { return "Hello World" } ?
Very cool, I'll give React Lite a go. Thanks.
I think /u/odisant's point was that if a user genuinely had the username 'random' they would be given a different avatar each time this service was queried. A solution could be that requesting the rootpath gives you a random avatar, and requesting a path gives you the avatar for that username.
&gt; Yeah of course, because we're taking idiomatic haskell and translating tit for tat to js/c/whatever. No, I'm not. I'm talking about idiomatic Haskell vs **idiomatic C**. Check this out: [Idiomatic C.](https://paste.ofcode.org/yQpSpnHSitME9ucif6DeFf) [Idiomatic Haskell.](https://paste.ofcode.org/agyCJb5bUk9hKULLzBRSwK) Both codes are basically equivalent, and dead simple. They both build an array of 100 billion ints and call, 64 times, an `add1` function that increments each element by 1, and then print the sum. The Haskell version is pure, i.e., the `add1` uses `foldr` and returns a **new array**. To make things honestly idiomatic, the C version is impure: it mutates the array in-place with a pointer and a `for` loop. To be completely fair, the C version would need to return a brand new array, as that is what Haskell does, but I'm not even doing that. So, after it all, what is the result? The Haskell code runs in 1 second, and the C code runs in 8. That is almost an order of magnitude faster. The only way for C to beat Haskell is to write a specialized `add64` function which does it in a single loop - and, yes, on this case, it is faster. But then you lose modularity. So, yes, as long as you care about modularity (i.e., absolutely essential in any real world programming, and you know it) `foldr` is faster than `for` in general. &gt; Regardless, the unfortunate thing is that there's really not that much room for GHC-style optimizations in typical js apps (assuming you're writing reasonable code) :( Yes, there are. That again is the point. If you used the `foldr` I posted above, and someone wrote a JS compiler that will inline it well enough (again, not "sufficiently smart", it wouldn't be even that hard), you get **the exact same performance gains**. You'd be able to write modular code that is dead fast. And if you allowed yourself a curried style (i.e, `f = x =&gt; y =&gt; x ...`) you can write pure code that looks very similar to the Haskell, and also get the readability, maintainability and safety gains. The only reason nobody is doing it yet is because there is this unspoken consensus, which you're part of, that `for`s are more readable and faster than `foldr`. I just hope you'll get out of this conversation being aware this is a fallacy. &gt; But we need to acknowledge that it's also possible to ruin performance with a subtle issue precisely because of the aggressive nature of GHC. Because GHC is a mess. It is too experimental, deals with very complex Haskell features and thus does some things much worse than a language designed from scratch could. Now, if we just invested the same amount of effort we did for JavaScript's V8 for a proper pure functional language...
&gt; Things are usually IO bound, and the perf things that aren't, require memory/op-count aware algorithms (looking at you, virtual dom...) That is exactly what I was going to cite. Things like virtual dom rendering would absolutely benefit from folds, because you could create the dom and diff in a single pass. Moreover, how often do you see `todoList.map(concatTime).filter(...).sort()` and the like? This functional style is already common nowadays and is needlessly slow. I avoid it at all costs when writing React code, but that makes my code considerably less maintainable because, again, `for` loops are terribly less readable than functional compositions when they're not trivial. And this is just the best example, but there are many other situations that are CPU/memory bound if you think about it. Not everything is IO bound.