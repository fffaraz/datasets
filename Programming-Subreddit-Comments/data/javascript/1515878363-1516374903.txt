That logic is usually good and makes sense, until you actually do `foo = undefined`. Great, now we're defined it to be undefined.
When you google I use `javascript -jquery` if I'm getting too many jquery answers. Javascript can do ANYTHING that jquery can so there is no reason to believe a JS only answer doesn't exist.
Cool, glad it might help you out. Like I say I‚Äôm not an expert, but Vue has one of the nicest communities I‚Äôve encountered in the front-end galaxy. I‚Äôm sure you‚Äôd find help for specifics over at /r/vuejs 
OP, I know you already solved this but I am curious to know what you were trying to do.
The way a lot of modern libraries do this in a portable (i.e. old-es) way is by inspecting the result of `Object.prototype.toString.call(thing)` and using a regex to figure out what the value returned is. From node 8 repl: Object.prototype.toString.call(null) // '[object Null]' Object.prototype.toString.call([]) // '[object Array]' Object.prototype.toString.call({}) // '[object Object]' Object.prototype.toString.call(void 0) // '[object Undefined]' Object.prototype.toString.call("") // '[object String]' Object.prototype.toString.call(0) // '[object Number]' Object.prototype.toString.call(class {}) // '[object Function]' Object.prototype.toString.call(() =&gt; {}) // '[object Function]' I'd be so happy if a new function like typeof was added that just returned the class.
Not sure. I just googled it. Ive not used the apis for js. Only in objective c 
Looks like a typical intro CS algorithm. One of those "write a program to print the following" ones.
I edited Switchem library and integrate it in Rambdax as `switcher` method - https://selfrefactor.github.io/rambdax/#/?id=switcher It helps with readability in long `switch` statements.
Thanks, I saw this project on Scala Center but didn't know that it was ready for use. 
Conversely there are many JS developers who hope to never write code and simply hope a combination of open source libraries will do this for them so that they can focus on important things like configuration, implementation details, and copy/paste. https://en.wikipedia.org/wiki/Invented_here
&gt; What to learn next? Go write an ambitious application from scratch. What you will need to learn will be self-evident.
I love this comment. The perfect eureka.
It's not strange to see all those Vue stars, considering how many Chinese people are out there.
I'd rather see community working on improving existing libraries. Just like Java crowd is doing. No one needs yet another clone of RxJS, but fixing bugs and improving it will benefit everyone.
I was jumping around the room when i finally figured it out
What is NLP, my bro?
It's a convention, not a hardset rule of the language, and per that convention you're not allowed to set anything equal to undefined. So while you *can* do it, if you're abiding by the convention, you shouldn't. We use this at work in another ECMAScript language. `x = undefined` is banned. It makes debugging so much easier. Unexpected null? ok, we messed up the logic somewhere. Undefined? We forgot to set it. It also prevents scenarios where you meant to delete an element but set it to undefined instead, which can break key iterators and anything using hasOwnProperty to check for existence. Luckily all of the libraries we use follow this convention too; that's probably the biggest hurdle to sticking to this.
Natural Language Processing.
Don't forget "not defined", which isn't the same as undefined. I really like javascript, but I can sort of understand the haters. 
https://developer.mozilla.org/en-US/docs/Web/API/File
Everything you say is truthy. Nonetheless, isn't it a curious thing that `document.all` is falsy? It's an object with properties you can access, but if you just test for its existence with an `if( document.all ) {...}`, it pretends it's not there. Why would browsers do such an odd thing? As usual, it was for backward compatibility with very old JavaScript code, as [this Stack Overflow answer](https://stackoverflow.com/a/10394873/1202830) explains.
Better off to use `null` - null is a type but undefined is an identifier. If you check against undefined, the engine needs to check scopes for instances of the identifier undefined. It's not possible to override the global `undefined` object any more under es5 - but because it an identifier, the check must still take place.
I gut your point, but I disagree. The JS community is certainly contributing PRs to existing major libraries (like RxJS), but that doesn't mean there isn't room for smaller players. Popular libraries like RxJS and React are great, but at the end of the day they are open source products from giant companies like Microsoft and Facebook. That's not everyone's cup of tea. The JS community shouldn't just stand around waiting for big companies to open source their internal projects so we can contribute something. Smaller players can drive innovation, too. RxJS is huge, I wanted something leaner so I wrote Bulb. Simple.
Please tell me what it is, I cannot figure it out üòÜ
Yup, upside-down gummi bears.
I wrote an industrial-era econ sim game in JS+WebGL. This was my first project ever done in JavaScript, while writing it I learned to use Webpack to bundle my scripts, CSS, and shaders, Babel to compile them, NPM for dependencies, Jest for testing, and React for the user interface. Some observations: * Deployment is a breeze (just push to GitHub). * Testing is super easy to set up and use. * React is way better than any game engine UI framework I've used. * I'm really enjoying the modern JS tooling. Up next I'd like to add Redux for state management. [Here's a link to the game.](https://idleprovinces.northronics.com)
Promises are a pattern. But honestly, the most important one I learned was functional programming. Learn it as far as is applicable in JS, it will help you out a great deal.
Did you already figure it out? I see the issue but I don't wanna write it for nothing 
Sounds like a cool idea. If you want to figure out where to start, you should write down what you want it to do. Write up what happens when a user visits the site. What they first see. What they can do. Then you‚Äôve got a list of features and a better idea of where to start, not to mention a start on a more specific list of questions to ask on reddit ;)
I would agree if RxJS was the only option, but as your own article states, there are plenty of them already. And this is a very big issue in JS world - too many libraries doing the same stuff and then you end up with node_modules with the weight of a super sized black hole, because each of your dependencies decided to use different implementations of underscore, rx, etc. That needs to be stopped.
They should just build diffing into the browser
MDN's [canvas tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial) might be a good starting place.
&gt; A company does pre-screening for hereditary disorders, but is unethical because they support physicians who's hospital or practice restricts their machines to IE8? If you‚Äôre enabling said hospitals to access very sensitive personal information on machines with internet access and IE8 on them, then yes, that is highly unethical. With an unsupported browser, these machines could easily be compromised, and said information stolen.
Thanks in advance for helping!!
thats a bug. it would break half the web if they fixed it.
Yeah i have a pretty short list so far of stuff. But that helps me a lot! Thank you!.
Use `indexOf` to find duplicates https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
https://colintoh.com/blog/5-array-methods-that-you-should-use-today
use that in a conditional. eg if (array.indexOf(element) &lt; 0) array.push(element)
Ohhh. Sick thanks man :)
More importantly, are you overwriting the node variable "module"? Don't do that.
I think it's always valid to try and write your own for a while, get your head around the potential of some approaches, etc. When it comes down to it, always feel free to use frameworks that suit you, or your project. Never reinvent the wheel unless it's still made of spokes and rotting wood. If you do, you'll find you dedicating lots of time to writing clever structures (that someone's already gone to the trouble of doing) rather than progressing towards the project's main goal. There will always probably be something (open sourced or not) that will meet a requirement, but suitability is on a scale from conflicting implementation to customisability in your experience. Take care when selecting, play around with various options, and focus more on what you want to make, not how you're going to lay the groundwork. People have been there and done that.
I've recently put quite a bit of work into a simple website generator that takes markdown files and renders them on specific routes, and it all happens in the browser! It still needs some more work to become more perfomant, but I would appreciate any feedback (or PRs)! https://github.com/johnsylvain/pagine
It's great that the author is new to this topic and so has to break down the stuff very much to understand it - with the neat byproduct to write it down for us in a very simple sense which most articles don't cover. I will follow this excited!
This comment is unhelpful, but I just wanted to point out the humor in you actually spelling out what OLOO stands for, and then misspelling it twice.
`object-path-resolve` is a &lt;200b package for resolving object paths using either dot or bracket notation. https://github.com/johnsylvain/object-path-resolve
I'd change your component names (`Header`, `Footer`) to not collide with native element names. The vue style guide recommends prefixing all components: https://vuejs.org/v2/style-guide/#Base-component-names-strongly-recommended Multi-use components with `App` (or the like) Single-use components with `The` Eg. ``` &lt;AppTodoItem /&gt; &lt;TheTodoList /&gt; &lt;TheFooter /&gt; ```
I am having great difficulty in trying to simplify my JavaScript AI at **[http://ai.neocities.org/MsIeAi.html](http://ai.neocities.org/MsIeAi.html)** 
Add vanilla to the end of your queries https://www.google.com/search?q=add+li+to+element+list+vanilla
Yes. `const module = ...`
whoops, lol didn't notice that. This isn't actual code. I just wrote up an example.
You should know that it‚Äôs hard (impossible?) to read the sample code on the blog post on mobile ‚Äî I can‚Äôt scroll the code and it is still not large enough in landscape orientation. I‚Äôll take a look on desktop later, tough. Just wanted to give you a heads up. Im using an iPhone 7+ 
Ideally you won‚Äôt need to call subscribe. Have you used `react-redux`? There you pass the store to a component that handles that for you.
Thanks, mate.
If you‚Äôre more visual, try drawing out what the app should like. That helps too. 
You shouldn't be calling `store.subscribe` yourself. See [a comment I wrote on why you should be using the React-Redux `connect` function to handle that](https://www.reddit.com/r/javascript/comments/6hperk/i_use_react_and_redux_but_never_reactredux_what/dj0fywb/).
Post your code.
I see. What's the best practice for passing down the store to a nested connected component? I've been using this method but I'm not sure it's best: class ConnectedComponent extends Component { render() { return &lt;NestedComponent connect={this.props} /&gt; } }
Again, you don't. You use the React-Redux `&lt;Provider&gt;` component, which uses React's "context" feature internally to make it accessible to any connected component automatically.
No always start with Vanilla, then move to React
I have no idea how Visual Studio works, in most IDE's or text editors the html would look like this &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class ="allTheHTMLElementsOnThePage"&gt;&lt;/div&gt; &lt;script src = "filepathToApp.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
This article explains what they are, but doesn't really explain when to use one or the other.
If you use it in every file, importing it in every file makes sense to me. You're going to spend most of your time writing the tests anyway, the time it takes to write an import is really minimal in the end.
Cool, thanks for letting me know. I'll fix it up.
Novice here, currently working on starter projects for both React and Vue. At this point, for a small add-on to an existing project, I would strongly prefer Vue. My problem with React is that it's never *just* React. Of course you need ReactDOM, and since you're writing JSX, you need Babel. And Babel isn't just one package anymore; it's five or six different modules that you may or may not need. But wait! You can skip all that by just installing Create-React-App. All you have to do then is *configure Webpack....* (expletives deleted) ...So anyway, if you're the kind of guy who doesn't mind building a $5000 gaming computer to play Minesweeper on, then sure, use React. *Or* you can link to one Vue CDN, write a couple of .js files, link those to your page, and get on with your life. It's probably a bit more complicated if you're using professional practices, but for a small-scale "hobby" sort of project, I find Vue sooooooo much easier to use. I'm interested to see what more experienced developers would say.
Really well written article.
&gt; All I really plan to do with React is to make my tables searchable, filterable and interactive on the client. It sounds like you're just talking about [DataTables](https://datatables.net/).
Ok here‚Äôs one of mine in vanilla JS https://github.com/TravisL12/apod_chrome_extension
Cool idea for bringing tab switching behavior from FF into chrome. Will definitely be trying this out
They did one of these (rendering 3,d on 2d) at a talk so I'm glad this is being done.
&gt;You can skip all that by just installing Create-React-App. All you have to do then is configure Webpack.... What? If you used the cli and then had to configure webpack you did it wrong.
Sure, it's fine. The answer is whatever you feel most comfortable with. If it's React or jQuery, or whatever, as long as render times are acceptable.
What do you mean?
I've never used visual studio and was thinking it might be similar to something like visual basic or bluej for JAVA or Dreamweaver for html/css where linking to a file would be very different than the process I described or it might be more similar to .NET where you would import the file . The code editor might not affect behavior, but it could change the process of linking files . 
Managing a large application with redux stores can be confusing and complicated. This article shows how it can be simplified using redux-box (https://github.com/anish000kumar/redux-box).
^ I agree. Just adding on: Notice how when you initialize a variable, it is always automatically set to undefined at first? It's because it literally does not have a definition. Things that are null do have a definition. They are defined as void.
&gt; At first glance, null and undefined may seem the same Indeed I even read both words the same way. ^/s
Thanks for the advice. I don't always respect naming guidelines but I will look into it
&gt; I've heard that React might be too overkill for simple scenarios like this Why would it? Either use something ready-made https://ant.design/components/table/ (searcheable paginated tables) https://ant.design/components/auto-complete/ (auto-complete) http://jedwatson.github.io/react-select/ (tagged select) Or just hook an input to a filtered list.
I think that people are right and that you should use Vue. It has been made with this use case in mind and is not less powerful than React. Go ahead and have a treat! Vue is a joy to use.
It's the difference between saying "nothing" and saying nothing.
Do you need any contributors, have any issues, or help in expanding or maintaining?
They are asking about a roadmap, future development, open issues or tasks you have in mind. They are interested in helping development if the library needs more functionalities.
Never noticed ff did that
We have widget system based on react. Sometimes it is just input with button and API call, sometimes something more complex like whole live sidebar. We have loader which looks for placeholders on page and loads widget we need.
Here's the beginnings of my [personal site](http://filleduchaos.me). Currently revamping the filesystem/working on adding more commands [Github](https://github.com/filleduchaos/personal_site)
Opera has Ctrl+Tab switching in most recently order option as well, and it is turned on by default even. I found this a bit confusing without a visual displacement of tabs, and implemented such behavior as an extension.
I'd be slightly concerned about the cost of the javascript you'd shift just for that small feature. I'd consider looking into https://github.com/developit/preact (same API, much much lighter) for such a use case.
I'm a bit confused why you need the API wrappers, since Firefox supports the callback based API on the `chrome` namespace as well: https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Chrome_incompatibilities
I saw meth meth method doing this as well
TLDR anyone? From the looks of it, the article mostly just lists why not to do something, couldn't find solutions for the problem though. Or I got bored of the no-don't-whatevers that I didn't read to the end properly.
Straight because of ‚ÄúChrome incompatibilities‚Äù title: there are some things (in my case, mostly with `chrome.tabs` Promises) which work in a different way. I did a couple of tests on this and decided to go that way, by explicitly defining API wrappers for each browser. In addition, it seemed to me like the world want to move towards `browser.*` API for extensions, which means one day Firefox may drop ‚Äúchrome‚Äù compatibility. Anyway, you may decide to use different behavior for different browsers, and this pattern works well.
Can you post your code so we can see what‚Äôs going on? If you are using a RegEx to replace the characters be sure to use the global flag. It could be that you are only replacing the first instance of each of the characters. 
ok I understand the connect thing now, but what about changing urls dynamicly based on store/state changes? the urls aren't components so they dont have props that you can put the store/state into and let it do the changing. Do you need to use subscribe and window.location for that?
`method(...[x,,,y,])` might work
What do you mean with that? JSON does not treat `undefined` and `null` the same. &gt; let t = JSON.parse('{"test": null}') &lt; undefined &gt; t.test &lt; null &gt; JSON.stringify(t) &lt; "{"test":null}"
If you need to sanitize input you can also try the pattern attribute on text inputs, be sure to duplicate the same regex for any server-side sanitisation too. https://stackoverflow.com/questions/19619428/html5-form-validation-pattern-alphanumeric-with-spaces
I meant `{foo: undefined}` and `{}`.
As a CMS developer, I come across this situation all the time... Sometimes bigger more complex widgets, sometimes smaller ones like you're describing. Always use a frontend framework... They're just a joy to work with and make development quicker, easier, better. I personally enjoy VueJS very much, but the notion that Vue is for smaller tiny things inside a normal application and React isn't is wrong... They can both do this - AND they can both do a full SPA... VueJS &amp; React are both so great! Good luck 
Jest itself doesn't work that way, and some of the other libraries we looked at don't do that either. It's not about time, it's about unnecessarily rewriting code. [jest-context](https://www.npmjs.com/package/jest-context) for example has something that you include in `setupFiles` that automatically includes it. (Which is the point of setupFiles as far as I can ascertain)
Start by reading [some the stuff that can be found here](https://www.google.com/search?q=javascript+dungeon+generator)
Let test = fetch("/wherever") test.then(result =&gt; doStuff(result)) --- Fetch returns a promise. Promises have methods .then and .catch. .then takes an argument that is the asynchronous result of your fetch
No, you do not require a new promise when using fetch as fetch _is_ a promise by itself. In your console, this would work &gt; fetch("https://www.reddit.com/r/javascript/comments/7qbdal/very_confused_about_promises_with_fetch/").then(console.log).catch(err =&gt; console.log(err)) If you wanted custom logic to reject/resolve then using a new promise could be useful - perhaps you were fetching a resource and wanted to check what was returned and reject/resolve based on that (for example, authenticated user). Take this example var pro = new Promise((resolve, reject) =&gt; { fetch("https://www.reddit.com/r/javascript/comments/7qbdal/very_confused_about_promises_with_fetch/").then(res =&gt; { if(res.status == 200) {resolve("YAY");} else { reject("BOO!");} }); }); console.log(pro); If you make the URL 404, it will return "BOO" instead. 
It's great that there are people who discuss things like this, but personally, from practical viewpoint, I don't give a single damn how imports are going to work in browser at all, because I'm absolutely sure I will use build tools and bundlers forever, because I'm not going to link the dependencies manually one by one, because it's totally impractical both for network and development performance.
As I understand it: 1. New promise is for converting a callback to a promise. 2. Storing it in a variable or using it as it is doesn't make much difference, it's the same as with any data where you use it straight away or store it in a variable for later. 3. Within the new promise callback, call resolve with the data that should be passed to .then , reject gets the data that should be passed to .catch Hope this helps, if you have any more questions I would be happy to answer them.
Pardon my english. 1. If you want to create promise, you use `new Promise()`, that's it. Since most async tasks are ajax related, and like you said, the `fetch` api already returns a promise, you often don't need to explicitly call the `Promise` constructor. Still, there are many async apis which are not primise-based, and if you want to use them in a promise style, then you need the `Promise` constructor. For example: ``` function toBlob(canvas) { return new Promise(resolve) { canvas.toBlob(resolve) } } ``` 2. If you put it into a variable, the promise is created immediately. If you return it in a function, the promise is only created after the function is being called. 3. When you get the value you want, you call `resolve` with the value. When you get an error, you call `reject` with the error.
I've got a question regarding resolving promises: fetch(exampleURL) // return a promise .then(res =&gt; res.json()) // still a promise .then(data =&gt; data.test) // resolved Why does the promise not resolve until the second .then()? If I console.log(res.json()) it logs a promise, and I'm confused why I need two .then() to resolve the promise :P
The promise return by `fetch` is already resolved then you get `res` in the first `.then()`. The method `.json()`, like `fetch`, also returns a promise. Actually, every `.then()` also returns a Promise, with the value being returned. So you can keep `.then()` after `.then()`. It is a bit confused when you just start learning Promise.
what is http/2 :S
Ah, I did not know that .json() returned a promise! Then it makes sense, thank you for explaining it to me :) 
That‚Äôs one hell of a run-on sentence you‚Äôve composed there. 
Aw, thanks, I was too lazy until now to read [about it](https://stackoverflow.com/questions/30861591/why-bundle-optimizations-are-no-longer-a-concern-in-http-2#30864259).
The only use case for `new Promise()` is to convert a callback based asynchronous function to a promise (e.g. like OP's `setTimeout` example). Fetch never needs a to be wrapped in a Promise constructor. const fetchPromise = fetch("https://example.com/foo.json") .then(res =&gt; { if(res.status !== 200) { throw new Error('not found'); } return res.json(); }); console.log(fetchPromise); // logs a pending promise 
Cheers for the feedback, the rest of our team at quirk use async await and i chose after considering that option to use promises, assumed Hut might be necessary, makes sense that it isn't. Regarding the for loop, I remember reading that the type of looping i used is the safest way to iterate over an array or object in js?
Thanks for the response, but I need a count*down* timer where the user can input minutes and seconds.
The .mjs has been shot down it seems. The latest proposal is pretty nice actually: https://gist.github.com/ceejbot/b49f8789b2ab6b09548ccb72813a1054
Gyroscopes don't measure movement per se, they measure the force on a little ball in the phone. The API can handle removing gravity from the forces for you, giving you acceleration data, but then it's up to you to integrate it over time to track the total movement. Implementations have a ~70hz limit, but will give instantaneous acceleration data. 
The answer was this: In `jest.conf.js` the Vue default is this: setupFiles: ['&lt;rootDir&gt;/test/unit/setup'], You can add functions to the global via node's `global`: // test/unit/setup.js import given from 'given2' global.given = given ESLint might complain, to fix that, add node to the globals: // add to .eslintrc "globals": { "node": true } Voil√†!
Let's say you have some classic asynchronous function, which requires callback (aka function that get called when some action is complete or fails). Let's call that function fetch. When you want it to, well, fetch, you call it, providing callback: fetch((err, result)=&gt;{ if (err) { //handle error } else { //do whatever you need result for } }); Now if someone took a time to rewrite that function using promises, he will name it something like fetchAsPromised, which you call like this: fetchAsPromised() .then((result)=&gt;{ //do whatever you need result for }) .catch((err)=&gt;{ //handle error }); You might agree or disagree latter code is better than the former but important part here is, it does the same thing. But to use promises like that you, again, need someone to provide you with *promisified* version of fetch. Here's the problem: sometimes you have some older (often third-party) code, which you do not want to rewrite, especially if you download it from npm or something. It uses callbacks, but you don't want to use callbacks, you want to do the same thing but with promises. This is what new Promise constructor is made for. It allows you to create new promise, which you can use just like any other promise. To do that, you need to tell the constructor 3 important things: 1. What to do. 2. When to consider that action successful. 3. When to consider it failed. All 3 points are done via providing a function, that accepts 2 arguments: resolve and reject. Inside the function itself you do whatever you want to do inside promise, calling either resolve when promise should be resolved or reject when it should be rejected. For example, let's see how to turn fetch into fetchAsPromised: const fetchAsPromised = ()=&gt; new Promise ((resolve, reject)=&gt;{ fetch((err, result)=&gt;{ if (err) { //instead of handling error here, we reject the promise, which means the .catch callback will be executed with argument we provide reject(err); } else { //we don't do anything with result, but we resolve out promise here, which means .then callback will be executed with argument we resolve the promise with resolve(result); } }); }) //now we can use fetchAsPromised fetchAsPromised() .then((result)=&gt;{ //do whatever you need result for //this is same result we passed into resolve inside the promise constructor callback }) .catch((err)=&gt;{ //handle error //this is same error we passed into reject inside the promise constructor callback }); I really hope that clarifies it a bit. If you have additional questions or don't understand something, feel free to ask.
You could use either [JS vanilla timestamps](https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Date) or [moment.js](https://momentjs.com) to do time based calculations.
The guy forgot to mention that http/2 multiplexing will not make the smallest dent compared to the payload gains treeshaking, commonchunking and full-bundle compression make. If http/2 is more prevalent in the future, bundlers will simply output individual, tree-shaken, modules ready for multiplex consumption. But i think you're spot on, bundlers won't go.
&gt; Using modules directly is great when you just want to prototype something quickly. Either write JS or let TSC just output modules. Done. No need to setup anything. Just spin up a server and off you go. If you don't have access to npm/yarn, then you're probably right, but otherwise it's much faster to use some starter boilerplate which sets everything up, including babel, bundler and server. For example, when I want to play around with some js library, even if I don't need `react` I do this: create-react-app playground cd playground yarn add some-library yarn start Then I open `App.js` and add my test code to the top, and check the console output on automatically reloading page. &gt; development performance &gt; Seems perfectly fine to me. If npm and yarn will in future be adjusted to automatically add dependencies as well as your application files to `index.html`, then it's fine I guess.
And from what I've heard all the rage of Node 10 is to get native modules included, _and_ it's going to be the next LTS release. It seems this late in the game that is very unlikely to happen. I guess in 3 years we may have it figured out. We've only been working on this since [2012](http://blog.izs.me/post/25906678790/on-es-6-modules). Jesus.
Thank you so much
Oh, sure. And not just react, but other SPA frameworks. https://medium.com/qbits/django-unchained-how-quorum-converted-its-django-site-into-a-single-page-application-3fd4cd513bc7 describes how the process from a legacy server side rendered app to a SPA in a deliberate series of refactoring steps. &gt;What we needed was the ability to take the ‚Äúlegacy‚Äù pages that relied on Django templates and jQuery and anchor them, unchanged, within a React Router that could seamlessly transition between them and our new features. &gt;We could then set up React Router to render this component whenever it encountered a url for one of the legacy features. This freed us to write all of our new features using React and transition between them using router links.
Pretty tired of this false equivalency. You can't compare multiplexing alone to _all_ the optimizations people use with HTTP/1.1. As if people who use h2 don't know what tree shaking is. The point is that the _bundle_ itself would be obsolete (and bundlers would likely have some other name). If you're outputting individual modules, you still need to worry about how browsers will resolve those modules.
Maybe a misunderstanding but yes, this is what i meant. *Right now*, given that there are no tools to do this, raw http/2 modules wouldn't compete. In the future the bundler will output optimized http/2 friendly modules. 
Interesting stuff thanks. 
Pretty sure OP posted both. 
 @connect(state =&gt; ({ type: state.filter.type, color: state.filter.color })) class Jeans extends Component { render() { const { type, color } this.props return ... } }
It is, since there are array-like objects in JavaScript. For example when your query the dom you get an object with a length and the keys are ints however it does not have the array as it's prototype and is not iterable. Classical for loops work on these and arrays. In your case you are using full-blown arrays. The for...of loop is just more readable for your use case. Although there is nothing wrong with a classic for loop. 
I doubt bundling will be obsolete. Compression works better when there‚Äôs more data to compress and so how we bundle is likely to change.
Of course. But as there are good answers to that questions already, there is no point in adding another one.
Sounds pretty similar to what is already happening except for the file extension. Why do people care about mjs? People are only angry about it for aesthetic reasons as far as I can tell. The developers of the new spec had practical reasons for the change.
Thank you for your input! I'm using Webpack. To add to what's going on, I have access to the window object within knockout-jqueryui.js. I was thinking that window was the issue because in the snippet of knockout-jqueryui.js below, the root argument is undefined in my app but when running the knockout app normally, it's the window object. window.kojqui = { version: '2.2.3' }; (function (root, factory) { 'use strict'; root.kojqui.utils = factory(root.jQuery, root.ko, root.jQuery.ui.core); } The issue seems to be that root and the window object are not associated so my error is `TypeError: Cannot read property 'kojqui' of undefined`. 
Agreed! jQuery is written *in* JS, it should all be possible. I think the best way to think about it @WhoYouWit is to break down and understand what each part of a jQuery line is doing. For example: $("#example").html("Hello, World!"); The first part `$("#example")`, the selector is really just a method. So that selector is just the jQuery library doing the equivalent of looking up an id with: document.getElementById("example") It might be even easier to think of the `$` as a giant function. When `$` is called, it's arguments are the string `"#example"` and the giant function handles this string with the eventual `document.getElementById("example")` to return that node (along with a few other features).
Xpost :/ https://www.reddit.com/r/learnjavascript/comments/7qbb1k/very_confused_about_promises_with_fetch/
That's where client-side routing comes in. There's many routing libraries, but the most common is React-Router. I'd suggest checking out the [React-Router docs](https://reacttraining.com/react-router/web) for more information.
You really don't want to push 5000 files down the network, even if it's a "more viable" solution with HTTP2 than today. The most of ESM in the browser I can see is that we're loading bundled ES-modules. But (I hope) nobody will push their multi-thousand-file JS application down the line in a lot of small files. I'd not even consider it for my small private projects, tbh. Creating a few bundles just makes way more sense. So yeah, bundling for the browser won't go away. It's here to stay for the foreseeable future, especially with the web-packaging standard right around the corner.
The future is definitely not clear right now. I hope my next blog post will clear things up. But, in general, I believe that browser compatibility will shoot down the `.mjs` proposal, as `mjs
Note that it hasn't been "shot down" yet. It's just a proposal from people working at npm, inc. Yes, it has working code on it, and yes, it is from people that are very much at the heart of the node community, but it currently is just a proposal.
So, basically you *want* to use React, however because others have claimed that Vue is better for this use case, you want Reddit to help you decide which is better? Well the answer is React because you want to use react. Vue is indeed more suited to this task, but the benefits won't be big enough, so it does not matter that much.
I believe your `Promise` constructor is wrong - you can't put `{}` after the constructor, that doesn't mean anything specific. Instead, I think you mean function getCanvasDataAsBlob(canvas) { return new Promise(function(resolve, reject) { canvas.toBlob(resolve); }); } Note that the `reject` param isn't required there, but could be handy in other cases (like in your last point), so I listed it to show how to add it.
This is what happens when you work with promise chaining instead of async.
&gt; but otherwise it's much faster to use some starter boilerplate which sets everything up 
Even if you're using Babel it still matters though, because wherever the browsers/Node go Babel follows. If Babel is doing X right now, and the browsers decide to do Y, Babel (or at least its presets) will shift to Y.
await is more logical, like you are awaiting an answer When you wait, it doesn't necessarily need to be for someone or something I haven't read why, but this seems be a very logical explanation
Neutrino anyone?
 myurl = myurl+'?appid='+appid+'&amp;q='+urllib.quote(q)+'&amp;from='+fromLang+'&amp;to='+toLang+'&amp;salt='+str(salt)+'&amp;sign='+sign try: httpClient = httplib.HTTPConnection('api.fanyi.baidu.com') httpClient.request('GET', myurl) #responseÊòØHTTPResponseÂØπË±° response = httpClient.getresponse() print response.read() except Exception, e: print e finally: if httpClient: httpClient.close() how to use myurl ???
 xmlHttp.send(myurl); ????
Feel free to drop a script on the page. But for big webapps, devs have decided keeping all of your dependencies managed by code is better than manually adding them to the page in a specific order. Webpack automatically includes the dependencies, while cropping out the stuff that isn't used by the code (treeshaking). Webpack also allows you to important non-JS files such as CSS and HTML which is useful when rendering parts of a site through JavaScript. It also handles things that grunt or gulp used to handle such as minifying code.
 // Javascript, not python myurl = 'api.fanyi.baidu.com' + myurl + '?appid='+appid+'&amp;q='+urllib.quote(q)+'&amp;from='+fromLang+'&amp;to='+toLang+'&amp;salt='+str(salt)+'&amp;sign='+sign function httpRequest(url, callback){ var xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) callback(xmlHttp.responseText); } xmlHttp.open("GET", url, true); // true for asynchronous xmlHttp.send(null); } httpRequest(myurl, function (response) { console.log(response) });
From a high level, webpack is used to minify and then bundle all your JS files together so your end users only need to download a single minified bundle.js file. Not sure how familiar you are with NPM, but that is also a key part of the modern workflow. You'll use NPM to grab packages / libraries of code. In your JS, you'll use import statements to bring in those packages for use (such as jQuery). You'll then have a webpack config file setup to look at your JS folder (wherever it might be) and it will take everything in there and bundle it appropriately. The webpack config uses "loaders" to determine how to minify and bundle is, css, etc. You'll also specify what folders to read and where to output everything. Using NPM as a task runner, you then can have webpack auto building your code, so anytime you make a change and save one of your JS files, it will auto rebuild and reload your page. This saves you a ton of time during development. On a side note, if you do any node.js work, look up nodemon for auto rebuilding / rebooting your server on file change too. There's a lot more detail involved and I apologize if I missed anything, but that's my high level overview of why webpack is awesome. 
write cleaner javascript using your brain
This is the sort of thing I love arrow expressions and the implied return for: const getCanvasData = canvas =&gt; new Promise(resolve =&gt; canvas.toBlob(resolve))
&gt; If you wanted custom logic to reject/resolve then using a new promise could be useful In this case, just throw a new error (`throw new Error('BOO!')`) or return your own value (`return "YAY"`)
Take a look at webpack alternative. parceljs.org It is new trend with zero config.
Keep it up!
It's much better to have a longer enforce the code when you're working on even a small team. The value of almost all of software is to automate tasks so your brain can concentrate on things that are more important and non-mechanical. The smarter you are, the less you rely on your own brain for.
Also node modules. If they aren't built for the web, it can be a pain to use them in the browser, but webpack let's you `require` them as if you were in node.
"Await" is a verb that requires a [direct object](https://en.wikipedia.org/wiki/Object_\(grammar\)#Types_of_objects). In JS's case, you're awaiting upon a function. "Wait" can be used as a verb or a noun and, as a verb, it can have many different [grammatical moods](https://en.wikipedia.org/wiki/Grammatical_mood). On its own, its meaning is ambiguous and it requires additional context for the intended meaning to be understood. So, unlike "wait", the meaning of "await" is clear.
Has a nice phonetic pairing with async too. Not sure if that has anything to do with the original keywords or not.
You may want to read through some of the tutorials and introductions in the [Webpack Tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) section of my [React/Redux links list](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md).
I'm sure the alliteration played some part in the keyword names
Not sure why Im getting downvotes when I know Hr depts are throwing this on postings left and right because its trendy.
[link for the lazy](https://parceljs.org/getting_started.html) 
I was in your shoes once.. To simplify it webpack is a bundler for single page applications, and it is primarily for javascript, CSS and assets are imported from within javascript. Webpack takes care of creating js bundles and with the right plugins it will create CSS and other files. Resolves any path related issues. You could use it for building sites, but for me it is an overkill. As an alternative I use task runners such as Gulp to compile my scss and optimize my js files, like uglify and compress. Also cdn for libraries. For me Webpack is only for when building Angular or React js apps, and from my experience this is where it shines. It reduces the generated JS files by only copying what your code needs and not the whole library. Reducing a 5MB file to 256KB as an example. Vue.js is on the way but haven't created a development stack yet. 
I'm so sick of this JavaScript and web community that reinvents the wheel every day.
This sounds interesting. But how do you handle the hydration of the state of those widgets? In the classical jQuery way, one would generate simple HTML on the server (input, select or a table like the example from OP) and the jQuery plugin would then extract the state from the DOM and convert/replace it with (generated) markup of the rich UI widget. How would this be done with react?
Before might have 2,3, 10 different script tags to import the things you need for a site/app. Webpack can‚Äôt bake those things and put them into a single file. Import is now part of the ES standard and while browsers may not fully support it Webpack understands it and changes it to something browsers can understand. The learning curve is high but it a truly awesome tool when you get the hang of it. With all that said you don‚Äôt need it for everything so don‚Äôt shoe horn it in just for the sake of it being there. Alternatively there is Rollup and Parcel. Both do similar things to Webpack but came later so don‚Äôt have the same following/community as Webpack.
Where does the difficulty come from? I just see it as rails sprockets! The webpack that comes with create-react-app is painful though hahah!
lot of people reference confis from large projects or boiler plates that have a lot going on. Those build processes have a lot going on. Webpack isn‚Äôt inherently complex At its core webpack is a bundler. It reads your code (through an entry point, say index.js), finds require/imports and bundles them together so your source code can be divided into neat modules. It has many powerful features on top of that (including loaders for files so you can preprocess them before bundling)
For a web technology, linking files is a defined constant across all platforms. And in plus, the editor is (as the name suggests) just an editor for the code. Your web browser is what's really doing the rendering/processing work.
So, modules are now a part of the Javascript spec, but even before there were solutions like CommonJS. Webpack uses those to bundle files. Technically you can still achieve similar results just putting scripts in the page instead of bundling them, but not only it looks awful on the HTML but it means more requests for the server. Basically, Webpack takes a file as a starting point and retroactively bundles it with whatever Webpack perceives it's importing (of course that includes what these imported files are themselves importing), until everything it needs to work are there. It also can pass these files through plugins like Babel and Typescript compiler during the process, so Webpack is much more powerful than just a bundler. Native imports let you use modules without bundling them (and apparently HTML/2 has no issue with that, HTML/1.1 still does though), so you could do it instead if you have nothing to gain with plugins.
I'm not the author of this library, nor have I read through the code, but generally speaking, I'd say the reason to want an alternative to lodash comes down to: 1 - whether you care about bundling code to handle obscure corners such as symbols 2 - whether you like having a bunch of overloads to improve devexp at the cost of (again) bundle size. With that said, there's a bunch of other libs similar to this out there.
Think of it as "Async wait" and you no longer have that question.
Ahh I see, I'll take note and look into a bit further, thanks for the feedback
Webpack is a lot of things, but most importantly is a module bundler (fancy word for dependency manager) Basically, It is emulating a common feature of every other lang in existence. Example, see you can import a scrip, lib, class or function in pyhton ? Ohh well is the same, just that webpack will "module" (put the code in a function) and export the code so it can be explicitly use somewhere else (require)
Usually npm will dedupe automagically on install now. In practice, it can miss some things. This is a highly specific case but this is a case where dedupe needs to be done: If moduleDep exports a class and you check instanceof in an application. Now if moduleDep is a dependent of both moduleA and moduleB -- the one you require from A will have a different prototype than the one from B. If you dedupe them, they get required from the same file so they are the same.
Don‚Äôt know if it‚Äôs the reddit app browser but the age confirmation pop up buttons overlap
Yes, it was a world moving experience. Gulp meant more manual labour than anything, it's a dumb tasking mechanism, dumb in that it has no idea what your project it. Webpack is an AST analyzer, you give it an entry point and it will scramble through your project. Want to use something (?) `npm install lodash` and in your code √¨mport _ from 'lodash'`, hit save and webpack has got your back. That makes working so, so much easier than having to change configs in very specific order, etc. Webpack also makes debugging a whole lot easier. With webpacks hot-reload the application doesn't refresh. Only the component that you edit does.
&gt; The configuration that I have shared is a personal choice and I am more than happy for you to use it if you wish to, but at the same time, you should also dive into the available rules and see if there is anything that fit your guidelines. In my experience, you're better off using eslint:recommended, for the same reason I'd recommend using prettier-eslint: you don't want to waste collective team time bikeshedding over dozens of rules.
That was webpack 1-2 though. Webpack 3's configs are already simple. The upcoming version though starts with [zero configs](https://twitter.com/TheLarkInn/status/948657974196621312) and sensible presets. Going between production and dev right now is tough, i give you that, in Webpack 4 it's just mode: 'production' and your app is minified, tree-shaken, hoisted and it manages common chunks on its own. I run the alpha on a project, they've come quite long way.
&gt;React is often used for making single page applications. I have no intention of making one. I intend to create a traditional server side rendered application. &gt; I really plan to do with React is to make my tables searchable, filterable and interactive **on the client**. With react you can render the table initially as an html string and send that to the client - also include the js bundle on the client-side and `hydrate` the app - react will pick up what it rendered and attach any event listeners to the document which could potentially `setState` and invoke dom changes. It might be easiest to create an API endpoint that returns your data and do the entire thing completely client-side. So in `componentDidMount` you do a fetch to populate the initial data. Or maybe include stringified JSON of the table data as an initial prop in the render. I wouldn't say it's overkill - but the build tooling required for this might be a bit much. You'll need to transpile that server-side code somehow... or don't use JSX might be an option. Either way, that bundle that has the react bits in it needs to be used on both server and client. There are completely client-side options - you basically hand them a table and they'll inject a bunch of controls for sorting/filtering/etc. personally I'd look at that before attempting to dig into react or vue especially if the application doesn't already have a framework in place for this kind of stuff.
If you've worked in a compiled language, or any language with good module support, you've likely seen interpreters a compilers handle building your dependency tree (a includes b, c includes b, etc) and spits out your output as a single executable, or in this case, bundled JavaScript. Webpack manages your dependency tree in a simar manner. On top of that, if your code requires transpiling (typescript, ES6, etc), webpack will handle the work of asking Babel or the transpiler to take care of that. There's a bit more, but that's a 1000ft view.
Webpack can be used at any time. Even if you are stuffing your entire app into a single JS file, I'd still recommend it for a simplified build process, at least for the minification step. Any time you start adding multiple script tags to your main HTML, you should probably use webpack to reduce that nightmare into a single bundle. 
Academind YouTube channel and 30 mins of your time 
It's in the list posted below, but [Webpack Academy](https://webpack.academy/) is my favorite resource and the one I wish I'd found first. It's free, by a core contributor, and really well thought out.
&gt; mostly with `chrome.tabs` Promises But neither browser has Promises in the `chrome` ns... &gt; it seemed to me like the world want to move towards `browser.*` API for extensions Yeah, except for Google people seem to agree that `browser` is a better ns name and Promises are nice. Even though overkill for your case, there is a polyfill to provide the browser namespace in Chrome with Promises: https://github.com/mozilla/webextension-polyfill (and there's an alternative one, too). I doubt `chrome` compatibility will be dropped without Chrome also dropping those APIs, or Chrome supporting the `browser` namespace, too many extensions use the compatibility feature. The real pain, by the way is Edge, where you have APIs on the `browser` ns but no Promises...
I'm using react router, but from what I've seen so far of it, it only works when you use a &lt;Link&gt; or when you go to the url directly. Is the solution to wrap every single button into a &lt;Link&gt; or is there a global "url" parameter that I can just plug in and it automatically changes it?
One of the big use cases for webpack is the ability to split your code. app -- feature A -- feature B -- feature N There are times when your app doesn't need all N features loaded by the user. Indeed there are times where certain users won't ever need all N features. Webpack supports splitting your javascript into multiple bundles such that a user can load `Feature A` when they need it. 
I wonder if there's value, or if it's possible, to write a type of plugin or something that can capture error messages, print out better and readable errors to the console, and offer suggestions for common issues?
I agree. My biggest complaint is that I don't have time to learn it during work hours. But if I attempt to learn it on client projects I just lose a ton of time on something that honestly can be done with Gulp/Grunt, etc. I'm not saying I wouldn't love to know it--it just seems that the time investment is unrealistic.
Haha, I believe. In my case tabs movement API doesn‚Äôt implemented in Edge at all. Regarding to promises, my apologies, ‚Äúpromises‚Äù... I don‚Äôt quite remember what exactly was wrong with `chrome` ns in Firefox, but there was a reason for that: I needed to detect a browser in a code a couple of times.
I will say I haven't used Webpack 3. I read a lot about how much easier it was. Your comment makes me interested in trying it out. However, there's still some things that would make me hesitant. As /u/iams3b pointed out: have error messages been improved because spending hours just to figure out I misplaced a folder is rather frustrating (that's just a simple example, sometimes the problems are *much* more heinous and hard to track down)
I've never used routing myself, so I can't help too much there. Going purely off the top of my head: yes, I'm guessing you need to use `&lt;Link&gt;`, or render a `&lt;Redirect&gt;` component, or use the `withRouter()` wrapper to get access to the `history` instance and call `history.push()` to change the URL. You might also want to read through some of the tutorials on React-Router I have listed in the [React and Routing](https://github.com/markerikson/react-redux-links/blob/master/react-routing.md) section of my links list.
Here's my best shot at explaining webpack as someone who struggled with understanding till I could finally put things into words I could understand. Say you have a rather large app, like 10+ Javascript files, style sheets, and various HTML templates. You've got a nice header, maybe a sidebar for navigation, and some area that displays where the users gone on your site. Lets say you've created components, either through Angular/Vue/React or you're going naive. Either way, lets say you have a sidebar, header, 3 views and a dozen components. Each one of these has their own JS, HTML, and CSS files. Sure you could put all the CSS and JS in one file and if that works for you then do it. Otherwise, you're going to have to do one of two things: Add &lt;script&gt; and &lt;link&gt; tags on your main HTML file or bundle all your code together. The first one requires no webpack, but you need to be careful about your script and link tags being in the right order so things don't break. You also take a hit to performance because several web requests for resources is a lot slower than one big request (in some cases this is not true but for JS/CSS/HTML files we don't have to worry about those cases...much). Your second option is to bundle. This option requires webpack or a tool like it. This tool was originally built for JS bundles, so let's focus only on the JS part right now. Now, webpack doesn't work by just grabbing all your JS files and concatenating them - you'll run into the same problem with script tags being out of order (big exceptions when a JS file executes and expects something in scope that's not there). Instead, webpack starts at an entry point, usually called app or main.js. This file should be used to start up your header, sidebar, and/or home page. If the header, sidebar and/or home view require components, then the header/sidebar/homeview should be used to start up those components. How do we do this, though? Well, require() basically "imports" the component into the JS file using it. Therefore, your entry point "root" app.js file would require() the home view, the header and sidebar js files while each of those files would require() the JS files for the various components that make them up. This is referred as a dependency. app.js depends on homeview/sidebar/header and each of those depend on the components. When webpack runs, it starts with the file defined as the entry, sees what it depends on, loads those dependencies, checks each of those dependencies for more dependencies and so on. By doing this, webpack can concatenate JS files in order to create a bundle. That said, how do we bundle CSS and HTML? Well, webpack is VERY extendable. Say our sidebar requries a CSS and HTML template: we can use the same require statement we used to load dependent JS files to load dependent CSS and HTML files. However, because default webpack doesn't understand how to load these types of dependencies (HTML and CSS dependencies), we have to bring in loaders that tell webpack how to load those dependencies. By default, the html-loader and css-loader will inline your template/styles in the JS so you wind up with one big JS file and one request, all loaded in proper order. 
When you hear people or webpack documentation say "module", it's important to realize that in my above example each JS, CSS and HTML dependency would be considered a "module" by webpack. I'm not versed enough on the subject to explain how to bundle individual components as modules cuz i haven't really gotten into ES6 or AMD modules. 
Let me say, first of all, that you sure can _just drop a script in your page_. It's a totally valid solution. Let's try to walk all the way to a generic solution such as Webpack (or Rollup, or Browserify or others). Notice, though, that I will be writing _only_ about JavaScript, not other types of assets such as CSS or images or any other stuff. So you have a script for your page. It's about... say... 500 lines of JS. Life's ok, I guess. But then you start adding more functionalities to the page and your bosses hire a couple more devs and you all work on that JavaScript and if you just continued that way, with a single script file, well... I can see that getting out of control to a big 20k LOC file. Life's not so ok any longer. You and your team start splitting the code into different parts. You have, say, a bunch of functions to deal with DOM manipulation, some other pieces to deal with server requests, some others for data processing, a couple of components you reuse here and there, some utility functions... You quickly break the big file into... let's say about 20 smaller (~1kLOC) files. And how do you manage these? Well, you just insert 20 `&lt;script&gt;` tags in your page, in a carefully chosen order, because, well, you have to be sure that that utility function is available _before_ you try to use it, right? Now life is... well, better, yes, but it's not that nice either. Because you have to keep track of where you put your functions, the order in which things are loaded and all that. And files, well, 1kLOC files are still a bit big, you know. But if you split more finely, you'll get many more files and that means more `&lt;script&gt;` tags and more loading issues and... Ok, life is not really too good, I guess. Not only that, but you know, all those files define a lot of names. Names of functions, names of variables. And those that get thrown in the global scope... uh, yes, they may collide with other names defined in other files. So adding new stuff gets complicated. So you reach out to your knowledge (or consult some book, tutorial, ask for help, whatever) and you discover the "Revealing Module Pattern". I won't explain it in detail. Suffice to say that it is a structure like so... let something = (function() { // "so called private" code here // ... // and then... return { publicOne: ..., publicTwo: ... }; })(); ...which basically provides you, through a closure, with some encapsulation. The thing returned and assigned to `something` has some visible methods and/or properties, and those methods have access to the local stuff defined inside the function expression which no one else has access to. So, to some extent, it is a structure that allows you to write some encapsulated blocks with "private" visibility. Why this is good for your problem? It avoids name collisions. What you do is each of those 20 or now 50 files you have, you create this structure, engulfing all the content of the file. And at the end you _only_ return the things you really want to be visible. This is a huge gain, because you can now split the files as small as you want without concern for name collisions. On the other hand you now have 50 `&lt;script&gt;` tags or a hundred. And that thing with the order, well, life's not so nice in that front. Let's recap a bit: 1. You've successfully solved the problem of having a single huge file. It was a problem, because it was really huge and because you needed to have various people working on it at the same time and that's nasty. But now that's solved because you have separate files and one person can work in some files while another works in others. 2. But you now have these problems: 2.1. You have 200 `&lt;script&gt;` tags in your page. 2.2. They need to be kept in a certain order. So we're going to try to solve these two new problems. There's a really simple solution. It won't solve everything, but it is simple: You could have a shell script or some similar tool that simply concatenates all your script files in the correct order. That way, the first problem is clearly solved. Your sources are in 300 files, but the script included in the page is back to being just this one file. So just one `&lt;script&gt;` tag again. Great! But the second problem remains. For the shell script to correctly concatenate the JS files, you have to tell it what's the correct order. You can go through many na√Øve solutions here. Some may even work to some extent. Say you named your files following a certain pattern like `00100-somefile.js`, `001300-anotherfile.js`... and then just concatenate following the number. It sort of works. Not pretty at all to maintain, but it sort of works. Anyway, any solution along those lines is still a kludge and doesn't really _solve_ the problem. So instead, you think of a pattern a bit more sophisticated. To the above pattern you try to add some way for a particular file to say what other files it needs to be available before it can run... Its _dependencies_ if you will. I don't want to write what that could look like in a na√Øve approach, but you can look into [RequireJS](http://requirejs.org/) for an approach that is somewhat close to what it could look like. Then again, while you're doing all this, some folks publish NodeJS, it becomes popular and as it precisely includes a mechanism to do exactly this (defining "modules" which can _export_ some public parts and _require_ other modules) then that mechanism, with that particular syntax and all, becomes very popular too. Note, that later, the standard decides on a different syntax and mechanism but that doesn't really matter much; the important bit is that there are some particular syntaxes that become popular, and so you follow that. But of course, the syntax in NodeJS works well for NodeJS. And while ECMAScript finally standardizes on another syntax, the point is that these systems are designed towards really having _multiple_ independent files... and you don't want to serve your files separately. The syntax leaves out most of the "weird" boilerplate about closures and simply allows you to write it in a manner such as... // one of these to require dependencies: let a = require('a.js'); import a from 'a.js'; // ...your code... // One of these (or other similar variations) to make things visible out of your module: module.exports = something; export something; So you revise that shell script you had that simply concatenated all your JS files, and turn it into something a bit more sophisticated. On the one hand, you make it so that before and after each file's contents a little bit of boilerplate is added. This is, approximately, the same closure boilerplate you had removed in exchange for this new syntax. Not exactly the same, but it is similar. The main difference is that it is putting your code inside a function expression but instead of simply calling it directly, it passes it to a small function that the shell script makes sure is included first thing into your final "bundled" JS file. That function _will_ execute the function that it receives, but it will do so with a bit more control. Because it either manages those `require('a.js')` calls or transforms those `import from 'a.js'` into calls it can manage. And it will capture the returned output from the module (i.e. the parts you decide to `export`) and it will manage those too. In what way? Well, it keeps a registry of modules. That way, the system knows what it has to give your module when it asks for `a.js` and also what it has to give other modules when they ask for yours. Not only that, but having such a registry, that keeps track of what is loaded and available also solves the order problem. If it is in the registry, it has already been loaded. If not, the system can delay your `require`ment or your `import`ing until that file is indeed loaded. Let's recap again. 1. You have a manageable code base, where the sources are split functionally into small modules. This is a very good thing. 2. You have a _process_ or _tool_ that: 2.1. Puts all the small files into one big file 2.2. Adds some completely generic utility functions that: 2.2.1. Take care of providing each module with any other modules it asks for 2.2.2. Solves the problem of order. Note that it's not _only_ this. Really the dependency system can work with your code, whether it is encapsulated and bundled into one single file or whether it is left as separate files and loaded on demand when they are `require`d or `import`ed. As long as the system or the tool provide the mechanisms and understand the same syntax you gain that ability for your code. Now, this _tool_ is something you can do yourself. But it would be much better it lots of people used similar tools and if those tools worked in the same way. That way, you could treat external libraries in the same way you treat your own code. So, instead of actually building yourself such a tool, you use an existing one. One of those tools is Webpack, though there are others. A final notice: Some of these tools, as others have mentioned, tend to take advantage of the fact that you are doing all those code transformations and bundling to offer doing _other tasks_ too. Such as minifying your code. You know, compressing it so that it's smaller and is loaded faster. Or maybe they can even avoid including files which are not actually needed. Or the parts of files which are not needed. Or they can also process other assets such as CSS and/or images. Once you've agreed to have that tool or process as step in your workflow, well, why not make the most of it? So this, in a generic way, with many inaccuracies and over-simplifications, is what these tools (not only Webpack) are about.
&gt; I was spending so much time trying to keep Flow happy. TS stays mostly out of the way Do you remember any examples?
Already called that in languages that had this already. The other replies answer why the term was originally chosen.
Well, for Vue, you could always use the Vue cli, generate a project and examine the Webpack config it created. 
Vue cli webpack being one of the "templates" I was referring to
Have to agree it is not a fun tool to use. I‚Äôve gone so far as to use Maven to achieve the same thing. I love javascript as a language but I really hate its most popular tools.
Though I can't really understand how to use it as a power user, I'm still in awe of what JS is capable of these days. The teams behind these transpilers and bundlers are sure a talented bunch.
Is it really that much simple, though? We recently switched to 3 and I did the conversion, and I honestly don't see much of a difference on the difficulty scale. Then again, I've never got the complaint about the difficulty of webpack in the first place. Webpack had a slight learning curve in the beginning, because it does things a little different, but overall I've found it ridiculously simple. Once you pass that first small hurdle of figuring out how it works, it doesn't really get much more complicated for very complicated projects. Unlike the alternatives, who all get insanely complicated for any kind of real project. 
https://medium.com/the-node-js-collection/modern-javascript-explained-for-dinosaurs-f695e9747b70
I highly recommend learning webpack from the free laracast series here: https://laracasts.com/series/webpack-for-everyone It will take you through the process of building your webpack config from scratch. It also covers building node scripts for webpack dev and production builds. The series has a ton of videos that are less than 10 minutes so you can go at your own pace. Once you get the basic gist of webpack, setting up more advanced configurations is a breeze. At the end of the day you still link your bundle.js or app.js script the same way you always have.
This little comic gives an excellent high-level view: https://medium.com/the-node-js-collection/modern-javascript-explained-for-dinosaurs-f695e9747b70
I got downvoted for basically saying the same about Gulp..took some time but it just works right now( and I understand how). 
If this assertion is true, you will fall behind in the job market 
I opened up the fiddle and the minute hand didn't update until 20 seconds after the 00 seconds mark, refreshed the page, then it didn't update until about 35 seconds after.
https://github.com/AriaFallah/WebpackTutorial
Why?
Greasemonkey / Tampermonkey
New library from 2016?
I agree with you, I might not be that experienced when it comes to webpack. For me when building a site it is more CSS than JS, and depending on the components in the page I would load JS in a strategic way to make the site behave like a progressive web app. Google page speed scoring is a priority for me. Can you direct me to such an example of using webpack, let's say with WordPress or Drupal. I would appreciate it if you could.. 
This is a fantastic answer and deserves to be its own blog post!
Meh, a lot of these boilerplates are very opinionated when it comes to SSR, folder structure, API backend etc
I'd say a huge perk is getting to use cool tools like TypeScript, Babel, Sass/Less/PostCSS, etc. (Although other bundlers can do this too)
This is going to make it easier for me to shitpost. üëç
Hell yeah, that sounds awesome having sensible presets that can be switched off makes way more sense than having to keep track of the zillion different "loaders", I mean it's not like a logic issue understanding web pack for me, it's having to read up on the differences between `style-loader`, `css-loader`, `postcss-loader` etc. etc. etc. it's like a crawl through the jungles to just figure out what does what. Lately I have just created a project with create react app, ejected the web pack, removed things I didn't need, change the `entry` and `output` and boom! I got what `webpack`'s official docs refuses to tell me. 
I know, I love programming and learning new languages and frameworks, but to me learning **webpack** beyond the basics is asking too much. It's like they assume everyone else is as familiar with the active developments in the various transpilers and tooling that the OSS contributors who build them are. I would rather be learning a new language or paradigms such as the Actor model, or dive into the specifics of some web protocol that may come in handy in the future. But webpack sucks away that time and joy leaving me with no new "real" skills or knowledge, just a slightly smaller bundle at best. Man oh man do I wish it wasn't such an endeavor. 
Honestly, I the current side project I am working on for the past two weeks has barely any new features, all of it has been tweaking the webpack tooling which eats away all of my time. Looking back I STILL have no idea why "it's better", to me it just feels like a bloated over complicated tool that sucks up memory and file space. I am actually starting to get angry now that I think about it! I just realized I wasted so much time with nothing to show for it! 
It's just a js file bundler with add-ons support. Files are connected together with "require" function or "import" statement, just as how node.js works. So you can cut you code in different "modules", to make it more readable or structured. So instead of having one huge js file when you develop, you'll have one huge js file only in its release format (on the website).
I don't even know why it's so "standard" - seriously, most people want es6, to import other files, and minify them. Webpack is so overkill for that
I haven't tried it myself yet but uppy was posted here in the last few weeks and looks awesome https://github.com/transloadit/uppy/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [transloadit/uppy/.../**README.md** (master ‚Üí c1b1d94)](https://github.com/transloadit/uppy/blob/c1b1d94c496af202daed3dd0369a2546356f8716/README.md) ---- 
Well, not this week but have been working on something which becomes release worthy today. Please check out https://github.com/ashubham/tokenizer.js
Array.find is basically this: function find(arr, test) { for(const el of arr){ if (test(el)) return el; } }
No, it's not really an issue with the docs. I figured out what I needed with the docs and info I could find, it was more just the time I had to spend that I wish I didn't have to use. 
If this is simple automation, but you need it often, you can use Greasemonkey. If it's a little more complex, you can take a look at webdriverio.
Yeah, it used to be way worse. Webpack 1 was a jungle of options. I mean, depending on what is needed, 3 is still complex with all the loaders and plugins, but this stuff comes piece by piece.
Here's what I've learned about webpack... 1. Everything feels like a nasty hack 2. When it works, it's great 3. Many of its developers do not speak English as their first language, so certain nuances in the docs might be lost in translation (if a translation even exists).
I think webpack related error messages have improved because they have a schema (would previously just crash with a random stack if you had a wrong option). It would also warn you if import paths are wrong. Code errors aren't an issue because of source maps.
What are the steps? Bookmarklets are super easy and don't require any extensions. Create a bookmark with a URL of the form: javascript:alert("Hello, world!"); ..and you're off
Came to suggest the same article. Totally cleared so many things up for me.
You could read its documentation and fix what's broken instead of copy pasting code from SO until it works.
That's(hopefully) minified code. It's difficult to make sense of. I haven't done jQuery in years and my brain hurts looking at that, so maybe someone else can chime in :p
webpack 3 is still complicated as fuck when it comes to getting it working with templates, or libs that don't play nicely, or really anything other than just the basic functionality. i've had a much nicer experience with rollup tbh.
Could you give us a more readable version of your code ? For instance with a Gist : https://gist.github.com/
If I had reddit gold, you'd get it. That performance is oscar-worthy.
Please checkout https://github.com/ashubham/tokenizer.js Any feedback appreciated.
Truth is, I don't want to learn anything from that code in particular, but I want a person to simplify the code in "conversational" terms, so that I would know what letters to key in as I'm kind of intrigued by the nature of this website.
Thanks everyone for your kind responses. Ah... I don't know if I'd post this in a blog, but feel free anyone to post in your own if you so desire. You don't even need to give credit to some random letters and numbers on reddit xD But anyway, I had to stop but forgot to add a bit about how it _really_ happens. I'll use Browserify because its simpler. Don't mind much the code itself, it's not a complete example. (Also, the following is _not_ needed to just get a general idea, but it might help in understanding _how_ it is done) Say one of my files (something called `linkLoader.js`) looks sort of like this: const xhr = require('../lib/xhr.js'); const dom = require('../lib/domUtils.js'); function loader(container) { const output = dom.printTo(container); xhr.get(href, function(content) { var { content, js } = dom.parse(content); // ... }); } module.exports = loader; I've removed most of the code. The interesting bits are still there. So, you run browserify on this file and it spits out a _bundled file_. I won't show _all_ the result of that here because it's too big and noisy. But, this particular part gets transformed into something like: { 1: ..., 2:[ function(require,module,exports){ const xhr = require('../lib/xhr.js'); const dom = require('../lib/domUtils.js'); function loader(container) { const output = dom.printTo(container); xhr.get(href, function(content) { var { content, js } = dom.parse(content); // ... }); } module.exports = loader; }, {"../lib/domUtils.js":4,"../lib/fnbasics.js":5,"../lib/xhr.js":6} ], 3: ... } So it gets thrown into an object. This object will be passed to the function I mentioned that will execute each of those. As you can see, the transformation is mainly just wrapping the original code _and_ extracting the dependencies that each module `require`s, for easier management later. It is interesting to note that your code then gets executed in an environment where you have access to three things: a `require` function, a `module` and `exports` references. This is basically all you need for your code to work and it is interesting that it doesn't really matter much what these _are_ or how they work at a detailed level. Just that they do what you expect. This is what allows what I mentioned earlier: the actual loading can happen like it is done here, in a single bundled file _or_ it could happen in some other way (e.g. by loading it on demand through XHR or from the filesystem or whatever). If you want to actually see what those things look like or what the general function at the start of the bundle looks like, you can have a look at the [browser-pack](https://github.com/browserify/browser-pack) package. But a _general idea_ might be doing something like this. I have that object there with all those functions so forEach(key, module) -&gt; { funct = module[0]; dependencies = module[1]; registry[key] = execute(funct, getDeps(dependencies, registry) ); } This, of course is a very na√Øve approach. A real solution needs to take into account the availability of dependencies before they are used. It also _doesn't really work like this_ at all in regards to that `registry` because your code does **not** `return`. Instead you add things to the passed `module.exports` or `exports`, but that's just a detail. Now, I've used Browserify because it is much simpler than Webpack. The output Webpack generates is _similar_ in spirit. Webpack builds an array, instead of an object and wraps our modules into something like this: /* 1 */ /***/ (function(module, exports, __webpack_require__) { const xhr = __webpack_require__(0); const dom = __webpack_require__(3); // ... }), (The comments are there just for human debugging purposes.) As you can see, the main difference is that Webpack applies some transformations to your code _while it is generating the bundle_. The main transformation is that one you see with `__webpack_require__`. Not only it does change the name or `require` to that, which is a superficial change, while it is doing that, it also removes the reference to actual filenames and substitutes them for a simpler index number. In any case, the result is _similar_: All the benefits explained in the previous message are there. Also, as already mentioned, Webpack does _more_ than this. This is all in relation to modules. But Webpack also includes other tasks which you might do with other software. Like compressing (minifying) the output file, or managing CSS alongside JS, or running a transpiler... Or a common one. As I mentioned there are mainly 2 different syntaxes for importing and exporting. The CommonJS (what NodeJS uses) and ESM (the ECMAScript standard), i.e. `require('bla.js')` vs `import from `bla.js'`. While Browserify only supports CommonJS, Webpack supports both by transforming "at pack time" those `import`s into `require`s. (**Note** that this isn't correct. Webpack 1 didn't support `import` either, but Webpack 2 (and 3) does. And also, you _can_ combine Browserify with other tools -Babel- so that they do the transformation and then Browserify does the packing.) ---- Now, there is just _one_ remaining thing you may be wondering about. It could be something like: "Well, now that there is a _standard_ way to load modules, can't we just use that and forget all this about bundling it all into one file and just let the browsers load what they need?" The answer to that is not completely straightforward. Let's just say... - While _there is_ a standard, there has been no available implementation of it in any browser until... well, _very_ recently. The very latest versions of some browsers are just now starting to ship with (some) support for ES modules. (See the warning at the top [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)). - So in the future it may be a way or _the_ way, but for now, needing to support current browsers, the solution does seem to inevitably go through a bundled file or some similar solution that offers the functionality browsers don't. - There are also some other things that affect usage of all this. In particular, performance concerns and HTTP2 support may help or may not help going back to multiple independent files being loaded. This is a bit hard to determine _yet_, but it _may_ mean that in some scenarios bundling all files into one (or a few) file(s) might still perform better. So the answer to that is a classic _it depends_. Or, if you prefer, it could be something like: "For now, bundling is a good idea in many cases. In time, we'll see".
It looks like it will try to add different images on the page based on a sequence of key presses you make. It won't work though, since there is a typo (3c instead of 3 * c as the event from keydown). By running the math backwards and converting the keycodes to strings: [2018,1994,1991,1961,1964,2003,1984,1951,1990,1960] .map(s =&gt; (s - 1756) / 3) .map(t =&gt; String.fromCharCode(t)) .join(''); You get out the string: WONDERLAND. I assume that if you type that into the page, you will see the pictures.
+1, based on the ‚Äòaway from js for a while‚Äô comment. 
Oh, it actually worked? I got errors when I tried it without the multiplier. Anyway, you're welcome!
&gt; You don't need polymorphism. You can make a bunch of toStringFromA(obj), toStringFromB(obj) methods, each taking different obj types, one for each type you want to implement toString for. The spot where we'd need polymorphism is if we wanted to write a function that could operate on either objA's or objB's. function serialize(objAorB) { // Can't call toStringFromA or toStringFromB because we don't know which kind we have // Ideally we just want to say toString(objAorB) and have it do the right thing } &gt; If you need something like polymorphism you can pass your toString function alongside the object into the function that you want to use toString. Interestingly, that's basically how traditional OO polymorphism works. You have references/pointers to functions that travel with the object those functions operate on.
You could automate stuff using in-browser extentions, browser manipulation (Webdriverio/Puppeteer) or through CLI applications (NodeJS + http-client library [node-fetch / bluebird / axios / async / etc] + optionally, a dom manipulation library [jsdom]). All within the realm of javascript. I usually go the NodeJS way because you have easy access to your OS, so if you want to save files, make logs and also include external scripts/programs, it is simpler. All in all, it depends on how simple/over engineered you want your solution to be. Cheers!
Lol dealing with this now. Spent a year figuring out javascript and bootstrap....But I just realized I need react to get hired. Wish me luck I guess.
'millennial thing"
This is the only way I learn anything that I do, really. I love tutorials of this nature, that follow the pattern of "you used to do *this*, and now you can do *this*" It's been extremely frustrating that in general things aren't written this way. Web dev, game dev, dev of all kinds. As simple and elegant as these solutions may be, I don't think people realize in general that if you're new to the domain, it's hard to understand how to use the solution when you didn't already know the problem. I've always felt a bit stupid for not for the life of me being able to understand how/why to use RequireJS. I've always been afraid to ask (not really afraid, just haven't taken the time to do it) why would I use this when I see a lot of code using "module" and "exports"? Those don't seem to be the same thing, sooo what am I missing? It wasn't until I read this explanation above that I finally got it, sort of.
maybe post code here?
Thanks! It seems that "web based node editor" is the buzz word to search for. I found this that seems promising. D3 Node Editor, using d3 https://github.com/Ni55aN/d3-node-editor jscow-node-editor https://github.com/jsCow/jscow-node-editor A simple one in a fiddle https://codepen.io/xgundam05/pen/KjqJn
On the flipside you need to know vanilla js to properly learn React. Otherwise it's a slight clusterfuck going back and forth between what is vanilla js problems and what are react problems. You can learn it by doing the framework, yes, it just makes it a lot more confusing when you cant split it up in your mind properly. 
what a job using a particular framework? learn that framework. want a job in webdev? learn how to leverage/learn frameworks as they appear.
Hi Fabian! Who was using it when it was closed source? What benefits does it have over gatsby?
Node-Red is a full fledged development environment around this idea.
We switched from 1 to 3. 2 wasn't out long enough for many people to make the switch. &gt;commonchunks (i still don't get it, at all ...) It's magic. It just automatically cuts up your bundle, so that they can be loaded in parallel and cached separately. It's opt-in, so if you don't think you need it or don't understand it, don't use it. We don't need it because we have a separate deployment process for creating a commons.js file.
I do have it in place, two times, once on async and the other catching vendor libs. But i've basically brute-forced the settings until we got the smallest possible bundle out. In webpack 4 this plug will be obsolete and chunking is done automatically by default. : D
Specifically ES6. The frameworks transpiles the code to ES5, so its super nice to be able to use ES6 features.
Learn JS first.
Learn JS, master it. React is really simple, hardly any boilerplate BS to learn. Angular is a pain to learn. 
Hey samgaus! We have quite a lot of active users at the moment. I think you cannot really compare Gatsby to GraphCMS, since Gatsby is an static site gen and GraphCMS a SaaS GraphQL CMS. We actually have a source-plugin to use GraphCMS Gatsby btw :) In GraphCMS you can define your content model and we generate a GraphQL API for you which you can consume in your frontent. GraphCMS is basically a content backend for every kind of application. Does that answer you question?
Teach a person how to fish...
Want a job as a carpenter? Learn to use a Stanley claw hammer.
Because it's backwards. If you pull up your pants before you pull up your underwear, very soon you'l find out it should be other way around.
Unless you are going for a specific job where knowing react is a requirement, then you don't need react to get hired. There are plenty of non-react dev jobs out there.
You definitely need to have a strong grasp on JS before moving on to frameworks. I agree with that. I don't agree with the idea that you don't need a framework at all though. Even in other languages, there's always a UI framework written on top of it, e.g. iOS has UIKit and C++ has QT. 
Hiya! I'm just here to say that the `npm` proposal is just that. It is a proposal to diverge from the existing `--experimental-modules` flag. It will take a long time to review but has no +/- indication from the Node Foundation as of yet.
A store, state-&gt;state functions and dispatching actions. Shouldn't take more than a few days.
&gt; Node-Red Yes I found Node-red. The images is actually from that project. But it seems to be so big so I thought there must be a more basic version. 
Is there a specific compatibility problem here? Also, if your server supports redirects you can still drop the extension either by doing an HTTP redirect, or if it does not by setting up a redirecting module record `export * from ...`. However, the browser has given these two solutions slightly differing semantics so some care must be taken and no standard approach has been adopted by most tools. Let me know if you have a server that does not support .mjs out of the box. I've updated most of the MIME libraries already (except Apache which is waiting on the IETF draft to finish landing [6+ month time from when it gets published :0 ]).
&gt; So if you were being practical, you should jump into one of these frameworks and learn how to use your basic JavaScript knowledge within the constraints of that technology ...which you need basic JavaScript knowledge for in the first place. Back to square one, OP.
nobody is claiming you don't need frameworks. but with a proper understanding of basic javascript, you will have a way easier time understanding those frameworks. people learning frameworks and libraries without proper js basics results in all those people who say "wait, you can do this without jquery?" 
furthermore, many companies exaggerate in their job descriptions and are gonna mention a thousand things they think they might need, but when you're actually there, show them you are solid in the basics, and fit them otherwise, they usually won't mind too much that you don't know that specific framework. because someone with proper basics will be able to learn it quickly enough anyway if they really need it.
Alot of people seem to say this is completely untrue, and to learn vanilla JS first. I actually jumped right into Angular 1.x when I was leaning things years ago. I think it greatly helped me actually learn JS. I will say knowing JS is actually more important, but starting with a framework will let you build some more complex things and get you excited about filling in the knowledge needed. You can't just stop at a framework though.
\#HammerFatigue
I don't think anyone is suggesting going into a framework with no knowledge whatsoever.... Look on any job site for junior frontend developer roles. React comes up consistently. https://www.indeed.com/jobs?q=junior%20front%20end%20developer&amp;l=California&amp;vjk=4b2e7bc93a93c299
&gt;Javascript ~~trends~~ frameworks ~~to watch~~ in 2018 Fixed the Title for you.
I agree with this article 100%, with a few caveats: - A good interviewer will test a candidate's knowledge of the framework and the underlying language, so this advice all but ensures your first job will be at a company where people aren't good interviewers. - If you take this approach, your first web dev job is just a step on the path to becoming a competent developer. Companies know, when they hire junior developers, that they're hiring someone to learn on the job. Many are also short-sighted and look at hiring a junior developer as an investment; raises may be inadequate no matter how much you grow in the first year. The balancing act is to bring enough value to justify your salary while learning the skills you'll need for your next job. - No matter how shiny the React stack looks in the job description, there's probably legacy Backbone code lurking somewhere. - The modern React stack for enterprise apps can also include Redux, Immutable, and Flow, which will take you out of your depth *very* quickly if you don't understand the language well.
Frameworks are useful *in addition to* basic JS skills, not *instead of* them. Sure, knowing more buzzwords might get you a phone interview more often. And then you're going to fail out in the first ten minutes anyway by getting basic JS questions wrong. Even for a project that is using a particular library or framework or build tool or whatever, I would rather hire someone with competent general skills but little experience with that specific technology than the other way around.
yea exactly.
Yeah, my bad
Well, there's a good reason it's so big. Why do you need a smaller one?
Use case??
Great answer. Would give 100 upvotes if I could. Thanks for clearing some of the stuff that was still mysterious to me.
Something like http://archive.is/
This doesn't apply to super heroes! (They wear their underwear on the outside).
No you don't. You can learn react well enough on the job in 2 weeks if you truly understand javascript or basic programming principles. I got a job that "required" 2 years Angular experience and I had never touched it because I understood JS. Now we have moved on to Vue for our main application but have others still on Angular and some on React...all of which I have worked on. I have even been bouncing from C#, to Swift, to Java, and back to C#. A good programmer/developer can learn the tools easily. To hire or not hire someone based on the fact that they don't have experience with the tool is moronic.
And they become a fish?
Documentation available at https://github.com/gitential/datasets
Frameworks largely don‚Äôt mean shit. You just need the skills to understand a framework and its choices so you can work within it readily. No frameworks that exist today require any substantial amount of learning. Knowing JavaScript inside and out, and being a talented software architect on the other hand - those are things I look for. I could give a fuck what framework you know.
I don't quite understand your requirements, but if you need to do it in-browser your options are limited. Most people do PDF generation on the server-side, and then you have lots of options (depending on which server-side language you use).
maybe i didn't explain good enough: pdf IS generated on the server side and returned to the client via ajax in a blob format. Then, I need to display and print that in-memory pdf generated with this blob.
Sounds good, also for a girl. Will pass it on, thanks
I know. It's easier if you come into a codebase with all of that already wired up. For the uninitiated, setting up Redux is a bit daunting.
The problem is that (at the bottom of the code) you are setting the event listeners at the beginning, then updating everything else except the event listeners. So in pseudo code you have this (on page load) if user clicks mango, remove 4th element But later, when you only have 3 elements left, clicking mango will look for the 4th element and not find anything. I personally don't like using removeChild[i] for this kind of thing unless its really necessary. I would try using data-attributes myself, but what you have could work if you remove each event listener and add them again on each call to remove()
React can render to pdf, not sure if this is what you want, allows you to either create the file or display it: https://github.com/diegomura/react-pdf
Counterpoint: Someone who does have good fundamentals instead of buzzwords is only likely to wind up with a job somewhere that's smart enough to value people with good fundamentals and trust them to get up to speed on buzzwords as required. Working somewhere like that will surely be infinitely more pleasant and educational for them than getting a job as a framework monkey somewhere that hires based on buzzwords and is full of staff with no idea what they're doing.
interesting... does it support printing of these files as well?
So this is an announcement of a blog post saying you will *eventually* open source *parts* of the application? Will you update us again when the code is available?
Your user name gave me a momentary flash of panic for some reason.
I'm not sure I'd call it simple but [mxGraph](https://github.com/jgraph/mxgraph) is a full-featured JavaScript library that the Chrome app [draw.io](https://www.draw.io/) was built on. [Draw2D Touch](http://www.draw2d.org/draw2d/) is another, simpler diagram drawing library. For the above and more see this list of [10 JavaScript libraries to draw your own diagrams](https://modeling-languages.com/javascript-drawing-libraries-diagrams/)
There's a version 2 of [Laerin's Node Editor on Codepen](https://codepen.io/xgundam05/pen/bNeYbb)
all the code works now, whats the wÃâÕäÕíÃ±Ã∞ÃñÃ´ÃªoÃâÃòÕôÕïrÕ§ÃàÃéÃÖÃèÃ¨ÕöÕñÕïÃ¨Ã∞Ã≤sÕ≠ÃêÕ•Õ´ÃÖÕìÃ∫ÕÖÃ†Ã≤Ã¨tÃáÕ≠ÃãÕåÕô Õ≠ÃèÃÜÃèÕßÕÇÕ©ÃúÃ•ÕïÕçÕáÃûÕötÃéÕóÕ§ÃÇÕíÃ∫ÕÖÃôÃ§ÃôÃ∞Ã†hÃÖÃÜÃêÕÉÕ•ÃâÃúÃ£Ã§Ã™ÕÖaÕÆÕ´ÃöÃíÃΩÕåtÕØÃáÃôÃñÃºÕéÃ∞ Õ™Õ≠ÃëÃíÃÉÃ¨Ã≠^cÃÅÕëÃîÃåÕñÃ≤ÃúÃ±ÃòanÃΩÕßÕÑÃöÃäÃ†ÕîÃØÃùÃ∞ ^Õ¶ÃçÃåÕ™ÃóÃ´Ã©Õì^hÃöÃíÃÖÃ£ÕâÕâÃóÃ∞Ã•Ã™aÃüÃ©Ã≥Ã§pÃΩÕ§Ã™Ã©ÃñpÃÅÕßÃìÕêÃÆeÃÜÃÅÕ¶Õ•ÃøÕíÃâÕìÃûÃØÕönÃâÕé?
...I mean, that's true, yes, but the UI framework for vanilla JS is the browser. In an ideal universe, the browser environment itself would preclude the need for an extra block of code being downloaded.
Yeah. They're describing poor interviewing. Bad interviewing: ask trick questions with one answer that has little to do with the real world skills required to build an application. Answer no questions and silently observe the suffering. Good interviewing: ask open ended questions and actively engage with the candidate to test not only creative problem solving but also teamwork and communication skills. 
It‚Äôs pretty frightening how many times I‚Äôve been down voted for saying the exact same thing, it‚Äôs even more frightening how often this sentiment is expressed and then ignored (definitely guilty of it myself) . 
Estwing? Hah, that is so late 2017. We're building a new house using Stanley Native, the new all in one home design framework from Stanley and Home Depot. It has great tools built in and awesome foundation control. What is even more awesome though is that it comes with preferred build tools. All we have to do is add a build script to our package.json and run it with something like "npm run callContractor" to call someone to come out and build it. If it detects a problem it automatically calls 911 and files the proper insurance paperwork!
&gt; this has never been a hindrance for me. gettin paid well and working on awesome shit in the valley I don't know anything about your situation. Maybe you are 1 in a thousand. &gt; i also have coworkers in their 40s. one in their 50s. Yes, there are lots of people working dev in their 40's and 50s thats not my point &gt; theyre fuckin awesome programmers. Not very relevant &gt; stop spouting this ignorant garbage Don't be an ass The problem I see, and I've seen this myself first hand, is that in webdev if you are oldish you are very likely getting interviewed by 20-30 somethings, including management, and I see my coworkers/interviewers being uncomfortable about older people, especially the prospect of managing them. This is not uncommon so I don't know what cave you are living in, its usually covered up with "culture fit" excuses. addendum: I should add this is a plague in the ruby on rails world, maybe not so much in other fields. 
We are actively working on the code refactoring and improvements as we speak. I can definitely update you when we are open source!
Well, I've worked at a number of household names in tech through phases as startups and onto acquisitions, as well as some of the top 5. Are there companies with inept hiring managers? No shit. There are people who look at women programmers weird, people who discriminate against certain races, and of course some who discriminate against ages. Shitty hiring managers exist in all industries for all professions. This is not specific to software development. However, in the valley it is simply not a real problem for a 30, 40, or 50 something web developer. If you can prove your chops nobody (worth your time) gives a fuck what age you are. If you worked with people who did, then I'm sorry you worked at such a garbage shop. I'd consider changing jobs.
Exactly. Kinda puts this article to bed, really. I started out with HTML, CSS, and PHP which I eventually stopped using because all the jobs I had never called for it. After a while, JQuery was in high demand. Silly me, though. I didn't think of it as JavaScript. As the years progressed, frameworks were in demand, but good-paying Dev jobs called for JavaScript experience -- not framework experience. If I want to work in a place that will enhance my dev skills, I need to be around quality front-end devs that know the ins and outs of HTML, CSS, and JavaScript -- not just Angular or what React can do. Some people who learn React automatically think that you have to build it out with ES6 Classes which is absolutely not true. That sort of understanding only narrows their understanding of what React can do, and the fact that uses JavaScript. 
I really hear that argument and I wish that were the case, but unfortunately there's a huge disconnect between the documents that the web was designed to create and the applications that are available on the web today. For better or for worse, the web has evolved into a platform for applications, not text documents.
Counterpoint to your counterpoint... if you find these places... *please PM me if they're hiring I'm dying inside*. These places are rare. Software engineering is a slave to finance. Everyone wants the cheapest engineers who work the most hours to build the product as fast as possible, with the least amount of buttons not clicking on the UI. Whether or not the product design is *good* is another story.
Off topic but I hate this trend: fetch(url). // &lt;- dot should be on new line then(doSomething). catch(errorHandler); 
A co-worker joined our dev shop back in August while going through workshops and learning the basics. He was more or less thrown into a React project with absolutely zero experience or knowledge as to what React is. I feel bad because he'll be learning React under a harsh schedule while barely using the basics to continue. I think that's the reality now. Mind you, you still need to be using JavaScript to do the work in any framework, but there's a lot that's being neglected when learning it. Years ago, I had learned JQuery before actually learning JavaScript and wished it had been the other way around.
@bradleymeck - for some reason, my answer got truncated. The problem is *not* the extension, definitely. The problem is that people in the browser world assume that it is the _caller_ that specifies whether the file being imported is a "script" or a "module", and thus do not understand why they need to If we want full interoperability with ESM in browser land (and to some extent, with ESM in babel/webpack land), we can either convince them that Node's way is better, at least for Node, so would you please rename all your files to mjs, or we (as in the Node community) can go with the flow. Both are valid. (And I didn't want that to sound sarcastic. As I said, both are valid.) This is a TL;DR of my next blog post about ES Modules. Hopefully, you read the first part? (https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71)
This article is more I think about the realism of personal progression; that learning a framework is a start. I mean you basically said it yourself... using jquery lead you to learning javascript. Any job taken based on, say, jquery or react, will benefit from, and almost force, personal growth thru learning JS. Learn django &gt; advance thru learning python &gt; move onward and upward. 
'Your post gave me a monetary flask' of confusion for some reason. (srsly, that's what i saw at first glance)
That's definitely another way of looking at it, and it did help me, but I felt that I could have been much better with JS at this point in my career. I was learning when PHP was the biiiiig thing. Now when people learn, it's all about JavaScript. At least from what I've noticed.
I just looked up a few UK jobs pages to see what typical employee positions in front-end or full stack web dev are looking for right now, and while some certainly mentioned big name frameworks, few required one in particular, and others specifically mentioned needing solid JS and not relying on crutches. YMMV, but I'd guess that if you can't find anything that doesn't strictly require this or that JS framework, probably either you're somewhere with few web dev jobs available at all or you're looking in the wrong places.
this is basically what the article said (learn the basics then get a framework), and not really what the op of this subthread said.
Because saying it doesn't help anything. It's neither advice nor direction. It's just a statement. "hey man... i'm trying to figure out how to get to the post office." &gt; Learn how to drive. It's real easy to flop out an obvious point in a terse way. It's a fully different thing to actually help if someone wants to actually help. 
I had a similar problem with PDF.js. Increasing the 'scale' option (try 2.0 or just something &gt; 1) fixed it. https://github.com/mozilla/pdf.js/issues/7041
You do need to have a good grasp on JS before hand. I use frameworks all the time, different ones through different jobs and projects depending on needs/requirements. Do use a framework, learn them, it does help. Know what your fundamentals though. I‚Äôm not even sure how important knowing a framework would be in getting you through the door. If you‚Äôve got fundamentals, show a willingness to learn, you‚Äôre positive about what you do, and you work well in a team, this alone might get you an offer. It might be an offer that‚Äôs lower than what‚Äôs advertised on that job listing you‚Äôve seen, but if you get experience in a working environment, with said frameworks and a team you can learn from, do it!
I just wanted to make a quick hack. But yes, Node-red seems to be good stuff.
Yeah i was playing around with this a bit..where can i set the scale option? do you have perhaps a code snippet?
Seriously, who keeps doing this crap?
Tried to play the clicker game, and I got an error: SyntaxError: redeclaration of formal parameter other AnCore.js:197:6 note: Previously declared at line 191, column 29 AnCore.js:191:29 Looks like you could just remove the other argument from this function: /** Detects collisions between objects */ function place_meeting(that, other, x = that.x, y = that.y, angle = that.angle, poly = that.poly) { Edit: Looks like its fixed in your repo. I guess you just need to update it on your clicker game.
**This is shit advise.** The primary problem is the short-sided goal: *getting a job*. The short-side goal is shitty because of what happens next. Seriously ask yourself what the next goal is. You have a job, so now what? Obviously the next goal is *keep your job, and don't get fired*. That is incompetent. If you want to get a job writing JavaScript **practice** writing JavaScript. I cannot stress that enough. I have spent almost 0 hours writing against popular frameworks and this has never stopped from getting a kick ass job as a senior developer. I currently work at a Fortune 50 company that found me. If you can master these skills, really nail writing in the language, and software architecture you can side-step all this drama. You don't have to look for a job. The jobs will look for you. Seriously consider the reality. JavaScript developers are super high in demand. If you have trouble getting this job then maybe you aren't competent at it. This is where I get down voted because I told some millennial they aren't a precious snowflake and that jobs really are magically there only if they put forth insane effort without taking shortcuts on trendy bullshit.
I would never hire anyone that complains about having to learn javascript, bootstrap *AND* react. Learning is a key component of your job.
&gt; ‚Äúbachelors in CS or similar‚Äù This almost never matters, unless you are being filtered by HR drones.
That looks really cool!
I see the analogy work a little differently though, sometimes in - case a: hey man I'm trying to get to the post office: you give them directions to the office of the postmaster general or case b: hey man I need directions to the post office to buy some milk: The way I see your position is that you're saying to only give the person directions without informing them that the post office doesn't actually sell milk .
UI Devs aren't masochist :P 
[removed]
To remove an HTML element use something like this: myElement.parentNode.removeChild(myElement);
I would say... learn patterns. Frameworks are just a semi-random collection of those
check if `inputs` is undefined inside your for loop. inside function light, check if `inputs.parentElement` is null. Just a little defensive programming tips to reduce headaches in the future :) Other than that, I think it looks good.
Raw Chinese text of a chapter in a book
I have! I really liked the article, let me know if you want any other info from me as well :).
When I read your reply at first glance, I saw "Your pole gave me a mammary flash."
Reason but no mention of Elm?
Cool! Any plans for a Firefox version?
Is this in response to other systems that are showing up like Sanity CMS (has open source admin interface)? Or is your plan to fully open source the entire project (allowing for free self hosting?)
Stupid question: why not just send the client a PDF? Much simpler.
[Calculating Moon Orbit in Projective Geometric Algebra](https://enkimute.github.io/ganja.js/examples/coffeeshop.html#pga2d_physics_moon) Added a new example to ganja.js demonstrating numeric integration of the classic 2-body problem in the PGA framework. (using operator overloading etc in js). It calculates and visualizes the elliptical orbit of the moon around the earth. 
Maybe you didn't read it carefully enough because your last question was "where do I set scale" and it is shown on that page. Not far down on that page is this code: var scale = 1.5; var viewport = page.getViewport(scale); So start with that example and try adjusting the scale up if 1.5 isn't high enough quality.
I suppose I lose control about how PDF is displayed, then. If it's blob I can provide the same look-and-feel of PDF viewer regardless of the plugins installed on the browser.
(o)(o)
I definitely agree with this. When I was first learning React it was a breeze since I'd already had experience with other UI frameworks (Vue, Angular, and Aurelia). But getting over the Redux hurdle was difficult for some reason. It wasn't until I got a job using React and jumped into a codebase already using it that it finally clicked. Another thing that helps is reading the Redux source. Once I went through and read it (It's not that large, and pretty well documented) the light bulb really clicked. 
Nit for readers: TypeScript has function overloads, but they all end up describing only a single implementation. So while you're right, it's just helpful to give that bit of context.
Fair point. I guess it's better to say I would like to hire people who are enthusiastic about learning, or at can least tolerate learning.
I believe the idea is to clarify, as automatic semicolon insertion isn't incredibly clearly not relevant. That said, I agree with you.
You'll want to do this with CCS. You could use jQuery to do this in a script, you just need to inspect the document to find out each element's class name or id.
Some very odd style choices. You should check out eslint and use a popular preset such as airbnb's -- I've learned more through this method than through all Medium articles I've read combined. :P Other than that, would be nice to see a demo. I'm too lazy to load this into a page and figure out how to use it. :)
+1 for this, I refer to some GitHub projects a lot with huge folder structures.
Getting a 404 on mobile. 
`webshot-factory` is a bit more customizable in the fact that is can expose a callback on the webpage which the webpage can call to get screenshotted. This is helpful to use in your own apps/websites to generate reports or even run periodic tests.
I would love to be bored at work. 
It's up here. http://downforeveryoneorjustme.com/rollupjs.com
The problem is indexation breaks when you remove an item, I'd suggest having a "fruit" attribute for the "X" icon and then search for the fruit based on that. Check it out - https://jsfiddle.net/ffr42can/
Interesting idea. Yes, you could. Although given the distributed nature of the library, each screenshot will come from a different chrome instance. So, it would be great if the webpage shows something synchronized like a countdown, but might not be for something like an animation which starts from the beginning on page load.
Lovely, well done
I don't think React and Babel are gonna be abandoned any time soon. Same goes for typescript. Typescript and Babel solve really important problems that cannot realistically be solved any other way within JavaScript. React is also safe thanks to technologies like React Native that bring it to other platforms. Webpack I feel like is pretty solid but I can see it being replaced if we find something that is easier to use, since a lot of complaints are generally targeted towards that. With all this in mind, here are my suggestions: - Identify which technologies are more likely to die off in the future and try to limit your usage of them (do not use sub-stage-3 JS, avoid relying on Webpack too heavily by moving maybe towards Babel-plugins, etc). - Write great documentation for your code (code-level as well as high-level). Remember to be as predictable as possible in your code. - Write your code in sufficiently modular ways. This may mean separating in more files than usual and leaving places for new code to be hooked. Think of the gradual change you're doing now, this is the same process you want to make easy for the next group that has to rewrite it. - Add in layers of indirection that interact with your frameworks so that they can be swapped in later if necessary and possible. - Just because you can use a fancy new feature, does not mean you have to use it. Look twice at what that framework feature brings you and don't use those that are maybe just sugar or not really beneficial. - Add in annotations (through decorators maybe) to your code so that things can be automatically refactored later (at least, as much as possible). - To make React safe, realise that Javascript itself may have a shorter span than React. Therefore, beware of the way the async nature of Javascript may make your React code incompatible with other languages. Finally, realise that at one point your code will be obsolete. You can't really defend against it, just make the transition easier for the people that follow. And that is done mainly through sticking to the basics, avoiding hacks and writing great documentation. Cheers and good luck!
If I got that right, you need the inner element to change its color when the outer one is clicked. If so, use the third optional parameter for addEventListener: outer.addEventListener('mousedown', foo, true); Works for me in Chrome Version 63.0.3239.132
Vue is the only other one I've seen.
ikr, I've got enough work to last a lifetime without even trying to find some. 
Try this: function toggle_light(input){ input.classList.toggle('focus-input'); input.parentElement.parentElement.classList.toggle('focus-rest'); input.parentElement.querySelector('p').classList.toggle('focus-rest'); input.parentElement.querySelector('hr').classList.toggle('focus-rest'); } inputs.forEach(function(input){ input.addEventListener('focus', function(){ toggle_light(input) }); input.addEventListener('focusout', function(){ toggle_light(input) }); input.addEventListener('mousedown', function(){ inputs[i].focus() }); })
Yeah no, that works here too. Chrome 63 on Mac.
no, I want it to behave like the 'commented' jQuery one
haha, vanilla strikes back! I won't even try it ;D I will tell u what happens, inputs is not a function so lets keep the for loop with indexes, lemme check rest ok this is nice, idk how I didn't thought of that, I just knew jQuery has toggleClass and I forgot to check whether vanilla has :DD just cut half function and 1 parameter of each func thx! 
case b is actually a description of an XY Problem (asking the wrong question when looking for help with a (programming) task) &gt; you get to the post office like this, but why are you getting milk there? &gt; you use a loop like this if you want to go thru items in an array... but `forEach` is actually better (with mdn link). I dunno man... it really I think comes down to style of mentoring. Personally I tend to help people stretch themselves, whatever the topic. I generally assume that people aren't idiots, and that they're capable of understanding the specifics in what i'm talking about. . . and if they don't get it, I explain it. 
dude you win I'll take that mammary flash . . . from sufficiently attractive mammary.
&gt; I felt that I could have been much better with JS at this point in my career. Ok look, subject change . . . That's a mistake, a trap that A LOT of people (read: me) fall into. The whole "Maaan, I shudda". You know what? (and I'm saying this to myself as well as you) You didn't (learn it), ***but that's ok***. It's in the past, nobody got hurt and it's water under the bridge. You know what you need, you've made the goal, and now you have motivation and direction. Right? [Godspeed](https://cnet1.cbsistatic.com/img/Qz83RFvM0J87KfxuvLZAhmXzRes=/fit-in/970x0/2015/06/04/0baaf113-8608-4bf6-9fc8-49120dbfa24a/shialabeouf.jpg). [Godspeed](https://i.imgur.com/kMtzV.jpg).
with all the people trying to force types into JavaScript it won't be long before it becomes Java
&gt; You know what you need, you've made the goal, and now you have motivation and direction. Right? I sure have! I remember when I was let go from one place because my experience was lacking. At that point, I had to make a decision to either pull up my socks or give up. I did some online courses, learned some new stuff, and learned a ton. I had realized that there was a part of coding that I really liked. 
Here's a Codepen that shows how to do event delegation: https://codepen.io/rbiggs/pen/YYOqGp. The way to do delegation is to register the even on the parent of the elements you want to test. You use the event target to test for appropriate targets. You can use any value. Your divs had ids, so I used those. I also added a button. Since there's only one button, I test for its nodeName, which would equal "BUTTON". You could use a class name as well. Or any other property on the event target that would distinguish it from other possible event targets. Hope that clear. I use this technique all the time.
The problem is this approach for what you describe is really kind of complicated to do in JS. The thing is... your object is not just "an instance with a method".. it's just a piece of data. So what if the piece of data happens to carry a function with it that turns it into a string? Even in Haskell certain aspects of programming are more easily done by declaring a data structure which contains a function in it.
I'm not sure what you mean by making the text a bit smaller to fit the header. I mean, its obvious the header doesn't look right, but what do you want to make smaller ? Either way, both those things can be achieved with CSS only, no need for Js. The trading view thing is easy, the element even has it's own id. So, add this to your css #tradingview-copyright { display: none; } Although, if you are using their services, you should probably find a way to keep it in your page.
[Well done!](https://www.youtube.com/watch?v=535Zy_rf4NU)
I'll put something on github pages asap :) But the usage is very simple: you create a container with position:relative and all the children are absolutes widht display:none. You can manage everything that's not mandatory via css. The script takes care of positioning and moving, all the children can be seen as a circular buffer.
What can you show? That‚Äôs what‚Äôs important.
What on earth makes you think "getting a job" and "not getting fired" are the end goals? Getting the job can't realistically be anyone's end goal, but it represents a specific milestone: the point at which you can be paid to learn more, rather than doing it in your spare time. And honestly, for as good as the money is in our field, it's borderline irresponsible for someone to stick around in a $50k/yr marketing job learning to code on the side until she achieves some arbitrary standard of mastery, rather than jumping into the first developer job she can land and filling in the gaps in her knowledge as she goes.
&gt; This is shit advise. &gt; That is incompetent. xd
Good God, no. 
you know what stands out to people making hiring decisions? things you've built and problems you've solved.
&gt; What on earth makes you think "getting a job" and "not getting fired" are the end goals? You answered your own question in that last long statement.
Redux is definitely the difficult part to grasp. 
Back a lifetime ago I did some freelance design (newsletters and what not) so I totally get the whole "listening between the lines" part. It's a fine skill to figuring out that the client doesn't know what they want ***without telling them***. To the point tho, the devil is in the details. The mentor you speak of; it sounds as if you were never left hanging on a "you need to learn about prototypes", which not only helped you in the moment, but fleshed out your skills long term. (and now I'm going to check out that course)
thx
I should really be working on my own projects, but I made [this](https://jsfiddle.net/ffr42can/2/) for the fun of it. made it in to a module that handles the adding, removing, saving and rendering. You can use the input to add a single fruit, or add a comma separated list to add multiple at a time. Remove has the same functionality when using the myList.remove() method, but not setup in the example. There is a button to toggle the auto save on change behavior, and a reset button to restore to the default values. you can see the results if you make some changes with save on, then just hit run again after adding or removing some elements, or see how if save is turned off any changes are not applied when hitting run again.
I understand your plight, man. So I guess the best approach is to make impressive projects? Could anyone tell me how they improved their LinkedIn and overall social media game? Mine are basically non-existent, and I‚Äôm hesitant to put odd jobs and random feats in un-related fields on my LinkedIn page. Thanks for posting op.
http://imgur.com/gallery/NNzJ8G8
Sounds like a good way to raise developers to think that the `map` function is a React thing.
That doesn't exactly answer your question, but you could try something like Es6-shim or run your code through Babel before putting it into GAS.
ES modules, don't rely on complex webpack transforms, trust React's smallest API footprint, and use minimal CSS preprocessing if any at all (use css variables, they rock). Sure this cuts down on a lot of fancy new tools, but you're investing for future tooling that may radically rethink how bundles are produced.
&gt; The reality is, an engineer with a marginally working application using the libraries required for the job will always trump an experienced engineer knowing the language to someone who doesn't know how to program. That doesn't make any sense. Your statement expresses a binary comparison, but lists three types of individuals: library user, experienced engineer, and somebody who doesn't know how to program. Anyways, I completely disagree with your position. In my experience rockstars always trump framework peddlers in the job interviews. Knowledge of the framework in use is desirable, but experience making architectural decisions and solving hard business problems is **more** desirable.
So, no.
Really? Literally everyone I know who's tried to get paid to do their hobby, whether it was building vintage race cars or stuffing meat into sausage casings, has ended up hurting financially, and usually hated their hobby by the end of it. This idea that anyone who didn't grow up teaching themselves 6502 assembler is somehow going to be an inferior web developer in a junior role needs to die. It's classist in ways that people more qualified than I have written volumes on, plus it ignores the fact that there are about a million times more developer jobs than there are kids who grew up teaching themselves 6502 assembler.
The State of Carpentry in 2018
yeah, that would be the best way to go at the moment but it's kinda disappointing that it's 2018 and Google doesn't support ES6 natively, isn't ES7 coming out soon or something? 
[People](https://github.com/whatwg/dom/issues/544) proposing Observables to be part of DOM used similar style. It's just like that guy who placed all semicolons to the far right to avoid them. Snippet from the link: element.on("click"). filter(e =&gt; e.target.matches(".foo")). map(e =&gt; ({x: e.clientX, y: e.clientY })). subscribe(handleClickAtPoint); 
Thanks. I may contact you, for the second post in the series. I've been reading all I can on the web, but it's difficult to understand the various pros and cons of all the suggestions, as they are all interconnected to each other, and they are so *many* considerations. Hopefully, writing the second part will make me understand it better, as writing the first part (and the talk I gave) made me understand what you did in NodeJs concerning ESM. And great work, BTW! You all succeeded in getting some code into Node, for one of the more contentious issues in Node today. 
That probably was a temporary error, sorry for that!
That's a rule !?
I've actually implemented that beast before. I was capturing a Flash client to make a recording of a live event. Not sure if it was the Flash, but we topped out about 8 FPS. The video had to be synched with a separate audio stream later, so there was some effort put into keeping keyframes at the right timecodes. 
Username doesn't check out, I can't edit your comment
Was kinda curious about that too, I just read about Reason recently and while it seems cool, I don't immediately see what it has to offer over other functional compile-to-JS languages like cljs or elm, nor does it seem to get much positive buzz (or any for that matter). If it had a good JS interop story (including Node) I would probably give it a shot. 
Simply ignore the requirement, it doesn't mean anything. Most frontend interviews will focus on: -A combination of questions similar to these (especially the ones on scope): https://github.com/h5bp/Front-end-Developer-Interview- - Rudimentary practical knowledge of CS fundamentals/algorithms (as in, not knapsack problem or binary search, more like stacks, queues, hashing, maybe some simple graph algorithms tops) - Questions about how you would do x in framework y that you listed on your resume, what are the disadvantages of doing z, etc. Nothing too complicated, they just want to see if you know how the stuff you're using to get the job done actually works. Networking helps, but even without that, if you're solid in JS/webdev, have been doing in for 2.5 years, can demonstrate that, and are not a rude or defensive person, I say you'll land a job in less than 3 months after posting resume, possibly without even applying anywhere.
[Not sure if joking but](https://www.reddit.com/r/javascript/wiki/index#wiki_posting.3A_advertising_.26amp.3B_self-promotion)..
Yeah learning a framework is all well and good, but the skills aren't really transferable.
You're totally right. Sprockets doesnt provide that at all, i was just going for the most basic explanation i could find. Getting data, transforming it and pushing it to q chain of loaders.
The rules said you had to link to a project page with unminified code OR a write up about the development process OR a working codepen. I thought 2 out of 3 was the least I could do :)
On my current job, they required bachelor degree, 3 years of experience. I got the job with 7-8 months of experience and no degree. I have talked with people who hire people(the tech ones) and their answer was always the same. We look for attitude. 
I use http://element.eleme.io/#/en-US - despite many advantages (multilanguage, community, frequency of updates) it's possible to just cherry pick interesting components not whole library. Downside - it's not intended for mobile, however I use it in RWD theme and there isn't anything I can't live without.
Very slick, looks like a good fit for Electron stuff too. 
I have a coworker who enforces that. Best part is when your cursor is at the end of the line (directly after the dot) and you press enter. Then the IDE suggest something and you insert it instead of creating a new linebreak.
This is actually awesome! I wish I had time to port this to Firefox.
jQuery, obviously
[Ant](https://ant.design/docs/react/introduce) is pretty nice. It's made by Alibaba. Lots of components, small size, and component based, not a css wrapper. They have a [mobile version](https://mobile.ant.design/docs/react/introduce) as well
Look into phaserJs as well
&gt; This idea that anyone who didn't grow up teaching themselves 6502 assembler is somehow going to be an inferior web developer in a junior role needs to die. 6502 assembler isn't web development. You cannot become a rockstar without learning to identify and solve really hard problems. You will never get that on the job, because if the problem was really hard they would not assign it to an untrusted amateur. Learning to program is a skill, like playing the piano. It comes down to hours of practice. There isn't a magical shortcut. I have often seen people try to cheat this in various ways, but they only fool themselves and other mediocre people. The real proof is in the quality of product, speed of delivery, and speed of its execution. A framework isn't going to answer hard questions for you. It isn't going to solve accessibility or security for you. It is an architectural convenience. That isn't necessarily bad, but it isn't a shortcut to competence either. If you want to be more than mediocre in anything you have to be willing to independently learn to solve for improvements.
I believe you can't freely use Microsoft Fabric - only with connection with Microsoft API's: Fabric Assets License and Guidelines 1. License Grant. Microsoft grants to Developer, a non-exclusive, revocable, worldwide, nonassignable, non-transferable, royalty-free license to use the Fabric Assets (defined below) or a subset of them (e.g. the ‚ÄòToolkit‚Äô) exclusively for the following purposes: ‚Ä¢ In connection with the use of a Microsoft API within the development of a software application, website, or product you create or a service you offer designed to provide access or interact with a Microsoft service or application (‚ÄúApplication‚Äù) ‚Ä¢ To illustrate that Application integrates with one or more Microsoft products and services. 
Thanks for pointing that out!
And here‚Äôs a lovely resource that get stuck into for anyone who is interested in is design patterns: [Addy Osmani JS design patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/) 
Thanks @occz. I don't have any plan yet but PR is very welcome!
I'm very glad that it's helpful to you. PR is always very welcome :)
I‚Äôve used Semantic UI on a few projects. Compared to other UI frameworks in React, Semantic has a LOT of customizations for its various components I‚Äôve also used Material in the past. While it looks cool and Googlely, the UI design language itself is actually counter intuitive if you‚Äôre building a larger application that requires more finite controls. Material‚Äôs good if you‚Äôre building a small to medium size app with limited functionality. 
[React Toolbox](http://react-toolbox.io) is my cake to go 
Good to know, i read somewhere that it would only apply to the font. I haven't used it yet in a public project, only ran some tests.
Agree with ant. They have quite a bit of keyboard and aria attribute support baked in as well.
font and icons i think.
Why would this be a better approach?
you're right, it should have been input.focus, as for the rest, in my view your approach is cool and stuff, but it makes the code harder to read.
Redux isn't a UI framework
OP means a UI framework, not a state management library.
I agree it's ES6 and stuff, just learned about the `for of` is cool but it's harder to read for sure, altho you made a "map"? 2d array or what's called so you could add more listeners from outside (if it would be global), but overall good to know ty
It's **Fabrics Assets License** not **Fabrics** license. UI library itself is MIT and you can use it freely. You can't use fonts and icons out of developing plugin to one of Microsoft's Office programs. https://github.com/OfficeDev/office-ui-fabric-react/blob/master/LICENSE
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [OfficeDev/office-ui-fabric-react/.../**LICENSE** (master ‚Üí 88fd649)](https://github.com/OfficeDev/office-ui-fabric-react/blob/88fd649d875b4535914e9a1f809aa6ac48a613ee/LICENSE) ---- 
You are right, it applies only to assets - i.e. fonts and icons. https://github.com/OfficeDev/office-ui-fabric-react/blob/master/LICENSE https://static2.sharepointonline.com/files/fabric/assets/microsoft_fabric_assets_license_agreement_sept092017.pdf
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [OfficeDev/office-ui-fabric-react/.../**LICENSE** (master ‚Üí 88fd649)](https://github.com/OfficeDev/office-ui-fabric-react/blob/88fd649d875b4535914e9a1f809aa6ac48a613ee/LICENSE) ---- 
Grommet has a commitment to accessibility that the others lack (significantly in some cases).
the controls make no sense to me, I use both Azerty and Querty but his is weird
I prefer ReactStrap, it's very simple to use, supports Bootstrap 4x and is well maintained
1) Not a clue. 2) I use it to create web apps, websites, mobile apps, desktop apps, servers and command line tools. 3) It's the most popular language right now. It's definitely worth learning more about, but I recommend not studying the language on its own, but rather in parallel with building any kind of an app / tool. 4) Visual Studio Code. This is actually an IDE created with Electron, which is a JavaScript framework that allows you to create cross platform desktop applications! It's open-source and developed by Microsoft. You'll find a strong community and good docs to back it up. Many use it, and it can be as complex as you need it to be, but it's much essier to start using than WebStorm, imo.
They decided to roll-up some and disappear in smoke. Joke aside: https://github.com/rollup/rollup
Its fantastic but just not as complete as i'd wish it would. Semantic ui itself seems to have stopped development so i don't know how much we can actually count on it for the future. 
Thanks for clarification
Sounds like my experience with recruiters! :D
1) No idea 2) Historically it's for web apps / websites but today it's a serious language for mobile apps (React Native for instance) or servers (NodeJS) 3) I don't know if it's THE most popular language (depend on what you mean by popular) but it's clearly one of the most important languages of these last years and the future is full of JavaScript so yes it's definitly worth learning more about. A term of performance, it's damn good since the v8 engine. 4) I use Webstorm and used Sublim Text. Both were fine (Webstorm is a lot more powerfull but not free). 
There's also Element (great UI library for Vue) version for react - https://eleme.github.io/element-react/#/en-US/quick-start I don't know about it's maturity
Why should they? Whatever version they support now, gets the job done.
Link works.
Excellent. Thanks for the advice. I will definitely work on bolstering my portfolio and continue from there. Casting a wide net sounds like the way I'll need to go as my tech network connections are not that strong. Really appreciate the feedback!
Thanks
Thank you, I had no idea it could be done like that
Woah, that's cool, how do you even come up with that
Pixi.js!
I'm confused, I'm new to the react world, are UI frameworks like css frameworks? Like bootstrap but for react?
I like Pixi but I'm sure you could do all of this Natively! Natively you say? yes. checkout css variables: https://css-tricks.com/making-custom-properties-css-variables-dynamic/ you can move it using left: 0%-100% using CSS animation. you can animate the up and down motion using a css animation.
so, for moving use: J for left, L for right, I for up &lt; for down see the pattern? and for rotation it's just QWE ASD please let me know if it helps
BlueprintJS and Antd - Undoubtedly the best ones.
Good bot. 
Pretty much. 
No! I'm organising a party and It's a drinking game I'm going to build in Vuejs with NFC tags for all guests to enter the race.
I had it for free indeed :)
Customizing material-ui 0.x was painful and irritating. However working with 1.x is been pleasing while dealing with small-medium size app. It also provides decent look on mobile screens.
Semantic UI React
Are react devs trying to not use CSS or something? CSS is great, I wish more native app frameworks had renderers for CSS. (Like electron, but actually native instead of running a whole web browser) 
Yea, no point in ever improving anything.
 &lt;Alert bsStyle="warning"&gt; Why would you learn new tags instead of just using JSX and Writing your custom components like regular HTML/CSS? Is that for people who aren't proficient in "regular" web development? 
Wow, Ant looks fantastic. I must say that the chinese are pumping out such great opensource projects. 
So many, I work on several apps that use esm exclusively and very rarely do I encounter modern packages that don‚Äôt support it. Here are a few off the top of my head: Ramda, Vue, Vuex, moment, animejs, angular 4, jquery
I also used material ui for my last projects and I must say that I encountered more bugs than I'd liked. It looks great and some components really work well, but some component combinations just don't work at all or not well together.
&gt; 6502 assembler isn't web development Of course not, but it speaks to a certain personality type and willingness to take on an esoteric hobby. I brought that up because I had a friend who did that, many years ago, and got involved with the chiptune community. She's - surprise - a developer now. &gt; You cannot become a rockstar without learning to identify and solve really hard problems. You will never get that on the job, because if the problem was really hard they would not assign it to an untrusted amateur. This might be the most salient part of your post, but I think there are plenty of opportunities for newbies to work on hard problems at smaller companies and startups - I'm "fortunate" enough to have worked on some real nightmare problems at my first job out of the coding bootcamp I went to.
Here's a [site I made](https://edabit.com) with Semantic UI React if anyone is interested in seeing a real world example.
I love this one but without a date and time picker it is really inferior.
 Wouldn't it be better to just wait for the production release of after-after.js? 
Why should I read this? Who is MoLily.de? What authority do they have?
Yep same here, I've used material and it had a bunch of little bugs that made it a pain in the ass to use. Semantic is great though. 
Exactly!
I like this [Bulma](https://github.com/jgthms/bulma) implementation - called [ReBulma](http://bokuweb.github.io/re-bulma/). Really simple and really easy to use. EDIT There's also [Bloomer](https://github.com/AlgusDark/bloomer) and [react-bulma](https://github.com/kulakowka/react-bulma)
For the first question: The CodeHS environment does not look _dumbed down_, just basic and "student friendly". It _does_ do a number of things for the student. This means that you're running in an environment where, from a brief glance I just gave it, it doesn't seem like you're being _limited_ in any sense, but you _are_ being given a number of facilities you'd normally have to set up yourself. As an example, you have some output functions, such as `print` and `println` which are provided to you and print out to the IDE's output panel. Another example: You have a `canvas` element already created for you and a number of global utility functions such as `getWidth` or `getHeight` and a number of helping objects such as `Circle` or `Rectangle` you can create and use. Now, I don't think this is any sort of _dumbing down_, but it is giving you a batteries included environment that generally distances you a bit from the actual lower level code.
+1
Good idea, thanks for sharing!
Interesting, thanks for sharing! Do you plan on keeping it updated?
Not to sound condescending but that‚Äôs sounds like less than 5 projects in the world. 
This statement seems really privileged to me. Getting a job is the end goal for people with no money. Its all about the money
Cool, how long time did it take you to create it? Did you use any reference / tools when doing it?
If you don't loose anything on applying, why not?
In case you missed /u/GrzegorzWidla's reply, /u/nightman was mistakenly referring to the license for Fabric's assets (e.g., the font), but Fabric itself uses the MIT license.
If you could make anything (realistic) what would it be?
There is [this one](https://github.com/mdehoog/Semantic-UI-Calendar), I haven't used it but the demo makes it seem like it'd fit in nicely with the other components.
Yeah, there weren't any big updates in quite a while, which is a shame...
SemanticUI's an awesome project for getting any project up and running ultra fast - it just gets out of your way. Another project that's equally as awesome is [UIKit](https://getuikit.com/) as it's super easy to customise especially when using Sass. If you're using webpack it shouldn't be an issue [integrating](https://getuikit.com/docs/webpack) UIKit into React or VueJS or any modern front end framework.
Thanks. I was confused by that, too.
They often go a step above just the layout/visual components and include JS to implement actual interactions. For example: * Bootstrap will help you put a nice looking button on a page * a UI framework will put that on the page and help manage the underlying complexities.
Uh... what? I meant it as the person you're inevitably interviewing will not know how to program, so an engineer that can show they know the library is no different than an engineer that knows the library and the language. Hiring managers inevitably are only trying to match resume libraries with job description required libraries. If you read the article, it only hearkens my point: that software engineering is extremely biased towards people who can be perceived as knowing what they're doing, instead of people that do.
[Ant Design](https://ant.design/) -- Great look and feel and easy to use components.
I'm a big fan of the [React-Widgets](http://jquense.github.io/react-widgets/) library for more specialized inputs. Has a great date/time/datetime picker, calendar, numeric spinner, and some dropdown/checkbox controls.
My #1 problem with Ant is that it affects global styles - for instance, it puts a :hover color set to blue on all &lt;a&gt; tags, so you can't just drop Antd into a project to use one component without completely screwing up your CSS. 
I was working on it on and off on weekends, took 2-3 months to finish. I used Babel to transpile ES6 code, other than that, it's just JS+canvas
&gt; This statement seems really privileged to me. I taught myself how to program while away from my family for two years in Afghanistan. To me privilege is hearing about people bitching and crying about how they can't get that programming job when the jobs are so incredibly in demand that companies are having trouble filling them. If people really **really** wanted to get that programming job they would spend more time programming and less time bitching about how hard life is. They should spend less time crying to their friends over a beer at the bar and spend more time with fingers on their keyboard.
thanks!
I still disagree with all of that. Hiring managers are not HR recruiters. They are trying to hire the people they would prefer to manage. No hiring manager, in all of my experience, is simply trying to put bodies in seats. That is what recruiters are for. &gt; If you read the article, it only hearkens my point: that software engineering is extremely biased towards people who can be perceived as knowing what they're doing, instead of people that do. That comes down to the competency of the interviewer. Vaguely competent interviewers know when a candidate is spinning their wheels and blowing smoke. It is simple if they are experienced enough to ask hard questions outside of framework comfort.
Imagine you need something more complex - a date picker with calendar view, ability to switch years, months, select a span of several days. Unless such date picker is essential to your product or service - think Booking, AirBnB or Kayak to just name a few - you shouldn't really spend time developing custom one. Pure JavaScript implementation don't work well with state driven frameworks like React so we're looking for React components to fit the need. Now add to that several more seldom needed components and library becomes a reasonable choice. There are also 2 more use cases: 1. Prototyping - library like Semantic UI has nearly everything from buttons to tabbed layouts so you can mock data and work on the layout directly in code and browser. 2. Common components - you shouldn't be creating the same components in every project from the scratch. Big companies can create their own libraries that the re-use across projects and they often do (not all the time though) but smaller ones really can't so they utilize external solutions. Add to that complex problems like accessibility and you'd end up spending hours upon hours to just craft components that you can take from somewhere else.
I understood those were the binds but why no regular wasd ? or just the arrows as main movement?
[react-md](https://react-md.mlaursen.com) is my favorite so far. Really great UI library considering it's being developed and maintained by a single guy.
Nobody is bitching about how hard life is. The article is about suggesting the reader learn a skill, not about millennials demanding jobs. Whats wrong with you?
Style should be separate from logic. I've imported components into react projects, for example, a searchable dropdown selection box, and I expect it to basically not have any style, and that I will style the box myself with my own CSS. Or, if I'm using bootstrap, I expect the selection box component to be easily set as the default bootstrap style by simply assigning the component the appropriate class. The things you're describing do indeed sound easier, though they don't sound like good practices. It seems to me that React components are not following best practices if they come with styles built in.
&gt; Is JS considered a powerful language? What does this even mean? You are mixing this up with fantasy films and "magic languages", where experienced wizards or mages speak some ancient "powerful" language with "words of power" :-) It's (just) a programming language. You can make it "not powerful" by only outputting Hello World!" -- or you can make it really, really "powerful" by letting a piece of software writing in Javascript control the firing of an ICBM. Or what exactly do you mean by "powerful"? Any software is limited by the hardware, and what we have still cannot do more than a Turing machine. If you want to understand what computers can do you could (should?) start with assembler. I'm quite serious. There are great tutorials (Google is your friend). If you understand what actually happens (in the hardware) you'll be very well equipped for higher level languages. You don't need to take it (assembler) very far, just some basics about I/O, ports or memory-mapped, interrupts, registers. Everything - all those "languages" - are on top of the exact same kind of hardware. Even different families of CPUs (ARM or Intel, for example) actually are pretty much the same basic principle. This is what limits anything you build on top. Whether you feel more comfortable with this or that type of higher level language (e.g. purely functional vs. purely procedural or purely object oriented) is very much a matter of personal preference (you can mix the methods, pragmatic languages let you do that, e.g. Scala or F# - or Javascript, to a degree all major languages allow being used with different styles).
How do you want dropdown component to work without CSS? There are certainly components that are as basic visually as possible and then there opinionated ones but you can't get self contained dropdown component without some `position: absolute` etc.
Valid point!
The article is suggesting that the fastest path to getting a job is jumping into a framework. The motivation is to be under prepared in order to get paid now. A short cut. Learning JavaScript and how web technologies work is a skill. A framework is a tool, not a skill. If somebody were interested in learning a skill and does learn that skill they won't have any problem getting a job. This isn't a secret science. &gt; not about millennials demanding jobs The article is entirely about getting a job.... opposed to learning a skill. It is even in the article title.
It's similar to what [webcomponents](https://developer.mozilla.org/en-US/docs/Web/Web_Components) are trying to achieve and from my understanding it's similar to how a lot of frameworks work. It's just nice to be able to contain all the code and functionality that relates to an element and it's behavior, and helps with namespace issues. I did just notice that I accidentally called the remove function when trying to add a single item. I fixed it [here](https://jsfiddle.net/ffr42can/3/)
the arrows should also work, I was aiming for using laptop and you don't have keys like leftUp or rightDown on a regular laptop The move binds were coped from the original Dos game
Once again: Getting a job is the point. Getting paid is the point. To think otherwise is a mark of financial privilege
The paths in the html are relative (don't start with a '/') and the one in the onclick eventhandler is an absolute path (start with a '/'). That's probably causing your problem. 
Thank you!!!!
I made a fetch wrapper with async/await with lots of features built in. Check it out at https://github.com/CorentinAndre/next-fetch
This is becoming circular. You have run out of anything worthy to contribute to the conversation and so have become repetitive. I have already directly responded to this.
Let's be honest about Aurelia, it's not really happening, is it?
Menu won‚Äôt hide on mobile. Kind of throws me off for a UI kit haha. 
&gt; Is JS considered a powerful language? What does this even mean? You are mixing this up with fantasy films and "magic languages", where experienced wizards or mages speak some ancient "powerful" language with "words of power" :-) It's (just) a programming language. You can make it "not powerful" by only outputting Hello World!" -- or you can make it really, really "powerful" by letting a piece of software writing in Javascript control the firing of an ICBM. Or what exactly do you mean by "powerful"? Any software is limited by the hardware, and what we have still cannot do more than a Turing machine. If you want to understand what computers can do you could (should?) start with assembler. I'm quite serious. There are great tutorials (Google is your friend). If you understand what actually happens (in the hardware) you'll be very well equipped for higher level languages. You don't need to take it (assembler) very far, just some basics about I/O, ports or memory-mapped, interrupts, registers. Everything - all those "languages" - are on top of the exact same kind of hardware. Even different families of CPUs (ARM or Intel, for example) actually are pretty much the same basic principle. This is what limits anything you build on top. Whether you feel more comfortable with this or that type of higher level language (e.g. purely functional vs. purely procedural or purely object oriented) is very much a matter of personal preference (you can mix the methods, pragmatic languages let you do that, e.g. Scala or F# - or Javascript, to a degree all major languages allow being used with different styles). I come back to recommending looking at assembler programming (to make this recommendation even stronger). I think (from own very long ago experiences) that if you understand the lowest level it will give you a lot of confidence. I'm not making a concrete recommendation because the concrete assembler language depends on the CPU, and which one you choose does not really matter. An ARM based assembler course might be easier, maybe for small embedded systems (without an OS, 32 bit ARM CPU and 32 kByte of RAM), Intel (and AMD) CPUs carry a lot of ballast from being compatible to ancient designs. If you want to continue with Javascript though I recommend this course if you want which uses Javascript to do biology simulations: https://www.edx.org/course/nature-code-biology-javascript-epflx-nic1-0x &gt; If you are interested in learning programming, but find pure programming courses not very exciting, this course is for you. &gt; Instead of just learning programming principles outside of any context, you will learn JavaScript programming by implementing key biological concepts in code so they can run in your browser. &gt; If you know a little (or a lot of) programming already, but want to learn more about the rules that govern life without having to pick up a traditional academic textbook, this course will also be of interest to you. You will learn some key ideas that form the basis of modern biology, from population genetics to evolutionary biology to infectious disease spread. &gt; No prior programming knowledge needed. The course does have slight weaknesses, a professional programmer would write a few things differently, but I don't see a problem recommending this to a beginner.
Link?
https://github.com/airbnb/react-dates
Or friday-after-next.js
http://google.com
I like the interoperability personally (great type safety) but as far as I know the plans for server side Elm don't even include node. Evan had mentioned developing a ground-up solution when Elm gets to the server so that it can really excel in that domain.
Interesting to see that this is from the same guy that made [Razzle](https://github.com/jaredpalmer/razzle). I don't totally see the appeal to use After.js, maybe I'm not getting the difference from Razzle though.
It's about not reinventing the wheel. Sure, you could make all those components yourself, but if someone built a library of components that consider things like accessibility, responsiveness, etc. and are full of features that you want, why wouldn't you just use those instead of doing all that extra work? If you're building a large application and want a unified UI, you're going to do that kind of thing anyway, and most of these libraries allow you to customize the styling so it doesn't look like every other site. It also provides a nice baseline for those who don't know CSS and design like the back of their hand, and just want to get started on the UI. I've been doing web dev for 7 years and I'd still rather use a UI framework than build all that CSS myself.
Atlas Kit is clearly under the radar and it deserves a lot more attention https://atlaskit.atlassian.com/components
You can also use response.ok to check for successful responses instead of using the status codes
Yup, currently making a site with semantic and we're using the airbnb datepicker as well. 
&gt;But don't focus to much on JavaScript server side programming because most companies are still using PHP. In the US, only shitty web agencies building interactive brochures that you don't want to work for. The rest of the real world is still using some combination of Java, C#, Ruby, Node, or even GoLang. Most decent modern companies barely even have backends that directly serve frontends that's not through some API, so there is no need for some bastardized template language like PHP. If they do have a dedicated frontend API Gateway that does basic translations and some serverside rendering optimizations, and they are modern, then it makes the most sense to build that in Node. It's 2018. Time to catch up. 
I agree that eslint recommended is a good starting point. But I am of the opinion, that if you want people to follow you, you have to give them a "voice". Having a few discussion on some rules may get messy (it can be hard), but at the end you will have the whole team agreeing on a set of rule and feel like they are their rules, instead that let them feel like they do not count anything. 
&gt; it's
Must have missed that this is finally getting into the browser. https://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues Though no need to use expletives. After all, for decades, crypt was not part of the browser. Well, how things change https://caniuse.com/#feat=cryptography Cheers,
In my experience, there's no such thing as a set of rules that people agree on. My opinions on eslint and prettier are different from that of my co-workers and no amount of dicussion will lead to an agreement. We don't _agree_, we _yield_ because ultimately we understand that consistency trumps personal preference - that's literally the whole point of using eslint/prettier. Giving your team a voice is an entirely different can of worms. Lint rules are probably the easiest place where you can end up encouraging loudest-guy-wins dynamics. Some people are naturally more vocal and articulate more tirelessly, so giving people space often involves understanding their perspectives, strengths and goals (via one-on-ones, etc) and planning work in a way that lets everyone contribute to the best of their ability.
I found [Blueprint](http://blueprintjs.com/) and like it so far.
I love [mui.css](https://www.muicss.com/). It's lightweight, based on material an does not get in your way. Mui is a general CSS framework but it has has a number of (optional) react components. 
I love Semantic UI, but it hits the top of these threads all the time. It might be underappreciated in the corporate world, but it's most definitely not underappreciated on Reddit. I've used it for pretty much all my React projects that aren't heavily branded, though. Really is an amazing framework.
It certainly looks nice, but it doesn't seem like it would be compatible with React... ?
Yeah, first we could teach you that Java and Javascript are completely different languages.
Sweet, I was trying to avoid writing my own 'form data in URL' library for a pet project.
If you know regular Bootstrap, then sure, it can work "just as well," but something like React-Bootstrap gives people who don't have experience with Bootstrap access to its functionality through a React-based API. I would argue that it is better to create abstractions that reduce the complexity of an API than it is to try to stay as native as possible. Also, just a personal note, I would advise against using CDNs where possible. Using a CDN for something like Bootstrap means that your UI has a dependency on a network resource that you have no control over. If that CDN goes down or is compromised, you just lost your styling for your site. Bundling Bootstrap in with your site's code is safer and more performant.
True. No developer is going to last long in this field if you're not open to learning new things. With great compensation comes great responsibility, heh.
Can you help me out? 
&gt; more performant. That's not true. A cached CDN resource will be faster. &gt;means that your UI has a dependency on a network resource that you have no control over. What is a fallback my dude? .NET 4.5 web platforms have fallbacks built in. I'm willing to bet most modern web frameworks have similar structures in place. &gt;create abstractions that reduce the complexity I disagree. Abstractions don't inherently reduce complexity. They reduce difficulty, but things are just as complex behind the curtains. I can tell I'm not going to agree philosophically with most developers on this sub because I don't agree with nodes dependency system. 
Unfortunately no, this is not a support forum. You could try something like /r/javahelp 
Here's a sneak peek of /r/javahelp using the [top posts](https://np.reddit.com/r/javahelp/top/?sort=top&amp;t=year) of the year! \#1: [\[x-post from /r/learnprogramming\] Books that helped me grow as a junior Java developer](https://np.reddit.com/r/javahelp/comments/6ze1l4/xpost_from_rlearnprogramming_books_that_helped_me/) \#2: [I just wanted to say thanks](https://np.reddit.com/r/javahelp/comments/6v1hqb/i_just_wanted_to_say_thanks/) \#3: [I think I found piece of code which is 8 times slower on java 9 than on java 8](https://np.reddit.com/r/javahelp/comments/7b5erh/i_think_i_found_piece_of_code_which_is_8_times/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
No time picker unfortunately, but just for dates and ranges it's pretty cool. 
I liked this one a lot initially, but then came to see that this framework was really lacking in a11y support. When I then went through it's github issues list, it seemed like the core dev(s) had really no clue how to approach a11y and expected pull requests for elementary things.
Please don't forget to consider accessibility support in your decision. Lots of people are suggesting Semantic UI here but I've found that to have very poor support for a11y. We use React Bootstrap, which isn't quite as visually flexible as Semantic UI, but it does include a11y in its core feature set which is otherwise a non-starter IMO.
1. No idea 2. You can execute code inside of a webpage, on the command line with Node.js or in a desktop application with something like Electron or nw.js 3. JavaScript averages (real world use) about 1.8x slower than Java or about 4.5x slower than C++. In purely numeric algorithms used for running micro benchmark tests JavaScript is 4-9x slower than Java. Java and JavaScript are completely unrelated languages but neither manages memory in a high performance way as both are utterly reliant upon garbage collection. 4. VS Code (free editor from Microsoft)
It's been in browsers for ages. Chrome: 2011 Firefox: 2013 Internet Explorer: 2013 That is 4+ years now. (I looked at the versions specified at MDN, and googled their release date). And when if not for "showing others how to write insecure code" are expletives warranted? That is one of the worst sins one can make, in my opinion. And even if you did not know the API for secure random existed, you mention the "don't try this at home" as the very first thing, and don't encourage practices like "I copied that code from the internet lol" for security-relevant stuff. And you can argue it's only for small side projects, but if you train wrong you'll play wrong.
I would recommend ES6 along with a modern front end framework, such as React. Andrew Mead has a great course on react on udemy. He is very thorough and actively updates content. He and a TA also actively answer questions that students have in the Q&amp;A section. It is well supported for a udemy course. Udacity has a React nanodegree as well. The instruction is weak, but the projects are a great way to learn. I would also recommend viewing traversy media's videos at random. He has so many crash courses on random languages and technologies.
This was posted here recently. If you haven't seen it before, perhaps the old discussion will be of interest: https://www.reddit.com/r/javascript/comments/7nln84/30_seconds_of_code_curated_collection_of_useful/
have you tried window.close() ?
According to the Electron docs it's literally just an event emitter.
Formatted nicely, this is how it should look like. I'd recommend always putting semicolons at the end of each line of JS code. javascript:( function() { window.open("http://osnews.com"); window.open("http://mozilla.org"); window.open("http://slashdot.org"); window.close(); } )();
I want that in the form of something that can be entered into the address bar of a browser (such as Pale Moon in my case).
Using react-strap on a new project. So far, so good.
Pretty cool, felt smooth on mobile.
The ipc serves as an API between the front and backend, so if you want to replace that with Node, you'd have to write just that, an API. You could use something like Express to do so and hook it up to the frontend using something such as Axios or fetch.
You're welcome. Glad that I could help
Fabric team member here. This is mostly accurate. Besides being a toolset for building extensions for Office and more, Fabric is used extensively by a bunch of Microsoft web products. OneDrive, SharePoint, Project, VSTS, and Outlook all share (and contribute to!) lots of common UI elements from Fabric. The fancy new [React-based Outlook](https://www.theverge.com/2017/8/8/16111716/microsoft-outlook-beta-web-features) is a great example.
This is the javascript sub. You want something like /r/java . Similar name, completely different language.
Thank you :)
That‚Äôs what I love about new HTML tags, man, I keep getting older, they never get browser support. 
A PR is super easy, and also gives you credit for contributing to the project! After a commit and push to github, loading the github.com repo site should show a button for "New Pull Request" right beside the "Branches" dropdown. Follow the prompt and click the big green button at the bottom to create a pull request :)
Guide should be called "Yet another guide to front end frameworks".
Awesome!
Where is it?
I feel like you missed out on a really good pun with "30 Seconds to Parse"
This framework look amazing. So much less intrusive than Material UI, and it has Typescript support out of the box. Unfortunately it doesn't have mobile support, which rules it out for me.
Material-ui v1.0 is such a joy to use. I wish there where non-material themes available for the same components.
I'm sad to see Material UI is number 1. I've used it in production (I shouldn't have in retrospect) and it's been a nightmare to work with.
&gt;I'm sad [Here's a picture/gif of a cat,](http://78.media.tumblr.com/tumblr_luvi9cnPPy1qgnva2o1_500.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
You shouldn't be dropping ant in for just a few components anyway
i'm a fan of [spectre.css](https://picturepan2.github.io/spectre/)
Yyyyaaaaassss
I like Meteor
I'm building a whole app with it right now :D the integration with React is phenomenal.
If your using React, this is the best thing since sliced bread https://github.com/clauderic/react-infinite-calendar/
Its sad that there‚Äôs been no adoption... it has some features that would be really beneficial.
It's how they spy on us.
I usually just assume "San Francisco" unless otherwise noted.
Why? Modularity is a critical feature for a component library, in my opinion. Changing the global styles forces you to adopt an all-or-nothing approach to the library and that's not ideal if I only need a few of the components. 
Antd, get started quickly by the document &amp; examples.Also beautiful
I *think* I agree with you. I've been using jQuery for as long as it's been around. I have yet to run into a use case it cannot handle. These other libraries seem like solutions in search of a problem. 
In 2015 it was on Amelia island. 
I was referring to ReasonML, not Elm! But that's good to know anyway :)
https://www.reddit.com/r/javascript/comments/7qxwrw/recursion_tutorials_in_javascript/
Yesterday I made an identical post to yours, but switched out "React" with "Vue." It received one comment, but yours now has 99! I guess Vue still has a while to go... I've used Material-UI and Semantic-UI for personal projects/clients. None of them were customer-facing (more like dashboards), so if being lightweight is a concern, it might be best to look elsewhere. MDL-React seems promising for this. Oh, and both of them have Clojurescript wrappers available too. 
I have no problems with that.
I had to like the first comment. Recursion lends itself to humor :) And thank you for all of the links. I can usually get recursion after spending a lot of time with a problem but it does require you to approach a problem differently and I need practice.
You can do it with JS, but it's probably easier with some css changes. You can use flexbox for this. On the UL, add the following rules: display: flex; flex-flow: column wrap; With that done, all the LI elements will be in a list from top to bottom - apply an explicit height to the UL to get it to wrap the columns properly. Playing around with it, I found ~585px seemed to work. If you do this, beware that setting explicit height is not exactly mobile friendly.... but you can get around that with some media queries - just only set the height on larger devices and it should appear as it does currently on mobile devices.
I'm interested in using material-ui for my next project. Any concerns I should have? 
Thank you for getting back to me! Thanks to both of you actually! But okay so if I add that to the code I'm embedding that will get rid of the "Trading View" thing thats at the bottom and when you ask make what smaller I was referring to the text.. And how to possibly change the text from a size 16 maybe to a size 12 because I figured that was the only way to shrink the width of this thing in order to make it take up less room on my header.. What do you think? Is there a better way? Thank You though again I really appreciate the response in the first place!
Not quite sure what exactly that means as of just yet but let me do a little bit of googling and some research and hopefully ill be able to figure that part out! Thank you again for responding to me I really appreciate it! I know the both of you have better things to do with your day so it really means a lot to me when people take time out of there day to help me with such small meaningless little tasks that the majority of the world wouldnt take 3 seconds out of there day to usually help someone and allow someone to better under stand so thanks both of you its cool you did that
Don't want to come off as too harsh, but from your reply I can tell you know very little of CSS or how webpages are built. I would help you with those, but teaching them is a whole other thing. Did you build that page yourself ?
great post!
I don't think so as well. All the frontend mind share is in Vue, React and Angular and aurelia has issues like [this](https://github.com/aurelia/fetch-client/issues/90)
How complex is the question? For normal interview questions, you should be able to draw a table of the recursive call stack and the expected local values in each of the stack layers. 
this was what I got most recently: Implement this function: def doesSumExist(startNode, sumTarget) ...which returns a boolean, indicating whether or not the sum of values in any path from the ‚Äústart‚Äù node to a leaf node exists as the target in the given tree. given the following node structure: a|5 | | | b|7 c|3 d|2 | | e|6 f|1 | g|8 then: a, 4 = false a, 5 = false a, 12 = true [a -&gt; b: 5 + 7 == 12] c, 3 = true [c: 3 == 3] d, 16 = true [d -&gt; e -&gt; g: 2 + 6 + 8 == 16] 
You should be fine with seperate. Batching is more important if you're dealing with hundreds or thousands of elements.
Like a neatly encapsulated and themed bootstrap + bootstrap-ui. They consist of css, js, static assets distributed as npm packages. Generally, they require the use of a module bundler like webpack. React itself would replace something like jquery. These ui frameworks are something like jquery-ui or bootstrap-ui.
this is the solution I have so far but it does not work for subnodes https://jsfiddle.net/avdohckf/
More like, yet another rehash of the same bullet point lists for the most popular frameworks, plus copy-pasted blurbs from 20 other less popular ones.
Doesn't work over Tor.
Really like it, reminds me of some hackernews clones. Apart from that I don't see anything in redux dev tools and details of a post just shows a json response.
Last time I tried Semantic UI, it looked awesome, it felt natural to program, but it was so heavy and slow. Have the fixed the performance issues?
Thanks! The json in the post is expected. It's a placeholder while I work on the app. How are you using DevTools? I intended for people who visit the site through this post to download the extension and use it via their browser's developer tools.
As someone who didn't take Computer Science / algorithm, other topics that are pretty common that requires studying: * Binary search * Sorting (order of importance IMHO: merge, heap, quick, insertion/selection/bubble, everything else) * Heap (at least implement "binary heap") * Space-time trade off (dynamic programming, hash table, bitwise calculation) * Common substring/subsequence/palindrome If you have time, I would go to site like LeetCode / GeeksForGeeks and do 20-40 problems. Also watch some YouTube videos on System Design and Behavior interviews, so you know what they are looking for. (E.g. [this](https://www.youtube.com/channel/UCcdCkJKXlRoXVD03eo-q8mQ/videos)) Good luck.
Browser support? https://github.com/GoogleChrome/dialog-polyfill
`&lt;dialog&gt;` is supported in all sane browsers.
We use react-jsonschema-form at work. I like it a lot.
I had an interview with recursion and with 4 people watching me, including the CTO of the company, I couldn't get it right and probably blew the interview. I called it spectator recursion. But you know what, if I was sitting at my desk, in the zone, like a normal work day, I'd have no problem doing it. So what did they they really accomplish?
Angular-Materialize
Not Javascript, but java... I experienced the following syntax on the other day: .doSomething() .setProperty(property) .getId() .postURL() I am not joking
They're just collections of controls/components with a unified style-guide. &gt; What a world front end development has become. It's become what it should be, a rich eco system where people share and re-use code.
The most toxic JSConf
And Opera.
Definitely not bad practice, any framework or language that tied you to a specific DB would be a big red flag. You see Node/Mongo tutorials everywhere because it is quicker to set up Mongo, but quicker doesn't necessarily mean better. 
https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f
There is a pretty good one maintained by the angular developers: https://material.angular.io/
I use the mysql2-promise node library for connecting to MySQL databases from nodeJS, and it works very well. https://www.npmjs.com/package/mysql2-promise Important to know that your queries all return promises, so best to make sure you understand how to use promises in node and js/es6 in general. Also, if you use connection pooling (recommended), remember to always release connections back to the pool after doing a database query, otherwise the pool runs out of available database connections and your app hangs indefinitely (and requires a restart).
They are styled react component for common UI-objects like buttons, menus etc. You can of course customize and theme them. 
You could say the same from american opensource projects if you go that route...
Great write up. Although it's hard to miss the bullet points about "Job market" in every single pros&amp;cons section. You outlined everything nicely, the following point is definitely not about you, BUT: &gt;Our developer paradigm (indirectly + unintentionally) is so distorted and shifted that under the hood, our priorities has become 'chasing the job market' rather then 'improving fundamentals and making better software'. This is a loosing battle because it is an anti-pattern.
I recently went with using process.env.npm_package_version in webpack config files and passing it to the code via webpack Define plugin
I'm sorry, but this is not a good guide. The information you present is mostly what's popular and what isn't. This is available everywhere, and is extremely volatile. In one year time your guide will be useless. The popularity contest between frameworks is the most over discussed and least important thing. The information I care about that's tough to find is what kinds of problems each framework is best for/worse for. As someone who already has a job and can learn a framework on demand I don't care about job market or popularity (as long as there is enough documentation), but rather, when I approach a new project, which framework will fit my project best. 
I sadly don't know how to use promises yet, but I will look into it soon! Thanks
Thank you very much for your answer
Good to know! Thanks!
When I got to the point of using a framework, I took a brief glance at React and Vue, then choose React as it seemed easier to use. I'm curious as to why React is considered difficult, but Vue easy?
Material Design Lite (MDL) is deprecated. The successor is Material Web Components.
Yup, was going to make the same comment 
Because it's a lot easier to start with vue than to start with react? Especially for beginners in webdev.
Looks nice: Questions: * Have you tried to do a Lighthouse audit(chrome tool), what's the score? * what's the bundlesize after gzip?
Seems like I missed the opportunity to plug my [article](https://medium.com/@elianibaj/one-rule-and-three-exceptions-to-understand-javascript-coercion-35289365c449) on javascript coercion before this went to the top of r/programming :P Oh well, this is a more appropriate audience anyway, and the goal is not for javascript programmers to ever write code like that but rather to spend 10 minutes once to learn a feature that is part of the language whether we like it or not.
The big take away for me is not coercion per se, but using "invisible" unicode characters in the source
Indeed unicode seems to have been the original bug for the people asking the question, but multiple "solutions" in the original thread using different techniques and coercion seems to be blamed most by people reading that.
Lol
I found React a lot easier than Vue.
Learn Vanilla JS and understand how things work. Not just learn a framework to start working with clumsy knowledge.
Who decides what is merited?
&gt; What's the valid practice to have the same effect? Something that's not **that**, apparently. Whatever you do, make sure **that** isn't it. Isn't knowing that enough? ---- Seriously tho, I think the point is that there's plenty of different container types that a 'valid' hierarchy can be built without using a tag that was originally intended strictly for text. Your example, for example, can use &lt;span&gt; with no side effects, technically speaking. Of course it makes more sense to have a &lt;p&gt; full of text with embedded &lt;span&gt; for smiley's, than a &lt;span&gt; full of text with &lt;span&gt; for smiley's. Also... where'd you get that text block?
Thanks for this, do you plan on updating it regularly? 
Thanks for sharing!
Angular-materialize is my choice
I think this is a question more for stackoverflow if Im not mistaken
It is mostly because react introduces jsx, css-in-js and other concepts while Vue builds on html and css. They are equal in both complexity and capability, but most devs are used to html and css
Just a silly bullet point taken out of the thin air, there's never been even the slightest explanation as to why that would be the case, and how. For api size and cognitive overhead alone Vue is a lot more to digest, especially because each and every aspect of javascript programming has to be re-learned. 
You work with regular css and classes if you want. [Vue btw. also has css-in-js](https://vuejs.org/v2/guide/class-and-style.html#Binding-Inline-Styles). JSX is a minimal DSL, the semantics are understood under a minute. It does not break assumptions and integrates with regular javascript. Vues HTML is a *major* deviation from regular HTML that has you re-learn even the most trivial and daily aspects of programming. It also breaks common assumptions, which now leads to further complications like dependency injection. 
Yes, i see 2 ways of doing it very simply by overriding the valueOf() (or the toString()) or by defining a getter on a.
**Why:** Moment.js has localization files that take 160+ minified KB. These files are included by default when you build your app with webpack. This plugin helps you to remove unused localization files (and strip up to 160 minified KB from the bundle). **How to use** `npm install --save-dev moment-locales-webpack-plugin` ``` // webpack.config.js const MomentLocalesPlugins = require('moment-locales-webpack-plugin'); module.exports = { plugins: [ // To strip all locales except ‚Äúen‚Äù new MomentLocalesPlugin(), // Or: To strip all locales except ‚Äúen‚Äù, ‚Äúes-us‚Äù and ‚Äúru‚Äù // (‚Äúen‚Äù is built into Moment and can‚Äôt be removed) new MomentLocalesPlugin({ localesToKeep: ['es-us', 'ru'], }), ], }; ``` **Why not `ContextReplacementPlugin` or `IgnorePlugin`** These plugins could also remove unused locales, but they are complex: ``` const webpack = require('webpack'); module.exports = { plugins: [ new webpack.ContextReplacementPlugin( // The path to directory which should be handled by this plugin /moment[\/\\]locale/, // A regular expression matching files that should be included /(en-gb|ru)\.js/ ) ] }; ``` This plugin provides a simpler interface to do the same job and documents its direct goal.
The people that run the show, man. cmon. If you're throwing your own party, then you decide who comes based on your own sense of merit. I mean if you can't stand Jan from accounting, but everyone else likes her, are you going to invite her to your birthday party because *everyone else* likes her?
There are quite a few interesting comments in the HN thread for this same subject, where it was discussed a day ago: [Hacker News: Convert React JavaScript Code to TypeScript with Proper Typing (github.com)](https://news.ycombinator.com/item?id=16159389)
V8 already tried it once with [strong mode](https://groups.google.com/forum/#!topic/strengthen-js/ojj3TDxbHpQ) Of note: &gt; Implementation complexity: Strong mode tweaks many small bits of the language semantics (see the list at the end). Consequently, it requires special-casing all over the compiler(s), run time, and libraries. In V8, it amounts to literally hundreds of new code paths, and that does not even include libraries. As you can probably imagine, VM implementors are not happy about such added complexity, and it gets in the way frequently. While some of that was to be expected, it was worse than we had anticipated. and &gt; But our hope for being to able to utilise strong mode for _improving_ performance did not materialise, mainly due to the constraints imposed by the weak mode interop requirement, and the disappointing results for classes. For the foreseeable future, ES6 performance in fact will make strong mode substantially worse. In addition, it adds a lot of cross-cutting complexity to the implementation. &gt; Considering all that, we have reluctantly decided not to pursue strong mode further. We learned some worthwhile lessons, but overall it is not clear that the benefits justify the costs. Starting with the next version of V8, we will hence remove support for strong mode. Basically, as I understand it, additional "modes" makes implementation _really_ complex for the javascript engines, especially when interoperability is required. These days we have transpilation languages that target javascript anyway, which can easily abstract away all the problems you listed.
How many `Markers` are there?
My firs thought was setting the `getter` on `a` to increase in value each `get`. Glad someone else had the same thought!
&gt; JSX is a only a **small** dsl &gt;Vue-HTML and Vue-javascript are a **major** abstractions over HTML and JS On what basis, do you classify jsx as "small" while vue as "major"? &gt; The size of what you have to learn in order to get going **cannot be smaller**. &gt; Even the most trivial things like referring to scope, using component A in component B or rendering children, none of that is obvious in Vue. again, what is your basis for that? Maybe, you have conducted thorough studies on this subject, maybe you have seen multiple devs on your team struggle with Vue while understand react easily or maybe not. My money is on "**you just learned react first, and now you are biased towards react**". Now, I have not conducted any studies either, nor have I met significant devs who tried Vue and React both. and of course, I learned Vue first, and find React to be a constant struggle between best practices and convenience. But, I understand that other people have different experiences and do not force my opinion on others. I highly recommend you to try it. PS: Surely even you would admit that if, from the get go, *react had good tutorials, MIT license and create-react-app, then Vue might not have taken off*. 
About 100. 
Wow such badass
I would start by extracting the `getDistance(...)` function out of of the `forEach`. Creating it on every iteration is wasteful. Since it needs the `place`, just make that another parameter. Is `distances` an external array you are pushing values into? Instead of `forEach` you may want to use `map`, and write directly to `distances`. That may not solve your performance issues, but for some people (myself included) it makes the code clearer to read. let distances = Markers.map(place =&gt; ....)
const a = {}; a.abuseCoercion = 0; a.valueOf = function() { this.abuseCoercion++; return this.abuseCoercion; } console.log(a==1 &amp;&amp; a==2 &amp;&amp; a==3); There you go
Is there something I missed on JSConfUS ? It shut down for a while and it seemed as if there was a lot of controversy around it.
I expected to be annoyed at this "gotcha" interview question but I actually learned something new. TIL
Shrug. I was a beginner once too. A list of bullet points about the pros and cons of various languages didn't help me learn anything. Just picking one and building something did. I dunno even why I'm taking potshots at the article. My framework is there too lol.
Console.log(‚Äútrue‚Äù);
They could always learn python then they can even run one block of code using tabs and another using spaces. Might just be me but semicolons make me feel safe and allow me to sometimes write 1 liners
So you poorly cloned the gif that was circulating yesterday?
My response to this stupid interview question would be: If it ever did, I would question the skills and abilities of the programmer who wrote such plain and obviously bad code.
I've decided to go with react after consulting.
Not in _my_ work.
Another thing - really think about if what you're building is an _app_. Like, really - is this something you would roll into an APK and have users install? Is this something _you_ would install on your phone/laptop (for the functionality it provides)? Also in building an API - do you really envision your userbase using their own clients to consume your services? _All_ of the endpoints you expose? Have you done due diligence in ensuring it's standard, accessible and well documented if that is the case?
Adobe (Acrobat) has an implementation where you can use a JS engine to do various things in a PDF =&gt; that being said, it is a custom implementation (does not follow ECMAScript standards precisely) and often has very little documentation. You can also use JavaScript to manipulate a PDF from traditional JavaScript (like a browser environment [e.g. Chrome/FF/etc]), but this often involves needing user exceptions (they'll have to either accept prompts or download extensions), so you can use tools like Microsoft's ActiveXObject to interact with various softwares on each user's PC. In short, I've used JS in the past to manipulate PDF's when I first got in to programming - it is really challenging for anyone new given the amount of holes/gaps in documentation you will need to fill and find out for yourself. http://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_developer_guide.pdf http://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf https://docs.microsoft.com/en-us/scripting/javascript/reference/activexobject-object-javascript ** Edit ** =&gt; I will also add that this subreddit is specifically for JavaScript executed in a browser environment (or occasionally related to some NodeJS concepts). If you are going to route of writing JavaScript in Adobe's implementation, you are probably better off finding a subreddit/community that understands/focuses on Adobe technologies.
Nice!
This looks awesome! 
I find your lack of semicolons disturbing.
This works in most languages in one form or another. The Java version is interesting, because it involves code that's not thread safe. If you increment a in one thread and run that test a few billion times in another thread, eventually, the test will be true.
The correct answer is "only in pathological cases". And then ask if their code is pathological.
Yes i did it looking at it and you poorly write a comment.
An alternative to moment.js: https://date-fns.org/ which is modularized out of the box.
[We talked about this recently](https://www.reddit.com/r/javascript/comments/7pzph2/shebangs_in_js/)
TLDR: * Unless you have additional users/apps consuming an api, SPA's create complexity by creating an additional tier (webservice/api tier) which can cause additional work. * Unless you use graphql, it's quite possible your app might need to make multiple api requests for the SPA page it needs to render. * Unless you use something like websockets or reactive programming techniques, data can go stale since it's rendered once and the information might change unless something else requests it. Some of the above information is spot on, but I would also like to hear about some of the negatives of server rendered pages. * If you use server rendered apps you have an increase in server load because it has to render the page. If If we are going to talk about ever mutating data, caching might not be possible here. * It's easy to create untestable code if the JS isn't architected properly. * If you use server rendered code you can't pop prebuilt React/Angular/Vue/SPA components into their platforms because you're using C#, PHP, Java, Python, Clojure, Go, Rust, Kotlin, Rust, Elixir or one of other 50 other different languages. The advantage of SPA's might not be in the complexity but the reusability of a platform and ecosystem that far trumps the cluster f**k of every back end programming language and framework that exists under the sun which probably dwarf the most popular front end frameworks. SPA's have their place as do classic backend rendered code. The point is to use the tool for the right job. It's quite possible that based on the article the user doesn't get any benefits from SPAs. Additionally, this list isn't exhausted and I would love to hear more about the pros and cons of each architecture. 
‚ÄúIn this company we question reality!‚Äù
it's not like /r/programming likes to mock javascript every week anyways :(
And the reason for why it needed to be there.
You want to avoid that call to "new" in Java. Use Integer.valueOf(1) and it will always give you the same instance. I believe that's what autoboxing will do too. Not that it's recommended to use == on any object except an enum value! Interestingly, in Perl, it would be done without operator overloading. The effect is similar to creating a getter in js.
LOL. That's a great one.
 class Thing: def __eq__(self, other): return True a = Thing() (a==1 and a==2 and a==3) 
Well yeah, `Integer.valueOf(1)` just returns the cached instance, so it's literally returning the same instance. But... only for integers &lt; 128 (which is the default max int for the cache IIRC): Integer.valueOf(127) == Integer.valueOf(127) # true Integer.valueOf(128) == Integer.valueOf(128) # false I was just trying to show that two instances can't be compared for *equality* in Java using `==`.
And Firefox with a (rather specific) flag.
With all the talk of modifying "a", I was curious if it would be possible to modify the numbers. Unfortunately I wasn't able to make it work.. Number.prototype.valueOf = function() {return 1;} Unfortunately it doesn't seem to work: console.log(2); &gt; 2 console.log((2).valueOf()); &gt; 1 Anyone able to give a reason why this approach doesn't work? 
Demos: https://demo.agektmr.com/dialog/
I've seen in react bootstrap's github issues talk between the two maintainers of combining efforts once BS4 hits a final v1 release. Glad to hear you're having luck with it! Have they kept the project up to date with the latest betas?
Because value of converts an object to a primitive. Since 2 is already a primitive, it isn‚Äôt called. Where you call valueOf, calling that method casts your number to a Number, which then needs to be converted back to a primitive.
Ok, so could a similar approach work with implicit casting while using the `==` operator? 
What benefits does this have over [Memoizee](https://www.npmjs.com/package/memoizee)?
Hadn't heard of this before. Thanks for the suggestion!
I understand what you're saying and to some extent they can be interchangeable, and yet I still believe that the existence of feature A or B can make a measurable difference in my ability to deliver a final product. For example, I personally have professional experience only with Ember and Angular 1.5. With this experience I would say that for an application that needs to reflect models I have in the backend and display/operate on them (like an admin panel, a CMS etc.), I would prefer Ember because so much of the required wiring comes out of the box. But if I need to work mostly with unstructured data (like perhaps charting/graphing) then I'd like a framework that is more like angular 1.5. Had I chosen to make something like an admin panel with angular 1.5, with equal knowledge of both, I'm pretty confident I'd get out a finished product faster and in higher quality with Ember.
Actually, 'a bunch' appears to be a bit of hyperbole on my part. Since the project's last commit there has been two new TypeScript versions: 2.5 and 2.6 (2.7 RC was just announced today). 
You could use the [Performance tab](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/) of Chrome's DevTools to test an algorithm's runtime performance and memory usage. You could also use the [Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance) in the DevTools console: var startTime = performance.now(); doSomething(); var endTime = performance.now(); console.log("Call to doSomething took " + (endTime - startTime ) + " milliseconds."); ... or [console.time()](https://developer.mozilla.org/en-US/docs/Web/API/Console/time) &amp; [console.timeEnd](https://developer.mozilla.org/en-US/docs/Web/API/Console/timeEnd): console.time("doSomething took"); doSomething(); console.timeEnd("doSomething took"); // doSomething took: 3.696044921875ms If you want to compare several different algorithms, you could also use [jsPerf](https://jsperf.com/) or other similar online solutions.
My web browser doesn't ;)
I dunno, it's not likely someone could make this work on accident without a pretty good understanding of JS and how the loose comparison operator works. Knowing they can change the built in *.valueOf* or *.toString* methods to also increment the value when the loose comparison operator is used on that object is pretty clever. I would, however, deeply question their ability to write and maintain readable, reusable, and non-destructive code, but not their understanding of the language.
A skilled and able programmer would know enough about their field and language to never write code like that.
Awesome. Thank you. jsPerf seems more like what I was getting at but these APIs are great.
Thanks :) I didn't know about Lighthouse, but I just ran the test and got these scores: * PWA: 82 * Performance: 47 * Accessibility: 100 * Best Practices: 88 Is this about average? I'll certainly look into the performance score first. It seemed to not like first meaningful paint time of 8 seconds. The bundle is 155KB. I'll look into switching to the fetch api. I originally used axios so I wouldn't have to think about polyfills, but I'm sure it won't be difficult to implement if CRA has docs on it. I bet reducing the bundlesize will cut down on time-to-first-paint as well.
Additionally it does not mutate the supplied dates so that you can skip all the calls to moment.clone
You're welcome! I've been working on it regularly over the last month or so and plan to continue development for at least the next few months.
Yeah I'd ask it just to see if they'll solve it or give an answer like yours. Even if someone did try to solve it, I'll ask follow up question like what would you do to make this more robust and readable, just to give them every chance. 
launchRocket (321)
I just figured it out I need to convert it from hex to get what I need ty anyway
It only works if there's unboxing involved. 1 == Number(2) // false because calling Number returns a primitive const n = new Number(2) n.valueOf = () =&gt; 1 1 == n // true because js needs to unbox the value class Num extends Number {valueOf() {return 1}} 1 == new Num(2) // true because js needs to unbox the value
a11y 100üëç nice. About Performance: Note that perfomance is based also on how long it takes to download your files. If the server happens to be slow to deliver in that moment, thers's not much you can do. 1- If you have a [shell](https://developers.google.com/web/ilt/pwa/introduction-to-progressive-web-app-architectures) that you know will be rendered on every route you could render it to index.html and then use ReactDOM.hydrate( a 2 steps rendering) instead of ReactDOM.render. 2 - Note that cra supports dynamic imports ```import (..).then ()``` You could do route based code splitting. 3- check react-snap/react-snapshot, havent used them but look promising. 4-you should inline your 4 css lines. Chrome waits those 4 lines to do the 1st meaningful paint. About PWA: Icons: make also a 192√ó192 icon and a 512x512 icon(for the splashscreen) Ps wrap your calls to localStorage.setItem in a try catch block [see](https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem) and [this article](http://crocodillon.com/blog/always-catch-localstorage-security-and-quota-exceeded-errors)
What are your precise requirements? That is, do you only need the nearest point or do you need all and also the nearest one? I ask because you can avoid a lot of work if you just want the nearest point (or even the five nearest points). First, given you're not considering height variations and _if the points are not spread across an area too large_, you can avoid calculating all the precise distances. Just calculate an approximation. If the approximation is good enough, the order will still be the same as with the precise calculation. You could, e.g.: var x = (lon2-lon1) * Math.cos((lat1+lat2)/2); var y = (lat2-lat1); var d = Math.sqrt(x*x + y*y) * R; // For _order_ you don't even need to multiply by R if you don't want to. // Or even take the square root. You could just do var kd2 = x*x+y*y; and order would still be preserved. This should already perform better. I know we're making a sacrifice in accuracy, but I'll solve that in a moment. A second optimization is that, if you only need the, say, 5 nearest results, and are going to discard the rest, then just discard them as soon as you know you don't want them. That is, you could do something like... var nearestFive = []; for (var i =0; i&lt;Markers.length; i++) { // You calculate the distance for this one... let approximateDistance = calculateApproximateDistance(Marker[i], origin); if ( isBetterThanCurrent(approximateDistance, nearestFive) ) { insert(nearestFive, Markers[i], approximateDistance); } } At the end of that loop, you already have the results you need in the `nearestFive` array. If you wrote your `insert` function correctly, they can even be ordered already. (Note that if you only want _one_ it is even simpler. You don't need an array, just the one reference) Finally, about that loss of accuracy: If you want, you can now use your more precise calculation on the results. The benefit is that you only perform this more demanding calculation on five (or one) results. And they are the ones you really need so there's no wasteful calculations later discarded.
In terms of 'trying to think through problems', I'd be more inclined to phrase the question in a way of say - "why are mutating getters a bad idea?", and have an example that is a bit more inline with what you might actually run into. var obj = { _count: 0, get count() { return this._count++; } } if(obj.count === 0 &amp;&amp; obj.count === 1) { console.log('would this code get it, and if so - why is it a bad idea?') } I've seen code before where people get a little overly creative in getters - and could potentially introduce a bug like this, it's getting at a bit of the same issue - but without trying to be overly clever about it. At the same time - I'd be curious to hear their thoughts on "when might you want to do something like this?" Likewise, I think there are better ways to get a sense of someone's understanding of type coercion without throwing red herring at them. For example, the solution that was making use of assigning array.join = array.shift and knowing that .toString() calls join internally. While I'd be a bit impressed if someone could do that on the spot in an interview and explain it well - I don't think I'd hold it against someone if they couldn't either. Dunno, guess I just prefer more "honest" questions that are not trying to intentionally trick / brain tease / be overly clever. I think even if you wanted to keep it at the tricky-level, how you even phrase the question can make a difference. Instead of being "can this ever evaluate to true", tweaking the wording to "can you think of how to make this evaluate to true?" It drops a hint for "yeah, it's possible" - but then also opens up discussion for a bit of back and forth where you could drop a hint / nudge them about things like getters, or toString. So if they are a bit stumped, could be "well, when doing this, it calls a toString()..." - and maybe even if they didn't know that before hand, could lead to an "ah-hah, well then maybe this way" moment, and at that point I'd be curious to see how quickly they can integrate new knowledge into how they answer things. I guess it could have potential to be a good interview question - but how the OP phrased it, I think it's a shitty one and would never use it myself. 
This is interesting, coming from a PHP background my first thought was that if a = true then (a==1 &amp;&amp; a==2 &amp;&amp; a==3) would evaluate to true. In PHP that works because 1 == TRUE and 2 == TRUE and 3 == TRUE $a = TRUE; if ($a == 1 &amp;&amp; $a == 2 &amp;&amp; $a == 3) { print 'yes'; } But in javascript 1 == true but 2 != true and 3 != true, also 2 != false and 3 != false, and 2 != null and 3 != null Because js evaluates the conditional in the question to 1 == 1 &amp;&amp; 2 == 1 &amp;&amp; 3 == 1 Whereas in PHP all numbers except 0 are truthy js is weird, ha
There's also https://moment.github.io/luxon/ it's fairly new though so not sure how good it is.
Can you explain why a+a is always odd? a = {num:0} a.valueOf = function() { this.num += 1 return this.num } lol = (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) console.log(lol) //true console.log(a+a) //9 console.log(a+a) //13
&gt; I just feel that the forEach approach is far easier to read, You basically answered your own question. For whatever reason you aren't comfortable with reduce so you think it's harder to read. When I see reduce I immediately understand that somehow the entire array is going to be collapsed into a single value. To me reduce is idiomatic. Foreach is idiomatic when some action is going to be taken for each item in the array. Reduce is idiomatic when a single value is going to be created from the entire set of the array.
I've been toying around with an implementation similar to this. The biggest issue imo is that your solution doesn't respond to changes to the key whenever they are made outside of the abstraction. What you probably want to implement is a listener on the [storage event](https://developer.mozilla.org/en-US/docs/Web/Events/storage) with fromEvent as the source instead of manually emitting changes after a successful set operation. Speaking of which it's possible for a set operation to fail when there isn't enough memory left to save the value but your implementation doesn't handle that either. Set should include a try catch block to handle when the set operation fails.
Because it's the same as `n + (n + 1)` or `2n + 1` (where `n` is `a.num`). Since `2n` is always even, `2n + 1` is always odd.
Because you're always adding two consecutive numbers, which will always be even + odd, which is always gonna be odd. You can only get an even number if you're adding two like-parity numbers. const a = { number: 0, valueOf() { return ++this.number } } console.log(a + a) // 1 + 2 = 3 console.log(a + a) // 3 + 4 = 7 console.log(a + a) // 5 + 6 = 11
Nice one. Another reason to use === instead of ==
No best practice. This is a case of multiple ways to solve a problem. Both are good solutions. Just learn and understand how both work. If you have a preference, use that one. 
forEach is going to be easier to read if you're not going to use reduce on one line with an arrow function. You should be able to use reduce with single character variables and understand what it is doing straight away: let sumVal = arr.reduce((a, b) =&gt; a + b) 
&gt; collapsed into a single value or when the resulting array has more or less elements than the input array, or when the insertion order does not map neatly 
`reduce` is more _self-contained_ and explicit. What does that mean? With `forEach` you have a generic way to "apply some action to each element". elements.forEach(action); This, _on its own_, reads like the explanation above. That `action` can be _anything_. The action is not necessarily supposed to produce a change in some other variable defined outside as your `sumVal` or any other. It _may_, of course, by on its own, seeing `forEach` does not give you the idea that this particular action is supposed to produce a result. On the other hand, by its definition, `reduce` _is_ supposed to produce a result. Its mission is exactly that: successively apply the `action` on the current element and an accumulated value. The assumption that `reduce` produces an accumulated result is right there in its nature. So then, when you read... elements.reduce(action); ...you know something's weird, because what you really want to read is... result = elements.reduce(action); // or, optionally .reduce(action, initialValue); ...and this form _explicitly includes **what** is being produced_ and where it is being stored, in contrast to the `forEach` form. You read that line and you _know_ it is supposed to produce an output and that the output is in `result`. So it is more self-contained and explicit. The situation is similar to other collection methods. You may be aware that in the same way you can write a `reduce` operation -but worse- using `forEach`, the same can be done for `map` or `filter`. So, yes, you could always use `forEach` is you wanted. Or you _could_ use `map` when a `forEach` would be more appropriate. But then again, if you _do_ use the correct operation in each situation, then the code becomes more explicit and sincere about its goals.
That's fair, I was just trying to use something similar to the "common" syntax for those for demonstration purposes. By that I mean, the param names not the arrow function.
For those that haven't tried them, shocking how?
Thank you for that write-up! I totally understand being explicit about functional goals, and that is something I will try to keep in mind in the future. I suppose my example above is also too simple to really highlight the explicit nature of reduce in this fashion, whereas it is a lot easier to see / understand the benefits when you write it out that way. Bravo!
&gt;is there a functional difference to these two approaches that I am missing? Not really that I'm aware of. There might be some minor variation in execution time or memory usage between the two but I doubt it's enough to worry about. Logically all of the array operators are derived from reduce. Foreach is just reduce that continuously returns the original array (or null? I always forget which forEach returns). Map just returns a new array where each each iteration pushes a value onto this new array. Filter returns a new array where only items that pass the predicate test are pushed onto it. Etc. But as for actual functional differences there aren't any in particular I'm aware of.
I got that from the page. I was asking them why they found it to be shocking as they tried the examples.
Haskell is even easier because, like almost everything in Haskell, `==` isn't a built-in operator, it's a function in the standard library - associated with the `Eq` typeclass of things for which equality is defined. It doesn't even rise to operator overloading because there's nothing special about operators in Haskell - they're just functions that can be used in infix fashion by default. You can (and many libraries do) create your own novel operators. So we can just define a new `==` which will shadow the standard library's version of the function: (==) :: a -&gt; b -&gt; Bool (==) a b = True test :: a -&gt; Bool test a = (a == 1) &amp;&amp; (a == 2) &amp;&amp; (a == 3) test 7 -- True test 3.14159 -- True test "i'm a little teapot" -- True test test -- True (!)
Why is it weird? The set of binary numbers (0, 1) is equal in size to the set of boolean operands (true, false), you can perform any calculation in boolean algebra while substituting the later set by the former. In fact Boolean is a 1 bit long data type, which can also store the values of 0 and 1, which is their representation. Even when we're talking electronics, 1 and 0 have a direct correlation to the presence and lack of electric current, respectively. On the other hand, there is no sintactic equivalence between the set of boolean operands and the set of all integers. What is ' NOT 2' ? What is '4 OR 7' ? Any truth value you assign to these numbers has to be arbitrary and shared by a subset of numbers, there is no mathematical logic for such a conversion. If you take a random integer, which is 2 or 4 bytes long and tell a machine to compare it to an address space of 2 or 4 bytes that is fully zeroed, which random integers would evaluate as the same? If you take two such random integers and perform an operation such as ( a == b ) would it evaluate as truthy? Yet, if you're telling me that all non-negative, non-zero integers should evaluate to True in boolean algebra, then (a ==b ) for any two such numbers should also be true, but it very clearly isn't. It's not JS that is weird, integers are not booleans, neither are they NULL and should not compare truthily to either, with the exception of the subset that is mathematically and physically equivalent to the boolean operands set.
So in JS if you compare a bool to an int it converts the bool to an int and compares those. Whereas in php it converts the int to a bool and compares those. That right?
Shocking seeing startup time drop that much. Clang went from 30-40s startup to less than 1s. Another large drop: the wasm load time of the Epic Zen Garden demo; now if they could parallelize compiling shaders...
You take it too seriously. There is no "best practice" about this in JS, and you can do it in any way that you and your team are comfortable with.
Awesome, thanks, I'll give this a try.
**Update**: I've uploaded the submitted games for the community to take a look and vote in the Community Choice Award. You can find the details: see http://gynvael.coldwind.pl/?id=670
https://codepen.io/pen
Because React has little to no abstraction. If you‚Äôre familiar with JavaScript‚Äôs... peculiarities, that‚Äôs not an issue. But a lot of people (even experts) prefer sensible layers of abstraction. 
Even weirder, while `if(2==true)` doesn't branch, `if(2)` does! :^) JS has a lot of weird things like that: https://charlieharvey.org.uk/page/javascript_the_weird_parts
"SPA" sounds like a something I'd say in 2009. "We're going to upgrade your site to web 2.0 by delivering a rich interactive SPA with semantic xhtml."
 console.log( document .querySelector('script[type="text/javascript"]') .innerHTML.split('State": ') .map(el =&gt; el.split(/\s/)[0]) .map(el =&gt; el.replace(/[^a-zA-Z]/gm, "")) .slice(1) );
I hear stories of a browser called Chrome - with support for for CSS grid and Flexbox. Do not fool yourselves, this is only a myth. Polyfills and media queries targeting IE 11 is the one true road. 
I hear stories of a browser called Chrome - with support for for CSS grid and Flexbox. Do not fool yourselves, this is only a myth. Polyfills and media queries targeting IE is the one true road. 
The example I found most interesting was: var aÔæ† = 1; var a = 2; var Ôæ†a = 3; if (aÔæ†==1 &amp;&amp; a== 2 &amp;&amp;Ôæ†a==3) { console.log("Why hello there!") }
Hmm it does look like a for loop would be more efficient here. 
Ah this makes a lot of sense. All these points are in the same state, and I only need the top three. It seems I've been wasting a lot of performance by calculating 100 distances and then sorting them.
Watch out for coin miner webassembly crap. It'll come sooner or later.
There are 3 "State" values in that script. Which one do you need?
Once you have a reference to the inputbox element from the `getElementById()`, read the element's `value` property and convert it into number using `parseInt()`. Repeat that for the other inputboxes but this time, add the values instead of simply assign it into the variable.
Use VS code for debugging 
The only true answer here is "sometimes".
Sorry if I am incorrect (I don‚Äôt really understand this concept well) but can‚Äôt you also use getters and setters and whatnot?
I don‚Äôt think there is a one size fits all way, and the code you wrote is perfectly valid. For something very small like this it‚Äôs hard to argue either way. That being said, my preference (more generally) is for reduce‚Ä¶ Advantage 1: If you're casually glancing at someone's code and you see forEach, what does it tell you? It doesn‚Äôt return anything, it just does something, somewhere, gotta read it all to see. Reduce expresses more intent. When you see other array methods you have a better feel for what it‚Äôs doing without dissecting every line: Reduce - iterate over all elements in a collection, and accumulate them into one‚Ä¶thing (this one is more generic, but tells you more than forEach, still) Map- iterate of a collection and return a new collection with the elements transformed according to some criteria Filter - iterate over a collection and return a new collection that meets your criteria Find- iterate over a collection and return the first element that meets your criteria Advantage 2: Purity, and less intermediary variables. It‚Äôs easier to reason about stuff that returns new values than reassigning and mutating variables. Sure you have to do that in Javascript anyway, but why not keep it to a minimum while writing more succinct code? Advantage 3: Chaining! Chaining map/filter/reduce will serve you well in many operations on collections. Say the requirements changed, now you need to filter out all even numbers, add 3 to each of them, and *then* add them. You could keep the code you‚Äôve already written while adding the rest in one line someArrayOfNumbers.filter(n =&gt; n % 2 == 0).map(n =&gt; n + 3).reduce((x, y) =&gt; x + y)
Step through the code in the JavaScript debugger and you will see at least one problem right away. Don't rely on `console.log()`, that is too clumsy. Learn to use the interactive debugger so you can step through your code statement by statement. When you step through the code in the debugger, take a look at the value of `token` the first time through the loop. Is it what you expected?
Your postfix to prefix is broken -- you're feeding in the wrong input. const rpn = ["-", "*", "/", 15, "-", "7", "+", "1", "1", "3", "+", "2", "+", "1", "1"]; I could not -- for the LIFE of me, find a post-fix to pre-fix converter online. I had to download an app for my phone. I put together a codepen -- basicly the same code you are using. https://codepen.io/jstarche/pen/PExWMX?editors=0011 
I'm not saying you're wrong as I have no data either way. But do you have any proof of the claim that for each is faster than reduce? From my understanding actual for loops are still (usually?) faster than the built in array methods but I haven't ever seen any evidence that foreach in particular is faster than the others.
While I agree that debuggers have their place -- lets not give the idea that `console.log` (or `console.table`) is bad. I often find that I can look at the output of `console.log` and the problem just jumps out at me. Stepping through with a debugger means remembering the values between loop iterations.
One difference: using `forEach`, your variable must be mutable (i. e. you have to use `let`). With `reduce` you can use `const`, which is by far preferable.
Thanks! Fixed it.
oh and you can also do it with a `with` statement, that makes 3 way of doing it
Hey u/tme321, thanks for pointing that out! I didn't know about storage events before. Have you got your implementation anywhere online? And concerning your last paragraph, did you mean memory that was allocated to the browser, or the storage limit of the localStorage? Because if running out of RAM is what you meant, there isn't much that we can do, is there?
If someone asked me that question in an interview, I would immediately know I'm going to turn down their job offer.
Oh come on op. There was a question like this two days ago 
It's already out there. I think uBlock is even blocking a few of them.
You can't do this. In any way. Browser is sandboxed from you're local filesystem to prevent any unsafe operations executing without user knowledge (and that's the reason why to get some information from files user **have to** manually trigger that action).
First of all you swapped your branches &gt; if (typeof token === "string") Strings are *operands*, operators are + - * / etc.
For one you can actually read the code... I was going to try running Memoizee's test suite against it, but I found out it mostly looks like [this](https://github.com/medikoo/memoizee/blob/master/test/index.js). Indents 50 levels deep (literally). Every variable is 1-2 characters. Zero comments. The actual library is a bit better, but god *damn*.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [medikoo/memoizee/.../**index.js** (master ‚Üí bdbd44b)](https://github.com/medikoo/memoizee/blob/bdbd44b284177586501bee2046cfae1d20f6c924/test/index.js) ---- 
https://github.com/severen/disposition This is my first real JavaScript (well, TypeScript) project so I'd love for some comments on any best practices I could do or just general code smells.
found the North Korean. contacting homeland now..
Yeah that's the problem. I won't be able to distribute.
Is there any way around so that a externally running script say it a python script trigger the browser's extension JavaScript. This could be a win-win situation but I don't if it's possible or not
I'm not converting postfix to prefix. I'm trying to evaluate postfix from left to right
It is a valid test of how someone would think when hit by certain subtle bugs. How many times have you hit sometihng that looks like it should work but it obviously doesn't or vice versa? The fact that there are two distinct ways for the obvious not to be the case (white-space characters being valid parts of names and abuses of comparison overloading) makes it an interesting test: does the canididate see either or both? Though it is more a test of *experience* than technique and thinking IMO. You are more likely to "see" the white-space characters if you have been hit by bugs caused by not accounting for input data perhaps having trailing spaces, especially if you've worked with paired systems that deal with them differently (for example SQL Server says 'string ' == 'string' but your other application layers disagree).
Same problem as with the Node way - you won't be able to distribute. What you could do is create an installable file which uses Node, acts as a server and gives your extension information.
https://stackoverflow.com/questions/37684/how-to-replace-plain-urls-with-links
https://github.com/klooperator/redux-rest-fetcher Small api fetcher. First project...
I'm confused as to how this scales with respect to Redux. All actions are in the same file. Is it expected that you create subdirectories under /ducks? May want to mention that in the article. 
Did you open source your code? Perhaps you can link to your repos.
We don't *need* any of the iteration methods and we could abuse just about any of them to accomplish the same thing through side-effects, or use plain loops. However, choosing one specific method over another implies something about your intent, it's declarative. Since forEach has no return value, using it implies you want to iterate over a list of values and cause some kind of a side-effect, but that's all you are saying. Reduce is slightly more declarative, because it implies you want to derive some other data from the list, by applying given function to each item. Methods like `some` and `filter` are even more declarative, because they imply exactly what shape of data you want to derive by applying a function. So you choose the method that is most convenient and best describes your intent. When you consider readability, also consider the function isn't necessarily anonymous and defined right there, but could be in another module, at which point it wouldn't have access to whatever variables you've defined prior to it. Many list iteration methods are fairly universal and can apply across languages and libraries on wide variety of lists, so it's a good idea to get comfortable with them.
I don't think I did. Are you sure?
I didn‚Äôt. It‚Äôs like 30 lines each file, but maybe I could write an article
This article is a mess. So which is the proper way? Why is for..of not even mentioned in 2018? Why is there a benchmark for only one of the ways? 
Often with things like this (as is the case with Backbone.VDOMView, which is also small), the value is in packaging and documenting it.
This is pretty intriguing! We have a pretty big Backbone SPA. Would love to get some of this vdom benefit without rewriting the whole app in React. Do you have any benchmarks or memory/cpu comparisons available to show how well this new view helps with browser performance? Would be interested in load times, memory usage, perceived speeds with updates/re-renders, etc.
Nothing there actually detects Chrome headless specifically, they just test features Chrome headless *currently* distinctively has. 
pretty awesome! i'm slightly shocked to see how it's built, but it's a cool project
Loading the page crashes my chrome tab every time :z^)
IMO it's usually not necessary to use a big library to manipulate strings, most of those functions are extremely short, and the ones that aren't can be included on their own. If you really, really want one, here: http://gabceb.github.io/underscore.string.site/ For turning urls into links: https://github.com/alexcorvi/anchorme.js
I'd be very interested to see it! We are going to be doing the same thing with Vue in the future, I believe
The big idea is just simple: Every time I update my code I don't have to press refresh to see the change. Recently I am on to learning PHP and refreshing the localhost page was too tiring for me. 
That's a good point I hadn't thought of. Thanks!
I don't have hard data for you, although this could be gathered by comparing this release of converse.js (which uses Backbone.VDOMView) with the previous one. I did two things in this release which I believe improved performance a lot. I removed jQuery and I added the virtual DOM. Removing jQuery made a big difference, as is noticeable in the time it takes to run tests (much reduced now). With the VDOM, the main advantage for me was simplifying my views a lot, whereby I can simply implement pure functions (a la `renderHTML`) and let the VDOM worry about what needs to be updated. That, and the fact that my form rendering code is now much simpler.
This was pointed out a little further up the thread and I hadn't thought of it as being a particular advantage until now, definitely nice to have immutable variables.
You inspired me to write it, so here it is: https://medium.com/@michaelsholty/transitioning-your-marionette-app-to-react-4b94ddefafd1
Surprisingly, it also works perfectly on mobile
`Array.prototype.forEach` is a `for`-loop (or `while`; likely same performance), but there are two differences. - `forEach` will skip `undefined` elements in an array. It does this with a `if` statement in the loop. - The invocation of a callback likely adds a lot more overhead. An extra statement within a loop adds N-length more things to do, and could be dramatically slower for large arrays. [Lodash **does not** have this check](https://stackoverflow.com/a/18884620), opting for the 99% case, where arrays are not sparse (e.g. it's up to the user to handle `undefined` elements in the array with the callback). See the [Mozilla polyfill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Polyfill): // 7. Repeat while k &lt; len. while (k &lt; len) { var kValue; // a. Let Pk be ToString(k). // This is implicit for LHS operands of the in operator. // b. Let kPresent be the result of calling the HasProperty // internal method of O with argument Pk. // This step can be combined with c. // c. If kPresent is true, then if (k in O) { // i. Let kValue be the result of calling the Get internal // method of O with argument Pk. kValue = O[k]; // ii. Call the Call internal method of callback with T as // the this value and argument list containing kValue, k, and O. callback.call(T, kValue, k, O); } // d. Increase k by 1. k++; }
https://github.com/nickforddesign/notifire A tool for designing notifications for SaaS products
Sounds like a hardware or driver issue
The video container ‚Äî black background ‚Äî isn‚Äôt sized right on mobile, it‚Äôs too large, making the page not line up correctly
Hi /u/lluviyah, For javascript help, please visit /r/LearnJavascript. Thank you!
On mobile and curious, how's it built? All canvas?
It can't do real-time, like on a QNX OS. For example, you wouldn't use it for a fly-by-wire system on an aircraft.
Even the Help Topics work..
not saying this to offend anyone or diminish the awesomeness of this project, but it looks like this project was started a few years ago, and the structure of it reflects that. no framework, just jQuery and a lot of plugins, no build tool, just lots of scripts included in the html. it works really well and i'm sure one could argue that those tools are a great choice for this project, but i would have lost my mind working like that
Object.values
Method overloading, static typing, or keeping the developer 100% sane, to name a few
TypeScript ftw.
Agreed, but TypeScript !== JavaScript
Just because you don't get it doesn't mean you ought to put that on others üòë
I thought that's what socket.io was for?
I think you are misinterpreting he term 'realtime'. I mean actually guaranteed time of execution. There is no guarantee your JavaScript will execute when you expect it, let alone any program running on Linux or Windows. I'm just giving an example where JS is not a good application. 
It can't really be used in cases where garbage collectors are undesireable, parallelism is key, or memory needs to be shared (the last two might change soon?). JS also needs an installed runtime, which could be problematic I suppose...
If you don‚Äôt think JavaScript makes sense, you should check out Lua. Bring a towel, though.
Understandable. I was looking for clarification. I suppose it would be off if there was anything in the execution stack when the even got dispatched.
The example at the start is a little disingenuous. Nothing about React prior to v16 mandated that you have unsemantic markup. The issue was that every component had to return a single element, which in some cases led to an overabundance of wrapper spans and divs (which are defined as having transparent semantics, and cause no harm to screen readers). In the case of the example, it was easily possible to achieve the full semantics of the "semantic" version, but it'd often be littered with extra tags that were at best unnecessary bloat, and at worst created layout problems. It was possible to work around the layout problems (using flexbox was a particular pain point), but doing so usually meant you were harming the reusability of your components. The introduction of fragments in v16.2 simply enables a prettier way of returning multiple elements, because using arrays is a little bit ugly.
How does that work?
https://github.com/1j01/jspaint/graphs/code-frequency Looks like a lot of the work was done in 2014 and 2015, with a recent flurry of changes.
Extreme math. I've been doing some Euler Project prompts recently and one of my algorithms was terribly inefficient and my for loop timed out. I've also used React and accidently threw a function that ends up changing state into the componentDidUpdate method and my browser crashed. It also wouldnt be recommended for full video games either. 
I was trying to figure it out. Made a [quick JSFiddle](https://jsfiddle.net/0w3w522w/) which presents more questions than answers. It does seem to be dependent on the extra white space before "a = 3", but I don't know why.
React &lt;16 and semantic HTML are not mutually exclusive. The article seems to imply that React &lt;16 precludes you from writing a11y-compliant markup; the only thing that would preclude you is yourself.
I love it when people assume an API is stupid without understanding why it was made that way, and then start making fun of it publicly. Great way to kill your credibility as a developer.
thank you so much!! 
Operator overloading
I think /duck/ is an example. So you'd have /duck1/, /duck2/ etc. All with their individual action files.
I base my opinion on the never-ending questions and doubts people have about the whole prototyping model. I've never seen so many people stuggle with the basics of a dominant language. Just when you think they understand it, a new doubt pops up.
Nothing, it's all the powerful ruler of the full stack. That said, while that is sarcastically true, just because it can do it, DOES NOT mean it should do it. You not gonna hang a shelf with an axe now are ya...
Most WASM projects these days are compiled with Emscripten, which historically produced rather large binaries (it's essentially designed to emulate an entire POSIX environment so you can compile legacy apps / games unmodified). And most browsers could only compile WASM at around 2 MB/s. So you end up getting used to these 10-20 second startup delays. It's easy to internalize the notion that "WASM *runs* fast, but takes a while to get started." Firefox's new compiler runs about 20x faster than competing engines, so that 10 second wait drops to 500ms. And with streaming compilation, it drops to effectively 0 since you can compile as the bytes are coming down the wire. It *feels* dramatically different.
What does `windows98` logo inside of the "documentation topics" ?
I love date-fns but unfortunately it doesn‚Äôt yet have any support for managing time zones 
Hi AtmosphericMusk, thanks for liking my project! I am available for hire if you'd like that envelope. I can make that envelope for you within a day. Reach out if interested. If you'd like to give it a try, I am happy to answer any questions on how to use the lib! Thanks again!
I use Jest for unit testing all of my Vue projects. I found it to be MUCH easier to set up and manage, and I‚Äôve never encountered any issues with the built in instanbul coverage. 
I use Jest for unit testing all of my Vue projects. I found it to be MUCH easier to set up and manage, and I‚Äôve never encountered any issues with the built in instanbul coverage. 
I do use single file components and Babel/webpack. Jest may be by Facebook and originally created with React in mind, but there is nothing about it that makes it React-specific. I also use it to unit test projects that are just a node server!
Is response a promise because it can be streamed?
Its not just that. JavaScript has a garbage collection system responsible for cleaning up memory which can randomly decide to kick in at any time. Js also has a jit that can drastically alter the efficiency of a particular block of code for the future at the cost of current execution. And it has multiple other places where execution cannot be determined statically. System level languages like C have manual memory management, no gc, and can be used to design a program with exact execution paths taking a predetermined amount of time to execute. Real time in this context means that the developers can guarantee exactly how often a part of the program will execute and when it does exactly how long it will take. This isn't possible (or at least reasonable) with higher level languages that provide complex systems as part of their runtime.
Sounds like PEBCAK.
thanks, I will give Jest a shot and see how it goes! 
But then it‚Äôs no longer- oh shit RangeError: Maximum call stack size exceeded
Hmmm. Well the thing that I'm working on is that I'm writing a code to monitor air traffic between drones as in I want to prevent on air collisions and I want to show that on the screen. Like I want to show images of aircrafts not colliding. I don't know if that provides any more info. 
Super cool, but the Edit Colors dialog crashes Chrome for me :/
Oh, so you should start with this! I've never used it with PHP, but LiveReload (app and a browser extention) is what you're looking for. There are also other tools, like browsersync, but configuring it with PHP may be a bit more tricky ;)
Thanks a bunch for this. This clears up a lot. :D
The README needs to be fleshed out a bit more with examples showing off the -ables you delcare it to be. I'm interested in seeing what it does.
Is it a desktop app or a web app or a mobile app? Where do you envision the gui being displayed and where will it get it's data from?
It'll be on a desktop. It will get it from the code 
It can if the JS engine can guarantee real-time. You can write JS code that doesn't cause GC by using pre-allocated Typed Arrays. The rest is just controlling system calls and memory footprint. That being said, JS isn't ideal for that use case.
[Seems that way](https://developer.mozilla.org/en-US/docs/Web/API/Body/text) &gt; **The text() method of the Body mixin takes a Response stream and reads it to completion**. It returns a promise that resolves with a USVString object (text). The response is always decoded using UTF-8. emphasis mine
You can overload methods in JavaScript, it's just done differently. Overloading is essentially using the same method name for different amounts and/or types of arguments. In JavaScript, we can throw anything we want into a method, and do the checks of the arguments ourselves inside. In Java, this would be a compilation error, so you define them separately. Each have their advantages and disadvantages. I'd argue that providing default parameters is much more succinct in JavaScript vs making a whole other method, creating the default variable and then calling the other method, √† la Java. I'd also argue that you can technically do static typing with JavaScript, and typescript is a perfectly valid example. Since it is a superset of JavaScript and compiles down to JavaScript using a compiler that is technically running JavaScript. Compare this to something like WebAssembly, which cannot currently do dynamic typing at all. You cannot reasonably compile a dynamic language down to WASM until it gets more features.
So yeah... to do GUIs with JS on desktop, Electron is a way you could go. As the other commentator said, you'll use HTML to define the structure and connect everything, CSS to style it, and JS to manipulate and dynamically display data. :) I meant more of how the data will flow from aircraft --&gt; ??? --&gt; GUI display How is the aircraft transmitting it's position and what is registering/storing that data? What's the overall flow of data from aircraft to display screen?
I think JavaFx is better to choose, specially if your app needs to look nice or you have some experience with CSS and styling in HTML. But if you don't care that much about the look there are more examples of Java Swing online (because it is older) so you might find a better example/tutorial of how to use Java Swing.
Works fine on 63. It's just an `&lt;input type="color"&gt;`
The [halting problem](https://en.m.wikipedia.org/wiki/Halting_problem) Edit: also if you're doing the history of JavaScript, I'd highly recommend Douglas Crockford's series of talks, he's been highly influential in the development of the language. Starting, [Crockford on JavaScript - Volume 1: The Early Years](https://youtu.be/JxAXlJEmNMg).
Non-Mobile link: https://en.wikipedia.org/wiki/Halting_problem *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^139234
Huh, I'm on 63 as well. The input opens fine but changing the color makes the whole browser crash.
Because fetch() just resolves when the response is available, and it's not going to fully decode the response and store it in memory unless you actually request that. It's for performance reasons. If a response is huge, like several megabytes, synchronously decoding it will hang the UI thread. Additionally, larger responses can be streamed, in which case the full body will literally not be available at the same time as the headers. With all these things considered, it just makes sense to make the actual retrieval and decoding of the response body an asynchronous operation.
This is really cool! I set up a basic blog on a VPS instance that I hadn't been using and it was remarkably easy. 
good job! 
sort of but not really. you could do much of what ng-container is meant to do without Fragments, particularly since react 16 allows you to return children directly (which is kind of what fragment does, but without actually using fragment) or since you can write arbitrary javascript inline (unlike angular) you don't need an element at all
JS isn't just not ideal for realtime applications, it's just not possible. For many realtime applications, the time it takes an input GPIO pin changing state, causing an interrupt, the CPU switching context and an IRQ handler responding needs to be absolutely guaranteed, down to clock-cycle precision. You'll never achieve that with JS in any form.
Use `document.body.scrollTop` to get a scroll position on the body. Use [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) to store a value in the browser that persists between refreshes. Pseudo code: document.body.addEventListener('scroll', function() { localStorage.scrollPos = this.scrollTop; document.body.scrollTop = localStorage.scrollPos; });
Comic Sans font is missing üòû
Can you please add it to the userscript and paste me the code?
Holy crap, this is the greatest thing ever.
I enjoyed using BB back in the day, but I wouldn't go back to it. It's way too primitive for today's needs.
[removed]
Javascript could be providing data to those systems, but it wouldn't be possible for a JS engine to respond in a realtime way and still have it be called javascript.
also nothing minified
Start with courses on HTML and Javascript. https://www.codecademy.com/learn# has some. You'll eventually want CSS, too, but you can do things with just HTML and Javascript. If you're looking for a good first project after you've gone through HTML and JS courses, below is a more basic version of the test we give junior dev applicants. It's going to be beyond you after just those courses, but with enough research and practice, you'll get it. Use Flickr's search API to retrieve a list of 25 images, based on the user's search word, and display them. https://www.flickr.com/services/api/flickr.photos.search.html That should give you a place to start and somewhere to work towards. Once you manage it in basic javascript (hint: use chrome and its new "fetch" api to simplify things) then try making it in Angular. You'll need some Angular courses before that's possible. I don't recommend trying to learn Angular before basic JS, though. That'd be much, much harder, IMO.
See the Readme: &gt; Important: Most properties supported by Headful are only useful when they are set before the browser executes the JavaScript. For example, you won't be able to change properties used for URL sharing on social networks (e.g. Facebook, Twitter) or messengers (WhatsApp, Telegram). That means you should either prerender your pages before the deployment or use server-side rendering. Yes you can use it on the server-side for prerendering. Personally I use it for a simple (more or less) static website that is being built with Vue.js and prerendered locally before the deployment. It changes the actual DOM of the current page.
Eerily accurate.
"Real-time" is a concept entirely implemented by schedulers. There are 3 schedulers governing JavaScript - CPU pipeline, kernel process scheduler, and event loop. You just need to have those schedulers guarantee instruction cycles for your program to be able to do real-time. There is also interrupts (include system calls), which you can either manage with your code/deployment or shuffle into a specific CPU core using process affinity. Everything is "providing data" to some systems, when you write a file (in any language), you are providing data to the kernel so it can send a block of 1s and 0s to a disk controller. As long as you have a kernel module or driver that expose that as a file handler, there's nothing stopping you from implementing your IO in JavaScript or any language. 
It's freaking fast too, very impressed. 
&gt; It also wouldnt be recommended for full video games either. Unreal Engine can compile with Javascript as a target. There are definitely "HTML5" games written entirely in JS, or at least transpiled into JS. Microsoft released an experimental version of Cut the Rope years and years ago that was Objective-C transpiled to Javascript. (can't find it on the web anymore?)
[removed]
I'm personally working on a Rogue-like for the FreeCodeCamp data visualization course and it has been pretty dang hard so far. Lot of sturggle with optimization. Not saying it can't be done, just very hard. Didnt know about the Unreal Engine though!
Have you heard of js13kgames.com? Not just javascript, but js with the limit that the gzipped source+assets can only be 13kb in size. Some people manage to make some pretty nice games even with those limitations. For a more extreme example, see what people can do with just 1kb of Javascript. http://js1k.com/ 
Which is why I said currently. It's just a feature that can be added. Just like TypeScript is static typing added to JavaScript.
`reduce()` needs to process the callback's return value and returns the final value to the caller. `forEach()` doesn't do any of those.
I am kinda sure I was testing console.log there and it was working... am I drunk or wtf
Oh, crap!
OP's point was about persisting state across page changes, not about using frameworks
Pokey can [find more hot pants!](https://www.yellow5.com/pokey/archive/index175.html)
You're still several layers above actual realtime. Try writing interrupt handlers in assembly language and counting cpu cycles, and then get back to me.
Use this. (function(state) { Array.prototype.slice.call(document.scripts).some( function(ele, m) { if (m = ele.text.match(/Pricing\.init.*,\s+\[\{"State": "([^"]+)/)) { state = m[1]; return true; } } ); console.log(state); })(); 
I think the question implies what can be done given currently existing technology, not what's theoretically possible.
Webpack is basically the standard now.
I'm just going to be honest and say that if this is your first programming project, you're in over your head. That's a lot more complex than you think.
You just need to configure those layers to do real time. Linux is not a real-time operating system, but it's not stopping people from using it for [real-time](http://www.ni.com/white-paper/14623/en/#toc3) because the amount of hardware linux supports. Nobody writes interrupt handlers in application code these days. Like everything in engineering, you write an [abstraction like this](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S), and hand it off to the next layer (user land) with some guarantees. And then write the rest of your app or the next layer up in a bare-metal language (C/C++/D/Rust) or system language (if you don't care about kernel overhead). Also you can count instructions in JavaScript with `node --print-code`.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [torvalds/linux/.../**entry_64.S** (master ‚Üí dda3e15)](https://github.com/torvalds/linux/blob/dda3e15231b35840fe6f0973f803cc70ddb86281/arch/x86/entry/entry_64.S) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dswczlw.)
Yep, [my ability with MSpaint](https://www.dropbox.com/s/y5czqssaja0t2e4/untitled.png?dl=0) is exactly the same as it was [20 years ago](https://www.dropbox.com/s/xs2c9j8fs3gwgrn/-base.bmp?dl=0).
That is subjective. You can definitely build a team of a dozen engineers and make it happen. You would need everything from EE, to kernel developer, to compiler designer tho. Just "internet argument du jour" for me.
I haven't lost my talent https://imgur.com/a/tMFpu
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/mFbXOzW.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dswejb2) 
&gt; That is subjective Not really. A real time javascript system doesn't exist now. That's pretty clear cut.
Quickly decided to add it to my homescreen.
It would be a terrible fit for CPU-bound server-side applications, because on the server (as in the browser), you have a single-theaded event loop to process messages https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
My original word was "can", like in "human can go to Mars". That does not mean "human has gone to Mars". 
`console` *is* available in node, but from your screenshot it looks like it's not available in whatever environment brackets uses.
Reminds me of something I made like a year ago. It was a little painting app in canvas. Originally you could submit your images and they would appear on the main page for everyone to see. Images are locked at 256x256 (I think) https://collin.moe/paint/paint.html
Sure, if you wanna put it that way. The OP said: "what JavaScript _is not_ able to do". Present tense. "Humans _are not_ able to go to mars". Present tense. A corresponding question is "What _are_ humans able to do?", present tense. You're saying "humans _will/may be_ able to go to mars", future tense. A corresponding question is "what _will_ humans be able to do", future tense. "Are you at home" and "Will you be at home" have different tenses and are therefore different questions. So in short, you're answering the wrong question. Makes sense? 
My way was just shorter...
It sounds like dict isn't what you think it is at the time this code executes. Are you sure it isn't modified between when you log it earlier in your code and when this code is run? One thing to note about logging that could be tripping you up: Chrome (and possibly Firefox, I don't remember) lazily evaluates objects passed to `console.log`. If you log an object, then modify it, then click to expand the prior log line you'll see the values after modification as Chrome doesn't bother to fetch them until you click to expand. You can work around this by saying `console.log(JSON.stringify(dict))` instead.
at a glance looks fine to me. you could remove some "var"s and use comas between lines... it's almost-negligibly faster but also just looks cleaner... also your first uncommented line in the send has inconsistent spacing before the plus... not that it matters 
Fair enough. The verb "can" has ambiguous tense.
I have only been coding a few weeks but you never show commented out code or console logs when you show your week. And your file path should be shorter. Is your HTML and JS in the same folder? If it is it should be more like second=‚Äúscript.js‚Äù no need for that file path unless it‚Äôs not in the same folder. 
That makes sense. In your first version, what guarantees onReadyHTMLStateChange runs after onReadyStateChange? If the HTML request happens to finish faster you'll run your analyze function before anything gets put into your dict. Ajax requests are asynchronous by default so if you dispatch two in a row like you're doing there's no guarantee that their callback handlers will be called in any particular order. We're you trying to make synchronous ajax calls?
Typescript throws more errors than it's worth! a headache in it's own right. Difficult to debug compared to real typed languages like Swift. I would rather stick to ESNext than TS 
What you're describing would be synchronous, not [asynchronous](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous). The lines that actually makes your browser fetch the data you want are the calls to `.send()`. Since your Ajax calls are asynchronous, your browser will start fetching the data when you make that call, but then continue executing the subsequent lines of code, including the other XMLHttpRequest send. Then, once the browser finishes downloading the data from your requests your callbacks will be invoked. Which one runs first will depend on which file download was faster. If you used synchronous requests when your browser executed the first `.send()` call it would stop and wait for that file download to complete and execute your callback before continuing executing the rest of the code and the second XMLHttpRequest. It sounds like that's what you were expecting. Note, actually doing synchronous requests is usually a bad idea. While the request is executing the entire page will be unresponsive as the browser can't run any other code until your request finishes. Asynchronous programming can be harder to grasp but it provides a much better webpage experience. Try looking up some tutorials about asynchronous programming in JS. Here's some I found to get you started: * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests * https://www.pluralsight.com/guides/front-end-javascript/introduction-to-asynchronous-javascript * http://exploringjs.com/es6/ch_async.html
Because you are using the name of your variable and then its value like this: " renderTime: " + renderTime + "ms" you should really consider using an *object*. The reason is that you can make a change in one place in your code without having to track through and make changes in other places in your code. This is especially relevant to you since we can see you have been commenting out things that you have been trying in development. You could do the following: function sendData() { let data = { perfData: window.performance.timing, pageLoadTime: perfData.loadEventEnd - perfData.navigationStart, renderTime: perfData.domComplete - perfData.domLoading, domInteractive: perfData.domInteractive - perfData.domLoading, responseTime: perfData.responseEnd - perfData.requestStart } xmlHttp.send( Object.entries(data).map(item =&gt; item.shift() + ": " + item.shift() + "ms ").join('') + " test103 "); } in doing so you might want to at some stage add **domComplete** to your function. Change it in the object and that's it, no more retyping code in the xmlhttprequest.
&gt; You can reduce the code even more by using &lt;&gt;&lt;/&gt; &lt;&gt; &lt;h1&gt;{props.title}&lt;/h1&gt; &lt;p&gt;{props.subtitle}&lt;/p&gt; &lt;/&gt; WHY? Why would anyone do this? Why? Oh, you're an asshole. Because I don't want to type. **This is not fucking semantic**, it's not readable. Be explicit about what you code, don't try to be all cute about it.
Doesn't work on mobile.
That has nothing directly to do with JavaScript. That's how floating point works. We *could* discuss how js defaults to floating point. But once you start down that road you get into a discussion about types and type systems.
Do a web search for ‚Äútemplate literals‚Äù (an ES6 feature).
Oh good to know. Thanks bud!
 &gt; 0.1+0.2==0.3 false ?
This is fast and works fine. Another evidence you don't need fancy js framework to build anything nowadays.
Even if `Object.values` wasn't a thing, the linked implementation is still one of the more obtuse ways of achieving that functionality. You can get it as a readable one-liner as per: const myObj = {a:1, b:2, c:3}; const values = Object.keys(myObj).map(key =&gt; myObj[key]); 
Thanks a lot! This was very helpful. I‚Äôm looking to make this bigger so using an object seems like an easier way to grow it. Thanks again!
Are you trying to make a point or a joke?
I was hoping for a bit more on how feasible it is to use Fragments on production grade software. Since it requires Babel 7, which is still in beta, I'm afraid something might break if I start using it already
Well most people are a bit retarded
impressive :o
https://github.com/ExpressGateway/express-gateway/ Open source API Gateway built entirely on Express.js. Interested in a overall project review. - Is this something useful? - Are you handrolling your own shit right now? - What's it missing? Love to get some feedback from Node.js or Express.js devs 
Passing this on to one of my engineers who's trying to solve this problem.
You act like framework is the modern intelligent way of design? It's just convoluted koolaid drinking. What flavor you gonna choose? Which one makes you feel the most special? "lots of scripts" so what, you think your framework any better? Jquery has and will continue to be awesome. Be original, create your own stuff, don't get tied up with some other nerds code.
what are some of the problems?
It works well and fast on Chrome (for mobile) but not Firefox (although maybe mine's outdated). On Firefox it is way slow, whereas for example, this works just fine, and generates music too: http://openmusic.gallery/music-maker.htm
Hmm that's cool!
What's really nice is this: let a spyware scanner run, and it insisted on closing the browser to delete ad track cookies. Well, when I started the browser up again, this page reopened, and *my complete doodle*was there as well! That is something too rare for web "apps". Soundcloud, for example, if you go back to its page it'll reload the stream, like it has completely forgotten what it had added to the page before.. 
It has everything directly to do with JavaScript. JS was deliberately designed to handle numbers in an incredibly dumb way that has nothing to do with strong vs weak or static vs dynamic type systems. No other language I've written (not even PHP, not even actual Assembly which doesn't have any sort of type system whatsoever) is so bad at numbers that it doesn't understand* what an integer is. *Understand is almost definitely the wrong word here but I can't think of a word that actually fits right now.
That has nothing to do with JS though
Replace JS with any language, and it still sounds right.
`1 == "1"` for example. `this` is super hard to understand. Until ES6, classes were super weird. Browsers might interpret the same code slightly differently (not as big of a problem anymore).
You'll indeed need some for of streaming download as you cannot hold the whole response in memory. AFAIK regular XHR doesn't have support this, it will always buffer the whole thing. Many "xhr streaming" libs are not true streaming: they do give progress chunks but internally it is still filling a buffer). The `fs` API is from Node.js runtime, not browsers. There is an upcoming streaming API for `fetch()` API in browsers but it is still early and experimental and I don't think Cordova is that cutting edge: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams I'd see if cordova has a HTTP library that either has large downloads implemented directly or else a streaming API you can hook up to the file writing stuff yourself. I did a google and found this for example: https://github.com/wymsee/cordova-HTTP#downloadfile
You might also like etherdraw
Just for that Webpack could be an overhead for you, but yeah, if you want to use something hot/trendy/popular that's the choice. But results will be very similar (if no exactly the same) so while you're not doing some complex assets optimization you can stay with gulp - it's doing own job well :)
I disagree. The decision to not include a type system in js means that they had to choose either 1. A method like python where the type of the value is defined by how you encode the value 2. Or by just unilaterally choosing a format for all numbers You might think that 2 was the wrong choice but imo choice 1 is just deferring the type information into the value itself instead of being upfront and defining the type on the actual variable. And, while you aren't technically wrong about it, none of this has anything to do with assembly. That's orthogonal to the issue at hand. It really does come down to how do you get a developer to tell you what type to use. And if the language doesn't require some sort of type or type hint then the only option left is to take one of the choices and run with it.
I still use Gulp, I ditched Grunt a few years ago, Webpack is still way more complex for me to actively use it
Yes they absolutely should! I'll fix that
There's nothing to disagree with here. You're confusing a _type system_ (which is where strong vs weak and static vs dynamic come in), a construct that's more aimed at the developer to prevent errors, with actual _data types_, constructs that are aimed at a much lower level. Case in point: Assembly has plenty of _data types_ (SBYTE, WORD, QWORD, etc) but has no type system whatsoever. You can have a strong, static _type system_ but represent your _data types_ with all the common sense of a potato. The way JS handles numbers is just straight up dumb, and has nothing (directly) to do with its choice of typing discipline (see PHP, a language that somehow manages to be even more loosely typed than JS and yet represents data types properly under the hood).
done
In modern Javascript (modern browsers only): if (elem.dataset.attr.includes(string)) { // ... } In older browsers: if (elem.dataset.attr.indexOf(string) &gt;= 0) { // ... } `contains` and `indexOf` are herby methods of the `String` type. They have nothing specifically to do with attributes.
yes, you can also use its interceptor to record calls from chrome and reply them in postman, as well as synching your collections online (so you can test from multiple boxes), just go for it!
there is no such thing as a class in JS
/u/adequatepimpin Instead of the `.shift()`-technique, I'd use destructuring: Object.entries(data) .map(([key, value]) =&gt; `${key}: ${value}ms`) .join(' ');
Glad to see you enjoyed this tutorial!
that plugin looks very promising. Thank you. I'll try that.
This is very, very impressive. And also I love the fact it just uses JS and jQuery, without any "transpilled" framework that hipsters love to hype. Congratulations!
Only the shortcut syntax is dependent on babel 7. You can use `Fragment` instead.
&gt;Assembly has plenty of data types Assembly has 0 data types. Those all just describe the number of bits to use for the operation. And it depends on the operator as much as the operand. And again since assembly is just running the specified opcode on the specified bit pattern it doesn't really apply to this situation. &gt;PHP, a language that somehow manages to be even more loosely typed than JS and yet represents data types properly under the hood. Php does the same thing as python but with less options. You've got int which is any number that has no decimal that fits within a 32 bit representation and float for any number that doesn't fit in those constraints. The value itself describes the type to php. That's option 1 as I described above. This stuff isn't magic. In the end the processor is going to get 2 numbers and an operation. Python and php use the format the value itself is in to determine what the type of the value is and therefore exactly which opcode to use. JavaScript always uses the floating point representation and floating point opcodes. The reason that this leads to a discussion about types is when you have a type system you can directly control which opcodes are used. If your variables are defined explicitly as int then the assembler can easily know to use the int opcodes. If your variables are explicitly defined as float that translates to floating point opcodes. There's no guesswork. &gt;There's nothing to disagree with here. No reason to be condescending here either. 
`&lt;&gt;` expresses a clear intent: multiple tags (in other words an array) that are not to be wrapped into a containing element. Why would you have any trouble parsing this? const Items = () =&gt; &lt;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/&gt; const Table = () =&gt; &lt;ul&gt; &lt;Items /&gt; &lt;/ul&gt;
&gt; My money is on "you just learned react first, and now you are biased towards react". You would be wrong. I learned Vue first. Also use it professionally, both actually. You read my arguments, if doesn't make sense to you, i would actually ask you to first pick up the other before making claims about it. &gt; On what basis, do you classify jsx as "small" while vue as "major"? Because it is. JSX transpiles function signatures, that is it. The code would fit written on my palm. It makes this: &lt;div&gt;hello&lt;/div&gt; Into this: createElement('div', null, 'hello') And that is it. Thereby it doesn't break scope and integrates with javascript, something a string template is not able to. The string template also needs a highly complex engine to parse. &gt; again, what is your basis for that? const A = () =&gt; &lt;div&gt;hi&lt;/div&gt; const B = () =&gt; &lt;A /&gt; Do it in Vue, there you have your basis.
https://swagger.io/
ES6 classes are pretty much classes.
I love loose typing! I think it is one of JS's strengths. But I agree that the whole 1 + "1" is very problematic, as are some other weird attribution behaviours in JS. It would definitely be possible to have a loose typing system without those problems. The issue at hand is how the + operator is handled in each case.
&gt; Assembly has 0 data types. ...you do know what a _data type_ is, yeah? The things I listed are _actual_ primitive data types. In higher-level languages than Assembly they're called fancy things like `int` and `short` and `long` (prefixed with signed or unsigned as needed). &gt; This stuff isn't magic. In the end the processor is going to get 2 numbers and an operation. No-one claimed it's magic. The point is that how a language chooses to allow a developer to express or not express typing is orthogonal to how the language handles actual data under the hood. The very existence of another dynamic, weakly typed language (and even untyped languages) that handles numeric data properly illustrates that. There is _zero_ logical reason to represent all numbers as IEEE 754 double-precision floating points, unless that reason is "it's too dumb to determine what the type of actual provided data is".
Eh, haven't used it much yet, but its behaviour is still prototypal in philosophy, isn't it?
Heh, true that.
Some people prefer not to use frameworks. I still do it whenever I don't have the time pressure and am working alone. The performance gains are undeniable. Framework bring an overhead after all. I also don't use build tools, I don't like how messy they make the end result. I just stabilish a pattern for modularizing my code and follow it rigorously, I even have a system for naming the script files so I don't get lost. I think it's comparable to people who still use lower level languages nowadays. Frameworks are generalizations, which inevitably cause some performance losses. The more specialized your code is, the better it'll perform.
Nocturnal is worth a look too
üëç great article though
I didn't realize that, i tested in ruby, and you're right, it gives the same as JS.
It's the same for pretty much any language. Turns out numbers with fractional parts are ridiculously difficult to work with when all you have is zeroes and ones.
I still don't quite get it. If you know beforehand what output you want, be it text, json or otherwise, it's going to load and decode in a thread anyway given that you're working with promises. In most of all cases you'd just await twice in row, so it wouldn't matter much if it could resolve in one go. Even the above hack wouldn't affect any of the points you have mentioned.
I'm starting to realize you have no clue how assembly works. SBYTE, WORD, and DWORD **do not** signify the type of the data *in any way*. Those are merely size descriptors. SBYTE is literally a single byte, 8 bits. WORD is 2 bytes, 16 bits. DWORD is double WORD, 32 bits. Now obviously those sizes are architecturally defined but those are the common bit sizes for those descriptors including x86 architecture. There is **no way** to type data in assembly. You have an opcode which takes 2 (or even 1 or 0, but for mathematical operations like we are talking about here 2) operands. Which opcode you use **determines how the data will be treated**. You can take 32 bits and treat them like an integer throughout your code. At any time if you want you can use those same 32 bits as an input to a floating point operator. There are some rules about invalid bit patterns as far as floating point representation goes, but even if you trip one of those during the operation you are still attempting to use the previously 32 bit integer as a float. If you don't trip any format validation checks then no matter what the 32 bits represented previously then for the sake of the floating point operation the bits will be treated *as a floating point representation of a number*. They won't be converted. The computer just accepts that you fed it 32 bits and told it to do a floating point operation. It doesn't know or care about types *in any shape or form*. The fact that you apparently don't understand how assembly works raises flags about your understanding of how php is handling numbers vs how JavaScript handles them. Your description isn't adequate and is ignoring a lot of both edge cases and implementation details. There is a logical reason to only use fp. I won't claim it's the best reason. And I won't claim that given a chance the original author of JavaScript wouldn't do things differently given a chance. But to dismiss it out of hand and then turn around, misrepresent assembly, and gloss over any failings that php's numeric system has hurts any argument you are trying to make.
I love you.
It's working well for me. I have no shortage of customers.
Gaaaaaaaay
why
Postman works. But I've recently fell in love with Paw, such an amazing tool.
Lmao. You know what, read these and then we can continue this conversation: https://en.wikipedia.org/wiki/Data_type (see the parts on machine and primitive data types, and also where a _typing system_ is a different thing from a _data type_) https://en.m.wikipedia.org/wiki/Integer_(computer_science) (see the list of integral data types) http://www.assemblylanguagetuts.com/x86-assembly-data-types/ (what was that you were saying about assembly not having data types?)
Did you use tame-demon.js?
So it‚Äôs working now? If you still have instanbul manually installed, you can remove that as Jest comes with it. Jest configs are very flexible, not sure I understand what issue the folder structure was causing. FWIW, I have everything inside of source but all my Vue components are in /src/components for reusable components, and /src/views for pages, and I keep my pure js files in other directories.
I guess I could sum up my problem as this: I can not figure out how to have two root folders of source code, and coverage reports, at the same time. When I have one root folder of source code, Jest works, and I'm guessing Karma/Istanbul will work as well.
Hmm, how are you running Jest? Have you added any Jest configs to package.json? I found that I had to add a bunch of test ignore patterns and coverage ignore patterns because Jest was looking in TOO many root level directories.
http://i.imgur.com/Hg9vV6o.png
ha, so I didn't do very much due diligence on this configs and instead was sort of copying/pasting configs from their examples. now I'm really looking at it, I assume it has to do with babel. "jest": { "moduleFileExtensions": [ "js", "vue" ], "transform": { "^.+\\.js$": "&lt;rootDir&gt;/node_modules/babel-jest", ".*\\.(vue)$": "&lt;rootDir&gt;/node_modules/vue-jest" }, "snapshotSerializers": [ "&lt;rootDir&gt;/node_modules/jest-serializer-vue" ], "mapCoverage": true, "collectCoverage": true, "coverageDirectory": "reports/coverage", "coverageReporters": [ "json", "lcov", "text-summary" ] } Jest is very simple, and I assume it automatically discovers tests because the tests are in a folder called tests. The babel config is the only thing that has test-specific configuration: { "presets": [ ["env", { "modules": false, "targets": { "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] } }] ], "plugins": ["transform-runtime"], "env": { "test": { "presets": ["env"], "plugins": [ ["module-resolver", { "root": ["./src", "./components"], "alias": { "@": "./src" } }] ] } } } 
Seconding Paw. I just love the shit out of the UI.
If you can get hold of Visual Studio you can debug js in the IDE while viewing the app in IE
Jest can find tests based on several different indicators, you can also just name your test files whatever.spec.js, and they will be found if their directories are not ignored
Why don't you use the [debugger statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) instead? 
What an original idea
Funnily enough, I came to the exact opposite conclusion. With webpack, I could just use npm scripts with various cli tools, and everything was fairly straightforward, but with grunt/gump I needed to edit these weird task files and then invoke the task files with grunt/gump. Seemed like an unnecessary indirection. When I started with webpack, I could just set a few options in a config and define the entry and exit and get started. Add some plugins along the way. And most of that was just copying directly from the docs. Plus, I would be surprised if grunt/gulp were in widespread use for new projects 10 years from now. I didn't want to invest any time in something that was declining in usage. Am concerned about the way your code can become tied to webpack though. There are some features which could bite you later if you use them and try to transition to something else.
Chrome Android 8.1.0 drawing doesn't work.
Re-creating a framework to learn about why all the parts of the framework exist is probably the best way to learn. If doing the grunt work that a framework abstracts away from you sounds like a nightmare, it's because it probably is. But it doesn't mean that you shouldn't do it to get an appreciation of what the framework does for you.
Modules have 'use strict'; turned on automatically, making this less and less relevant.
Many COBOL developers say the same ... ;-)