Share your HTML code. As of now I can only say, try putting the loop in quotes : document.getElementById("loop").innerHTML = loopcounter[i];
document.body.onkeydown = function (q){ if(q.keyCode == 81) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-3').click();} else if(q.keyCode == 87) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-4').click();} else if(q.keyCode == 69) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-5').click();} else if(q.keyCode == 65) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-6').click();} else if(q.keyCode == 83) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-7').click();} else if(q.keyCode == 68) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-8').click();} else if(q.keyCode == 11) {document.getElementById('canvas-msg-g-bt0').click();} }; document.getElementById('canvas').onkeydown = function (qq){ if(qq.keyCode == 81) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-3').click();} else if(qq.keyCode == 87) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-4').click();} else if(qq.keyCode == 69) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-5').click();} else if(qq.keyCode == 65) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-6').click();} else if(qq.keyCode == 83) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-7').click();} else if(qq.keyCode == 68) {document.getElementById('pl-answer-71d678ad-6b85-4de2-aa20-bd3e7c14d3fc-8').click();} else if(qq.keyCode == 11) {document.getElementById('canvas-msg-g-bt0').click();} }; document.body.querySelector('#requestform &gt; a').onkeydown = function (qqq){ if(qqq.keyCode == 32) {document.querySelector('#requestform &gt; a').click();} }; http://i.imgur.com/82v0lbs.png
Fine. GAWD.
check if you get any value when you do console.log(f[b]) and try using: surround = s[a].concat(f[b]); Hope it helps!
you could try [leaflet](http://leafletjs.com/). also, from looking at the example you posted it looks like they're using this for the map part: http://jvectormap.com/.
https://github.com/raganwald/raganwald.github.com/commit/885f0db2f8318df6acec261cf4244cc257b5f5af
Yes atom crashed or caused the computer to run out of memory.
In my professional/corporate experience the people who hate JavaScript the most are shitty Java developers who cannot do anything outside of Java and are forced to write JavaScript without any delay or training. Every tool they use is written in Java and so when they code in JavaScript they force the language to look like Java until they fail... at which point it is the language's fault. I just left a major dot com where this was the majority of the code. JavaScript hating, in my experience, isn't a thing for any other developer. If other developers are smart enough to know any language other than Java and still don't like JavaScript they simply choose to not write in JavaScript or find some simple transpiler. A major gripe with the article (and I have seen this elsewhere) is they act like Prettier invented code beautification.... as though this sort of magic was never existed before. This isn't a complaint of Prettier. It is a complaint against stupid people. Example: https://www.reddit.com/r/javascript/comments/6g8adf/prettier_has_surpassed_standard_as_mostdownloaded/diog5wo/
_Yes atom crashed or_ _Caused the computer to run_ _Out of memory._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^RogueNinja64 ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
Comparing and diffing any two files side by side is a +1 for VS Code!
Doesn't Marko also support async server side rendering? How do you notice that SSR is a breeze any other specific differences with SSR using React?
TS' analyzer is probably the best one. VS Code also uses it for JS and it can gather type information from JSDoc comments and type definitions (those d.ts files, if available, are automatically downloaded for your project's Node modules).
`.test()` simply mimics `.exec()` here: * Without `/g`: first match only * With `/g`: all matches Not that intuitive (or useful) for `.test()`, though.
Nope, sorry. I learned the hard way, by just banging my head against it and _staying out of insert mode_.
`vim-tutor`
Thanks! You're the first one to actually give advice on what to do. 
I guess SSR depends on the implementation and tbh I haven't used SSR in React production work. So I wasn't implying that SSR is difficult in React (is it?). But I happen to like using Koa on the server and there was a really straightforward guide in Marko docs with gzip and streaming support. Then on the client-side, add one (or two?) lines and it bootstraps the components you're using there (I don't have to include the outer-most template in my client bundle). It does feel a little bit "magic" but I also don't really care about the implementation and it's been perfectly flexible and performant. Anyway I wouldn't say there's like a single killer feature that Marko has I mean they're both very similar, but I have enjoyed using it and recommend trying it if the project is relatively small like mine is. My UI is super lightweight all the heavy lifting is done in other modules.
Wow, I think this is for people who know vim better than I do haha. Does it address my splitting concerns, or was this just meant as general advice?
try changing the parameter passed to the querySelector method to a simpler one, something like: document.querySelector("#onetwothree"); and change all the elements with the id "#requestform &gt; a" to "onetwothree" Check if that works...!?
To take this another step further, commonalizing internal utility or component code. It's real easy and fun to find yourself making extravagent library like code for common use within the company, but if you are doing this before you have multiple use cases you are probably over enginenering the solution. Even if you have multiple use cases, you are probably overengineering the solution.
Ebay's actual UI design has nothing to do with the UI framework it uses any more than Facebook's UI design has to do with React. Are you really this obtuse, or were you just hoping to sneak in a cheap shot under the radar?
Well VSCode made it out without such decision somehow, am I right? What's the problem here?
Something was different back then?
I'm not sure if this is true for VSCode, but that does pretty much describe what Chrome is.
&gt; This is the state of affairs with all code, whether functional, OO, whatever. We have “leaky abstractions” like iterables. The (strongly-typed) functional tradition is different. It allows creating non-leaky abstractions, e.g. if you enforce that monad implementations must conform to the monad laws (perhaps by requiring them to supply proof of this at the type level - I believe I've seen this done in Idris) then that becomes a non-leaky abstraction.
Note that the built-in TypeScript support also results in great code completion and the likes for Javascript.
&gt; Cleaner templating syntax than JSX (with features like loops and conditionals that you'd expect from more traditional templating languages) I think you misunderstood jsx a bit. JSX is not templating system, it uses control structures from javascript. So there is no need to include things like ngFor, ngIf. Missing this "features" in intentional there, you definitely would not want it there and you cant expect them there. Basically, its THE reason people want to use JSX instead of templates
http://i.imgur.com/ErqBkof.png in green circle everything works perfect in red one button and it's not work, I don't know what im doing wrong button code: &lt;a class="btn btn-primary" onclick="check();"&gt;Launch Request&lt;/a&gt; http://i.imgur.com/frYBo9p.png 
Chrome vs Chromium.
Be a problem solver. Don't have a way to do something? Scour the net like a famished dog until you find a way.
with this code http://i.imgur.com/WhVn5Nz.png button #32 works only once or when i click to the place where this button is http://i.imgur.com/DWO5Nry.png like that 
Good bot 
Am I the only who uses WebStorm?
How are you finding Atom 1.19 compared to 1.18 for your larger files and projects? Is it noticeably faster?
Probably not, WebStorm is quite a good IDE.
The problem with this approach is that writing a plugin becomes a bigger chore for the developer it won't mesh well with their development environment. The vision I have for these plugins is that plugins are expected to expose an API in a specifc manner, and that API is called by the application. But authoring a plugin should require as little bootstrap code as possible with a very clear way of separating the actual logic of the plugin, from whatever bootstrap code is needed. I've been spending almost a week on this problem and I've finally found a solution that meets most of my requirements. https://www.npmjs.com/package/webpack-runtime-require This exposes a global "Require()" function that exposes the modules of the app. I can't, at runtime, ADD modules to the app so the idea of one plugin explicitly importing another is out the window. I can then use a webpack loader on a plugin itself to covert import/require statements with a call to the global Require() function making this aspect completely transparent. What's nice about this, is that I'm not even imposing anything on anyone. If you want your plugin to stay small in size, then use my webpack loader to leverage dependencies that the app bundle already has. Any out-of-the-box or "official" plugins I might provide will certainly follow this pattern. But if say, you, wanted to develop a plugin for this thing, no one is forcing you to use this approach. The app still has to provide a global plugin loader function since these plugins are loaded at runtime and I'm not aware of any other means of loading a script at runtime and getting access to whatever it exports. So basically, the app might do something like this: import 'webpack-runtime-require'; // exposes global Require() function plugin_loader(plugin_cb) { plugin = plugin_cb(); plugin.doSomething(); } window.plugin_loader = plugin_loader; A plugin might look like this: var d3 = require('d3'); var plugin = { doSomething: function() { d3.blahblah(); } }; plugin_loader(function() { return plugin; }); But using my webpack loader, it would end up looking like: var d3 = Require('d3'); var plugin = { doSomething: function() { d3.blahblah(); } }; plugin_loader(function() { return plugin; }); So, from a plugin author's point of view there is just one line of webpack config to allow their plugin to leverage modules that are already part of the app bundle. There is no hassle or fuss when it comes to unit testing. There is no need to fuss with externals, and there is a decent separation between the bootstrap code to make the app aware of the plugin, and the plugin's logic itself. But, other than calling that plugin_loader global function, there is no other imposition being made on a plugin author. A plugin author is free create a bundle using browserify that includes its own copy of d3 if the author was so inclined (maybe a newer version of d3 has new features that the author wants?). 
Marko supports async rendering and streaming (with early flushing) for server-side rendering. Also, Marko has extremely fast rendering on both the server and in the browser and the runtime is very small (improving page load times). Marko is not coupled to a VDOM and this allows the compiler to produce a program that renders to an HTML stream on the server and, for the browser, the same view will render to a VDOM tree, thus allowing Marko to optimize for both server-side and client-side rendering. With Marko, we are able to a do a lot more optimizations at compile-time because we "own" the compiler. For eBay, lack of async rendering and poor server-side rendering performance (Marko is faster than other UI libraries by a huge margin on the server (see: [benchmarks](https://github.com/marko-js/isomorphic-ui-benchmarks))) were blockers when considering other UI libraries. Most of the other improvements in Marko are nice-to-have (but important) things like reducing boilerplate, clean syntax that is compatible with HTML, simple event handling, etc.
I think that will be a good change. I had seen the threads discussing that and it looked like the community was split and that there were some performance concerns with supporting both, but glad to see that you all are making the change.
I can't see how there'd be any performance concerns as we'll fast-path "class" to be a "className" property on HTML namespace DOM elements. Personally, I've always wished React supported "class", as it reduced the learning curve.
Definitely on my older laptop. It doesn't seem to care at all.
It's not "just HTML" that Marko supports. Marko is a superset of HTML that combines the expressiveness and familiarity of HTML with the power of JavaScript. Here's a contrived example to hopefully clarify: &lt;if(input.firstName)&gt; $ const fullName = input.firstName + input.lastName // It's just JS &lt;div&gt; Hello ${fullName.toUpperCase()} &lt;/div&gt; &lt;/if&gt; &lt;color-picker colors=['red', 'green', 'blue'] /&gt;
Wow, that's great to hear that it's noticeably faster. I'm not sure what you meant by it doesn't seem to care at all, though?
And MS actually used Chrome as an example when they were thinking about how to licence Visual Studio Code. https://github.com/Microsoft/vscode/issues/60#issuecomment-161792005
I've always treated regular expressions in javascript a bit as a primitive, in the way that I thought that they were kinda immutable-ish. I've always thought that the test method just returned a value without mutating the regular expression itself, because why should it? I'm amused by the fact that my view of regular expressions were just plain wrong. And not even in my wildest dreams I saw the possibility to use a regular expressions as an overly complicated "toggle".
You should not check generated files into version control. Your branches should just contain the source file and your build tool config. Your build folder should be listed under .gitignore. With this setup, everybody working on the project may perform a build on his own, without checking it into git. 
So when you git push, you then build on the server? Because I thought it's not good to keep npm, gulp, ... on the server, I might be wrong.
Excellent explanation, thanks. Helps when justifying what technology to use!
You could build on your dev machine and deploy the built files manually to the server.
Hi /u/tpucci, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Wasn't keen on this test's UX... it's not even clear what you should type in 'Other' given none of the choices are correct, such as #6. \#4 also claims it's undefined which doesn't seem correct
React calls itself a library and Marko is in the same category as React. The line between framework and library can be a little blurry at times and I see aspects of a framework in both React and Marko (since React and Marko maintain a lot of control over component lifecycle, event handling, etc.). The authors of both React and Marko have aimed to keep the API surface area a minimum and leave a lot of decisions to the developer. Angular is definitely in the framework category because it takes ownership over a large part of application structure and there will be lots of references to `angular`/`ng` in your code (your entire application will be tightly coupled with Angular). On a related note, in Marko, you will never actually reference "marko" in your code (only the file extension) and that was completely intentional. &gt; What I'm curious about is the claims of being "blazing fast" - especially compared to Preact. Is it that you just don't use a virtual DOM? Yes, not being tightly coupled to a virtual DOM and rendering directly to a HTML stream on the server (instead of rendering to a VDOM tree that then has to be serialized to HTML) provides huge performance gains. Also, Marko has a really good story for async rendering and that allows for parts of the page to start rendering and flushed to the browser even before you have fully retrieved all of your backend data needed to render the page. &gt; Do you have fewer features? Where is the tradeoff? The tradeoff is that the Marko compiler is more complex (React is just a runtime while Marko includes both a compiler and a runtime). Using JSX with React is completely optional and JSX just does a simple transform. We can add features to Marko without paying a price at runtime because of our compiler and that allows us to add more features and to evolve Marko very quickly. We feel the tradeoff of having a reasonably complex compiler is worth it since it allows us to boost runtime performance and keep the runtime small, fast and modular. For more details, please see: [markojs.com: Marko vs React: An In-depth Look - Differences in compilation](http://markojs.com/docs/marko-vs-react/#differences-in-compilation)
I should have clarified. There were concerns around supporting both "class" and "className" to avoid breaking apps. Is the change from "className" to "class" going to be a breaking change in React v16?
It shouldn't be a breaking change as we won't remove `className`. If you tried to use `class` now, it shows a warning message about using it – we'll remove that warning.
Big companies like Walmart, eBay, Netflix, Facebook, etc. have to deal with often unique challenges like scaling development across lots of teams, scaling performance to support high traffic, keeping sites robust and secure, or scaling across multiple platforms. Personally, I think it is awesome that all of these companies invest in open source and make efforts to raise the bar.
Apparently their customisations are limited to different configuration values - Chrome's are rather more extensive (though still limited) compared to stock Chromium. Also, I I had no idea IntelliJ was actually open source. That's pretty cool.
I was actually just on there : ) ... Found a lot of videos on Youtube (mostly about the summit) or really short videos about how to do XYZ. But I haven't seen much on building a full version of something (some exist for Polymer v1.0).
&gt; copy/pasting bootstrap snippets You know there's a react version of bootstrap already right? or do you work on that library ;)
the vscode team's been continuously adding contributions to the plugin. can't tell you if it's better, but it's definitely been getting love. 
are marko components composable? can I do something that mimics: let C = () =&gt; &lt;div /&gt; let f = C =&gt; p =&gt; &lt;C foo="bar" {...p } /&gt; let C2 = f(C)
Question 4 is wrong. Paste your code into the console and watch as it works. Ones where the answer is "other" need to remove whitespace as it's saying that function(){ return 'A'; } is wrong as the right answer is function(){return 'A';}
Didn't really seem to make an impact on performance having larger files
the project I'm working on is meant to be small with specific chunks of functionality. Plugins are there to really just abstract away specifics of that functionality. The project is an alternative to Sonarqube, whose concepts I like, but I hate its implementation and how it's riddled with enterprise-y features that I don't need. The scope of my code metrics dashboard is MUCH smaller. Take output from tools you're already using, normalise that output into a standard format, then display it somehow. Plugins are essentially just tool output parsers written in python (think parsing coverage reports, linting reports, SCM commit history, etc) and display widgets written in JS (think graphs over time, highlighting certain issues etc). Those display widgets won't be given data, they will be expected to fetch data from http apis provided by the app, or fetch data from other APIs somewhere else (eg, your CI server or something, who knows, show the weather if you want!). From a dev time perspective, this is what will get me from start to finish the fastest I think, including writing out of the box plugins for some common things like parsing output of git, eslint, svn, pylint, coburtura reports, etc, and has a very very low barrier to entry for other people to contribute plugins if this project of mine ever becomes popular enough. Short, sweet, and simple. No need for elaborate contracts, fine grained control, or anything else. Maybe this project will explode in popularity and a gazillion feature requests will necessitate something more complicated and future versions will introduce increasingly stricter contracts with increasingly granular plugin types. Most likely it won't though, so choosing a more complex architecture just because maybe in the future it'll become necessary seems like over engineering to me ;)
Visual Studio (not code) notoriously crashes, and not ever run on macs
Likely not breaking, but something you should be doing is declaring `i` and `loop` so they don't leak into global. for(var i=1;i&lt;10;i++){ loopcounter[i]++; var loop='loopcounter'+i; Additionally, if you're looping through the `loopcounter` array, you should start at 0 (unless there's a specific reason you're starting at 1?) and loop up to `loopcounter.length` (unless there's a specific reason you're stopping at 10?). for(var i=0;i&lt;loopcounter.length;i++){ Otherwise, as it is now, you're not hitting the first and last elements in `loopcounter`. If `loopcounter` had a length smaller than 10, it could cause your error. Since its not, I'm betting on what /u/fraenkthetaenk96 said as being your problem.
Technically, you should also add tests when things go wrong; create a test that reproduces the defect, then fix the code so the test passes. Doing so helps prevent pesky bugs from continually resurfacing over time.
Yeah I thought there were problems with code
I have to turn all the plugins off except for vim-mode-plus in order to use atom without it lagging so much that letters take half a second to appear Faster program? Yes please
This one gets my vote. When experienced JS developers engage in their own little private games of code golf, they fail to recognize that a codebase needs to be maintainable by the devs who come after, who may have zero knowledge of the problem-space. This would be my argument in _favor_ of redux-style boilerplate; it creates easy-to-follow breadcrumb trails so that new devs can onboard quickly, by pattern-matching, while they're still getting familiar with the project. 
Fix the seller dashboard, it could be greatly improved.
Good point!
This wasn't fun at all
as a general advice :)
Vue 2.0 beats out React in a few benchmarks, or comes close to a tie in others
I'm not sure if I have misunderstood what you are saying, but I think what /u/0x13mode is saying is that it is perfectly acceptable (encouraged, even) to use 3rd party libraries, but that you should create some abstraction over them so that they aren't so tightly coupled to your app. For instance, in your Node app you are using the "request" 3rd party library to make HTTP requests. You could reasonably argue that creating a separate HTTP service that implements "request", and then using this service within your app, is a better approach that requiring request directly at the point you need to make your requests. The reason for this, is that if you decide that "request" is no longer suitable for the job, and you want to use a different library to make your HTTP requests, you simply have to update your HTTP service to implement the new library - not search through your whole app to find every place you have used "request", and re-implement the new library. This avoids the tiresome search/replace exercise (because you make a lot of different HTTP requests!), but maybe this new library is promise based (vs. "requests" callback based approach), and therefore you will only have to deal with the pain of refactoring your HTTP service, rather than all of the different implementations throughout your app.
I agree with this, and it's great for beginners, but it's worth noting you can definitely get a lot more power out of reduce. Learning LISP is a good way to understand the power of recursion, and with parameter deconstruction you can get very similar patterns with reduce. I've found I can very often replace a forEach with state variables only used inside the iterator function with a reduce that returns the new version of the state variables, thus avoiding variable leak and sometimes making it a bit easier to understand. (sometimes) 
The worst I've seen, I think, is when developer thinks that he's experienced, but he isn't.
that's a classic from Intellij, `sout` `tab` `arsljarlshnd` `alt-shift-f10` debugging I call it. You really can't be Jetbrains IDEs when it comes to live templates. They pushed the game even further in 2014 when they introduced POSTFIX completion which allows you to type some pattern like ``` variable.if &lt;tab&gt; ``` and directly convert that to ``` if (variable) { } ``` So glad that all of this glory is now available for us C# developers with Rider.
Yes and no. Yes, you can interpret a Redux architecture as a vague form of OOP if you squint enough. Justin Falcone's recent post [What's So Great About Redux?](https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b) makes that argument pretty well. On the other hand, it's also entirely possible (and highly encouraged) to have more custom and advanced reducer logic that goes well beyond just another switch/case setup. I have some examples of this in my post [Practical Redux, Part 7: Form Change Handling, Data Editing, and Feature Reducers](http://blog.isquaredsoftware.com/2017/01/practical-redux-part-7-forms-editing-reducers/). When you complain about "lack of use of proper OOP techniques", I'm assuming you're arguing that Redux should really have made class-based models or something similar. That goes against the core Redux principles of plain serializable state data and functional programming approaches (which I talked about in my post [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/). Now, there _are_ actually dozens of Redux abstraction libs out there that try to retrofit Redux with class-based models whose methods are action creators and reducers, so it's _possible_, but definitely not the intended usage. All that said, I'd definitely agree that most people don't seem to read the "Reducing Boilerplate" page :)
&gt; Personally, I think it is awesome that all of these companies invest in open source and make efforts to raise the bar. Took the words right out of my mouth. It's fantastic! Big companies _need_ to play ball with the open source communities or risk being undermined by technologies they don't understand... And it does the world a lot of good &amp; makes for great PR. That's more or less the point I was implying to BrianBoyko. 
build on the server. Building on the dev machine leads to nothing but needless hassle.
Test domain logic. Everything else is debatable. For UIs I find it easier to write some E2E testing for business critical functionalities at most and leave the rest to QA.
Atom is dead. VSCode has won. Don't use dead things, just like you wouldn't use a horse-drawn vehicle in this day and age.
One thing to keep in mind is; every single browser (chrome/firefox/safari/etc), at the end of the day executes code in "vanilla" JS, html and css (for 99% of scenarios). All these libraries (like jQuery) are written/built in JavaScript, which means there is always a way to write it in vanilla js ;).
I can't say that using lodash or any other module is a really bad thing. Sometimes it's better, I think, to use a module instead of the native js implementation. For example: working with dates, http requests, files. If the module solves the tasks better then the native one and it's small, I'd use it.
We already have angular. . . I'll see myself out.
I get JSX. In the most general sense you still have to write "templates" when using React, Vue or Marko. Instead of getting caught up in semantics tho it's good to think about why someone might actually want to invert control and use higher level abstractions. It can be faster to write, easier to read and the syntax is very easy to grasp. A lot of web apps rely on very predictable patterns. In my particular use case Marko has been perfect. Neither templating language nor JSX is universally better and using a templating language client-side again helps highlight why templating languages are still around.
I seem to remember they added a feature recently that would use JSDoc comments for the JavaScript autocomplete. I find VS Code just that little bit snappier and for that I tend to use it over Atom. 
I don't want to compare because I know that text editors are subjective and you shouldn't compare them, but... You're wrong. Atom has more commits, more watches, more stars, more forks, more branches, more pull requests and way less issues than VSCode: http://i.imgur.com/8rPC676.png http://i.imgur.com/4kdtgYu.png No point saying one or the other has "won". This is a nice new feature for a great text editor, just like VSCode's multiple projects per window is a nice new feature for a great text editor. They are starting to become more and more comparable as time goes on in terms of completeness and usability and that's a good thing.
Reduce is indeed confusing to beginners. I took too long to understand it fully, and then, well, it changed my life XD It would have been a nice addition to mention how powerful they all become when you start chaining them.
The ignorance is strong with this one.
I found the vim plugin on vscode to be functional enough compared to vim-mode-plus on atom when I switched to vscode recently. Honestly though l, as long as it works with the "change in between quotes and brackets" shortcuts I'm generally happy.
Agreed, and I too can't understand why this relic is promoted here time and again. Unbelievable that people are willing to use editors which can't open files larger than 20KB, and sometimes when it does, the syntax highlighting and analysis goes for a toss. On the other hand, both Sublime and VSCode can handle large files (20MB+) just fine, without disabling syntax highlighting and analysis. However, I don't think it's just "ignorance". Editor love is a bit subjective alright.
&gt; Can't deny that VS Code is faster than Atom. Even still? Atom seems a lot faster for me now than it was before.
The first four or five were 'B' so I spam clicked B and the rest weren't B haha It was fun, though I think number four might be wrong (it told me it was undefined but I think it was B);
i can't stand marko. (jmho)
Yeah I understand that libraries are just written in the base language, what I meant with my question was more, is a a easy vanilla js way to do it :p
shouldn't be using?
Change the jquery code to the vanilla javascript equivalent. May cause problems with cross browser var $output = document.getElementById('output'); window.addEventListener('scroll', function () { var scrollTop = window.pageYOffset, elementOffset = document.getElementById('my-element').offsetTop, distance = (elementOffset - scrollTop); $output.innerHTML = '&lt;p&gt;' + distance + '&lt;/p&gt;' + $output.innerHTML; });
&gt; I'm assuming you're arguing that Redux should really have made &gt; class-based models or something similar. Actually I'm making my own OOP alternative to Redux, which is inspired by Redux (among others), but there are object based models like in Smalltalk (so you dispatch actions directly to the objects, not to the "store". And you don't have to use `dispatch` function because actions are automatically dispatched after you call a method. So you call: counter.increment(10) instead of Redux-like approach store.dispatch({type: 'increment', payload: 10}); I just think that manually dispatching actions is too low-level. But this is not really a problem because in Redux you could also make something like "action creators which would automatically dispatch an action". The bigger problem is that Redux operates on `store` level, one root object. It's too coarse grained. Redux is a forest, not a tree - you can't easily to subscribe to changes in particular sub-object, or send action to the sub-object within state - you always send actions to the Store. Redux is super simple but I think it's too simple, because people need _some_ level of complexity to solve complex problems they have when making real apps. &gt; have made class-based models or something similar. That goes &gt; against the core Redux principles of plain serializable state data Object based models also can be serializable, maybe not always out of the box, with some additional code (e.g. using special method for serializing). &gt; and functional programming approaches Functional programming is not against OOP. 
We use a number of bootstrap based themes that extend the base bootstrap with new components and widgets etc.
I use it with my vim setup and it works as expected. 
Depends on what you are calling your server machine. If it is your production machine, then yes, installing build tools etc. Is a bad idea. Normally you have a build chain or CI/CD pipeline. It typically consists of a build server (Jenkins for example), version control for your binaries (artifactory) and a deployment automation system, you can use Ansible with Jenkins for eg. It does require a lot of effort investment, but there are many cloud offerings if you are open to it. You can build your pipeline in stages, so not every piece of the puzzle needs to be in place immediately. You must have a build machine at the minimum though. 
I think the author understates the importance of this test. Some concepts it tests will save you time debugging and pulling your hair off.
Good quick guide! Why didn't they use just a fn reference for the last (easiest imo) example though?!
&gt; I had to switch to visual studio code on my work Mac because it crashed all the time. Facing a similar issue, also on Mac--Atom would crash when opening additional files via finder or Cyberduck. Can be infuriating. Had to move back to Textmate. I want to love Atom, but crashing while doing basic text editing and file i/o is pretty much #1 on the list of things that gets you flagged as unreliable.
Because opening 20KB+ files happens like 0.00001% of the time. That's not enough reason for most people to quit Atom. I'll enjoy using Atom the other 99.99998% of the time.
[removed]
Reposting this because this subreddit hates shortened links and the link doesn't work well with reddit The issue I almost always see with lodash is that people start to second guess their own codebase, they add a \_.get here and a \_.get there and all of a sudden you don't know whether the object you have is actually there or some accidentally wrongly provided default value. I completely agree to use lodash for projects where the goal is to be a distributed module that many platforms use. If you control the platform a specific thing runs on you can make an assumption of the language from that point onward. If you need to target anything less than v6 then go ahead, the last thing you want to do is compile your server-side. If you do anything in Node v6 plus you have a lot of built-in features to the platform which you can make assumptions off of. I also thing it's unfair to compare [modules dealing with time](https://www.youtube.com/watch?v=-5wpm-gesOY), dealing with XMLHttpRequest(https://developer.mozilla.org/en-US/docs/Glossary/XHR_(XMLHttpRequest)), and file IO. I would say that Node's file IO isn't _terrible_, and it's not something I'm immediately grasping for a module. I guess my problem with lodash and lodash derivatives is the overuse of certain functions with the assumption they work a certain way when they don't. That said, there is nothing wrong with lodash itself. It's a great library but it enables poor unskilled development too easily.
Video linked by /u/sieabah: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [The Problem with Time &amp; Timezones - Computerphile](https://youtube.com/watch?v=-5wpm-gesOY)|Computerphile|2013-12-30|0:10:13|37,986+ (99%)|1,338,701 &gt; A web app that works out how many seconds ago something... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/sieabah ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dldzl29\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
`reduce` has certainly reduced the size of my code :D
Reduce doesn't have to return a number, or even something less complex than what you started with. Here's a reduction of an array of numbers into an object where every value is the key squared. const obj = [1, 2, 3, 4, 5].reduce((r, num) =&gt; { r[num] = num * num; return r; }, {}); console.log(obj); // { // 1: 1, // 2: 4, // 3: 9, // 4: 16, // 5: 25 // }
If you do not have `http://` or `https://` in the url, then it doesn't treat it as a new website but rather a different page of the current domain. This is nothing unique to the `window.open` function but rather how the internet works as a whole. There are some places where typing just `www.example.com` will work because the service will automatically add the `http://` for you, but at some point that Hyper Text Transfer Protocol tag must be prepended for it to work.
I don't see anywhere in their features where they can record a user's screen. What they can do is record all of the inputs and then put all that data together to create a replay, but it's not actually recording the user's screen. The input recording is not magic either. You can do it yourself with [standard events](https://www.w3schools.com/jsref/dom_obj_event.asp).
Fixed &gt;Thank you for reporting. We have adjusted API limits that should ease this immediately. Our monitoring is clearly not sufficient and we will follow up with process improvements to avoid this recurring.
Nice introduction. I often see `map` used to perform some action on each element of an array even though the return isn't needed. I realize it's only an introduction, but the power of reduce is a little under-sold. I think it's worth pointing out that reduce can even be used to implement `map` and `filter` (and `forEach`, but that's less interesting to me). e.g. function map(mapper, array) { return array.reduce((accumulator, element) =&gt; [ ...accumulator, mapper(element) ], []) } function filter(predicate, array) { return array.reduce((accumulator, element) =&gt; predicate(element) ? [...accumulator, element] : accumulator, []) } console.log(map(item =&gt; item * 2, [1, 2, 3])) console.log(filter(item =&gt; (item &gt; 5), [1, 9, 4, 2, 42]))
Thanks for reply. "The input recording is not magic either" - I know this was no magic for me. They actually record users screen I tested it on my website. And I can see what every user does. Like really see in a video player their screen, what did they do! Now, this is what I is cool. I thought maybe they get your html + assets on initial load and then render on their server server with PanhtomJS a "clone" page and when user is clicking or doing other events they send it to their PhantomJS instance that reproduce the same behaivor. And being on their server, they can record the screen. I found a link on youtube that demonstrates that recording: https://www.youtube.com/watch?v=VwJvF68NgbY
So if I'm looking through an array of objects for a property with a specific value how could I use these methods to do so? Example being, I want to know which item has Array[i].value === 7
 const array = [ { id: 1, value: 3, }, { id: 2, value: 25, }, { id: 3, value: 7, }, { id: 4, value: 120, }, ] const findValue = (array, value) =&gt; array.filter(object =&gt; object.value === value) findValue(array, 7) // [{ id: 3, value: 7 }]
Have you tried it on another code editor ? 
(Author here!) God, yeah, I kind of poked shade at early DHTML-era code, but wow I *loved* that stuff. The 1x1.gif trick alone was absolutely mind-bending stuff when it was first coming out, and it let us do things with table design that was totally unheard of before. I have really warm fuzzy feelings from those old days. Don't ever want to have to work in that environment again, but it was a really exciting time to build web pages.
Filter will return an array of values that match. Find will return the first value that matches.
Thanks I thing I must pass a bit more time in Tern documentation to understand how to configure it to my needs. I actually need it to a react project. Have you an idea how to do that? 
 let item = list.filter(item =&gt; item === 7).shift() would work to get the item itself. If you're asking to know which index it is, a traditional for loop might be best.
What do you mean by fundamental JavaScript concepts? This can be interpreted in a lot of ways. Do you refer to JS related stuff like (callbacks, scoping, this keyword closures et..) or more like more overall concepts (design patterns, best practices, trade-offs) applied in JS? 
&gt; In a perfect world a 'web API to database' would be more like a proxy... an automated API that was a seamless mapping of the request to database calls (with security / sanitisation, etc.). That way the client would request the fields and how they're joined, and the API would resolve them. I haven't really done anything with GraphQL myself, so I have zero experience with it. But the first time I looked at some examples I had exactly this impression that it would work great for applications that query and push simple data to the database (mostly CRUD applications). What I can't imagine is how GraphQL could help in non-trivial, multi-layered applications with a rich domain model (which can be completely different from the underlying database model). Has anyone experienced GraphQL in such environments and how does it compare to REST?
JS uses "short circuit" evaluation for `&amp;&amp;` and `||` operators. If the first operand is sufficient to determine the truthiness of the whole expression, the second operand is not evaluated. false || console.log('Hi') // Hi // undefined Where `undefined` is the value returned by `console.log()`. The second case is about truthiness. `0` and `undefined` are both falsy. In `0 || undefined`, since `0` is falsy, the whole expression evaluates to the second value, which is `undefined`. Likewise in the second case. The same goes here for truthy values and `&amp;&amp;`. a = 1 &amp;&amp; true // true a = true &amp;&amp; 1 // 1 
You can use [`Array.prototype.findIndex`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) for this: const idx = arr.findIndex(it =&gt; it.value === 7); If you want the value, not the index, use [`Array.prototype.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find): const elem = arr.find(it =&gt; it.value === 7); If you just need to know whether the array contains a value, [`Array.prototype.some`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) works well: const hasSeven = arr.some(it =&gt; it.value === 7); `findIndex` and `some` have specialized, simplified versions for if shallow equality `item === searchTerm` works in your case (arrays of primitives, or if you're looking to see if the array contains *a reference to the same object* as you have): arrNums = [1, 2, 4, 7, 11, 7]; const idx = arr.indexOf(7); // 3 const lastIdx = arr.lastIndexOf(7); // 5 const hasSeven = arr.includes(7); // true Reader's exercise: prove to yourself that a similarly simplified version of `find` would not be a meaningful function. 
`true`
&gt; Because opening 20KB+ files happens like 0.00001% of the time. That's true though. Most folks using Atom are probably not playing in the big leagues and mostly working with toy projects (todo apps, itsy bitsy ui components, that sort of thing).
There was a thread a while ago with a similar topic: What 10 Things Should a Serious Javascript Developer Know Right Now? https://www.reddit.com/r/javascript/comments/6mlc9d/what_10_things_should_a_serious_javascript/
Fair enough :)
You should write up a 2 minute medium post about replacing forEach with reduce. I would totally read that 
The value being populated is a fully qualified URL. Do you think there would be any issues by creating the element after the page is loaded? Or maybe the URL should be encoded a different way?
That was really frustrating I hope people don't write code like that, BTW half of the questions don't make sense if some sane mind would have thought of writing `"use strict"` at the top (or using ES6) Add to that that the "correct answer" to question 4 is wrong...
I would argue that the motivation for `filter` is better described as: "*when you want to strike out 0 or more things from the array*", and I would describe `reduce` as, "*When you want to build something new based on iterating through the array from left to right*", as opposed to `reduceRight()`. I would also mention that `map`, `reduce`, `filter` are methods which don't modify the array it's attached to, so `forEach` might be better reserved for side effects.
That's just not true. I work at Airbnb and a good portion of the company uses Atom.
I'm not sure what else might be wrong without seeing the actual data.
Like I said, editor love is subjective, but Atom is objectively inferior to vscode on every level (especially performance). For a project with at least 1000+ source files (outside of node_modules and derived artifacts), Atom is a no go, whereas sublime and vsc fly through things... However, people are free to use whatever they want to based on whatever pleases them. --- Edit: Just tried the new C++ based shawarma: - 168 MB Installer for a frikin' text editor (lol, does it do ray tracing and rendering?) - 7 seconds cold-start time on an SSD (with a default install and no additional packages) - ~15 seconds startup time with a complex initial workspace (~20 open files on startup, extremely large project) - Freezes and UI janks are still rampant - All this without a single additional package / theme installed. No thanks. I value a buttery smooth, lightning fast experience over all else. I'm going to try and put this piece of junk on my ramdisk and see if it helps: Maybe that will get it to open in less than 1 second like Sublime, or in 2-3 seconds like vsc. But that wouldn't help with the UI sluggishness and jank, would it? 
I just wish you could add your own postfix completions.
var declarations are hoisted to the top of the scope so none of the references in #4 are to window.variable1
I think it would be more fun (and more valuable) if the answers were shown after each selection, along with an explanation of the behavior of each. This way, we can learn from our mistakes and improve. As is, we really don't gain anything other than a "hey, JavaScript is weird and you suck at it!" (which is not fun!).
While editor love is subjective, your points are anecdotal, as I don't encounter those issues, at all, or very rarely. Maybe build a better computer. /s
agreed, I would love that as well. I wanted to add a postfix completion for log messages before so I could do `variable.log``&lt;tab&gt;` and it'd convert to `Debug.Log(variable);` but couldn't.
Agreed, you can even build your own map and filter functions based on reduce. Edit: just saw that someone else pointed that out already.
I've tried working with ctags. It didn't work for me. Know any good post on how to set things up? 
Look at the Polymer starter kit, it has alot of the best ideas
'this', closures, .map(), .reduce(), .filter()
I meant more technical things like lexical scope, closures, etc.
RemindMe! 16h after work
I will be messaging you on [**2017-08-10 13:16:42 UTC**](http://www.wolframalpha.com/input/?i=2017-08-10 13:16:42 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/6slsm6/which_array_function_when/dlebxvu) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/6slsm6/which_array_function_when/dlebxvu]%0A%0ARemindMe! 16h after work) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dlebyjl) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Does this mean being bad is good? Or is something off?: // Bad . ├── controllers | ├── product.js | └── user.js ├── models | ├── product.js | └── user.js // Good . ├── controllers | ├── product.js | └── user.js ├── models | ├── product.js | └── user.js
For reference it was the index I was after, though I think I have some places I can use the other ones as well. And it worked perfectly thank you! I definitely was not aware how useful these kinds of string methods were, I've used splice and stuff but pretty much always used loops if I was looking for something in the array
Wow... screw this.
hah. nobody on your team likes you and you probably have zero real friends.
Do you have a URL for the dashboard you're talking about?
I'll answer with a question: Is HTML composable? Therefore, what you answer to that question is the same answer for Marko.
make `ternjs` great again Kappa
Understanding the difference between function(){} and ()=&gt;{} var, let, and const So essentially how Javascript handle scope.
Trick question. If you want to _master_ the language: all the fundamentals!
super useful for an empty bucket like myself! 
HTML is strings, so the answer is no. Therefore the comparison to JSX is useless. For every second saved hours will be lost due to insufficient data type.
Most people would be using free software I'd think. If you're in a work environment, where your company can pay, I don't see why anyone would use Atom/VSCode over a solid IDE like Webstorm/IntelliJ.
https://medium.com/javascript-scene/top-javascript-frameworks-topics-to-learn-in-2017-700a397b711?source=linkShare-2c586ce429fb-1502321558
ES6 has no future. We're at ES2017 right now.
Watch the video. That's what he says.
&gt; Watch the video. Why would I? The dumb title isn't intriguing in the slightest.
Could you possible post an example?
To prevent dumb comments :')
Visual studio for Mac is now a thing too (Though really it is mostly Xamarin)
Which have the same dumb content as the dumb video? Uh hu.
I realize this is meant for beginners, but the originalArray.forEach(doSomething); form is noteworthy as well, imo. 
Biggest thing for me was being able to map 'j k' to esc insert mode. Used to not work in atom, but just tried it today and it does now so...
Marko is composable via components that can wrap other components. There's different strategies for creating higher-order components in Marko and we need to create an article that goes into more detail on that topic. Marko is very similar to React (and React alternatives) when it comes to composability, but there are some minor differences.
A few people have asked for an example. I'll give it a shot. Say you have an array of items you'd like to index by their name by their id. var items = [ { id : 1, name : 'foo' }, { id : 2, name : 'bar' } ]; You can do this with `forEach`: var map = {}; items.forEach(function (item) { map[item.id] = item; }); return map; or using `reduce`: return items.reduce(function (map, item) { map[item.id] = item; return map; }, {}); 
I agree with everything you said here including this being an intro. It's probably reasonable to cover the intricacies of reduce in a separate post. 
https://bondifrench.github.io/ml-in-js/ An overview of the current landscape regarding libraries to enable Machine Learning in Javascript. Was presented during the recent CampJs, presentation made for a non-expert audience willing to go beyond web-development and expand into Machine Learning
Here's something I wrote (not original commentor) about the interrelation between map, filter, reduce and recursion: http://www.chrisstead.com/archives/841/all-in-the-family-filter-map-reduce-recur/ Maybe this will help in seeing some of the deeper aspects of what reduce can do. 
^ This. _Reduce_ is often misunderstood, probably because of the name, and because the example is _always_ sum. But _reduce_ is the most versatile and powerful (and least concise) of all the array functions. For example, you can easily use reduce to implement both _map_ and _filter_. If you have a problem where you need to iterate over an array and save the results of that iteration _in any form_, you can use reduce to solve it.
Nice! Of all the features that component design brings, composition is the main reason to be excited. Looking forward to the article!
A for loop allows you to repeat the execution of a chunk of code (i.e. function) while accessing variables of the containing scope (i.e. state). Typically the reason for the repetition is because you have some set of values or things that you want to repeat this code on (i.e. a collection). Reduce allows you to repeat the execution of a function (i.e. chunk of code) for each item in a collection (i.e. set of values) and pass state (i.e. variables) from one iteration to the next. Map = reduce where the function takes in a collection as state, transforms the current value to something else, adds that to the collection, and returns the collection. Filter = reduce where the function takes in a collection as state, adds the current value to the collection if it meets some criteria, and returns the collection. Max = reduce where the function takes in the current max and returns the larger of the current value and the current max. 
I'm a little too lazy to do that, so here's some code right here: Imagine a nested Mongo object with children, where each layer has an `_id`. So, for example, you could have a (simplified) object like this: { _id: 1, children: [ { _id: 2, children: [ { _id: 3 } ] }, { _id: 4, children: [ { _id: 5 } ] } ] } Now, let's say you get a `path` that might look like `[1, 4, 5]` and you want to turn it into (in this case) `'children.1.children.0'` as that would be the relevant Mongo key for that object. A good, naiive solution (possibly better than the reduce for this simplified example) would be the following (I'm ignoring defensive programming and safety as well): let key = ''; let currentObj = { children: [object] }; path.forEach(id =&gt; { const index = currentObj.children.findIndex(({ _id }) =&gt; _id === id); currentObj = currentObj.children[index]; key += `children.${index}`; }); // and now we have `key` set appropriately, as well as a possibly useless `currentObj` object ------ A way to do it using reduce would be as follows: const { key } = path.reduce(({ // I prefer to state my defaults in the destructuring at the top rather than // as the second element of the reduce, but that's a bit of an idiosyncrasy. currentObj = { children: [object] }, key = '', } = {}, id) =&gt; { const index = currentObj.children.findIndex(({ _id }) =&gt; _id === id); return { currentObj: currentObj.children[index], key: `${key}.chlidren.${index}`, }; }); ------ So you can see, the benefits of using the reduce this way are actually pretty minimal, but it is technically more "pure"^1 and less "imperative" because we never mutate a variable and we don't leak any variables we don't need. This (in my opinion) comes at the expense of harder-to-read code, so I tend to prefer the first approach over the second, but this kind of thinking expands the mind a bit I think. Many languages do not offer things like changing variables, so that's why you need to do this approach or something like it. This is very similar to the way you would "iterate" using a recursive function in Scheme (or at least how I learned to do it in SICP). There's a reason I prefer JavaScript. ------ Hope that was at least coherent. =) ^1 I actually think "pure" is the wrong word here as neither have any side-effects. Perhaps "declarative" would be a better word?
I appreciate it, but this is actually not what I'm referring to. See my other comment for what I meant.
https://www.reddit.com/r/javascript/comments/6slsm6/which_array_function_when/dleqgwo/
&gt; probably familiar with ES6, which is the most recent version of javascript. I mean, sure, ES2017 is supported in Node v8.. I guess what's he's getting on about is that there aren't versions of the language anymore. Except there are, and will be because it's not a compile-to-executable language.
When you want to return the first item in an array that meets the criteria, you can an use [find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find). The support isn't great, though.
Hi /u/melushcca Here's an updated [Pen](https://codepen.io/anon/pen/XaRQWZ) I did a couple things here: 1) added this CSS to make the slideshow images full width: .mySlides img{ width:100%; height: auto; } 2) Changed function calls that looked this this: showSlides(slideIndex = n); To this slideIndex = n; showSlides(); As your function does not take any arguments function showSlides() { I also lowered the timeout because i'm impatient - anywho, hope this helps you out :) **Edit** Forgot to mention, the reason your slideshow seems to be going "Haywire" is because you're recursively calling the showSlides function - This is basically a function calling itself over and over again - so each time you click the Prev-Next buttons, you're initiating a whole new instance of this recursive loop function showSlides() { var i; var slides = document.getElementsByClassName("mySlides"); for (i = 0; i &lt; slides.length; i++) { slides[i].style.display = "none"; } slideIndex++; if (slideIndex&gt; slides.length) {slideIndex = 1} slides[slideIndex-1].style.display = "block"; // Calling showSlides from within showSlides - creating a new infinite loop every time you click prev and next setTimeout(showSlides, 3000); // Change image every 6 seconds } You might want to add something to manage the state. for example: **Not Tested** but should work // define a variable to manage state let prevNextNotClicked = true; //in your prev and next functions prevNextNotClicked = false; function showSlides() { var i; var slides = document.getElementsByClassName("mySlides"); for (i = 0; i &lt; slides.length; i++) { slides[i].style.display = "none"; } slideIndex++; if (slideIndex&gt; slides.length) {slideIndex = 1} slides[slideIndex-1].style.display = "block"; // add a condition so if our state changes, we no longer need to loop if(prevNextNotClicked === true){ setTimeout(showSlides, 3000); // Change image every 6 seconds } } 
Yeah, you totally can! Reduce is probably my favorite higher order function. Super versatile. You can do cool stuff with objects and reduce using `Object.keys`, like: const cow = { name: 'jerry', sound: 'moo' }; const loudCow = Object.keys(cow).reduce((r, key) =&gt; { r[key] = cow[key].toUpperCase(); return r; }, {}); console.log(loudCow); // { // name: "JERRY", // sound: "MOO" // } I'm pretty adamant about showing people reduce in contexts other than summing arrays, cause learning it that way made me think it was mostly about adding for a while, which is a pretty narrow focus. EDIT: For fun, I wrote a few basic higher order functions using reduce, and then wrote a simple reduce function. The native implementations pass a couple more arguments to the HoFs, but I decided to keep it simple. // The array we'll use in the examples const stuff = [1, 2, 3, 4, 5]; /** * map */ function map(arr, func) { return arr.reduce((r, val) =&gt; { r.push(func(val)); return r; }, []); } // Double every item in the array const mapExample = map(stuff, (thing) =&gt; thing * 2); // [2, 4, 6, 8, 10] /** * filter */ function filter(arr, func) { return arr.reduce((r, val) =&gt; { if (func(val)) { r.push(val); } return r; }, []); } // Get even values in the array const filterExample = filter(stuff, (thing) =&gt; thing % 2 === 0); // [2, 4] /** * forEach */ function forEach(arr, func) { arr.reduce((r, val) =&gt; { func(val); }); } // console.log the items in the array - nothing is returned forEach(stuff, (thing) =&gt; { console.log(thing) }); /** * reduce * For fun, let's implement a basic version ourselves */ function reduce(arr, func, initialValue) { const tempArr = initialValue ? arr.slice(0) : arr.slice(1); const startIndex = initialValue ? 0 : 1; let accumulator = initialValue ? initialValue : arr[0]; for (let i = startIndex; i &lt; tempArr.length; i++) { accumulator = func(accumulator, tempArr[i]); } return accumulator; } // Turn our array into string that says, "I love the numbers " plus each item in the array const reduceExample = reduce(stuff, (r, val) =&gt; { return r + val + ' '; }, 'I love the numbers '); // "I love the numbers 1 2 3 4 5 "
😂
Bruh that black background is super harsh, I recommend using a [dark blue instead](https://i.gyazo.com/679b3b47817048d64fd66be7eaa61560.png)
Ehh, I have a thing for pitch black backgrounds, I just like it much better that way. :D
[A re-introduction to JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript) on MDN.
Asynchronous programming with promises and error catching, the event loop, limitations of frontend vs backend js. Understanding how react and redux work is nice too.
Isn't the point of OOP to keep internal state inside objects? I thought functional programming was against stateful objects.
Ah, yea I've remapped caps to esc so it's easy to use
Read all of the [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) books until you fully understand them. They're free online. 
vuejs beats both
my man! have an upvote
I actually think you're missing the point. Composition is a theory, not a specific implementation. The _browser_ actually interprets those "strings" as DOM elements, which is what we're building for, right? The browser. Not for the developer. Therefore, composition is how you can embed one element inside another and use that composition to describe views and attach events. So ... yes, like how HTML works. You can have Marko components that can include child Marko components. And additionally to handle events that bubble. Let me know how I can help to somehow convince you to try Marko. 😉
you too!
Yeah, I guess I always think positively. ¯\\\_(ツ)\_/¯
I see @psteeleidem answered, so I'm sorry I didn't see it before I posted.
How is it diffrent than setting a prototype?
Prototype is used for inheritance. Object.assign is for composition. 
Ok, I have not seen being used anywhere. A practice example would be nice. 
Possible that I'm missing something, but isn't try/finally in generators the best answer here? That allows you to define cleanup actions that will always run, even if the iterator is returned early. See the example at https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate — this example is using async iterators, but try/finally works just the same with sync iterators.
I got that they record events. But If you will check the video on youtube, BESIDES recording events, you can see the screen of the user, like when he click somewhere it pops out a menu, etc. 
You would need some kind of REST API as a server, but many databases have solutions that work out of the box if you don't feel like building your own. Eg postgesql has postgrest, which I really love
Object.assign is more like inheritance than not, and it isn't composition at all. Inheritance: const a = { aMethod() {} }; const b = Object.create(a); // b IS-A a // That is, b fulfills a's interface and borrows a's implementation b.aMethod(); Also inheritance: const a = { aMethod() {} }; const b = Object.assign({}, a); // b IS-A a // That is, b fulfills a's interface and borrows a's implementation b.aMethod(); Composition: const a = { aMethod() {} }; const b = { a: a }; // b HAS-A a b.a.aMethod(); 
Article was published before stable release 1.19, interesting to see if there are any changes.
Thanks for the help! Do these need their own server system setup? Or can I load it to my machine and get a URL for the data from it?
This is what I had in my mind!!! Totally agree!
Great. this is a great example. I got the concept but becase i am a newbie. I dont understand completely yet. especially the 'const' itsnt it supposed be used for defining constants?
There are a lot of ways you could do this. [MySQL Rest API](https://www.infoq.com/news/2014/09/MySQL-REST ) would allow you to send SQL in the URL... which would be really, REALLY bad if public facing but OK on your small(?) LAN. 
Any advice on using File API?
Even though there are optimizations on the way for `forEach` nothing beats a simple `for` loop's speed :) The main reason why I used `forEach` was for its scoping ability, but now with `let` it's again faster to use a simple `for`. 
Thank you, amazing answer and totally correct 
Thanks, that was my guess too, because I don't find other explanations of how they could do it. What is interesting they do this "reproduction capture" on pages that require login also. But yeah if they send the modified HTML &amp; CSS to their environment every time a change in DOM occurs they can reproduce it for "closed access" pages as well. I really think this is a genius idea!!! 
Good enough advice. I use nodenv instead of nvm, its more modern
An object properties can be still be reassigned/assigned. 
I like to use reduce on an array of promise when I want to run them sequentially instead of Promise.all
File API ( Javascript ) has no write ( because security :O ) - only read. I've mainly only used it for file / image / doc drag / drop. If you want to do file writes ( save files ) server side you'll need do do it via the back end. 
Is it possible to generate data that a user can download? Like could I use File API to load a file and another library to let a user download the data if they click on a "download" button? Or is that a no-go since I'd need to write the data to host directory first?
Maybe I'd agree. But when you combine react with clojurescript, I think there's no contest. 
What is happening and What do you think should be happening?
What does that mean?
Nice for beginners. But instead of "Return one new thing" for reduce, I'd say use reduce to "Return another data-structure, or an array which elements don't map the initial array".
you have to parse the user inputs : let Score1 = prompt(); // &lt;--- that will be a string let Score2 = prompt(); // &lt;-- idem let wrongAverage = (Score1 + Score2)/2; // not good let goodAverage = (parseFloat(Score1) + parseFloat(Score2)) / 2;
Hi Everyone, Thanks for taking the test, I'm glad it has piqued your interest and I hope you found it as fun to take as I found it writing it. The answer to question 4 is in fact undefined. @LukaLightBringer correctly points out that this question is designed to show the results of hoisting. Unfortunately chrome's developer console has undergone some changes in the last few months which mean that it no longer hoists variable declarations like it should. You can see the results of hoisting in question 4 if you run the script in the page rather than the console like in [this fiddle](https://jsfiddle.net/n4x1fu1z/). Here you will see undefined correctly being reported in the console. Of course, we don't expect anyone to actually write javascript like the questions in the test. In fact we hope you don't! The test is designed to highlight some of the oddities of javascript and things that may catch you out.
That only happens if they're explicitly closed, it's easy to leave an iterator unclosed if you don't fully consume it: function* foo() { try { yield 1 } finally { console.log("Cleanup action!") } } const g = foo() g.next() // If I don't call g.return()/g.throw()/g.next() after // the first call // then "Cleanup action!" will *never* be printed even // if the generator gets garbage collected Fortunately `for-of` handles this for you if you break the loop by calling `g.return()` on the generator to force the finally block to execute.
Taking a look at the value that you got for `total` should be enlightening.
Wow another "comparison" between Angular and React. Or is it Angularjs and React? Well he compares the github stars, as if that's a good measurement anyway, of angularjs vs react but then apparently he's actually going to be using angular for this article. Ok well hmmmmm... So in React he creates a component that takes in a name and then just displays it inside an h1 element. Then that component is used 3 times inside the root component to create 3 instances. Then in angular he creates only the root component and then uses a backing array to spit out 3 h1 elements with an ngFor inside the root. Why didn't he create a 2nd component in angular that takes in a string and puts it inside an h1 element? Then he could have just used the component 3 times inside the root component. In fact the html would have looked identical. Or instead of that he could have used a loop inside jsx to show an h1 per element inside an array and done the react component in the same style as angular. But for some reason he used 2 completely different methods. Why? This makes no sense. Performance. I still haven't seen good numbers on this supposed better performance that react has, nor have I experienced any performance issues with angular. So we have specious claims about performance with no numbers to back them up. Nor does he even mention some of the features you can use in angular to increase performance. Note that I'm not claiming that angular has better performance than react. Or vice versa. My point is I haven't seen any good comparisons that show this supposed better performance in react and this article doesn't present any evidence of this claim at all. For debugging angular does parse templates and give errors at compile time if you compile it for AoT. AoT compilation is the standard for the build command of the angular cli now, and it's enabled with -aot for the ng serve command. Serve is used while developing where it provides hot module reloading and that kind of stuff. As an extra thought I don't think that really has anything to do with debugging. Debugging would be the experience of actually debugging the code while running. And in that regard chrome has no issues using the typescript files as maps. You can inspect values and set breakpoints in the ts without ever looking at the js if you don't want to. Of course you can also still use the js to debug if you desire. The section on DI contains no useful information. Hurray, another article that fails to provide useful comparisons. edit: oh and I forgot to mention that his point: &gt;The HTML template is separately attached in a different file. This is a key difference in Angular, as an additional HTML file is needed for each component created, this leads to overhead. No actually, angular allows you to *either* use a separate file *or* inline the template. That's why the @Component decorator has both a template and a templateUrl field. The general guidelines say that if a template is small you can inline it into the component file under the template field but if the template grows to a bigger size your better off using templateUrl and splitting the template out to a separate file. I personally think they are good guidelines, but they are just that; guidelines. You *can* put all your templates inside the file in Angular. My point is this article reads like someone who only has extremely limited experience with Angular. If you're going to write an article comparing frameworks I feel like you should be more than passingly familiar with them.
Sigh. You live and learn I guess.. I now know about unary operators :)
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/keithwhor [Build a "Serverless" Stripe Store in 5 Minutes with Node.js and StdLib](http://np.reddit.com/r/node/comments/6ss7g3/build_a_serverless_stripe_store_in_5_minutes_with/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
thanks for valuable feedback. I would also like to add that the GitHub comparison has a single repository for both angular js and angular 2 , apart from that I will make edits to the template section and I'll see what I can do on the angular front overall.thank you
This should be a sample of my code. Again, my code works, but I need to repeat myFunction every time the button is clicked. At the moment, I can only click the button and run through the code once. In other words, how can I click this button more than once and trigger my myFunction each time said button is clicked? Thank you for the help. https://gist.github.com/EpicKingdom/30ed9f504be1ad0ded15a93c267b2f77
Why not Vue so that you can have the best of both worlds?
remove （）in HTML onclick="functionname"
This isn't an issue with unary operators. If I run this and enter scores of say, `20`, `90`, `65`, then `total` comes out looking like `"209065"`. The issue is that `prompt` always returns a string, so you're simply concatenating the strings instead of summing them. The solution is to first convert the values from String to Number. How you go about that is left as an exercise.
Not sure if FP talks anything about stateful objects but Redux "store" is one big stateful object too ;) What I'm doing is replacing one big "store" with many small models in tree. Every model is independent but notifies tree root (so it's possible to subscribe via root to changes in deep children)
You make the random selection outside of the function called by the button click. The function is called each click (add a console.log to see for yourself) but you insert the same thing each time.
well vue has really good features and is similar to react (both libraries) but it needs better community support. A company would prefer using Angular or React which have good support and in case they run into bugs will find it easier to troubleshoot, this again leads to better jobs in case of learning React and angular.
&gt; That only happens if they're explicitly closed It also happens if the generator completes naturally. But sure, if you leave an iterator open it'll never clean up, but that's the same for the manually-defined iterators in the article.
Vue inherits lots of the same issues and troubles that Angular's always suffered from. It uses an outdated technology stack (scope-unaware type-unsafe templating, html mark-up extensions for javascript-like code emulating conditions and loops, pre-flux mvc) and thereby either skips modern concepts completely or only slightly brushes them. If you have worked with Angular before, Vue is very similar to how you made applications in the 2010 era, although in a more polished way. React/Fiber on the other hand is already contemplating a future in which javascript apps run everywhere with native performance, in a way that's elegant and simple. I don't think there's a case here where many people would want to regress from that. There's also the not so little issue of an eco system and wide spread use. The hype around it didn't translate to actual numbers unfortunately: http://npmcharts.com/compare/react,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer http://www.npmtrends.com/vue-vs-react-vs-@angular/core-vs-ember-cli-vs-@polymer/polymer
Haha duh!! Thank you. :) I put the random selection within the function.
You need this in each HTML file &lt;script src="http://webaddressofyourjsfile.js"&gt; &lt;/script&gt; &lt;script&gt; // any functions specific to a page go here &lt;/script&gt; This will link all your pages to an external library from which you can call functions. You need a separate script tag for any functions specific to a page. 
Yes, I have that in my HTML, but how can I include other js files in a js file? Similar to @import in css.
Tried this? http://requirejs.org/docs/start.html
Full disclosure: I’m the author.
Ah, maybe this: https://stackoverflow.com/questions/4634644/how-to-include-js-file-in-another-js-file
I'm assuming you goal is this: All HTML page have a single &lt;script src="master.js"&gt;&lt;/script&gt; tag. master.js would include other js scripts, and master.js would allow you to add/remove scripts as desired. Seems like modules using [RequireJS](http://requirejs.org/docs/start.html) would be good for that. Alternately, do it manually with something simple like: ` var script=document.createElement("script");` ` script.src="newstuff.js";` ` document.body.appendChild(script);` 
That word serverless is annoying me to no end.
That's what I assumed the + added before each string did..? The article I found called them unary operators hence my answer. Cheers :)
This post has a classic beginner's error of using reduce: const originalArray = ["Alice", "Bob", "Charlie", "Bob", "Bob", "Charlie"]; const numberOfBobs = originalArray.reduce((accumulator, item) =&gt; { if (item === "Bob") { return accumulator + 1; } else { return accumulator; } }, 0); Is actually: const originalArray = ["Alice", "Bob", "Charlie", "Bob", "Bob", "Charlie"]; const numberOfBobs = originalArray.filter(name =&gt; name === "Bob").length This is much shorter, easier to understand and has a better separation of concerns. The provided reducer function does two things that are already there in standard Array API: * picking some items based on some condition (.filter) * counting a number of items (.length) Rewriting .filter in reducer is a common error I've seen a number of times even in experienced developers code (they didn't have the FP experience though). The bad code smells to avoid this kind of error in reducers are: * you have some kind of logic which skips some of the items of the original array * you return an array from reduce The problem with oversimplified articles is they don't give you any understanding of what's actually going on which leads to these kind of errors. If you grok what higher-order functions are and can write .reduce (not reducer) as a recursive function and write .filter as a reducer for .reduce then you won't be making this kind of errors.
Right now I'm using "document.writeln". Seems to work, but I'm not sure how good of a practice it is to do it like so. And I also don't want any warnings on my sites. As of now I'm trying to import 4 other scripts into my master.js I get this warning in Chrome &gt; A Parser-blocking, cross site (i.e. different eTLD+1) script, https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js, is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message.See https://www.chromestatus.com/feature/5718547946799104 for more details.
Just host [jquery](https://jquery.com/download/) locally?
This example doesn't show any reduce benefits. It is actually better to use simple for here - less code, easier to read and faster to execute.
This was one of the four scripts. As all the other scripts are hosted "locally" with the master.js script. They won't load on any sites unless they are linked to the master website. But if there is no other method I would prefer, I think I just will have to stick with it. Seems it only will affect devices on a 2G connection, but that probably isn't too many people. Thanks anyway :)
This looks 90% like Vue. Why would someone use this instead of Vue which is much more mature at this point. 
Full disclosure, you're freaking brilliant. I visit your website and books quite often, especially when I want to get ahead and improve my code. Or when I want to read on JavaScript and realize I know nothing. Thanks for all that you do. For those that don't know Dr. Axel check out his free ebook publications at http://exploringjs.com . You won't be disappointed. 
Thanks! 😀
That's nice, but isn't that where you should use async/await ? For reference, I commented about this case a few months back in this /r. https://www.reddit.com/r/javascript/comments/677tcu/understanding_asyncawait_in_7_seconds/dgok7bk/
If you can, yes. Sometimes you have to work directly with Promises and then it’s useful.
To be clear you _shouldn't_ use reduce to implement map or filter except as a thought experiment. It would be less concise and readable. You should always use the most specific array function that suits your use case. That said, if none of the others work, _reduce_ almost certainly will.
You're definitely right about that.
I would also add, learning to reason about reduce is a useful mental exercise. So if it confuses you, I would tackle a few toy problems and force yourself to use it, even if there are more appropriate tools available.
If you have Windows 10 it comes with bash https://www.google.com/amp/s/www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/amp/ Otherwise look into installing a bash shell for windows or a cURL equivalent for powershell 
Thanks! After I install bash I just copy the URL normally from the 'Network' tab and input it in bash with the emoji as pictured in the article or do I need to add anything in the front or back, as it's not Mac. Or does it behave the same? I'm currently still at work for another two hours but I'll test it out as soon as I am home.
Assuming it's a real bash environment you shouldn't need to add anything, cURL just makes an http request just like a browser does 
The big change: V8 6.0 The V8 engine has been upgraded to version 6.0, which has a significantly changed performance profile. #14574 More detailed information on performance differences can be found at https://medium.com/the-node-js-collection/get-ready-a-new-v8-is-coming-node-js-performance-is-changing-46a63d6da4de
Perfect, I will test it out.
Wow, just tested on a simple script I have to check for solutions to [538's Pick a Number Any Number](https://fivethirtyeight.com/features/pick-a-number-any-number/) puzzle. - node **8.2.1** runs 1,000,000 iterations in 38s - node **8.3.0** runs 1,000,000 iterations in _16s_ I'll certainly take it!
`try... finally` absolutely works, but now the blog post opens up a can of worms getting into exceptions, something I had wanted to avoid. Either way, it doesn't change the central premise of the post, which is that there are hidden affordances provided by JavaScript's constructs so that it's easy to write code that mostly works, and sometimes you can accidentally write code that always works, but sometimes not. Here's a version of the post including a `try... finally`: https://github.com/raganwald/raganwald.github.com/commit/6d1d94421e36e2b487d2a26eacbe65a4aac6811b
It may amuse you to know that I began writing this two months ago with the intent to lightly discuss closing iterators and end up discussing the larger problem of "ownership" of resources and responsibilities like "who is responsible for closing this iterator?" But closing iterators turned out to be an entire blog post, so there you have it.
It reminds me of my old https://github.com/naoxink/notifIt. Good job :)
Even though I kinda agree with some of the points of the author, I have the feeling that comparing the kind of features that Code or other IDEs like Webstorm provide to Vim is a bit pointless. On one hand you have a system that is packed with features that the average developer needs or will almost certainly use, on the other hands you have a system that you can extend without limits and that has an extremely high barrier of entry.
I think you are (probably) wrong, and hoisting works nicely in chrome. Question 4 is a weird question. Even if hoisted, var variable1; //window.variable1 is declared here variable1 = 'A'; variable1 = 'C'; variable1 = 'B'; console.log(window.variable1); // output is 'B' On the other hand, if we had a closure, we would get: (function(){ variable1 = 'A'; variable1 = 'C'; var variable1 = 'B'; console.log(window.variable1); //output is 'undefined' })()
It's fixed now. It was a mistake. 
Also how to debug using console, debugger &amp; breakpoints, and getting used to doing the same without a browser (node)
If you wanna know more JavaScript libraries, please, take a look at this article https://www.cleveroad.com/blog/discover-top-javascript-libraries-to-keep-an-eye-on-in-2017 There's list of most popular and new JS libraries for web development
I was asking this more as an opinion question. They just added the help flair. Kyle Simpson's books and workshops are what I tend to recommend to people who really want to take deep dive into JS.
&gt; Here's an example: in Bluebird, cancelation doesn't propagate upstream. After registering onCancel in a promise constructor, you have to call .cancel() on that exact promise object. Calling .cancel() in any child promise created with .then() or .catch() will not abort the work, rendering the feature useless for the most common use case! This just isn't true. Bluebird counts children, and propagates the cancellation upstream if all of the children are cancelled: Promise.config({cancellation: true}); const parentPromise = new Promise((resolve, reject, onCancel) =&gt; { onCancel(() =&gt; console.log("Oh no, I've been cancelled")) }); const child1 = parentPromise.then(() =&gt; {}) const grandchild = child1.catch(() =&gt; {}); const child2 = parentPromise.then(() =&gt; {}); grandchild.cancel(); //Cancels grandchild and child1, but doesn't cancel parentPromise //No output child2.cancel(); //Cancels child2 //Output: "Oh no, I've been cancelled", since all of parentPromise's children have been cancelled (You can copy and paste the above code into the dev console on the [Bluebird website](http://bluebirdjs.com/) if you don't want to take my word for it). --- And even if the claim that Bluebird didn't handle cancelation correctly were true, I still don't buy that you can't add cancellation to a Promise implementation and somehow need to invent your own "promiseish" thing to do it. You could also just use an RxJS Observable which, (I'm told) also supports cancellation. 
`Score_1 + Score_2 + Score_3` vs `(+Score_1) + (+Score_2) + (+Score_3)`.
If you're recording all events that includes the keydown events in login forms. I imagine it would work for on page login forms however if for example you used a social login like Google or Facebook where the actual login process takes place on a different domain where events cannot be captured it would probably break. It may actually pose a real security risk to users.
Tiny? It requires damn jQuery...
You are correct. jsfiddle is actually adding a closure on your behalf by default which explains the different behaviour. We will have to update the answer to Question 4 :)
React ecosystem: build your own frankenstein framework
why not just `Math.round()` or `.toFixed()`
TOP KEK
It's probably not what you're looking for, but I am doing a project with Google Visualization, Google Apps Script and MySQL Server. Data is queried on the server side (i.e. as a Google Web App) and returned to the client in JSON, whereupon the Visualization API can plot in dozens of formats. If you can open your db to Google IPs + SSL, there is a JDBC API to make things a bit easier. 
http://memecrunch.com/meme/DWNO/scope-creep/image.jpg
You don't :) ..javascript works a bit differently and there is no need for inversion of control. Although Angular has it, usually trying to implement an ioc leads to a lot of issues (know by experience :))
A slight variant on the multiple return values solution is to reuse intermediate promises: const connectionPromise = db.open(); const resultPromise = connectionPromise.then(connection =&gt; connection.select({ name: 'Jane' })); Promise.all([connectionPromise, resultPromise]).then([connection, result] =&gt; { //Do something with the result and the connection }); It's got the same limitation about passing data into the catch or the finally block, but an advantage over multiple return values is that promises don't need to be concerned about what the next promise needs: you don't have promises passing through values just for the sake of their "children". Like, suppose you need to do some async operation on the result you get back for the DB. With multiple return values you'd write: db.open() .then(connection =&gt; { const resultPromise = connection.select({ name: 'Jane' }); return Promise.all[resultPromise(), connection]; }) .then(([result, connection]) =&gt; { //Doesn't use connection, but needs to carry it through const result2Promise = doSomethingWith(result); return Promise.all([result2Promise, connection]); }); .then(([result2, connection]) =&gt; { //doSomething with connection and result2 }); With intermediate promises you'd write: const connectionPromise = db.open(); const resultPromise = connectionPromise.then(connection =&gt; connection.select({ name: 'Jane' })); //Doesn't need to know about the connection const result2Promise = resultPromise.then(result =&gt; doSomethingWith(result)); Promise.all([connectionPromise, result2Promise] =&gt; { //doSomething with connection and result2 }); Each promise only depends on exactly what it needs, and only returns whatever it calculates.
That's not a callback correct, it's just a normal use of functions. There is no special name for it.
You might not know how many significant digits you need to display. This gives you a number, Math.round gives you an integer, toFixed gives you a string.
any new es6/7 features?
Object rest/spread is implemented and shipping (i.e. available by default).
Use factory functions 
To understand these accesses look for the term closure
 const roundP = function roundP(number, precision) { const factor = 10 ** precision; return (Math.round(number * factor)) / factor; }; console.log(roundP(1234.5678, 2)); console.log(roundP(1234.5678, -1)); Here's the jsPerf demonstrating how much faster my (mdn's) way of doing it is: https://jsperf.com/floating-point-number-rounding/1
I just sent you a PM
Your singular experience is more anecdotal (read: full of c) than what I stated (which is also the reason many users moved away from Atom back to Sublime, or moved on to VSC). Proof? The numerous performance complaints on their issue tracker itself, while no such complaints exist for VSC or Sublime. The anecdote card was a weak one tho....
doing it with ** could certainly help. This is for the times when you're doing the math but you don't know the intended precision.
You might want to checkout [inversifyJS](https://github.com/inversify/InversifyJS) -- check the end of the readme for an example with `js`. If you're using webpack on the client side you can alias your paths [like this](https://webpack.js.org/configuration/resolve/). Also, [Node.js Design Patterns second edition](https://www.packtpub.com/web-development/nodejs-design-patterns-second-edition) has a section on `DI`.
`(0.2 + 0.1).toLocaleString()` is usually sufficient I find.
That's perfect if you need a formatted string instead of a number. Try (3500).toLocaleString() 
When would you not need that? toFixed / your library converts the number to a string, too. You only ever need to get rid of the 0s or 9s when outputting the number to the user. Also, if the thousands seperator are really a problem, One can use `1500..toLocaleString(undefined, {useGrouping: false});` Edit: Never mind, I didn't see that you convert back to a number.
While I have no comment on the cancellation aspect, I want to respond to this quote of yours: &gt; I still don't buy that you can't add cancellation to a Promise implementation and somehow need to invent your own "promiseish" thing to do it. This is not a "promiseish" thing he invented. This is the Future/Task monad, which is standard in functional languages like Haskell. In fact, a Promise is actually a "futureish" thing, since the concept of a "Future" has been around since the late 80s and Promises are basically inspired by them. The downside of a promise over a future is that of lack of referential transparency and purity. Futures are lazy, Promises are not. Promises execute immediately, which makes them impure because immediate execution, at least in the FP world, is considered a side effect. Futures do not have this problem, which makes things like cancellation, retries, etc, far easier to reason about. 
[removed]
"Build your own framework that works better for your specific application"
What would be the best way to remove node v6 completely so that I can install v8.3?
&gt; One thing I'm starting to realize [...] is that even if a method accomplishes or extracts the data you're looking to extract, that doesn't mean it will return what you're looking to return. It seems you may be under the [false] impression that "functional" means that it has to be a one-liner, or that you must return from a single expression. Instead of: return bookList.splice(0, 1, bookName); Why not: bookList.splice(0, 1, bookName); return bookList; ? Thought it seems like the actual result they're looking for should probably be: function remove (arr, bookName) { return arr.filter(book =&gt; book !== bookName); }
You can use NVM (node version manager) to install any version you want and switch between them. You can use it to uninstall versions too. https://github.com/creationix/nvm
Looking at the code pen, the problem is with your transform origin. You're throwing that out on the right end of the hand which in turn causes size to have an effect on position. Instead, keep it left, then use `left` to position the hands. This will keep width independent of position. ~~transform-origin: 100%;~~ left: 50%; transform-origin: 0 50%; Then change the size of the hour hand by changing its width. .hour-hand { width: 30%; }
Thank you. I think this proves to me that a lot of the concepts that I went through in this course, I simply approached with the goal of "solving" the puzzle, I didn't actually spend enough time fully understanding the concepts. You are correct in your assertion that I'm confusing the definition of functional programming. I also think I distract myself by trying to simplify what I'm writing into a single expression. Thanks for looking at this.
 .hand.hour-hand { width: 30%; left: 20%; }
Thanks!! I'll check it out!
Sure, I'm aware of the Future monad, and this may be a more "pure" implementation of it than the actual standardized Promise API. (Haven't looked rigorously at the examples to see if it's actually lazy, or if this just behaves closer to Promises) Maybe there's value to a more functionally pure implementation of the future monad, (though personally, I think the fact that the Promise is the defacto standard, and interoperability with other libraries and syntax like `await/async` outweighs the benefit of functional purity, though that's just my two cents). But "more pure future monad" isn't listed as the reasoning for this library, it's listed as "Promises can't do cancellation", which just isn't correct.
You can also always do a "poor man's dependency injection" through constructor functions default values. (ES6 code shown) class Whatever { constructor(someDependency = new SomeDepenency()) { this.someDepenency = someDependency } } // in a test: it('does things', function() { const mockDependency = { // ... }; const whatever = new Whatever(mockDependency); // ... }); But typically I just `require()` or ES6 `import` modules and mock out those modules at test-time as needed: https://stackoverflow.com/questions/35240469/how-to-mock-the-imports-of-an-es6-module
FeathersJS is a pretty powerful or realtime applications. Abstracts a lot of the socket connection implementation.
Cancellation doesn't belong in a result type. If the result type can somehow affect the underlying operation, it isn't really a "result" at all, now is it? Both the web (https://developer.mozilla.org/en-US/docs/Web/API/FetchController) and Javascript language committee (https://github.com/tc39/proposal-cancellation) are taking a different approach to cancellation. In both cases, the idea is to pass a cancellation controller directly into the async operation itself, such as the `fetch(url)` call: const controller = new FetchController() return fetch(url, { signal: controller.signal }) To cancel the operation, call `controller.abort()`. This cleanly separates starting &amp; stopping the download (the input side) from the results of that operation (the output side).
Was listening to a podcast about this, the first implementation of turbofan in Node wasn't that optimized. So the performance probably was skewed.
That has been in since v6.
Hi /u/AnsikteBanana, 1. The site isn't loading for me, is it still loading for you? 2. Due to #1, I can't verify that the submission is appropriate for /r/javascript (the title doesn't appear to be directly related to JS); does it actually talk about JS specifically?
This looks great! I have npm modules folder at `~/.npm-global`. Will it mess things up if I ran `nvm install node` now?
That was for [arrays](http://node.green/#ES2015-syntax-rest-parameters). [They added it for objects in 8.3.0](http://node.green/#ESNEXT-candidate--stage-3--object-rest-spread-properties)
I think you're thinking of object destructuring, or maybe about array rest/spread, not object rest/spread. 
/u/kenman the link loads fine for me. Tyler and Kent are both well known in the JS community and mostly everything they talk about has direct application to JS projects 
Why has no demo link?
First off you would do something like `nvm install 8.3.0` since nvm only installs node. As far as global modules, when you do an npm install of a package globally, that package install is scoped to that version of Node. That means when you switch to a different version of Node with `nvm use x.x.x` you will have to make sure it is installed for that version as well. It may sound like a headache at first, but it is actually quite convenient for compatibility purposes.
My biggest minor irritation with JSX is having to escape Unicode characters grrr 
edit: ok, it comes up here at home, and it does look related. Thanks!
Functional programming is a programming paradigm. A style of building the structure and elements of computer programs. Its the opposite of object oriented programming. As you learn, you'll see that object oriented is king, but.. functional still has many purposes, and is making a "come back" of sorts.
You are incorrect. See myths. http://blog.wolksoftware.com/the-current-state-of-dependency-inversion-in-javascript
[removed]
Technically, the values, e.g., 1 and 1.5, are primitives of type `number` and are not types of `Number`. There is no integer type - numbers are always doubles. &gt; typeof 1 "number" &gt; typeof 1.5 "number" &gt; 1 instanceof Number false &gt; 1.5 instanceof Number false
I hope this includes the `String.prototype.split()` regression fix. But looking forward to TurboFan!
There are several controls available, you can try them out here: https://threejs.org/examples/#misc_controls_orbit Click "view source," it's pretty easy to use. Once you have a control it doesn't matter what's in your scene, you can now steer it. Images you can project over mesh surfaces as textures, again there are lots of examples: https://threejs.org/examples/#webgl_materials_texture_anisotropy
hey thanks, this helps point me in the right direction
Money. Thanks!!
RESOLVED
So, a virtualenv for node. Got it. I will spend some time on it. Thanks.
I did not know that. Performance is nice and all, but this is officially my favorite new feature. Now (for me) there's *really* no point in using babel for smaller/server-side scripts.
breakpoints in node? did I miss something?
I wish 
Wood love to see a recent comparison with deepstream.
Or use this https://stackoverflow.com/questions/202302/rounding-to-an-arbitrary-number-of-significant-digits
It takes a while to get used to. Its definitely confusing at first. Here, there's a bunch of new things going on. [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), it sounds like, you already get. One thing about them is that their body can optionally include wrapping braces (`{}`). However, if you're trying to return an object literal, which also use `{}`, there can be some ambiguity as to whether or not its meant to represent a function block. To ensure you mean return an object literal and not use this block to represent the arrow function body, the literal can be [wrapped in parens](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals). () =&gt; { something } // &lt;-- returning an object? Or a function body in {}? () =&gt; ({ something }) // &lt;-- ensures returning an object Object literals also have a new shorthand syntax that lets you [abbreviate key value pairs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Property_definitions) if the key is the same name as the variable used to represent its value. let name = 'joe' let normal = { name: name } let shorter = { name } //&lt;-- same as { name: name } With that, given `actions: () =&gt; ({ increment: (amount) =&gt; ({ amount }), decrement: (amount) =&gt; ({ amount }) }),`, what you get is loosely the same as the ES5 version of: function actions () { return { increment: function (amount) { return { amount: amount } }, decrement: function (amount) { return { amount: amount } } } } The next sample is similar, but includes one more additional feature: [computed property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names). Before, property names couldn't be expressions when in an object literal. Now they can, using the same array access syntax you'd use to define dynamic properties objects in the past, only available now in a literal definition. let older = {} obj[name + '-son'] = name // &lt;-- before let newer = { [name + '-son']: name } // &lt;-- now
Note that your solution for the add() function is still mutating state. Instead you could create an array of the one bookName you passed into the function, concatenate that array with the bookList, and return that. 
Most of that is ES6 syntax, and is not specific to React, Redux, or Kea. First, let's format the items in question properly: @kea({ actions: () =&gt; ({ increment: (amount) =&gt; ({ amount }), decrement: (amount) =&gt; ({ amount }) }), reducers: ({ actions }) =&gt; ({ counter: [0, PropTypes.number, { [actions.increment]: (state, payload) =&gt; state + payload.amount, [actions.decrement]: (state, payload) =&gt; state - payload.amount }] }) }) Now we can break this down piece by piece: - `@kea()` is a decorator function that takes an object as an argument - The `actions` key in the object should be a function, and return an object - Each value in the `actions` object should be a function - The `increment()` function takes a parameter named `amount`, and uses ES6 object literal shorthand to return an object where the key is named `amount` and the value is named `amount` (equivalent to `return {amount : amount}` ) - The `reducers` key is a function that also returns an object - The `reducers` function receives an object as a parameter, and that object has a key named `actions`. The `reducers` function is using ES6 parameter destructuring to extract the `actions` key as a local variable inside of the function. - The keys for the object that's part of `counter` are being defined using the ES6 property name syntax, where we can use the value of a variable as a key name. For comparison, here's a partial version of what the `reducers` section would look like using mostly ES5 syntax: reducer : function(reducerArgs) { const actions = reducerArgs.actions; let counterReducers = {}; counterReducers[actions.increment] = function(state, payload) { return state + payload.amount; } return { counter : [0, PropTypes.number, counterReducers] }; } So, ultimately that's almost all "just" using ES6 syntax to write things in a very short way. For more examples and explanations on ES6 syntax, see the [ES6 Features](https://github.com/markerikson/react-redux-links/blob/master/es6-features.md) section of my React/Redux links list.
Oh, neat. 
I wonder why it wasn't mentioned anywhere in their [notes](https://nodejs.org/en/blog/release/v8.3.0/).
Hi, Redux maintainer here. Hmm. The example code shown looks vaguely interesting, but the source of the lib is _wayyyyy_ over my head. Also, from what little of it I can follow, I don't see how your use of Redux internally is even doing anything useful. You're not using any middleware, you're not setting up any enhancers, and your "global reducer" appears to be returning instances of your observable stuff inside the store state. It seems like you could completely drop using Redux and keep your same external API. If someone's really into observables and functional programming, this might be intriguing, but from my perspective it's mostly dropping the things that make Redux valuable and going a very different direction.
Node 8.2 uses V8 5.8, which included the first "release" of turbofan, but it was disabled by default (behind a flag, and as you said, not that optimized). So that 8.2.1 result was likely using crankshaft still. Turbofan was enabled by default in V8 5.9, which was an improvement over the previous version, and was included in a Node RC release, but there were still some sizeable performance regressions in microbenchmarks etc, which is why the Node team opted to wait and jump straight to V8 6.0 which is in a better state.
The word StdLib is annoying me to no end. 
Can you link to some programming podcasts? I've been looking for some but they're not exactly at the top of spotifys suggestions
It's alright, I still have a lot to learn on the subject as well, but I think this part is important to point out: &gt; using language defined functions to return a result that doesn't impact the original variable There are at least 3 array methods that fit this description, but 3 primarily used for FP -- `map()`, `filter()`, and `reduce()` -- and it's not always obvious when you should use them if you're not used to thinking in these terms. However, once you see it, it becomes much easier to read and think about IMHO: ## map() I think of this method as _transforming (or translating) one array into a new array_. Have you ever done this? let result = []; arr.forEach(value =&gt; { result.push(Math.floor(value)); }); You could do this instead: let result = arr.map(value =&gt; Math.floor(value)); ## filter() Use this when you want to target a subset of your original array. Ever do this? let result = []; arr.forEach(value =&gt; { if (value &gt; 0) { result.push(value); } }); You might consider this: let result = arr.filter(value =&gt; value &gt; 0); And lastly... ## reduce() Use this to calculate a single value* from your original array. I know I've done this a lot in the past: let result = 0; arr.forEach(value =&gt; result += value); But this is what I use now: let result = arr.reduce((total, value) =&gt; total += value, 0); The * above is because "value" can be literally any type of data that JS supports; you could return a single string, an object, or even an array may be necessary at times. So those are nice and all, but with each example taken alone you miss the expressiveness. Consider this: let result = 0; arr.forEach(value =&gt; { if (value &gt; 0) { result += Math.floor(value); } }); Vs: let result = arr .filter(value =&gt; value &gt; 0) .map(value =&gt; Math.floor(value)) .reduce((total, value) =&gt; total += value, 0); Sorry to get carried away, but you seem eager to learn :)
In my amateur mind, call backs are usually part of an async process. I think there is a difference between normal program flow control and a call back. The purpose of most call backs I run into is because they are waiting for some async operation (XMLHttpRequest) to finish. And call backs are sometimes built into functions like this ----- // define our function with the callback argument function some_function(arg1, arg2, callback) { // this generates a random number between // arg1 and arg2 var my_number = Math.ceil(Math.random() * (arg1 - arg2) + arg2); // then we're done, so we'll call the callback and // pass our result callback(my_number); } ----- source : http://recurial.com/programming/understanding-callback-functions-in-javascript/ // do stuff then do call back did a search and found : - Any function that is passed as an argument and subsequently called by the function that receives it, is called a callback function. https://www.sitepoint.com/callbacks-javascript/ - we can pass a function as an argument in another function and later execute that passed-in function or even return it to be executed later. This is the essence of using callback functions in JavaScript. http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them
I love the logo for this. I literally loled. 
If you want 100% uptime, you'd want a dedicated server, but you could use it on you own machine for testing
Why did you describe VIM twice in a row?
How? Node can transpile in its own?
Thanks for checking it out! That's good feedback. I'm built on top of redux in my mind because silhouette's create method exposes the createStore method of redux. That way silhouette can use the middleware and enhancers for redux via plugins. Redux is the engine, silhouette is just a layer of shiny stuff ontop. For clarity, the global reducer returns a plain state object- that would be super weird otherwise, I agree. Can you elaborate on the valuable parts of redux I'm losing? I'd like to preserve as many benefits as possible.
I don't follow... In new projects, I generally pick up babel only for object spread. Now that node has it built in, I don't need a transpiler.
[Here's one related to javascript that's pretty ok](https://changelog.com/jsparty).
As I recall they said it was enabled, but most of the NodeJS specific optimizations were for Crankshaft, which resulted in slower performance in turbofan.
Going off what I see in the source right now, and acknowledging that stuff could be added later: At the moment, `createStore` appears to be used internally, so there's no middleware or enhancers. No middleware means no centralized logging, action interception/manipulation, API calls, side effects libs like thunks or sagas, or any of the other middleware use cases. No enhancers also means no middleware, as well as no DevTools for time-travel debugging. I'm also not sure how you would actually go about using this in React components. I assume you'd wind up having to import the `silhouette` instance directly into each component file, unless you were to implement your own `&lt;Provider&gt;`-type pattern. Another concerin is more on the philosophical side. As I talked about in my post [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/03/declarative-earth-part-2-cesium-react/), one of the core intents behind Redux (and main reasons to use it) is to make it possible to easily trace back when, why, and how a given piece of state was updated. While Redux doesn't actually care how you format your action type names, and doesn't care how "granular" they are internally, the _intent_ is that they should be readable and descriptive. So, a type like `"SET_STATE"` (or, in this case, `__DELEGATE__` ) is going to produce a history log that isn't particularly informative. (I also talked about this some in [The Tao of Redux, Part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/).) So, overall, it looks like you're building something that makes a rather different set of tradeoffs than Redux itself does. That's totally fine, just trying to clarify how it differs.
You're entering religious war territory. Just pick one and learn it.
Turbofan hasn't been enabled (by default) in a release build until now, that slower performance was noted in non-release builds using V8 5.9, which included an 8.2.0 RC (but it was [reverted for the actual 8.2.0 release](https://nodejs.org/en/download/releases/)). [One of the relevant discussions](https://github.com/nodejs/CTC/issues/146)
Backbone
?
Angular has too much surface area on it's api. Vue tries to get a litte bit too cute. React just goes "ok give me some state, tell me how to render that state, here are your life cycle methods, and if you want anything fancy (loops, etc) use raw javascript for it". Super powerful, and super simple. So React is the clear winner for me and a lot of others.
Yes, with some limitations. Here's [a few examples](https://stackoverflow.com/questions/13752984/html5-file-api-downloading-file-from-server-and-saving-it-in-sandbox) that may help.
I see where you're coming from, you're giving me some ideas. The createStore function is passed into any provided silhouette plugin on a namespace object currently, so you can do composition shenanigans to get middleware to it. Then it is used internally. I think Ill make a devtool plugin next, based on what you've said. You've given me an idea to help with the ___DELEGATE__ problem as well- by making the functionality of the default case the effect of the current ___DELEGATE__ case, I can get back that more granular logging. This also makes using the store directly alongside a silhouette not problematic. Thanks! As for use in components, I imagine components would be passed silhouette fragments representing their slice of state via prop. The root silhouette is also useful, though. As you said, it can be imported. I'm still playing with ways to get those references passed around properly and cleanly- That's the part of the code I'm least happy with so far. Your comment on tradeoffs is wise... it makes me wonder about the sheer complexity of the optics and what they replace elsewhere in the code.
I went to a bootcamp back in the day before there were tons of them. Shortly after I left, they switched to all JS and Kyle Simpson was hired as the director of curriculum. Sometimes I wish I had been able to do the bootcamp while he was writing the curriculum. I've read a couple of the YDKJS books and watched some of the Frontend Masters workshops. They are great resources.
I had a little helper function called promiseChain function promiseChain(promises){ let data = []; return promises.slice(1).reduce((c, i) =&gt; { return c.then(out =&gt; { data.push(out); return i(data) }) }, promises[0]()).then(last =&gt;{ data.push(last); return data; }) } const chain = [ () =&gt; Promise.resolve(200), ([twoHundred]) =&gt; Promise.resolve(twoHundred * 3), ([twoHundred, sixHundred]) =&gt; Promise.resolve(twoHundred + sixHundred / 8), ]; promiseChain(chain).then(([twoHundred, sixHundred, oneHundred]) =&gt; { twoHundred + sixHundred + oneHundred // 900 }); But now I just use async await;
Is advertising allowed in here? 
Everyone has their preferences and some people are really aggressive in what they recommend/use. Don't pigeonhole yourself, use whatever you like best. They all have their merits and uses, all can be used to build web applications. In my opinion, learn them all.
If promises aren't enough might as well go all the way to observables. 
 Vue hands down no questions asked. Angular is a non-starter btw, you shouldn't even be considering it. You should look at React just in case you like it and then move to Vue and get shit done.
If you want to get proficient in current JS, and prepare for the situation in a few years, do you really think it is wise to start by learning ES5? Having modern syntax as the "natural" way of doing things sounds logical to me. 
Hey, you're a fellow Chicagoan! Well-written guide!
I don't like that article actually..it is just people coming from different background trying to do things like they are used to do. ES6 imports is usually al you need and if you want to share recourses than you will use a state container or redux. The things is that you will have to use factory functions to reference imports and you will have to import all dependencies in one place anyway which than again can lead to circular references and very hard to find bugs. I had my fair share of the issues as I tried it also this way ..but than realised that wait this is my OOP/PHP thinking and not the Javascript way. You will want to organise your code in modules and namespaces which you can map with webpack and just leverage imports. You can thing about imports like namespaces in PHP which already provides the dependancy without the need of a DI. You don't have the issues which DI supposed to be solving because you can import only exported dependancies..so for instance if a dependance changes, you can pretty much rewrite the entire dependancy and just replace the export and you app will still work. This is were the PHP world is heading as well if you checkout for instance Symfony's new auto wire features 
Seriously.... You wrote your own formatter before a simple 15 second Google search? If you're not aware of mdn, I'm about to improve your life considerably. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify Edit : Interesting that last night I was at +8 upvotes. Now in the morning I'm at -8 with people saying I'm being discouraging. All the SJW are up and the programmers working. 
No, he wrote a wrapper around what 15 second Google search yielded him.
JSON.stringfy does support indents. Reference here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify clean nice little project tho.
I admit to not searching very hard, because I was really excited to test out JSON.stringify's built-in formatting. :)
Right! That's what prompted me to build this and [test it out](https://github.com/RobertAKARobin/json/blob/gh-pages/index.html#L87).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [RobertAKARobin/json/.../**index.html#L87** (gh-pages → b6d4755)](https://github.com/RobertAKARobin/json/blob/b6d4755862f6fb9a8ae0b784c2b073019d0a54ca/index.html#L87) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlgpe9a.)^.
lol, somehow I read TIL as 'til' not 'today I learned' (and I think some other ppl as well) 
Hey there! I'm just refactoring all of my repositories and moving them to the newly created @tunnckoCore organization (before it was my own profile). The link points to CONTRIBUTING.md file that will be included to each repository. But there's also an extended version in tunnckoCore/contributing's README. There will be included more and more things, for now that's it. I'm asking for some feedback and thoughts. :) Is it good and welcoming enough for new ones and for power users?
Well not really. For instance, I am a web developper. Webstorm provides a few things out-of-the-box that make my life easier. Say, a Node debugger, or a Babel file watcher, or autocompleted documentation for native Javascript methods. Those are absolutely very specific to Node or Javascript of course. Yet they're already there in Webstorm, nothing else to do or to install or to configure. See my point? Vim is an absolutely excellent tool, I use it too all the time. But it's a hassle to learn (not even mentionning mastering) and it takes time to extend properly so that I get the same kind of features Webstorm provides out-of-the-box.
Feathers! 
lol
WTF is this bullshit lol
Why so negative mate? He learned something new by building it himself. Awesome stuff!
Angular is like Windows or OSX. You pick it and you get all the tools you'll most likely need out of the box. You write HTML and give it fancy behaviour by using special tags and attributes. React is like Linux. You get the basic stuff and pick tools for the job from the open source ecosystem or write your own. Your write JavaScript and in it your write kinda HTML that gets rendered into HTML. Vue is the best or worst of both worlds, depending on what you like. It gives you the basic stuff only like React but is HTML-first like Angular.
Don’t listen to them. This is great and something I have bookmarked and will genuinely be using in the future! Thanks!
Would be nice with a Hello World template.
Look at usage stats, that's pretty much all you need to know: https://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue,@cycle/run,@polymer/polymer There's a reason for how it's fallen into place. Angular was amazing but it did struggle with issues that couldn't be resolved due to its roots. Vue is a polished Angular on the outside but inherits the same oop/mvc/di bulk. React is more of a newer paradigm, it fixes most of the problems older stacks had and it does it in a way that is radically different, though elegant. That paradigm will last for a while, even if frameworks change they will use these principles for years to come. [Most frameworks today](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html) are React derivatives, even Vue is React underneath. In itself React is [simple to learn and use](https://egghead.io/courses/react-fundamentals), learning it is a matter of an hour maybe, its api surface fits the palm of your hand. It is forward thinking (see Fiber, Reacts upcoming release) and allows you to write applications natively everywhere. It is the only framework that is seeing industry adoption outside of the web. Microsoft for instance has adopted it, Androids Kotlin is borrowing from it, and there are many others. 
Not really relevant, but I just saw a thread in /r/programming about how Node is now super-popular for all sort of apps. If it's so popular why is /r/node a ghost town with almost no threads having more than 1 comment? And the /r/javascript thread about a Node release gets 1 comment per hour? 
Because node only needs one thread
What is transpileing your files to ecma5?
I've pasted in the following and it just says "Bad JSON :(": `{obj: { subobj: { subsubobj: { val: 1 } } }}` ... What am I missing here?
Oh, you!
I assume it's becaue JSON keys must be double-quoted.
Ah, you're quite right. Javascript spoils me.
So many people have been missing the point of /u/robertgfthomas's post. Its not that he built a formatter from scratch but he found out that JSON.stringify supports indents and used that as his fomatting engine
https://xkcd.com/1053/ 
[Image](https://imgs.xkcd.com/comics/ten_thousand.png) [Mobile](https://m.xkcd.com/1053/) **Title:** Ten Thousand **Title-text:** Saying 'what kind of an idiot doesn't know about the Yellowstone supervolcano' is so much more boring than telling someone about the Yellowstone supervolcano for the first time\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1053#Explanation) **Stats:** This comic has been referenced 10903 times, representing 6.5913% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dlgv6s3)
Install nvm, then run nvm use 8.3.0, and nvm alias default 8.3.0
Nothing, node is able to use the syntax without transpiling 
I posted this link a month ago when it wasn't as comprehensive. We had to come up with a set of common practices for everyone to follow in our team. The result was a list of guidelines which looks random and is not perfect. But we try to stick to it and improve it by making it public. The reason for reposting it here is to have it criticised by community. So please comment if you have better approaches or open an issue on github. Thanks :)
I posted this link a month ago when it wasn't as comprehensive. We had to come up with a set of common practices for everyone to follow in our team. The result was a list of guidelines which looks random and is not perfect. But we try to stick to it and improve it by making it public. The reason for reposting it here is to have it criticised by community. So please comment if you have better approaches or open an issue on github. Thanks :)
He didn't write his own javascript function to format JSON, but made a website which uses JSON.stringify. But even if he had written his own JSON formatting function, a javascript JSON formatter is hardly a grueling task: function stringify(obj, ch, depth) { depth = depth || 0; ch = ch || " "; var ws = new Array(depth + 1).join(ch); if (obj === null) return "null"; if (obj === true) return "true"; if (obj === false) return "false"; if (typeof obj === "string") return '"'+(obj .replace(/\\/g, '\\\\') .replace(/\"/g, '\\"'))+'"'; if (obj === Infinity || obj === -Infinity) return "null"; // Infinity and -Infinity should be null if (obj === 0) return "0"; // -0 should be 0 if (typeof obj === "number") return obj.toString(); if (obj instanceof Array) return "[\n"+ obj.map(x =&gt; ws+ch+stringify(x, ch, depth + 1)).join(",\n") + "\n" + ws + "]"; // Treat obj like an object if nothing above was triggered return "{\n" + Object.keys(obj).map((i) =&gt; ws+ch+stringify(i.toString())+": " + stringify(obj[i], ch, depth + 1)).join(",\n") + "\n" + ws + "}"; } Sure, it's probably half an hour of work and not worth it when you can just use JSON.stringify, but come on, it's just 30 LOC...
It doesn't work, sadly. Bash doesn't support emoji input.
So how is this running in the browser? And why do you keep downvoting,I'm just asking a question....
You have a valid point, and it's not something I would insist someone do if they where someone I was mentoring. More of something I would encourage so that they could develop a better understanding of the language.
Default values are not the point. The point with dependency injection is that they dependencies are injected (from the outside). So your snippet could be an example of DI but not because you used "default values" (actually in this case dependency injection would be gone, because there would be no injection) but because your constructor allows for injecting dependencies via arguments. class Whatever { constructor(someDependency) { this.someDepenency = someDependency } } This would be sufficient ;) 
I'm not voting on anything. It doesn't run in the browser, this is about running on node
With the use of some es6 it could be as easy as the following: function add (arr, bookName) { return [...arr, bookName] }
ES6 imports are not replacement for DI. I think AngularJS has made a big misunderstanding with their DI version because in AngularJS (1.*) DI was used as a replacement of module system like CommonJS, AMD etc. These were times where big applications were made with concatenating files (Browserify, Webpack was not so popular). AngularJS adressed this issue by creating its own module system. I think that's why people think that DI = modules. In my opinion DI is used everywhere in JS. For example in React when you pass props from parent to children, or you use context - this is also DI. Although I would agree that JavaScript has its own way (so porting Java DI implementations to JS 1:1 would not be necessarily good). 
+1
You can find an hello world example with express here: https://www.openode.io/sub-sample.zip
Thats what I actually meant..that you don't really need a standard DI(IoC) container just to have dependancies in one centralised place..because the current version of JS just works in a different way than Java, asp or PHP
Even shorter: const add = (arr, bookName) =&gt; {...arr, bookName}
MDN web docs is my go-to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ Check out what methods are already available. The other posters here have given good suggestions!
Ok then it makes sense. What are you developing on node in JS if not for a browser?
The server side components (e.g. express), command line tools, anything you want really
If native apps excite you, the only solutions is React (because of React Native). That's the leading factor I've let lead me.
x-ref: https://www.reddit.com/r/programming/comments/6sz1jt/nodejs_foundation_report_from_survey_nodejs/dlgw8ii/
That was genius! [I had to do this...](https://www.reddit.com/r/ProgrammerHumor/comments/6t0tib/blamo111_why_is_rnode_a_ghost_town_with_almost_no/)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programmerhumor] [blamo111: ... why is \/r\/node a ghost town with almost no threads having more than 1 comment? And the \/r\/javascript thread about a Node release gets 1 comment per hour?](https://np.reddit.com/r/ProgrammerHumor/comments/6t0tib/blamo111_why_is_rnode_a_ghost_town_with_almost_no/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I have to second this. If you don't have experience yourself, learn what most other people are using. That is react and it will be react even in 2 years time.
If you invoke `start` after these declarations, there's nothing special going on. The start function has access to `done` and `next` once it is invoked only because they exist in the scope where the `start` function is called, even though you technically defined them after you defined `start`. A really simple callback example is: function done() { console.log("I'm done!"); } window.setTimeout( done, 2000); The done function is defined but not invoked (or called). It is passed to the `setTimeout` function as a callback. You'll notice it is just a reference that is passed and it is not called via `done()`. The setTimeout function is asynchronous, and when its job is done it "calls back" to the done function. Therefore you see the log output after 2 seconds. 
Nice idea but I think there is a problem: the button to open/collapse a file are hidden when the files are collapsed and the two are displayed when a file is open. (Sorry for my bad english, it's not my mother tongue, I can provide screenshot if you need)
Hi /u/danielfurze, I thought it was funny, but the users have reported it many times so I've removed it :( 
Nice work
Because this is level 1 stuff.... 
Would probably be helpful to say what version of angular you have to use
They said angular 2
Yup, I agree. But does that matter? You can choose to ignore the threads you find uninteresting. Everyone has to start from somewhere and it's already too difficult to get into software development without everyone's discouragement
I feel like the graphics on the homepage of your service need some work - the inconsistent color scheme on the icons near the bottom and the flowchart-y thing at the top aren't really helping to convey your message, they're just getting in the way and distracting people from the actual, important content: the examples. If anything, you should replace the icons at the bottom with the points you make in the slideshow thingy at the top. Those slideshow-y things are usually to show a preview of different articles or events, not to send the main message of the page! I literally scrolled right past it without clicking to see what was on the other four pages of it! It would be best to focus more on text and the terminal intro than on the fancy website contents - it has little bits of awkwardness, like the fact that the step for installing the command-like tool is *below* the usage example. It might be better to give an example like *this*: # Just install our command line tool... npm i -g openode # And deploy your app, just like that! openode deploy
Ahhh ok thanks!
Thanks very much for your fruitful comments. Yeah the front pages definitely need some work.
* `angularjs` refers to versions 1.x and `angular` refers to versions 2+. * go to the [angular quickstart](https://angular.io/guide/quickstart) and work through the tutorial fundamentals section. * [ngrx](https://github.com/ngrx/platform) store is basically a redux + observable state management platform. React devs seem to like redux, so maybe you'll like this. 
maybe github instead of a zip?
This is a cool little example. For anyone who doesn't know how to do this, the third argument in JSON.stringify is an option for how you want the parsed json to be indented (generally an integer denoting spaces or a string denoting the spaces). By default, it is not indented. What I normally do is: JSON.stringify(json, null, 2); What /u/robertgfthomas did is a *tiny* bit more complicated, where he allows you to set the indent level based on the top-most text area, with "\t" (the tab character) - as a default: textOut = JSON.stringify(JSON.parse(textIn), null, (indentLevel || '\t')); And yes, I know this is basic stuff, but hopefully this will help someone become one of today's [Lucky Ten Thousand](https://xkcd.com/1053/).
[Image](https://imgs.xkcd.com/comics/ten_thousand.png) [Mobile](https://m.xkcd.com/1053/) **Title:** Ten Thousand **Title-text:** Saying 'what kind of an idiot doesn't know about the Yellowstone supervolcano' is so much more boring than telling someone about the Yellowstone supervolcano for the first time\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1053#Explanation) **Stats:** This comic has been referenced 10905 times, representing 6.5917% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dlh38x0)
Thanks, bot!
[](/sswink)My pleasure
I'm not trying to be discouraging, I'm trying to spread awareness of the documentation
Oh nice. It's hard finding other devs in Chicago.
Here it is: https://github.com/martinlevesque/openode-hello-world
Thank you! Yes I am :)
This looks really good but new. Do you have any criticisms of the serverless.com framework that made you build this?
thank
Am programmer, currently working (ish). We're down voting you because you're being a dick for no reason. Nothing to do with your imagined SJW conspiracy. 
It's the culture not a conspiracy. You guys can't take any negativity. Everyone's a winner. Even the guy who can't Google. 
Thank you.
I, and I imagine most people, are fine with critics- just do it in a way that isn't toxic right off the bat. Saying something like "I'm glad you had fun learning something new! As an aside, here is a link to the MDN documentation in case you weren't aware. They have lots of information about this and other APIs" is valid semi-criticism. It softly lets one know that they didn't really do something new, but doesn't cut their head off for posting the (to them) cool thing they did. What you posted is just unnecessarily vitriolic. That's why you're being downvoted. 
Hi /u/openodeio, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
edit -- I misread some of the post and my comments make me look foolish. Nice post/work.
Nope. It's sometimes permissible when there's a free tier or similar. Also, you're shadowbanned.
As has been noted before, that works when you know how many significant digits you're going to need later.
Things you need to know: SQL or Mongo JavaScript NodeJS ExpressJS REST How comfortable are you with these technologies? [ You could also just jump in the deep end](https://medium.com/@jeffandersen/building-a-node-js-rest-api-with-express-46b0901f29b6)
&gt; SQL I've done production-grade work using PostgreSQL. Interacted with it using the Django ORM. Haven't really touched too much 'raw' SQL, but have a decent grasp on it conceptually. &gt; JavaScript Pretty comfortable for general use on the front-end, but I'm just now getting into 'full-stack' Javascript. &gt; NodeJS Fairly comfortable with the general ecosystem. See above. &gt; ExpressJS Never used it, but from Googling around before this post was submitted, I figured I would need to pick this up. &gt; REST Knowledgeable in some ways, lacking in others. I've interacted with RESTful APIs plenty, but have never created one. 
[removed]
[removed]
Cool, find a tutorial for building out a REST API using Express and SQL (I personally prefer postgres, but any SQL will do.) Or you could start with the tutorial I linked above. I did a quick scan through it and it seems to cover all the basics. Does this API have to be production ready?
Thanks for the tips! I will probably stick with PostgreSQL as I am a huge fan of it, personally. MongoDB seems to be pretty popular for full-stack JS, so I might give that a shot if it makes sense. This is just a personal project I wanted to take on to learn more about making REST APIs and working with server-side JS. I'd like to make it public, but it doesn't necessarily need to adhere to any strict standards.
Are there any meetups / relaxed social groups for devs in the city? I'm a dev, and most of the other devs I know are from college or work.
You seem to be in a good position to dive in with your previous knowledge. There will be some gaps to fill, but that's the fun part.
You don't have to use sql or any database. If your project is small just store everything in flat file json
It would potentially grow to be quite large, although starting off it will definitely be pretty small. I have considered this, but I'd really like to learn more about using JS with databases. 
Fixed. Thanks for reporting.
I've been on meetup for a while and besides the bootcamps, I haven't had any luck. All of the Chicago devs I've found have been through Reddit. I'm in a discord group with a few but it's barely active.
I have yet to try out any Meetups for dev (I usually do biking or boardgame Meetups) though I've met people through interesting random means like Twitter. Hmm, I'm leaving the country for a few months next week but I might try to start something for Chicago when I get back.
I'd be down, if you start something. I know a few other people that'd be interested as well. I'm still learning and would appreciate being around more experienced people.
Did you base this off of anything, or is it just from your team's gathered experience? Would you recommend these practices for solo-devs as well?
These are the bits that I got hurt from the most, so It's mostly from experience. But I had to find other resources (articles, docs) to back them up. I highly recommend you start using them because some of these practices are commonly used.
Great post, a lot of what you have down mirrors the workflow and practices that I employ.
I've seen lots of tutorials for express and MongoDB but if it's a major project I would go for sails
Thanks, if there are any practices that you or your team use and worth mentioning feel free to make a PR, or open an issue for it so I pick it up.
But that is way easier than number of decimal digits. Sigfig? 5. 
thank you very much for the explanation when managing the state now all works fine! 
I'm pretty sure this allows you to use Go as a Lambda runtime.
I would suggest working on a way to map your CSVs to JSON objects and then you will have filter/map/reduce at your disposal. 
OP didn’t make the tool. 
So does Serverless through a shim
I feel like there is always something tech-related happening in Chicago. I usually attend about 2 meetups every week. For JS there is the [Chicago JavaScript Meetup Group](https://www.meetup.com/js-chi/). And I really like the events hosted by The Nerdery, ChiPy, and ChicagoRuby. Also are you aware of Chicago Tech Slack? It's got over 3000 members and it's pretty active. Great way to connect with other Chicago devs. http://www.chicagotechslack.com/ /u/pentakiller19 /u/floppydiskette 
i didn't make this, but TJ did (person who made express.js)
I heard that React Native apps aren't as fast as Android/iOS native-native apps. Is that true? (specially with long lists)
Awesome! I didn't know about it, but I'm going to join.
What board game meetups are there? I'll be looking to join some when I move to the north side of the city 
Thanks for the links. I've been avoiding meet ups after having bad experiences in Miami. How are the ones here?
The 10,000 applies to things that everyone will know by the time they are thirty. Unfortunately, programming does not falls under that category. :(
No, this is amazing information! I really appreciate the time you took to explain this.
I appreciate the feedback. To be honest, sometimes I struggle with the examples provided on sites like MDN, I find that if the example isn't doing what I'm trying with it, it's a lot more challenging for me to understand the application in terms of how to accomplish what I'm trying to go for, it's definitely something I see that I need to get over and spend the time really thinking about the examples presented in articles like this.
Not sure why this was downvoted but it was very informative, thanks!
Neat thing about programming is even if you're reinventing the wheel, you're likely still learning something.
Vue.
haha. exactly my thoughts. react is like an ugly version of vue. or vue is a simpler, prettier version of react. however you want to look at it, vue all the way.
&gt; Vue tries to get a litte bit too cute. ?
&gt; Backbone 
thanks for checking it out despite the points :) I was hoping that /r/javascript has some more advanced tips and tricks for me.
Might also check out this from our front page: [I wrote about some examples of using map, filter, and reduce, as well as accessing JSON and using the DOM with vanilla JS](https://www.reddit.com/r/javascript/comments/6sytdf/i_wrote_about_some_examples_of_using_map_filter/) Full disclosure: the site's not resolving for me, so I haven't reviewed it, but it looks to cover the same 3 methods I discussed.
I bought your book. Can't wait to get stuck into it, looks great :)
well of course not. But they are excellent, and the past year brought several key improvements like `FlatList`. So overall it's a win, as the developer experience is many times superior. For probably the majority of use cases regarding lists the difference isn't noticeable--it's a native scroll. 
So as someone who was learning this stuff a few weeks ago and definitely used some of the tutorials listed. Where should I look for a best practice way of doing this?
I'd consider this as a spam.
Usually you're best off finding a well known and battle-tested library that handles all of your authentication, authorization, and identity management. From there, follow their documentation. Most of these issues stem from developers making these systems themselves, which is risky and unnecessary.
I didn't know about debugger, thanks! 
TJ isn't real, it's a bunch of world class developers posing as one dude. Kidding, but he puts out so much work it makes everyone feel like an imposter.
Is this missing exponential retry? Usually you want the first retry to happen immediately, and then scale back from there.
Great job! I was just building CONTRIBUTING.md file too in the last few, but didn't know for yours. I'm thinking for extending it, because i have mcuh more to add, so your guide may help too :) Hope you can learn something from my, too. And also, [my readmes are just awesome (actually the whole flow &amp; automation)](https://github.com/tunnckoCore/parse-function) too :) https://github.com/tunnckoCore/contributing - the README is main, and the CONTRIBUTING.md file is file that is included in each repo, from which there is a link to the extended version (e.g. the readme of that repo)
Well the first think I learnt by just looking at it is to add "back to top" links 👍
For parsing a CSV file into a JS object which you can filter, you can use [papaparse](https://github.com/mholt/PapaParse) 
he is a Canadian guy, he did work for segment in person, you can follow his twitter
Thanks.
&gt; Bluebird's Promise.some() only requires a certain portion of the promise iterable to pass, but ALL must return results before it triggers a then() If I understand what you're saying, I don't think that's true. https://jsfiddle.net/tcs5h1km/1/
Ok i would do something like this. acme/Foo.js export default class Foo{} acme/Bar.js export default class Bar{ constructor(foo){ this.foo = foo; } } acme/index.js (entrypoint) import Foo from "./Foo" import Bar from "./Bar" export const FooFactory = () =&gt; new Foo(); export const BarFactory = () =&gt; new Bar(FooFactory()); And than access them at any point I need them, e. g. a main.js import {BarFactory} from "./acme" const bar = BarFactory();
Cool, I will give it a try. Do you know if it reuse the list cell? And it's not slow even with images inside list items? I am asking because I am Android/iOS "native-native" dev, and building with only one language would be cool but loosing performance isn't a choice.
Very informative. So for Google to fix this, could they not just require that any mouseup event for a given window require a corresponding mousedown? 
I would recommend reading the angular styleguide. It should give you some ideas what best practices are: https://github.com/johnpapa/angular-styleguide
Thanks
yea, definitely, good navigation is "must" for such long documents. i'll save some more time to dive more deeply in your, and i'm almost sure that i'll include something from it! Very thanks again! Collaboration is awesome thing too :)
Don't forget about this one! const someVar = 'hi'; const someOtherVar = 5; console.log({ someVar, someOtherVar }); // -&gt; { someVar: 'hi', someOtherVar: 5 }); Also, OP, the design of your blog makes it kinda hard to read, and there's so much wasted space! I get that maybe you don't want to be like every other blog, but look at how much nicer it is to use when you follow typical conventions: http://imgur.com/a/RYjDj
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/Mf4Hzfd.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dlhszi6) 
this was great to watch. Thanks!
That was basically also the issue: &gt; On the Mac, the mouseup from a mousedown only gets delivered to the page that got the mousedown. On Windows (but interestingly, not MacViews!) the **mouseup** can get delivered to a different page than the mousedown. But the fix was a bit more powerful. &gt; Expand the power of the popunder preventer. &gt; &gt; If *any* WebContents in the opener chain of a popup attempts to bring itself forward in front of the popup, block that attempt to create a popunder. https://bugs.chromium.org/p/chromium/issues/detail?id=752824
There is a signaling server. The Webtorrent tracker servers are also signaling servers.
Wow that's a very nice answer: you put simple words on what was in my mind after using AngularJS and React. Thanks also for the npm chart: makes things very clear.
In Chrome dev tools, you can also set breakpoints without polluting your code with 'debugger.'
So much wasted talents on popups of all things....
I can't comment on the implementation details, but the concept is called a [continuation](https://en.wikipedia.org/wiki/Continuation).
Probably downvoted by the pop-under developer ;)
Basically it's exactly the same as a regular function except that the scope is kept between executions e.g.: function* foo() { const x = 12 yield x yield x + 10 } In that function there's a scope record that has the value `{ x: 12 }` after the first `next`, when the generator is paused it keeps the scope stored for when the next `.next` is called, whereas a normal function would hit a `return` and dispose of the `{ x: 12 }` scope. If you want the details of that here's the actual code that a generator is in v8, note that the `context` parameter to `GeneratorPrototypeResume` is the the thing that contains the scope record: https://github.com/v8/v8/blob/master/src/builtins/builtins-generator-gen.cc#L27
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [v8/v8/.../**builtins-generator-gen.cc#L27** (master → 94830f4)](https://github.com/v8/v8/blob/94830f4b1b635139e22d69642add593f34ebe726/src/builtins/builtins-generator-gen.cc#L27) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlhy2lu.)^.
I really dislike the "bucket" approach to resources. It's popular, but dumb (imo) When you have a class, class User { //some junk } const user = new User({id:17}); assert(user.id === 17) I think &gt; /users/17 Is kinda dumb. When parsing the url in express (or whatever thing you're doing) it's an extra operation to append (or truncate) the 's' from the string to figured out what you're actually doing. The same is true for database names. When you're talking about objects, tables and urls do you say "The user table" or "The users table"? The url/table name/module name defines the *type* of thing you're working with, not the plurality of the thing. Gah! 
No love for console.table?
NVM is the best.
Can we stop calling them "best practices" and simply call them "practices"? Today's "best practices" are tomorrow's "bad practices", and today everyone has different ideas about what the "best practices" for anything actually are.
there is money in ads ;)
How so?
A multitude of things. Maybe an object-document mapper. Maybe an Electron app. 
What terminal is that?
I love this. I want this to be a continuing series where you battle against the shady pop-under developer. He continues to discover new and interesting ways to circumvent the blockers while you continue to discover new and interesting ways to debug and deconstruct his code. Eventually he will run out of options and be defeated, thereby being forced to reveal himself. But there's a twist! . . . . . . It was Avi Drissman the whole time!
If you wanted to learn how to do these things properly, where would you go to learn? Sometimes knowing the "how", makes me think differently about other decisions within an application.
Not to mention goose, mouse, moose...
It's hyper with the Dracula theme and the fira code font 
Yeah you won’t be able to do this on Windows. Emoji support isn’t as integrated on Windows as well as is on Macs.
That's great!
I lost track of time watching that. Great detective work! Interesting to learn the nuances of browser engines. New subscriber :]
I've been struggling with JS... This vid, thru your highly explanatory approach, showed me that I'm not struggling with the language itself, but with my own assessment of how much I thought I knew. I was able to follow everything you said. I mean, like being a fan of a sport, I can understand the finer points of what's going on without necessarily being able to do it myself. Great video.
I'm hard against that from the beginning. We can use the constructor as said in article too. That's absolutely needless and adds no benefits, i believe? Bytes are almost the same too.
There is a popular third party package that does reuse really well. I think by wix. The core packages probably do too, to some extent.
I guess it's more about making it more idiomatic with how people write imperative code. Nothing more than syntactic sugar, it may be useful or not, the devs will tell.
I our projects we have a bunch of Symfony and Laravel apps, and we have many things working as daemons or handlers for specific parts of our business logic that fit better in JS that are micro services. While I don't have a full blown production JS app in production, I personally have a few in working on and here's what I like the best so far: HTTP/Router layer: ExpressJS "ORM": Sequelize for SQL, Mongoose for Mongo with schema, Monk without Requests: Axios Rendering: VueJS server side, Jade, Handlebars (all good, really a matter of preference) Auth: PassportJS, genuinely wish this would exist in the PHP world Validation: haven't found something I **really** enjoy using Scheduling/CRON/Some queuing: Agenda (another awesome one) Events: well it's JS, use its events Sessions: Express sessions Localization: i18next WebSockets: Socket.io -- don't drink the KoolAid that it's slow, it got a massive rewrite last year Also, FeathersJS seems like, to me, the best framework if you don't want to compose your own app. Biggest tip tho is embrace the prototypal nature of JS, don't try to use it in a classical (programmatically speaking) way, with the good (super powerful inheritance which is really more composition) and the bad (lack of object contracts, alternatives to inheritance).
Agreed. Pretty sure (on mobile so can't test) that if the function in the first code snippet was changed to an async function, then that would achieve the desired result. edit: Yup tested it and it works, also shorter than all other solutions, including `Promise.try` async function countPlusOneAsync() { return countAsync() .then(result =&gt; { return result + 1; }); }
I disagree - the line lengths in your design are way too long and hurt readability. I think his design could be improved by narrowing the left column a bit though.
hm, actually, good idea. You mean the function that is passed to the constructor? Probably, but then maybe it won't be in same tick? hm, i'll play.
yea, it won't hurt any way.
It’s not a big deal, but it does make code prettier and more self-explanatory (IMO) if you have to work with Promises directly. If you don’t – which is most of the time – then async functions are much better, anyway.
oh, my bad, i'm sleepy
Yes, exponential retry is missing. Usually we get sudden spikes in traffic thus we don't retry immediately.
Not sure if you've found a tutorial or not but this YouTube playlist is really nice, I've been using it myself: Node.js &amp; PostgreSQL Recipe App: https://www.youtube.com/playlist?list=PLillGF-RfqbaEmlPcX5e_ejaK7Y5MydkW
But why
For me the biggest crime: Writing layers of abstraction for the sake of productivity. Important concepts should be more explicit (more code) instead hidden away, while minor concerns should be hidden For a clear example. Look at Table 1.5 here: http://www.informit.com/articles/article.aspx?p=1944876&amp;seqNum=3 Not only most people strive for the second solution, they are even praised for doing so. 
[but just in case you need proof](https://www.youtube.com/watch?v=wxDBF3OOaRA&amp;feature=youtu.be&amp;t=178)
I think it's good to understand what JSX actually does, but I have no idea why anyone would actually write code this way.
So... essentially this? Promise.try = function(func) { try { return Promise.resolve(func()); } catch (e) { return Promise.reject(e); } } 
Weex (Vue) is also an option for mobile.
Really cool, thanks for sharing
#DID I STUTTER
Documentation is not hiding it from you :) https://facebook.github.io/react/docs/react-without-jsx.html Also, you might be interested in things like https://github.com/hyperhype/hyperscript or http://cycle.js.org/ , based on your article
Yeah sort of
Keep your templates as simple as possible. I'm not saying don't take advantage of features in them. I mean don't do put logic in them. For instance don't: &lt;div *ngIf="loggedIn &amp;&amp; authorized &amp;&amp; !expired"&gt;&lt;/div&gt; Instead inside the controller make a getter: get accountValid() { return loggedin &amp;&amp; authorized &amp;&amp; !expired; } And then the template would just be: &lt;div *ngIf="accountValid"&gt;&lt;/div&gt; Having simple templates will aid in understanding down the road. Learn observables. They are one of the best parts of angular and you shouldn't just convert all your http methods to promises immediately. Learn to use observables to your advantage. In the same vein use observables as much as you can with the async pipe. Then you get to set change detection to on push making sure performance stays high. If you don't know how to use one learn about dependency injection systems. I would say learn in general what di is for and then apply that knowledge to angulars di. Don't just use angulars di by memorization. State is often best handled outside of components just like react. And the idea of dumb and smart components is still valid. It's possible that what you are working on will already be using one of the redux style libraries with angular. If so it will (probably) be familiar. If not just realize that with angular you don't *have* to use something like redux. You can use injected services to act as state stores and still get the same effect of unidirectional data flow. And finally I would say ignore 2 way binding. There's no real need for it. The closest you'll come to *having* to use it is for the basic forms library. But angular also has the reactive forms library which I like using a lot more. Oh and I really can't stress this enough. Learn rxjs and observables. They really are one of the best parts of the framework. But they do require some practice to understand and utilize well.
Thanks a lot
Your shorter solution generates an intermediate array of filtered values for the sole purpose of obtaining its length, and you wrote the reducer in long form and not the filter which skews the comparison. const originalArray = ["Alice", "Bob", "Charlie", "Bob", "Bob", "Charlie"]; const numberOfBobs = originalArray.reduce((a, i) =&gt; a + (i === "Bob"), 0); 
Oh I should add that for the example getter I wrote above that would probably be fine because it's very simple but don't use calculated getters inside a template. If you have a value you need to calculate like map and filter an array or something then you'll want to cache the results so change detection tripping doesn't cause the value to be recalculated more than it actually needs to be. In other words don't do get filteredList() { return this.list.filter(...); } Instead do something like @Component({...}) export SomeComponent { @Input() set list(list: any[]) { this.filteredListCache = list.filter(...) } get filteredList() { return this.filteredListCache; } } And then your template could freely reference filteredList for an ngFor or whatever. There are various other ways to achieve the same goal. Like personally for that example I would probably end up feeding the list into the component through an observable and I would just attach a filter operator to the observable before feeding it into the component. I'm just trying to point out that you don't want to attach "expensive" calculations to your templates. The /r/angular2 sub is a good place to ask questions specific to angular. Oh and if you don't have another setup in place or are willing to switch I can't recommend using the official cli highly enough. It's referenced in the official documentation at angular.io.
[removed]
There is no big difference between angular 2 and angular 4? 
If the resource is loaded by another function that is responsible to dispose of it and the iterator is used to iterate over that resource which is in memory and properly cleaned up already, then I guess we can avoid this problem? What we could learn from this is to avoid accessing resources that need cleanup when using iterators. If you do, at least make sure you know what you're doing if there's no other alternative.
This is a great video! Thank you so much for posting it :D Since it's using a mouseup handler, does that mean that the new tab would be more obvious if you just hold down the mouse button without releasing it?
Yep, I think it would.
Nope. It's the same framework. They have added a few things here and there but for 2 - 4 the 2 biggest changes were under the hood speed and size improvements and they made the animation stuff into its own package. To give you an idea I upgraded a ~30k sloc code base from 2 to 4 and I had to change 1 line. They have a container type that changed from untyped contents to a generic so I just had to add &lt;myType&gt; to the type information. I had a few warnings about the animation library being moved but everything still ran fine. And those warnings I resolved in about 30 minutes. It wasn't really a big deal to me at all.
I see. Thanks for your big help
I've commented on the article and you are going out of that context. 
rss readers in browsers will never be a thing since CORS stops it all. You need a local proxy for it.
Are you a savage?
Fair. I did it in a hurry, just using chrome inspector. Really I think I would increase the font size (I don't believe the issue is the actual width, more the number of characters per line), and set a max-width to something reasonable. But yeah my point is that it's _so_ narrow right now, and because the column isn't center-aligned, it looks really odd when you're scrolled down. A narrow column off-center in a sea of white.
[removed]
So the performance profiler includes the content of popups, nice to know.
This is debugging on another level. Very eye-opening. Link to the author's subreddit here: /r/LiveOverflow
I released v2 of my React state management library: https://github.com/solkimicreb/react-easy-state. It focuses on being simple and maintaining a balance of local state and global stores. It uses ES6 Proxies behind the scenes.
And he would have gotten away with it too! If it weren't for you kids and that mangy mutt!
Yeah, but then you have to navigate to your code in that little inspector window :D
True, but you can quickly make note of the line number and use CTRL+G to goto that specific line. Or you can use good ol' CTRL+F.
No. Just no
#DOES HE LOOK LIKE A BITCH???
"My team is not adopting this technology because HTML inside JavaScript is stupid"
I write many a Node lib and quite often a few lines of JSX don't warrant the inclusion of Babel. Plus the API can be more terse than JSX at times.
Why would anyone want to write Javascript in Javascript rather than in XML? Granted React's hyperscript isn't quite as nice as some others. With Mithril you can do things like: m('#foo.hero', 'The hero text') m('p', 'A paragraph') In React you'd have to write h('div', {id: 'foo', className: 'hero'}, 'The hero text') h('p', {}, 'A parargraph') I'd still use hyperscript over JSX in React though.
You're assigning test in the function body, but you never actually call App as a function. You should read up on the JavaScript module pattern: https://toddmotto.com/mastering-the-module-pattern/, that'll show you how to do what you're trying to do.
App should be declared as an object. var App = {}; App.myFunc = function() { alert( 'test' ); }; To call it, App.myFunc();
Why? It's really the same thing and JSX is easier to read and work with.
Usually for something like this (storing related functions under a single variable), it's recommended to use the revealing module pattern. http://jargon.js.org/_glossary/REVEALING_MODULE_PATTERN.md
you could put the functions inside an object var foo = { bar: function() { alert("test"); } }; foo.bar();
What you need to do: const app = new App(); app.test();
Here's a fiddle: https://jsfiddle.net/bjLk4087/1/ Using native JavaScript rather than es6 and works ok. Are you seeing any JavaScript errors in your inspector? You can also set it up so you can have multiple instances of the app. Depends what you need it to do: https://jsfiddle.net/bjLk4087/2/ Hope that helps!
Well that's an opinion. I find JS less typing (don't need to write close tags) and easier to read since I'm not constantly switching between JS and XML. m('ul.itemlist', items.map((item, i) =&gt; m('li', {class: i % 2 ? 'odd' : 'even'}, item.text)) ) 
I've looked at promises, asyc, await, and they look good for waiting for multiple promises to complete as a group. However, they still work on a callback, so I can only say, "when all these AJAX promises have finished, then run this callback", and that callback will have to do the form submit. I can't say, "wait here until these promises are complete" then check the results and actively prevent the form submission if anything failed, but otherwise just continue so everything else connected with that form can run as it should.
thank you so much for the response, now it's much more clear to me!!!... 
This is great thanks for sharing this. I still need a good overview of Monads so I might look at the linked chapter in there as well. My main criticism of this and other functional programming articles such as documentation in Ramda is: 1. Never defining stuff (wtf is a Kleisli?) and 2. Writing code in a terse way so as to abuse arrow functions. The whole chaining of arrow functions is just... total trash for readability IMO. It makes the writer look clever and leaves the reader dumbfounded.
Yeah, many people work in companies where senior tech managers who no longer code have *very* opinionated views on technology, and impose arbitrary restrictions on the tech used to build systems
Looks good! We have such a tiny team all in the same room it's hard to justify the time overhead in keeping the master branch sacred, doing pull requests - so we do merge into it, but dedicated feature development branches is really useful. Also make sure all your team have the same compile settings - we've had conflicts caused by one person having an auto tidier with different white space settings so GIT thinks the whole file has changed. Conflict nightmare.
So, like graphql? 
Hi, I have very limited experience with graphql, but yes in theory you should get a similar outcome with typed structured data. 
Great pace and informative, keep going. 
Watch this series on objects. https://www.youtube.com/watch?v=GhbhD1HR5vk&amp;index=1&amp;t=68s&amp;list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub
I know about all these things but still I thought this was worth writing about. 
Or I just have a different opinion than you! 🤔
That would give you 2 global variables though, App and app. You'd have to call `new App().test();`
Finished v2 of my universally rendered, offline ready progressive webapp in react: https://ismaywolff.nl It's quite resistant to bad network conditions now. I'm still working on further improvements, but for most people it'll work even if they're offline (after it's installed). Due to to ssr it'll even work decently for clients with js disabled :) Source is here: https://github.com/ismay/ismaywolff.nl
You want IIFE module pattern - http://adripofjavascript.com/blog/drips/understanding-the-module-pattern-in-javascript.html var app = (function () { // Private variable below - no access from outside var private_name = "John Snow" function test () { return private_name; } return { test: test } })() app.test() // returns "John Snow"
Because it wasn't designed to store big amounts of binary data. You might want to refer to IndexedDB instead or use browser caching mechanisms in case of images and other resources.
This is a little tricky. On the _instance_ level, data that is accessible through every instance is that which is defined on the prototype. This would be `Dog.prototype.diet` in your example. Its the prototype that is used for instances as a shared location to look up their property values if they're not defined within the instance itself. On the flip side of that there are static properties. But static properties you don't grab from instances. Instead, you grab them from the class itself (e.g. `Dog`). The big difference here is that you can easily access these properties _without an instance_. Static members are stored on the class itself and usually serve as auxiliary data to or helper methods for instances, or something that is known not to change or is meant to be overridden by individual class values, which is possible with prototype values. (And yes, given that JavaScript objects inherit from the prototype, and you have access to the prototype without instances, prototype values can behave like statics in that instances aren't needed. But generally, if something is defined on the prototype, it means you intend to access it through an instance.) 
I know I'm getting into pedantic details with this but I'm curious if attaching it to `window` would count as a global. I'm assuming yes because you can use both `window.App.test()` and `App.test()`. If not, he could do something like: window.App = (function() { this.test = () =&gt; alert("test"); return this; })(); If I were to give an actual suggestion it would be similar to what other people said: var App = {}; App.test = function() { alert('test'); }; App.test(); or var App = (function() { var test = function() { alert('test'); }; var componentTest = function() { alert('component-test'); } return { test: test, component: { componentTest: componentTest, }, }; })(); App.test(); App.component.componentTest();
Through prototypal inheritance. Lassie is a Dog, which is an object. When you do lassie.diet, first it's going to check if your instance has a "diet" method. If it doesn't, then it will move to the upper ladder. Does Dog have a "diet" method? If yes, then it's going to execute the method. If no, it will check if the parent has it. [Here's more detail about it](https://medium.com/@kevincennis/prototypal-inheritance-781bccc97edb)
how much money does gae costs for nodejs ?
According to the information I linked, SessionStorage use to be `unlimited`, so why are they now limiting it? Regardless if it wasn't *designed* to store large amounts of data, it's easy to create our own unlimited SessionStorage, so why the quota?
Many good ideas here! However I would argue very strongly that using stage 2, or anything that is not a shipped feature of a JavaScript release, is not a best practice. While it may be fine for personal projects, the very fact that the specification may change or never be implemented means that it is not worth the risk in the long run. 
&gt; looked even nicer than with JSX no it's not
[removed]
Because plain JavaScript is fine. No need to introduce a weird DSL on top of it.
At this point define global. Is it global if it's attached to window? Is there a way to get a variable hoisted up to the same level as the window object? To my knowledge all top level variables are just properties on the window object. 
Also, you write ES6 methods like this https://jsfiddle.net/ovvshiee/zo0zhw8d/
Even when using babel ? 
Tidy 👌
https://cloud.google.com/appengine/pricing
Especially when using Babel. Just because it can work doesn't mean it's a good idea to use. And if Babel can handle it then that means you can implement it another way. What happens if that feature never becomes part of the specification? It's not like you're using another language and transpiling to JavaScript. Now you have to support a half-baked non-standard feature, or refactor it out of your code. Is it really so important to use whatever feature to sacrifice maintainability? How about a different use case? What about if the feature changes, but your code does not? It becomes part of the spec, but behaves completely differently. Now we're back in the old days when different browsers implemented different feature sets. It's important that Babel can implement all these new features. And I'm not suggesting one should never use them. Try them out, experiment, give feedback to the author and improve the spec. But if you're writing code for public consumption or getting paid to write something for a company , I do not believe it's worth the risk or maintainability headache just to use something new and cool. There's absolutely no reason not to wait for anything in stage &lt; 4 to solidify, and many reasons not to use them in _production_. It's not stage 0-3 because it's not yet implemented in browsers. by their very definition, those stages mean it's not production ready
I'm very convinced. I can change it with a copy of your explanation or feel free to make a pull request yourself 
Actually, you're code does work. You just need to do something like: var myApp = new App(); Then, do myApp.test()
Got the code for this but im on phone right now. Basically just create an object. Each module is a property of this object. Then return the object. Will try to post code later. 
You're right, my wording wasn't correct.
&gt; couldn't I just create my own object to hold a seemingly unlimited amount of loaded data Chrome gives you up to 2GB Javascript heap, but your objects there won't survive a page refresh. But if you're worried about having to download the same images over and over, you should just let the browser's cache handle that for you.
All of window's properties are considered global variables in the context of a web browser. Declaring anything in the global namespace will actually create it as a window property, and creating new window properties will allow you to access them globally. 
Thanks /u/mflux . If you're interested in learning more about monads, I made my own attempt at [explaining the Maybe monad](http://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/).
Seems to me like it was "inspired" by it. After all it was developed in Facebook
Call prevent default at the beginning no matter what, then manually submit the form if everything checks out.
How do I know when everything has checked out? I won't have control over all the events that may be bound to onsubmit. Is there some kind of standard wrapper for all this that onsubmit handlers would hook into in a commonly understood way to cooperate with the overall process? For example a stack of all promises running in the events and a standard way for them all to notify the final callback of the result?
You may want to look at Promise.all... waits for multiple promises running in parallel. You need some promises and once they're complete send the form info with Ajax.
You need to get access to the source file. This is definitely a legally questionable though. 
The oldest protobuf release on that I found on github is from 2011 and that is for v2.4.1 https://github.com/google/protobuf/tags?after=v3.0.0-beta-1 
AKA the revealing module pattern. Christian Heilmann's explanation is among the best.
You can have 1.5GB (in V8 anyway) of memory in use on a page, and arguably that's what a session is. So if you really need THAT much, force a polyfill, never rely on the included storage mechanism, and you're back in business. 
Check out Service Workers. They are perfect for caching images. With this you can even load all of your cached content while there is no internet connection
The backend. That is why node exists at all no?
the problem here is that array.reduce is synchronous and so would run over the entire array right away and not wait for one to finish before proceeding... What you need is the https://github.com/caolan/async library - then you can use the [mapSeries function](https://caolan.github.io/async/docs.html#mapSeries) const async = require('async') async.mapSeries(array, api, (err, result) =&gt; {}) This comment is cool: &gt; I learned that you can compose funcions with reduce that JavaScript treats functions like any other primitive (so you can pass them as values to other functions) is one of the most powerful tools :-) 
In the first example, the code would have worked anyways because javascript auto inserts "var" when it is omitted, unless in strict mode.
If you run the code with reduce you will see the `console.log`s in `api` been run one after the other. 
Here is an example of a form with async validation: https://jsfiddle.net/bzy991yz/2/. I think `Promise.all` is probably what you want to use here.
But I'm assuming that api is async and you want to wait for it?
i.e. it's the same as them all happening at the same time
I don't think I explained well what I meant by "all at the same time" and "one after the other". What I mean is that if you use `Promise.all` and let's say the api downloads something for example, all the downloads will start at the same time, will finish at random, but will start at about the same time. In the examples without `Promise.all` the second download will only start after the first is finished and so on. In all examples I wait for all downloads to finish, but the order of the downloads changes.
Well I have node JS installed to run npm etc
yes. in fact, when you do this var x = 1; my understanding is it turns into this in the JS engine var x; x = 1;
Yeah, part of the etc is a server side JS backend lol. 
It doesn't insert var; it makes an implicit global. This is different because it doesn't make the variable local to the function block (or code block in the case of let/const).
the `this` in your function is the global `window` object, not the `App` variable, so it's putting `.test` on `window`. See [mdn about `this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#Function_context) for more. Or, well, as written (`App = function () { ... }; App.test()`), it's not putting anything on `window` yet because the `App` function isn't being executed. To put it on `App` you could do App = function() { App.test = () =&gt; alert('test'); }; App(); // assigns the test property to App App.test(); but it's a bit odd to mutate App inside itself.
Assuming the teacher gave the OP the current code as boilerplate, then I agree, this is the correct answer. 
If you are a beginner start with Vue
You could write a Node script to connect directly to the database. There are many drivers and ORMs available.
what's the worse case scenario for letting end-users change variables and activate functions? i don't understand the use case here.
Give the form input an arrayed name... Then query based on the arrived name. So... &lt;input name="firstName[]" /&gt; For all your inputs (in this example getting first name) Then you can use document.querySelectorAll('[name="firstName[]"]') Which would return you the array of input fields... Which you can then pass to a foreach loop, pulling the value creating the desired markup. This can have the added benefit that you could pass the form submission through to your server side and have it understand all the values (correct configuration required). But I take it you wanted this for an SPA, which means you probably won't do that, but it is good practice to do if you're talking about producing a table or list of input fields (i.e. to get into the habit of using the name attribute properly as an array). Edit: this would work similarly on selects as well, except instead of doing .value straight off the element, you would do similarly to this: https://stackoverflow.com/questions/1085801/get-selected-value-in-dropdown-list-using-javascript
Because your script runs before the DOM constructed the path object (CodePen injects the script just before the closing &lt;/body&gt; tag) -- yours is currently in the &lt;head&gt;. Put your script just before the closing &lt;/body&gt; and it'll work.
That's a good solution and could very well work the only thing is that : in this context the form is 100% generic and I have no control on the number of &lt;td&gt;s or forms 
The approach would be the same. If you know you want to pull all input fields or selects, use... document.querySelectorAll('input, select') And carry on as suggested.
I have updated the javascript version of the library. Please do checkout. https://github.com/AmanAgarwal041/Toast
That's also true, in fact I think I could very well use that 
Variable names polluting the global namespace. Your scripts probably won't be the only you load on your site - you'll likely load also scripts for ads, processing payments, etc. If their variable names are same as yours, things won't behave as expected.
no need to tell me about it. I recently refactored couple of methods on our API from callback style to async/await and like 1/3 of the code is gone.
You could do this with rxjs using something like flatmap or switchmap depending on your needs. You might not want to bring in another dependency just for this, but if you do use rxjs you can just use a small slice of the library, probably observable, behvaiorsubject, and 2 or 3 operators, and the size shouldn't be too big. If you try to import the entire rxjs library it's pretty chunky though.
How is this different from, say, Surge.sh?
If only one global variable is allowed, go beyond and use no global variables. Use a self executing function and get rid of 'this'.
Other than what has already been mentioned by /u/HattyBetty, the limit is is also a form of security. If there's no limit, any ill behaved script can deplete your harddisk free space. Or at least, consume most of it.
Yea, it synchronously puts all the async events on the event loop. Doesn't mean it waits for each to finish.
Thanks, that makes sense. Basically, the moment I have any action in the submit event that has an asynchronous element to it, then three things need to happen: 1. The default submit must be disabled (preventDefault). 2. All asynchronous actions must be done through a promise. 3. All the promises must be collected together so that when they are all resolved then the form can be programmatically submitted, given all the promises completed with a success. Anything that runs in that form submit MUST hook into those three things, otherwise it is at risk of not being able to complete in time, or may not stop the form submit even if there is (say) a validation failure. I'm assuming the HTML5 validation runs first, and the `on submit` events do not even get fired if the HTML5 rules aren't all met? Playing with your jsfiddle seems to confirm that. Now, if I was creating this as a library that could be thrown into a form and could work with third party code on that form, I guess I would have: 1. A stack for logging the promises. 2. On the first promise added to the stack, set preventDefault then add a last event (it would go at the end - but can I do this, adding another `on submit` event from an `on submit` event?) that will handle the submit. 3. The final event waits for the stack of promises to finish successfully then submits the form. If no promises are thrown onto the stack, then the form just submits as a normal form. Edit: yes, I can add another event to the stack from within an event already running, at least in the fiddle. Edit2: according to the [Event Loop](https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop) model, it probably should not work, as any listener must be attached when the event occurs, otherwise it doesn't get thrown onto the message queue. So I guess rather than attaching a new event listener to the form, I just manually shove a message onto the queue to execute at some point after all the `oncommit` messages have been executed and to do the actual form submit. Any validation that does NOT involve a promise, would also need to flag to the final event in some way that the validation has failed. This is why I wanted to try to avoid programmatic submission of the form if I could, because there are so many things to watch. If someone has written a validation check for another item in the form then it needs to be able to stop that final submit, so needs knowledge about how to hook into my card tokenisation code, which is after all *just another event*. I don't want those validation checks to have to stop all further propagation i order to prevent the submission, because there could be other validation checks that the user could do with seeing the results of. It all seems kludgy in that JS cannot subtly slip into a form submission to do some checks (involving AJAX). Instead, it has to totally take over the whole form submission logic built into the browser, and then all events hooked into that form must cooperate in some shared way to make sure the process works as expected. I guess this is why frameworks exist. ------ I know this may look like I'm over-complicating things here, but I am just trying to understand how all this stuff works. While doing this, I'm discovering that things really are that complicated.
Look closely: the reduce call always builds functions, that have a connection to he previous function. The final function is called, it calls the api and hands over the previous function as callback. So the last function is called first, when the async api finishes, the function calls the previous one as callback, this previous one does the same, this goes on until all functions are called after one another. 
1/3 of lines, not code. It's same code just shorter. 
You can pop out the dev tools from the kebab ("⋮") menu
No need to be pedantic. You know what he meant.
Who is himawari?
Doesn’t work with Observables tho
I watched this [video](https://youtu.be/14hS7f8gyiw) yesterday. Which, I thought, explained it nicely as well. Great article btw!! 
You can do the following: function callbackHell () { const api = new Api() return api.getUser().then((user) =&gt; Promise.all([api.getFriends(user.id), api.getPhoto(user.id)]).then(([friends, photo]) =&gt; console.log('notSoCallbackHell', { user, friends, photo }) ); ); } Does the usage shown of async await do the getFriends &amp; getPhoto calls sequentially or concurrently? I see how the 'await' keyword is useful, but why do we need 'async'?
If you don't want things to be done sequentially, you can also use Promise.all in conjunction with await (and destructuring if it's convenient): let [friends, photo] = await Promise.all([api.getFriends(user.id), api.getPhoto(user.id)]); console.log('notSoCallbackHell', { user, friends, photo }); &gt; I see how the 'await' keyword is useful, but why do we need 'async'? Async/await is built on top of promises. You await the result of a promise and async functions return promises. Await can be only used inside async functions.
I know this is the javascript reddit, but I am a C++ dev by day and have been waiting for coroutines to be able to write very similar code. This is just so cool! I think I need to start writing more js in my spare time. How are the transpilers making this code work on older browsers (babel, et. al.)? That blows my mind even more. *edit* fixed bumbling phone typos...
Babel transforms async/await feature to generators.
Thanks!
How come? I've used async await extensively with rxjs.
Not only are you being pedantic, you're also wrong. What's on those missing lines? If it's not code, I don't know what they refactored away...
If being even more particular, it just makes it a field of global object(which is basically the same)
observables fire a stream of values, async await only works with promises which resolve to a single value
Thanks for the tip. This is very interesting. I was reading the description and it says it helps with this asynchronous business.
I released an open-source, offline-first(PWA), Javascript interpreter playground app. It's written in vanilla JS (no framework) and offers a choice of two code editor interfaces, including Monaco, which is the same editor used by VSCode. Web App - https://code.patricktriest.com/ Source Code - https://github.com/triestpa/OpenJS-Sandbox I would love suggestions and/or collaborators!
I've enjoyed async/await in Dart, which has made me multiple times more productive. Cool to see it in JS. Hopefully I can use it some day without Babel...
python has `async for` which would be a good fit. used on an observable it would just be an infinite loop that has to be broken out of. could look like this async for (const event of observable ) { console.log(event) if (event.last) break /* not part of the protocol, just an property of the objects yielded by the observable */ }
https://youtu.be/ilRnq7BBWGY?t=24m51s it's coming in the next version of ECMAScript, Observables will be included, they are at stage 1 right now 
That day is today... Unless you care about IE, in which case the day is the day you stop caring about IE ;) http://caniuse.com/#feat=async-functions
There is a Stage 3 proposal for async iterators which should work with observables. 
I suggest you use TypeScript instead of Babel, it transpiles to plain javascript (ES5/ES3) with generators and async/await, TS will be more suitable for you, because you have CPP background which is a strongly typed language like TypeScript: https://www.typescriptlang.org/docs/handbook/basic-types.html &gt; How are the transpilers making this code work on older browsers they basically use state machines.
Notice the reduce is building a promise chain, and not directly calling the api function.
&gt; Does the usage shown of async await do the getFriends &amp; getPhoto calls sequentially or concurrently? Sequentially. Every `await` is basically a `.then`. If you want to do them in parallel you use regular promise composition: const [friends, photo] = await Promise.all([api.getFriends(user.id), api.getPhoto(user.id)]); async functions are just sugar over promises (note that they wrap any returned value in a resolved promise, and any exception in a rejected promise). &gt; I see how the 'await' keyword is useful, but why do we need 'async'? To avoid breaking older code, `await` only works in `async` functions: because `await` can be present in contexts were a *variable* called `await` could be present, just asserting that "`await` makes the function async` could break significant amounts of existing code (since it expects to be "fed" promise resolutions and ultimately returns a promise). It also helps the parser/compiler as they can set up whatever machinery they use to transform async functions immediately rather than have to wait until they're midway through the function and go "oh fuck we have to start over in async compilation mode".
Hi /u/waw01, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I want to believe
http://naruto.wikia.com/wiki/Himawari_Uzumaki You're welcome
Thanks for your feedback!
Thanks!
Thanks!
Thanks!
The best projects to contribute to are the ones that you use. If you use the project, you have a vested interest in its continued improvement.
You shouldn't have builds in version control, because they only pollute the history with less useful and redundant information. You can always rebuild old versions from the sources anyway. That doesn't mean the client-facing production server needs to perform any builds though. You could either manually build and deploy the package there after pushing your changes to version control, or have a separate CI server run the builds and deploy the packages elsewhere automatically. Latter is a good idea, because the testing, builds and everything can be done with a clean slate. You ensure everything required for the build to succeed is in the version control, rather than on your machine.
I thought that's what async/await *is*, generators that return promises.
As a react developer who writes JSX all day, I couldn't agree more. I love this approach both as a react developer and a fan of CycleJS
In addition what others have said, one benefit to the 'async' keyword is that you're guaranteed to get a Promise back from the function. No more if statements that sometimes return synchronously and sometimes return a Promise. 
Downright beautiful article! I literally just played with async/await over the weekend as I was messing around with PhantomJS. This couldn't have been more perfect!
Instead of array.concat(result) you could do [result, ...array] to preserve the order.
I meant regenerator runtimes. https://babeljs.io/docs/plugins/transform-runtime/
Async/await support has been around for a while and with TypeScript you can use async/await on ES3/ES5 environments. ES3/ES5 environments include older browsers/NodeJS runtimes (ie: `node-0.12`) that don't support async/await or generators natively. Yes you are correct that async/await is generators+promises, and ES3/ES5 support for async/await is done through non-native promises (of which there are many implementations, including Bluebird) and "artificial generators" (of which there are none that I know of, outside of TypeScript).
TypeScript will also provide async/await support to ES3/ES5 environments (most older browsers), which is good. For the sake of argument, these state machines can simply be called "artificial generators."
Will? It's been doing that for a while already AFAIK: https://blog.mariusschulz.com/2016/12/09/typescript-2-1-async-await-for-es3-es5
Yes, but what about error handling? I don't disagree that async/await is a lot cleaner, but not handling errors can be problematic
I completely agree! Check out the second-half of the post, where error handling is discussed. In short, async/await lets you wrap async operations in normal try/catch blocks, making error handling quite easy and consistent.
Promises and Observables serve different purposes https://github.com/kriskowal/gtor We would need constructs in JS to basically spawn an actor that can await values as they come in, since an observable can be infinite and in single threaded code would never hit the statement after the await.
Thanks, I'm glad it was useful for you!
Yeah I wasn't referring to past-tense, just that it offers this.
Have a look at this link https://github.com/MunGell/awesome-for-beginners . Might help you find some project to contribute to.
While some things are a matter of opinion, claiming pure JS function calls can be more readable then a template is outright silly. Sure, you can write useful helpers that allow for concise syntax, but as soon as you move a few steps away from the simplest `&lt;ul&gt;` example you used to something from a real life app, it can't compare at all. Nest a few child elements 3 or 4 levels deep, throw in a conditional or two and you've got a total mess on your hands. Now, I can agree that for the smallest components it can be good enough if the trade off is getting rid of parsing templates and mentally switching languages, but that's just one specific use case, not enough to generalise on.
`location.host` and `location.replace()` const oldHost = 'clone.abcd.com', newHost = 'www.example.com'; if (location.host == oldHost) { location.replace(location.href.replace(oldHost, newHost)); }
Fantastic article! 
Thank you for replying so quickly. But I have 0 javascript knowledge. Could you please give me full javascript? I would be forever in your debt. Please?
Updated. You'll have to update the `oldHost` and `newHost` variables to the correct values.
Thanks, I'm glad you liked it!
Hi, I don't wants to specify the cloned domains, I wants to redirect if the page wasn't loaded on the correct domain. PS: My website is getting scrapped, so even a visitor redirects to other cloned domains, I wants them redirect to the real domain.
 const realHost = 'www.example.com'; if (location.host != realHost) { location.replace(location.href.replace(location.host, realHost)); } This assumes that the person scraping your site is also scraping and running your JavaScript code. They'll notice very fast that you've caught onto them and will probably stop pulling your JavaScript code directly and will likely host a modified version of your code without this snippet present (if any is even needed).
ah okay, I misunderstood.
I have been using the [following solutions](https://stackoverflow.com/questions/16222759/preventing-site-being-scraped) But it was not redirecting the page, only the domain. PS: the solutions has a little bit of encryption.
I'd hardly call a window variable called "app" polluting the global name space..
&gt; Nest a few child elements 3 or 4 levels deep, throw in a conditional or two and you've got a total mess on your hands. Why? Adding XML doesn't make that structure any "cleaner". You're just adding more angle brackets and close tags and curly braces for code context switches intermixed into the same JS logic. Purely from the perspective of typing I find it a lot more awkward. Anyway I can't prove that hyperscript is better or worse because ultimately it is an opinion of aesthetics.
Maybe you just need to use a patched font?
`.call`, `.apply`, and `.bind` are very useful
Dude needs a proof reader. 
Honestly before the async await node module that made you wrap everything, node was practically unusable. And now with the native async await handlers / es6, I can't imagine wanting any other language. 
+1 for vue. -1 for poorly written article.
As some politicians says - "Think about the cows and end this DST stuff"
Thanks.
This is my exact core problem with `async/await`: async function getUserInfo () { const api = new Api() const user = await api.getUser() const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) return { user, friends, photo } } We've accidentally serialized two asynchronous operations. It should be written: async function getUserInfo () { const api = new Api() const user = await api.getUser() const friends = api.getFriends(user.id) const photo = api.getPhoto(user.id) return { user, await friends, await photo } } **EDIT** As pointed out by /u/VoiceNGO this doesn't work, not because you have to use `Promise.all()`, but because you can't `await` in an object without using a key name. This syntax works: return { user, friends: await friends, photo: await photo } If you wrote it as promises, you can't mistakenly serialize requests without it being obvious, so you get: function getUserInfo () { const api = new Api(); const user = api.getUser(); return Promise.all([user, user.then(u=&gt;api.getFriends(u.id)), user.then(u=&gt;api.getPhoto(u.id)) ]).then(([user, friends, photo])=&gt;({ user, friends, photo })); } And rather than the Promise Error example (still serialized), you can handle errors from all three requests with little effort: function getUserInfo () { const api = new Api(); const user = api.getUser(); return Promise.all([user, user.then(u=&gt;api.getFriends(u.id)), user.then(u=&gt;api.getPhoto(u.id)) ]).then(([user, friends, photo])=&gt;({ user, friends, photo })).catch(err=&gt;console.log(err)); } That catches errors from all three api calls, even if they are synchronous. I'm a fan of Promises because they do something that async/await can't: unify the way you code. They take getting used to, certainly, but they are more powerful. You can accept any synchronous or async function in a chain without knowing if it's async: Promise.resolve(user).then(…).catch(…); This will take a plain value or a promise and pass it on. If the source is a rejected promise, you get a rejected promise. I still feel that `async`/`await` are like `let`. You use them because they are easy. Eventually you'll move to `Promise` and `const` because they are powerful.
Not ES7 – ES8 (ES2017). ES7 has `Array.prototype.includes()` and `**` the exponentiation operator.
We are both partially right: You *can* specify multiple awaits, but you have to put the key name. This syntax works and is not serialized: return { user, friends: await friends, photo: await photo } **EDIT** Here's the code I used to prove this out. Running on NodeJs 8.1.2. function getData() { return new Promise(function(resolve){ setTimeout(function(){ resolve(~~(Math.random() * 1000)); }, 1000); }) } async function getUserInfoOne() { const user = await getData() const friends = await getData(user) const photo = await getData(user) return { user, friends, photo } } async function getUserInfoTwo() { const user = await getData() const friends = getData(user) const photo = getData(user) return { user, friends: await friends, photo: await photo } } function test(){ let start = Date.now(); getUserInfoOne().then(_=&gt;console.log("original", Date.now() - start)); getUserInfoTwo().then(_=&gt;console.log("parallel", Date.now() - start)); } Output: &gt; test() undefined parallel 2007 original 3007
&gt; they basically use state machines. State machine? Are you talking about regenerator or babel? Last time I checked babel was an AST transformation. 
yes? I'm aware?
senocular: Here is an example I wrote after reading your explanation and understand of JS objects so far. Is my modeling good or can be improved? :) function Actor(name, age, oscars) { this.name = name; this.age = age; this.oscars = oscars; } Actor.prototype.hello = function() { console.log("Hello, my name is " + this.name); } Actor.prototype.hasMoreOscarsThan = function(actor) { return this.oscars &gt; actor.oscars; } var leonardo = new Actor('Leonardo DiCaprio', 41, 1); var jennifer = new Actor('Jennifer Lawrence', 25, 1); var samuel = new Actor('Samuel L. Jackson', 67, 0); var meryl = new Actor('Meryl Streep', 66, 3); var john = new Actor('John Cho', 43, 0); Actor.actors = [leonardo, jennifer, samuel, meryl, john]; Actor.getActorByName = function(name) { return this.actors.find(function(actor) { return actor.name === name; }) } Actor.getAverageAge = function() { return this.actors.reduce(function(sum, actor) { return sum + actor.age; }, 0) / this.actors.length } leonardo.hello(); // "Hello, my name is Leonardo DiCaprio" console.log(meryl.hasMoreOscarsThan(john)); // true console.log(Actor.getActorByName('John Cho')); // Actor {name: "John Cho", age: 43, oscars: 0} console.log(Actor.getAverageAge()); // 48.4 
Thanks mate! :)
With Promises we don't need little helper functions to deal with try/catch; it's just there. Promises don't have to check for sync or async, and we don't need an extra keyword *in case*. It's just there. We can refactor all the data requests to return cached results synchronously and not impact our Promise chains at all. We don't need Flow or TypeScript to get Promises right, because we don't have to do the extra mental or programmatic tracking to know if it's a Promise when chaining. Promise chains work like Functional Programming, in that you can write small, compassable bits of code and reason about them well. One of the last tasks at my last job was working on a bit of code that went something like this: Promise.resolve() .then(fetchUserConfig) .catch(getDefaultConfig) .then(fetchPersonalizationData) .then(mergeLocalData) .then(updateOfferZones) .catch(reportErrors) .then(displayOfferZones); // Even if there were errors It doesn't matter which steps are synchronous or async. Each step has a specific, unique function. Each function can be reasoned about separately. Errors are handled at different points without making it hard to follow. At my current employer we have even more substantial request hierarchies. I'm pushing for Functional Programming and Promises to make it maintainable. Fun tidbit: ES2018 will likely include a mode where *catch doesn't catch anything*. [2ality has a good write-up](http://2ality.com/2017/08/optional-catch-binding.html) on when you might use it, though most examples include "You should be doing something with the error."
No, it works outside of a return, too. You have to **make the requests first** and call await after. This allows the requests to start, and you await them later: const prom1 = getData(user), prom2 = getData(user); // Already running asynchronously const data = { one: await prom1, two: await prom2}; If you look at the code in a [Babel REPL](https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Ces2016%2Ces2017&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;experimental=false&amp;loose=false&amp;spec=false&amp;playground=false&amp;code_lz=AQ4QwZwTwOwY2AMwK7wC4EsD2NgHMBTNAVQgICcBJGRLAeRgIAoBKYAbwChRQ4cI0wZGXLAAvOADuYDIMJoAImDRhW3HsD4wBSchgIwAJhHFSZcokpVNhFFup5adABwAWWNFlNhps_JeVVW3J7DWByImRyXHYhEQAaXX0jCES3Dy8AXwdgbJzIWAQUdGxceVIKaloAFUksVg4ckCdBYO9fC0VAtTCWpINjU3krIJFQjT70zyGA62Dxngi0KJi4ikTEPQGIAC4zP03k4zT3Tz2fc2AprJzMoA), you can see the second step makes both calls simultaneously: case 2: user = _context2.sent; friends = getData(user); photo = getData(user); _context2.t0 = user; _context2.next = 8; return friends;
Agreed. It should be considered a best practice. 
I can explain the downvotes for you: People think your comments are smart alec'y and annoying.
Sorry if I missed this, but I find ordering of things to be particularly problematic on larger projects. Developers tend to add new functions, arguments, variable declarations, etc to the end of a block. They should be alphabetical if there is no other logical ordering in place. Reduces the likelihood of merge conflicts. 
Yes we have heard of vue. Thanks xD
Object.keys(roleMembers).map(userId =&gt; roleMembers[userId])
This is pretty good. You're creating instance methods on the Actor prototype which each instance is able to call and use, referencing themselves with the `this` keyword. You're also have some static methods which are being called off of Actor as they should be. However, the problem with this approach is the following: What would happen if you wanted to separate actors by, say, TV actors and Movie actors? Right now, you only have one list of actors in the static actors array. There's no way to have two lists because there is only one Actor class. Your statics actually make more sense if they were their own class, something like... function ActorGroup(actors) { this.actors = actors; } ActorGroup.prototype.getActorByName = function(name) { return this.actors.find(function(actor) { return actor.name === name; }) } ActorGroup.prototype.getAverageAge = function() { return this.actors.reduce(function(sum, actor) { return sum + actor.age; }, 0) / this.actors.length } var myActors = new ActorGroup([leonardo, jennifer, samuel, meryl, john]); // ... And now its possible to have a different ActorGroup to work with This is something you have to be careful of with statics: state. You generally want to avoid it when you can, because many times, you may want to have different versions of that state (e.g. different lists of actors) via instancing rather than being tied to one representation, as would be the case with `Actor.actors`. Most of the time, static members are methods - functions that don't rely on [static] state and just perform some action that may or may not even deal with any instances of that type. 
But have you heard of Reddit? Bonus points for knowing about vue _on_ reddit!
In technical interviews I always stumble on the difference between `.call` and `.apply`.
Thanks! That worked.
It will continue to get easier. Don't be too frustrated when you don't understand something; file it away and circle back later. Everything makes more sense as you gain context, and that can only happen with time and exposure!
process.env.PORT || 8080 is fine
I've never felt an urge to use async/await. I guess it was because of my applications following redux-like patterns having every single asynchronous request as one action triggering another one eventually.
So trying Object.keys(roleMembers).map(userId =&gt; console.log(userId)) Gives no log. 
Correct me if I'm wrong, but doesn't it still run the exact same, you just don't have to write it all, so technically it's still running the same instructions.
&gt; const friends = await api.getFriends(user.id) &gt; const photo = await api.getPhoto(user.id) const [friends, photo] = await Promise.all([api.getFriends(user.id), api.getPhoto(user.id)];
so what if two chrome extensions or libraries want to use window.app and end up overwriting each other?
i supposed chrome extension make it more likely that you will have naming collisions since you don't have control over what extensions are called. my question really, is why do you need private variables in JavaScript, when unlike every other language on Earth: it's compiled by the end user.
Yeah wtf do people in this thread think "code" is?
+1 for contributing to the ones you use. That's how you'll know for sure what features would be helpful. Beyond that, I'd recommend libraries which contain many implementations of similar patterns, that way you can look at other versions to get a feel for it. For instance, there is a React port of the Semantic-UI framework. That would be a good place for a React or Semantic-UI user to contribute to because there are many pieces which are implemented separately (different UI elements) but similarly (same functional component patterns). You can get a good start on filling out any missing component by looking at how the others are implemented.
This is an issue with scope and the way console.log works. Try assigning console.log to a variable, then using that variable in the map - should resolve scoping issues.
[There is a reason JSX is used, and I think it should be kept that way.](http://i.imgur.com/z20utxh.png)
More info, if needed... On site load, I make 2 ajax calls: 1) get category info - with this, create a "category carousel" using Slick JS. 2) get offers... This is handled via a Code Igniter controller. It hits the db, returns a list of offers and uses PHP templates, rendering the html on the back end, then delivering it. So I don't really have Offer objects (in which I would use an Offer class) - I'm just given a chunk of HTML that I spit to the page. Then I run it through Masonry to create a grid. Hope that makes sense...
Yeah, well, that's just, like, your opinion, man.
For context, I just want to use them to create unique variables like strings. Maybe this falls in basic functionality or isn't even a proper use of them?
MDN isn't always accurate in its browser support tables, all the recent browsers support `Symbol()`, the well known symbols like `Symbol.match` and stuff are just symbols you can use to override certain `RegExp` behaviour, e.g. when `'fizz'.match(someRegExpLike)` is called it'll call `someRegExpLike[Symbol.match]` and do some stuff with that. Because you just want them as unique names and not for the RegExp overriding behavior you shouldn't have any issues on any of the current browsers.
Symbol support just means that the Symbol function is defined, and that Symbol-keyed properties are supported and non-enumberable, etc., Well known symbols refers to specific functionality that's implemented with Symbols, like Symbol.iterator. Symbol.iterator is really more of a part of supporting Iterables, than Symbols, though Symbol support is obviously required.
Hey wavebeem, definitely something worth writing about, and really interesting. Thanks for sharing it. Personally for me, It's strange to think about custom web components without think about some form of XML, (which by the way if I heard myself say that 7 years ago I would totally be like, wtf). I think this form looks weird, but so does everything else that i'm not used to. Maybe in my next project i'll try this out and see how I feel!
I've been using async/await in Hack for a while, and it doesn't take long before it becomes obvious that this is bad: const friends = await api.getFriends(user.id) const photo = await api.getPhoto(user.id) Whenever you see two awaits in a function, just think "does the input to the second depend on the output of the first?" If not, parallelize them.
I agree with the direction you are going with this. My preference would be something like the following: * see things on npm like `common-tags` * use ES6 modules that mostly expose classes, except for perhaps something where there really isn't any need or utility for keeping track of different instances and then just expose functions from the module. Its ok to use a class where it feels like it makes more sense though. * you do have some dynamic interaction, but it is simple enough that you can streamline it to be sort of stateless in a way * the correct abstraction at some point may be UI Component (such as React or Web Components etc), but if the flow can be simplified enough to remove complex event and other flow dynamics, they can be mostly straightforward ES6 classes without requiring a lot of the lifecycle complexity of existing frameworks * the way each page and/or component(s) display is specified by a URL. see npm modules like `history` etc. * my preference is that the flow is just provide the data and render the component, with no other event cascading or other complexity if it can be avoided. combined with the stateless definition based on history/URL, this can avoid some plumbing code involved with clicking events etc. * include a minimal abstraction like a data store or maybe just a shared (by front and back end and tests) data injection interface for components for handling data.. don't make it any more complex than you need though * just use JavaScript string template literals and maybe something like `common-tags` to render HTML * lose the dependency on PHP etc. and organize things so that the same code can render on the server as well as the client 
As I demonstrated, if you make variables to store the promises before the `await` calls, you can avoid using `Promises.all()`: async function getUserInfoTwo() { const user = await getData() const friends = getData(user) const photo = getData(user) return { user, friends: await friends, photo: await photo } }
That pretty-looking promise chain isn't going to look anywhere near as pretty the moment you need branching logic - with async/await it's as trivial as synchronous code. And if all of a sudden you need one of those return values further down the chain, that's potentially a lot of function changes, or else an extra declared variable in the outer scope, or a refactoring using nested promises, etc. Plain promises require a paradigm shift in reasoning and a bag of tricks whenever you use them for something significantly non-trivial. Your touted advantages barely offset that at all in my opinion.
Thank you for this. I'll go through this in more detail in a bit. But to clarify, I'm working in part if an existing app and I'm kind of stuck with Code Igniter and routes and controllers are already set up using CI. I need to build a small ui on top of it. I'll post more details in a little bit.
Your formatting is screwed, but this bit here is returning if the mobile phone matches the regex: if (EnteredMPhone.match(MobCheck)) {return (true);} And the next part alerts and returns no matter what: { alert("The mobile phone number you have entered " + EnteredMPhone + " does not have the expected format eg '0417 525 954'."); return false; } 
&gt; `const [friends, photo] = Promise.all([await ..., await ...]);` I think you mean... const [friends, photo] = await Promise.all([..., ...]);
Possible? Yes. Probable? No. The best way to learn as a junior engineer is to work closely with a senior engineer. You can't really do that remotely.
Does this transpile down to something that will run on all modern browsers and ie11?
You should also take a look at AVN too. It works together with NVM to provide automatic version switching based on a .nvmrc or .node-versions file in the folder. https://github.com/wbyoung/avn
Note to people looking at this: careful that you don't get conflated between [async iterables](https://github.com/tc39/proposal-async-iteration) (`for await ...`, stage 3 proposal, single consumer "streams") and [observables](https://github.com/tc39/proposal-observable) (stage 1 proposal, subscription-based, multiple-consumer). Although I believe an async iterable could feed into an observable and vice-versa. Have a look at the [FAQ for the WHATWG streams standard](https://github.com/whatwg/streams/blob/master/FAQ.md#how-do-readable-streams-relate-to-observables-or-eventtarget) and/or watch that video from about halfway for a little more info on the differences.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [whatwg/streams/.../**FAQ.md#how-do-readable-streams-relate-to-observables-or-eventtarget** (master → 406ed76)](https://github.com/whatwg/streams/blob/406ed766a8969cd8e2fb3a7e709d59a2f601b5e0/FAQ.md#how-do-readable-streams-relate-to-observables-or-eventtarget) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dll62cu.)^.
With Babel, yes. You can [try it out live](https://babeljs.io/repl/).
Do all your date/time calculations in GMT/UTC (or just use raw Epoch seconds) and only ever convert to local time for display purposes.
Side note, first letter of variables should be lower case. You should stick to camel case. 
One of the few articles that gives credit to .NET/C# for the actual syntax and keywords. Most people don't know how much modern JS has borrowed from them.
Will do thank you! 
So how do I get for that entered M phone part to alert if it doesn't follow the rule instead of alerting no matter what? 
Hey. Thanks again for the help. This gave me a bunch to look into, but I'm still kind of hitting a wall. The issue is really that I'm working with a PHP based framework with all routes, controllers, etc already set up. Routes hit a controller, gets some data, feeds the data into a view (php template), loops through some data and spits out rendered html. I can't use history since the back end is using url routing. And I'm not really sure if it makes sense to use common-tags, web components, etc, since I'm getting fully rendered html from the back end. Note: maybe I don't know what I'm talking about and my whole approach is wrong. That's definitely a possibility :) Per your comment - "my preference is that the flow is just provide the data and render the component" Though I would love better model/view binding. It's weird the way it's set up - even ajax calls return html and I just replace div content to update ui. I don't like it one bit and would love find a better way to do this. I think I need to look into how other people are doing front-end stuff with Code Igniter. ----- 1 Question... "you do have some dynamic interaction, but it is simple enough that you can streamline it to be sort of stateless in a way" I'm not really sure what you're going with here. Can you explain? I never really grasped 'state' like I should.
Nice link.
I have some simple branching logic in there: .then(fetchUserConfig) .catch(getDefaultConfig) I know not everything is as simple as that, though that became the core program control logic after cleaning up ~1000 lines of nearly unmaintainable code. Even the example I provided before – based on the article – saves off the `user` Promise and then adds two separate chains onto it, re-accumulating all three into a `Promise.all()`. I certainly agree not everything is as simple as that. I've helped another developer write a polling interface for a long-running job that uses a nested promise chain and has to support six separate failure conditions: 1. Initial request failure 2. Single polling request failure (recoverable) 3. Repeated polling request failure (non-recoverable) 4. Timeout error. 5. Job failure (successful response with an error state of the job) 6. Error logging error (sounds dumb, but the API needs to log the errors). That logic isn't easy to reason about no matter the mechanism, but using Promises helped us break it down into a series of smaller, more maintainable pieces... requestJob() .then(pollForJob.bind(null, 20000, 1)) .then(rejectJobFailure) .then(reportJobSuccess) .catch(logJobError) .catch(handleReportingError); The `pollForJob` function hides a lot of complexity, but that's sort of the point. It uses partial application accept configuration of timeout and polling errors (20000 ms and 1 consecutive failure allowed). I don't have to reason about the internals of the polling logic when I'm writing the outside control logic. Nested promises are needed less often than people think. Most of the async/await articles I see have a naive view of Promises as essentially equivalent to callback hell. The examples look complicated because they're made almost entirely out of anonymous functions. That's terrible coding practice, though. If you're just going to pile up anonymous functions, or create a 200-line function with a half-dozen `async`/`await` calls in it, you're still writing a monolith. Name your functions and suddenly Promises make a lot more sense.
Stateless as in just render the data into the template string as opposed to being subject to a complex lifecycle like a React component. https://facebook.github.io/react/docs/state-and-lifecycle.html
(I split this into two comments, because I write too much.) Async/await is *not* as trivial as synchronous code. It *looks like it is*, but it's a leaky abstraction. **It breaks the fundamental understanding of being able to substitute a function call for a variable.** You have to save the functions to variables before you `await` them if you want parallelism. There's no indication in reading the code that you get parallelism out of that, either… you *just have to know it*. With `async`/`await`, these two are *not the same*: // Serial requests const c = {one: await getData(1), two: await getData(2)}; // Parallel requests const a = getData(1); const b = getData(2); const c = {one: await a, two: await b}; Nothing else in JavaScript has this particular behavior, nor any of my previous experience with C-style languages. Admittedly, I stopped working in C# in 2012, just before the `await` spec was added. I lived through "callback hell", and `async`/`await` is better than that, but not much. I know Promises have a learning curve, but pretending that `async`/`await` *doesn't* is wrong. They *are* Promises and have their own unique set of headaches *on top* of Promises. That's the gist of pretty much my entire discussion, here... there is an additional mental overhead exclusive to this new syntax. It is so easy to misunderstand that the article gets it wrong. The article got it wrong. I tried to correct the article and got it wrong. Someone tried to correct me, and got it wrong. **Four tries** to write a proper parallel call with just `async`/`await`. Thank goodness we aren't under a deadline.
See also http://redux.js.org but what I am saying is you probably want to skip all of that and keep it simple with just one render and done if possible.
That helps a lot. I get what you mean "just one tender and done". That makes sense and definitely simplifies things. I guess need to look into how to do it using routes. 
That video perpetuates/falls victim to a very common and very frustrating misunderstanding of Promises. He wraps a function which returns a Promise a `try`/`catch` block. You know... in case it errors. But it's a Promise. It will **reject**. We can handle both the failure of the initial function *and* the parser with a single `.catch()`: fetch() .then(JSON.parse) .then(doSomething) .catch(err=&gt;console.log(err)); Is this `await` code really less complicated? try { let data = await fetch(); let result = JSON.parse(data); doSomething(result); } catch (err) { console.log(err); } Or, if you want to strip out the extra variables, I think it quickly becomes much less readable: try { doSomething(JSON.parse(await fetch())); } catch (err) { console.log(err); } 
The old MDN design was beautiful. Idk why they felt a need to change it to this abomination.
You need an 'else' to define "this is the behavior i want when the conditional in the above if statement is false". Without the else, it's just code that will always execute after the resolution of the if statement. else{ alert("The mobile phone number you have entered " + EnteredMPhone + " does not have the expected format eg '0417 525 954'."); return false; }
Thank you, I have fixed it now
My first real web app had a really hard to find 'off by 1' bug. Didn't happen all the time, but I had a bunch of users and this bug was a big problem. In the end, what I had to to is change my loop from for (var i = 0.... to for (var somethingElse = 0... It was one of those 3rd party share button things. Usually their code ran first and the bug didn't matter, but if the user started doing stuff right away I had a problem. I've done a lot of dumb stuff in my career, but setting a global variable named 'i' might have been the dumbest so far.
Thanks a lot, guys! 
Why would you need async/await if you're using Observables? Stream libraries have `fromPromise` built in, so you already get the same functionality as async/await.
I'm not saying async/await doesn't have its own quirks/pitfalls to know how to deal with, or that you don't need to have a somewhat decent understanding of promises to know how to use it correctly. But after having used both and weighing up the tradeoffs on each side I find async/await vastly more palatable to write and reason about on average - in my mind (and many others) there is no contest. The extra work you need to pour in to make nice-looking promise chains out of complex use-cases, and the pain of changing things when requirements change just isn't worth it to me. &gt; there is an additional mental overhead exclusive to this new syntax In my opinion, any "additional" mental overhead is easily offset by being free to forget the promise-syntax-specific "bag of tricks" which I mentioned before, and the syntactical simplification. Additionally, the two syntaxes aren't even mutually exclusive - if there's logic that vastly favors promise syntax, you're free to use it within your async/await code. You might point to mixing syntaxes as evidence of a leaky abstraction, and maybe it is to some degree, but I'd just view it as being pragmatic. &gt; You have to save the functions to variables before you await them if you want parallelism. There's no indication in reading the code that you get parallelism out of that, either… you just have to know it. Destructing `await Promise.all([...])` removes the need for intermediate variables and makes it obvious that things are being done concurrently. If there's a case where I do need promise-holding variables, I always name them with the suffix `Promise` so there's no confusion. &gt; Four tries to write a proper parallel call with just async/await. I see your point about it not being so intuitive at first glance, but I see it as a relatively minor pitfall where how to deal with it will quickly become common knowledge (assuming it isn't already). It also seems like the type of thing a linter could easily warn about. &gt; // Serial requests const c = {one: await getData(1), two: await getData(2)}; Similar here. Just thinking about it logically, `await` synchronously (within the function context) waits for the result of a promise, so it shouldn't come as a surprise any more than a slow synchronous function would, or hypothetically (for the sake of syntax similarity), a particularly unoptimized `typeof` operator.
In the end it's only the very first point that will matter, people can work in a team, with webstorm and do refactoring without types.
Thanks.
Typescript will make your life more difficult, but not because of node modules. You can get typings for all the popular libraries, and writing your own for some small library you use isn't very difficult. The real problem with TS is the endless configuration that's needed. It's almost impossible to get it working with no false positives and no false negatives. For example, if you import a single function from Lodash, TS will think you have the whole of Lodash in scope. If you want a preview of some of the worst pain Typescript has to offer, try using immutable.js records with TS.
Your question is lacking context. Is this for a personal project? Agency work? Enterprise scale SaaS product? Are you considering Flow as well?
That would work for runtime caching, althought is not the recommened way. For static assets, it depends on the service worker which gets activated after a reload. So no, the user must perform a hard reload. A way to cope with that, is to show the user a notification, just as I do http://imgur.com/a/M9h3e. I'll post about this soon! Another cool strategy is described in this post: https://zach.codes/handling-client-side-app-updates-with-service-workers/
Almost every project can use better documentation, and nobody wants to write documentation, so if you want to get your hands dirty, that's a great approach to jumping in. You'll learn a lot, and people will love you for it.
I'm a really big fan of the no-nonsense styling. Makes the "page" loads blazing fast. Nice work!
I never understood the desire to merge these modern js frameworks into mvc, when you should probably just make your life so much easier by having separate projects (js frontend and backend .net API). Having separate solutions also helps future proof your project if you want to add mobile or desktop apps.
I totally get your point. Usually I have separate projects but sometimes doing it the MVC way might be faster for some people and maybe you have small parts of your website (e.g admin and website) which you want to be as separate "Views". In the end it's up to you to chose the stack. This is just one option do it which can be a little faster than doing API + SPA and maybe more suited for smaller projects.
Once you learn to properly use TypeScript, your life will be a 100x easier. Strict typing gives JavaScript a whole new dimension for easily creating more complex logic without sacrificing maintainability. It prevents you from making mistakes. Even as an experienced developer, the amount of bugs caused by incorrect typing is bigger than you might think. Especially for big and long-running projects TypeScript is a must, as your code base will be generally more stable to work with and expand upon. And when working with others it is amazing. For example, when you want to use a function written by some one else in your team, you shouldn't have to look at the implementation to know what the arguments should be. Sure this can be done with JSdocs, but having this as a (required) language feature will save you from having to maintain those comments. TypeScript will also warn you when refactoring code breaks other parts of the application which might be even unnoticed otherwise. As for npm module typings, these can be easily installed using i.e. "npm install @types/some-module" which makes it completely hassle-free to work with. I've been using TypeScript for almost two years now, even for small personal projects, and I'll never go back. TL;DR: TypeScript is awesome and it's definitely worth learning it. 
And some advise: - Use the "strict" option from the beginning - VSCode is a great free light-weight IDE by Microsoft with amazing native TypeScript support. You should use it! - TypeScript is not a magical tool to turn messy monoliths into clean code. You still have to learn how to write proper modular code. 
&gt; create unique variables like strings Not sure what you mean by "like strings". Symbol values are inherently unique at creation while string values are not.
+1. Having something to reference means you're not in the dark in the whole process. Don't forget to join the community of the repository you're contributing to, their support is invaluable! 
There goes my hope of ever wanting to make a game with UnityScript.
Is the only reason why I should start using Async/Await because my code will look simpler.
&gt; This is just so cool! I think I need to start writing more js in my spare time. How are the transpilers making this code work on older browsers (babel, et. al.)? That blows my mind even more. If that interests you, [Eric Lippert has a series on how that works in C#](https://blogs.msdn.microsoft.com/ericlippert/tag/async/) (start at the bottom of page 2 for the full background) where async/await is a static (compile-time) transformation to a big state machine. It's an msdn blog so the code blocks are painfully garbage, but that aside it's great insight and applicable to most every language.
Could trivially be linted for too, it's pretty basic dependency analysis.
&gt; And then on the Mozilla page at the bottom of here, its just a bunch of ? ? ? ? ? ? ? ? ? for something like Android: It just means MDN has no information on the subject (nobody tested, or bothered filling it in).
Doing this is precisely how I ran into the above behavior- I wanted to enumerate all the days of a month for a calendar, and my enumeration included two November 5ths. 
&gt; Symbol values are inherently unique at creation while string values are not. That's not quite true, you can load symbols from a central registry via `Symbol.for(key)`, in that case symbols from the same key are identical.
&gt; Symbol-keyed properties are [...] non-enumberable, etc., That's a misconception. Symbol-keyed properties are in fact enumerable (by default) same as most other, rather a number of constructs *specifically skip* symbol-keyed properties (or more commonly non-string-keyed properties), non exhaustively: * `Object.keys`, `Object.entries`, `Object.values` and `JSON.stringify` are specified in terms of the [EnumerableOwnProperties](https://tc39.github.io/ecma262/#sec-enumerableownproperties) abstract operation which skips all non-string-keyed properties (4.a) * `for…of` is specified in terms of the [EnumerateObjectProperties](https://tc39.github.io/ecma262/#sec-enumerate-object-properties) abstract operation which specifically skips symbol-keyed properties ("Returned property keys do not include keys that are Symbols.", also visible in the pseudocoded version at the bottom of the section, line 4) However e.g. `Object.assign` will (properly) copy symbol-keyed properties, and if you check the descriptor of symbol-keyed properties they are defined as enumerable.
[Bluebird's Promise.map has a {concurrency: N} option](http://bluebirdjs.com/docs/api/promise.map.html)
Wasn't it like super old/weird flavour anyway? 
How learning something new could make your life more difficult? You'd have more problems trying to use typescript without learning it, so...
Like a lot of things you read about on reddit, Typescript is a Microsoft spin off to help them protect their assets by claiming you can't live without it and, because Microsoft said it, redditors bite it hook, line and sinker. Eventually these kids whine and cry enough that those who know better eventually give in and it gets weaseled in to projects where you can't get rid of it cause it sticks around forever. Just like you'll find Windows used in medical equipment and other critical systems where Microsoft products have no business existing. Don't follow reddit for hacky, trendy, fluff things trumped up by people whose only reason for having a computer at all is to play games. Eventually all their toys disappear, and so do they.
Thanks! Yeah it took a while to slim everything down so it loads fast, but it's getting there :)
President-bot is adding 1 bot$ each time someone mention his name. It's currently 2959 bot$ in the jar.
yes, everyone just uses C#
Yes, it doesn't have first-class functions. Calling it JavaScript was pure marketing in the first place.
I don't think I'll ever want to work with Unity at all after this. C# is just way too different from JS. Hopefully more decent js game engines pop up over time.
I love JavaScript but even with 10+ years of writing JS i quickly moved to c# for unity. UnityScript lacks some of the features that make modern JS great. This is for the best.
Yeah, this is definitely the way to go. Might suck for some, but this should streamline development for the platform.
as in the async/await in es3 are implemented as state machines.
Maybe, but for desktop/mobile platforms only. Frontend developers who familiar with JS will think twice before doing something with Unity WebGL. It's quite possible they start looking for some "pure" javascript solutions like B4W, Three.js etc
Yep but it worked! Some webdev guys on the Unity blog say that they have switched to Unity over Unreal only because of JS.
And maybe that's the right solution for them.
but but but blueprints???
While not very close to JS, you could program in Python (Look up IronPython)
To be clear, Unity never had support for JavaScript. They had support for UnityScript, which is a *very* different beast. It had different syntax, different semantics, and different functionality. It was more akin to ActionScript or Dart than Javascript; a statically typed, vaguely ECMAscript inspired language designed to run on the CLR. Knowing JS was not really an advantage when trying to use UnityScript.
Wow, what a crock. JavaScript without first-class functions is like a car without a windshield.
This one is BS: &gt; Do you work on a team? Plenty of work happens in team with dynamic languages. &gt; Do you spend a lot of your development time bugfixing/refactoring existing code? This is actually a reason not to go to typescript. The false sens of security given by types leads to reduces unit test coverage which leads to long debug sessions But finally these are valid: &gt; Do you like working with other typed languages? &gt; Do you prefer feature heavy IDEs over simple text editors? Some people are predisposed to like types. And IDE's can certainly add more bells and whistles. 
https://github.com/Unibeautify/parse-framework/tree/tests The project is framework of parsers. Actually the parser **is** the framework and the language specific rules (the lexer) is separated out. **Cool things about the project** * Read about the performance of the JavaScript lexer in the FAQ on the readme near the bottom. It seems this is now tied with Esprima for being the fastest JavaScript parser written in JavaScript. * Since the application is a framework with a uniform output that is both environment agnostic and agnostic to the language analyzed the application can endlessly scale to support any number of languages. * The framework supports seamless recursive lexer switching, which makes writing parsers for something like JSX a breeze. **Where I need help** * I need a lot of help generating and validating unit test samples. The test runner is already written and works well. I just need additional test samples populated into the respective directories and to qualify that the samples are valid tests. There is not an easy way to do this. I will be writing documentation later today for each of the current lexers to provide the necessary guidance. * Any help with documentation is critical. If the documentation, that is written so far, could use some improvement or clarity please open a pull request or issue. This is your chance to become an early contributor on what may be the most extensible and fastest mainstream parser written in JavaScript. Get in early and become an open source superstar.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Unibeautify/parse-framework/.../**da463ba784b7a5b84dec04d992944735d6df4f99** (tests → da463ba)](https://github.com/Unibeautify/parse-framework/tree/da463ba784b7a5b84dec04d992944735d6df4f99) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dllo687.)^.
How does one do that? Google gives me some Github links and therein lies another chapter of my confusion.
there are already plenty http://noeticforce.com/best-3d-javascript-game-engines-frameworks-webgl-html5
I am not trying to use typescrit but. Recently wanted to learn asnyc/await in js and there were couple of tutorials with typescript which made it seem like important to know typescript.
Nope. Have no need for it. We can code in Javascript just fine.
Shouldn't WebAssembly supersede JavaScript in that regards anyway?
yes! Now let my write my front end with c# or a similar full fledged language !
&gt; it allows you to use code without having to lookup the source - which is something you do a lot more of when you are on a team. If you dont code your review your teams source, you have a gap. And if you need an IDE to know how it works, you have a crutch. Somehow the people who use python, lua, JS, and other languages dont seem to have a problem working on teams. &gt; I have to disagree with that one Its common to see this explanation given when a static typing advocate tries to explain why it is beneficial. Actual experience with programming dismisses that notion. You have to write the exact same amount of unit and integration test logic, and the unit tests check anything that static typing would and more. Pure functions with no side effects and no types allow you to construct more general purpose code with fewer bug opportunities. In the end, OOP + static typing is overhead cost that you never recover; its premature optimization. There may still be individual preferences and habits that lead people back to it, but those with an open mind dont feel the need to ossify their logic to specific datatypes any earlier than than optimization passes. For a simple example, would you make list logic which only works for integers? In C++ you resort to templates to avoid specifying types prematurely. 
I've been using Three.js for a long time and I've always had a hard time justifying any move to Unity. I know there's some benefits but I still thought the bare bones library Three.js gives for creating objects, vectors, scenes, lights, etc. was hard to beat, especially since it's written in a language I know well, and open source so when I want to expand it for personal purposes or figure out how it does something, I just have to go reading through the source code. And free! Yay!
I've been facing a similar problem recently when I volunteered to help on a big Angular project. I think the three most important things to understand (on the front end at least) are the project dependencies, the component structure, and the data services. Getting really familiar with the UI also helps. 
Not to mention that Unity's export is massive compared to three.js which gzips down to around 100K.
Regenerator is implemented as a state machine. Babel uses Regenerator as a library to polyfill generator functions which async await are built on top of. I know I'm splitting hairs at this point but answering "How are the transpilers making this code work on older browsers" with a state machine is really an over simplification of how the process works. 
like the java in javascript ;)
Thank god, their "JavaScript" was a weird abomination that wasn't clearly documented and specific only to Unity.
Isn't IronPython an abandoned project?
http://bridge.net/
I'm a huge fan and lover of JavaScript. I write in it every day... but unity's JavaScript was trash. 
&gt; The false sens of security given by types leads to reduces unit test coverage which leads to long debug sessions What's false about it? If you use the wrong type, if you leave off a required property, if you don't define/declare a variable, etc. it will tell you and your code wont transpile.
It will also transpile with plenty of logical bugs. There is no substitute for unit testing. Type errors account for 1%-2% of all possible bugs. Unfortunately, the overhead of adding static types in much higher than 2%, so its not a good investment of programmer time.
You mean ECMAscript? JavaScript was what it was called when still subjugated by the browser. 
It's maintained as an open source project
It means making sure things are written well enough that you dont have to.
No. WebAssembly is just a project to add another language to the browser. It's not going to remove JavaScript, or its massive user bases and community. 
&gt; Type errors account for 1%-2% of all possible bugs. Citation?
Isn't React's PropType stripped from production builds anyway? Removing it to reduce the bundle size doesn't really make sense.
Typescript certainly isn't required or even really recommended learning for fledgling devs, but here's are some clues TS will be helpful: * You want better compile-time error checking so you don't have to debug as much in runtime (e.g. typos, scoping errors, wrong parameters, strict null checks) * You want to use async/await and/or ES6 features that aren't natively supported in your environment (other supersets/platforms offer this as well) * Your application has grown/is scoped to grow too big for you to remember all the various pieces of it, for example what parameters go with what functions or what object properties are required, optional, etc... * Your company is pretending they are agile and you may need to do a lot of refactoring (TS refactoring is a breeze compared to traditional JS) * You've used strongly typed languages like Java/C# and miss their explicit or object-oriented nature when coding JS Like any language you'll hear some people hate it and others love it. Why not *try* TS and see what you think? If you are proficient in JavaScript it'll take you all of a day or so to learn TS and get an app up and running. Then you should pretty quickly get a feel for whether or not this is what your app(s) need.
Why would it make it harder for you to use node modules?
lol, that's cute.
It's a big "only reason". It makes your code look much more synchronous and easy to read. As far as raw capability, though, you could stick to callbacks forever if it suits you, or promises. As the example shows, writing async loops and handling errors is especially much simpler. Having been through all three in a big app, I definitely prefer async/await. It's a big win. The only counter argument is native support isn't there everywhere, but both babel and typescript will downlevel compile today.
Except JavaScript wasn't used in Unity in the first place. They developed their own JS-like language called UnityScript, designed to work with the CLR (same as C#).
Are... um... all present life forms assimilated?
Agreed. UnityScript has all of the worst features of JavaScript with none of the powerful ones: first-class functions, closures, and prototypes made the ugliness of old-school JS bearable and worth it. UnityScript has none of these - it's *only* the ugly parts of JS. Now that JavaScript has removed a bunch of cruft, even syntactically UnityScript has nothing at all to do with JavaScript. There is no good reason to keep it around. C# is an excellent language, UnityScript was a poor wrapper over the top of it. 
UnityScript is/was also way different from JS.
If it makes you feel any better, UnityScript wasn't even close to what you or I probably think of as JavaScript. It's based on Microsoft's [JScript .NET](https://en.wikipedia.org/wiki/JScript_.NET) which is based on [JScript](https://en.wikipedia.org/wiki/JScript) (which is why supporting IE8 is such a clusterfuck fyi). Basically take Microsoft's take on ES3 (ie a steaming pile of shit), then shove in a bunch of extra shit so it can pretend to be C#, then add on whatever you need to make it work in Unity. That's what UnityScript is. Highlights: * Semicolons are required, but not always * Variable assignment works differently * C# style classes * `this` works differently, and implicitly * No first class functions [Here's](http://wiki.unity3d.com/index.php/UnityScript_versus_JavaScript) Unity's wiki page on the differences.
&gt; The real problem with TS is the endless configuration that's needed. Didn't have this issue. Pointed it at the files I wanted compiled, tweaked a few options, done. &gt; It's almost impossible to get it working with no false positives and no false negatives. That's what `any` is for. The goal isn't to avoid `any` no matter the cost, it's to balance type safety with clean code. &gt; If you want a preview of some of the worst pain Typescript has to offer, try using immutable.js records with TS. What's the problem?
I don't know. It seemed to me like it would . Since the code will have to go from typescript -&gt; vanila javascript -&gt; webpack for using modules.
That actually does make me feel better. Almost sounds like it should have been deprecated long ago. 
As many people said before, this is fine since that JavaScript implementation was madness. I use Unity with C# in my personal projects, even though I work as a JavaScript developer.
To be more specific UnityScript is based on JScript .NET, which is Microsoft's JScript (IE8 anyone?) with a bunch of C#-like features thrown in. It was never updated past ES3.
http://tratt.net/laurie/research/pubs/html/tratt__dynamically_typed_languages/ here is a starting point. sorry i dont remember hte exact link to the statistic, but its out there
&gt; This aproach is not bad, but sometimes the array is too large and it is better to make the calls in sequence instead of all at the same time. Sometimes we just need to do the async calls in order. If you're doing things in sequence just use a `for` loop! function api(element, callback) { console.log(`start: ${element}`); setTimeout(() =&gt; callback(element * 100), element * 100); } async function doTheThing() { const array = [1, 2, 3, 4, 5, 6]; const results = []; for (const element of array) { results.push(await new Promise(resolve =&gt; api(element, resolve))); } // Do something with results... } Much easier to read than some mess of reduce calls or some third-party library.
[removed]
Or maybe Unity would have been the best solution, but now will be no longer available. E: Why is everyone involved with coding such contrarian man-children? Does it make you feel good about yourself to sarcastically dismiss everything, pretending like you knew all along or had some enlightened opinion? 
No, we wont do that. 
&gt; OOP + static typing is overhead cost that you never recover Why do you bring up OOP? That's tangential to the discussion. You can write as much TS code as you want without ever creating a single class. Are you familiar with `interface` in TS and structural typing? In your "pure functions with no side effects", your parameters will always have an implicit shape; there's no getting around it. With TS, you can specify it and let the editor help you catch small mistakes more quickly. It can **reduce** overhead in this manner. &gt; For a simple example, would you make list logic which only works for integers? In C++ you resort to templates to avoid specifying types prematurely. TS has [generics](https://www.typescriptlang.org/docs/handbook/generics.html), though, for this exact situation. Additionally, I don't think TS is necessary for every project. That doesn't mean it doesn't have its upsides, though.
&gt; Knowing JS was not really an advantage when trying to use UnityScript. It was definitely a disadvantage. 
&gt; without having to constantly bother my coworkers? Actually bothering your coworkers is often the most effective technique in such cased. One question to coworker and their answer can save hours or days of reading unfamiliar code. 
remember when Array#contains was renamed to Array#includes because some banks ran super old versions of MooTools
ECMAscript was the standard long before Node became a thing. We still call it JavaScript now, just like we called it JavaScript then. 
`async/await` really make things easy. Thanks for the tip.
This is the correct answer. I love ES6 and beyond, but UnityScript wasn't even close to it. Heck, I don't think I'd even build a game in JS if I could avoid it. There would have to be a lot more tooling before it was viable. C# is definitely the right choice moving forward. 
Shame, it's probably an interesting statistic. The paper is an interesting read, if a little dated. I noted his bit about type errors being "trivial", but also noted he cites himself on that point and doesn't really elaborate, so it's not a very compelling point. Another major issue is this paper is entirely ignorant of supersets like TS, citing examples like paper standards and not being able to make dynamic tweaks to debug, both of which TS solves nicely. I agree, unit tests are a better option than types if you can afford them, but I think had supersets like TS been around when that paper was written it would be a very different paper. He even sort of predicts it at the end: &gt; The cross-fertilisation of ideas between statically and dynamically typed languages will continue, with language features such as compile-time meta-programming crossing both ways across the divide. 
It's marketing all the way down: "JavaScript started out as Mocha, then became LiveScript and then became JavaScript when Netscape and Sun got together" https://stackoverflow.com/questions/2018731/why-is-javascript-called-javascript-since-it-has-nothing-to-do-with-java
&gt; It was never updated past ES3. Christ.
Ah, thanks for the clarification!
&gt; Another major issue is this paper is entirely ignorant of supersets like TS, citing examples like paper standards and not being able to make dynamic tweaks to debug, both of which TS solves nicely. I like that typing is optional in TS, which is already worlds better than mandatory static typing. I even see a crucial place for it: when optimizing a core funciton or cryptographic primitive and you want to hyper-specialize the code to exact datatype primitives. Being a transpiled language however, it cannot really deliver this. That said, most of the typescript I end up working with is just Java 2.0, with tons of OOP, needless class hierarchies that never capture the real world object model for long, the joy of constant refactoring for no good reason, over specified function argument types, spaghettificaiton b/c derived classes have knowledge of ancestors, and the increasing difficulty of development without a slow heavyweight IDE bogging everything down. JS freed me from all the above nonsense and made programming fun again. I still love to get down with c/c++ for hyper speed performance, but pounding out rapid prototypes for money is just more fun without the static types, and OOP overhead doesnt have any value afaict. 
There's a great saying there: Java is to JavaScript like ham is to hamster.
Which is why I stipulated "at creation". Retrieving the same symbol multiple times will naturally return identical values each time. But that doesn't change the fact that it was unique when it was created.
As I understand it it WA works together with JS, can be imported into JS and also runs in the same VM. So for me it makes sense to use WA in the future for such a task instead of JS
It's also doing &amp; including a lot more. Not that it can't be optimized or improved. It provides way more functionality for you than ThreeJS does.
That… makes no sense. Strings have value semantics in JS so by that account every string is also "inherently unique at creation".
Seems you're having trouble linking an external CSS style sheet to an HTML document. Put this in the header (between `&lt;head&gt;` and `&lt;/head&gt;`): `&lt;link href="path/to/YourCSSFile.css" rel="stylesheet"&gt;` The `path/to` bit should be the actual relative path from your HTML file to the CSS file. So for instance, if you have your website in a folder, and your CSS files in a folder inside that first folder, it'd read: `&lt;link href="css/YourCSSFile.css" rel="stylesheet"&gt;` The javascript should function fine without the CSS, however without the CSS styles that the JS is manipulating, you'd see the JS seem to "not work". 
I'm personally intrigued, so I may pick at it a little later this evening.
How does a barebones 3d renderer even compare with a fat, IDE driven game platform?
Yeah that's the big question: is the overhead worth it or not? I've yet to see a well-written piece that discusses TypeScript explicitly. Mostly blogs who copied and pasted the talking points off typescriptlang.org.
Just from looking at the comments... The first part: https://github.com/polygonplanet/lzjs Second part: Try contacting https://github.com/x052
So if you have already created a string value once, you can't create it again in the same program? Wasn't aware of that.
Jesus, I already had the css file linked, but I just realized I had my include('header.php'); commented out the entire time I was trying to troubleshoot this. #facepalm
As someone who loves JavaScript, I agree. It wasn't JavaScript, and calling it JavaScript just made things confusing.
Are you wilfully astoundingly dishonest or do you somehow misunderstand what `Symbol.for` does?
Doesn't even have closures, which I think is one of the most iconic features of JavaScript.
In recent releases it's been removed entirely and put into a separate module. But I think the proptypes definitions still end up in your production bundle in older versions.
It happens to all of us.
`Symbol.for` reads from the same location in memory every time you call it with the same key. I knew that strings have value semantics, but I was unaware that the `String` constructor does the same.
I would like this, but when the user clicks on an image it calls a function to handle the loading and pre-loading stuff for that image, unless it's already in the SessionStorage. How can I know if the image data is already cached by the browser?
Implementations can do any interning they want on strings, but that's besides the point, which is that you can't make a difference between "different" identically valued strings from within the language, likewise Symbols, and thus you're making a distinction without a difference.
Has anyone used Preact/Inferno before? What has your experience been like?
When I tried Unityscript I found it to be different enough from javascript that it was a turnoff. Maybe one day they'll implement javascript and when that happens I'll take another look. 
Because skinny &gt; fat. And also I'm sick of people mutating Unity into anything that requires a bit of 3D.
Sorry but what is the tcp emitter is about ?
That isn't the point at all. The point is that `Symbol()` creates a unique value every time it is called. Nothing about strings does something similar. And bringing some unrelated function that has nothing to do with what I wrote into the mix doesn't change that, no matter how badly you want it to.
Just out of curiosity, have you evaluated react? I spent years in both ember and angular. The move to react was the most productive move I've made in my career.