Depends if you like post backs every time someone interacts with your web app. if you say "use ajax" or "hidden divs" then that is exactly it. You can build responsive apps using angular or other MVC frameworks which can save a lot of time. For example you have a simple todo web app and you want to add a todo. You could either click "add" and do a postback to show the "add" form or do it in JS/Jquery ajax anyway and have your backend render the view. if you don't do ajax then you could make a hidden div for that right? this is where angular and other MVC frameworks come into play. what if you have 10-20 of those hidden div's for adding todos, editing them etc??? if you do it in plain js or jquery it would take more code and more time than using something like angularJS. Also the web app can work offline. 
This sounds like a good time to use something like MongoDB. You would store the data as in your JSON example inside a collection. Super fast to access, and each item can have its own unique attributes.
Aw, snap.
What is the browser LCD? If your environment supports ES5, look up `Object.__defineGetter__` and `Object.__defineSetter__` You could do something like var _a; myObj.__defineSetter__("a", function(val) { _a = val; callback(); // defined elsewhere }); Then you could just do myObj.a = "whatever"; And your callback would be called.
Nice, though it's not Conway's Game of Life anymore if you modify the rules.
Yeah thats exactly what i would've suggested, in fact thats what ive done in my latest application, see the following code: transformSupport : function () { var s = document.createElement('p').style; return ('transition' in s || 'webkitTransition' in s || 'MozTransition' in s || 'msTransition' in s) }(), transformKey : function () { var s = document.createElement('p').style; if ('WebkitTransition' in s) { return '-webkit' } else if ('MozTransition' in s) { return '-moz' } else if ('msTransition' in s) { return '-ms' } else if('transition' in s) { return '' } return false }(), loadingScreenSlideOut : function () { if(this.transformSupport) { loadingScreen = document.getElementById('Loading'); loadingScreen.setAttribute('style', this.transformKey +'-transition-duration: 350ms; '+ this.transformKey +'-transform: translate3d(' + window.innerWidth + 'px,0,0)') setTimeout(function() { var loadingScreen = document.getElementById('Loading') document.body.removeChild(loadingScreen) }, 350); } else { $('#Loading').animate({left: '100%'}, 400, function () { $('#Loading').remove() }) } }, 
Thx! Yes it doesn't try to do too much, just calculate where the pixels should go. You can probably imagine that's easy to let features creep in. The first versions tried to incorporate the actual rendering. So that meant I had a giant todo list with numerous rendering methods on it. But that way I could never finish the project and be done with it! So I threw all that out and decided to limit the tool to one simple thing: just calculating pixel offsets ;-)
There's a powerful library called knockoutjs that can help you out on this. Your variable would be an ko.observable and you can subscribe to it and execute a predefined function every time the observable value change. 
I'd say to google for javascript news. You can find a lot of projects on http://www.chromeexperiments.com/. Just browse the projects and when you find something useful, you can acces the source code to know which libraries they used. They're rather cool scripts than useful, but i regularly try them out.
An excellent Video
Blocked by CORS. They emit: Access-Control-Allow-Origin:https://www.bitstamp.net This doesn't seem to be part of their public API. You should not consume resources without permission.
On bitcointalk.org, a forum member (with the bitstamp.net logo as avatar, just like the OP) posted this: https://bitcointalk.org/index.php?topic=38711.msg1734562#msg1734562 So i think it is a part of their public api. I'll post on that forum for more info. Thanks 
A link to a confusing picture of some horrible looking code. Hmm. JavaScript types don't work like that. If you want to use a language with classical inheritance then... just use a language with classical inheritance? There are compilers that target JS for quite a lot of languages now. Or, even better, actually learn JavaScript. There is a JS way to achieve the same result (reduced repetition, easier to reason about the code) but you will have to stop pretending that JS is something else first.
Whenever i try to make a utility script i end up having feature creep because its a big temptation to make this amazing script that just does everything for the user, but you often just end up sacrificing almost all flexibility and increase the file size. Kudos for realizing whats best
Actually... can you describe the behavior you're getting and the behavior you'd prefer? Can you also tell me which browser you're using? I'm seeing different behavior between them.
You have some serious errors in your code. Firstly, you do not have "caching" of variable values in JavaScript. What you actually have is a scoping problem. You need to do something like: var a = 1; var olda = 1; ... if(a !== olda) { // a has changed olda = a; cb(); } But more importantly you have an infinite loop. If you call check(1, 2) the first thing that happens is that the if statement happens, which will call check(1, undefined). In there the if statement happens, which will call check(1, undefined). In there the if statement happens, which will call check(1, undefined). [you can see where this is going!] I think that your if statement is supposed to be calling getval instead of check. (of course, you should probably be looking at something like https://github.com/melanke/Watch.JS to do this for you)
Good idea, but only as an additional extra to your standard application. If it is an awesome job, they will have many applicants. As the recruiter, you can't be bothered to go through lots of "unique" presentations while doing the initial sorting. Always need a quick-to-read cover letter and clear CV/resumé. Oh!, and don't forget to make the source best-practice and available on Github. 
You can put all of your "sitewide" functionality into an external JS file. Then you can reference that file within each page with: `&lt;script src="path/to/file.js"&gt;&lt;/script&gt;`. Changes made to that external file will affect all pages that reference it. Hope that helps.
Erm, are you including elements with the ID of '#until300s' in the content of the specific page or not? 
A quick googling pulled this page up: http://www.tripwiremagazine.com/2013/04/jquery-countdown-scripts.html - most plugins have demo pages and usage examples. Find one you like and just play with the demo until it's what you want.
this. additionally, op is also calling check on an interval. You (op) need to pick one way of doing this - either make the function recursive (by having it call itself under the correct conditions) or have it be called on an interval. but yeah, as wibblymat said, you don't even need to be calling anything at that point.. you can just use if (va === val)
Yeah, that wouldn't work.. Add this before that line: &lt;div id="until300s"&gt;&lt;/div&gt; If you add any other HTML or content, keep the script line **at the end of the whole post**.
Now I feel stupid. Thank you so much for pointing this out to me, I no doubt would have spent hours longer trying to work this out!
:)
What is this monstrosity!?
Even with the content being pretty interesting, this is IMHO the **worst** way to navigate an article/site.
A simple and good portfolio will buy you any job. I just put screenshots of my work + a link to see online. Not too much text because nobody cares to read about your feelings to this project. Pick your best - and finished work, not some past shit - employer do not want to know HOW did u achieved that level - but WHAT level have you achieved.
I've got some methods that I extended underscore with, so I use this for empty checks: function(obj) { return obj == null || (_.isObject(obj) &amp;&amp; !_.keys(obj).length) || (_.isString(obj) &amp;&amp; !obj.length); }
NoScript disables it. (After it has been allowed to execute). 
That is NOT faster. It is less code. The loop is O(1). Object.keys is O(n) in time and memory.
One of these "Fixing what it not broken" threads :)
This doesn't really look like an interesting exploit. It doesn't trap the user in the site but in the alerts, rendering the browser unusable, which is easy anyway.
The bug however appears to be quite nasty. So trying to refresh or manually move/close the page triggers the bug. Marking the page as untrusted in NoScript allows you to escape. 
Include jQuery to count down 30 minutes... Seems legit. 
Yes, nobody would ever want a DESIGN PATTERN such as classical inheritance to be in JavaScript. Nobody even likes it or uses it anyway. /sarcasm Not to mention, have you even taken a look at the reserved keywords for future use? https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words So obviously, just because something isn't "broken", doesn't mean it can't have improvements, or for more stubborn people, alternatives, and the ECMA obviously agrees.
it's a bit of fun, but there is some good stuff in there, like the audio being encoded in BASE64 so there are no calls to external audio files.
Looks like ole' scrogu has got it right. You can't argue with science. http://jsperf.com/empty-object-tests/2 Still, it's a nice easy code snippet to remember and easy to type, so not completely irrelevant. 
Thanks, faith restored. While the "fast" way is certainly more elegant, it's going to nosedive in a hurry once the amount of keys add up.
Can you not setTimeout()? 30\*60\*1000ms should do it unless there's some limit.
Actually, your size() method is O(n) and less performant than the loop which exits immediately when finding any key. Here, I fixed it: http://jsperf.com/empty-object-tests/3 Also, we should note that in these samples, we are only testing the best possible performance of the Object.keys() and stringify functions. If you are testing objects that frequently actually have keys, then their performance will degrade significantly, but the isEmpty() function will stay the same.
This would be faster: function isEmpty(a) { if (a == null || a.length == 0) return true; for (var key of a) return false; return true; } This does assume that no one has added enumerable properties to Object. 
Realized my mistake in my head while reading another article, came back to fix it and found you already had. So, I will amend my statement to say, "You can't argue with math". Either way you're still right.
He works for Google now as a JS evangelist I believe, and so it's kind of his job to do stuff like this now, though he did this kind of stuff prior to getting the job there. Always does an excellent job though, so I can't complain.
Going off everything thats been said here. It comes down to the fact that you would want to make minimal calls to your backend. With Angular you put most of the processing power on the client, minimizing the cost to your backend in multiple ways (support, load, performance). In addition to that you are providing a friendlier user experience by not making the user wait. Ultimately you can do everything you want with Rails without using Angular, it just comes down to usability, maintenance and your interest in learning new techniques.
Well, the big O notation really only says what performance does when n gets large. In this case, you can't argue with test results.
Correct. For most applications, it probably won't matter. But let's not call something faster if it isn't. And honestly, as a developer you should be aware of the performance implications of every function you use. For instance, you should know this: Is this function O(1) O(log n) or O(n). You should almost never use anything worse than O(n). Does this function allocate any memory, and if so, about how much? 
Yep, fixed.
With a Vim integration I'd be in heaven.
Ya, i recommend the term "concise" to refer to faster to write.
I think you have a fair request. Have you ever tried to propagate it with Google engineers or within Google developer groups?
Agreed. I think it's sad when people bemoan _big O_, such as being interrogated about it during interview questions, saying things like "I've never used asymptotic notation for anything before, it's just a gimmicky interview question"... yeah, until your app grinds to a halt because you used a O(n) as opposed to a functionally equivalent O(1).
Or some one i there UX department if they have one.
Required for anyone learning to program, whether in CS or not. 
I think most of us appreciate the fact that you've published your work so that others can use it, however, in this particular case, I think this library is unnecessary. Function overloads are a feature of strongly typed languages, where types are distinct and hence the compiler will refuse any attempt to supply an incompatible type during compilation. When compiling, each function has a mangled name which includes the types of the arguments, so although they have the same 'human' name, the compiler sees overloads as functions with different names. Javascript, on the other hand, is weakly typed and this is a language feature. A function is a first-class object in Javascript and can be used just like any other type (stored in variables, passed around as function arguments, instantiated during runtime, etc) which is where the power comes from. Of course, it can lead to specific bugs and exceptions being thrown (eg. function arguments not being what is expected by the function), but all this is part of programming in Javascript - you have to be aware of the language features, the possibilities it offers and potential dangers. Making a language behave like another is prone to subtle bugs and makes it difficult for others to understand how the code behaves or works. 
I will use this shortcut in my javascript projects. Thank you.
Amen sir, amen!
A more common pattern to make functions polymorphic in JS is to use a options object as argument. var defaults = { startDate : new Date() }; function myFunction(options) { var settings = $.extend({}, defaults, options); } myFunction({ target : '123' }) This pattern is used in jQuery for functions that take more than 3+ inputs. 
What version of Chrome is this available on?
[Let me google one for you](http://lmgtfy.com/?q=add+site+to+home+screen+using+chrome+for+android)
We're talking about different things. I was talking about being able to style an icon on the homepage- it's something that Android has never offered, and that iOS does. My post covers adding it to the home screen with Chrome at the end (and I maintain that it's a terrible UI).
Ok, that looks nice but there isn't much to see for now...
It's not really a bug, it's a feature. A much-used feature that probably won't go away anytime soon, either. Being able to execute script before a page unloads is essential to many web applications to preserve state when closing a webapp, and do event tracking, etc. The fact that someone misuses and abuses this feature is nothing new, and not a "bug". You have to be careful no matter where you click around on the web, and sites that do this are shitty. 
There is another way for the length. var fakeFunc = new Function("a,b,c", "/*function body here*/"); I used that pattern in a little helper lib I wrote, [lambda-js](https://github.com/dfellis/lambda-js/blob/master/lib/lambda.js) The downside is that functions created that way can't be closures. If you need a closure, ``eval`` is the only way.
I'd say your two most important tools are going to sublime text 2 (as your editor) and chrome dev tools (chrome) or firebug (firefox). Depending on what your doing, you'll probably want to set up a local server so you can interact with a database and have a backend(node, laravel, django, etc) that does your routing etc. To start I'd suggest getting wamp, which will give you apache, php, and mysql out of the box which is nice. But really the only things you need to get started are a good editor like sublime text and some sort of browser tools so you can see what's going on. Hope that helps. Inb4: editors/ides are very subjective. eclipse/Dreamweaver/vim/jedit/coda are all perfectly legitimate and produce essentially the same result. I recommend st2 as I like its package manager and its clean lightweight interface. 
The code posted uses your (ISV_Domocles) way. It is creating functions that look like this: function (fun) { return function (__1, __2, __3) { return fun.apply(this, arguments); }; } So there are no free variables to close over. It's just a hack so you can take a function that doesn't declare any variables and give it a length.
Nice one, finally something I can print and put on the office wall.
The difference is that ``fun`` could still be a closure of some other scope, while ``new Function(args(len), funBody)`` will lose the closure. (Technically it has one "closure" scope, the ``global`` or ``window`` scope. ``new Function("", "return Math.random()")`` will do what's expected of it.) Your mechanism differs in that the actual function isn't ripped apart and used by ``new Function``, so the scope remains intact.
I usually use it for ethical game hacking: http://www.youtube.com/watch?v=Db9ATukiQUc
Information graphics or infographics are graphic visual representations of information, data or knowledge intended to present complex information quickly and clearly.[1][2] They can improve cognition by utilizing graphics to enhance the human visual system’s ability to see patterns and trends.[3][4] The process of creating infographics can be referred to as data visualization, information design, or information architecture.[2] Wall of text + a few images now = infographic? Doesn't seem all that sensible to me (har har).
Haha, so I built a chrome extension around this. Happy troll day people - https://chrome.google.com/webstore/detail/artscroll/aleccjpdgapbpljpcepdlgjegkfkofhj?hl=nl&amp;gl=NL
I use a function that makes an inner function (more polymorphic). It's the functional_polymorphism function from a library I have written. It's up at https://github.com/metabench/jsgui-lang-essentials/blob/master/jsgui-lang-essentials.js. 
If you write `new Function('fun', 'return function (__1, __2, __3) { return fun.apply(this, arguments); }')`, there are no free variables since `fun` is defined as the argument to the function being created.
Why are you raping JavaScript? Is this really necessary?
Right now, I'm working on a project that needs audio input in pure HTML5. I found the `getUserMedia` API and thought I could just use something like recorder.js; it would work fine if the user was using Chrome, which wasn't a problem for me. But wait: it doesn't work. It's implemented and returns ... zero. There are several StackOverflow questions about it: * http://stackoverflow.com/questions/10791457/is-html5s-getusermedia-for-audio-recording-working-now?rq=1 * http://stackoverflow.com/questions/11420846/whats-wrong-with-my-code-to-record-audio-in-html5?rq=1 * http://stackoverflow.com/questions/15734693/capture-microphone-using-getusermedia?rq=1 * http://stackoverflow.com/questions/4227313/audio-capturing-with-html5 * http://stackoverflow.com/questions/15940934/html5-capture-audio-from-default-microphone?rq=1 But it hasn't been fixed yet. Until then, I'll have to user Flash or a browser plugin.
Yea, I figured that was the problem. Guess I'm going to have to wait until I finish typing up all this reference.
Indeed, but Chrome isn't the default browser, so that worsens the situation. When are they going to ship Chromium for Android and make it default in Android? :/
My bad. It actually seems to be an issue with jsfiddle. The following works fine self-hosted (ie. on my own web server). &lt;script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.10/socket.io.min.js&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var c = io.connect('https://websocket.bitstamp.net:8080/live_trades'); c.on('trade', function() { console.log(arguments); }); &lt;/script&gt; 
The practice question (at least the one that I got, something about where to find API docs) was a little absurd - I've only ever tried using this sdk once and I got it right by thinking about it, not any real Touch knowledge.
Typically the practice questions are the easiest ones in these tests, but thanks for the feedback, this is good input.
Oh I must've missed that. Still though, Chrome for Android is much more standards compliant. The Android browser is one of the worst browsers when it comes to standards (also according to http://caniuse.com/)
That's fair, but no questions should guessable from my zero-knowledge level (I wrote an android app, once, about two years ago, and an iOS app about four years ago) based on wording - as someone who can pass that simple of a test, do I value the numbers it tells me about some other developer?
I would like to start off by saying the intent of this post is to let people know about Boiler.js's new features and changes because I've spent a hell of a lot of time working on this project and my hope is that one day it might save a lot of people a lot of time. So you might ask what's the advantage of using Boiler.js vs. Underscore.js? My answer is "deep iteration". In the most recent release (v8.0.0) all the pertinent array methods (along with many of the collection and object methods) will now perform deep operations on nested arrays and object-literals by passing `deep` with a value of `true`. Additionally I've added Unit Tests with QUnit as well as refined the code base bringing it down by about 1000 lines of code.
Good job and much improved everything by the looks of it. The only thing I would have liked to see is some kind of example usage per item like on underscores docs.
Thanks! Working to refine and perfect every day. I have a fair amount of documentation complete: [http://www.boilerjs.com/#api_compact](http://www.boilerjs.com/#api_compact) it may not be as intuitive as I had hoped... On the site just click any of the method areas and they expand to reveal more information.
Does it remove the gui when you add the bookmark to the home screen? 
Be careful with .extend. By default it is a shallow merge, meaning that it will not merge nested properties. The syntax is a little weird, but it will optionally take a "deep" parameter as the first argument -- moving everything else back a spot; var settings = $.extend(true, {}, defaults, options); 
Yeah I have a project I just finished with it.
We don't spam is not the same as we will never try to contact you ever, at least I assume that would be their reasoning.
you must have missed the fartscroll plugin post
We at Google use https://chrome.google.com/webstore/detail/rhino-vision/fhcmnjkoifnmgdnhnmbpilgmiabphkke?hl=en-US
I need an adult
So let the copy-paste-monkeys police themselves and our security problems are solved? Funny!
"Want to work on technology that changes the world? Or just technology that farts? We're hiring a Front End Developer. Drop us a line!" Awesome, How much experience are you looking for? 
For people that wanted to include it in open source software, yes. However, he was well within his rights to release it under any non-free license he wanted and just make it proprietary. The fact that it *appears* he intended to help the open source community by making it *almost* open source compatible seems misguided at best.
How do handle what your game should be doing? Do you calculate everything server side or do you do some stuff client side? I would also like to know how responsive socket.io, lets say i want to make a snake multiplayer game. How responsive would it be? 
[This](http://i.imgur.com/WRY9Po3.png)
I'm trying to figure it out for my current project. I have managed to get something working on "Nodejitsu" if you are looking for hosting.
Is the length check for arrays? If so, wouldn't it be better to ensure that what you have is actually an array? Otherwise something like isEmpty({length: 0, width: 10}); -and- isEmpty({length: "", width: "20"}); would return true, which is probably not what you want.
Also, it doesn't look as seamless.
Hey guys wrote a little article on performing source modification with r.js.
You obviously spent a lot of time on this, and I applaud you for contributing a project you're proud of to the world. Although some of this functionality is quite useful, I couldn't see myself using a library that pollutes the global namespace and overrides the behavior of built-ins. Suggestions: * Namespace your functions under `Polish` (i.e. `Polish.min`) and don't override built-ins. The last thing you want your library to do is to break working code. * Stick to camelCase, that's the JS convention. * Try to keep your method names short. `combinations_with_replacements` is overboard. * Test it. I wouldn't use a utility library that doesn't have near 100% code coverage. Furthermore, benchmark it and prove your solutions perform optimally (where necessary). * Many wont think this makes JavaScript better, and some will even be offended by that statement. Change your description to something neutral like "Handy utility functions." * Try contributing to an existing project, even if its just docs, tests, or bug fixes. You'll end up learning more than venturing our on your own, and you'll have something tangible on your résumé.
The whole reason I built this library is because I honestly believe that the core javascript environment can be improved, which is why I specifically added things to the global namespace. My actions were intentional. The library should overrides builtins in such a way that it does not remove any functionality, and thus should not break anything (though obviously it could still happen). My testing coverage is quite good (check polish.spec.js) And finally if people disagree that simple things like Math.min being able to accept a list does not make the language better, then they should be offended. I honestly believe that most of the changes make javascript better (I can see that a few may be looked down upon, but most are still useful). note: the naming convention for itertools came straight from python, but I could see changing the names. (I also may namespace itertools)
[html5 history API](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history) - see pushState and popState
I have been running this on lighttpd on my VPS for ages for small scripts where I used to run PHP, and I think it has potential.
It's not that simple. An Ajax based site can have many states. For the browser to recognize each state individually it has to be defined by a hashtag in the url. There are some jQuery Plugins to help with it, but your whole application has to be written (or rewritten) with that in mind. 
the concept is interesting, but why would I want to do this rather than just run node.js, for example? I'm not trying to cut down the idea - I've not delved into server side javascript yet so as an outside observer considering trying it out, I'm curious what the advantage would be, if any.
Some suggestions: * Grunt build tool instead of just npm aliases * Travis build tool integration * ending semicolons * jshint 
Good call! I have been doing a lot of Java/.NET, so I treat pretty much everything from outside a function as immutable unless otherwise specified, so never got into that problem, but a full defensive copy is always a good practice!
Build tool: * Grunt Testing: * Jasmin * QUnit * Mocha Mocking (standalone): * Sinon.js Static analysis: * JSHint Minifier: * Uglify Test Coverage: * Istanbul * JSCoverage Application Scaffolding: * Bower * Yeoman 
Nope. Only on Nexus 7. 
Actually, it used to. The standard browser will use the home screen icon meta (I think it prefers the composed version), however it was super buggy. Chrome, however, doesn't seem to use any of that.
Be wary of deep copy performance impact. If your code is passing values and is as immutable / functional as possible it's less of an issue.
*Any* unsolicited mail is spam. What if I just want to take the test, but don't want to receive communications ever ?
I don't get it. A bunch of small functions, easily implemented and/or hardly ever used. `abs(-5)`instead of `Math.abs(-5)`?? *Why??* Or this, so you can call `choice("abc")`: function choice(s) { return s[Math.floor(s.length*Math.random())]; } (In some browsers, `s.charAt(i)` must be used instead of `s[i]`.) Conclusion: random collection of functions, at best moderately useful.
Thank you. After 2 hours of fiddling I got it working. Here is the result: http://donepro.com/
In HTML5 you do not need hashtags anymore.
glad to have helped you get it going in the right direction! not exactly heavy on the content yet I see, but nice start :)
Here are the supported browsers (at the bottom of the page): https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history
Good work, very smooth.
And, wasn't it Google who thought the idea of a web-app on your desktop via Chrome was a smashing idea as well? This is a very good point you bring up.
Unless you want the current state to be possible to bookmark.
Yea thats how though i would do it the only thing i was worried about was how lag would fuck things up. Guess is just send the position a player changed his direction to the server and then if needed the snake needs to "jump" back on other clients. Oh another thing how do i make the collision checks on the server? I guess i will need to have a timer setup or something or?
Is there a step by step guide somewhere on how to get this installed and setup on a fresh box?
I'm not sure on the relationship, but this is also on github: https://github.com/ondras/TeaJS
That appears to be the same thing. It has been a while since the Google Group has seen activity. The developer has probably moved it there.
http://code.google.com/p/teajs/wiki/Manual http://code.google.com/p/teajs/wiki/ApacheConfiguration 
No idea what res is, but you could always hook into the window unload event and cache the data in localstorage. Then when the page refreshes check for cache and redisplay.
RES is the reddit enhancement suite.
What did you use to generate the doc? That looks really nice!
How are you liking at at Kendo? We're building a huge application using Marionette (thank you, by the way!) and I have to say, one of the first things I did is get rid of the Kendo grid we had (and it was a huge chunk) - it just wasn't manageable to have a Backbone based app with large parts relying on Kendo. I had a bunch of code to "bridge" the two and it soon became too much of a hassle. I guess we could have gone Kendo all the way instead. The MV* part of Kendo is not particularly popular from what I've gathered. How do you think it fares compared to Backbone + Marionette?
That doesn't sound like an efficent way of running JS code.
That's the jTypes website layout that I designed. Thanks!
It doesn't seem to have a lot of support. It's a neat project but I doubt many people would use it.
http://redd.it/1e4ja1
Never looked at it. However, my first guess if I had to do it would be history.push and keep the info there. Plus it makes for a VERY smooth experience. 
Nope and that's what makes this solution irrelevant. Then it's not an app that uses Chrome as runtime environment, but just a link to a website, which wastes the top bit of your screen on displaying address and navigation controls. I asked about this last year at Google I/O and the reply was "it's coming, but we have to figure out the right way of doing it first". From what I could understand, navigation was the big issue. It was believed that people would be confused at the lack of navigation controls, but this is, in my opinion, no real course for concern if the app was designed to be viewed this way - after all, regular apps do not have address bar and navigation controls. If we could get something like "apple-mobile-web-app-capable" (only without the apple-bit, so it could be universal across platforms), we'd ave come a long way.
I don't believe it's an efficient way to run anything 
[Reddit Enhancement Suite](http://redditenhancementsuite.com)
I've built a remote control interactive display with socket.io and node.js, ipad views a remote page and separate display shows updates. Hosted on an amazon ec2 instance and ran really smoothly, far better than I predicted. Give it a shot and if it doesn't meet your expectations at least you learned something new, but I bet you'll be stoked.
I disagree. There is more to code than just efficiency. This is for people who are conscientious of their designs. Classical inheritance exists because it is a good system of design, simple as that.
HTML5 pushState I presume, API is [here](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history).
I've tried that, it just saved page scroll position
lol, I've searched for js state and firefox and just see people trying to turn it off, haha
Perfect, thanks!
1) I initially chose to wrap the `l` in parentheses when I had just started writing the library and hadn't yet written a `noConflict` method. Doing so allowed me to change how all the libraries methods are referenced by changing the value of a single variable since the `l` is evaluated within the parentheses. I'll likely change this in the near future because it's just taking up extra characters. 2) I wrote the vast majority of the methods from scratch, yes. Though this doesn't mean I didn't look through a lot of other implementations for some ideas. ... My job interview skills are pretty bad. ;) I'm just lucky to work for a software company that values programming skill over verbal communication skills. 3) In the jsperf tests I've completed so far many of the methods are much faster than underscore even with the extra functionality included to allow for deep iterations over arrays and objects. I'm very much so looking for interested developers to assist me in the ongoing process of perfecting and adding to the library. I want `Boiler` to become as useful as a tool as possible. The main reason I wrote it was because there were a lot of things (especially concerning working with object literals) that many other JavaScript libraries just couldn't do.
Yep, works real well: var callback = function(){ alert('change'); }; var _a; var myObj = {}; myObj.__defineSetter__('a', function(val) { _a = val; callback(); }); myObj.a = "whatever";
I've use BBQ to work with hash state changes. http://benalman.com/projects/jquery-bbq-plugin/
RES is open source. You can see exactly how they do it. [Relevant source](https://github.com/honestbleeps/Reddit-Enhancement-Suite/blob/master/lib/reddit_enhancement_suite.user.js) - search for the 'neverEndingReddit' module.
I don't know how RES does it, but the way that single-page apps in general do this is by looking at the URL, either via the history API or by the fragment ID (the hash) or both depending on browser support. There's usually a router table which JS uses to lookup by URL which page it needs to render to the user. Example: http://documentcloud.github.io/backbone/#Router Also as others have said, sometimes browsers hold the state of the DOM and JS runtime in memory for a bit, and can automatically jump back to it when the user hits back.
I'm not saying I agree with their methodology, I'm just saying that might be their reasoning. As for what spam is, I believe that's more down to a subjective view of it. Personally, I don't consider it spam unless they're sending me more than 1 email every couple months, but obviously others will believe that one is more than enough.
I'm surprised the file:// reference works at all -- usually javascript isn't allowed to talk to the local filesystem ... I'd recommend setting up a local web server and using relative links within the directory... But hey, if it works it works ;) In answer to your question -- if you take a text file with line breaks, the line breaks are represented by carriage returns and line feeds. In windows, it is encoded as CRLF ~~and in unix, LFCR~~ and in unix, LF -- either way you slice it, neither of these are typically rendered in an HTML document. As bluej10013 stated use the css declaration "white-space:pre" on the element you append it to.... that should do it.
string.replace(/\r?\n/g,''); Edit got the order wrong
This is how I did it for a project at work...
Don't know how RES does it but local storage would be a possible solution to replicate it
I've looked there. I know and understand how they re-load the latest page in case it's not there... but most times for me, it doesn't need to reload and shows me the HTML as it was before I left the page. But it NEVER worked for me on my site, I was wondering why
Based on the comments here, I have reworked some parts of the library. Specifically, many global functions have been moved under Math, (only range and zip are left in global scope). Also I have re-scoped extra functions (itertools, clone) under the Polish namespace. I also tested the library against jQuery, backbone, and bootstrap unit tests, and it did not cause any failures. Thanks to everyone who gave me feedback.
__defineGetter__ and __defineSetter__ are deprecated, use Object.defineProperty() instead. 
Assuming you're using jQuery and having not looked at your code at all, have you tried using `jQuery('...').stop().animate()`? Also using the `mouseenter` event instead of `mousover` would trigger the event once instead of continuously. Give it a shot if you haven't already.
That works, thanks :)
I'm a little surprised accessing the file through file:// works too. I thought in order to not violate the same origin policy one was required to be using the same domain, protocol (http or https), and port between the script and the file it's accessing. 
You've got to feed it information that can completely load the state at that time independently. You can't just give it meaningless information and expect it to know exactly how you want it to act.
I understand, but if you read some of my comments here and on SO, you'd see that I understand how to do the URL thing, it's just the page state and the HTML that's created after page-load that disappears
You can try using [jQueryUI menu feature](http://jqueryui.com/menu/) Might be suitable.
So not having node as in option is what I meant was a good exception, but if you can install this you'll can install node **which works with apache**. You might be able to use node modules with this but they will probably be slow because they expect to only be loaded one time so they will greedily load all possible dependencies instead of lazy loading which is what this would want, they are also set up to be async which could be a problem here as this seems to be fundamentally sync. For the classic php pattern of read a value from the db do some stuff return HTML, these days your better off sending the values to the client as json and render the stuff there. All that being said, I am 100‰ there are legit uses for this when it comes to legacy php apps that need to be upgraded. 
Use JS to toggle through classes that change the properties of the element and use CSS transitions for the animation.
Don't do this. Store your data as JSON and read it in, then parse it.
tl;dr: everything except IE9.
Couldn't you just do this with css and avoid script completely? selector:hover { style:value;} 
&gt; I am 100‰ there are legit uses 100‰ is 10%. :-)
I don't know if anyone mentioned the biggest reason to make a single-page application versus a traditional style web application with views rendered on the back-end: much better UI responsiveness provides a much better user experience. Its also more efficient, takes advantage of the processing power of the browsers, and easier to code if you have any significant amount of JavaScript interaction in the browser. The main reason that I can see people having problems understanding that is because they have invested a lot of time in a language and system that _can't_ run in the browser and don't want to have to retrain. Or they have little JavaScript experience. If you like Rails, try CoffeeScript. As far as I'm concerned it is the best programming language out there, Ruby-like and even more so Pythonish, and a big improvement over JavaScript. For things that really do make sense for the server side, like reading databases and sending it to the browser as JSON etc., Node.js is the best system out there now. There are almost 30000 packages in npm. https://npmjs.org/ 
Or, if you're using python 3, `python -m http.server`.
Might not be a perfect solution but it's definitely a decent start: Professional JavaScript for Web Developers, 3rd Edition http://it-ebooks.info/book/483/
Its also used in the documentation for [coffeescript](http://coffeescript.org/documentation/docs/grammar.html)
[Mongoose](https://code.google.com/p/mongoose/) Copy &amp; paste into the folder you're working in, doubleclick. Done.
http://eloquentjavascript.net/
This is a newer one from John Resig, "Secrets of Javascript Ninja". http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X/ref=sr_1_1?ie=UTF8&amp;qid=1368335690&amp;sr=8-1&amp;keywords=secrets+of+javascript+ninja 
I have been working on something known as [Survive JS](http://survivejs.com/). I would appreciate it if you could go through the material and provide some feedback on it. :)
http://james.padolsey.com/jquery/ you can search any jQuery prototype and it will show you the code for said proto
thanks man.. Ill keep that in mind!
My bad, was on my phone
I am amazed that these conversations are still occurring, shim Object.create and use this pattern for classes/inheritance : https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create ES6 classes are sugar for the above. There is no further discussion needed.
Err, why is it not a perfect solution? I'm asking cause I'm learning from this book right now.
lidoc works well and lets you do custom pages in markdown as well as inline comment docs
[Javascript: The Good Parts](http://www.amazon.com/exec/obidos/ASIN/0596517742/wrrrldwideweb)
I'm also wary of inheritance, it's something that should be used rarely, if ever - that applies in any language not just JS. How big was the biggest JS code base you've ever worked on? EDIT: People seem to dislike my statement regarding inheritance, I suppose I should have provided more meat but it's a fact that it can lead to headaches when working with large code bases. Most people are probably aware of [composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance). The major benefit highlighted there is the fact that concerns are kept within one class as opposed to spread out over multiple classes in the inheritance hierarchy - it's also very helpful to create interfaces and to work with them inside classes as you can more cleanly encapsulate an implementation behind an abstraction. This does help when you need to add more functionality to the code, it should allow you to create a new, separate class instead of adding more code to another one. The of course there is [fragile base class problem](http://en.wikipedia.org/wiki/Fragile_base_class_problem)... inheritance has its place but I'm always cautious when using it and normally prefer not to.
Thank you. I swear, this kind of discussion pops up at least once a week. You wouldn't try to do prototype-based inheritance in Java or C# so why do people feel the need to force JavaScript to do classical inheritance? To expand on your comment, if you **need** "classes" in JavaScript (not to say that something that emulates classes can't be useful) then you have an incomplete understanding of inheritance and/or JS.
You CAN bookmark the pages loaded with AJAX without hashtags. Just tried it in Chrome 26.0.1410.64 m (latest version).
8500 lines. Inheritance is a blessing. The underlying problem here is a difference in perceived approach... or rather functional programming versus OOP. The primary strength and curse of OOP is that it is reference based. Objects, properties, and classes are linked by references. In this case you need a naming convention to discern any sort of structure or hierarchy and it is important that references are well named, because otherwise the code is challenging to follow, but you have manual control of everything. In functional programming, particularly with lexical scope, inheritance is natural, automatic, and unavoidable. In this case properly named references are a convenience, but are not really important. Functional code tends to rely more upon structures rather than constructs and so the alignment of the parts is visually clear, but you loose some manual control when reliance upon a means of structure is always available. The closer to the hardware the more manual control of absolutely everything is important. In JavaScript you control nothing, with regards to hardware, and the code's execution is almost never persistent so there is little benefit in wanting too much control of how pieces are aligned in the grand scheme. The general trend I have observed is that the larger a JavaScript application becomes the more it is willing to exchange OOP practices, such as *new*, for functional approaches with inheritance. I believe this trend is entirely unintentional and yet is omnipresent.
https://news.ycombinator.com/item?id=5693514
You'd not try to do prototype based inheritance in c# for the same reason so many people try to simulate classes in JS: prototype based inheritance is shit and class based is a more familiar way of doing things for many of us.
Wary of inheritance? Can't tell if you're trolling or just talking out of your ass...
My one complaint about that example is that it doesn't set `constructor` on the new prototype. Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; Without it, Rectangle objects all claim to have been constucted by Shape. 
I created a mailling list https://groups.google.com/forum/?fromgroups#!forum/pythonscript and twitter account https://twitter.com/_PythonScript_
I also used BBQ. works well.
Inheritance couples classes together, I much prefer composition. When you have deep inheritance hierarchies you don't separate concerns, you spread it out over the classes in the hierarchy. Dealing with interfaces/abstract behaviors instead of inheritance hierarchies makes it far easier to reason about systems. http://en.wikipedia.org/wiki/Composition_over_inheritance
I'm surprised you got so many downvotes for this.
Prototypal inheritance is how Javascript wants inheritance to work. It is arguably the best way to do inheritance in Javascript - not that you want to do that, anyway.
200,000+ lines, ~1,100 classes. Inheritance is a double-edged sword. I've already [talked about that in another comment.](http://www.reddit.com/r/javascript/comments/1e60l1/interesting_discussion_on_inheritance_in/c9xb0xz). I'd say that's the underlying difference, it's a matter of scale. Once you work with applications that must match fat desktop clients and must match their performance then you should use the tried and tested approach of classes that generate objects which contain application state. You can talk about abstractions and they encapsulate their functionality allowing large, distributed teams of developers to work away on the code base and deliver features without stepping on each others toes. Functions within functions within functions all inside a few large files is a recipe for disaster if you are trying to scale the codebase and have large development teams. You don't have inheritance in functional programming, it [only applies to OOP](http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29). I have found the opposite, the larger the code base the more you need an OO approach to help you structure the code base. Functional programming starts to reach it's limit when you want state and state is something any large single page application worth it's salt will need. On the other hand if you are dealing with the most common use of JS, in websites to add some interactivity, then yes you don't really need state or classes. ES6 is for the future, it's for native equaling applications, it's not for websites... Oh and for your point number four above " 4) You cannot create classes in JavaScript. Doing stupid things with patterns and constructors will not produce true classes in this language. " From the definition of [Class on Wikipedia.](https://en.wikipedia.org/wiki/Class_%28computer_programming%29) "In object-oriented programming, a class is a construct that is used to create instances of itself – referred to as class instances, class objects, instance objects or simply objects. A class defines constituent members which enable its instances to have state and behavior.[1] Data field members (member variables or instance variables) enable a class instance to maintain state. Other kinds of members, especially methods, enable the behavior of class instances. Classes define the type of their instances.[2]" What part of that cannot be done in JS, even just using the method I linked to?
That inheritance is something one should limit the use of? Could you please explain your comment, I explained mine. I've worked on large class hierarchies which made reasoning about the classes far harder then it should have been purely because of the coupling between the classes. It also made changing the code more danger fraught as a change could impact other classes in the hierarchy in unexpected ways. [link](http://www.reddit.com/r/javascript/comments/1e60l1/interesting_discussion_on_inheritance_in/c9xbi7j) [link 2](http://www.reddit.com/r/javascript/comments/1e60l1/interesting_discussion_on_inheritance_in/c9xb0xz)
JavaScript does not have classes. :( The whole point of classes is to extend objects with a property that maintains residence in memory. There is no way to emulate that feature in JavaScript. The only similar resource conserving feature in the language is prototypes. &gt; You don't have inheritance in functional programming, it only applies to OOP. **EDIT:** A variable used in closure is available in one scope that is inherited from a higher scope.
When I speak to control I am talking about the logical layout of containers in code. In OOP the foundational premise is to extend objects, which implies extending an object with something via a reference. The control, or freedom, here is allowing a programmer to determine how they wish to extend their objects. In purely functional programming objects are primarily for data only and extension of objects is not an important concern. The primary concern is how instructions are executed and the relation of those executions without regard for references or any other type of programmer supplied convention.
Prototypes and classes have the same execution and purpose. The only real differences are in how they are written and where they are available.
Just a note about your terminology regarding closures. You're describing a variable which has been captured by a closure, rather than a closure itself. A closure is a function packaged along with a table of references to variables which are non local to that function (and accessible to that function when called from any scope).
OK, let's analyze the statement from Wikipedia and see how it fits or doesn't fit with the example I linked. "In object-oriented programming, a class is a construct that is used to create instances of itself – referred to as class instances, class objects, instance objects or simply objects." That is achieved in the linked example. var rect = new Rectangle(); "A class defines constituent members which enable its instances to have state and behavior.[1] Data field members (member variables or instance variables) enable a class instance to maintain state." That is achieved in the linked example. If you were to console.log this line the value of the instance variable would be printed ( 1 in this case ) rect.x &gt;&gt; 1 "Other kinds of members, especially methods, enable the behavior of class instances." That is achieved in the linked example. rect.move(1, 1); //Outputs, "Shape moved." "Classes define the type of their instances.[2]" You guessed it. rect instanceof Rectangle //true. rect instanceof Shape //true. As for your closure statement. "In object-oriented programming (OOP), inheritance is a way to establish Is-a relationship between objects.[note 1] It is often confused as a way to reuse the existing code which is not a good practice because inheritance for implementation reuse leads to Tight Coupling." You clearly mean something totally different when you use the term inheritance then the rest of the programming world, please stop using it as you are. Inheritance is not a lexical construct, if I move a class from one file to another one it doesn't stop being a subclass, it doesn't stop inheriting. Also a closure is not a variable. "In computer science, a closure (also lexical closure or function closure) is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables) of that function." 
You can, actually, create classes if you want to. Doesn't mean you should.
Interesting. Though I'm not sure I'd use this in an environment where I have a debugger available, it is well-written with some nice tricks in the code such as indentation using `new Array(count)`. I was curious: Is there any reason why you copied each property from `arguments` to a new array instead of using `Array.prototype.slice.call(arguments)` to convert `arguments` to an array?
If you're able to explain how you'd get the pattern explained in this paper with classical OO, with the same expressiveness and terseness, then I'll agree with you: http://www.cs.cmu.edu/~aldrich/papers/ecoop05pmd.pdf
I came here to say this.
&gt; OK, let's analyze the statement from Wikipedia and see how it fits or doesn't fit with the example I linked. The theoretical definition from Wikipedia is nice, but my practical explanation is more valid. If in OOP classes do not conserve memory then why use classes at all when any property could be just as easily extended and reused? JavaScript does not have classes. &gt; You clearly mean something totally different when you use the term inheritance then the rest of the programming world, please stop using it as you are. Here is an example of inheritance via closure: var x = function () { var a = "top", y = function () { var b = "bottom"; return a + b; }; return y; }; x(); Function y inherits variable a from parent x. Too simple. I did not have to define that inheritance in the code or specify anything fancy. The feature is already available and it cannot be turned off. If I can just follow the flow control of the scopes then I don't even need fancy names to describe how things are linked. Its just there and simple.
Correct, you could also use Object.create itself. //subclass extends superclass Rectangle.prototype = Object.create(Shape.prototype, {constructor: {writable:true, configurable:true, value:Rectangle, enumarable:true}}); Although that is verbose! Made your suggested change.
"The theoretical definition from Wikipedia is nice". That is _the_ _definition_ and my explanation was with real code, fairly practical. Well designed OO languages do have classes that conserve memory, ( implementation detail anyway ) heck that's one of the reasons to use the prototype in JS instead of just creating copies of objects including all their functions. If you create 100 copies of an object you have 100 exactly the same functions in memory while if you put that one function on the prototype and create 100 new instances of the object you have one function. Your example is not of inheritance, stop using that term you simply don't understand it. What you describe is a closure; function y IS NOT A x. This is not inheritance in the computer science way, what you're saying is if I pass an argument into a function, or if that function closes over one of my variables that function has inherited from me. That just isn't the normal definition of inheritance, there is no IS-A relationship between the two pieces of code. JS, currently, does not have the class keyword accessible, that does not mean you cannot have classical style programming available in the language, ES6 to ES5 transpilers are already changing ES6 classes to ES5 code. The class keyword is syntactic sugar, no more. We can do class based programming in JS right now as I showed in my last post all of the important attributes of it are currently available.
It's the best book I have seen so far with respect to Javascript. 
Yeah no, there is plenty of discussion to be had object create is not the be all end all, because you have to deal with code that uses other patterns like just attaching shit to the prototype, plus you also haven all of the class shims that different libraries use to make things easier for oo type stuff, and they do make it easier but they are totally incompatible, this is not helped by the peanut gallery of people that answer every single javascript question with, 'read javascript the good parts' and the other group of people that are just confused by JavaScript object inherentence not being exactly like c++/java/smalltalk and won't shut up about how javascript needs multiple inherentence/dimonds/whatever and it's ruined without
Warning: Non-native English. Edit (constructive criticism): * Capitalize all I's as in "i am writing" (it's not optional). * Don't use articles ("a", "the") with names (omit the "the" in "the github" or "the jQuery"). * Learn about uncountable nouns ("information" not "informations"). 
Can you point the english errors ?
I'll clarify the "I" portion. Whenever an "I" is by itself, it must be capitalized. This also means "I'm", and "I've", as the ' is simply joining two words ("I am" and "I have", respectively).
&gt; There are two means of inheritance in JS: 1a) Scope chain Scope is a distinct concept and orthogonal to inheritence, so I wouldn't bring it into the discussion here; you'll only create even more confused programmers. &gt; it is automatically inherited by descendent functions Here you're using "inherit" and "descendent" in a more colloquial way; this relationship doesn't fit their technical meaning. Functions don't really "inherit" scopes so much as simply have a place on the scope chain. Functions also aren't really "descendents" of the functions that enclose them. If I have one function inside another, it's not an "is a" relationship which is what inheritence is ultimately about.
Why didn't others think Backbone would make their life easier? Or was it because they didn't want to invest time in learning "yet another framework"? Were you using any framework before Backbone, or just plain javascript/jQuery?
On top of Sublime Text 2 I would recommend installing TernJS (https://github.com/marijnh/tern_for_sublime) and SublimeLinter, or at least JSHint (https://github.com/SublimeLinter/SublimeLinter). Both really smart packages for writing javascript.
Fixed. Please, if there is more errors, i will be very pleased if you point :D
I'm new to JS but I've been struggling to figure out inheritance. The object.create and his code snippet only works for non reference values no? Anything such as object or arrays for object properties will not work for his snippet because they all share an instance? And the pattern for inheritance of referential values is much difficult? (Parasitic combination inheritance) ? Is it an uncommon practice to inherit any value that are reference type (array,object and such)? I keep on thinking there might be a prototype way of designing this and that I'm thinking it too much of a class base OOP way? There are hints that I should mostly use composition which is what GoF suggested (composition over inheritance), but the composition way is much freaking confusing; constructor pattern and the constructor prototype pattern for object creation is not something pretty to look at.
I'm reading through the book too. Wow it is technical, it's good but technical as hell. The object creation patterns for inheritance holy freaking hell is confusing. It's like you're not suppose to fucking even bother with inheritance in JS or something...
Neat! But why use bower instead of just npm? 
Very nice! But, you should have assigned a reference to random() to a variable r or ra... you could have saved a few more bytes and avoided this ridiculously bloated code ;) LOL
var base = { aReferenceProperty: ['blah','blah2'] }; Do you know what pass-by-reference versus pass-by-value is? Let's say you have a function object that inherit from base, let's call it sub. You do sub.aReferenceProperty.push('cow') Now both sub and base: ['blah','blah2','cow'] Sub and base DOESN'T have it's own instances of aReferenceProperty array. You usually want one copy for functions but for properties that aren't functions, such as value or array, you want a unique copy for every instantiation. Parasitic inheritance doesn't work for referential stuff such as Array. What you've gave me originally only works with properties for boolean, numbers, etc.. It doesn't work when you inherit a function object with ARRAY as a property (well in term of classical inheritance). Because arrays are by reference. http://jsfiddle.net/VxNk5/
It could be memory efficient for a infrequently run task (just a guess)
Given the behavior you are expecting, I guess you could consider this a shortcoming of the language. `[[prototype]]` chaining is inherently referential. Generally, I would say that stateful values (a property whose value is specific to each instance) should not be attached to an object's `prototype` for this very reason. If so, they should declared constant, but there is no ES3-friendly way to enforce that.
What are the performance characteristics compared to something like deferred? https://github.com/medikoo/deferred
I'm the only JavaScript fanatic in a very small (4-5 employees) mainly coldfusion/PHP/rails shop that has only three devs. There's no methodology and a big focus on billable hours. Hard to bill a customer for learning a new framework. So I did that on my own time, and spent some time perfecting REST wrappers around our existing CMS/framework before beginning to use BB in new projects. It is not so much that they thought of it as yet another framework as not knowing or caring that JS frameworks even existed. A bit like how I am not tremendously excited about the write performance of Oracle databases. I have yet to get anyone else to write or modify any backbone code and I doubt I will. Since I am the one that writes and maintains most of our JS, I am reasonably happy with that. I've also evangelised the framework to my colleagues in a former job with some limited success, and I'm planning to try Marionette after listening to a recent JavaScript Jabber podcast on the subject with Derrick Bailey as a guest. I wasn't using any framework per se, apart from the Crockford module style and jQuery for ajax/DOM, though I spend a lot of time in the node world, just not at work. Working with node/express and using backbone is so easy that you forget just how complicated it used to be. Once i started using Backbone, there was no turning back for me. I think the conventions are a little ugly/verbose (I'm not a coffeescript user) but the API is enchanting, very sensible and gives you room for interpretation. There was no "aha" moment like there was back when I first got the hang of jQuery, or first understood the MVC concept in general, just a growing appreciation of how the framework was saving me time and teaching me good practice. I do remember spending the first few weeks or days wondering if I was completely missing the point of backbone in the same way, until I watched a few screencasts and was relieved to see people mostly do it in a similar way. This is down to the documentation being pretty short on explanation. Stack Overflow is full of great answers, but no authoritative answers, it is far from an opinionated framework and understanding the scope of it was a little difficult for me.
Fixed ! Thank you s3than !
The primary reason at the moment to choose Dart over Angular would be to ditch JavaScript. Personally, I can't stand JS as a language, and Dart is just much nicer syntactically. Whenever I'm working on a project that has to be done in JS, I use Angular, but when it's up to me, it's Dart all the way.
so almost, but not quite, an es6 -&gt; es5 compiler?
try something like this and just set the callback to invoke another ping. https://gist.github.com/rlemon/4dfc3122f86e82778a9f
Thanks for the link. I'm very new at using javascript. what do you mean by setting the callback to invoke another ping?
In the English language, all punctuation is placed adjacent to the preceding character. This is incorrect ! This is correct!
What does that have to do with JavaScript?
https://gist.github.com/rlemon/4dfc3122f86e82778a9f#file-gistfile2-txt like this.
It looks like the author used the aivopass compressor to do that.
&gt; Scope is a distinct concept and orthogonal to inheritence, so I wouldn't bring it into the discussion here; you'll only create even more confused programmers. I disagree. The prototype chain will not be considered if a reference can be resolved from the primary scope chain. I fail to see how that is orthogonal. &gt; Here you're using "inherit" and "descendent" in a more colloquial way; this relationship doesn't fit their technical meaning. One function is able to inherit access to the variables of a parent function, which is external to its own scope. I really don't care that this language will confuse programmers, because the very concept of lexical scope is immediately confusing to programmers with a die hard emotional obsession that OOP is the only one true way.
Wizard needs food badly!
Right now it takes about 1.5 seconds. That's about 1 second longer than my tolerance, but it's not even the real problem yet. My code right now is 50kb but it will grow to over 1Mb before I am done with this project. The problem is that the build time is O(n) where n is the size of your project. As my project grows, the build time will grow proportionally. Running some tests, I see this with browserify: 200k project = 800 ms 500k project = 1590 ms By the time my project grows to 1 Meg i'd be looking at 3 seconds wait time. By comparison, my builder takes about 3 ms, no matter how big my project is (because it only rebuilds the files you touch and doesn't do much processing): 200k project = 3 ms 500k project = 3 ms 10 Mb project = 3 ms I am currently designing the build system for Viewpath 4.0, an online project management web app. I am going to use commonjs modules for this version. The most important part of my development time will be spent on an inner loop of tweaking some code and then refreshing the browser to see the change. I write my source in coffeescript, and that is automatically built to javascript whenever I save. This browser builder will then automatically detect the change in the javascript and build a browser version of it, and copy source and sourcemaps to the browser folders as well, all in about 3 milliseconds. I also have unit tests that run automatically whenever a file is saved, and I will be making those tests incremental as well so that they don't increase in time as the project grows either. Some people like to optimize code inner loops. I like to optimize my development inner loop. If something takes more than a few seconds, then I might just start browsing reddit, and that really kills my productivity. (Also, the build time with commonjs-everywhere is 4 seconds, even incrementally, which is what spurred me to write my own.)
You are assuming that code without classes is inherently broken or impossible to manage. That is pretty ignorant. Nobody complains about the absence of classes from Haskel, for example, and that is not broken code. JavaScript does not have true classes. The inability to perceive code without classes implies a limited understanding of diverse code architectures and claiming that everything is wrong is simply advertising ignorance. &gt; As I've already explained further down dealing with hundreds of k of JS and distributed teams of developers makes writing code in a few large files containing floating functions with a lot of global state a scalability nightmare You should always avoid coding in the global state, which has nothing to do with whether or not you use classes.
How would you compare your experience with browserify to requirejs?
&gt; The result of these two snippets of code should theoretically be the same. However, as said, the probability of experiencing bugs in Augmented JavaScript is still fairly high, and **I have not explicitly tested the snippets found here yet.** Really? Surely it wouldn't have been that hard. I stopped reading at that point.
This looks like a great project for Browserify! If anyone is looking for an alternative that requires no compilation step there's also [Mr](https://github.com/montagejs/mr) (disclosure: I maintain it), and then [Mop](https://github.com/montagejs/mop) for creating optimized bundles.
It's not a book itself, but this link will guide you through a lot of javascript core concepts and patterns. I recommend it. http://javascriptissexy.com/how-to-learn-javascript-properly/
build time for 1.5 seconds looks fast. I am used to wait 16 seconds on closure tools build step. 
The database API is elegant. Having relationship build into the library is one step forward then other wrapper library. I am not sure how foreign key constraint is enforce though. 
That's horrible! You need two setups. One for debug development, and one for release. Slow steps like closure compiling should only happen when you build a release version. A sub second save/refresh cycle will change your life. 
&gt; The prototype chain will not be considered if a reference can be resolved from the primary scope chain The prototype chain and the scope chain are two entirely different things. The prototype chain is used to resolve the properties of objects. The scope chain is used to resolve the value of variables. Your sentence as written does not make sense. &gt; One function is able to inherit access to the variables of a parent function The issue here is that's not what's really happening. The function is **not** "inheriting" access in the same sense that an object inherits the properties of it's prototype. Inheritence in a computer programming context is talking about a specific type of relationship. Consider this example: function A() { function B(){} } The relationship between A and B is that B is inside of A; that's it. There are consequences from this re: scope, but that's irrelevent for the moment. B is not "an instance of" A....B is not "an example of A"...there's no **inheritence** relationship here; they just share access to A's scope and whatever scope is enclosing both of them. You could use "inherit" in a **different** sense...one that is closer to the way it's commonly used in English; but that's a bad idea because it's confusing. You're confused, the people you're talking to are confused...everyone's confused and it's not good. You are getting confused because the process of resolving an objects properties and the process of resolving a variable are very similar in that the both involve the concept of a "chain" that is traversed. It is important to note though that they are two different and distinct things. It's true scope could be involved in inheretence in that you could use it to build a system to express inheritence between things. However, they are still orthogonal and distinct things. You could also use arrays, string concatonation, etc to build a system to express inheritence as well. None of those things are relevent to a discusion of inheritence unless you are explictly talking about building such a system rather than strictly the semantics of the language.
Great beginner's guide to Jasmine! Thank you! One could make the Jasmine code even more readable using the function names. Just pick your strings so that a full sentence is formed: it("should be false"), expect(a).toBeLessThan(...) and so on.
"Mr" Looks kind of complicated. Also, if you are "evaling" your module source code, then your debugging is going to suck. Errors won't tell you the file and line they were thrown from and forget about source maps. 
And where do you put that 'div is visible' check?
I like that people are building stuff like this. Last week I started poking at which hooks I would need to expose in browserify to do a similar fast rebuild and it was tricky but not impossible. To make this work with browserify I just need to make browser-pack or something like it support cached rescanning. There are 2 tricky parts for doing this: reference counting the dependency graph to cull unused files and scanning the new versions of files for require calls only as far as the files were modified. The second tricky thing will require browserify core to expose its custom packageFilter logic in a more hookable way so that all the custom module resolution and transform logic applies in exactly the same way. I'll probe this problem again when I get some time in a few weeks probably.
*cringe*
What do you use for watching and automatically compiling your CoffeeScript files? The default compiler or something else?
This looks like a very nice and scaleable approach! But how would you use non-CommonJS libraries like jQuery or something with this?
java != javascript, try /r/java
I'm assuming that code without structure cannot scale, that's not ignorant that's fairly obvious. The structure can be classes or it can be something else but just having large blocks of code floating about grabbing state is a recipe for disaster. According to your definition of classes, a syntax based one where if you have the keyword "class" you have classes then [Haskell does have classes](http://en.wikipedia.org/wiki/Type_class). I agree you should avoid global state and you can achieve that with classes and provide yourself a nice simple to understand encapsulation mechanism, it's not the only way of doing that but compared to functions within functions with no abstract concepts it is clearer.
"Circle jerk"? You should be familiar with [the Duck test](http://en.wikipedia.org/wiki/Duck_test). I particularly like the quote "It is sometimes used to counter abstruse arguments that something is not what it appears to be." I know you're not speaking theory, I'm not the only person to have explained that your use of the word inheritance is not the same as the rest of the computer science world a ubiquitous language is quite important within a professional sphere you may find it helpful to use the same one as other people in it.
I'm just curious what you would classify as an example of inheritance in Java.
You don't need to. Just use a script tag for those libs if you really think you need them.
Jasmine lacks real asynchronous unit testing, Mocha FTW
lukxde, the problem with a test named "should be false" is that when it fails in a bigger project. You know nothing about the error. =/
I didn´t know this one. I will read about that :D
in my javascript :)
The idea is to have the checks separate from your modules. :) In this case, not in your Toggler script.
Friends don't let friends use Jasmine.
Yep. You can still combine them during a release build step, but you don't need them to be part of this build process. 
It's a lot easier with separate files. Another reason i like separate files is it makes debugging easier. That's not as important now with source maps, but some browser versions you may need to test don't support them. I still merge files, but only in the release build process. 
wouldn't work for an instance using a constructor function, perhaps use instanceof Object (though an array is also an instanceof Object, and it wouldn't cover array-like objects like node lists and arguments). I like the check for length first because it covers array like objects. I'd hope people would only use the length property if that was their meaning. Perhaps there could be a second parameter taken in the isEmpty which the use can specify if their object is meant to be array-like or the length property should be read as just another property
 var x = []; // this is your array var myObj = {}; // this is your object x.push(myObj); // x now contains one element: myObj. 
I cant even begin to tell you how brutal it is.. 
Well if you want subclasses of object to be isEmpty, they can always set their length property to zero.
I think the paradigm that you're implementing is actually [Aspect-Oriented Programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming), or AOP for short. Here's [another implementation](https://github.com/cujojs/meld), and [another](http://www.reddit.com/r/javascript/comments/18bd61/middlemanjs_a_new_open_source_library_for_hooking/), and there are quite a few more I believe too.
Thanks. Sorry I should have been more specific. I need to have multiple objects like this. So when I press "add object" button - I need to so something like this (will provide shoddy js just to show I am contributing something.) I am not sure if this would push a new object or overwrite: var id = 0; // define id var function addObject(){ // function for adding object var myObj = { // create object 'id': id++, // 'widget': 'flange', // items in obj 'age': 25, // } x.push(myObj); //push the object to the parent array } 
Have you looked at [browserify](https://github.com/substack/node-browserify)? It solves the client side packaging problem using common js/ npm. That way you can use code from npm and organize your projects with a simple/coherent module system. It also packages all your scripts into a single file, speeding up page loads over requirejs.
&gt; I'm assuming that code without structure cannot scale You keep making these ignorant blanket assumptions. Why would you presume code without classes is utterly void of structure?
&gt; The prototype chain and the scope chain are two entirely different things. The prototype chain is used to resolve the properties of objects. The scope chain is used to resolve the value of variables. Your sentence as written does not make sense. You have to resolve the object before you can resolve properties on that object, so what I wrote does make sense. &gt; The function is not "inheriting" access in the same sense that an object inherits the properties of it's prototype. Where did I say that? I was pretty clear the scope chain and the prototype chain were separate things. There is no confusion to be had. You are presuming I cannot tell the difference between an object and a property. Objects inherit prototypes but do not inherit properties. A property is defined within an object.
I program in JavaScript and not Java. Java did not have lambdas until Java 8, so it makes a pretty poor comparison. If you somehow believe there are similarities in Java and JavaScript we probably should not be having this conversation.
I enjoyed that. Thanks for sharing.
As a result of writing this I ran into a number of packaging systems, including browserify (I noted it in a comment) and a few similar projects. Thanks to a blog comment I also just ran into mantrijs. This seems to fit Obviel very well (as it already uses namespace objects which Mantri is built around) and I wouldn't need to break Obviel's public API. Plus it works out of the box with Buster.js, unlike require.js which required a lot of work. [update; mantRI.js, not manti.js] 
Do you mean the internals, or the usage? Debugging and errors work as normal using the trailing @sourceURL comment. This will also work for source maps once support is added. 
Frankly speaking, right now there are no tools for acceptable mobile development. We are developing a mobile application for iOS/Android/WP and we are using Sencha Touch. And it is slow as hell (I think because of the class system and event subscribers they have developed) but we cannot just change the framework because we faced a lot of bugs in mobile platforms and Sencha seems to be the only framework that bypass them. The time for HTML rich mobile applications is yet to come.
Both. Specifically: Runtime XHR requests, eval, require scanning, require.* properties, module.* properties, promises, optimizer, 33kb require.js implementation. The advantage of Mr is that you don't need a compile step to use your modules in the browser, but that requires quite a bit of effort and code to achieve. The basic problem is that I want to run my commonjs modules in the browser. The simplest solution that works is this: 1. Wrap modules in a function like this: require.register("module/name", function(module,exports,require){ /* my unprocessed module here */ }); 2. Provide a simple 1.5kb require.js file on the client. Less runtime components means less that can go wrong, and you can also use your require function and modules in other places, for instance... in a Rhino Javascript engine running on the Google App Engine.
So eval'ing supports source maps? That's pretty cool.
I have been doubting about 'html5 will win in the end' lately as well. Not so much in terms of technology but more how marketplaces are so good at delivery native apps to their customers.
What can we do as web developers to get HTML5 into the "mainstream" of mobile web app development?
All apps on limited hardware need to be made performant, regardless of tools/frameworks/tech used.
One of the problem is that most framework use a one-way approach and never downgrade anything based on the performance of the phone. Web application can run fine on older phone if you use simpler layout and remove most of the expensive CSS styling (mostly webkit-transform and gradient). Also, it's definetly not a sinking ship, phone are getting better and better each year and there's already a good proportion of device which have good enough performance to run web application without any problem.
True, Mr does have a lot of features. The runtime XHR, eval and require scanning are all necessary to avoid a compilation step. Most of the require.* properties are APIs that are used internally and exposed in case they are useful (which .async and .loadPackage are if you are dynamically loading dependencies at runtime as they're needed). The module.* APIs are (largely) from the CommonJS spec, and similar to Node, to ensure compatibility. As for promises, this was originally written for [Montage](https://github.com/montagejs/montage) where we make extensive use of them and so isn't seen as an issue. And the optimizer is there to avoid the runtime XHR, eval and require scanning in production :) The problem I have with 1 is when I want to use packages from NPM then I can't wrap them without a compile step. For 2 the Mopped (built) version is smaller and bundles Mr and your app into one file reducing HTTP requests and avoiding latency issues. Hope this explains it a bit. Thanks for the feedback!
No, that's not what it does at all. It complements JavaScript's inheritance.
Javascript does not have an inheritance problem in my opinion. While the patterns are different from a more classic oop language like C# or Java. Inheritance is easily implemented in javascript. More so if you take a functional approach (which is the recommended approach), then you can skip inheritance entirely. Embrace the language, Don't try to make it into java. 
[This Guy] (http://gifwall.net/gif/clint-nod.gif)
sounds to me like you are on the sinking ship. phones with those specs probably aren't even used by the majority of people now, and definitely not in just a couple years
Unless you're linkedIn or Facebook which can afford to hire an android team and an ios team, most devs would rather invest in a html5 app. You don't need to deal with app market places and fixing bugs for each and every app (especially across different devices). Even the native apps use html to display some parts of the app. Honestly, most of the native apps I see are an overkill for what they do and most modern smartphone browsers are almost as capable their desktop counterparts. That being said, there is always drawbacks when coding for browser based apps as opposed to native. You always have to work within the browser security model, push/ajax, working with the DOM, loading 3rd party libraries, etc. But as a small time dev, I rather target mobile browsers rather than native apps due to resource constraints and learning curves. 
I just realized another potential problem related to dynamic XHRs per module. My 3.0 application has over 300 separate files. I'm a bit concerned about how long that would take to reload a page during development with that many files using XHR/eval. It's less than 1 second with normal &lt;script src..&gt; includes. Do you have any experience with projects with that many modules, and how long it takes to reload the page. That time is part of my inner loop.
&gt; There are countless of articles aaaand i'm done reading.
The template.js file is amd-compliant and NOT referencing window
Can you give a simple explanation of what it is? i couldn't find a demo on the page and the description wasn't entirely clear to me
It's ORM for mysql, postgres, sqlite3 similar to Active Record or DataMapper but for Node.js. It's similar to a project like http://sequelizejs.com but with better relation handling and transaction support.
[sequelizejs](http://www.sequelizejs.com) *^if ^this ^link ^is ^offensive ^or ^incorrect, ^reply ^with ^"remove". ^\(Abusers ^will ^be ^banned ^from ^removing.)*
Does anyone have a source for this? Anecdotally it's wrong. 
this scares me. I don't mind the pseudo classical pattern with constructors but this is going well beyond that. Have you tested whether this is compatible with javascript minifiers? I'm guessing there will be some problems with names being defined in strings mapping to properties
Is there any support for generation of stored procedures, or plans for it?
Ironically, I always hear people bitch about Apple wanting to cripple mobile web apps in order to force apps into their store, but the reality is that it's 10x easier to make a decent web app for iOS than for Android. The browser is better, the hardware is better, the tooling is better. Users can easily save a web app to their homescreen and it can seem like a native app. Android on the other hand, is a nightmare to develop for. The emulator is slow and crappy. Remote debugging is cool, but I'd like to be able to do that in the emulator. But then the emulator still just comes with "Browser", not Chrome, which is apparently different. And it's a multistep process to save a webapp to your homescreen, so users will never do it. If Google wanted to kill Apple's app store, they'd make the web developer tools for Android awesome and draw developers to the mobile web. They'd support web standards for doing things like push notifications to web apps, so web apps could be on par with native. But they'd rather push me into their app store. No thanks. I've been doing mobile web for about three years now, and I'm ready to say fuck it and focus on desktop apps. Android is the IE6 of mobile web and I'm fucking sick of it.
Ahh okay so a library that makes it easier to work with SQL selections in node. I might look into using it for a web server I'm working on when I get time.
I totally agree with you. Only thing Android has done better is to remove click delay. 
I see, but I don't think many people use require.js for dynamic loading. When you release to prod, you run the r.js compiler utility which combines all your code into one file. It auto figures out dependencies. In addition, you can easily use require.js AMD files in node.js with the require.js node plugin. It's an extra node require, but it works just fine. I would give require.js a try just to see if these methods work for you.
There's [browserify-shim](https://github.com/thlorenz/browserify-shim), which allows you to use non-CommonJS packages with browserify.
I'm curious, what would an API for that even look like? Does it exist in other libraries/languages? I'm the author of a different query building library ([gesundheit](https://github.com/BetSmartMedia/gesundheit)) and I've given some thought to how to best handle prepared statements, but stored procedures are usually much more complicated and use syntax that isn't available in normal statements, so I'm curious as to what the benefit of writing them in a JavaScript DSL would be.
I prefer cross-platform solutions, but not via HTML5. I mainly use Appcelerator.
I see you're using Foundation for your style. Is this the vanilla CSS version? Does the entire Foundation framework play nice with Angular? Any experience/tips you have would be great.
I have lots of ideas about how to go about it. I did some work on this at different stages before, generating both SQL Server and Postgres stored procedures. I concluded that making the full system how I wanted was too big a task to do at the time but have got plans for it. If there are other developers interested on collaborating on this then I could start sharing my ideas with them. I have written some JavaScript code that's a lot more abstract than most JavaScript code, and makes use of the MVC-like system (or JavaScript data structures with event binding) in order to accomplish tasks. It's possible to do the stored procedure generation in a variety of ways, here are two: 1) For each language, have code that generates SQL code that creates / defines the stored procedures / functions. This reads a (JSON?) representation of the database structure (rather than connecting to the database itself, to keep it more modular and usable in different contexts). It constructs various strings for CRUD functions using string concatenation , using the data model it has as well as data representing some instructions / indications of what it should generate, or extra information about the database structure that is not just simply read from the database. This would be good for generating a more limited set of SPs. 2) Generate stored procedures in an abstraction layer that then gets translated to statements in different languages. This requires translation layers between different SQL dialects, using programmatic objects that represent the SQL languages both as an abstract and in various dialects. This requires a lot of code, and would be an architecture that would scale well if it were well made, but it's a difficult task, but a very interesting one though.
&gt; You have to resolve the object before you can resolve properties on that object, Right, the issue is it doesn't make any sense to bring that up. The program must be parsed before you can do anything, but that doesn't mean the concepts of parsing and dereferencing have anything directly to do with eachother. &gt; Where did I say that? Right here in your first post, and a few other places: &gt; which means it is automatically inherited by descendent functions. &gt; I was pretty clear the scope chain and the prototype chain were separate things No, you weren't. You keep talking about functions "inheriting" scope; by saying something like that you are ipso facto confused about something in the process - whether it's what "inheritence" means, which chain is which, etc. 
Having stored procedure generation as part of the ORM lib makes sense from my perspective. It takes an object model and creates an RDB that operates more efficiently and securely if it uses SPs, and it's useful to the programmer to have the ORM layer provide a CRUD layer for dealing with objects that the database represents, which may rely on more than one table in the database. Making use of Knex to generate SPs makes sense, that could be the library that actually produces the code, however I advocate including the generation of SPs that work with the data model as part of the output of the ORM layer. 
&gt; Not exactly. No, it's pretty much exactly that. &gt; Can A see inside B? That question is irrelvent. The point I was making is that there's no inherent relationship between the two except that. Compare this to two objects on a prototype chain - that is expressing a different and particular type of relationship. &gt; This opens all kinds of possibilities that you appear to be ignoring because you are too busy limiting yourself to instantiation No, I'm pretty comfortable with functional programming and know my way around a closure. The issue here is you were using words incorrectly and I'm trying to help you with that. I'm perfectly aware that you can use closures to roll a system of inheritence. One issue is if you want to talk about that you need to be more specific and precise in your language, especially in a conversation about how there are a lot of programmers out there who are confused. Another is that this does not mean the concepts of scope and inheritence are somehow directly related, or that all closures are examples of inheritence, or that functions "inherit" scope, etc. You could also use arrays to roll your own inheritence, but I'm not gonna toss an unqualified "Arrays are a means of inheritence in JavaScript" at new JS programmers. 
I've also done some work on this, but not released the code, but would be interested in talking to other developers to continue it, and if anyone wants to listen to my advice and gets ideas from it integrated in an open-source (not GPL etc) library or framework then I would be glad to help with that. DSLs were not part of my thinking when working on this, or at least I was not thinking about that terminology being associated with that programming until now. I was thinking about what code would be specific to what functionality, and keeping various components isolated from each other so that it should only be a requirement to have an interface with the database in order to carry out interactions with it. Classes were written using some code based on John Resig's Simple JavaScript Inheritance that represent syntactic objects of various dialects of SQL, and I used a generic SQL dialect of my own as the base class. It's really an undefined dialect that only has its syntax tree and covers what the other ones have in common (and for the things they don't have in common options can be added somehow). The reason it's done in JavaScript is portability so it can run across platforms, both in browsers and node.js. This could be used in client-side query building tools.
i would think that on a global scale older phones are far far more prevalent than the latest greatest.
Everyone could shame Google into making a decent web platform on Android. (See my previous comment.) Developing web apps for Android sucks, so the perceived benefit of easy "cross-platform" compatibility is illusory. You make a nice iOS app and spend 50% of your time trying to make it acceptable on Android.
As cool as all the newer JS libraries/frameworks are, they add overhead processing from the browser/client as they're piled on. IF the weak link is mobile device processing power, mobile web apps may be starting a downward spiral. As a web dev, that bums me out.
Minifiers automatically convert bracked string-based keys to their dotted counterparts anyway. They don't actually change the keys themselves unless you turn on the advanced settings which is only possible when you compile the entire library at once, but it usually ends up breaking the JavaScript anyway. So when the minifiers are on their standard optimization settings, they work just fine and don't interfere at all.
Nice! So many new possibilities with voice recognition.
Writing a module to abstract object creation is a bit of a rite of passage. Here are a few suggestions in no particular order: - It'd be a little neater if you preserved more of the original JS syntax, so that `v = new Dog(80)` would do the right thing (or `v = Dog(80)` if you really hate `new`..) - Similarly, allow for "normal" constructors to be used with your library, for example to be used as base classes to extend. - Bonus points if `dog instanceof Dog` works. - some way to traverse the "inheritance" chain of your classes, with some kind of "super" members on your classes and/or instances, would be useful, particularly if your subclasses want to redefine yet leverage some methods from their parents. - your array detection code is a bit flaky, but it's arguably not the easiest thing to do correctly in JS. `obj instanceof Array` would seem to make sense, but it'd fail if your code crosses browser window boundaries. See https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray for a proper ES5 approach and an ugly polyfill for it. Those are probably your best bet. - `child.prototype = new parent` is generally not a great way to define inheritance relationships. Look into https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create (which has a polyfill for older browsers), which would allow you to do things like `child.prototype = Object.create(parent.prototype)`. To get constructor code running, you'd need to have something defined like `child.super = parent`, and have your child constructor include `child.super.apply(this, arguments);`, roughly. Also, that approach should let you implement your `properties` setup a bit more cheaply, since you'd move their definition at class creation rather than at instance creation. Some of those suggestions are a matter of taste, and can be ignored. Others have a bit of an impact on your library's ability to integrate with other code bases, or on performance, and should probably be given a thought. 
Ah ok, cool then! I like that JS easily allows things like this, it lets you look at problems in a new light. 
I don't know. I've thought those demos were insanely awesome for years but it always seemed like it was really complicated stuff so I never really got into it. I'd love to see some real-world usage though.
I haven't found this to be a noticeable problem and generally loading time has been dominated by some other factor, such as loading data. Often the app is also split into parts that are asynchronously loaded as needed, and so not all the modules are loaded at once.
Isn't the current state of the art in voice recognition *way* beyond needing do to this for such a simple vocabulary, even for a recognizer untrained for a particular speaker?
Spelling mistakes abound. 
I've been looking at doing something similar with some stuff for work. DOM lookups can be expensive, so instead of looking up an element during construction (it's a ui library), it could be better to defer that lookup until it's actually needed. 
I didn't see any transactions supported in sequelize last time I checked. The major difference with the relations is the ability to easily specify nested eager relations such as. new Posts().fetch({withRelated: ['comments.user', 'author']}).then(... and have it fetch all the posts, with all comments for each post, the user paired up along with each comment, and the related author for each post, only running 4 queries in all. Or if you want to fetch the posts, and then only load up one: new Posts().fetch() .then(function(posts) { posts.at(0).load(['comments.user', 'author']) .then(function(model) { res.json({ posts: posts.toJSON({shallow:true}), current_post: model }); }); }); Also, since the related models are keyed off methods on the model, you can do something like: new Posts().fetch({withRelated: ['admin_comments']}).then(... where the "admin_comments" would be constrained: admin_comments: function() { return this.hasMany(Comment) .query('whereIn', 'author_id', function() { this.select('id').from('users').where('status', 'admin'); }); } Last I'd checked there wasn't anything like that in other ORM/query builders, but I could be wrong.
Definitely, I really don't like the facebook app, in fact its slower than simply visiting Facebook with the browser.
Thanks, yes, this is correct... edited to reflect this. 
I would be curious to how this compares with D3.js for making web graphics.
For me, it was the "three WebKit browsers" comment. If your CSS is all vendor-prefixed, oh sweet Jesus you did it wrong.
Object.observe is really cool stuff! You should try to fork [Knockout.js](http://knockoutjs.com) with Object.observe and see how that would work. 
Everytime some developer who is used to Java, ObjC or any other language with classical class inheritance happens to stumble upon JavaScript, they instinctively try to fix a problem that isn't really there: their preconceptions about inheritance just don't work in JavaScript. Please, for the love of prototypical inheritance: fix your preconceptions, not the language you're probably just about to abuse.
Im still migrating my blog from portuguese to english :D One of my posts is half to half, sorry about that.
thanks... I dont know all the subreddits... still trying 
Wait, it's javascript and it runs in the browser?!
I would think the reason for the inconsistency would be that because it's local, you've probably already defined the variable (perhaps they initialize it to undefined explicitly). I've read before that you can change the value of undefined (I believe jQuery pass around their own undefined object around in their code) and so typeof would probably be a better way of doing it IMO too.
I was thinking of forking AngularJS with it. Mostly because its core is highly geared towards two-way data binding.
Nice - can see it being useful for making more interactive graph visualisations: re-clustering graphs based on a selected node etc.
probably not. You'd only use it if you're working on a large codebase with developers who only understand classical inheritance - and even then consider if it'd be easier to teach them about prototypes.
I used [Karma](http://karma-runner.github.io/0.8/index.html) for a test runner. You can see the setup under my [Backbone.Advice](http://github.com/rhysbrettbowen/Backbone.Advice) repo. The big plus is it also gives you test coverage results. 
what frustrated me a lot with my time on it was that each view had to have a template, what if the view is some sort of direct parent (two simple dom elements) to another view? so it didn't make sense to me and i fought to no ends against marionette on this(i understand that i could have used plain old backbone views but whats the point of using marionette by then if i don't get the niceties it provided). That meant i always had some extra mark up just to get a parent -&gt; child relationship between two simple dom elements. tbh i might have been thinking about it wrong and just didnt see it the right way, so im not saying that i'm correct or anything.
What're the merits of using `child.prototype = Object.create(parent.prototype)` over `child.prototype = new parent`?
It relates to graph as in graph theory. You're thinking of *charts*.
Yes, but can it run in an INTERNET browser?
agreed.. I'd be hesitant to support something like `this.super.doStuff(arg1,arg2)` since it'd require binding methods on every instance, and not dealing easily with dynamic added methods on parent classes. My happy middle ground would be to just define `super` on both the prototype and the constructor, where `child.super = parent` and `child.prototype.super = parent.prototype`. That lets you use `Dog.super.apply(this, arguments);` in the Dog constructor to use the Animal constructor, and `this.super.vocalize.call(this)` in the overridden function. It's fairly minor, but it's cheap, and it avoids hardcoding the relationship between Dog and Animal more than it needs to be. 
That article is about ten times longer than it needs to be. 
Bah! browser sux, lets go back to Node.JS -.-
pretty cool. I would like to remember to use this when needed.
god why... why
A for execution and for annoyance .
I think it'd be a lot nicer if there could be an argument for max length (instead of one word at a time), so it would take a bunch of smaller words and display them all (up until the max length). 
Congratulations, you've made me nostalgic for the marquee and blink tags. At least I could disable those.
Loving this, man. Looks and feels great. Snappy. Responsive. 
That's definitely a worthy suggestion. You could probably split the text in a number of ways if necessary. An effect like this is great for short phrases. So in most cases you could just modify it to accept an array of strings. If you were to animate a whole paragraph like this in the real world you'd see more comments similar to the others on this page;) 
Thanks. 
While I haven't used it yet, the newest release of Mocha has a coverage reporting type. I'll have a look at your repo though, thanks.
Why would it be never? If you're catering to the entertainment industry, this is just one more tool in your arsenal. Obviously, don't use this for local restaurant menu but what's wrong with using this while the demo of your new game or trailer for your short-film loads? Better than yet another spinner.
Awesome, I love it...
Thanks ! Well the output should be an amount of money that keeps increasing towards the final goal as time passes. like... 2000.00 $ then 2000.01 $ 2000.02 $ etc... Until it reaches the final amount of 200 000.00 $ on the last day. Your example gives me a different amount for each day, that's not exactly what i want. Altough it gives me clues, thank you. Here's what i want it to look like, but instead of time, i need an amount in dollars : http://demo.tutorialzine.com/2011/12/countdown-jquery/ Also it needs to count up not down obviously...
This is so cool!
 &lt;div id="output"&gt;&lt;/div&gt; &lt;script&gt; var start=2000; var end=200000; var startDate=new Date(2013,4,1); //midnight on may 1 2013 var endDate=new Date(2013,4,30); var currDate=new Date(); var dateGap=(endDate-startDate)/1000; var moneyGap=end-start; var moneyStep=moneyGap/dateGap; //per second var currentMoney=((currDate-startDate)/1000)*moneyStep; setInterval('updateCount()',1000); function updateCount(){ currentMoney=currentMoney+moneyStep; if(currentMoney&gt;start&amp;&amp;currentMoney&lt;end){ document.getElementById('output').innerHTML='$'+(Math.round(currentMoney*100)/100).toFixed(2); }else if(currentMoney&gt;end){ document.getElementById('output').innerHTML='$'+end.toFixed(2); }else{ document.getElementById('output').innerHTML='$'+start.toFixed(2); } } &lt;/script&gt;
Where do you see that this is by Google?
What does 1000 represent in this equation again? Sorry if i'm being dense...
Here's a fairly simple way to do it. function ratioBetweenNowAndDates(start, end) { var now = new Date(); return (now - start) / (end - start); } setInterval(function () { var startDate = new Date('2013-05-01'), endDate = new Date('2013-05-31T23:59:59'), startPrice = 2000, endPrice = 200000, dateRatio = ratioBetweenNowAndDates(startDate, endDate), priceRatio = dateRatio * (endPrice - startPrice); document.querySelector('#amount').innerHTML = '$' + priceRatio.toFixed(2); }); 
You taking the time to code this is very appreciated. Have some gold !
That's an impressive effect - very clever. To those dissing it because it'll be annoying, you're missing the point - this is an experiment in animating text in a new way using Javascript. How you use it is up to you. If you choose to use it for something annoying and pointless, that's your fault - not Javascript's and not this guy's.
Hey, that works too... :)
The lead dev works at Google and if you go to the contribution guide page it directs you to filling out the Google CLA. But there is no official branding and it is dangerously similar to AngularJS so I am skeptical Google is putting many resources behind this.
I couldn't have said it better myself. Thanks for your support.
You are welcome! I commented on your blog post, but it didn't appear (now it appear), so I posted here, since it is such as promising library. 
Being created by Googlers means there is some good technical talent driving a project, but it certainly doesn't mean that the project is *by* Google.
I had the same thought.
The pricing changes haven't affected me one bit. Some of the stuff that will be coming to the non-free tiers is kind of cool, but nothing I need. I even use the hell out of the "explorer" package on their cloud services. A recent app I just published is hosting about 500mb of m4v's in their cloud for free. For me the biggest advantage was javascript. I came into App Development from a very weird background (linux/windows servers, networking, repair, jr level web designer) so it was a MUCH easier jump than say Java or Objective C. I managed to learn Javascript concurrently alongside Appcelerator, I don't recommend it. But with that said, I probably have come across every gotcha or weird thing about Appcelerator and I'm confident in saying that all the resources are out there to overcome any issues; its a great community. For iOS development it really is a joy and you can bust out some decent looking apps VERY quickly(and beautiful apps if you put the time into it like anything else). They've released a MVC framework based on backbone called Alloy that people are really seeming to enjoy that also seems to speed up the process a bit more and offers another avenue for separation of concerns. Android development, in my opinion, has only really been viable in the last year and a half with Appcelerator...at least as a FULL cross-platform solution. Once they implemented the commonJS spec and started to expose all the new Android UI API's it became a lot easier to go architect the application from the ground up with both platforms in mind in a single code base. Before that I was using 2 code bases but still reusing 60% of the code and almost all of the business logic. I haven't explored the Blackberry support and probably wont until more than a couple clients ask. Their Cloud Services called ACS (formerly CocoaFish) is pretty nice for a lot of things, I've built an internal social network(ish) for a school solely on ACS and so far I haven't even touched 15% of the amount of API calls allotted a month. It's a lot like Parse or other services similar to that. For a cross-platform solution, I'd say its the best one.
Sweet relish mixed with diamond potatoes, this looks pretty cool!
Very cool. I'm sure it will be overused, but today I want it.
Not sure if you were being sarcastic but it's more accessible than video. JS can be easily parsed. Or if you modify this a bit, the source text could come from a &lt;p&gt; element. As for UX, it should be fast, work smoothly cross-browsers, and be entertaining - which is when you should use this. Do not use for this "Loading... Hospital Patient Data... Now... Directly... Using your SCI Login..."
I really appreciate your response. You have convinced me to go ahead and check it out. Thanks a lot!
Please check your spelling. "shoud" should be "should", for example.
...but it doesn't show the second decimal when it's a 0.
I couldn't help but hear it all read in ***Super Serious Movie Announcer Voice EXTREME***
The UI is not so intuitive for me but I'm highly interested in how you synthesized the violin .. My knowledge about audio synth is very very limited, I didn't find on the net information that's useful for me to implement it. On the other hand I was able to synthesize plucked string audio using strong-karplus algorithm relatively easily. I just had to understand the algorithm ... (without understanding a whole lot about the underlying theory).
Glad I could help, let me know if you have any questions.
Hey @selyria, Check out this enhanced version that intelligently groups words together: http://codepen.io/GreenSock/pen/sxdfe
Good stuff. If you could add support for logging in and commenting, that would be cool. The back button in the top left of the Article page doesn't seem to work on WP8, but my hardware back button does so no big deal.
It's also supposed to be announced at Google I/O this year.
If it does have any Google official backing (probably not based on their FAQ), then I wish they'd all just put more people behind AngularJS. Although not being burdened by the past is a nice thing occasionally, I think one of Google's faults is always trying to make _new_ frameworks instead of putting more effort into their existing (good) ones.
Nice! Unfortunately, Object.observe is slated for ES7 now.
Better than &lt;blink&gt;†
Good one! I hadn't thought of using it outside the browser but that is just limited thinking on my part. I'll make a note to add npm support and server-side loading!
Britains/(Americas) Got Talent voice over guy. 
This seems like they are reinventing dojo toolkit?
How would you inherit a component and override the template or script aspect of it? As painstaking as it is to develop in Qooxdoo, I'm afraid that having all of your rendering logic in methods allows for the most control over refinement of rendering. That is why both this and AngularJS are limted in their ability. Cute, and interesting but simply not as powerful as Qooxdoo.
No, we can not! ;)
Here is a better way by using $.proxy() or Function.prototype.bind() : (function($) { // utility function function proxyAll (object, methods) { var proxy = {}; $.each(methods, function(key, val){ proxy[key] = $.proxy(val, object); }); return proxy; } // constructor function createBuilder() { var privateThis = { hiddenText : 'secret' }; privateThis.proxy = proxyAll(privateThis, methods); return privateThis.proxy; } var methods = { method1 : function () { return this.proxy; }, method2 : function () { return this.proxy; }, }; window.createBuilder = createBuilder; }(jQuery)); createBuilder().method1().method2(); In the above, I used jQuery.proxy(), but you can easily replace it with Function.prototype.bind(). It is a superior pattern for the following reasons: * "private variables" are a lot easier to manage than the traditional way (using "local variables") because you don't have to be in the same closure to access "this". * You can allow extensions on the method list by doing something like $.extend({}, methods, thirdPartyExtensions) * Your private variables are hidden unless you allow for extension. In fact, even if you do allow for extension, you can give 3rd party methods a different "this" context. 
lol =/ It was a typo that I copied to everywhere.
Is there another typos ?
Oh. Good. Yet another framework.
Hmm. Announced, the subject of a class, or both? They've taught classes on stuff that's not theirs before. 
Not in a situation to try it out right now, but I just wanted to compliment you for 1) the nice website and 2) what is clearly a lot of thought and effort that went into the library and design. As a C# developer it looks very comfortable. I hope I'll get a chance to try it out. Thanks!
Hmm... I'm not sure if classical inheritance qualifies an entire library... _extend = function (classes) { var subClass = classes.child; var baseClass = classes.from; /** * A function used to extend one class with another * * @param {Object} subClass * The inheriting class, or subclass * @param {Object} baseClass * The class from which to inherit */ function inheritance() { }; inheritance.prototype = baseClass.prototype; subClass.prototype = new inheritance(); subClass.prototype.constructor = subClass; subClass.baseConstructor = baseClass; }; Primitive = function (config) { /* Private properties */ var _self = this; this.Initial = []; this.Create = function(params){ _self.Initial = params; //TODO: stuff... }; }; Derived = function (config) { /* Private properties */ var _self = this; //ctor Derived.baseConstructor.call(this, null); _self.Create(config); };// subclass of Primitive _extend({ "child": Derived, "from": Primitive }); var d = new Derived([1,2,3]); d.Initial; //[1,2,3]
Perhaps you should take a look at all the features offered then, because it certainly takes a lot more lines than that for everything that is in there.
I took a look at the type-checking and casting... &gt;Type-Checking &gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. &gt;Casting &gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 
Oops, looks like I copied an older language resource file online. My apologies, thank you for finding that!
How many times are you going to post about this? At what point does it cross the line into spamming the subreddit?
[fixed it!](http://codepen.io/anon/pen/leKbh)
You don't feel that with the number of tools in the Dojo toolkit, you could say that about *any* web framework that comes out?
http://www.reddit.com/r/javascript/comments/1e996r/jtypes_solving_the_javascript_inheritance_problem/ - this was posted yesterday by noffke1234 and received rather negative feedback. Actually, this was the only post by noffke1234, so I believe this is a throwaway... are these accounts maybe related?
The contract also states that in order to contribute to an open source project, you must get clearance to do so, which is essentially a legal release that the company doesn't want it. The fact that they are publishing this under their own names and not Google is a good indication that this has happened.
haha, maybe but it was my first reaction when i looked at it.
I rarely speak against Javascript libraries but i have seen so many posts about this library that i think i have to say something This isn't really something the average JavaScript developer should have a use for, it sacrifices readability, performance and flexibility of objects for a code structure that doesn't fit the OO model and it doesn't take much to implement the functionality of creating an object with the same structure as an other. There is a reason JavaScript doesn't have classical inheritance, it's because classical is in many ways inferior to prototypical. It's much simpler to code without classical inheritance and in most cases your code is going to be smaller and since the prototypical is dynamic it fits very well with the dynamic nature of JavaScript.
My understanding was both.
Nice. Though you know browserify used to have this --watch feature that did all of this stuff for you. Unfortunately with v2 it got taken out, and build times suffered accordingly.
I chose your script in the end because i found it really neat. However, it doesn't seem to work in Internet Explorer... Any idea why? Instead of numbers, it just shows the letters "NaN".
I would like to point out that Intellij actually has some pretty nice plugins for javascript development. You can actually rename variables, extract methods, etc. It can't do all the same analysis that it can on statically typed languages, but in my experience it is quite a bit better than plain text editing.
updated the code to round properly...i think this is a better implementation because when you return to the page at a later date it will still display the correct data.
I was wondering, do you guys ever validate your scripts with Jslint? Because i tried it with your code snippets and i get a bunch of errors :/
Yes... Good. I hope more are developed.
Damn, this library is huge. 89kb for modern browsers, 123kb for non-modern ones? I think that is everything. It might be super powerful but it seems like overkill for most projects.
Your script is the only one who works in IE8 :) Congratulations. The only thing i liked better in pmw57's script is that we see all the seconds flying by... how does he do that?
i work with IE a lot and it's the most frustrating part of my day...I try and code with the most basic functions I can because I know anything weird is going to freak out ie.
The idea is that it polyfills things which the browser should do, so as things progress it should get smaller
I understand the concept, but it seems like it goes to such an extreme that it'll hinder adoption due to being so large, especially if you're trying to be mobile friendly.
I don't think that this is a fair jab at Angular (I do not have experience with Polymer). You allude to rendering not being done by method but that is exactly what the compile / link functions of a directive do. Rendering in Angular isn't just {{substitution}} and stating as fact that it is is misleading.
This title is incredibly deceptive. This has nothing to do with google and certainly isn't "by Google." If you want the web framework by google, try angularjs. &gt; How is this related to Google? &gt; We’re first and foremost just a group of folks who think web components are the bee’s knees–a bunch of us just happen to work at Google.
Almost responsive. It doesn't use a truly fluid layout. Look at it on your desktop browser.
I don't follow your reasoning, or agree with the statement that SPs are 'session dependent', as they can exist in the database and stay there in between sessions. The ORM layer could write the stored procedures, and put them in the database as a setup procedure, and then assume they are still there when the application calls the procedures. It's possible to think of the mapping as being from objects to different possibilities of databases with different kinds of structures and APIs for accessing them.
It is weird behavior. It works but sometime once you scroll, it will stop working. I don't have WP8, so I went to ATT store to try it out.
I do use it on my desktop browser. What do you mean by truly fluid layout? Screenshot would be more helpful.
&gt; I prefer to use underscore.js so that I can use the wonderful functionality even on old browsers. Which, thankfully, right now [is only IE8](http://kangax.github.io/es5-compat-table/#Array.prototype.map), about [10% of the web](http://theie8countdown.com/).
Didn't know that. Why did they take it out?
The layout isn't flexible. You are using pixels rather than percentages and ems. In short, it "works", but it isn't responsive, which I think is what you may have been going for. http://imagebin.org/257772
You should clean up the code samples. Add spacing like "for(var i=0; i&lt;10; i++){} Also, add the output text that's generated from the code samples as a comment in each block. 
Please name me a single other framework which uses *any* of the following standards-in-progress: * Mutations * Custom Elements * HTML Templates This is a pioneering framework for the standards being pioneered. Also: our existing frameworks all suck horrendously &amp; aren't worth a fig, so thank god.
hahaha that was not my intention. It was just a compliment
[Here's how Jinja2 allows you to override pieces of a template](http://jinja.pocoo.org/docs/templates/#template-inheritance): it's a reasonably elegant way of allowing different pieces of a template to be named and overridden by children using only templates. I don't think programmatic construction ought be necessary and this goes somewhat to show that, but I also don't see where HTML Templates or Angular come in to help in this arena, and that definitely needs to be addressed in some way. What this does do is decouple the template from the registration of the template. If there's code, that code can be shared across multiple templates but each template will have to have it's own independent HTML Template backing it. If these individual templates have common stanzas that need to be shared, you can go about it by using HTML Import to reimport that same stanza in each template. Agreed that this is suboptimal, that it lacks the elegance and growable structure of template inheritance. Inheritance is one semi-complex behavior, the other that I'm very curious about is calling templates. I don't think Jinja2 has an answer here either- how do you pass in complex, multi segment templates? Can templates accept multiple different HTML stanzas, multiple pieces, which will get put on the page in different places? Regarding your comment, it took me considerable effort to get around your slanted biased view &amp; to dig in to your arguments. The last paragraph, was a huge turn off even though I don't necessarily disagree. Talking about the capabilities is really interesting. Using that as a synopsis for why apples are the best was for me very off-putting. That is why both this and AngularJS are limted in their ability. Cute, and interesting but simply not as powerful as Qooxdoo.
Good write up, thanks! `_.map` the function that makes `_.pluck` possible in underscore has saved me lots of work heaps of times. A write up on `_.pluck` might be nice too.
Backbase did pretty much everything Polymer does back in 2006. Shame it never caught on.
I don't know about Jr. JavaScript developer. Generally employers are looking for master level whatever your specialty is. When I started as Lead JavaScript developer on the west coast base salary was 120k.
Angular is it's own beast, beholden to nothing. This is a demonstrator framework for the standards Google is driving. Whether Polymer continues to gain attention and momentum or not, Google *is* driving a wide range of standards it intends to drive the web forwards with and Google needs frameworks out there exploring how these standards will be used. Thusfar Polymer is the only framework doing that.
@itsnotlupus - Would you mind explaining to me why `child.prototype = new parent` is generally not a great way to define inheritance relationships? Matter of taste, ability to integrate other code bases, performance, and/or other?
As I don't use underscore a lot, I usually achieve the same by defining "prop" (a factory that returns a function that extracts the property value). In that case I end up with something like `arr.map(prop('name'))` which isn't too ugly. Sure, pluck is shorter but this is composable. You could then build something more complicated on top of that if you wanted to.
Both in memory and using web workers, interesting. I'd love to get a high level writeup on how this works- is there a single shared worker holding the database and doing all the graph navigation?
This looks like some boring ass CMS. I have no idea what grounds you are standing on when you make this claim.
Look at the replies at [/comments/1e9ncv/a/c9ykikd](/comments/1e9ncv/a/c9ykikd) for some explanations of the downsides. The core issue is that, when used with non-trivial constructors, it will not do what you expect an inheritance pattern to do.
Polymer project has some superficial resemblance to Angular in that it uses HTML templates, but it's build around web standards (HTML Templates, HTML Import, Shadow DOM, Custom Elements, DOM Mutation, Object.observe). Go with Angular if you like it, but I find Angular frustrating in that there's not a lot of practical guidance on how to make good isolated directives (their components) with it, and most applications I've spotted end up a giant hodgepodge of code. Certainly Knockout or Angular would benefit from Object.observe, if you're looking for un-pioneered ground to break. If you want some peers about, I'd suggest, perhaps, give Polymer a shot.
(as always) that's 10% of the *public* web. If you've got corporate customers, you may well have to support all the way back to IE6 -- but hey, your project manager should communicate those requirements.
Quick questions : I'm going to have to change the dates and amounts to : start : May 31 2013 end : December 31 2014 and the amounts : start : 48 664$ end : 200 000 $ My question is : will it still work ? Also : why is the date for May 1st : 2013,4,1 ? isn't May the 5th month? Or is it because it's an array that starts with 0 ?
Did you know that `Array.prototype.reduce` [is already built-in](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce)? I'd recommend not to overwrite it, especially with a function that doesn't implement the same behaviour, since other libraries might expect it to be there.
it will work and the array for month starts at 0...so you subtract 1 from whatever month you want to use. December would be 11.
It *is* a boring ass CMS these days. A CMS for banks. Apparently there's more money in that than in selling commercial JavaScript frameworks. I worked several years at Backbase and implemented their framework in dozens of projects. It had many of the features that Polymer had. Custom tags, imports, data-binding. The whole thing with the shadow DOM is pretty much a carbon copy, up to the &lt;content/&gt; tag. It's a shame, really. The framework had a lot of potential. 
You nailed it, well done &amp; thanks!
I ... probably learned that at some point, and then I forgot when I had to go back and shim it into IE8 =\ thanks!
Not completely sure. I think the goal was to make it more modular and smaller. The idea being that you could emulate this using a transform or something.
&gt; while every instance of parent would get their own state, every instance of child will share a common state This will only be the case if you set state within the parent's constructor and never change it again. Changing an owned property after construction will not change other instances. function Parent() { this.state = {}; } function Child () {} Child.prototype = new Parent(); var c1 = new Child(), c2 = new Child(); console.log(c1.state === c2.state); // true c1.state = 'cats'; console.log(c1.state !== c2.state); // false
o wow...thanks man...i can finally see what all the hype is about! 
I should have been clearer. My example was intended to use the `state` member as a container for other stuff. For example, with `c1.state.age = 3;`, which would break things. Still, you have a point. There are a number of cases where assigning a parent instance on a child prototype will not break things, be it by sheer luck or deliberate design. The mere fact that it will break under some scenarios is hopefully sufficient to discard it as a valid general approach to be used in libraries. 
sweet, i knew it could be done cleaner. just a hack attempt at the end result i wanted. Thanks!
I liked your version because you could see all the seconds go by, it was cool visually.
There are further cross-browser changes that need to be made though. Working on it now.
I was actually wondering this myself today. I've had people recommend books to me but there has to be a good course online somewhere. I really liked CodeSchool's jQuery courses but wish there was one for straight JS.
Instead of explicitly setting the endDate, I'll come back by one second from the next day, which is a more compatible way of doing things. So we end up with: function ratioBetweenNowAndDates(start, end) { var now = new Date(); return (now - start) / (end - start); } setInterval(function () { var startDate = new Date('2013/05/01'), endDate = new Date('2013/06/01') - 1, startPrice = 2000, endPrice = 200000, dateRatio = ratioBetweenNowAndDates(startDate, endDate), priceRatio = dateRatio * (endPrice - startPrice); document.getElementById('amount').innerHTML = '$' + priceRatio.toFixed(2); }, 50);
I was just experimenting with the new ES6 Object.observe. I have no desire to write a library or framework.
Not a CS major, I hope. ;)
you should look into AngularJS
I dont think you have a good understanding of AngularJS.
What does this mean?
In case you're not aware, [@horse_js](https://twitter.com/horse_js) is an excellent Twitter user to follow.
Meh. Just a simple usage of Three.js. Keep working on it though!
Very cool. I'm still quite new to javascript and wish to one day be able to make something like this. For now, though, I'll have to stick with replacing text dynamically, lol. 
He's likely hoping that learning javascript is not a requirement for Computer Scientist majors at a major technical university, or that it is their main programming language. Seriously, I'd cry if I found out a big college's main computing language was Javascript. Or for that matter, any language - scripted or compiled - that is run against a browser (instead of an actual Operating System like it should).
&gt; (instead of an actual Operating System like it should). Can you explain what you mean by this?
j/k, you've got some relative links to other js components that others don't have, if you were trying to demonstrate the code you wrote. If you didn't want to demonstrate the code, then full marks!
Good point. Will do that tonight.
The course is called Web3D and Graphics Technologies. I'd cry if Javascript wasn't taught in that course.
Not getting any sound here, unfortunately. Windows 7 64-bit; Chrome (Version 27.0.1453.81 beta-m)
At this point, your browser *is* an OS.
If you develop anything commercial, 10% is way to much to ignore. :) Most businesses have profit margins lower than that, so cutting another ten percent isn't a great idea.
that's a good place for js to be taught. I'm not saying it shouldn't be taught...
_.pluck is absolutely essential in data manipulation.
Yes, you can change the dates and the amounts. The 50 at the end is to update things every 50 milliseconds. Use 1000 if you want it updating only every second, for example.
That's a right good horse, mate. Thought I was looking at the real thing for the first few hours.
Just... Stop it. Please. For the sake of humanity, just stop it. Clearly you put a lot of work in to this library, which I can admire, but there's no reason to force a prototypal language to use classical inheritance. Classical inheritance is a great solűtion for some problems but fails in the land of JavaScript. JavaScript has a *beautiful* system if only you can Ōpen your ëyȩȿ and stray away from classical thinking. There's a bright and wonderful world out there `void` of the constraints of typical ȼla`$$`es. No longer must we `bind`^^^.on('end-of-life') ourselves by making explicit contracts ⅍ we did in the past (unless He so desires). **Li**fe is too `short` *^^^it's ^^^so ^^^C#old* to waste טסr lives on forcing a **lᴁ**nguagᴟ to do things that it doesn't need to do. Making [ЈДΛдϨЯЇΡΤ](http://www.deadseascrolls.org.il/explore-the-archive/image/B-314654) *^as ^the ^ancients ^called ^it* do classical inheritance summons **[Abaddon](http://en.wikipedia.org/wiki/Abaddon)**, the [`delete`]er. He ʁǣps your *p*r*o*t*o*t*y*p*e* ʗЊiN in order to preserve his `ORDER` *^^^weep ^^^for ^^^the ^^^children!*. the рrΦtΦtҰҏє of which `$` and `_` were born, **an**d th***er***eby мʊʗʰ of crǢtion ^^***HE*** ^^***KNOWS*** , is [loch](http://www.wired.com/images/article/full/2007/08/loch_ness_monster_580x.jpg)ed ΔЩΔУandforced to toΩϚh itself ***over*** ^and ***over*** again uЍtΐ Γ ~~ϻΛᵴᵵᶓᴦ~~ ᴙᴲᵓᴲᴵᵛᴲ**s** ***HIS*** **^^^^NO ^^^^PLEASE ^^^^GOD ^^^^WHY** answer. ᴆᵒ u ԊӠΆƦ `them`? țȟȨ ▓██▓▓▓█▓▓ סּḞ [ĎƎǍŦĦƾ](http://youtu.be/26YLehuMydo) cœld ƐƜƂƦåçė *^we ^never ^had ^a ^chance*. yØÜr `private` ϧ◙░⌠ is ~~₮orn~~ ~~t~~o ₴♯ṟệⱭ*s* by mere `public` ḿ•~~rt~~als ***THE CHAIN MUST BREAK*** ₩^~~h~~ Ữ**†** ʰ˄˅ɘ wɘ **~~ᶁΌ₦Ἕ~~?** [▓ █▓ █▓▓ ☻ ▓ █▓ █▓▓ ☻ ▓ █▓ █▓▓ ☻](http://www.biblestudytools.com/vul/revelation/22-13.html) ***[WEEP](http://youtu.be/bY1xbDm-tyE?t=8m22s)*** *[Inspiration](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)*
occasionally it is pretty funny but I confess sometimes I either don't get it or think its stupid
Such a misleading title :) I read "map reduce" which is very different from "map and reduce" 
They just don't know how to cook apps (http://www.sencha.com/blog/the-making-of-fastbook-an-html5-love-story).
demo felt slow as hell
For some reason I found it hilarious and had a good laugh. Thanks for posting.
I see. I probably should have played with it first. My apologies. It works flawlessly on iOS. 
[NodeJS](http://nodejs.org/) runs on your OS, though I don't see what the environment a language runs in has anything to do with it's teaching/learning merit.
The title is incomplete, it should have been "Building a Full-Text index for PDF files in Javascript". And it doesn't take one thing into account: fonts can be "[subsetted](http://community.zmags.com/articles/Knowledgebase/Difference-between-full-embedded-fonts-and-embedded-subset-1277814749518)", with as a likely result that the character code of the characters changes. In that case it's not possible to extract text, at least, not comprehensible text. (Caveat: At least that was the case when I last looked at the guts of PDF files, which may be up to 10 years ago...)
There are many localStorage/cookie facades out there, but for the sake of learning I'll point out a few things. - You should separate interface and implementations (localstorage/cookie). - Don't assume user wants to store only JSON data. - Remove jQuery dependency. - Some methods and variables could be named better... but that's just nit-picking.
Probably something to do with the massive amounts of traffic it's getting slammed with
[i'm sorry but I lost your horse](http://imgur.com/rsxc7Cl)
I assume I am just missing something obvious, but I installed brackets and theseus, and followed the instructions on the github page, but I see no theseus debug window, neither in brackets, nor in chrome. Any help?
Agreed. In my opinion it becomes even more useful when you can target nested properties like in Boiler.js's implementation: var colors = [{color:{vals:{hex:'FF0'}}}, {color:{vals:{hex:'0F0'}}}, {color:{vals:{hex:'00F'}}}]; _.pluck(colors, 'color.vals.hex') // =&gt; [50, 50, 50] [Boiler _.pluck API](http://www.boilerjs.com/#api_pluck)
a good roundup, I also like the GNM acronym. I believe that requireJS goes a bit far, at the moment a lot of people think that all code needs to be in an IIFE which is just not true if you control the page. It may be that way for webpages that pull in a lot of 3rd party libraries, but in an application you'll be just fine putting in a namespace with modules under that (or even a namespace per package). Just look at Closure Tools, it's dependency system is used for things like gmail which is a larger SPA than most of us could dream of building and it uses the GNM with no problems.
Why not just use an IIFE with AMD and keep things clean and safe? I see more than enough problems with GNM and no clear advantages. 
Could you go into a bit more detail concerning the problems with GNM? You can wrap a GNM module in an IIFE too, can't you? Expose API on a global namespace module and IIFE wrap the code that does that. Of course you might hide some implementation details you want to unit test that way, but I prefer to unit test my public API anyway. 
No, its all good. That made me thinking to have something on right side when you load first time. I haven't figured out what should I do. one idea is to put about section and it will only show up first time when you load. Once you click on story or comments, it will go away. 
I don't like the idea of 1) modules modifying anything global, 2) modules being able to use modules without declaring them first. Being able to load different versions of the same library is sometimes very useful. It might not sound very important, but where I am we are programming a large application with lots of components that need to get along and not kill each other. AMD has been a godsend. 
Thanks for going into more detail! I can see the point of wanting modules to declare they need other modules explicitly. Being able to load different version of the same library is a use case I haven't run into yet but I believe you it can be useful. "Modifying anything global" is not something I worry about much, as long as a module is well behaved and only touches its own namespace. If you have undisciplined modules that touch all kinds of stuff then introducing AMD can help, but introducing namespace discipline (with IIFE wrappers) can help too. Modules will also get along and won't kill each other. 
Managing script tags is an absolute nightmare when you have modules which depend on other modules. In big systems it is just not practical. 
Agreed that managing script tags is a nightmare in big systems. What I'm saying is that are non-requirejs systems that use GNM that load the right dependencies for you too, like MantriJS. 
I don't think modifying something global isn't a problem just in GNM, that is always possible. The only global thing here is a single namespace is setup, and it's setup for the module by the dependency loader (in the case of mantri). If you name your modules like you do your file structure then you won't have any problem, and in fact it'll be easier to find the modules you want based on the namespace that they are in. You also have the ability to use modules not declared with requirejs if it's a global. This is also not a problem. When you want to use a namespace you declare it at the top of your file. Also it's simple to change the module you want to use (for mocking and testing) all you have to do is override the anmespace with a different object and you're fine. GNM scales very well. Because each time you add a namespace that has in it as many namespaces as you need. You can have as many paths as you need. The point about access to other modules I was making is not the access from within another module but from your debug console. Sometimes global is a good thing, you just need to organize it correctly. If anything it makes you think more about good code organization than AMD and if you use it properly I guarantee it will take you less time to develop, debug and deploy
this actually sounds like a case for globals. There are libraries you can use to see when a global is changed so you know when a global is being overriden, however in requirejs you can't tell where a module is coming from during runtime. In GNM you still declare that you are using the $ namespace and a system like mantri will only pull in one file that declares it uses the $ namespace. If there was more than one then it would error and you'd know to only use the one. With requireJS you'd still have the issue if you used other jQuery plugins that didn't conform and to fix it you'd have to declare which plugins used which versions in the config and even then THEY use the global. So the issue would remain in require where as something like mantri would have told you it was incompatible straight away. I'd suggest you give something like mantriJS a try and you'll be amazed how much easier dependencies become. I've used Closure Tools in the pass and am currently using requireJS at my new company. requireJS works okay, but there are issues when we move around modules and getting it going with a test runner was hell. Even now there is the occaisional problem when a module is pulling in an old module from a path whereas if we wee using Mantri there would be no issues and debugging would be a whole load easier
other keys also worked. i tried a bunch of the alphanumeric keys
Seems very similar to Knockout.js As I commented on another such library, you should make the signals support the functional programming methods of arrays, like `map`, `reduce`, `filter`, `some`, `every`. Currently you have to use the following syntax to map an array: var a = Signal([1, 2, 3]); var c = Signal(function(){ return a().map(function(v){ return v*v; }); }); it would be much better with this syntax: var b = a.map(function(v){ return v*v; }); If you then push a new value onto a, you don't have to map the entire array again, since you know that only one value needs to be mapped (the last one you added). 
If anyone here watched the Google IO talks happening now, I think it really makes an awesome case for Polymer. I love AngularJS, but I might actually want to move toward Polymer since it has a lot of the same functionality, but working toward web standards.
If this had a memory inspector it would be monumental.
I'm choosing your script in the end. Have some gold !
You're entirely right about the side navigation. I used to have if fixed but I was running into a lot of problems on mobile devices and so I refactored to the more basic version you see before you today. ... My intent is to make a fixed navigation (that is 100% cross platform compliant) in the near future once I can find the time. No, I didn't use a specific tool to generate the API... just a little custom fix I came up with on my own. Thanks much for your feedback!
When I try that it prints true. 
Woo, I was worried that it might have been a regional thing.
Let's take this aspect of the example code for "Binding between components and native elements" - nameChanged: function() { Notice that `nameChanged` aspect of the component? What if other objects want to subscribe to the event of the name changing and perform behaviors based on it? How would you do that? 
I'm sorry if I seem like some sort of Qooxdoo crusader. Thank you for your comments.
Thank you sir, that's much appreciated.
That changed effect only exists in the context of the element encapsulation (the inner world). The outer world can see that change by observing the element instance (via polymer binding in the outer context, or with knockout.js, or any other way you like to do it). This is one of the Good Parts, you can isolate semantics inside the element.
Polymer "announcement" at Google IO: https://www.youtube.com/watch?v=0g0oOOT86NY The web components talk that precedes this one is also a great watch. (Polymer wasn't exactly announced at Google IO but this presentation followed the rebranding announcement from the Toolkitchen name by just two days.) *Edit*: updated YouTube link; they replaced the 10-hour live stream archive with a individual cut videos.
Wow, this looks fantastic. Thank you for going into such depth. I am going to read over this again and again and again to learn all I can off it. I really appreciate it!
But even hovering over an element on the left is delayed significantly. This should be as simple as a CSS :hover event to change a background color. Wonder what's going on to make it that slow. http://www.commafeed.com/#/feeds/view/category/all
&gt; they are also only available in the scope they are created in. Very true. I just thought this was more obvious. Personally, I struggled with the difference pointed out in the original article. I couldn't find the main reason/difference between the two definitions. I wanted to clarify for anyone who had no clue that there's a difference, especially considering majority of people interchange the two.
I've only written a single javascript program (an emulator for the compucolor II computer) so I very well might be mistaken, but there is another difference. In this case: function foo(x) { return 1/x; } The function is named foo. Doing "foo(0)" will raise an exception, and the debugger (via some stack walking introspection) will know that function "foo" threw an exception. var foo = function (x) { return 1/x; }; In this case, the function is anonymous, and foo is a reference to it. In this case "foo(0)" will also throw the same exception, but to the debugger, the exception was raised by an unnamed function, not by foo.
Cool! A demo would be nice.
you can fix this by using a named function declaration: var foo = function foo(x) { return 1/x}; This also allows you to call the function from inside itself for recursion.
In JSON.async.js, if( Worker ) will lead to an error "Worker is undefined" on browsers without WebWorker support. Use this.Worker instead ("this" will be window in the browser and global in node.js): if( this.Worker )
Thanks for the feedback dude, I'll push the changes up now.
angular is also only written by googlers and belongs to the community. if you really want a web system by google, try closure.
You're welcome.
Thanks for the suggestion. Here's a video walkthrough: http://www.youtube.com/watch?v=66i30ogH_x0 Here's a live demo: http://softwareispoetry.com/json.async/example.html And a large json file to use: http://softwareispoetry.com/json.async/examplebigfile.json
Cool!
Well... var isEven = function (x) { return x === 0 ? true : !isEven(x - 1) } This works just fine provided you don't try reassigning `isEven`. Whereas var isEven = function myself (x) { return x === 0 ? true : !myself(x - 1) } Will always work no matter what you do to the `isEven` local variable. I used a different name to highlight that the names do not need to match in any way, and also that the binding of a named function expression is not visible outside of that function. You could have several NFEs all called "myself" in the same scope without any conflict.
Did you benchmark performances between parsing in UI thread vs in a worker? This way we could know if there is there a point doing that for small files. Also it'd be cool to split the files and spawn multiple workers to parse the file in parallel...
Until you have the entire JSON you don't know where to split it unless the spilt is done beforehand (meaning the server sends properly formatted chunks) as JSON is just a formatted string. You also have to know this is happening and have some JavaScript that recombines the chunks (how about in another Worker process?)
You could use (if available) TransferableObjects to avoid the byval copy of the data for a spot more efficiency: https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)
Hi, Yes it is a single Web Worker but not shared, but rather a dedicated web worker doing all the work. I went with dedicated Web Worker because it currently has more support over the Shared Worker.
Baaad. The toString method on functions is definitely not guaranteed to return the comments that are in the original source. I think this would fail in recent versions of Firefox, for instance.
Yes, it's javascript and runs in the browser, as opposed to running on a server, like NodeJS or Vertx. Very good observation.
Kind of a cool little hack but I definitely wouldn't suggest using it in production code. [Cykelero](http://www.reddit.com/r/javascript/comments/1eiadz/interesting_hack_to_define_html_templates_in/ca0kesh) mentioned, this most likely won't work cross browser. Additionally, your production code should be minified and therefore those comments should be removed.
I was just coming here to say that. This works fine on most mobile, but it's better not to do it if you care about Firefox.
I like it quite a bit. As for how you present the functions, you might consider adding some kind of type hint in the definitions. The functions seem very straightforward but if I'm just trying to remember which kinds of arguments a function takes then it would be really easy if I saw something like `at( Array arr, Number index, Boolean deep )`. Definitely not necessary but it *could* make it slightly more readable. Personally, I'd also suggest making the sections in the sidebar collapsible. Then if I just wanted to look at the Utility functions, I could get to them much quicker. It also acts as a great way to quickly showcase the diversity of the library if I can easily see it in sections. Other than that, it really looks quite good.
In response to adding a type hint to the arguments I agree and today I'm going to work on some type of rollover tip. The reason I don't want to just include all the type hints without a rollover event is because for many of the methods (especially those that accept multiple types) the definitions begin to look very cluttered. ... I go back and forth on this a lot because to me the methods and what type of arguments they accept does seem a tad obvious, at least as far as the first argument passed: If it's an Array method, accepts array(s), a collection method, objects and arrays, function method, functions and so on... but I can see where a type hint would be of benefit for the rest of the arguments after the first. The sections on the sidebar are collapsible. Are they not working when you click on them? They should expand and contract. Or do you mean I should implement that functionality in a different manner?
I'm getting more comfortable with namespaces and I like the pattern, the only problem I'm having is chain depth now namespace.a.b.c.d.etc it's getting a little out of hand.
I absolutely agree which is why I emphasized that it could help but it depends. If you have a lot of functions with different kinds of signatures based on input then it could be overwhelming so use your discretion on that point. Ahh, I hadn't realized that since they all start out expanded and there's no indication, such as a little right facing arrow, to indicate they can contract and expand. I guess I would suggest making it more apparent by, for example, starting them as contracted and have a little indicator arrow next to them.
It's interesting, however it's also going to break really hard in the face of most minimization tools. Not to mention, I'm not entirely sure what's going to happen in all JS engines when you toString() that function. I know Angular and some other frameworks use this to get argument names from functions, but, I don't think the comments are always returned.
I'd recommend reading up on the module pattern and extracting your namespaces through the window to make them more explicit globals. http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html
Perhaps I'm overthinking this library, but how does an Observer know it should be triggered again? Is the library completely unaware of the Signals used by an Observer? If so isn't the performance implications going to be terrible as you'd fire off N number of Observers whether or not the Signals they depend upon are changed?
Yeah, I agree. I try to be brief in naming the project so that I'm not typing a million characters all the time. Intellisense also helps in Sublime Text.
Great link! I might start using some of those advanced patterns. I hate having to put everything in one big file and they seem to solve that.
Dependency management could also be useful to read up on. http://blog.startifact.com/posts/overwhelmed-by-javascript-dependencies.html
I would just like to point out that OP is spamming his blog all over the place. It's probably best to downvote and report. 
That is a *lot* better. Good looking site :)
You can alias those (globally) to shorter variables: var utilsGroup = Namespace.Project.Group.Utils, utilsIndiv = Namespace.Project.Individual.Utils; //then wherever you need them utilsGroup.doSomethingWonderful(); Also take a look at http://requirejs.org/
I'm partial to the [revealing module pattern](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript).
John Resig released a book somewhat recently called Secrets of the JavaScript Ninja. In the first couple of chapters he has you build a small test script that consists of an asynchronous assert function. He then goes into great detail about all of the little nuances of JavaScript while using that bit of code from the beginning to PROVE everything with asserts. Really great book to study.
Do you know of any projects on GitHub or anywhere else that use require.js? I would like to look at some examples of use because I'm not sure if it would be a great approach for the kind of work that I do.
Looks interesting. I will have to read that whole book. I'm a fan of Addy and his work.
I hate hate *hate* this trend of data presentation. Just give me a damn article I can scroll through.
If you use something like require.js or another AMD library, you don't need namespaces, you access various modules by file path. It is much cleaner and easier to maintain since every file path is always unique.
Does require.js depend on anything else? (node, backbone, angular, etc)
No it's not a MV* framework, it's a clientside standalone library that helps you build reusable modules. Takes some time to understand the require config and shimming not AMD libraries, but take a look at the examples if you are interested at all. https://github.com/requirejs/example-multipage
I agree, but I believe these are slides from a presentation. You can add the query `?print-pdf` to load the print stylesheet and then print/save as a PDF to get something a little more scroll-friendly.
Love it! Awesome work. From my point of view it is the best mobile App for reading HN!
I mean I have a project that uses RequireJS in it's most basic form. You can see it [here](https://github.com/vernak2539/vernak2539.github.io/tree/master/app/js). I use it much more extensively at work. RequireJS is a huge pain, and a huge help. It helps you create more modular code.
It's it's own library. I can be used to help out write modular code (AMD). Can require/include modules in either sugar syntax or what everyone's used to **Sugar Syntax** define(function(require) { var yourFile = require('path/to/your/file'); }); **What everyone is used to** define(['/path/to/your/file'], function(returnedByYouFile) { // start using your file cause it has already loaded }); r.js is also helpful when combining files into smaller files. So if you want to have one file with all your js in it, r.js can trace the dependencies of your modules and output one file that has all the code. It's really all up to how you configure your optimizer. Can be super frustrating at times
We use it extensively. I would highly recommend you use it and level up your javascript. If you have any familiarity with other languages like Python, Java, or C++, you know they support modules and namespaces natively. Require brings that "native" functionality to Javascript. I think of it like an extension of the language itself, to give it functionality it doesn't have natively. 
I can't imagine this won't have to be 'built' every time, maybe I'm mistaken. I'm [reading about all of it](http://requirejs.org/docs/why.html) now, but I'm finding it hard to persuade myself to use this over just statically linked js files. From what I can discern it's like a js loader (common.js) but async without constant checking to make sure a lib is loaded. From the 'Why AMD?': Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals. IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace. Clear path to defining the module value. Either use "return value;" or the CommonJS "exports" idiom, which can be useful for circular dependencies. Thank you everyone, for the insight, I'll keep plugging away at it.
It doesn't have to be "built" every time. I really depends on how you set up your optimizer. You can have the main js file that require loads pointed to the "un-optimized/un-built" file structure.
Good point +1
Sorry forgot to answer your question. **Why would you use it over statically linked files** Require loads files on demand. It only loads files that you actually use or are needed by other files. So lets say you have a main file that loads other files when certain actions are executed on the front-end. If you statically link all files in you html page, all those files will be loaded by your browser even if you aren't using them at initial page load. With Require, only the bare minimum files needed on initial load are downloaded by the browser (Asynchronously too). Then when you execute an action in the browser that uses different files, Require will load those when the are needed. So basically if a user goes to a page but doesn't use part of the functionality on the page and you have static links to JS, you have made them download files they will never use. Require solves this problem. **Edit** It keeps track of files you've loaded, and then if you "require" them again in your define, it knows they are already there and doesn't load them. And yes, it's basically a JS loader/LazyLoader
https://news.ycombinator.com/item?id=5720945
Good call! Thanks. I added a note to stress that this is only an interesting trick, but should not be used in production!
That didn't work for me. I tried these URLs: http://derkoe.github.io/presentations/angularjs-intro/#/?print-pdf http://derkoe.github.io/presentations/angularjs-intro/?print-pdf http://derkoe.github.io/presentations/angularjs-intro?print-pdf But they all just gave me the original presentation (in some cases starting with a blank screen, but the right arrow key moved into the presentation). Would you happen to have a full URL that works? I'd certainly enjoy reading this more without all the swooping and zooming. :-)
The site is incredibly laggy. 
IDSPISPOPD
I think that it's a good format for a presentation. It allows you to jump over some particular theme you're not interested in.
This is just an idea, but one way you could do it is to have the server send the data as a JSON array where the elements are themselves JSON formatted strings. Parsing could run int 2 steps, first parse the main array which gives you an array of strings, then parse each string in parallel.
So does my scrollwheel on an article. Or TOC anchor tags.
That looks very similar to what I do, but I do everything in a closure as some others have suggested. (function () { // "this" resolves to "window" in the browser var root = this , otherVar = "foo"; // Ensure namespace // Shortcut evaluation makes it so that // fields are only assigned iff not assigned already root.Namespace || (root.Namespace = {}); root.Namespace.Project || (root.Namespace.Project = {}); root.Namespace.Project.init = function () { return otherVar; }; }()); edit: fixed formatting
I seriously have no idea what is up with Mozilla on the SharedWorker front: it's been 3 years that Chrome has had support now, since Chrome 5! [Mozilla's bugzilla on it hasn't budged](https://bugzilla.mozilla.org/show_bug.cgi?id=643325).
i still use plain old backbonejs for smaller projects but use angularjs for larger projects now. yep, but the thing is even a layout view needs a template! its minor but that single extra element wrapper was just sorta annoying (i used an empty function as a template to get around it). lol don't get me wrong though i think marionette is great and covers alot of backbone boilerplate code for sure.
Thanks. I was not gonna show it anyone because i am like no 1 will like it, but looks like every1 liked it so far. 
It's hard to believe that it's that much faster than lodash and underscore, I'm really going to have to play with this a while. Thank you OP.
Wow that is something broken on mobile (android)
Well the source code is pretty short so you should be able to see by inspection, but the answer is most likely that when an observer executes the library tracks the signals that are used by that observer, presumably tracked in both directions - ie each signal also maintains a list of the dependent observers.
The violin is very similar to any other plucked string instrument, except there is no attack and the volume of each overtone rises slowly. You can look at the "Further reading" section to read about how a string pluck is synthesized.
Per [these instructions](https://github.com/hakimel/reveal.js#pdf-export), go to the second URL you tried and open Chrome's print dialog. Save as PDF. I don't disagree though; I couldn't really bring myself to read through these. I did get a lot out of the [intro to angular video](http://www.youtube.com/watch?v=8ILQOFAgaXE) that someone made and posted a couple weeks ago though.
"Should" is a strong word here, also "much better" is contextual. While appending an item to the end would be simple enough for your suggested functions, it rapidly gets more complex for any other mutation. eg changing a value in the array - was the previous entry filtered out or included? Better track which index it was mapped to in b. For reduce (and I'm presuming you are doing a left to right reduce), do you presume that they will track each reduce intermediate, such that if a value in the middle changes it can resume the reduce half-way along? One of the charms of the library is that it is light weight. I would caution the author against making it more complex at least without at least a strong use case. ie having a secondary list of squares is cute but you are better served presenting a real world problem faced by an app developer. eg mapping a list of values to a list of rendered DIVs
I just found the way they formatted their content the easiest to parse out of the sources I saw, so that's why I used them. I don't really see how I'm advocating the use of their site, I just feel the need to cite my source. Unless the site is providing any wrong information?
Ok, I can add those. Is there a good list/reference for each of those I should refer to?
Well I didn't say it was a good idea
And Polymer seems to be a lot simpler than AngularJS.
where can I find the code for the performance test?
we're using (Backbone.ComponentView)[https://github.com/rhysbrettbowen/Backbone.ComponentView] and you can get the same functionality on top of it using (Backbone.Advice)[https://github.com/rhysbrettbowen/Backbone.Advice] to add on mixins (have a look at mixin.js, there are mixins for autolist, makeSelectable, singleSelect, clickSelect etc.
you should load the data in the worker as well as parsing it (if it is an ajax request). I did something similar [here in my web worker library](https://github.com/calvinmetcalf/communist/blob/master/src/wrapup.js#L19-L36) that way you don't have to downloaded it transfer it to the worker and transfer it back. __edit__: Also fyi the worker location is resolved relative to the html not the script, so if you put the worker and the script in say a folder called js e.g. `&lt;script type="text/javascript" src="js/json.async.js"&gt;` you will get and error. You can use the call self trick to put them both in the same file [like this](https://gist.github.com/calvinmetcalf/5604360).
[parallel map reduce in a worker](http://communistjs.com/dict/) is I believe what your talking about
you're checking to see if the JSON object has the Worker method, you should check `window.Worker`
[ran some perfs](http://jsperf.com/lazy-cwm) and I like what I see. In other news method chaining (aka monads) lazy evaluation, it's like haskell in the browser. 
Remove the take and then read the array. The .value foot underscore and lodash return an array, it's only fair that lazy does as well
On first look it seems that simply updating a pointer instead of having two copies of the data would be more efficient for both memory and CPU. However, that advantage could be completely negated by the need to convert to and from the buffer array. Without benchmarking there is no way to be sure.
Woops, fixed it by putting in a toArray at the end. Also just for you, I optimized the loop so it goes twice as fast.
I know I'm saying I have, especially for text where to convert it into a buffer you need to do something like function fromText(text){ var len = text.length; var outArray = new Uint16Array(len); var i = 0; while(i&lt;len){ outArray[i]=text.charCodeAt(i); i++; } return outArray.buffer; } btw just for fun, you have to check if you're in IE10 because it flips a shit if you have an array as the second argument to postMessage. That being said that code is from a place where the transferable objects did speed things up because the character codes were good enough and I never had to convert the data (20MB text file) back.
Doesn't that require the closure compiler to function correctly?
Using an upfront `slice` is much harder to reason about, especially when you have a `filter` in the chain. In his example, he has a sequence (of arbitrary length) that he squares, increments, filters on even numbers, then takes the first five results. In order to get the proper result, you'd have to know upfront that you're going to need to take twice as many as you actually need because the `isEven` filter removes half of the results.
I would argue that the perf tests are relevant and they do perform the same tasks just by a different mechanism. But I see your point. 
I always use the closure compiler for compilation, not sure how uglifyjs or jsmin would handle it. Just another reason to use Closure Compiler
Well, that's IE for you, where postMessage across tabs / windows isn't supported (since IE8, when it was first "supported", BTW).
Does it really need it though? The home page does a pretty good job of explaining how it's different from underscore; for the parts that are the same, you can just look up the docs on underscore 
No but there's no need for that, you can do a high level analysis of the JSON string to figure out how big are each level of data, then you split that string evenly between workers, and merge the final object as a final step... You don't need any server-side code for this.
Something like this, yes!
&gt; in the browser Not that it wouldn't be useful in the browser, but might even be more useful on the server-side where you're perhaps more likely to be dealing with large collections.
&gt;"this" will be window in the browser and global in node.js &gt;&gt;&gt; (function(){console.log(this)}()) Window &gt;&gt;&gt; (function(){'use strict'; console.log(this)}()) undefined
Went for the javascript, left feeling violated by Apple
Right off the bat I'm curious why I have to click the create button twice sometimes. My guess is that the items aren't being added to the canvas fast enough, but I can't figure out a way to add in some delay. Any ideas are appreciated
FYI: $($('#playerPokemonVertical')[0]).val(); can be changed to: $('#playerPokemonVertical').val(); reference: http://api.jquery.com/val/
actually due to how it was called it's the JSON object
truth
Thanks! 
I can definitely relate, this sounds just like me last year! I've done things the hard way and it took me 5x longer. I also prefer screencasts to books. I always need to create a project to solidify those fresh skills, otherwise they'll be gone in a month. Also tutorials for things like Backbone assume you know how to use jQuery, Underscore, and things like REST, and JSON responses... this can *quickly* get confusing if your not familiar with all of these. **My largest regret is not building enough practice apps in the last year**. I really should have applied more by doing, instead of staying in the theoretical world. *Here are some insights that i've made and the courses/tuts/projects that helped me the most:* #**Learn the language first:** * https://tutsplus.com/course/javascript-fundamentals/ * https://tutsplus.com/course/object-oriented-javascript/ * https://tutsplus.com/course/advanced-javascript-fundamentals/ * http://eloquentjavascript.net/ If you feel you need more coverage of the same topics (interactive html like CodeCademy). * Build something interesting, things like games seem to also challenge your programming skills at the same time. Something like Whack-a-Mole, Connect 4, etc... Don't worry too much about the looks, unless you want to practice that too. At this point you should be able to do basic dom manipulation, events, and basic logic. * The tut-plus courses cost a little for a few months but they're really high quality... most of them also give you projects too. #**Set up a comfy environment** Take some time to start optimizing your development environment, the Paul Irish explains it very well below, but some of the topics are a bit too advanced for now (modules, build tools, etc...). * [Javascript Development Workflow of 2013](http://www.youtube.com/watch?v=f7AU2Ozu8eo) * Setup a jshint plugin (~4min above), read the website/docs for all the options. http://www.jshint.com/ * A more entry level talk on setting up your environment [Front-end Tools for the Young Developer ](http://www.youtube.com/watch?v=5_nt5qV15po) #**Learn the native DOM and it's API** * http://domenlightenment.com/ * Create your own DOM manipulation library * While this one is a book, it's small and has js-fiddle examples for every code block to try it out... i'm currently going through this and it's great! They have a free HTML version (not final edit) and a cheap softcover on amazon. This will make using jQuery much easier and less 'mysterious'. #**Learn jQuery** * https://tutsplus.com/course/30-days-to-learn-jquery/ * https://tutsplus.com/tutorial/jquery-anti-patterns-and-best-practices/ * http://fixingthesejquery.com/#slide1 * https://tutsplus.com/course/jquery-plugin-development-best-practices/ * Re-write one of your previous apps to use jQuery instead of vanilla. * While I love vanilla, jQuery just saves time. Learn when you can easily *not* use jQuery to gain some easy performance. #**Read "The Good Parts"** Though very cliche at this point, read through this classic. If you don't really understand it all 100%, make sure you hang on to it though as it gets better with age. Try and follow it as close as possible, then later feel free to break the rules. By then you'll know *why* you can break them. * [JavaScript the Good Parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) #**Learn Underscore** This is a great library that gives you a lot of cross browser ES5 features and features that *should* be in JS. Not a lot of tuts on this one, reading the docs and source helps a ton here. * http://net.tutsplus.com/tutorials/javascript-ajax/getting-cozy-with-underscore-js/ * http://vimeo.com/60216668 * http://underscorejs.org/ * https://github.com/bestiejs/lodash #**Learn Backbone** There are lots of these libraries but Backbone is the most popular and easiest to learn. Keep in mind this is a library, not an entire framework like ember. This means in a larger app you will essentially use Backbone to help build you own SPA framework for your app. * https://tutsplus.com/course/connected-to-the-backbone/ * https://tutsplus.com/course/advanced-backbone-patterns-and-techniques/ * http://addyosmani.github.io/backbone-fundamentals/ *Great* book! * Build a Todo app with backbone * Build a backbone powered Reddit mobile web app, read the following posts for inspiration. http://cheeaun.com/blog/2012/03/how-i-built-hacker-news-mobile-web-app http://cheeaun.com/blog/2012/03/how-i-built-hacker-news-mobile-web-app_26 #**Learn Node** * https://tutsplus.com/course/introduction-to-node-js/ * Build a command line app ( I built a scaffolding app to spit out my boilerplates, and a really janky language transpiler) #**General Front-End, Programming** * [Baseline for front end developers](http://rmurphey.com/blog/2012/04/12/a-baseline-for-front-end-developers/) * [So you want to be a front end engineer](http://www.youtube.com/watch?v=Lsg84NtJbmI&amp;feature=youtu.be) * http://pineapple.io/wiki * https://www.edx.org/courses/HarvardX/CS50x/2012/about * I can't stress how helpful the CS50 course has been to me, even on the front end. #**Read a comprehensive JS book** I really like Nicholas Zakas's book over the definitive guide. I find that he is able to tell more of a story and makes it easier for me to absorb. * [Professional JavaScript Development](http://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691/) * [JS the Definitive Guide](http://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527) * Re-read "The Good Parts", this should make much more sense than the first time you read it. #**Testing** Make sure you're comfortable with everything before moving onto testing... this includes frameworks etc.. Learning testing will only slow down the learning process if you're not comfortable with the rest. Mocha is the newer test runner and is better with async. However, Jasmine is very popular and time tested. The "Lets code javascript" below is an awesome course. Don't let the first sections turn you off, they may seem tedious at first (integration server, etc...) so feel to skip to dom/browser testing and then loop back when testing is more normal. * http://www.youtube.com/watch?v=eVpXkyN0zOE - Short intro to Jasmine and TDD * https://tutsplus.com/course/javascript-testing-with-jasmine-2/ - Nice n Easy course to Jasmine &amp; TDD * http://www.letscodejavascript.com/ - epic *comprehensive* JS TDD course from server to browser * * http://visionmedia.github.io/mocha/ - My favorite runner (with [Chai](http://chaijs.com/)) * http://karma-runner.github.io/ - Test in mult. browsers from the command line (advanced) * https://github.com/rmurphey/js-assessment - test your skills (no pun intended) #-- I just started sketching out a website to try and solve this problem. It has different paths to follow to fill in gaps of JS knowledge quickly (much like hackdesign.org)... unfortunately it's not finished yet! Watch [LevelUpJS](https://github.com/AdamBrodzinski/levelupjs-website) on Github in the future. I also have some more links on app architecture and things like modules but this list is getting a bit large! Cheers and good luck! 
Without going through his source function by function, I can't assume it's exactly like underscore without docs, I shouldn't have to explain how nice they are to have for a lib/api. It's silly to ask if a lib needs documentation.
Quite interesting. I'm evaluating going with including simple plugins like this or adding Marionette.js or Chaplin to do this and more. Anyone have an opinion? EDIT: I grammar no good
I'm assuming you're referring to minified javascript. The main reason why sites use minified javascript is to reduce its file size, which reduces bandwidth, thus reducing page load times (if the script is loaded before the page is loaded). Another reason is to obfuscate the code, but for the most part this is minor, since if someone really wanted to steal the code they can just use some type of beautifier to make it have good formatting again. This is why for most popular javascript libraries provide a non-minified version for development ( eg. jquery.js), and a minified version for production ( eg. jquery.min.js)
It's called minified js, it is used to provide a smaller file and obfuscate the code
Code is obfuscated to make it hard to read. This is done by removing comments and spaces, and renaming variables to single letters. This also gets the file size down, like everyone else said, which makes for a faster download.
Fun stuff. I made something similar for checking test coverage once. My version also created accessor functions for properties.
You can find the code here http://github.com/joshontheweb/synth. It's not really ready to open source or documented yet but shouldn't be too difficult to figure out if you know your way around backbone. edit: FYI this only works in Google Chrome since it uses the latest web audio api features.
http://jsbeautifier.org/
nice job. 
Might also try a js/json formatter like https://chrome.google.com/webstore/detail/sight/epmaefhielclhlnmjofcdapbeepkmggh
Very nice. For those interested in reading more about this style of design, look in to [Python decorators](http://www.artima.com/weblogs/viewpost.jsp?thread=240808) (not to be confused with the Decorator pattern).
That's just minified code, which is an accepted practice for optimization. It saves some bytes when users need to fetch the script from the server. You should try out the Chrome Developer Tools [Pretty Print](http://www.kinnetica.com/images/minified_script_without_formatting.jpg) feature. It's way too difficult to deal with minified code without that.
Dramatatic. I cracked up, I hope this was intentional.
I'm an old person viewing it over a terminal services connection and I expected to hate it; was pleasantly surprised.
Dude it's github, open a pull request
&gt; *I am not looking for religious or dogmatic arguments or subjective opinions.* .. as opposed to objective opinions?
While coffeescript debugging tools are improving, they are still behind JS. Most of the libraries you will end up using (at least in early-to-mid 2013) will be written in JS. ES6 (the newest version of JS) will integrate many of the goodies from CS It's doubtful that browsers will implement a native CS engine 
It's difficult to answer "Why not" questions. What are some technical, empirical reasons FOR using coffeescript? (I'm about to go off on an anecdotal tangent, you seemed pretty sure you didn't want to hear one of those, so look away now). We have a project at work which uses coffeescript, and everything else just uses plain javascript. Everyone hates going near the coffeescript project because 1) It's ugly as fuck getting it to play ball with plugins 2) It's another language to learn with unusual syntax conventions 3) Accordingly you have to google every little thing 4) Code which makes whitespace important and eschews all brackets is just obtuse 5) Nobody likes debugging code which is different than the code they wrote So why do we use it at all? One of the devs doesn't like JavaScript.
An opinion *can* be objective, so long as it is removed of any emotional attachment to the subject.
1) Elaborate more on this point. Why is it ugly as fuck? Is it just ugly or is it incompatible? 5) This makes more sense. 2, 3, 4 are non-issues to me.
Out of interest, what's the problem with plugins?
Worked fine for me
Just fixed it- apparently someone slipped "overflow: hidden" into the mix. The javascript was fine- it never occurred to me to check for a css issue that only affected the map. D:
Every resource you look up is going to give help and examples in vanilla JavaScript which you'll have to translate, and you'll end up writing regular JavaScript anyway if you decide to tinker with the plugin code under the hood (which you easily might do, custom bindings in knockout, patching behaviour in bootstrap etc.). That's not a problem with coffeescript, it's just an irritant about using it in a world which primarily doesn't use it.
&gt;(I'm about to go off on an anecdotal tangent, you seemed pretty sure you didn't want to hear one of those, so look away now).
I don't think that is possible for humans.
Second link (to finovate) is missing the `:`.
Basically that all the help you'll get online will be in vanilla JS and you'll probably end up mixing the two *anyway*, resulting in extra work in translating, bug fixing your translations, and having to maintain and write JS code (edits, patches to plugins, which is more likely than you'd think, particularly if the spec isn't being written by you).
&gt;There are a few dangerous point as ECMAscript evolves and starts incorporating features that Coffeescript already uses but which have differing semantics. I use to be afraid of this, but even if it is true, the worst outcome would be using version numbers to compile. I'm not too worried.
&gt;Most of the libraries you will end up using (at least in early-to-mid 2013) will be written in JS. This isn't really a problem, seeing as the two languages are basically semantically identical.
That's probably true, at least if you're looking for any kind of meaningful response. I think that what OP probably meant is that he's looking for an *unbiased* opinion, which is not the same thing, but could maybe be said to be "more objective" than a biased opinion.
Also jQuery is JavaScript. 
Right. I suppose this goes back to needing good JS knowledge to use CS. I have no issues mixing both, but I'd be wary of it if I didn't know both well.
Looking at ES6 it does seem as if CoffeeScript will end up being an evolutionary dead end. The major features of CoffeeScript will soon be available in the browser, so I don't see a compelling reason to use CoffeeScript.
I had no idea it was possible to make such a nice interface. I worked on a project earlier this year and I was shooting for something more like this, but it ended looking like a mess (I'm new to Javascript). Any tips/pointers/tutorials on how to get this mobile look and feel?
Like others have said, CoffeeScript is just JavaScript with a different syntax. When a .coffee file is run in node, it is does the conversion from CoffeScript to JavaScript. It doesn't take very long, and if it's a long running program, like a server, it's not a big of a deal. For a very short lived app that is run frequently it may be a deal killer. A friend of mine wrote a coffee app that was run as part of his bash prompt. There would be a noticeable delay before his prompt would appear. We are talking about maybe 50-100 milliseconds, but it was enough to be annoying. It became unnoticeable when he converted the app to JavaScript using `coffee --compile`. This may not be a common case, but it is an example of where JavaScript was better from a pure technical reason.
Your left brain, which handles linear processes like evaluating lines of code, handles symbols with incredible efficiency. The idea that the practice of omitting symbols in favor of whitespace and words would make code easier to write and read is based on a misunderstanding of how reading and writing code actually works in your brain. So that would be my main empirical reason right there.
You can use any JS library in CS, including jQuery.
Thank you!
Don't really care that much about karma but im curious why im getting down votes. Am I breaking some etiquette?
Are you saying that javascript implicitly returns 'this'? Automatically returning the last executed line seems like a pointless feature just to be different. Just like optional parenthesis and deciding try, catch, finally is no good and need to come up with different keywords (begin, rescue, end). Ruby has some good benefits but some of the syntax seems to try too hard to be different.
Great run down and idea. I have a feeling I'll be using this at work on Monday. Thanks!
Okay, so that's how to do it, but why? I've heard of this a lot, but I still don't get the practical application. Does anyone have examples as to the kinds of problems this solves, and how it works better than multi-argument functions?
The thing about multi argument functions is they tend to be unique; unless you clog them up with extra code they can only be used for a specific thing at (usually) a specific point in the code's execution. Once that happens, the function is essentially redundant until the whole codebase is rerun (like a browser refresh). This can mean that there is a large amount of the codebase that basically hangs around and never gets used again. If you can break down the functions into smaller ones that can be called in different combinations, the probability that a larger part of the codebase gets reused increases. This means the codebase can be smaller in overall size to achieve the same purpose. Also, unit testing is a lot easier; if f(x) and f2(x) pass unit testing then a function f3(f2(f(x))) doesn't need additional whitebox testing as you already know the internals work properly, reducing the time spent chasing obscure bugs.
I think of this more like I think of science in general. It may not have an obvious application, but it is interesting to know, and if you find some real-world application one day, you already know how to do it.
Also it improves parse time.
The only practical reason I can think of not to use Coffeescript is the development of potential workflow barriers if you are required to work with people who can't use Coffeescript. I work independently a lot and take that opportunity to work exclusively in Coffeescript, and it's brilliant. But working with others, unfamiliarity with the code had a negative impact.
Sadly ff doesn't support the webaudio API just yet. Coming soon though.
Worth noting, I believe, that ES5 and ES6 are not perfect supersets, and there are breaking changes. For example, in ES6 it is illegal to have a var decl with the same name as a catch parameter inside a catch block. There are a few others as well. Both ES5 and ES6 have an appendix with all known breaking changes, it's worth a look-through!
"Soon" is a relative term. It will most likely take many years for all ES6 features to be supported in all major browsers.
One extra layer of complexity. Harder to debug. Harder to maintain. Harder to have fine control. In the end, it is not a new language, but a pseudo framework. It will offload work when doing certain tasks, but you will curse when doing others not predicted by the authors.
I do not think the code looks "nicer" and "cleaner". I find it often ambiguous and difficult to follow due to lack of delimiters and structure other than white space. I also find that adding a layer of bugs in the compiler is an anoying fact of life with coffeescript. Good javascript programmers are unlikely to want to look at your frustrating code. Debugging, even with source maps is no fun, especially when the compiler is the thing causing the problem based on your ambiguous code. More reasons why Coffeescript is a bad technology choice: https://github.com/jashkenas/coffee-script/issues/127 http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/ http://procbits.com/2012/05/18/why-do-all-the-great-node-js-developers-hate-coffeescript http://ryanflorence.com/2011/case-against-coffeescript/ https://github.com/harvesthq/chosen/issues/193 https://gist.github.com/tomdale/2481356 
The nice thing is that you don't really need to know much. The web audio api was built to astract away all the heavy duty stuff and allow you to just plug nodes (gain, delay, reverb, etc) together pretty easily. 
&gt;I do not think the code looks "nicer" and "cleaner". I find it often ambiguous and difficult to follow due to lack of delimiters and structure other than white space. Often is not the right word to use. I can see some rare instances coming up, especially if you don't know what you're doing, but compiling is usually straight forward. If you don't like it, don't use it. &gt;Debugging, even with source maps is no fun, especially when the compiler is the thing causing the problem based on your ambiguous code. I use to think this too, but it's really not that bad. When you're writing CoffeeScript you already have an idea of what it looks like in JavaScript when it compiles, so it's not really an issue.
The client shouldn't know anything about the DB. Your server should be in full control of the queries and handle persistence to MongoHQ. The client only uses a simple CRUD API that the server provides. Also, don't forget proper authorization on the server.
I think I'm doing it the former way. So client talks to Heroku server, which talks to database. But with access to the Heroku server URL, does the client not also have indirect access to the database for anyone else who can get that server URL and use it?
Obtaining the URL to your server would be trivial, and if you don't have any kind of authorization in place, malicious users would have free access to your DB.
But when it's just called as an ordinary function, then it defaults to returning `undefined`, not `this`. Use of the `new` operator seems irrelevant to your original statement, as it's an entirely different situation.
I have no idea where to even start looking at what kind of authorization would be required for this. Would something like PassportJS be the right thing to look into? (except I don't use Express...)
Inside a service and not a directive?
I don't know how heroku handles security, however the basic way I would handle this is to disallow connections to the db from anyplace other than the app server. 
You need to implement some sort of authorization into your app. It may be something canned, or something you roll yourself. For example, you can create what amounts to a simple session mechanism... have a login page... once you get a valid user ID and password there (matched against stored criteria in your database) you (in the server code) create a cryptographically-strong token that you store in a "sessions" table and return to the client... then, all of your CRUD API methods look for a token passed from the client and only execute if it's found in the sessions table... you'll also probably want to store a timestamp with each token (whether in the DB or part of the token itself) and delete expired tokens from the table with each request... but now we're getting fancy :) The basic idea is simply that once the user is authorized, the token tells the server it's okay to execute the API all... no token, or no validation of the token by the server, no API execution. It's not an especially hard mechanism to build yourself, but there's libraries that will do it for you... either way, that's the basic idea behind it. 
Ah great, thank you! I think this is finally starting to make some sense. I'll have a look around for a library that I can use. 
So can you directly connect from your computer to the Mongo instance on the server?
See my reply above, but as I understand it, the question really should be phrased: "how do I secure my API?", not the database. Right now, anyone can use the API to manipulate the database, whether it's the proper client app or not. That seems to be the crux of the problem. The database, I suspect (and hope!) isn't directly accessible to the world at large (whole other problem if it is)... but since there's no access control on the CRUD operations in the API, the database *is*, effectively, open to the world. Some mechanism needs to be added to ensure only your client app can use the API. Some sort of authorization has to occur for each API call. The relatively simple session token-type mechanism I described above would do that... I don't frankly know what modules are available to do that sort of thing off the top of my head, but they're sure to exist, and probably a couple of them to choose from... or just build it yourself, since it's not hard (although, ensuring cryptographic strength isn't something you want to get wrong, so finding a good module that already deals with those details isn't a bad idea at all). 
ive been itching to drop my jquery dependence and learn vanilla js, and this seems to be my ticket out.
Just code in Javascript, you aren't saving yourself any typing using significant whitespace. Your talent goes to waste if you aren't honing your javascript, and no, coffeescript is most certainly not javascript.
And you are absolutely correct. Fuck the downvoters on this, they have no understanding of reality. They think less typing is a benefit, I think they are nitpicking about the wrong problem. -&gt; is somehow a more elegant? Coffeecritters have no clue.
&gt;If you don't like it, don't use it. The new guy at work wanted to start using coffeescript in our codebase, but that was a non-starter. You can't just say "if you don't like it, don't use it" when so many expert beginners are jumping on a bandwagon, eventually I will be forced to use it whether it be to modify a library, or starting a new job where some asshat decided coffeescript was a good choice for part of a codebase. People complain about Android fragmentation all the time, but it is far worse for a programming language to become fragmented, and that is what coffeescript represents - a fragmentation in the world of front-end programming. People may say it's a "matter of taste", but it really is a matter of ignorance. Ignorance of working in teams and ignorance of the fact it is more difficult to read and understand coffeescript than proper javascript. Ignorance of the fact that even coffeescripters are confused about how coffeescript works (just go read the CS bug report page), and ignorance that typing less does not equal a real benefit (it just makes you seem lazy). 
You can also use [CSS3please](http://css3please.com/) if you don't want to worry about remembering the prefixes. 
So "magic" happens when r.js is used in conjunction with front-end RequireJS. The basics are this: 1. It uglifies your file (minified) 1. It will generate your sourcemaps if you want 1. It will combine the modules you define in your config file, into one file I'll go a little more in-depth on step 3 (1 + 2 are pretty self-explanatory). In the main require file (usually main.js or app.js) you can tell require to output "modules" when going through it's build process. What this does is it takes the file you point it to, and starts tracing it's dependencies (the '/path/to/your/file' array in your define). So it will find which files are defined/used by that file and then go to those individual files. It will then do the same thing for every file it finds in the `define` paths. Once it finds all the dependencies of your initial file it combines them into a single file (which is now uglified/minified). The benefit to this is that only one file of code needs to be downloaded for that "module" to work, which could have included a bunch of files and dependencies, all of which would have taken up a connection to download when trying to load your site. Let me know if I need to explain more. 
Sherlock Holmes would be proud if he weren't a fictional character.
It's not a matter of the initial overhead of loading the library, it's how much slower every javascript call you make is, when you use jQuery over plain vanilla javascript. I'm all for using jQuery to make my life easier in certain cases, but most of DOM selection and manipulation I do in vanilla now because the code just makes more sense to me (with exception of one or two constructs that are hilariously bad, e.g. `element.parentNode.removeChild(element)` instead of `element.remove();`)
This is a great pattern if you only want to expose certain methods/vars to other objects/whatever. I usually start writing JS using the regular module pattern, then once I have that all done, consolidate and and return only what's needed by other objects
You kids, get off my lawn. 
I think most of this falls under premature optimization. Unless you've benchmarked and found that the method call overhead is your bottleneck; you are just wasting your time and writing shittier code. 
I know you're probably joking. But for those who don't know, that logo is for Java, which is a totally different language from JavaScript.
A lot of misconception in this thread, this framework is meant as a POC more than anything else. They clearly outlined this in the IO session that OP left out of the post. This is not intended to be used anywhere other than toying around on your own machine.
&gt;Suppose the player sends a chat message... Do I call protocol.send("text")? Yes. Define the interface you want when dealing with the protocol. It will probably be protocol.send and a handler you'll register to receive async messages from the protocol. &gt;This requires the protocol then know how to access the network, which I don't want Do it. You should instantiate your protocol class, which will give you access to the protocol interface for sending and receiving messages. The instantiation of the class should take in two arguments, your receive handler and the underlying network layer object it will use to communicate over. It will be network-agnostic so long as any communication layer object you pass in at instantiation time conforms to the same interface as you use inside the class. From within your code, and henceforth, you will only ever need to deal with the protcol object for sending and receiving messages.
I would use a websocket, but I'm also a huge websocket fanboy at the moment.
~~I don't know what to say. If you want to work with other people, you have to be a little more flexible. Nothing you've said has changed my opinion of developing with CoffeeScript. It seems like it's only your problem. Deal with it.~~ *edit*: Okay, I'll explain why people like using CoffeeScript. The reason is JavaScript is a shitty language. Go to /r/programming and ask for people's opinion on JavaScript. We all know what that conversation is like. CoffeeScript builds a path to using JavaScript the right way. Imagine a new JavaScript developer who knows the syntax of JavaScript but hasn't built an app yet. He kinda understands how prototype works, but even then he keeps forgetting why his function isn't binding correctly. When you write CoffeeScript, you get JavaScript. I like debugging and seeing the JavaScript I get from my code. It's how I've gotten better at JavaScript. Seeing variables always being declared at the top or making a variable for `this` in the closure is how we learn to do that if we need to edit pure JavaScript. ~~Sorry for the douche remark earlier. I need to stay off Reddit in the mornings.~~ *edit2*: Don't like using CoffeeScript at work? Deal with it.
The database should usually not be accepting queries from the wider internet - only from your application server.
Ahhhhhhhh. So, you're saying the Network is an interface and the Protocol provides an interface to the Network interface, basically? What's a good way to alert them of each other? protocol.link(network); ? protocol.chat(network,"hello"); ? network.use(protocol); ? network.chat(protocol,"hello"); ? 
The are *both* interfaces, the network interface being lower level than your protocol interface. They will both have send methods and receive handlers. The network one will be data-agnostic, meaning it doesn't care what is sent or received. This gives you more flexibility, but less bells and whistles are included: you have to do everything. Data checking, error checking, data parsing, etc. You want to create a protocol interface precisely because these checking and parsing tasks are routine and mechanical. Your protocol interface is prettier and easier to use, but only speaks your protocol. I'm not really sure what you're getting at with your examples of .link and .chat (maybe they make sense to you for your domain specific application), but what I'm saying is you should create and focus on what the interface to your protocol looks like. The guts of the class will be wrappers / message translators that speak at the network protocol level. This will give your high level code the ability to speak and understand "protocol" and the guts of your protocol class will speak and understand the network level stuff. Hope this helps.
Right, but I'm saying the "protocol" object must be aware of the "network" object, so at some point I will have to link them together, ie, protocol.link(network) would tell that protocol to start using that network. Both the "protocol" and the "network" are loaded asynchronously as needed, as javascript, so I need to be able to link them together. Do you have a better idea of how I could do this?
The advantage here is, or at least should be, a growth opportunity to better understand the core language and/or build a more portable application with fewer hard dependencies. 
I suppose I misspoke. I still plan to use jquery daily, but I feel bad that I HAVE to use jquery. I don't want to be dependent on it to write js.
They said why
I see what you're getting at. Yes, you could call link on the protocol in one of the callbacks to loading the protocol and comm code. The drawback to that is it leaves your protocol code in an intermediate state until both callbacks complete. Only then will the class be usable. Instead, you could simply instantiate the entire protocol object once both callbacks complete. This way you never have half-instantiated code to deal with. In your case, this will manifest in two things: (1) you will never worry about calling protocol.send and have it *not* work because it isn't yet linked with your comm layer. That's a latent bug. And (2), your protocol code will not be littered with if (commLayer) {} checks.
Even if it's faster in some browsers, "works" beats "faster" any time.
I'm having the same problem.
I have that same itch when I start a new project. Think it's a combination of knowing it's efficient + learning something new.
Wow! CSS3please is an amazing little gem! This will see some use in my next project!
Thanks for the answers, but I still have a few questions if you don't mind. It sounds like I would have to stop using YUI compressor and use r.js to do the minification process? Are sourcemaps a tool you use just to aid in debugging the app in minified code? Also, how does this work if some of your js files (all in my case) are not written with RequireJS in mind? Say I have a file which defines some stuff in a namespace (just an example): // foo.js (function (it) { it.foo = function () { ... } ... })(this); To use this from a module, would it just be the same syntax? e.g. define(['foo.js'], function (foo) { }); What would be in foo? Anything? I presume it would be undefined since foo doesn't return anything.
No worries. 1. I'm not too familiar with YUI compressor. If it's not an AMD loader, then yes you might have to stop using it in order to get some of these benefits. But like I said, I'm not familiar with it, so take that with a grain of salt. * it does sound like they do the same thing except that you need to define what JS files are combined into one file, unlike Require, which will decide for you based on the paths in your define array 1. Yes. Take a look [here](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/) if you want more info on sourcemaps or just google it 1. In your example the first line of the define would look like this `define(['/path/to/foo.js'], function() { // your code here });` I put an example below. * in this case since it loads your whole file, the namespaces would be there already. * the aim of AMD is to get away from this though. Mainly not clouding the global namespace. * So if you set up your app with Require from the start, you won't have to pollute `window` ever, and just load the modules you want to use and Require takes care of the rest **Example** // foo.js var app = window.app || {}; app.foo = (function() {})(); // bar.js return function Bar { // your object code goes here }; // other require file define ( [ 'bar.js', 'foo.js' ], function( Bar ) { // do something with foo.js app.foo.someMethod(); // do something with bar var test = new Bar(); }); 
This is really cool, thanks!
Quite a few of the methods are rock solid on all browsers I see no issue with using those, just do a little research and use jQuery only in the places you must.
I think the really important thing about this is that there's probably a lot of us who learned jquery before we learned javascript. Seeing the equivalent adds deeper understanding as to how jquery works, and why you use it. This is the same way I feel about photoshop filters - I learned how to do all of these effects without the filters so I'd have a better understanding how they worked, but I still use filters because they're better/faster/easier.
This encourages a very declaritive way of thinking and communicating. For instance, let us consider the following implementation of reduce (I will write in coffeescript because it's lambdas are syntactically more light-weight than JavaScript's). reduce = (f) -&gt; go = (accumulator) -&gt; (array) -&gt; if array.length &lt; 1 accumulator else x = array[0] rest = array.slice(1) accumulator_ = f(accumulator, x) go(accumulator_)(rest) go Now let's write some reductions. add = (x, y) -&gt; x + y mul = (x, y) -&gt; x * y append = (xs, ys) -&gt; xs.concat(ys) addPairToObj = (obj, [ key, val ]) -&gt; obj[key] = val sum = reduce(add)(0) product = reduce(mul)(1) flatten = reduce(append)([]) objectOfAssociationList = reduce(addPairToObj)({}) If I write my functions in this style, I can now specialize them just by feeding arguments. I am encouraged to thinking of functions as values, and to manipulate them as such. [EDIT] - Made reduce non-destructive. 
try with: var regexp = new RegExp('^'+the_input.getAttribute('pattern')+'$');
FTFY &gt; better understand the Document Object Model
&gt;It's not a matter of the initial overhead of loading the library, it's how much slower every javascript call you make is, when you use jQuery over plain vanilla javascript. Sure, but that's a micro-optimization you'll want to make on a case by case basis. If your app is running slower due to dependence on jQuery then by all means start using native selectors and methods (btw you can use native selectors in jQuery and it will pass them to the browser where available). But prematurely optimizing by choosing "vanilla" js because jQuery feels like it might be slow is probably the wrong choice, assuming you actually need what jQuery provides. In a lot of cases slowness due to jQuery is mostly a matter of making the wrong decisions--not caching selections, not building events correctly and reflowing the DOM too often by accessing/updating it where it isn't necessary. That's not to say that you can't make your page faster w/o jQuery. You absolutely can. But you should measure that and work against metrics.
Yeah. Play around with the matrix transforms a bit, too!
Lookup long polling and the c10k problem. I would recommend implementing your polling backend in something other than PHP and Apache, its a terrible combination for this.
Many of these aren't supported in all major IE browsers. classList is only supported in IE10 for example: https://developer.mozilla.org/en-US/docs/Web/API/element.classList#Browser_compatibility
I like using stylus with nib which allows will auto add all the vendor prefixes for you at compile time.
you might also like [BabelExt](http://babelext.com/) - which is my own work. It's a boilerplate for Chrome, Firefox, Safari AND Opera extensions that also includes some abstractions to help make your extension compatible across all 4 browsers more easily :-)
Armchair psychology at its most questionable. 
&gt;edit: Okay, I'll explain why people like using CoffeeScript. The reason is JavaScript is a shitty language. Go to /r/programming[1] and ask for people's opinion on JavaScript. We all know what that conversation is like. This is a non-starter. The people who complain about Javascript being a shitty language are the same people who confuse DOM for Javascript. There are numerous examples of great things that can be done with plain old javascript, the language is not "bad" any more than any other language is "bad". I am not a Javascript apologist, there are great things about the language and those who fail to see it are ignorant. &gt;CoffeeScript builds a path to using JavaScript the right way. "The right way"? What. the. fuck. There is no one true way to use Javascript. That is a false assumption that one guy's javascript "transpiler" is producing the end-all-be-all of javascript code. Your assumption is hogwash. Part of the beauty of Javascript is that it can be used in so many different ways. None of these include significant whitespace. &gt;Imagine a new JavaScript developer who knows the syntax of JavaScript but hasn't built an app yet. He kinda understands how prototype works, but even then he keeps forgetting why his function isn't binding correctly. This is not a problem with the Javascript language, and a "new javascript developer" has no business sticking his nose into coffeescript. If they do, they are going to have more problems than knowing how prototype works. Master Javascript first, then decide if you want to throw out a widely used language in favor of a bandwagon to nowhere. &gt;When you write CoffeeScript, you get JavaScript. I like debugging and seeing the JavaScript I get from my code. It's how I've gotten better at JavaScript. Seeing variables always being declared at the top or making a variable for this in the closure is how we learn to do that if we need to edit pure JavaScript. So What. None of this makes any difference to someone who actually learns the Javascript language. Coffeescript doesn't somehow magically make you a better programmer, in fact it probably acts like a crutch for bad programmers, and to some extent makes them feel like they are cool. &gt;Sorry for the douche remark earlier. I need to stay off Reddit in the mornings. No need to apologize for being an [expert beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner).
&gt;This is a non-starter. The people who complain about Javascript being a shitty language are the same people who confuse DOM for Javascript. No. That's a bullshit statement. They make tedious arguments like yours on why I shouldn't use a language I like using. &gt;There are numerous examples of great things that can be done with plain old javascript, the language is not "bad" any more than any other language is "bad". I am not a Javascript apologist, there are great things about the language and those who fail to see it are ignorant. You don't have to tell me that. I like JavaScript, too. When I program CoffeeScript, I'm also programming JavaScript. &gt;"The right way"? What. the. fuck. There is no one true way to use Javascript. Calm the fuck down. I'm talking about obvious shit like declaring variables at the top or slicing arrays. We know there are several ways to do that, and there is a "better" way. &gt;That is a false assumption that one guy's javascript "transpiler" is producing the end-all-be-all of javascript code. Your assumption is hogwash. You can compile your code to JavaScript and drop CoffeeScript completely if you want. Most people who like using it won't. &gt;Part of the beauty of Javascript is that it can be used in so many different ways. None of these include significant whitespace. It's the same language - just a different syntax. Python and Ruby developers like whitespace. CoffeeScript developers like it, too. I think semi-colons suck, but I still have to use them in languages that require it. &gt;Master Javascript first, then decide if you want to throw out a widely used language in favor of a bandwagon to nowhere. No. You're taking away an option for new developers to become familiar with JavaScript and saying they should master it first. That doesn't make any sense. &gt;No need to apologize for being an [expert beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner). I withdrawal my apology. Suck a dick. 
deserves extra upvote for the flying lotus mention. Flying lotus is awesomesauce.
That is awesome - I'll check that out!
With the MongoHQ DB user and password yes, but if I was a random person trying to connect directly to the database no as there is no way to see the DB credentials. I would however have the URL to the server itself and presumably be able to emit calls to it the way the game client currently does (sorry if I'm just making this more confusing, I _am_ starting to grasp this..just slowly)
Thanks for the comment. did you see the meteor plugin I made for tquery that is in Atmosphere? Anyway that is a start.
Is there a reason this has been down voted so? I feel as if I'm missing something.
CoffeeScript, not JavaScript.
What does this get me that a v3 or v4 UUID doesn't? (Apart from two bytes, that is.) *Edit:* e.g. https://github.com/LiosK/UUID.js
Ok so it sounds like heroku has the mongo credentials and mongohq enforces password protection. I don't see any major problems with this setup as long as the connection between the app server and mongo is over https. 
&gt; 2) with uuid there is theoretically a chance of duplication, with puid there isn't any chance to clash (this wasn't the reason to build puid ;-) ) What proof do you have that your system can avoid all duplication? And how is that stronger than the device-independence part of a correctly-generated UUID?
&gt; yes, uuidv3/4 are 128bit, but I don't want redis-keys like this (!/&amp;"&amp;§(¨⁄⁄ˇ˝‹Ï so I have to stringify the uuid =&gt; 36chars 24, not 36. And that's if you only care about them being safe to embed in emails sent back in time to the 80s.
&gt; 2) with uuid there is theoretically a chance of duplication, with puid there isn't any chance to clash (this wasn't the reason to build puid ;-) ) Assuming I've understood the specification in the README correctly, a puid has the same entropy as a v4 UUID, yes? The coarse and fine timestamps and the PID add up to 18 characters of (I think) Base36 (~=90 bits) and then you have 6 hex digits (=24 bits) of truncated MD5 and so the total entropy is around 114 bits. A v4 UUID has 114 bits of entropy as well. Your hashing and timestamp scheme is an attempt to distribute the puid namespace uniformly over time (up until 2056) and space (over all machines + processes). A UUID v4 is also uniformly distributed over time and space by definition. So you've in actual fact developed something with exactly the same collision resistance as a UUID(!)
I don't really build on top of this, it just enables me to quickly try out the app or start tweaking styling before or while the backend is being developed. So I'll build up the project tdd-style and when I want to take a peek, I'll start this up and start clicking around. As far as remaining 'dry', I guess it's more about remaining dry across projects.
I've looked through this presentation and I'm having a little bit of an issue *fully* understanding what is going on here: function g(h) { return function(y) { return h(2) + h(y); }; } console.log(g(function(x) {return x * x})(2)); I'm getting 8, which I understand. function(x) {return x * x} is being passed into g as h, but how would I explain in plain English what is going on with the (2) that is being passed in and used in place of the variable y? What if, for instance, the lambda inside of g required two variables?
If you want to more accurately see how long it takes for each function to run, you should define the functions in the `setup` area, and then each test can be just a function call. If you put the entire function inside the test, the computer includes the time it took to create the function in the results, as well as how long it took to run. If you define the function in `setup`, it only times how long the function takes to run. I like that you're doing these tests. Writing efficient functions for finding primes is hard. EDIT: Here's a simple thing you can do that gives you a performance gain, and makes the code easier to read: break the chunk of code that tests to see if a number is prime into its own `isPrime` function. The following is a refactoring of the first draft: var a = []; function isPrime(i) { //check if i is a multiple of any found prime for (var c = 0; c &lt; a.length; c++) { if (!(i % a[c])) { return false; } } return true; } function f(a, l) { //number to check next var i = a.length ? a[a.length - 1] : 1; l += a.length; //check if done while (a.length &lt; l) { i++; if (isPrime(i)) a[a.length] = i; } }; f(a, 1000); function `f` no longer uses `c` and `t`, but calls `isPrime`. Other improvements I can think of: * rather than `if (!(i % a[c]))`, try `if (i % a[c] === 0)`. This should be faster as it doesn't involve casting values to different types. * rather than `a[a.length] = i` use `a.push(i)`.
I once did a replace all on my entire project: (\S+)\s*:\s*function\(([^)]*)\)\s*{ with \1:function(\2){console.log("\1"); to find a performance issue. Slows everything down with a whole load of console.logs but it surprisingly was very efficient at finding the issue
I'm much older, and I'm sorry I couldn't convince you to give CoffeeScript another chance. You should look into [LiveScript](http://livescript.net/).
What's funny is that docco and family can produce nicer output too due to markdown support.
&gt; where are you see 10bits ?? This was an illustration of my point. The point being that is redis really cares about you adding a handful of bytes onto the length of keys, it must have some pretty poor scaling. Or, conversely, if reducing your key size by a few bytes massively increases performance, something is wrong. &gt; ok I could convert this 16Byte-value in base36 ... only to make you happy to use UUID? and with puid I have only 14 booomm ;-) I don't understand this at all. You can't escape the fact that your puids and UUIDs have roughly the same entropy. &gt; If you take a look how it works, you will see that a collision with puid-short14 isn't possible at all This isn't my comment. **Edit:** and my original comment is still unanswered: what does this get you over UUIDs aside from a handful of bytes space saving? (If redis really, genuinely performs significantly better with keys a few bytes shorter then fair enough but that, if true, would give me the heebie-geebies about redis' algorithmic quality.)
&gt; ok, I will answer in one comment, something confusing this comment attack ;-): I suspect it is a problem with at least one of us not being a native English writer. :(
I made a 3rd revision with a new test which is a bit faster. It has less branching and also just checks up to the square root instead of halfway up.
&gt; I'm sorry I couldn't convince you to give CoffeeScript another chance. Seriously, why would I want to abandon 15+ years of Javascript mastery for significant whitespace? It would make my life a living hell, as well as those I develop with if I chose to use it in our production code. It is seriously a bad choice for teams of JAVASCRIPT programmers. There is no good reason for me to use coffeescript, none at all, and you can't come up with any valid argument towards that. &gt;You should look into LiveScript. I have headhunters calling me every week offering me more and more money because I code Javascript. I'm up to 150k/yr offers just to code Javascript, because of my history of writing cutting-edge web applications in Javascript. You really think "LiveScript" or "coffeescript" is going to help me make more money or ship more products? No. Just no. You're so wrong. Coffeescript IS NOT Javascript, no matter how hard you or other coffeecritters try to say that it is. There is no equivalence whatsoever. I've seen plenty of coffeescript, and while the two languages share the DOM, they share nothing else. VBScript also works in some browsers, and that also shares the DOM and it also died a death that languages do when they are not widely used. Javascript killed VBScript in the same way that Coffeescript is getting very little traction compared to Javascript. People do not like to use it, and they actually do prefer Javascript, because everyone in front-end development knows it (or should know it), it is well understood and the few 'warts' it does have are easily avoided by a 1st year javascript programmer with access to the wealth of knowledge on the internet. There is no reason to use Coffeescript. It is favored by people who think saving a few keystrokes is somehow making them a better programmer, or it makes it easier to program, which is totally false. 
if you have functions that take only one argument and return a single argument then you can compose them. One argument in, one out and in to the next function that takes one argument. It's sort of like chaining in jQuery or underscore, except you decide what to pass in instead of using a jQuery object. for instance let's say you want to change an object to a query string, let's create a function that changes an object to a string given delimitters with currying let's pretend join is like [].join but takes the array as the second argument instead of using 'this' var joinC = curry(join); and our curry function detects the function.length of join and should know to return the value rather than another funtion when it reaches 2. now let's create a function that will take a map and give us a string representation (I'm going to use underscore here): var objToString = function(valDelimitter, pairDelimitter, obj) { return joinC(pairDelimitter)(_.map(_.pairs(obj), joinC(valDelimitter)); } now because the joinC is curried, passing in the delimiters will create a new function that will join with whatever you pass in. now we could use currying more and do something like this: var objToStringWithEqualPairs = curry(objToString)('='); var objToQueryString = objToStringWithEqualPairs('&amp;'); var objToCSV = objToStringWithEqualPairs(','); var objToPath = objToStringWithEqualPairs('/'); probably not the best example, but you can see how easy it is to construct other functions in one liners using currying. Then when you've got them like that you can chain them all together and get what you need in one line
I'm going to use this guy a few times below function double(x) { return x * x } Conviniently, none of the functions involved here have any side-effects. They all just consume arguments and return results. Because of this we can simply expand out function calls with their definitions, and then simplify. g(double)(2) =&gt; function (y) { return double(2) + double(y) }(2) =&gt; function (y) { return function (x) { x * x }(2) + function (x) { x * x }(y) }(2) =&gt; function (y) { return 2 * 2 + y * y }(2) =&gt; 2 * 2 + 2 * 2 I'm not sure what *plain* english describes this substitution and reduction, but if it helps for you to verbalize these things to yourself, the [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus#Reduction) has some very precise words for all of the ways to manipulate these things. As for two variables for the inner lambda, is this something like what you are suggesting? // `sumOn(f)` is a function `sumOnF(x, y)` that sums the result of applying // `f` to `x` and `y` function sumOn(f) { return function (x, y) { return f(x) + f(y) }; } Alternatively we could curry the inner function. function sumOn(f) { return function (x) { return function (y) { return f(x) + f(y) }; }; } Now if we wan't to apply and watch the reduction. I'll skip expansion of `double` and just reduce it for brevity. sumOn(double)(1)(2) =&gt; function (x) { return function (y) { return double(x) + double(y) }; }(1)(2) =&gt; double(1) + double(2) =&gt; 1 * 1 + 2 * 2 
Thanks, i didn't know that was a possibility, you kinda made all my optimization attempts to shame :p
I've added my version to the list, which checks for primes in jumps of 6.
You live and learn. I think it's still possible to go much, much faster by doing more language specific optimizations.
Well that is my main focus with this, what a small change such as not using "=== true" in an if statement can do for you'r codes speed.
No but the point behind this is what small changes can make your code more efficient such as saving the length of an array to a variable instead of looking it up twice.
I saw that. Is there a running example somewhere? I'd love to test it out. Would it be easier to do 2D first? Or even text-based? Like a MOO perhaps?
None of the code in your code snippets indents properly (at least in Chrome, latest). This makes the examples pretty difficult to read.
I'm still curious about the reverse process of currying. Would someone please explain what is uncurrying, and how is it related to apply() ?
&gt;Seriously, why would I want to abandon 15+ years of Javascript mastery for significant whitespace? I honestly don't care what you use. I even said that, but apparently *you* care about what other people use. Why should I care about what you think? You haven't given a good reason not to except that *you* don't like it. &gt;Coffeescript IS NOT Javascript, no matter how hard you or other coffeecritters try to say that it is. There is no equivalence whatsoever. I've seen plenty of coffeescript, and while the two languages share the DOM, they share nothing else. VBScript also works in some browsers, and that also shares the DOM and it also died a death that languages do when they are not widely used. VBScript is another language that works on only one browser. CoffeeScript is basically JavaScript with another syntax that compiles into JavaScript. How are you not getting this? Do they really pay you that much money **not** to understand JavaScript? &gt;Javascript killed VBScript in the same way that Coffeescript is getting very little traction compared to Javascript. People do not like to use it, and they actually do prefer Javascript, That can't be true, or we wouldn't be having this conversation. You seem threatened by CoffeeScript, and that's my entire take of all this. I'd imagine if you pride yourself on knowing JavaScript extremely well that you can also check it out, but you sound like a bitter dinosaur who hates change. Again, I don't care what you use, but fuck off with your obnoxious attitude about what I and others should use.
ah, gotcha. I put a fast seive implementation at http://jsperf.com/prime-finders/9 and it's ridiculous how much faster that is. Though it looks like a lot of the improvements being put in change the actual algorithm (like only checking certain numbers) rather than just plain old code changes.
Yeah, i'm not sure either. The no HTML thing might rub some people the wrong way, but I think it is refreshingly honest. The only downside is accessibility.
Also, the GEL stuff below the GAFFA framework is pretty cool: https://github.com/gaffa-tape/gel
&gt;Again, I don't care what you use, but fuck off with your obnoxious attitude about what I and others should use. But it's okay for you to go around telling me and others they should try coffeescript, and livescript? You're a dimwit, and a self proclaimed douche. Go back to your hole you troll. 
Voxel.js or a 2d or text-based are both good ideas. I am a little more interested in more old-fashioned 3d stuff for this at the moment though I think.
Yup. RMP is where it's at. It allows for [better code compression via Closure compiler](http://lpar.ath0.com/2012/03/22/javascript-module-patterns-and-code-size/) because everything except the revealed public methods can be renamed during compilation.
I wish he would go into detail about what specific DOM operations he is doing in order to get those benchmarks. Kind of uninteresting without it.
They're in the tests. If I was doing this with jQuery I'd do it more like his innerHTML method, which could also be improved by making the full string instead of appending chunks.
If you find yourself doing things like this in your critical path: var points_plural = (caption['points'] === 1) ? '' : 's'; var captionDOM = $("&lt;div /&gt;").attr('class', 'caption') .append($("&lt;div /&gt;").attr('class', 'votes') .append($('&lt;a /&gt;').attr({'class': 'up', 'href': '#'})) .append($('&lt;a /&gt;').attr({'class': 'down', 'href': '#'}))) .append($("&lt;div /&gt;").attr('class', 'meta') .append($("&lt;span /&gt;").text(caption['author'] + ' - ')) .append($("&lt;span /&gt;").text(caption['points'] + ' point' + points_plural))) .append($("&lt;p /&gt;").text(caption['caption'])).get(0); ...then I think jQuery performance is the least of your problems. You should look into using an actual template system, which is designed to do this kind of thing very efficiently.
I'm just starting with backbone, i'll give these a read through for sure. Either way I greatly appreciate your effort to help people like myself. 
same. Chromium 25.0.1364.160 and Firefox 21.0
angular.js is probably the way to go in this case. (And in most cases, in my opinion.)
Also, without a break-down by browser, I'm deeply suspicious of the results. I'd be very surprised if it's that consistent across Firefox, Chrome, Safari and IE.
That tends to depend on the browser! Browsers don't handle elements internally as one dumb string, so it could be faster to skip directly to the browser's DOM objects. (But not necessarily across browsers!)
I find Angular kind of neat. What do you use it for?
For me, it's anything that relies heavily on dynamic data-binding (which is most web applications nowadays). I've only recently started using it extensively, but I can say that I'm a big fan.
Really?! Thanks for this. I'm on Chrome Version 25.0.1364.160 Ubuntu 12.10 (25.0.1364.160-0ubuntu0.12.10.1) And Firefox 20.0, both look fine to me. I'm using the WPSyntax plugin which I assumed was working fine. Screenshot of what I can see is here: http://robsearles.com/2013-05-21-222404_776x334_scrot.png Is what you're seeing just totally inline, no indenting? Will check on other browsers. Thanks once again. 
Thanks for the encouragement. Let me know if they helped you at all.
Looks like it was the Disqus plugin. I have deactivated that for the time being. Have checked and no more javascript errors. Hopefully that fixes the issue. (Edit: Also removed comments for the time being)
He's analyzing the difference between using jQuery, innerHtml and thinDom for appending content to the DOM in his javascript code. read: client-side, web-app, spa, other buzzwords etc...
This makes me worry about compiling code, as some compilers will inline functions. so putting the inner code in a different function would probably just be moved back in the build process.
It's my opinion that having a fallback for non-JS enabled browsers is on its way out, even for SEO purposes. That said, having installed Ghostery and noscript recently, I'm beginning to wonder if this is such a good idea. One of the things you're going to find trouble with, I expect, is detecting when to provide Zepto over jQuery for mobile devices. Is that a user-agent identification? If so, is it done on the server? If so, are you building a separate package to send to the browser? For a long time I served a completely different set of JS for mobile. The detection was spotty, and if it was wrong, the JS broke because d3.js breaks on certain mobile browsers. &gt;We also add a class name, thinking about it I’m not sure why, possibly just because we can. Plenty of reasons, the most obvious being for css purposes. There's also a contrast with giving the View an id--I'm pretty sure that Backbone.View looks for that id in the DOM and will use that element I believe. Finally, inlining HTML templates leads to some pretty messy code and disorganized templating. I've yet to find the perfect template solution. 
That would be the innerHTML test, and it's about twice as slow. 
Wait, is that seriously what imgur was doing? 
I don't understand using require.js on the client--means multiple fetches for code, doesn't it? And I don't understand using require.js on the server. Why asynchronous, then? 
In the comments, he states that the real bottle neck is a cache miss not jQuery. The entire reason for writing the new library is beyond me.
Thanks for this. I think I'm just a bit of an old curmudgeon when it comes to having a fallback version, but I just hate the idea getting to a site and having a big "I'm too lazy to make this work for you" sign there. Choosing whether to use Zepto or jQuery was done using a version of ('__proto__' in {} ? 'zepto' : 'jquery') It's really messy and I'm not overly keen, but it's documented on the Zepto site (somewhere!) and it seems to work. From my point of view all I cared about was detecting IE reliably and only using jQuery for that. We did have some issues with Zepto as it's not a complete replacement for jQuery, and it meant having to write some custom Zepto plugins as replacement, but this was slightly outside the scope of what I'm trying to do in these posts. (Happy to add this detail in if you want) Regarding the class, I didn't delve too deep into this, mainly it was a matter of playing around with things until it worked. Again, being that type of person I don't really like adding extra markup just for fun, but being able to select a class in this respect could be useful. Templates is always a tricky one, in real life we use mustache (or derivatives) as it is the cleanest way we have found yet. No doubt I'll go off on a tangent when I come to write that particular post! Many thanks once again for your feedback, much appreciated. 
There are *better* solutions that may eventually necessitate looking into if we start getting more volume of comments. As it is, our most popular images get on the order of thousands of comments. The utility of something specifically like angular.js is a bit diminished by two major facts: * Captions are immutable so we don't have persistence problems and don't need "automatic [..] updating the view whenever the model changes." * Like any decision, transitioning fully to something like Angular.js would mean a lot of work for questionable benefits. I am also confused at what exactly is unparadigmatic about the snippet you cited. One could argue you should be creating all of it in one go by concatenating the HTML, but that imposes a very weak structure on the data. Take the InnerHTML test case: container.innerHTML = '&lt;div class="votes"&gt;&lt;a class="up" href="#"&gt;&lt;/a&gt;&lt;a class="down" href="#"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class="meta"&gt;&lt;span&gt;Arthur - &lt;/span&gt;&lt;span&gt;'+ caption['points'] +' point' + points_plural + '&lt;/span&gt;&lt;/div&gt;&lt;p&gt;'+caption['caption']+'&lt;/p&gt;'; It's very hard to see just by looking at this line exactly the structure of the tree that you're generating. Since it's in a string you most likely get no benefits from IDE autocompletion. There is no way to tell whether the HTML you are writing is well-formed. Again I tried to be as paradigmatic as I could in that example, because otherwise in what sense are you really using jQuery? If you just wrap the innerHTML call around a jQuery initializer then are you *actually* using it? DOM manipulation is a very big part of jQuery and you are misleading if you say that jQuery performance is the "least of our problems" when it's literally the difference between 50ms and 500ms. Don't take my word for it that DOM manipulation is important in jQuery, take it from the jQuery foundation themselves: &gt; jQuery is a fast, small, and feature-rich JavaScript library. **It makes things like HTML document traversal and manipulation**, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript. As I said in the post there are many very good uses of jQuery and we use it quite a lot at Imgur, even on the very captions page I'll be writing. Binding the actions of the upvote/downvote buttons is a prime example, because jQuery's `on()` method makes it so easy to ignore re-binding every time you insert a new caption or whatever. jQuery has its place. 
coffeescript? I would have used this but I won't waste my time with it now that I see all the .coffee This would have been far more useful to the world if it were all javascript. Fuck coffeescript.
&gt; I ask because I do something similar these days with js for hobby projects, but can never take them beyond that because setting up and managing a backends is too complex for me at this point By "setting up and managing backends", I assume you're talking about the whole process of coding and deploying something to persist data. Luckily, if you're not interested in stuff like that I think you could pretty quickly launch your hobby projects by persisting data on something like Parse, Kinvey...something like those. Really, you could go even simpler and just use [localStorage](http://diveintohtml5.info/storage.html) in a lot of cases, like little quiz games or whatever. &gt; and now I really don't know where to begin with it. Any advice? I think it's like most things tech related; if you want to know how to make something happen, the resources are almost certainly out there (and are almost always free!) and you'll figure out a way to make what you want happen. Other than that, I guess just write tests for all your code, it really is faster in the long run. Welp, those were some words! I hope you got something useful outta them! Good luck
Okay...?
I took that to mean that their server-side apps are now just going to spit JSON for comment data, and all layout will be created in the browser.
snif snif... TRRRRRROOOOLLLLLL!!!!!!
This belongs in r/coffeescript, not r/javascript. You're the troll.
Why not use something like Handlebars with pre-compiled templates?
So polyfill it.
Why polyfill when there is jQuery which abstracts all of the browser incompatibilities for you?
Because polyfills let you fully separate your logic from your cross-browser code, they let you take full advantage of native performance when it is available, and they let you program with a standards-compatible API, which makes your code more portable and more future-proof. If done correctly, a polyfill will not have cross-browser differences to be "abstracted away". And for most ES5 features, like classList, forEach, etc, polyfills are readily available - they're as easy to use as jQuery.
Thanks for all the resources! You're one of the first people not to suggest "Just read Crockford's *Javascript the Good Parts*. I am now 'watching' your gitHub project and look forward to checking it out.
jQuery does NOT EVER abstract away the performance differences in the browsers. A browser that's fast at a particular activity is going to be fast with that activity whether you do it natively or jQuery does it. The right way to add masses of DOM nodes has sometimes been extremely dependent on the browser you're using.
Thanks, it did help a bit. By not knowing where to begin, I meant the options to choose from being so vast its hard to know which one to run with to start learning, and was wondering what you used.
You responded to my comment about collecting performance statistics. It was ALL about performance statistics and not at all about the advantages or disadvantages of jQuery. Why the fuck did you respond with something that wasn't relevant to performance?
Improve it so that it makes sense. You shouldn't have to look up a table to see what bizarre completely unexpected results are causing your bug, when the design of the language is itself at fault. It's not just about being strongly typed, it's about respecting common sense. '' == '0' //false 0 == '' //true '0' == 0 //true false == 'false' //false false == '0' //true false == undefined //false false == null //false null == undefined //true ' \t\r\n ' == 0 //true From Doug Crockford's talk on The Good Parts: http://youtu.be/hQVTIJBZook?t=14m58s
Came here to say exactly this.
This comes across as irrational. Possibly as though you're protecting your investment -- something like "I learned it, don't go fixing it now." Or possibly like you're protecting territory -- "I had to put up with it to get where I am, anybody new should have to do the same". Neither of those is a good reason to not fix the eccentricities of the language.
You would be surprised how many applications depend on obscure behavior. I've processed gigs of script crawled from the web as part of breaking change investigations for the TC-39 committee. I've seen a lot of interesting code. For example, who would think there would be code using bare string literals as comments?
I'm very excited to use AngularJS in my next project. It was a big mistake to not use a data binding framework on my current project (although I will say, it was not expected to support nearly as many features as what it's turned into). I'm having to routinely template repeaters and programatically clone and fill in the data. Updating entries via ajax always sucks, having to get the current data, present it into the template editor, merge the changes back to the DOM where they were originally presented, etc... Getting old very fast to do this manually with jQuery. I have a number of components that have to interact with eachother, having a framework that supports nice dependency injection will be a big plus. Very excited for Angular, have been watching many videos and playing around with some labs. Had first looked at backbone, but I like angular better.
Cool screencast! It's interesting for me to see someone develop with Angular against PHP, I've mostly been developing against services (RESTful and psuedo-RESTful) that are written (sometimes by me, sometimes by others) in .NET or Java.
Dude, you need a new font and maybe a sub to [r/web_design](http://reddit.com/r/web_design).
Hopefully someone finds this entry useful, or *even better (!!!)* corrects me somewhere and then I learn something new.
You and /u/Rhomboid are mistaken. If your goal is to insert the comments on the client-side, DOM manipulation is actually the fastest method to get content onto the screen. Think about it. Which is better?: 1. 1000 comments worth of data 2. Generate HTML for 1000 comments 3. Browser must parse 1000 comments worth of HTML 4. Browser must manipulate DOM to insert comments OR 1. 1000 comments worth of data 2. JavaScript manipulates DOM to insert comments I don't have to tell /r/javascript users that JS is closing the gap on native code, besides the fact that most of the heavy lifting in this task is already in the native DOM functions. The real question is: Why is OP loading 1000 comments in one go? Surely an paged AJAX solution is better here. Also, why is jQuery almost an order of magnitude slower here?
You're wrong, r3jjs is absolutely right. Javascript doesn't need "fixing". It is what it is and it has been for a VERY long time. To "fix" it would be to break it. You don't go throwing out the baby with the bathwater. There aren't that many quirks that come up if you are straight-forward with your coding. Almost every language has similar quirks. Even assembly language on most CPUs have undocumented opcodes. They will do unusual things if you use them. It's no surprise. 
Yeah, I've been building against Rails and previously Java services; I chose PHP due to the fact that nearly every hosting provider has it available and Laravel 4 is actually really nice for a PHP web framework ;) 
While angular can do this quite nicely, is it that easy to just add Angular components to an existing website or do you have to rewrite the site with Angular in mind?
I'm afraid you are simply wrong about innerHTML. DOM manipulation is faster because there is no generating and parsing involved. Also, his test constructs 2000 comments 25 times.
In my testing, innerHTML trumps^\* thinDOM in everything except Chrome. It's obvious that most of the slowdown is in the multiple $([tag]) calls. You could probably speed this waaaaay up by building your own jQuery. ^\* or is as fast as within the error bars
Here's the innerHTML test: function CreateCaptionInnerHTML(caption) { var points_plural = (caption['points'] === 1) ? '' : 's'; var container = document.createElement('div'); container.setAttribute('class', 'caption'); container.innerHTML = '&lt;div class="votes"&gt;&lt;a class="up" href="#"&gt;&lt;/a&gt;&lt;a class="down" href="#"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class="meta"&gt;&lt;span&gt;Arthur - &lt;/span&gt;&lt;span&gt;'+ caption['points'] +' point' + points_plural + '&lt;/span&gt;&lt;/div&gt;&lt;p&gt;'+caption['caption']+'&lt;/p&gt;'; return container; } It creates one comment at a time. If it created multiple comments it would look like this: function CreateCaptionInnerHTML(captions) { var htmls = captions.map(function (caption) { var points_plural = (caption['points'] === 1) ? '' : 's'; var html = '&lt;div class="option"&gt;'; html += '&lt;div class="votes"&gt;&lt;a class="up" href="#"&gt;&lt;/a&gt;&lt;a class="down" href="#"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class="meta"&gt;&lt;span&gt;Arthur - &lt;/span&gt;&lt;span&gt;'+ caption['points'] +' point' + points_plural + '&lt;/span&gt;&lt;/div&gt;&lt;p&gt;'+caption['caption']+'&lt;/p&gt;'; html += '&lt;/div&gt;'; return html; }); var container = document.createElement("div"); container.innerHTML = htmls.join(""); return container; } And then you'd pass in a 2000-long array for `captions`. This is more representative of the actual performance problem he describes, which is on a page with a lot of comments.
You were right about innerHTML and the test setup. I stand corrected: http://jsperf.com/thindom-vs-crel/4
Which minifier are you using that preserves line numbers? Even Closure Compiler with pretty_print enabled would make optimizations (stripping comments, adding ternaries, etc) such that something like function foo (a) { // this is a code comment if (a === 1) { return "yes"; } else { return "no"; } } would turn into function foo(a) { return 1 === a ? "yes" : "no" }
Doesn't the browser still need to paint those inserted comments? However, I agree that a lazy-loaded comment stream would be much better.
That's not entirely true. Each time a new browser gets released, some bugs will be fixed. Some applications could depend on those as well. Further than that, sometimes features are removed.
This behavior of ES3+ is standardized. It's not a bug. &gt;sometimes features are removed Yes, about 15 years later, that is.
see this is where it makes no sense, why the hell would the back end even need to know about the dom structure. The dom structure at that level is an extension of the algo, wether it be in an imperative or functional language. 
If I ever needed a reason to not use Angular, I think I just found it. I absolutely cannot imagine a serious programming team looking at a full bug tracker and saying, "ah well, lets just not fix all our broken shit." The lack of accountability is staggering. Seriously - abandon your project before you abandon your bugtracker. . [Edit: Yes, I know it's an *issue* tracker technically, I get it. That still **does not excuse** throwing the baby out with the bathwater.]
April Fool's!! Good one, guys, if a bit late.
If it is that important, it'll come up again. This is not an abnormal approach and is often done in many industries. So much time and effort is lost to focusing on every little detail. When there is just a big cloud of issues it's near impossible to determine the wheat from the chaff in any kind of feasible and practical manner. So wipe the slate clean and the important stuff will come back. Also this is referring the ISSUE tracker, not a BUG tracker. There is a significant difference.
errorception.com has a freemium plan
[errorception](http://www.errorception.com) *^if ^this ^link ^is ^offensive ^or ^incorrect, ^reply ^with ^"remove". ^\(Abusers ^will ^be ^banned ^from ^removing.)*
well this is the appropriate way to handle it. if I look at other projects (hello laravel) the maintainer just closes open pull requests on an old stable because the new version alpha is out and takes over the bug. going through all old issues and closing them all without informing anyone. so yes, this is a better solution, angular peeps. thanks!
Wow... so someone has taken the time to fill out an issue report... and their response is to automatically close it without anyone even looking at it. Kind of a big fuck you to folks who took time to report a problem.
I can't agree with any of that. "It's always been this way" is not a reason to resist improvement. Javascript was developed to allow non-coders to write code that would at least run. It's changed since then, but it's still restrained by those original design decisions. Other languages aren't just as bad. Perl may be the only widely used language that is. But again, that's no reason to resist change. But sure, keep javascript as is. I'll throw it out with the bathwater.
&gt; There is a significant difference What is the difference?
Did you read the post? As lostjimmy echoed in another thread, its only issues older than 15 days and the reporters of these issues will receive a notification with a link to reopen the issue if it remains unresolved by their latest release.
I disagree, they acknowledged they have a crapload of open tickets, they acknowledged that some of them have already been fixed, and they are very aware that they cannot go through the open tickets due to the number of hours per day and close each one. They're asking the community, who put those tickets in the first place to let them know. The best part is, is that they're being open about their process - this time. I've seen tons of projects, where we report bugs, and the developers would just close it saying it's not a bug and it's not being fixed without any explanation and that was the end of it.
A bug tracker tracks only bugs. Issue trackers track everything from bugs to "Can I have it in blue?" Obviously this is a semantic naming convention - but I felt it pertinent to point out the difference when /u/krues8dr seems to refer to it only in a "things that are broken" context. 
Ah. I guess just pick one and start futzing around. I'd recommend [Sinatra](http://www.sinatrarb.com/intro.html) or [Express](http://expressjs.com/api.html).
Misleading headline. Read the post: &gt; Additionally, we believe that the majority of these issues are already addressed by PRs or are no longer valid for other reasons. [...] Next week, we'll be running a script to automatically: &gt; &gt; * Close issues older than 15 days that have no linked pull request. &gt; * **Send an email to the issue reporter with an option to reopen if it is still an issue.** If you filed an issue which you think still applies, just reopen it.
The error message doesn't need to support source maps. You should be able to take their error message (looks like you get line and character) and then you can use the source map to figure out the correct point in the original files. Have a look to see if there is a tool that can take a line number/character and give you the position in the original file (try https://github.com/mozilla/source-map#sourcemapconsumerprototypeoriginalpositionforgeneratedposition) or you can look at the spec (https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit) and build your own
Fair enough, but it's clear from commenters' reactions that they didn't read the post.
Are you having significant problems writing Javascript? If so, please elaborate on what they are. I have no problem writing JS and have worked on huge projects with multiple people, and we never have found a problem with Javascript, maybe with the DOM, but I can't say that any part of Javascript has hindered us in any way whatsoever. PHP has plenty of warts and is worse than javascript in many respects, and many people will tell you that. I also don't see Ruby as being so reliable given its track record and the debacle it caused at Twitter a while back. coffeescript is an ambiguous clusterfuck, and the v1.5 release demonstrates the problems with relying on it, as well as many other easy to argue issues with it. While C++ isn't a web technology, there are plenty of haters there too, and many WTFs with it. I really don't see how you can single out Javascript as being any worse than any other language. It makes you seem confused, or very noobish. 
I take it you're the author of the post? Let me say I liked it, I think it was well done. I agree very much with the underlying point. I do have a few problems with it though. I felt it was a bit sparse in both overall data and in elaborating your conclusions/points. It's not clear what I'm supposed to take away from this. Are you planning on using thinDOM at imgur? Here's a typical scenario for some front-end devs: - I need to do frontend, yay jQuery makes everything eay and fun. - Hm, naively written jQuery is slower than molasses in Janurary. - I know, I'll write my own DOM manipulation library/jQuery sucks because it's slow/some other misguided notion **no, no, no, no, no** As the famous diatribe against regular expressions goes: now you have *two* problems. Here's what we should be doing: - I need to do frontend, yay jQuery makes everything eay and fun. - Hm, naively written jQuery is slower than molasses in Janurary. - I know, I'll **rewrite my hot code so it is less naive**. - If it's still slow, I'll explore the many other lightweight DOM libraries. - If I have a problem with one of those, I'll sumbit a patch. - If I have a very good reason for not doing that, I'll write my own. Let's take a look at your original code: function CreateCaptionjQuery(caption) { var points_plural = (caption['points'] === 1) ? '' : 's'; var captionDOM = $("&lt;div /&gt;").attr('class', 'caption') .append($("&lt;div /&gt;").attr('class', 'votes') .append($('&lt;a /&gt;').attr({'class': 'up', 'href': '#'})) .append($('&lt;a /&gt;').attr({'class': 'down', 'href': '#'}))) .append($("&lt;div /&gt;").attr('class', 'meta') .append($("&lt;span /&gt;").text(caption['author'] + ' - ')) .append($("&lt;span /&gt;").text(caption['points'] + ' point' + points_plural))) .append($("&lt;p /&gt;").text(caption['caption'])).get(0); return captionDOM; } This is fairly representative of what Joe jQuery might write, but you're imgur - a hugely popular site; you're also a smart guy, I believe you can do better. &gt; Again I tried to be as paradigmatic as I could in that example, because otherwise in what sense are you really using jQuery? You're creating a false dichotomy. The whole point around jQuery is it makes things easy and takes care of a lot of grunt work for you. In most cases it won't matter. However, there's no law that says you have to write your hot code in the quickiest, dirtiest, easiest way possible. jQuery provides **helpers** you're not locked into using them. Let's rewrite the code to be less naive. First, you're recreating basically the same little bit of the DOM over and over, let's do that upfront: var capD = $('&lt;div /&gt;').attr('class', 'caption').get(0); var upD = $('&lt;a /&gt;').attr({'class': 'up', 'href': '#'}); var downD = $('&lt;a /&gt;').attr({'class': 'down', 'href': '#'}); var votesD = $('&lt;div /&gt;').attr('class', 'votes') .append(upD, downD) .get(0); var metaD = $('&lt;div /&gt;').attr('class', 'meta').get(0); var sp = document.createElement("span"); var par = document.createElement("p"); That's still pretty idomatic. IMHO it's pretty simple, clean, and easy. **Notes:** - *.append()* takes multiple arguments, you don't need to call it multiple times. - This could be cleaned up a bit more, or just done different ways. I opted to just mostly leave it alone. - passing an html string to *$()* is really nice, but it's **slooow**, don't do it in hot code...and especially if you don't need to. So we got that work out of the way, now lets build our comment: function CreateCaptionjQuery(caption) { var author = sp.cloneNode(); author.textContent = caption['author'] + ' - '; var points = sp.cloneNode(); points.textContent = caption['points'] + (caption['points'] === 1 ? ' point' : ' points'); var cap = par.cloneNode(); cap.textContent = caption['caption']; var captionDOM = $(capD.cloneNode()) .append( votesD.cloneNode(), $(metaD.cloneNode()).append(author, points), cap ); return captionDOM[0]; } **Notes:** - We don't need to "jQuery ALL the things". - *.text()* does a bunch of fancy escaping and stuff, if you don't need it you can use something else. - Again, we can use fewer appends. - *.get()* does a bunch of fancy stuff, it lets you do stuff like *.get(-1)*...if you don't need it, don't use it. So we took maybe 10 minutes to rewrite our hot code to be a little less naive and use a bit less magic. Some quick benchmarks on my box put the new version at several times faster than the old version. It's still pretty easy, and clean...and now we don't have to use/maintain some entirely new and separate library. That's just if we do a quick rewrite to take care of the obvious stuff. We could do even better - using less magic, exploring alternative ways of doing things. We could optimize the other versions too, but the point here is not to get the absolute fastest version possible. The point is to get something that is quick and easy generally, and that we CAN make faster when needbe. In most cases the fact that jQuery is slow doesn't matter, sometimes though the difference is 50ms vs 500ms as you say. However, you're not stuck. You can put in 10 min and get it down to 50 vs ~300. If that's not good, you can put in more time and get it even lower. That's not to say jQuery doesn't have some issues. There's *a lot* of things I don't like about it. However, it's widely used (hence good tooling and wide availability of knowledge), it's pretty easy to get things working quickly, and it mostly works. With the exception of things like bugs and bad design decisions here and there, it's generally slow for a reason. Usually it's taking care of a bunch of stuff behind the scenes for you. If you don't need that, you don't have to use it. That's also not to say you should always use jQuery. Lot's of times you can get away with using one of the lightweight wrappers around the native DOM api. However based on the blog post it seems to me that overall it's probably more robust and less work for you to just optimize the problem areas rather than coming up with a new library to either replace or augment jQuery. If it gets to the point where you hardly every need any of jQuery's magic and the speed is an issue, sure use a lightweight alternative. Maybe even write your own, but that would not be my go-to solution.
Web Components are the future of the web. They are seriously committed to this. AngularJS is a temporary solution at best.
I *think* (maybe wrong) what most people do is build/minify their code for deployment so that the browser can reduce the number of HTTP GET's for scripts. i.e. if B.js requres A.js and C.js requires A.js , your build phase might create app.min.js which includes the minified result of all 3.
So... "Thanks for filing an issue. We have no idea if the problem has been fixed or not... but we certainly are hoping it has. Please retest with the latest build and reopen the issue if the problem still occurs."
To wit: http://jsfiddle.net/FFzG6/2/ 3 times faster in IE10, ~20 times faster in Chrome. What I find interesting is the speed difference between '$("&lt;div /&gt;")' and 'new $("&lt;div /&gt;")' in Chrome, using the 'naive' approach. Though, that difference is nonexistent in FF/IE.
Phony due to the fact that it is complete BS - it was just an API client
Currently down due to DMCA takedown - see http://www.reddit.com/r/javascript/comments/1eugcx/so_my_grooveshark_api_client_was_removed_by_a/ for more details
The idea of cloning and replacing is good. Thanks. The main point to take away from my post is that "jQuery, like all abstractions, leaks," not that naively written jQuery *can* be slow, which seems to be the point that most people took away. The classic example would be making a string algorithm O(N^2 ) rather than O(N) because you didn't cache strlen. I think the fact that there is very little data out there on different ways of using jQuery that are slow or fast makes me a little bit uneasy. It's the exact example that Spolsky talked about in the leaky abstractions post that I wanted to call attention to: &gt; Something as simple as iterating over a large two-dimensional array can have radically different performance if you do it horizontally rather than vertically, depending on the "grain of the wood" In this case, using append with one argument repeatedly is slower than using append with multiple elements, and creating new nodes is slower than cloning old ones. In all of these cases the jQuery interface will happily let you do it, with absolutely no details on what is slow without doing this statistical analysis to get behind the opacity of the jQuery code. I wrote my example as paradigmatic as possible to emphasize the leakiness. The DOM method for appending a child node only has one argument so intuitively if I pass just a single argument to `jQuery.append` it should be almost always a pass-through to DOM `appendChild`. Again, it goes back to a bit esoteric performance details that are all abstracted away by jQuery's leaky abstraction. 
Hope no one minds me posting a link to my little JavaScript/canvas experiment here. Not sure if this is the best subreddit...I know the conversation here tends to focus on other aspects of JavaScript.
Indeed. If we wanted we could get even more speed by removing all jQuery from the hot function: [http://jsfiddle.net/FFzG6/3/](http://jsfiddle.net/FFzG6/3/) function CreateCaptionjQuery(caption) { var author = sp.cloneNode(); author.textContent = caption['author'] + ' - '; var points = sp.cloneNode(); points.textContent = caption['points'] + (caption['points'] === 1 ? ' point' : ' points'); var cap = par.cloneNode(); cap.textContent = caption['caption']; var meta = metaD.cloneNode(); meta.appendChild(author); meta.appendChild(points); var captionDOM = capD.cloneNode(); captionDOM.appendChild(votesD.cloneNode(true)) captionDOM.appendChild(meta) captionDOM.appendChild(cap) return captionDOM; } Not the most beautiful code, but still pretty readable - especially if comments were added. It's fine for the example; if we were doing more stuff like this I'd look into more robust templating solutions. 
Uh, what?
You're the lamest developer ever.
Yeah with a 100% money back guarantee if it isn't fixed. Sheesh, what an entitled brat.
Could you not read my comment, or do you you struggle with picking up on obvious sarcasm?
I mean, it's not really that hard... It's obviously not April Fool's day.
You may want to focus on what problems Takeoff solves. I can sort of guess what it does, but your first paragraph reads like a politician wrote it.
Any chance you're on Windows? Some approaches to aliasing makes the font _really_ terrible. The site needs a re-design in general, I had to disable one of the more visually appealing bits because d3 is unreliable on mobile. 
Right. Hence: why asynchronous?
Very cool, too heavy on the CPU for my older macbook air, which is odd because it the machine it works well on isn't that much faster.
&gt; cache manifests You are a brave man. The Application Cache API breaks harder and faster than anything I know.
Yeah, I don't recommend it, except when absolutely necessary. We used it to store stylesheets and whatnot, so it wasn't too bad, local storage did most of the work. That said, the worst bugs we ran into were mostly with syncing to the server. That, and a horrendous android 2.2 browser bug that found me reading the webkit c++ source after hours of searching and debugging. Fun times. 
You should checkout TypecastJS.org
I wrote a web app that took user data and stored it in local sql, and synced with the server when it could. I stored all of my application ui, and client logic using cache manifest. What alternative is there to this?
We were able to limit our application to webkit and used the cache manifest to offline all the files and then used a sqlite database in the browser. Runs on iOS and android and is pretty fast, too. We had to implement some fancy notifying and self-refreshing to handle letting the cache manifest update the files, but it's not too bad. Intuitive SQL, so it's actually really easy to clone (or mostly clone) a true SQL table from the backend during the sync process. We used basic javascript xmlhttprequest stuff to retrieve/send data.
sooooo sick!
I made a pretty sick beat, but it slowly died as the beat got more complex. :(
Yea, That was on my Windows 8 box. The font does render better on OSX.
I'm working on implementing a PouchDB solution. I'm not sure if it's production ready or not yet (fingers crossed) but if not it seems like the strongest starting point for rolling my own.
Haha, yea I forgot about that one! While it's good, it's aimed at more experienced programmers. (I just added it to the middle and end of the list). I also stumbled across a few tuts a few mins. ago and added them to the list (dev environment and an underscore tutorial).
really cool, will you be adding a save/share feature?
Absolutely! I had issues with that :( *Is* there an alternative? 
Very cool. Great work!
meh
regardless of whether or not you're using strict mode, typeof is usually the best option. resolving uninitialized object properties is *slooooow*
1.0.* = stable branch; 1.1.* = unstable branch
This must be the 20st-something class inheritance framework for JS I've seen. While class inheritance may have its practical uses, most scenarios based on JS are not among them. Therefore, introducing class inheritance for JS is fixing something that's not broken. 
Wow, your friend really sucks at handling data within the right context. Otherwise he'd have escaped those double quotes before putting them to HTML.
Incredible way to trigger epilepsy!
&gt; DOM manipulation is actually the fastest method to get content onto the screen. ...and any decent templating system should generate JS that does exactly that. How did you think they work? By doing simple text replacement and then using `innerHTML`? That would be pretty slow indeed. 
&gt;Finally, inlining HTML templates leads to some pretty messy code and disorganized templating. I've yet to find the perfect template solution. I've found RequireJS + the tpl plugin to be a godsend for this very use case.
Nice, they incorporated ui-if into the core.
Oh that's interesting. What happened? Did it get noisy? Had a few reports of that. Will look into it. Thanks for letting me know!
Hopefully! Based on feedback, it sounds like it's something a lot of people would like.
Does Grooveshark 'terms of services' allows you to build such as API?
Moreso than that, ASM isn't even close to a full JS implementation. It is a small subset specifically designed for performance, specifically designed to execute with a minimum of optimization or interpretation. The real-world usefulness is therefore rather limited.
It got noisy here, too, as the beat got more complex. And simplifying it didn't help. Chrome Version 27.0.1453.93 for Mac OS
It might even make sense to combine the two and have Dart compile to asm.js rather than full-syntax java script, if your browser doesn't support dart directly. 
asm.js CAN be run in slower javascript - but it's also a subset of javascript that CAN be run faster (and unlike DART other browser vendors are trying to implement it). Of course Dart is faster than javascript, but use C in NaCl and that will be even faster. Also you should compare Dart compiled to JavaScript with JavaScript that is also run through a compiler. And if you add in type information (say through typescript or type annotations with Closure) you'll probably find well written javascript is faster, and that's what matters because the Dart VM is not going to be put in by other browsers (or if it is then it'll probably be run on top of NaCl or something and so the performance enhancements won't be as large. Have a look at http://j15r.com/blog/2013/04/25/Box2d_Revisited (I know it's not a fair apples to apples comparison, but you can really see how asm.js shines, and because it can run on a normal javascript engine it should run anywhere, even if slower). In the end portability wins over performance, or we'd all have swithed over to program the browser in C by now. What I'm betting will happen is that the browser will take on more of what javascript does now natively so javascript programs will become smaller (just look at how much less code an angularjs program is) and that's where the performance gains will be had in future, by not having to have as much code written or run.
that's bullshit... even if you did somehow violate their terms of use, or circumvent DRM like they claim, the DMCA notice should state that, and not make false claims. Get a lawyer
Chrome PC (don't have the version). The sound got distorted and seemed to slow down. I guess I would describe it as noisy. I also wasn't able to recover by taking away some complexity. 
The benefit of ASM is that it runs in any browser, sure it only gets the speed benefit if the browser implements it, but it is backwards compatible.
Is it possible to use this for only part of the code? if so I can see it being very useful. We can carry on using convenience methods for most things and just optimize those parts that need it.
A library is just a collection of code, organized in a way that makes it easy to reuse. Every computer language has libraries, but you have to learn at least a bit of the language to use the library. Here is an introductory course to get you started: http://www.codecademy.com/en/tracks/javascript
And yet mozilla *still* benchmarks slower than IE10 
jQuery style manipulations, changing positions/graphics.
It's not _that_ big of a deal.. You only need to change the content of the manifest.. You can do that server side if you want..
Ah thank you.
Yeah they keep saying near native performance about java too and that's not true either. That's not to say this isn't a good thing though :)
Your second point is I think more important. First is easy to implement so it's a non-issue to me at least. You do have to learn a new language, but for it you get web-specific libraries to ease DOM-access woes.
Yes. Add `"use asm";` to the top of the function you want to optimize. This function must then use only the JS allowed in asm.js or it will just be run as normal.
Are browsers implementing ASM? Last I read no one was jumping at it. And to be fair the same goes for Dart. But the thing is, portability is a non issue. They both fall back to normal JavaScript. So I see more developers going to Dart and just letting Chrome run it in Dart, and everything else run it in JavaScript. The performance will basically be the same as if they hand coded it in JavaScript (in some cases even BETTER), but they get the ease of development. So why not? It'll save you time, and probably even allow you to write better apps because of it. I don't see the appeal of developing for ASM over Dart for the web, but that might just be me, as I'm more experienced in JavaScript/HTML than I am C/C++ and associated libraries available. The way I'm seeing it here, once everyone's already developing in Dart because it still works everywhere and is just easier, it will just make sense for browsers to implement the VM since there would be so much Dart code already out there. Just my thoughts though! For the record, I think both technologies are incredibly awesome :-). I guess ultimately both will be appropriate for different things, and hopefully at the end of the day both Dart and ASM are widely supported. For the time being though I think investing time in Dart is worthwhile.
Dart is dynamically typed so I'm not sure that would be possible.
In the realm of software development, pictures generally only feature when describing more complex concepts. You may need to get used to learning from text if you want to learn javascript. Javascript began as a scripting language used primarily to enrich HTML content, as the language has matured its responsibilities and capabilities have grown and it now features as a language used to create web applications and to implement server side logic. Javascript can either be used in its raw form or with libraries, libraries are collections of javascript functions which have been developed and matured for a specific purpose, animations or date formatting for example, both of which would take a long time to implement yourself and cater for each edge case. Have a look at some basic javascript programming tutorials to get you started, the libraries wont make too much sense without at least a little basic understanding.
Not sure why your macbook blows, it was just fine on my PC in chrome. I don't have anything fancy for a pc either.
I think there's a difference between use-cases for ASM vs Dart. ASM will probably be used primarily for cpu-intense 3D rendering kinds of things, where Dart would probably be used more in a line-of-business kind of web app. 
If that would make sense, there also would be a JS/CS/TS to asm.js compiler, but there isn't any. The asm.js subset is very limited and very restrictive. It works for C/C++, because it is like C/C++. That's also the reason why it's that fast.
Your macbook's browser sucks then :S works fine on chrome &amp; firefox in windows.
That sounds entirely unappealing, then, as a working environment. We don't really want to go back to writing C when we've become used to modern languages with, at the very least, automatic garbage collection. This approach is doomed.
Can confirm it brings my 2-week old 13" MBP Retina to a crawl as well. **Edit**: Not smooth on Chrome, smooth on Firefox.
http://asmjs.org/faq.html &gt; **Q**. Can asm.js serve as a VM for managed languages, like the JVM or CLR? &gt; &gt;**A**. Right now, asm.js has no direct access to garbage-collected data; an asm.js program can only interact indirectly with external data via numeric handles. In future versions we intend to introduce garbage collection and structured data based on the [ES6 structured binary data API](http://wiki.ecmascript.org/doku.php?id=harmony:binary_data), which will make asm.js an even better target for managed languages.
13 inch MacBook Pro on an external screen: runs great.
there isn't any... yet asm.js is a specification that is still relatively new. I guarantee you that the guys behind things like the Closure Compiler will be looking in to this
you can define types right? and the compiler should be able to infer types. Sure there may still be some parts that are dynamic, but I don't believe everything has to be written in asm.js. You could compile some parts of the code so that they are asm.js compatible and the rest in plain old jane javascript
My PC with Chrome is better, but the scroll interaction is still not as smooth as it could be. Don't get me wrong, it looks great, but scroll events not handled with care turn out sluggish.
What's the relevance of this comment? Benchmarks do not even use asm.js.
Felt like inciting a riot. It didn't work 
What is the actual question? Their JavaScript files aren't obfuscated. Check it out and learn!
Can't imagine this project will be more stable or better maintained then Yeoman, which has quite the development team behind it and already has momentum. Having said that, what is the exact difference? They're both tools to scaffold a web project with Grunt.js right?
Thanks! I'll check it out.
Yeah, I chose Laravel in an effort to appeal to as wide an audience as possible but was pleasantly surprised with how nice it, and PHP 5.4, are for webapp dev. I have another video coming early next week that focuses on Security in the AuthService and a few more tricks inside of Angular, stay tuned :)
Thanks for the feedback, let me know if you have additional topics you'd like covered. I've been using responses to gauge where to go next.
Mine's as smooth as I would expect from JS. There's a bit of a stutter if you go too fast but that's to be expected.
I can highly recommend the Skrollr library for this: https://github.com/Prinzhorn/skrollr
Downvotes with nary an explanation. Thanks for confirming the bias, folks!
Stop going on about Dart please?
Mozilla is toast. They can't keep up
the onmousewheel event. 
Shoulda sprung for the i7
Well, a riot of downvotes--still something. :P
This is why I never deal in raw html on client side scripts Also he did sterilize them he just used \" instead of &amp;quot;
So...does that mean that you're pegging the CPU (using 100%+)? If not, what do you mean by "server is coming to a crawl?" It could be a simple Apache misconfiguration...?