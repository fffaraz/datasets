That's set in the original canvas and isn't necessary for my case. Also, it's not related to my original question. I know how to set preserveDrawingBuffer, composite it, save the data on the backend etc. The problem is that in safari ios, everything looks like its right.. preserveDrawingBuffer = true, but it just returns empty data. I'm trying to detect this condition. 
A bunch of users/contributors hang out on https://gitter.im/lhorie/mithril.js. Some of us are using browserify or webpack (and experimenting with the webpack ~~successor~~, whose name I am blanking on EDIT: https://github.com/rollup/rollup EDIT2: rollup is not the successor to webpack, and webpack2 supports imports and tree shaking ). http://j2c.py.gy/ is pretty popular with Mithril users for styling components; using j2c with mithril makes it really pleasant to build components with isolated styles. Leo, the original author of Mithril, is working on a rewrite which will be a fully modularized codebase, among other things. Mithril is pretty small itself; you can read through the source in a few hours. Mithril is similar to React and other virtual DOM libraries. I've written a few "web apps" in mithril (previously using jquery, backbone, and angular) and am quite enamored with it. It's the easiest and most powerful framework I have used, because the blog ( http://lhorie.github.io/mithril-blog/ ) and documentation is so good, and there are only 15 functions in the API. I should mention a lot of us are watching https://github.com/trueadm/inferno/tree/master with interest, which is much faster than mithril (which is already very fast) and all the other virtual dom libraries including React.
I have his book "Programming JavaScript Applications". It aggrieved me that so much of what I do (or plan to do) in JavaScript seemed wrong in his opinion. The author of an esteemed O'Reilly book being so opposed to the likes of ES6 classes made me think I shouldn't use them, which was disappointing. I then spoke to other developers who told me quite simply: Eric was talking out his ass. He's been grinding this axe for years and is looked on as a bit of a loony.
so, are you actually eric elliot? some reverse psychology mind games, hey? 
Thanks for the reply. There's a new [tool](https://github.com/sindresorhus/ava) called Ava. I'd love to hear anybody's thoughts on it. 
Hmmm, I don't know. I looked at the comments for one of those tweets and it seems like he's talking about reddit comment threads. Really, I don't blame him for thinking like that when people talk like [this](https://www.reddit.com/r/javascript/comments/3yk6hp/problem_of_eric_elliott/cyecxqe) and [this](https://www.reddit.com/r/javascript/comments/3yk6hp/problem_of_eric_elliott/cye95e4) about him here. 
This has been true in the past, and their are documented cases of this causing problems. Note: It's not actually the minification, it's the concatenation. If your file doesn't end with a semicolon, then it *may* become invalid JS when another file is appended to the end, depending on what the first character of the other file is. A naive build toolchain would minify every file independently, omit closing semicolons, blindly concatenate every file, and yes, potentially generate invalid code. Modern build tools are smart enough to avoid this, either through appending a semicolon to the end of every file, or being smarter about concatenation.
I really like mithril. It takes the view as javascript idea to another level - instead of having separate syntax that mimics the HTML, why not just have pure javascript functions? If you have functions, you can do all of your usual organization and refactoring work that you would do normally. Suddenly everything just falls into place. I'm also glad to see react start to do some of the same things - there's purely functional components in 0.14, which is *exactly* the direction I'd love to see react pursue further, instead of trying to tie everything to classes.
Here you go. http://cube-drone.com/comics/c/relentless-persistence
Oh god. So I'm not alone. This feeling is normal. That's actually really relieving.
Really? It's the same idea as react. The code even looks somewhat similar if you squint and don't use JSX with your react code. Remember that JSX is just sugar for function calls that return objects - just like mithril. If you really wanted to, you could even use [MSX](https://github.com/insin/msx), though practice I have not seen this used in mithril code.
I'd say the primary reason Angular took off more/faster than Ember is because it had google backing, so developers had confidence that it would be supported long enough that the time spent learning the API surface would be worthwhile. React, on the other hand, beyond also having a major label backing it (Facebook), has a tiny surface area and one can get started quickly. Having worked on Ember-based projects previously, it was not a great experience, but I honestly believe if there was IDE integration it would've made a massive positive difference (which I'd say is true of convention-over-configuration solutions in general).
I wonder if this is a reaction to the constant change. A way to place your head in the sand because you've become fatigued with the chaos. As someone new to javascript. I can't say that tooling isn't particularly fantastic. With C# I can just open visual studio and start coding, testing, versioning very easily after starting anew project. With javascript, I have to do all this finicky stuff with console commands, folders and text files and it seems like every project does it differently so there seems to be no shared best practices about the proper way to do such a thing.
Nice article. I've seen such a topic in a local JS meetup as well. Honest question: If someone is capable of fixing a bug in a software project, wouldn't they already be familiar with github and the whole process?
PS I really enjoyed your article by the way :)
We try to weed those out during interviews, we need stuff getting done at work the best way possible not famboys defending whatever they think is best. 
I don't really consider myself a good programmer. My first ever pull request went something like this 1. I found a joke javascript library called [five.js](http://fivejs.lol/) on reddit. 2. Someone asked for a five.jackson() feature. I figured, "Hey" there's already code in it that would work for that feature. Namely five.fab() 3. I copy and paste the fab five code and replace fab five with jackson five. 4. Guy in charge asks me to create unit tests for it (I have no idea what I'm doing at this point), so again I copy and paste the fab five code, and then create unit tests based of the fab five code. 5. Code gets patched and to this day it's probably in the codebase in some form. https://github.com/jackdcrawford/five/pull/147 Someone else was working on matching jackson five code, but nothing came out of it. I just did the same thing but actually made unit tests based on the fab five code. In my experience the maintainer was pretty chill about the whole thing.
It's a nice feeling as a noob coder to get your pull request accepted into a high profile project. I added a small feature to the Zurb Foundation framework, and they sent me some stickers. Mind you, I contributed one line of JavaScript, and there was a bug it in, but it still counts, so I have "Core Contributor to Foundation" on my CV.
There are a lot of comments not attacking his misinformation but the person, though.
Thanks for the interesting post! I have 2 observations - can you share your opinion: 1) When I click a submit button in the UI I do not expect with 100% confidence that the action will be successful. I realize the clicking of the button is a fact, however I regard that as a simpl e and unimportant trigger 2) in serverbased or API-based CQRS scenario I could easily regard the creation and sending of the API request as an event by itself (POST request to /resources created and sent), however I still regard the overall interaction as a command (client app is then the brain)
For mithril to get more traction there needs to be guides on how to do UI with it: modal popups (with bootstrap or whatever), form validation (sync and async). Angular gained so much support because you could do rapid prototyping; once people got hooked they stayed despite the challenges. For such libraries success is a function of learning curve (how understandable is the API), progress speed (how much you can achieve in terms of ux, productivity, testability) and fame (of the authors or company backing up the library)
You'll need some kind of sitemap or collection of urls, then you can e.g. do a recursive loop: function keywords(urls) { if (!urls.length) { // done return; } var url = urls.pop(); miner(url, (error, words) =&gt; { console.log(url, words); keywords(urls); }); }
The other comments are good reasons, and here's another, less commonly needed reason: In a security or api design context, unnamed functions cannot be overwritten by other (third-party) code just by assigning another function to that function's name. There is no name with which to replace it, only the place containing the reference to the function can be attempted to be corrupted.
Are you young? Coz that sounds like the whining of a modern coder to me. Modern coders seem to be too used to having everything done for them. They get taught how to code with languages that are have been around for a while, established and had people going over the crap for years. Almost all the little problems and what not have already been done for you (I rekn every coder should be made to code for a c64 in assembly at some point, thatll teach em ;). JS is young and only recently started getting real attention from the hardcore coders. And its not like js cant do what they want, its just that it doesnt do what they want out of the box, so they bitch and moan you cant do it until someone else makes something that allows them to do it....with the same language they bitched couldnt do it. JS is not incomplete, if it was then none of our code wouldnt do anything (heres why I think people should have to do c64, so they see how much they can do with a very limited command set). From what Ive seen most of whats being added to js doesnt allow us to do new things, just the same things with less code....otherwise we couldnt have things like babel. Really if you want something to bitch about its browsers, not js. I fell in love with js because of what it didnt have, it was the last simple language to me, in an environment (the browser) that I saw taking over everything (OSs). Sorry, just get a little grrrrrr, with all the js bagging.
What? JavaScript has the worst set of tools. I almost exclusively program in JavaScript but it's a fucking minefield. Whoever praises the 'tools' in JS is not someone whose opinion Id hold in high regard. IMO the beauty is the simplicity - only using a subset of language that isn't robust to begin with - but building your own tools and leveraging the most robust open source ecosystem in the history of programming.
Rollup is interesting indeed but it is in no way a successor to Webpack. Rollup bundles ES6 modules whereas Webpack bundles just about everything. 
&gt; (and experimenting with the webpack successor, whose name I am blanking on EDIT: https://github.com/rollup/rollup[2] I'm sorry but this is utter non-sense
Are you sure you need Babel to write server-side code? Node v5 supports a lot of new stuff out of the box, what is it that you're missing? Or do you mean client side?
I loved the idea, tried it, couldn't get it working with my ES6/babel toolchain easily. I keep meaning to give it another go one of these days, but time is hard to find.
I was nodding my head until: &gt; Problem: Prototypal inheritance is pants-on-head stupid Now there's an assertion just begging for some explanation.
I'd only do it because oldIE has a problem with hoisting named function expressions even though that's not in the spec, and Safari 2 (I know, a very old browser) crashes if a named function expression is used elsewhere than the right side of an assignment.
Sure, but that doesn't mean we should all jump on the hate train - you can also brush it aside and focus what's wrong with the information.
* With the first method (`onClick` attribute) you must expose `myClickFunction` to the global scope which is a big no-no. * The second method didn't work for me and I've never heard of it (maybe you saw jquery's implementation `$('#Button').click(myClickFunction);`). * As for the third option, this is the way to go, I use `addEventListener` and `removeEventListener` as they go hand in hand, and easy to remember.
IIRC the space of function names is different from that for variable names, and only code inside a function (where the function's name is in scope as an identifier) can reassign a function by its name; it just so happens that a function declaration *also* creates a variable in the scope in which it is declared. Try this minimal example: function a(){} // variable a, function name: a var b = a; // variable b, function name: a a = function c(){}; // variable a, function name: c a = function b(){}; // variable a, function name: b b; // variable b, function name: a c; // ReferenceError: c is not defined
Maybe the OP wants to use the new ES7 features that Node doesn't support because they aren't finalized.
This is great. Thank you so much.
No he just said it wasn't as good as it is now, he never mentioned how good it is now though. (could be horrible now and atrocious before) 
hehe, I wanted that soooooo bad when I was younger as it was the one language the scene didnt hate that I thought I could manage and couldnt get it! and a couple years later I walked away from computers for a long time and when I came back I got it, only years too late ;)
Did he screen for web crawlers though? They don't usually execute JS...
I use closure compiler which names them for me.
Awesome. While I haven't used Vue, they certainly have a point when it comes to the hurdles of setting up a JS project. The amount of boilerplates is insane and it can be still be very difficult to find anything that fits you. If you want to start from scratch, most of the build tool configuration tutorials are outdated as the tooling makes leaps each month. For example, I often want to quickly just try something in JS out of curiosity or inspiration, but I'd also like to use ES6/ES7 features and sometimes React/Redux as well. I've spent many nights just configuring tooling for some sudden spike of inspiration and it's faded by the time it's 2am and I could finally start writing code. When I get boilerplates, there's always excess stuff I don't want that effect the structure or workflow (e.g. universal/isomorphic rendering) or they are outdated and don't support whatever new thing I wanted to try out of the box. Unfortunately this also applies to the build configs I personally set up with the intention "Well, I can just copy this the next time". In the past I used a ton of online editors and I think they've been fantastic for *trying* things and maybe showing it to someone or asking questions. However, most of them are stuck in the single JS/CSS/HTML-scheme, when nowdays I want to just create a couple of separate JS modules and use a variety of small NPM packages in them. Even if the online editors support Babel and allow me to pick some of the modules I want out of a dropdown, cramming things in a single JS file feels messy within minutes. As much as I like the idea of picking all of your tools and having complete control over all versions etc, I wish there was just some software I can download or a website I can open, that would have a completely invisible build step that has all the latest bells and whistles. Give me index.js, ES stage 0 feature support, ability to add new files and just allow me to do "import module from npm/module" for the latest version of whatever I want. I don't really care what happens behind the curtains, as long as I get my output and clean errors fast and there's not bunch of bloat I didn't ask for. In fact, letting me into the configuration is worse, because I'll just feel compelled to optimise it and remove anything I don't want. Welp, way to steer off topic. Sorry, had to rant.
Compilers (like closure compiler) can not only handle code without semicolons, but they can add them for you during builds to fix the concatenation problem.
&gt;¯(º_o)/¯ Does this bot really not perform escaping? 
As has been said before, JavaScript is a lot less complicated than C++ and it's ecosystem, while huge and incoherent, is still much less of a minefield than Java's. The thing is that it's the only programming language you MUST use for web development so a lot of people that think that programming languages (some 30-40 concepts a piece) are the tough part of programming, so they created tons of frameworks (some 300-3000 concepts a piece) to "javascript all things". And yes, a lot of it is down to thousand flowers of open source. It tends to work as evolution, stop jumping at bandwagons and soon(ish) some de-factos will slowly emerge or prevail. But JS is still a beutiful language if you can grok the beauty, it's just that depending on your programming background, you'll be biased to value some aspects of programming where JavaScript might be lacking, but that is often just a matter of acquired taste.
`&lt;div onClick="myClickFunction"&gt;&lt;/div&gt;` - requires it to be accessed by global scope. doesn't allow binding. `document.getElementById('Button').onclick= myClickFunction` is pretty much same as addEventListener, except it doesn't allow `useCapture` param to be specified (More info can be found here: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). Both of them allows to use .bind for binding scope.
Oh that pink glass we look at the past through. I remember Turbo Pascal as one incoherent mess. Case in point: the standard library was literaly full of cases where one function was pass by value returning the value, and then a intimely related one was a pass by reference procedure (procedure is Pascal's void function). It was as bad as PHP std. library, if not worse. At least PHP's crappiness is greatly down to the fact that it's library is lots of thin wrappers around standard C libraries (that come from many sources), whereas TP's one was all written by Borland and was still horribly incosistent. Delphi and it's VCL, on the other hand, were truly the best UI development thing that ever happened, yet it failed miserably and the shitcrap of MFC somehow prevailed.
It also says I have a Theoretical Degree in Physics.
&gt;so I have "Core Contributor to Foundation" on my CV. Oh right yeah... just like how on my CV I have *"Freelance content creator for one of the most popular news and entertainment sites on the internet"*... which means I shitpost on Reddit a lot. Might as well get *something* for my comment karma, right? Don't lie on your CV, they'll ask about it and you'll have to look silly.
Catering to people that have JavaScript disabled is probably not worth the effort. But you really should handle if a script tag fails to load if your page requires JavaScript. At least put an onerror attribute there and inform the user/show a reload button.
Thanks for this article! It definitely makes me feel less nervous about attempting to work on some open source stuff. I've never worked with any of the technologies listed here (Before reading this, I had no idea what Buffer, Zuul, Saucelabs, or Travis were), but it definitely looks like something I need to look into. I also want to learn more about test-driven development. Do you recommend any specific resources for learning test-driven development with Javascript, node, and github? Thanks again. :)
&gt; Things worked or didn't work based not upon the structure of the objects and data, but rather the names those data were given. This is why I dislike convention over configuration.
they don't need a name when they're used intelligently. ``` RequestLibrary.post(url, data, function(error, succes) { if (error) { logger.error(error); return; } // other stuff }); ``` Naming that function gets me very little in the way of extra stack information. Either way with stack traces, I find myself glancing at method names and concentrating more on line numbers anyway.
&gt; I tried to use it, but at the time, for me at least, its api relied on humongous amounts of implicit knowledge. The tutorials were non-optimal in the early days. I've been told that they're much better now (I personally haven't looked into them, since I already know Ember). &gt;Things worked or didn't work based not upon the structure of the objects and data, but rather the names those data were given. Yes, that's a common theme in Ember. The classes have to be named in a certain way so they're picked up by the framework automatically. If you don't do that, you have to specify everything manually, which you really don't want. For example, the index route is the route that's used when the page is loaded with the main URL. It has to be stored in app/routes/index.js. A component has to be stored in app/components/&lt;name&gt;.js, and its corresponding template has to be in app/templates/components/&lt;name&gt;.hbs (with the same name) to be picked up. A model class is in /app/models/&lt;name&gt;.js, and if you want to customize the way it's loaded from/stored on the server, you have to write a serializer located in /app/serializers/&lt;name&gt;.js (again, with the same name).
Well that should go without saying
You can't really read Ember code unless you know the framework (thus, all the implicit behavior). Then it's easy.
Have a look at The principles of a vanilla web diet: http://vanillawebdiet.com/ Build on what works! Not what is shiny, cutting edge, cool etc. 
Even though I have defended Ember everywhere else in this thread, I have to concur with everything you wrote. 1) I spent 3 months last summer to find a bug with property dependencies with absolutely no tools available where I ended up not doing it the Ember way to maintain my sanity. 2) I've confronted the devs about this issue, but they don't know what I'm talking about. I had to spend a whole day just rewriting all calls to string.fmt(), just because they thought that you don't need it any more and just deprecated it. While they're basically right, this is a huge thing to change in a large codebase. At one point, they also switched that relationships in ember-data return promise objects instead of the objects themselves. This change came without warning, was undocumented in the release notes and broke my whole project. Just two weeks ago I found yet another bug due to this change that happened half a year ago. 3) Not only that, they also tell you to not do things in a certain way, but don't provide a usable alternative. For example, controllers are supposed to be going away for more than a year now, but routable components are still not there last time I checked. How am I supposed to write future proof code with this? 4) Yeah, I asked two Ember questions on stack overflow. Once got a single follow-up question with no help, the other received no response at all. 5) I actually like ember-data. It's like a full database on the client with syncing, and it works quite well for me. It might be over-engineered shit for small tasks, but when I have to use one of those over-engineered features because my project has to handle more complex operations, I'm always glad it's possible to do so.
&gt; Yes, that's a common theme in Ember. The classes have to be named in a certain way so they're picked up by the framework automatically. If you don't do that, you have to specify everything manually, which you really don't want. Yeah, i kind of really do want that. It makes errors much more shallow.
Interesting, I encountered [vuepack](https://github.com/egoist/vuepack) only few days ago, and now we got an official tool for that. I'd like to see templates with vue-router, vue-resource and vuex inside. Anyway, great job.
I'm not saying you're wrong, but the point is for things go be done for us. That's how we evolve. Any stack where you have to reinvent the wheel each time fails us to innovate. 
~~There is no such thing as `document.getElementById('Button').click(myClickFunction)`. You might have gotten confused with jQuery's .click().~~ `document.getElementById('Button').click()` does not assign an event handler, it triggers the click event. It does not take an argument, so `myClickFunction` will be ignored. 1. Avoid inline onclick attributes. Among many reasons not to use them: - tight coupling between presentation and behavior - code runs in the global scope - makes testing and debugging difficult - defies progressive enhancement - quickly becomes hard to maintain - also it will unbind any previously assigned click handlers which might be an unwanted side effect 2. If you're using vanilla JavaScript, use addEventListener. This avoids all the aforementioned problems and also gives you an easy way to disable the event listener later if needed (via removeEventListener). 3. If you're using jQuery, use either .click(myClickFunction) or .on("click", myClickFunction). They both use addEventListener (or attachEvent in old IEs) underneath. I prefer .on("click") just for uniformity when adding other types of event handlers, but .click() is just an alias for that.
This is the correct advice.
As a maintainer of a few popular open source projects, _thank you_. I have so many more things I'd rather be working on or that are more high priority. As a developer, this is very well written! I'm going to share this around.
function expressions don't require a named function so why do it? var bla = function() { } `bla()` and it's called. Why a name?
Why is it important? If Marko works for you, use it. Templating is not rocket science.
Delphi is what I picked when I got back into computers, unfortunately I didnt have the memory for it (couldnt remember all the details about class's and what not). But I did make a BUNCH of apps with it regardless coz its a joy to work with.
The difference is subtle these days. React itself is just a VM library, but it has it's established ecosystem, all parts of which work well together. The same with Vue.js - you can use it as a simple and small library to bring some interactivity to your pages, OR you can add a router, flux-like store, http plugin etc. and get a full-fledged Angular competitor. 
Build a few simple apps with each, and don't try to build the ReactJS/Polymer apps as if they where Angular, but see how their community builds apps and solves problems. You'll come out a better Javascript developer and hopefully understand not only the difference between these frameworks, but also what problems they are tying to solve.
I see, so it it's core, some of these WC libraries are philosophically minimalist, as in, its primary goal is to just build web components. That said, other libraries can be pulled in (even other libraries offered by the same folks (i.e. Polymer has an AJAX support), to build something more substantial, more akin to a "full" framework. Thanks for the input.
My biggest complaint with angular is how they market themselves with sample apps, but then it quickly breaks down as soon as you try to do anything non-trivial. Performance also suffers as soon as you're doing anything more than a few forms on a page.
Thanks for the thoughtful response. As it stands right now, I'll be the primary consumer of the front-end code - the other developers are server-side, but I'd like to choose something (be it a framework or a set of tools) that would be easy to pick up. I didn't find Angular's learning curve too difficult, but that's all relative I suppose. I do like this idea of composing your own framework, as it were, of inter-operable parts. As you noted, like a particular HTTP library? Use it! 
I don't think so, you would prolly need var someElementMemoized = memoize(someElement) 
&gt; const someElementMemoized FTFY. But yeah that's what I was kind of afraid of =( Thanks anyways!
1. What are you googling for? API documentation? 2. I've found that they are completely true. I've been using Ember since shortly after 1.0, and I started a new position working on an Ember project six months ago. I was immediately comfortable with the code base, *and* was able to be productive and make meaningful changes on my first day. That's not something that happens with other code bases where you have to spend a few days just learning where anything is/how the build system works. 3. The only Strings/DSLs I'm aware of in Ember are the Router, and the templating language. I've never had the Router eat an error, and since HTMLbars was released it's quite easy to dive into the compiled template function to inspect its behaviour and the manipulations it performs on DOM objects. More importantly, how did you expect it to behave? 4. No argument there, but is that Ember Data's fault? It's meant for a very specific API format, and you shouldn't be using it if your API can't be described that way. What are you doing with Redux now? 5. This is almost completely false, the only true thing being that ember-cli is based on broccoli. The CLI project has been pretty well documented for over a year now, and has *never* used bower as its package manager. The only thing ember-cli has to say about bower is that you can directly import (a.k.a. 'include') libraries installed through it on your file system into your compiled `vendor.js` file, but it has no knowledge whatsoever of bower besides what its installation directory is. Far better than installing via bower is using an ember-cli addon for getting third-party libraries, which *are* distributed over NPM.
I created a npm module to connect to PHPFPM: https://github.com/longbill/node-phpfpm
If you need to reinvent the wheel every time you write a program, you're doing this wrong. If you then think you need other people's code to prevent you from reinventing the wheel, you're definitely doing this wrong.
So the context in which I posed this question was around a healthcare application, whereby when the end-user arrives at this app, they would be already be in the context of a patient and visit, as such, this application would have different components for say, vitals, past medical history, diagnoses. So I don't know that I need to control much state, but of course don't have a full set of requirements yet. This is why I am leaning towards more of a web component based setup. So if you use Polymer for web components, do you just require them in re-frame as if there were native DOM elements? Also, I was under the impression that most component libraries implemented a VDOM under the hood, I believe that's what ReactJS does if I'm not mistaken. Could you perhaps elaborate on a component library that doesn't use this technique? I know Angular uses dirty checking, and perhaps that's what you were referencing. Still coming up to speed on the new front-end wave, so I apologize if any of these questions are idiotic. 
Read the [tutorial](https://facebook.github.io/react/docs/tutorial.html). Read [thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html). It's a fancy templating engine. React itself is fairly straightforward but you'll also have a lot of other stuff thrown at you around application organization (Flux, Redux, Etc) and tooling (Gulp, Babel, Webpack, Etc). This stuff changes constantly so you'll have to pick up how your coworkers are organizing things.
[Visual Studio Dev Essentials](https://www.visualstudio.com/en-us/products/visual-studio-dev-essentials-vs.aspx)
Most people have already said what I wanted to say so I will keep this short. A lack of standards for things like modules is what makes me most uncomfortable with JavaScript. I quietly optimistic this might be getting better with es6 modules. If you want a tool to bundle these have a look at [rollup](http://rollupjs.org) My advice to not get overwhelmed by choice is to go to a lower level. In the time I spent reading up on gulp/grunt/brunch/brocolli/yeoman/webpack I could have learn enough node to do whatever i needed with npm scripts.
Ember is hugely popular with companies that actually have large production SPAs: Intercom, Square, Zendesk, Twitch, Travis, Heroku. As others have said, Ember is about working productively in teams on front-end SPAs, and 2.0 is does this incredibly well. Good read: http://brewhouse.io/blog/2015/05/13/emberjs-an-antidote-to-your-hype-fatigue.html
you want to do something like: myDiv = document.querySelector('.my-div-classname'); document.addEventListener('click', function(ev) { if(ev.target === myDiv) { // do whatever } } that way there can be a myDiv2, myDiv3, myDiv4, etc. but still only on event listener. this is pertty much what jQuery $.on does
Thanks you! I've definitely seen the combination of react/redux/router and webpack, thanks for solidifying my confidence with that suite.
It seems to me that many of the tools that pop up serve one of three purposes: 1. abstracting away browser inconsistencies 2. imposing and/or enforcing opinions about best practices 3. filling perceived gaps in the JavaScript standard library Issues with 1 and 2 are usually simple to figure out. If you want to know how to do something in jQuery, Angular, Express, etc., there's usually plenty of documentation and community support. I find that number 3 is the most hazardous. We didn't want to wait for ECMA and HTTP2 to free us from the tyranny of `&lt;script&gt;`. Accordingly, a cornucopia of excellent and unfortunately fragmented package managers, module loaders, build systems, and the like sprung up years before the ES2015 standard was finalized. It is uncertain whether ES2015 will bring order to the chaos now. But these tools were and are optional. If webpack, grunt, bower, et al are a source of frustration, it's not that crazy to stop using them. IMO, JavaScript is to programming languages as vim is to text editors: inconsistently distributed, often wonky, bad and good advice abound and hard to differentiate for newcomers, bare-bones out of the box and very frustrating to those used to a more composed platform, infinitely extensible and flexible, available just about anywhere, and robustly supported by a herd of cats.
I've been waiting for something like this. Really would like to know the specs on that demo computer, though.
Gotcha, Ember already does work to fix that and gives you the stack trace of the error where it *actually* occurred. It can look a bit weird in the console since in the Chrome dev tools clicking the error will give you the stack trace you're describing, but on its own the trace will be correct. Edit: Oh, and that won't fail silently. The module resolver will explicitly `require` the file, and things will blow up.
Cool. Works really fast and smoothly.
Agree. It is probably a minority of projects that have very high barriers for acceptance testing. Understanding the basic ideas for merging first, making a nice compact changeset, and maybe even understanding mergetools can help (I just mention mergetools because I have seen people edit merge conflicts by hand and it made me want to facepalm real badly)
I remember seeing a similar thing done with Java, I think it was a simulated Windows XP desktop.
&amp;gt; Solution: Compile a better language to JavaScript...ES 2016...JSX Uh, what? :) Not trying to be overly pedantic but *transpiling* ES 2016 to ES 3/4/5 is the solution to a browser proliferation problem, not a language one. And JSX is just syntactic sugar for inline HTML authoring. (Don't get me wrong, I'm very thankful for it- despite being very wary of it at first.)
Your code might overwrite third-party code, or vice-versa; the more global variables you have, the more risks you have.
No problem :) Feel free to ping me if you end up having any questions with that approach. I'm still learning myself but I have a few months head start so I'd be happy to try and help.
Why not?
And if I could pry just a little deeper. The overwriting of code - could that potentially happen because the same variable names might be used by both 3rd party and local. I'm not trying to find a way around it - just still not crystal clear.
This is known as event delegation, and for performance reasons, if you know all of the divs will be descendants of a particular element, you should attach the listener to that element, so that the event has fewer levels to bubble up. --- For capturing event listeners, you need an additional parameter after that function, like elt.addEventListener('click', function (ev) { if (ev.target === myDiv) { /*code*/ }, true); The third parameter is `false` by default (in older browsers, an explicit third parameter was required, so most cross-browser shims for oldIE use `false` explicitly), and it determines whether to listen on the capturing phase (from the whole document down to the target) or the bubbling phase (from the target back up to the document); oldIE's `attachEvent` supports bubbling only, so the default for the "useCapture" parameter was made `false`. Anyway, capturing event listeners can be caught at the document first, so it's faster to attach them to the document if the speed of event propagation is the bottleneck. Also, inline event handlers and event-handler properties are [registered in the bubbling phase](http://www.quirksmode.org/js/events_order.html#link4).
Best reason ever. I'm going to run through your documentation and see if I can make some modules for an admin panel for my webapps.
The answer is that the same variable names are used: On each page, there is one global namespace~ for all included scripts. --- If the code on your page won't need to be referred to by other code, a common pattern is to use an immediately invoked function expression (IIFE) to create a private inner scope (ES6 modules, `let` declarations, and the like could also be used, and transpiled for cross-browser support); if you do need to export your code, a common pattern is to use a single global variable in all caps that is not generic, like `AD6_LIB`, and export all of your public functions and data as properties of that variable (it's like ES6 modules, but with less encapsulation), and you can even use an IIFE to declare private functions and data and then export your library as an object in the function's `return` statement. --- ~Okay, if you have frames, then each "global" namespace in one frame is exposed as part of a "frame" DOM node in another frame (accessible with `document.frames` or `document.getElementsByTagName('iframe')`, etc.), subject to restrictions like the same-origin policy or permissions like cross-origin resource sharing; importantly, this applies to scripts in third-party *documents* and not to third-party scripts in the same document, because in 1995, third-party JS files weren't so commonly used, but frames were, and by the time the security implications became apparent, it was too late to subject third-party JS to the SOP because the Web would break.
Thank you for the explanation, very helpful! I could definitely see why this approach would be more peformant, over the constant `$watches` that must be implemented in Angular.
I have worked with using BigML in the past for the analytics. 
Thank you for this!
My first guess is Zepto, a lightweight library that does some of what jQuery does and is compatible with jQuery's API: http://zeptojs.com/ I also found an early Ajax library at crossbrowserajax dot com that was designed to work even in IE5 (the oldest browser that supports asynchronous server communication), even with disabled ActiveX. Then I remembered MicroJS, and it reminded me of Reqwest: http://microjs.com/#ajax
Worth it for the Wolfenstein 3D
Hi /u/magenta_placenta, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Maybe the Wolfenstein 3D that's included is using asm.js.
Desktop in the cloud? Desktop as service? 
&gt; What is the problem being solved? Where is the value add? The problem being solved is furthering the creators knowledge. The value being added is furthering the creators knowledge.
it would be really interesting to see the specs on /u/petakow's computer though
Don't we have RDP for that?
9 gag logo? 
for fun, could you post some ugly code? Maybe we can make it beautiful,
This makes me sad. Did anyone bother to properly research prior art? Anything before 1990, anything before 1980, 1970? E.g. citation from 1983 in [Knowledge Programming in Loops](http://www2.parc.com/istl/groups/gir/papers/stefik-knowledgeprogramminginloops.pdf): &gt; Object composition: This paradigm provides several composition &gt; methods (shown in figure 6). The simplest is &gt; the specialization of methods and variables of a superclass. &gt; Special classes called Mixins are used to impart a &gt; specific set of behaviors to a number of subclasses. The &gt; term “mixin” is borrowed from Flavors ~ (Weinreh &amp;amp; Moon 1981). &gt; Mixins exploit the multiple inheritance lattice &gt; by allowing inheritance to be factored. Composite &gt; objects extend the notion of objects to be recursive in &gt; structure so that multiple objects can be instantiated &gt; and linked together. Finally, perspectives in LOOPS are &gt; groupings of objects into a higher level object, such that &gt; each component is a view (or perspective) of the whole. &gt; Perspectives provide for the forwarding of messages to &gt; the appropriate view ... I assume that there are earlier texts about it. It makes me sad that people assume that software research and terminology started 20 years ago. And no, I'm not saying Eric Elliot is right, I haven't done proper research (other than 15min of Googling) to say either way. The fact of the matter is, in software literature "composition" has been used loosely. E.g. similar situation is for "parallel" and "concurrent". Furthermore GoF has made several blunders with definitions: e.g. [what a pattern is](http://stackoverflow.com/a/24664544/192220) and [what delegation is](http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html)[(explanation)](http://www.saturnflyer.com/blog/jim/2012/07/06/the-gang-of-four-is-wrong-and-you-dont-understand-delegation/), so I wouldn't be really surprised if it messed up "composition" as well. *Note: I have no clue who Eric Elliot is and what stampit actually does. And, yes, I also until today used "composition" to mean "combining of structures where identity of components is preserved", I guess another definition I need research.*
Desktop in cloud as a service. DICASS
Really fantastic work. How much time would you say you've put into the project? I'd love to see screenshots from some of the earlier releases to get a sense of the evolution that's taken place. Fantastic job bringing the desktop paradigm to the web :)
There's something in the air tonight, oohh ohh
Never heard of it, and I don't use (or like) template engines.
I wanted to use things like destructuring is that not part of es2015
Because the community recommended it........
Not required, for sure. But every time I had to add another controller or whatever, and had to figure our what to name it or where it went, it just felt like it would be nice (and easy enough to implement) if I could just right click the root of the project a click "Add Controller", or similar. It's been a few years though, so maybe I was just a significantly lazier/worse developer back then
Because I enjoy the JS environment and would like to be able to have a simple GUI OS-like interface to give users a more personalized experience. For example, with this code you can connect all your cloud document services to this program and it would give a user easy access and familiar interface to navigate all those sources, instead of each individually. I enjoy a simple and robust kernal that I can GUI with JS easily.
FX-8310 3.4ghz, 8gm ddr3 1600mhz, r9 270 2gb
Reminds me of [eyeOS](https://en.wikipedia.org/wiki/EyeOS).
IMHO the vdom approach is superior to model-view binding you see in things like angular. It's an abstraction over the dom that let's you write declarative html. With this ability you no longer need to be watching for changes all over the place and mutating state. Which leads us to uni-directional data flow. These concepts are separate but work well together. Which is why you see react, virtual-dom and redux, freezer etc. They don't need to be coupled to work well together. Another major point is that the apis for most of these things are very small. React's api isn't huge, redux's is tiny. You end up writing a lot more normal javascript than you do with something like angular, and hence you're improving your js skills all the time instead of learning something framework specific (like the digest cycle).
Why the downvotes? Is this SO? What I stated was literally backed by the community. https://github.com/johnpapa/angular-styleguide. 
Probably not a useful idea. Cool, but not practical.
Awesome, thanks much - I'll look into that :)
Awesome, thanks much - I'll look into that :)
Isn't this only an issue when minifying? 
A lot of people have taken the opportunity to list their problems with Ember, which is fine, but besides the point. You could get a laundry list of complaints about Angular too, which didn't stop it from getting huge; or even Backbone back in the day. A lot of the complaints - too much magic, surprising or changing conventions - could also be levelled at Rails, which was (and is) also huge. Magic has benefits as well as costs. My feeling is that it's a matter of timing. When there were a lot of people moving from server-side Rails apps to SPAs, the conventions in Ember simply weren't stable enough. (A lot of the 'surprises' people are mentioning in this thread are to do with Ember Data, which was in beta until - what - six months ago?) By the time things were settling down, React had put rendering performance on the agenda in an unavoidable way, and Ember in particular was made to look very poor in comparison. Today, it's a very nice framework; the design has settled down, the router is best in class, ember-cli really makes the CoC approach shine (I note with amusement that the new angular-cli is basically just an ember add-on), and it's a joy to hack out a weekend project. Ember and Angular 2 have both taken the hint about performance. I haven't used it on anything huge, so can't comment on that. I think that if by happy circumstance the core devs had stumbled more quickly into some of the ideas they had later, Ember could have been much bigger than it is (a simple cli, betting the farm on components rather than the conceptual churn we had over the years, etc). In any case, it's been quietly successful in the background, which is no bad thing. If I'm sitting down to write some JS code for the browser on my own time, I reach for Ember.
When the only tool you know is a hammer, you will start pounding in screws. I've learned a lot of frameworks and libraries, but React really changed the way I coded with other tools. Even the layout of my current Angular project (not my framework choice) is much more react-like than any previous Angular project I've done and the devs who only know Angular say it's the best Angular design they've worked on. The entire Angular framework seems designed to encourage bad architecture.
In one of my other comments, I noted I'd been coding up ReactJs all day long, and my word, it is an absolute breath of fresh air. I can definitely see how one could transpose the concepts from React back over to Angular
Thanks, this is a great piece of anecdotal evidence. In my last position, folks were coding up Angular services with variables that were referencing scope - now of course Services can't inject `$scope`, but if you generate some HTML via a Service, then compile/bind that HTML to some directive's template, voila, the HTML is renderable since `$scope.whatever` is now present. I was aghast at this type of architecture, and it was exactly as you said, they were so far down the rabbit hole turning back wasn't an option. I see that frameworks can give you enough rope to hang yourself, whereas a library won't lock you in as you noted. Thanks again for the input. 
On the OOP front, he's not alone. Other heavyweights like Douglas Crockford are opposed to the class syntax. I use class syntax anywhere I'd use a constructor though I avoid `extends` because it's a performance sinkhole and I don't like the fragile grandparent problem. It's fairly nice to use in those cases, but overall, factories are much better in my experience, so most of my code is written using factories. As with all things, the right tool for the right job, but a lot of C# or Java guys think they need to class all the things rather than understanding JS.
Take a close look at how scope works in Angular. It's tied to prototypal inheritance but there are new concepts too. Here's the well-cited ref https://github.com/angular/angular.js/wiki/Understanding-Scopes
Because the one who "wasted his time" actually didn't really waste his time because he built *something*.
Why
I'm pretty new to JS (started last month) and I'm wondering what this is/could be used for?
try VUE
The best cure for javascript fatigue: Dart + Angular2. Dart -&gt; Solid Core Libraries (so little external dependencies needed) Dart -&gt; Good style guide enforced by a linter Angular2 -&gt; Opinionated and awesome framework. In other words, less choices, there is just one way to `import` your library. There is just one way to compile to javascript. Less choices, learn fast, and get productive fast. I went crazy as beginner in javascript land, for those exact same reasons. Dart is a well designed language that works in the browser, on the server and also native mobile (with flutter). In my opinion, together with angular2, and a good IDE/editor (webstorm or atom), you will have a lot of fun. Check out some examples here: https://github.com/ng2-dart-samples
Very relevant XKCD: https://xkcd.com/1508/
I've been seeing these browser OS simulators for nearly 20 years now. Still haven't seen or heard a tangible reason why anyone would want one.
So this is where the traffic spike came from! Thanks for checking it out guys! :)
I gotta say, I definitely think OS stood for operating system. I mean, what else would it stand for?
Made me laugh way harder then it should have! :D
I think he's saying it's not really a waste of time, because he probably learned a lot by doing this. I don't think he really thinks it's an operating system, but it kind of mimics one. It's like the JS in-browser version of an operating system.
I might be able to dig out some old stuff for you. I probably have some backed up! I've spent two years on this version (mostly in my spare-time when I have a few hours to kill)
I am currently collaborating with some very smart people to bring a total development environment into OS.js. So stay tuned! :)
That's something that is coming down the road! :)
You're not the first to mention this. If only I was good at actual design and stuff.... If you know someone that actually can... let me know! :)
Unfortunately, with browser security restriction I was only able to make one layer: http://i.imgur.com/gqrBFNC.jpg :( But it's a start!
For sure :) 
There's an "enable mouse" setting.
That only framework that I've used that strictly follows this MVC model is ExtJS.
Much better, thanks.
I remember. Don't worry. How could I ever forget?
Why the editorialized title? Most frameworks actually don't claim that they are MVC.
This is one of the earliest videos I ever made (running v1): https://www.youtube.com/watch?v=W4CelKcfm_c That is all I could find at the moment. I have to dig out my old backup drive for more super old screenshots. But I will have to do that tomorrow. Getting late here :)
Nice, thanks for sharing the youtube link! Any thoughts on what you'll do next?
Awesome!! Glad to hear it. :)
Don't forget emberjs... Everyone forgets emberjs. 
[Monkey-patching like this is dangerous](https://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/), but less so from an extension or UserScript than from code that users *don't* opt into.
I'm not sure about Dart. Dart is largely a dead language, so you won't be convincing too many business-oriented people to use it... at least if you're honest. Angular 2 has great perf, but... @Pipe({ name: 'tempConvert' }) // The work of the pipe is handled in the tranform method with our pipe's class class TempConvertPipe implements PipeTransform { transform(value: number, args: any[]) { if(value &amp;&amp; !isNaN(value) &amp;&amp; args[0] === 'celsius') { var temp = (value - 32) * 5/9; var places = args[1]; return temp.toFixed(places) + ' C'; } return; } } A function masquerading as a decorated class implementing an interface? In React this would just be a function. This reminds me of my days doing Java. I wonder if Angular 3 will just go all out and have `AbstractTempConvertPipeBeanFactory`s.
Why not?
Hm, that's interesting! I admit I didn't even think of mentioning the web UI for pull requests, because I've gotten so used to `hub`. FWIW `hub` is maintained by Github themselves, so presumably it's a pretty rock-solid tool. Also I kind of like sharing the "power user" workflow, if I think that workflow is actually easier than the beginner workflow.
No prob! I enjoyed writing it. :)
I think Google writing Angular2 in TypeScript instead of Dart says everything you need to know about the future of Dart
As the seemingly only React fan who doesn't like WebPack, my big hope for the near future is that JS bundlers start going away Something based around es2015 modules and http2 along with a Babel that's more like a feature detect based polyfill than a blanket es5 transpiler If I could go back to the good old days of just having a single &lt;script /&gt; per page I'd be soo happy.
Google is writing the language in typescript, but Google apps like Google fiber are actually written in Dart. Dart was never an option as language for angular 2, as otherwise, it would be impossible to use angular 2 for javascript devs. 
Thank you - you're right in that my example was shitty, I'm just not sure what I can and can't talk about re: our product so I chose a (bad) contrived example. Thank you for these links!
Thanks! The example was bad, but I think you're still on the money with socketio.
nice project!! What do we need to pack that as a standalone app, and boot a GNU/linux kernel that launches it?
Well transpiling causes this issue for a similar reason. It takes your code and rewrites it a different way, so the code you see in the inspector is not the same as the code that you wrote.
Ah yes, Ember, the best JavaScript framework that nobody has heard of. It's a complex matter why companies don't adopt Ember. All of the reasons I listed below feeds into each other. Do note that below are my opinions from my personal experience and observations. I don't have any hard proof. - Ember developers are hard to hire. Plain JavaScript developers are relatively easier. - Since Ember has a bigger perceived learning curve, companies tend to steer clear of it with the hope that training plain JavaScript developers to use Angular could be cheaper. - The Ember developers tends to commands a higher salary than plain JavaScript developers because they're already specialists. This could be why we only see big name companies use it, because they have the money. - The Ember community is small but very tight knit. This has multiple effects. It means the top developers tends to know each other. This could work for or against you. It's easy to get great hires through referral and...it's easy to lose great talents through..referral. - Because of it's a tight knit circle, breaking into the community is hard. You need to be a big name company that can bring candidates through the door just by the name itself (think Uber). Only then you can drive adoption within the company. But, I believe there is still hope. Compare the search result for "Angular js consulting", "Ember js consulting", and "react js consulting" and you'll find there are any many specialized shops for Ember. If you are in the position to drive adoption of Ember at your company, I suggest to seek out one of these consulting firms, get the project started, then slowly replace the contractors with employees. Since the Ember circle is small, those contractors may even help you to fill those positions. 
It's less of a real os, more like a GUI framework that mimics a desktop GUI that you would see today.
SystemJS does a lot of what I'd like. A big problem right now is that Babel has [discontinued babel-browser](http://babeljs.io/docs/usage/browser/) which seems to throw a wrench in it as being a plausible option
Check it: http://codepen.io/anon/pen/KVNZxR
Many frameworks label themselves as MVC, e.g. http://mithril.js.org/ http://peter.michaux.ca/maria/ http://spinejs.com/docs/introduction/ https://github.com/paulca/eyeballs.js https://github.com/ahe/choco https://github.com/bennadel/CorMVC 
You have the described my story with single page apps :D I went through the exact same situations. The gain of React is truly in the simplification that it's API gives you over not worrying about the mounting/un-mounting of components (component lifecycle) and the component composition.
Thanks. I may get shouty when people get on my lawn, but can we please not call stuff operating systems when they are not operating systems? You didn't make the original post, but an operating system manages access to devices and services, controls memory allocation, memory mapping and schedules tasks at the most basic level. An operating system is responsible for overall system security. I wish people would not blur well defined terms.
[**@cem2ran**](https://twitter.com/cem2ran/) &gt; [2015-12-28 01:17 UTC](https://twitter.com/cem2ran/status/681282864814669824) &gt; @Vjeux Harnessing the power of systemjs! Doesn't get much shorter than that! https://gist.github.com/cem2ran/9be3dd3499566302d5ae &gt;[[Attached pic]](http://pbs.twimg.com/media/CXRnJ3cWQAAvD87.png) [[Imgur rehost]](http://i.imgur.com/3inar9I.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I played around with it for a while, it seems quite nifty to me, but I don't have a lot of experience with JS MV* frameworks or libraries. I was wondering what React does that makes it so much bigger (file size.) Mithril does JSX-style "templates" and includes a router too.
Or maybe write ES5 with no module loaders, no transpilers, and preserving your sanity :)
I'm pretty happy with react. At the time I picked angular, I picked up lodash, and now I program in a mostly functional style. I hope to pick up immutable data structures and functional reactive style in coming projects.
Are you sure you're on verision `5.3.0`? I just tried it out, and it seemed to work for me: http://i.imgur.com/Uf3y4u0.png
I come to Ember to look for naming convention inspirations, and then use them in Angular :) But to use Ember myself, there is too much of overhead of old-practice-inspired conventions stuck back in time. Years ago everyone kept controllers together with controllers in folder called "controller", views with views in folder "views" and so on. Even files having nothing to do with each other! Naturally, people realised that it is better to group files by components. And your test file `componet_test.js` should be next to your source file `component.js`, not hidden in some remote folder called "unit". Now Ember simply won't work with that! I call this enforcing bad practice, so no thanks. But thanks for the good parts!
Wow, seriously impressive
I didn't write this project, but have played with in the past. This isn't the first time I've seen a "JavaScript OS". 
To me JavaScript fatigue to some degree feels like whining. Every language out there has many, many libraries and frameworks to learn and choose from. Webpack takes you a few *hours* to setup? Just some time ago I was spending DAYS if not WEEKS writing and maintaining gulpfiles and gruntfiles. Try building a typical C project or writing a Makefile. React is too complicated? Well, you are still free to create a pile of spaghetti code in jquery. Things improve and advance and the world moves on and we should be grateful for the open source authors who build these tools. Human progress occurs through iterative development of ideas. Progress happens through small gradual changes, not a big bang everything is perfect up front. Java added generics and later added streams and functional idioms. Rust is on 1.5 and many ideas have come and gone in the core language. C++ is 32 years old and still is getting revised every year. Expecting everything to be perfectly fleshed out from the get-go is unreasonable. You can either keep up or sit back and complain about it.
Well, I've never seen any java-style decorators (like javascript has) in a functional language. F# has something like it, but it's used exclusively for metadata and CLR compliance. What I showed was monadic bind. This is a much more general way to solve what decorators tend to do in javascript now - aspects (among many other things). However, you can also do aspects through simple higher-order functions. Memoization in particular would probably be done with a higher order `memoize` function, like this: someElementMemoized :: () -&gt; jQuery someElementMemoized = memoize someElement If you were to write this in javascript, it would probably suffice to do something like: const someElementMemoized = _.memoize(someElement);
absolutely great work!
Seriously well done man.
[Microjs](http://microjs.com/#) is also a good resource for these things.
Thanks, I agree this is a vague question. I just updated with the hopes of honing the conversation, although I did get some great feedback and learned a lot. Also, I did comment at one point on the specifics of the application I'm building, hopefully [this link](https://www.reddit.com/r/javascript/comments/3ynr2m/full_js_frameworks_vs_web_component_libraries/cyf3d7p) works (I'm not a full-time redditor) :-)
Speaking as someone who really dislikes Mac I... actually think this is pretty awesome :) Kudos sir, very good! 
Good to know, thanks!
Yeah looks like MVC, esp. with views and controllers separate. Interesting they added optional MVVM in v5. https://docs.sencha.com/extjs/5.1/application_architecture/application_architecture.html
Saw livescript before. But actually planning on going for F# with [FunScript](http://funscript.info/). I'm also excited for what WebAssembly will bring in the future of the web.
I'd rather use browserify than webpack, I like my tools to be single purpose and flexible. Babel is ok, but if you're writing code to be consumed by the public it shouldn't be transpiled. React router doesn't expose your current route.
It's too abstract. It hurts my brain.
&gt; so you surely can't just make it a function Surely? This is pretty much the entire concept behind mithril, and a huge motivation behind react. The idea that you don't need Pipes, or PipeProviders, or PipeProviderProviders, or PipeFactoryServiceProviders. Pipes are a solution to a problem that angular created.
in case the user has a new version (or internet drops)... and someone else clicks "save", now you have 3 versions and need to diff them. might want to add that to your library requirements. there might be some diffing/multi client synch libs on npmjs.com, though im not sure what keywords for synch... maybe subscription/data synch, idk.
What could be the main application for this? I mean, it seems cool to have an on the cloud desktop environment but then again many of those things are already covered by Google docs. I am not saying it's worthless, it's impressive but I can't see a real life use. 
I am primarily an engineer but I do some design on the side. Feel free to shoot me a PM if you end up looking for some help on that front. I stay busy with my own open source stuff but I'd be happy to help out with a logo or something sometime. :)
&gt; But every time I had to add another controller or whatever, and had to figure our what to name it or where it went I don't think an IDE solves those problems at all? As for the physical action of creating the file after you've decided what to name it, I think using a mouse and typing `rails g controller MyController` in a terminal are comparable. It'd be great of IDEs came with an artificial intelligence that did the bulk of the work for me, though.
What exactly are you asking? How to make a tutorial?
&gt; We avoid $q to use a promise polyfill sounds dangerous-$q calls scope.apply on resolution/rejection, does your polyfill do that?
rightfully so
&gt; For at least twenty years, "composition" has had a specific and well known meaning. If you need to look back 40 years to find an alternate definition that fits your usage, then you ought to know that today, your usage is going to cause confusion, so much so that you even confused yourself (referring to Elliott here), as shown by your incorrect use of the "favor composition" rule. The main problem with this statement is that from 10 years now "composition" means something different, then 10 years after it changes again. It becomes impossible to have a conversation when everybody uses different terminology. The only sane way is to use researched literature for basis of terminology. Throwing out 100+ years of science and definitions is not the solution. It is the fault of today's programmers not researching (huge generalization and I have made that mistake too many times, unfortunately). &gt; "Favor object composition over class inheritance" is a well known quote from the GoF book, which Elliott frequently references to sell his ideas, and if you're going to quote GoF rules, then GoF definitions apply. I haven't read Elliot's book, so I'm not sure whether he referenced GoF and used it wrongly or, alternatively, GoF referenced something and defined it wrongly. I'll take your word about Elliot referencing GoF and, GoF defining their own "composition" instead of referencing something else. *EDIT: Yes, GoF clearly defined what they mean by "object composition" and Eric Elliot referenced it wrongly.* After taking a look at the `stampit`. As far for `Object.assign`, it is not inheritance. Inheritance expects an hierarchy, `Object.assign` destroys it. Similarly `stampit` is not inheritance, because it does not have the hierarchy in the final object (at least I failed to find one). However it does have the problem of components being mixed up. `stampit` is more like [mixins](http://dl.acm.org/citation.cfm?id=97982) not "classical multiple-inheritance". It doesn't have object schizophrenia (issue that can occur in forwarding), but it does have this severe issue: var storable = stampit().methods({ read: function () { console.log('storable::read'); return this; }, write: function () { console.log('storable::write'); console.log(this.read); return this; } }); var receiver = stampit().compose(storable).methods({ read: function () { console.log('receiver::read'); return this; } }) var r = receiver.create(); console.log(r.read() === r.write()); I.e. the `this.read` in `write` will resolve to the `receiver.read` instead of `storable.read`. So it has all the problems of inheritance (obviously excluding anything that has to do with the hierarchy).
&gt; I believe vdom templates compose better than stateful components stateful components? Didn't you mean string templates?
I don't like the fact that is by default based on AngularJS. It looks like it tries to cover many cases which is not really good nowadays.
If you respect the API contract of a library (either carbide or immutable.js), then things are "immutable" as intended.
does it get updated? sadly seems a bit stale to me from time to time but I'm also a fan of it.
There's a *lot* of immutable JS libs out there that just rely on shallow cloning and Object.freeze in dev mode. Offhand, I can recommend freezer, seamless-immutable, and tcomb, but I've run across almost a dozen more. But there's nothing wrong with writing your own! One quick comment on your code though: Object.freeze is really slow in some browsers; you probably want to use it in dev mode, but disable it in production as a performance optimization. Also, I'd highly suggest checking out tcomb if you're looking for inspiration; it's got a similar approach (defining structs), but also has a lovely type system.
Hey you can just make a function in angular2 too, you just need other syntax. ``` &lt;div&gt;{{ tempConvert(myTemp) }}&lt;/div&gt; ``` Now you can just define your `tempConvert` as just a method in the class. But this is different from the pipesyntax: ``` &lt;div&gt;{{myTemp | tempConvert}}&lt;/div&gt; ```
I hope something better. One has insane configuration, the other - insane command line options. One speaks the language of shell, the other - of itself! As we learned from Gulp, using JS own language is superior to inventing a new one as Grunt did. Now Webpack is Grunt's footsteps but the new Gulp is coming :)
As far as I checked last time it's a matter of contribution. So if the folks out there make PR the maintainer release a new version. I myself did it once.
Well, the north pole is kinda on fire right now...
Rest parameters are fine. Using `arguments` is kinda iffy. For one, it isn't an actual array. Secondly, passing it to another function may degrade performance. Thirdly, the function's signature won't tell you anything. ES6's rest magic fixes all of that. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters
That's the way I feel, and I've seen that sentiment thrown around quite a bit lately. The amount of things you can do with webpack is incredibly, but the API is really hard to grasp. I think @kentcdodds summed it up quite well in [this tweet](https://twitter.com/kentcdodds/status/681718127525105665) &gt; I often tell people: "The answer is always 'yes' with webpack. It's just a matter of how, not if."
[**@kentcdodds**](https://twitter.com/kentcdodds/) &gt; [2015-12-29 06:07 UTC](https://twitter.com/kentcdodds/status/681718127525105665) &gt; @mjackson I often tell people: "The answer is always 'yes' with webpack. It's just a matter of how, not if." ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Huh; didn't realize had a new book out. Is the Kindle edition of Thing Explainer any good? The other version ("hardcover") sounds too difficult and would take like forever to arrive. 
I'm actually working on one... :D
All of these butthurt blog posts recently... I think most devs were not keeping up with the times as much as they thought. He's right about the order of things, learn React first (state vs props, component life cycle, composing components, ie what this.props.children is), learn webpack, add babel then start learning about Flux first and what it's trying to solve then learn Redux. It's well worth the effort. 
&gt; Get your facts straight. Dart has had decorators since before 1.0. Yes, this is what I said. "I believe dart even had those (decorators) at that time". This means that they already had a language that did everything they needed it to, but decided they were going to invent a new language, then later cooperate with microsoft (a big deal) over using the language that they already had. &gt;Dart was just never an option, because Dart can not yet generate Javascript modules. dart2js turns all dart files in one big javascript file, that is fast and works great for apps in production, but not as a reusable javascript library. If this is true, then this is a wonderful reason to not consider dart at all, as this is a problem that only dart has, and it's a pretty significant one. ES6 is the future way of javascript. At some point, it won't even need to be transpiled down due to browser proliferation. I know this was one of dart's goals as well, but it [clearly has not achieved this, and never will](http://news.dartlang.org/2015/03/dart-for-entire-web.html). The future of dart meanwhile is fragile and questionable. Google has a terrible reputation of keeping all of its tools used and up to date. Ask GWT users how they feel about dart sometime. 
But the south pole is getting icier.
&gt;And if you have installed Dart on your computer, there is just zero tooling or whatever you have to install And if I don't? Installing is usually not the problem with webpack etc. It's configuration. If you download a project that's already configured, it's usually as simple as doing `npm install` to install and another simple command to build. &gt;Quite lean and simple, right? [Check out a todoMVC using mithril and livescript.](https://github.com/farzher/mithril-livescript-todomvc/blob/gh-pages/app.ls) An *entire* todoMVC that fits in 57 lines, the same amount as just *one* of your smaller dart files. Of course, this is using livescript, which not a lot do, but I think the point remains nonetheless. If you want some more details by what I mean specifically when I say "angular 2 has boilerplate", check out [this](https://www.reddit.com/r/javascript/comments/3uuvvq/how_to_build_minesweeper_using_angular_2_and/cxij08q?context=3) comment I made on an earlier angular topic. I don't know how much of this applies to dart angular specifically. Edit: To be clear, they have different areas of boilerplate. Angular has always been "batteries included" so there's less configuration you have to do, but instead of a configuration cost, you just have boilerplate you have to write in each file to tell angular how to do its job right. React doesn't have that, but is not "batteries included", so you need to tell it how to work, instead.
&gt; I don't like the fact that is by default based on AngularJS. It looks like it tries to cover many cases which is not really good nowadays. If you don't like it, you can use any frontend framework instead of AngularJS
You don't need any of it, you can go back to writing your jQuery/Backbone whatever the hell you were doing. If anything, these concepts are sorting out the wheat from the chaff. Architecture decisions shouldn't be made on the latest and greatest, it should be about what you are comfortable with and what you can get people on your team to learn.
I agree, bootstrapping is the problem. You really don't need to have anything bootstrapped. Bootstrapping is the reason why all these people don't understand the basic concepts. Above all of these frameworks ES6 should be learnt. If you see a demo/tutorial with syntax you aren't familiar with find out what it is. ES7 syntax that is still in flux should be avoided (i.e Decorators) Forget libraries just write code, if you've written something then find a library that does something better, guess what, replace what you had with it.
Thank you! :-)
What's wrong with Up/Down navigation with approach two? You could keep the index property and regenerate it from whatever is selected as you sort/filter. Then when you use key navigation, you use that index to get the correct model and update it, as well as getting either the previous or next model to also update.
It's not very elegant in my opinion. I need that selected item in other places of application, so I still need to track it by some additional pointer, otherwise I'd have to iterate through the array to find it. I thought maybe there is some cleaner way.
except sails is dead now :(.. As someone who has about 10 projects on sails 0.11x both external and internal corporate apps.. I say that with a heavy heart. I love sails and how quick and easy it makes things to prototype. In a large app with high demand it struggles to scale. See this blog post: https://kev.inburke.com/kevin/dont-use-sails-or-waterline/ also for an update straight from the owners mouth, check this issue out on their repo.. https://github.com/balderdashy/sails/issues/3429 there is a new framework that's based off some of the same concepts of sails, it is called [trailsjs](https://github.com/trailsjs/trails) which is es6 based and maintained by several of the core contributors like tjwebb. (hes the maintainer of sails-auth and sails-permissions). I think waterlock is also in the process of moving to support trailsjs. I have yet to use trails or even try it though, so YMMV
oh man you rock so much &lt;3
... we need to go even further! :D
I'm curious – which part of browserify command line is insane and how could it be improved? Is there a reason you don't want to use the programmatic API that browserify exposes? It is very "gulp-like" in that it encourages streams and avoids large configuration boilerplates.
Yea, there seems to be a general fear of transpilers and while I understand it somewhat (I spent 3 days figuring out how babel and webpack interact, granted this was mostly because of the nonsense between babel5, babel6, and babel-react) once you figure it out it becomes second nature. And I am never going back. I will quit my job before going back. ES6 is a completely different beast and it's a joy to work in. Arrow functions, spread operator, const (even if we don't get the performance improvements from it yet, same for tail calls)... having that code ready to go? Super excited for it. And from a front-end perspective, I actually enjoy import compared to juggling JS files that I have to manually manage. It also helps the company I work for has a 2 version rule. We just deprecated IE10 a week ago, so I'm in a better spot than most to speak on this.
I was aiming for something resembling XFCE on Linux... but hey, glad you liked it! Thanks for checking it out :)
&gt; On the bright side, the "React stack" is finally mostly solidified Is it, though? There is now [redux-simple-router](https://github.com/rackt/redux-simple-router) which some are starting to prefer over `react-router`, and others are moving away from redux [toward Relay](https://github.com/rackt/redux/issues/775). A lot of people are moving to higher level abstractions like [hjs-webpack](https://github.com/henrikjoreteg/hjs-webpack), eventually you may not even be interfacing with webpack directly, but instead an abstraction on top of it. Babel seems to be stabilizing, but the list of plugins/transforms/etc needed for a production scale app is getting pretty long, so it too will probably be hidden under some layers of abstraction. New features are entering the scene every month that potentially disrupt the current stack. Things like [ServiceWorkers for instant reloads](https://glebbahmutov.com/blog/instant-web-application/), [WebWorkers for vdom diffing](https://www.youtube.com/watch?v=okk0BGV9oY0), and of course the promise of HTTP2. Blog posts like the OP point out the insane complexity in the current stack, which leads me to believe next year's stack probably won't look anything like it. With that said, I'm happy to watch it all go down from the side-lines. :) 
The main goal is basically to recreate the desktop experience, only in the browser. I don't think this will replace the traditional desktop, but certainly has quite a few possible use-cases. A guy on hackernews summed it up pretty well (https://news.ycombinator.com/item?id=10810942): &gt; 1/ Make a modular backoffice for CMS based website. Make an app to manage users, an app to manage content, an app to upload and manage gallery of media etc. &gt; 2/ Make a distributed OS. All services can scale and use backend power beyond what a single node can provide. If you need to burst in the cloud due to a heavy process for instance. &gt; 3/ Could use it to provide a separation between the OS and the GUI, providing a UX I may like even if the backend server has to be Windows or Centos or ... Or remotely operating a part of my machine at home? &gt; 4/ What about reducing the cost of HW it needs to run? Chromebook style. &gt; 5/ What about being less tied in my Web App to Google Drive API + friends by adding a abstract VFS layer in between like a OS does? Same for texting, emailing? Sure it only uses part of this and don't need the client, but the architecture is well splited on this project between the two. &gt; 6/ It is multi-user as its core, so it can be shared across an organization and not only on one computer. You could even create one account per project/team and share a set of common tools / organization / folders that way across online services. **edit** missing word
It is bit similar in how you use it. In angular you would tell it to watch certain property or object and it would trigger your callback. With mobservable you make some object observable like this: https://github.com/capaj/jspm-react/blob/master/public/stores/example-store.js#L2 And then whichever component should always display latest version of that observable, you must make it an observer like this: https://github.com/capaj/jspm-react/blob/master/public/components/stateless-sample.js#L13 And your view will rerender on each change.
Good points. Just one disagreement: I don't really see `redux-simple-router` being intrusive in any way since it actually embraces `react-router`. It doesn't do much other than store the path in the state. So it's pretty insignificant compared to the other changes that swept over Reactland in 2015. I agree with everything else you said though. Great work on budō by the way. I hope whatever replaces Webpack in the future takes inspiration from it.
It's important to first understand what problems are being solved. If you understand what problems flux and redux are trying to solve, then the answer should be easy. Only **you** can answer this question, because depending on what problems **you** have, you might find that redux, or some other flux implementation is the answer. You might even find that the flux architecture is not the answer at all.
Trend in 2015: Angular 1 is horrible, React is wonderful and "easier to reason about" and if you don't agree you are just old Trend in 2016: React is horrible, Angular 2 is much faster and "easier to reason about" Sounds from the sidelines: you should really try Aurelia. Or virtual-dom. And Elm of course. PureScript is the future. Don't be surprised, there are no "revolutions" and silver bullets. Just regular churn and consultants getting paid to rewrite same functionality over and over again.
[More popular post from yesterday.](https://www.reddit.com/r/javascript/comments/3yo754/osjs_a_javascript_web_desktop_implementation_for/)
Might check out the comments in the [post from yesterday](https://www.reddit.com/r/javascript/comments/3yo754/osjs_a_javascript_web_desktop_implementation_for/).
I'm talking about maintaining and scaling the application, not legacy code. I personally find npm incredibly simple to update with. You see an update has come out, you view the changelog, and update accordingly. You can't blame the tooling or source-code because your team won't take the time to keep your dependencies up to date. And here is one of the main reasons I prefer React. It's just a part of that chain. It becomes deprecated? You switch over. It's only your view layer that will be affected. All my application logic is still good to go. So even if I ressurect my app 3 years after the fact, I can update and maintain it in chunks. I can start with React, finish that, then start with Redux, finish that, etc. Or pull in something completely new and work on that section until it's finished. If you aren't willing to do the above, then why are you resurrecting a un-maintained application and not just making a new one using the old app as a reference source? So I stand by my statement. 
Potentially it could be used for integration tests in environments where the existing browser testing systems (phantomJS etc) aren't good enough.
I had not heard about p2 until now! It looks great. I've been looking for a js physics engine to do some prototyping, but I had only seen matter and box2d. 
In js, ^ is the bitwise XOR operator. you want Math.pow: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow
&gt; not legacy code. What? Everything *becomes* what you call "legacy code". You don't understand a single word I say, do you? I'm talking about the *future*, not the past. &gt; So I stand by my statement. Wow, such a stong finale, in that case I of course must admit defeat. /s
Don't know about box2d, but it's a lot more mature than ~~p2~~ Matter.
Oh my god I'm dumb. I don't know how I overlooked that. Thanks.
Think you want the same as me petakow and wanna put this on a vps or something, screw client side, and interesting to know how low the specs could be. This could be a kick ass front for a mutli user cloud environment....if only the file manager had cut/copy/paste :( Ive only just started learning server stuff, but I wanna go install node now just to try it out. Worked awesome locally.
They're not mutually exclusive. I'm working on a project that uses Backbone models + views plus a hybrid of Backbone view + Polymer for views. Check this out: http://www.slideshare.net/andrewrota/web-components-backbone
I'd be highly surprised if: 'Angular 2 is much faster and "easier to reason about"' is a thing... Giving Angular 2 a look for work, I found it more convoluted than Angular 1 and that is saying a lot. I've already expressed my concerns on it in a [previous post](https://www.reddit.com/r/reactjs/comments/3tb6ef/argument_map_react_is_killing_angular/cx5eirw).
To be fair, React touched a part of my Development Career that made sense. It reminded me of Coldfusion components and that really resonated with me. On top of that, Dan introduced Redux at just the right time and I was like: OMFG, yes... this. It's all clicked just the right buttons for me unlike the other frameworks that have been trying to fit in somewhere. JSX makes sense and doesn't introduce too much of its own nonsense like other templating languages. Redux manages state beautifully using the spread operators and creating new objects to modify the state just works great. I've never been happier working in JS.
Well, at least it's faster than React currently: http://info.meteor.com/blog/comparing-performance-of-blaze-react-angular-meteor-and-angular-2-with-meteor 
Having a brief look at [his React code](https://github.com/ShMcK/Framework-Performance-Tests-with-Meteor/blob/master/react/client/performance-test.jsx) doesn't instill any trust in that result for me. It looks like he has one component rendering everything in some naive attempt. Any time the state is changed, it's re-rendering the whole table again.
This is actually comparing Angular to essentially a "worst-case" React scenario from what I can tell.
IMHO, Yes. I learned React pretty early. Got stuck on some Angular apps for a time and when Redux came out, I dug into that and never really implemented a flux app. Redux clicked with me.
Here's the link to the repo: https://github.com/navdeepsekhon/portfolio-generator
&gt; Any headline that ends in a question mark can be answered by the word _no_. [Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines)
I have to disagree with the premise of this comic. This just shows that human progress occurs through iterative development of ideas. Progress happens through small gradual changes, not a big bang. Not just JavaScript but every programming language. Java added generics and later added streams and functional idioms. Rust is on 1.5 and many ideas have come and gone in the core language. C++ is 32 years old and still is getting revised every year. Expecting everything to be perfectly fleshed out from the get-go is unreasonable. 
Yeah riot looks like a riot in and of itself. I'm looking forward to using it in my projects soon as well.
Interesting. How has it changed the way you work exactly?
By the way, React adoption rate is pretty strong: http://dev.cetrez.com/reactstats/
I've made this tool because I'm tired of building components by hand. Now what I'm doing is annotating HTML elements with data-component attribute supplying desired name of the component as attribute value. This is a quick move, even your designers can do it. Then pass the HTML and some config into the module and it will produce a lib of interconnected React components. You can just take the root component and render everything.
&gt; This just shows that human progress occurs through iterative development of ideas. Or in this case, putting lipstick on a pig.
Maybe it wasn't designed but it's been promoted that way. e.g. when FB claims MVC doesn't scale and calls Angular a "very leaky abstraction", it's hard to think React wasn't open sourced as a take over. ref: https://www.youtube.com/watch?v=nYkdrAPrdcw (39:30)
If phantom js isn't good enough then you'd go to selenium right? 
Exactly!
Just for a bit of self-justification, I didn't mean the decorator style so much as the decorator pattern. I was referring to higher order functions and function transformations. I'm using that now, but it seems to me like it would be nicer to be able to do something more like @memoized function someElement() { return "whatever"; } rather than const someElement = memoize(() =&gt; "whatever"); which feels a lot more imperative (partly because in the first, `someElement` is hoisted.)
If you're familiar with programming and just want to learn JavaScript concepts and syntax, I'd recommend JavaScript: The Definitive Guide by Flanagan (Rhino book). It's long but covers the basic to advanced topics very well. Avoid Crockford off the bat (recommended in that link) as he's very opinionated.
It definitely depends. If you can't easily test your code without the presence of a DI container or mocks, that's usually a symptom of poor design and too many side effects. Or you're trying to unit test things that should be tested at a higher level. The best solution is to keep a functional, immutable, unit tested core. As always, there are exceptions. 
Hi. I'm the author of [js-search](https://github.com/bvaughn/js-search) and one of 2 contributors to [redux-search](https://github.com/treasure-data/redux-search). After some recent discussion with a friend I decided to extract the web-worker search utilities from redux-search and into its own NPM package in case anyone else found them useful. In case you are wondering- yes, I am aware of lunr. When I initially wrote and released js-search, [it out-performed lunr](https://www.reddit.com/r/javascript/comments/3fd5d7/js_search_an_lightweightefficient_clientside/). That being said, lunr is clearly more popular because it's been around longer. I think both libraries are solidly unit tested though and offer similar functionality. However the niche that **js-worker-search** tries to fill is that it has a super simple interface (requiring no configuration) and it auto-detects web-worker support and uses them whenever possible for *drastic* speed improvements. (In my own benchmarks- indexing several thousand records dropped from ~188ms to ~4ms according to Chrome's profiler.) If you decide to try it out, I'd love to hear your feedback. You can see a demo of it (built with redux-search) here if you're interested: http://treasure-data.github.io/redux-search/
I feel like npm is way better than grabbing a build off of a cdn or github. It's better version management, dependency linking, etc. Sure maybe it has more of a learning curve, but way better stability.
 function mercator(λ, φ) { return [λ, Math.log(Math.tan(Math.PI/4 + φ/2))]; } While possible to do with utf-8, for people reading this blog, please don't do use non-typeable characters as parameter names.
[This](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions) is probably close enough. Not all examples are relevant, but the last one is probably closest to what you want. Slightly related, but [this](https://regexcrossword.com/) is pretty fun for learning regex in an enjoyable way.
looks like a canvas-based generator using a sprite sheet. Just search for a canvas library, the generator itsself/the functionality is low level programming a can be done easily with javascript
I'd say at very least write one app, even a trivial one, using traditional flux. That way you'll be more able to see where Redux differs when you start using it. That should help you to develop a better sense of the advantages/disadvantages it offers.
That guy is selling the maps for $45-60 each as a poster. Profit!
If you/your team can be disciplined about updates (and/or your architecture encourages this), you can use plain js objects + shallow clone update functions. See for instance `assoc` and `evolve` in ramda.js, or `lensProp` / `set`. Another method that folks are using is the ES7 spread operator (if u are transpiling). I would like to see some benchmarks but my instinct is the extra size and complexity of immutable.js or mori make them only worth it for situations where you have a deep state tree with leaves updated very frequently. Of course if you are transpiling from a language like clojurescript or elm that have immutable data structures baked in and standard ways of doing updates, it's a different story. 
If anyone wants to run this ... It's not working on os x because of node-gyp build error. It also needs an old version of Node. 0.12.9 seems to work. I spun up a (very large) digitalocean droplet and it's churning away as I type this. 
Okay. Deleted the post. Thanks for the links!
Python is my primary language, so I was delighted to discover spread in ES7 (or ES6 for Arrays I think?). It's how it should be done and makes it easier to write, understand, and document a function. Wrapping args in an array or object has always felt like a hack to me.
Is the case where no objects are passed in legitimate or is it always as result of a bug? If it's not a bug, would returning 0 make sense for your scenarios? Do you need the case to be an error instead? If it needs to be an error then an exception is probably best since you can't forget to handle the error very easily. If it doesn't need to be an error and returning 0 makes sense for what you're doing, I'd return 0. I would not return NaN because it's easy to forget that such a return is possible and so have NaNs propagate into other calculations. Similarly with null and undefined.
I see what you mean about NaN bleeding into other operations. It's more like someone might do a query against a set of widgets that returns zero results... Like for every widget made in Texas, average speed... but the first result might return nothing. I'll have to think about it. Thanks
&gt; imagine crashing mobile browsers with a 262MB file
It depends on how you are using the function, and how many other functions are using it. In a language like Scala I would return an `Option` type set to `None` if the computation failed for any reason. You can also do this in JavaScript, lacking some methods class Option { constructor(x) { this.value = x; } isNothing() { return (this.value === null || this.value } map(f) { return this.isNothing() ? this : new Option(f(this.value)) } getOrElse(elseValue) { return this.isNothing() ? elseValue : this.value } } You could also do a error first sort of like Go or Node, pass null to err if the computation is successful or null to result and a specific err if it fails. // Do stuff return [err, result]; And you would explicitly handle this with destructuring let [ err, result ] = computation(blah); if ( err ) { .... }
Wasn't grunt written in JS?
just avoid the zero division... but it depends on the context. should your program behave differently if there are no widgets? if no, then returning 0 average speed for 0 widgets is just fine. function averageSpeed() { return this.widgets.reduce((avg, widget) =&gt; avg + widget.speed / this.widgets.length, 0); } or function averageSpeed() { let avg = 0; for (const widget of this.widgets) { avg += widget.speed / this.widgets.length; } } or function averageSpeed() { if (this.widgets.length === 0) return 0; let sum = 0; for (const widget of this.widgets) { sum += widget.speed; } return sum / this.widgets.length; } etc...
&gt; It depends on what you mean exactly by [variadic]. https://en.wikipedia.org/wiki/Variadic_function &gt; If you want functions that have different functionality depending on the number of their arguments That would be function/method overloading: https://en.wikipedia.org/wiki/Function_overloading
A good tutorial isolates the thing to be taught, possibly later merging it with a familiar or more representative context as a "see how this works in real life?" example. If your tutorial expects you to be using ES6 and all the things required to do so, it might be a smell that what's being taught doesn't make sense without it. I recall the Redux tutorial I read included a "you can even do this without ES6" comment, showing how you'd set up a reducer. It wasn't awful, but it was clearly not how they wanted to teach you to use it. I've enjoyed Redux. I'm a bit frustrated by the boilerplate but I'm okay with it. The boilerplate would be even more insane without ...state for example. 
Please speak for yourself.
Hi, yes! Good point. I've updated the dependencies on the project and it should now run on the latest version of Node. https://github.com/danburzo/every-street (It also fixes a bug where the last batch of SVG paths were not flushed)
Maybe it was not clear from my article but I really like redux+react together. I dislike the effort needed to get into it, and I am afraid it's not a choice that pay off easily with a team currently foreign to all these techs. The first flux talk from Facebook where they say that using flux+ react optimized development time still resonate in me, I just have a hard time seeing this on the short-medium term. 
Ouch I consider myself on thin ice!
You're actually just borderline, but I wanted to warn you before you went too far down that path :) By most of the other means that we use to try and distinguish spammers from real redditors (number and variety of subs participated in, comment participation, etc.), you're looking good, it's just that you submit this one site a little too often.
es2k15 is the same amount of characters as es2015...
Like a jquery click loop? 
Sorry what?
With user input and forms 2-way data binding is a combination of: * 1-way data binding * Automatically handling focus/change/blur events to update your model
I mean the language you have "to speak" to use it. The language of config! This line of Webpack is definitely not JS: ``` "css-loader?modules&amp;sourceMap&amp;importLoaders=1&amp;localIdentName=[name]__[local]___[hash:base64:5]" ``` How can anyone prefer this over readable JS snippet which Gulp offers?
Sounds like you want to do something like selenium scripts. If you want something like that without wanting to learn and write it yourself why don't you just use iMacros plugin. https://chrome.google.com/webstore/detail/imacros-for-chrome/cplklnmnlbnpmjogncfgfijoopmnlemp?hl=en EDIT: Not trying to be a dick just saying a lot folks here will down vote you, if you just want them to write it for you without showing any effort in attempting it.
The insanity is replacing several lines of clean readable code that you instantly understand with a single line cluttered with options. I can look up Gulp file in any project and understand what is going on. With browserify I have to spend hours learning about every option used. Gulp "API" has 5 methods! How many does Browserify have? Just compare the size: https://github.com/gulpjs/gulp https://github.com/substack/node-browserify Would you prefer to learn 5 words to let you do 500 things or 50 words to do 100?
iMacros won't work for me in firefox or chrome. I've tried it a number of times, including a few hours ago. And I would do it myself but I have no clue where to start. I didn't think it was too much to ask lol
A great design is not when there is nothing more to add but when there is nothing else to remove :)
A great design is not when there is nothing more to add but when there is nothing else to remove :)
Is this a readable code? ``` "css-loader?modules&amp;sourceMap&amp;importLoaders=1&amp;localIdentName=[name]__[local]___[hash:base64:5]", ```
The problem with Webpack that it forces you to learn a new language to write its config. At least in Gulp I have readable code I can understand. 
Yes :(
&gt; Maybe I'm missing something, but from what I can tell this seems to be a walkthrough to creating a leaflet-like application. My intention was to create a high-resolution map that I could print out, although it seems most tools that might create a PDF or a PNG out of the SVG choke with the amount of data, so this is an area I'm still researching. It was also an experiment to see how far I can go with Node and SVG and get my hands dirty -- there are better, faster tools to work with geographical data. 
I'm sorry, it's my fault. Thank you for approving.
Did you have any other problems using Ava besides ES6/babel? I might try it with a Nodejs project that uses ES5 but your comment makes me wonder whether there are too many kinks to be ironed out in it. 
Assuming we're talking about signatures like `foo(x, y, ...z)`, I use them often. My rule of thumb is to use them when the caller likely does not already have an Array they want to pass. Besides saving typing and looking cleaner, it's much faster to iterate over `arguments` than to make the caller create an Array just to pass and be iterated over. I've seen this speed up entire application renders by 30% when applied to a low-level function. Signatures that can't even be expressed without English, like `foo(x, y) or if you feel like it foo(y, x)` or `foo(x, y, z) or foo(x, z)`, I absolutely never use. Besides adding complexity and runtime cost for no gain, you're actually harming the user by making it more difficult for them to spot their errors. (I call this "argument juggling". It's messy, showy, inappropriate, and pointless.)
Yea that's pretty much what I was getting at. What's the possibility for something like a CHIP computer to handle this app and provide a cross-platform environment for things like group projects, collabs, etc. Hell, even as an admin panel this could be pretty cool. I'm interested in minimizing the amount of physical hardware but still supporting many users comfortably accessing and manipulating simple database files such as JSON or TXT or something else in a familiar and uniform environment.
ill say again as js dev, js community always has full retard mode on 24/7.
we should go through new frameworks per month, it will help more.
I don't like that you have to add code to classes to allow them to work with the DI (e.g. the static constitute function). I think the DI container should be separate from the classes that it contains.
Thanks! I like working with the actual code itself since I'm still learning JS, so this is good material. So this was a work around importing the data into GIS and exporting an IMG so that a program like Illustrator can open and edit it.
&gt; And saying passing it "degrades performance" is misleading https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments **Edit:** I should probably also add that making stuff like QSA return array-likes instead of actual arrays was a big mistake. DOM4 will probably fix it by making NodeList extend Array, which is something which can be done with ES6. Then NodeList would have map/filter/etc.
It seems Firefox indicates the value for a conditional statement, making debugging 100.000 times faster.
I think I made this joke when I first heard about webkit.js: Yo dawg, I heard you like browsing, so we put a browser *in* your browser, so you can browse *while* you browse. /realxtothaz
I went to try it out and spent 15 minutes playing Tetris. I got tetris-sniped.
Thanks man, will try it.
That code you call "annoying" is fine as is. It just simple and obvious. This framework just adds noise
Pluralsight, Udacity and CodeSchool all have good tutorials.
I played Wolfenstein 3D on my 486 DX/33 with a mouse :P Amazing what you can do with 4 megs of RAM.
It's a query string. You can use a `query` object instead if you find it more readable, but the problem with style loaders is that they're usually chained together, which prevents you from doing this. However, you can write a utility method to take multiple loaders and turn them all into one `'!'`-delimited string for you, e.g.: import qs from 'qs' let combineLoaders = loaders =&gt; loaders.map(loader =&gt; { if (typeof loader == 'string') return loader let query = qs.stringify(loader.query, {arrayFormat: 'brackets'}) return `${loader.loader}${query &amp;&amp; `?${query}`}` }).join('!') The CSS loading pipeline in this boilerplate could then be written like this: { test: /\.css$/, loader: combineLoaders([ 'style', { loader: 'css', query: { modules: true, sourceMap: true, importLoaders: 1, localIdentName: '[name]__[local]___[hash:base64:5]' } }, 'postcss' ]) },
Webpack insanity starts right from step 0: entry: './src/main.js', output: { filename: 'bundle.js' }, Why not simply: entry: 'src/main.js', output: 'bundle.js' Was this created by masochists?
Webpack insanity starts right from step 0: entry: './src/main.js', output: { filename: 'bundle.js' }, Why not simply: entry: 'src/main.js', output: 'bundle.js' Was this created by masochists?
Jesus fucking Christ
What could be as configurable and dependable as webpack? So far I see no contenders for advanced builds. Browserify and gulp are stuck in their streamyness and the micro-module npm swamp. SystemJS is to clever and opinionated. Do we go back to rolling our own grunt shit? No way.
Why'd anyone one-line this? Except to be *clever*? The standard boilerplate is super readable and gives great VCS diff's on changes.
http://eloquentjavascript.net/ The great thing about it is, you can open the web console right there and then in the tab you're reading the text and try the examples and do the exercises.
I'd return undefined (just return;) instead of 0, seems to me a result was *not defined* within the function. If you return 0 it may well be harder to track the bug, for example you don't get why some result later on is *always 0*. To catch these ‘undefined' results you could do something like var average = averageSpeed() || 100; // set 100 as default when averageSpeed() is undefined.
Sweet
Hello, &gt; "Hey, would this not mean the browser would have to deal with rendering every single image inside the carousel all at once!" And "Wouldn't it be better to be done incrementally?" Yes, exactly. Three things real quick: 1. Carousel are considered a bad UX practice. They often kill conversion, aren't always accessible, and most of the time there is a better UX solution to come up with 2. Don't animate the margin-left, it triggers tons of browsers repaint, which creates jank. You can, for example, use a CSS transform instead. Have a look at this website where you can choose what CSS rule you should pick to get good performances: http://csstriggers.com/ 3. You should consider removing your node_modules file from your repository using a .gitignore file, any developer who wants to use your project can do a npm install on his own. :)
also remove React.PropTypes, it's noop in react-lite
It seems that Phaser's p2 is different than this p2.js physics engine, interesting they have the same name though. I guess my title was confusing, it should have been: If you need a **JavaScript** 2D physics engine, you should consider **p2.js**. 
 its readable config when you understand what it does. Until you get to that point, it's a bit mental looking. 
What's your device? [The most CPU-intensive demo](https://schteppe.github.io/p2.js/demos/circles.html) runs (almost) smoothly on Safari with my MacBook Air (2Ghz i7). There's [an issue](https://github.com/schteppe/p2.js/issues/175) about this, it seems changing the settings can help. I'm not familiar with physics engine, do they usually run smoothly without tweaking?
All of the demos are slow. I'm using this years 13" MBP, 2.7ghz, OS X 10.11 and Safari 9. The FPS looks to be 1/10th of what I get in Chrome. I also tried disabling my browser extensions. 
* Babel - this mostly exists because it takes a really long time to move from one version to another * Webpack - ES6 modules should make this obsolete(though webpack has a lot more features than ES6 modules) * Autoprefixer - if browser vendors wouldn't have started prefixing every new feature we wouldn't need this * All of the CSS libraries - CSS sucks so we need a ton of libraries to make it somewhat better etc.. You need to include a ton of code in packages, libraries, configs just to be able to use the newest stuff, that sucks.
Hm, this is interesting... I kinda expected it to pay a bit with runtime performance, similar to how Zepto.js is smaller and faster to boot than jQuery but is a bit slower at runtime. I would be interested in seeing some more extensive benchmarking between this and React itself.
Well, that sounds perfectly acceptable for a production build anyway, though I guess it would make sense to offer an optional dev build that does implement PropTypes. Right now I'm thinking it makes sense to use the real React for development and React-lite for production, but that's a bit risky because they won't have bug-for-bug compatibility.
I think undefined has the same issues as NaN. If only bugs lead to this problem then something that wont accidentally bleed into your calculations may be preferable for debuggability. If it is not the result of a bug then I think you can argue for returning undefined or NaN instead of 0 but the right choice really depends on how this is intended to be used.
it's ok. when you use React to do server side rendering, I suggest you use React.renderToStaticMarkup instead of React.renderToString for smaller size result, because React-lite has no 'data-reactid' in dom attribute, an it would replace the dom from server with new dom tree
In JS/Gulp it is still readable even if I don't understand it. And I can learn from it right away. With webpack I have to go back to Doc and spend hours. :(
You're giving such a stupid question way too much attention ;) Good explanation though.
I feel like this is more of the JavaScript answer. 
I think that this is a great start, and I'll keep an eye on this repo. However I think you need a lite router, as that is what riot has over yours right now. **edit: this was in context to it being compared as smaller than riot when riot includes the router**
It looks like you accidentally the bit of your comment which explains the thing you were trying to say ;)
react-lite works with react-router. Why would he need to bundle a router if even vanilla React does not do that?
Then both syntaxes should work. If the simpler one I mention is illegal, that's a bad API design.
Man we're just deprecating IE8/9 today.
Great example! Thanks for writing this up. Ultimately this stuff is just JavaScript and if you don't like something just write something to change it.
would definitely recommend codeschool's javascript + jquery courses for trying to pick up web javascript basics
I misread the title as “let’s block Kyle Simpson” and was wondering why – he’s a nice guy.
My book explains JavaScript to programmers and is free to read online, it may help: “[Speaking JavaScript](http://speakingjs.com/es5/)”
LOL, no, definitely not. If I'm ever in Austin, TX and happen to run into him, I would only hope he would be so kind as to talk to me in person. He seems like a very nice guy and really one of the few presenters whose speaking style totally makes sense to me and there are no weird speech quirks that distract me.
WinMerge is pretty good if I remember correctly! It can be kind of annoying to configure it manually, often requiring you to manually enter a complicated "git mergetool" command, but it will be better when you get that setup :) 
I'll probably start using it. I'm new to the whole thing still, but if I start now, I won't be behind when it becomes ubiquitous overnight (the way I tend to experience time).
Thank you! I can get the basics just fine, but once I start getting into the more advanced stuff, it can be pretty confusing to me. 
The real answer is to not use a carousel. They are horribly inaccessible and only about 2% of your visitors will even make it to the second item (never mind anything past 2). If you **need** to use one for some reason, please for the love of god, add the ability to stop it (at a minimum)! People who have certain cognitive disorders need any/all animation to be able to be stopped as they find it too distracting. 
I guess I'm watching an old course on PluralSight which has a date of December 2015 on it for some reason? Yep, it originally came from Front End Masters in 2014. Just Googled it.
Load up those websockets! Down with long polling!
Advanced as in....?
I think it would be better to throw exceptions ('Not implemented') than to leave naive developers uncertain why something wasn't working as expected. Or at least log some kind of warning ('React.PropTypes is not implemented in React-lite')
There's something to be said for perseverance when it comes to learning new subjects. Attack the learning curve, you'll eventually get there if you put in the work.
Echojs and Javascript Weekly are both good. Also Hacker News has a fair number of JS articles.
Try [ConcatNews JavaScript](http://www.concatnews.com/#javascript)
Perfect timing. I was going to try RxJS in the next few days. Having this to visualize my thinking will help :)
Right here
I think the remark was in relation to the lower file size compared to riot, even though riot has a router built in. The comparison is arguably ‘unfair’.
Thanks, I'm starting to think that getting myself to just focus on it is almost the hardest part.
Might check it out later, then. I've gotten used to Riot.js but it does slow down quite a bit in generating DOM content for hundreds of rows of data. Introducing hundreds of unique ID attributes in Riot adds a lot of local variables, and pollutes the local scope. I feel this is one major thing Riot.js needs to improve on.
Besides the point about changing versions numbers what does any of this have to do with Node? It sounds like you just needed something to complain about. If you are a front-end developer you aren't required to use Node at all since your entire world is the browser. You also don't have to use massive monolithic frameworks either.
actually your right, maybe not npm, maybe "is the javascript ecosystem a mess?"
read the edit and i did say "this is NOT an attack this is my view point and I write this to invite you to help me see the light." The point of this post is to help me remove my confusion and get informed. 
Oh I see. That makes more sense then! :) I still think a better route would be to use a light-weight router rather than to bundle one into react-lite. That way users can have more choice. :)
Inclined to agree with you here. Also the accessibility of Javascript I guess makes it popular for new developers to build tools and such. What your preferred stack for application frontends? Do you have one? 
It sounds like Shumway.
OOPS i forgot to call it...wow sorry thank you! it works fine...Thanks what a brain fart.
ooh thanks!
Im really getting into react at the moment and I HATED it for quite a while. But in the end you get used to seeing the jsx in the js and then you start to realize just how awesome that is. I just like the way my js is the template now, I can do anything. Im not limited by what logic you can put in the template. And theres decent tooling now, my ST doesnt bitch, Ive got my auto formatter and all the stuff I like. All the choices on how to do things does make it hard to figure out how to get going but you really should persist long enough to try and make something. Personally it was all that flux stuff that did my head in, so I just cheat now and mobservable, alot simpler. Oh and meteor is really cool with a great community, but theres choice there to ya know....can even use react.
I guess we use browserify in different ways, then. Most of my browserify usage looks like this: browserify index.js --transform brfs | uglifyjs &gt; bundle.js Which is not that hard to grasp, and usually much easier than dealing with gulp and its layers of stream abstractions (which don't even work with uglify). The API is also trivial to use: var browserify = require('browserify') browserify('index.js', { transform: 'brfs' }) .bundle() .pipe(fs.createWriteStream('bundle.js')) Obviously it has more options than gulp, since gulp doesn't really do anything on its own. Gulp relies on plugins, and when you add them all together, you end up with a lot more abstractions/configuration/boilerplate than you would with just browserify. :) 
not interested in what you have to say. Go somewhere else and be elitist. 
Sorry, fixed it! Thanks for telling me.
Was just experimenting, didn't realize the app would get as popular as it did.
Thanks for your insight. Total abandonment of angular in favor of react then?
This was massively helpful! Thanks man &lt;3
My condolences. If it's any consolation, I'm in the same boat as you are, my friend. I am a Mithril user which is close enough to React to be the same thing. I am pressing on with Angular for those things I wrote in that, and I am constantly banging my head against a wall, but a rewrite would take a lot of time. It's a lose-lose situation. Angular 2 feels like the Python 3 of Angulars. Happy new year! 
Happy new year to you too!
React makes a lot of decisions that -- at first glance -- fly in the face of 15 years of collective frontend dev wisdom. JSX is one. Another (not mandatory, but increasingly common practice) is writing your CSS in JS. At first alarm bells go off: separation of concerns! NIH! OMG! But reading this slide deck *completely* changed my mind on the matter: https://speakerdeck.com/vjeux/react-css-in-js (appeal to authority: deck written by FB employee/ React Native author) So much "wisdom" that is seen as gospel should be occasionally requestioned. [Why were we doing that thing other than "it's best practice"?](http://proliberty.com/observer/20080703.htm) Are those reasons still relevant? 
Some great links appreciate your time . Its definitely alien, that doesn't mean its wrong just means I have alot to learn ;). 
I guess, I appreciate your input, thanks!
You're totally right, I didn't notice that! The pages change, and the URL updates, but there is no actual redirect. That's super cool!
Honestly I just lurk on - /r/functionalprogramming - /r/webdev - /r/javascript - /r/programming - /r/reactjs - /r/elm and I feel like I keep up on stuff reasonably well :P. Edit: Also Javascript Jabber from devchat.tv is a cool podcast!
&gt; Still looks miles better than ng-directives Ugh, fully agree there. &gt; I don't see it as looking any more cluttered than expressions in JSX The part I'm not a fan of is that the `each` parameter of the tag has special formatting and requires that you learn something special about that specific control. I didn't look into it that far, but I assume `each` is probably a reserved word in riot, meaning I can't use it as a parameter name of my own, or it's exclusive to the `li` and then it's a matter of learning specific tags that could be collection 'loopers'. On top of that, now you have to manage scope in your head about what `item` is and what methods you can do there (if any). I don't really care to look into it too much because both outcomes don't feel compelling to me. It might look nice, but it introduces special formatting to do what it's doing that's specific to that library for that one purpose and it feels wrong. JSX on the other hand: I just put variables in there.
React is very fun to work with but- coming from an Angular background- it can be a difficult shift as first. Learning how to use Flux instead of binding requires changing the way you think about architecting components. At least for me, it took a couple of weeks before I started to "think in Flux" (Redux really). This subreddit is a good resource though, as is Reactiflux and a few others. I think you'd enjoy it once you made the translation. :)
The nice thing about rewrites is that you already have a perfectly working specification that you have to meet: your current application. A rewrite will take less time to do than what it took to write the application the first time around, and you may even find time to add a few new small features or fix some bugs along the way. My personal two cents: - experiment / get comfortable with basic features from the new JS specs (let/const, fat arrow functions, destructuring, import / export) - experiment with react - read through, and experiment along the way, with the redux documentation (this is important! each section builds on the previous ones, and the latter pages have a lot of interesting stuff going on to reduce boilerplate, etc) - experiment with react router, redux-thunk, redux-flow-async (or similar) See what it feels like. Understand how the new tools will adjust your perspective on the problem your application solves. ***THEN*** decide if a rewrite is, in business terms, worth the cost. Personally, the issues you describe with Angular are precisely the issues I had with Backbone, but if you're comfortable and happy with it, *for this app* that may also be the right choice. Either way, experimenting with React isn't going to do you any harm, as doing so will give you the information you need to make the decision you're facing. Don't make decisions unarmed!
Hi, Node.js is everything but a mess right now. Search for a module on np or nipstr and most of the time you can find something that is maintained, up-to-date, and fitting exactly your needs - to the point it's a real pleasure. 2016 is going to be THE YEAR OF NODE.JS and its NPM ecosystem. Now big front-end frameworks are indeed an ugly mess i'd advise anyone to avoid. Please instead try to stick to simple things like an HTTP backend and a DOM + pure js (+ optional polyfills or light helper libs), and you'll see how it's cool to make websites today. I recently acknowledged the powerfulness of web components, especially custom elements, and right now the only missing thing is a proper module system (HTML Imports not being fantastic) and a generic DOM Proxy that can do smart caching of generated pages for bookkeeping and robots. This is 2016 ! Keep server-side code to MODEL only !
this is perfect for something I'm using React for right now. I'm definitely going to give it a go (once I get into the office on Monday)
My reasons: React is conceptually small. You can fit the entire API in your (brain's) short term memory. It encourages functional programming techniques that can make for more predictable, reliable, easier tested code. The ecosystem around React is such that it is completely normal that I'll be writing ES6 (ES2015) via babel, which makes JS a **much** nicer language to deal with. Spread/rest operators, destructuring is everywhere in idiomatic React code. It is popular. People are using it. That doesn't necessarily make it *good*, but: People are submitting pull requests and making a whole ecosystem of supporting libraries. There are tons of examples and blog posts and Slack channels and StackOverflow answers. The value of an active community shouldn't be underestimated.
Are you looking at Aurelia because of its similarity to Angular?
I love this advice, thank you. I'll definitely try out react and see if it plays as awesome as it sounds. Edit: Though hmm for backbone I think it's really fast, the canonical way to render with backbone lends itself to a couple of simple optimization steps that can make it faster than most libraries. It also has server side rendering which is pretty cool.
I don't know if I'd agree with it having no future. There's too much built with it, it's not going away any time soon. I love Angular but I hear you with the speed / testing. If it were me, and the app wasn't going anywhere, I'd just leave it. If you're planning to add 20 new features and keep going with it, maybe a slow transition to React so as to not bum yourself out? I believe the two can coexist. 
&gt;They are tailored to the extremely specific needs of the developer Not really. The boilerplate is really for a specific application architecture. Not a specific need. That application architecture might not be one-size-fits-all but it's generic enough to suit very many applications' needs. &gt;I, too, can slap together an empty project with 10 npm packages It's pretty clear to me that you haven't actually done this. This is a lot more difficult than lets on, when you're trying to get acquainted with a new library, you don't just `npm install`, you're also burdened with how to implement them and get all the pieces working together. It could take you an entire day (if you're smart and efficient, with experience) to compose these things together. But like said in the Readme, these are things that shouldn't exist. It's like scaffolding for a building. You might as well just re-use a set of scaffolding somebody else has built, save yourself some time to do some real work.
Awesome explanation, thank you!
So cool. Would love to see this with moving objects.
The `each` word is indeed reserved for attributes, as well as `if`, usually for boolean expressions. It's not exclusive to the `li` tag though- you can use it to repeat elements with divs, table rows, etc. `each={ item, i in items }` is just one way to use the keyword, the less verbose version being that it takes one parameter for looping in an array. For example, just using `each={myItemArray}` and inside the loop access each property value of the objects in `myItemArray` directly with `{itemKey}`. Much like JSX you can also use the curly braces to output variables or evaluate simple expressions. I've been used to templating systems with PHP before so I guess it's not intrusive to me, as long as the logic is nothing more than presentation logic. For what it's worth, going from React to Riot was a far easier transition than un-learning the conventions of Angular when moving to React.
I've gone from Angular 1.x to Vue.js. I dabbled in Angular2, but honestly it's not feeling very compelling to me. I don't know why.
I'm also thinking about Vue, yikes so many choices. Does Vue support server side rendering?
I don't think it does. I'm not too personally concerned with it (Google seems to index SPAs fine now), but if I ran a SEO heavy operation I could see that being an issue.
Ooh yay, just in time for me properly learning Node and React!
There is a migration path from angular 1 to 2: http://angularjs.blogspot.com/2015/08/angular-1-and-angular-2-coexistence.html Ember and angular are both facing churn in the face of practical virtual dom and the benefits of one-way binding over two-way binding at scale that react successfully introduced. Backbone isn't dead, it's just old (and apparently reliable for what it claims to do). Meteor is built on good ideas, implemented well, but distributed badly. It requires a custom version of node and the ability to natively deploy meteor apps to your own server is hacky at best. React is sublime brilliance wrapped in style. Try it out! Even if you hate it, you'll learn some useful things. Nodejs just moved to an accelerated dev schedule after months (years?) of stagnation in the face of legitimate need for new features like browsers are gaining monthly. Here's the deal: web dev is not stable because nothing about the web is stable. From the browsers, to the security landscape, to the server technology, to the transport changes, to the changes in user expectations of app performance, everything is moving, and quickly. Why do you expect that dev tools for working with such an environment will be static or even stable? If you want my advice, it is this: Read everything, keep learning, and prepare for more change that is definitely coming. Make your code as modular as feasible, so that when you do need to translate parts of it to other things, you will have minimal entanglements with specific technologies. Use functional style code where you can to reduce the amount of code per feature while also making the functionality more generic. For new features being added to the language, learn them, set up a transpiler build step so you don't have to think about it, and then forget that the transpiler is there. Good ones are following the language specs, so you'll be able to convert by slowly removing the build step, not changing your code.
Start with github and basic Linux. Back end is more straight forward: node js, strong JavaScript coding knowledge, express(or something similar)understanding how web servers work, linux, api, apache/nginx, sql, orm, networking, and design patterns are pretty much it. There isn't much in terms of trends or radical changes.....but each area can go fifty miles deep. Thankfully once your skilled, less changes...knowing SQL well is great since nearly all major database software except mongo uses similar language. ---+++--- Front end? Easy path: Html/CSS ---&gt; htm/CSS templating/preprocessors ----&gt; bootrap/zurb -----&gt; how to use browser debuggers ----&gt;JavaScript ----&gt; more JavaScript ----&gt; pick a front end framework.....just one for now...make sure your high level JavaScript ----&gt; grunt/gulp/webpack---&gt; animation----&gt; apis, user authentication, cookies, local storage, socket.io, databases, orm or sql, security, cors, ----&gt;build an app or complex website---&gt; WordPress or drupal if you want to go down designers route more although its php, nice to have since a huge amount of sites are WordPress and /or php ---&gt; go learn back end...it will help and expanding your abilities as a web developer. ---&gt; algorithms (you'll need these for interviews at the very least). ---&gt; master JavaScript ---&gt;memorize HTML/css----&gt;3d js libraries ---&gt; do another project or get a job you bum! --+++-- If your your closer to design/graphics, double down on WordPress/drupal, Photoshop, adobe after effects, css./JavaScript animation, webgl, video editing, bootstrap, ux, ui design, art, graphic design, color, and latest trends in web design. Photography, videography, audio editing, and broadcast software would also be useful but not deal breakers on getting a dev job....but was very helpful breaking in. Bonus points: System admin, active directory, chef/puppet/chef
if you read the title as "the year I became aware of JavaScript" it makes a lot of sense
 jsondata.array.forEach(function(o) { console.log(o) });
 jsondata.array.map(function(element) { console.log(element) }); `jsondata` is a json object with a key called `"array"` which is an array of objects representing what looks like database rows. `.map` is an ES5 function which iterates over each element of the array and performs a function on the element without modifying the original array.
Can you explain your post-jquery phase comment?
 jsondata.array.forEach(function(obj) { console.log(obj); }); With bind: jsondata.array.forEach(console.log.bind(console)); ES6 #1: jsondata.array.forEach(obj =&gt; console.log(obj)); ES6 #2: for(let obj of jsondata.array) { console.log(obj); }
Honnestly, I'm not a fan of firefox debugging as well.
Does it really have a draw? Or is it just the only option for the applications we want to create? I think JavaScript would be better off dead. Let me develop client-side web apps in almost any other language and I'll be happier. In the meantime, I'll deal with this shit. edit: Wow, thanks for gold. Was almost out :)
Very circle jerky
Array.map creates (and returns) a new array with the returned values of the callback function for each element in the array. So while it basically "works" it can be misleading for people who know the difference between Array.map and Array.forEach.
I went from Backbone to Angular and then to React. I like React best of all of them. It's component concept and deep integration with the overall JS ecosystem really sold me. And one way data flow with Flux and Redux makes for much easier to maintain large code bases.
Only if he's a time traveller.
Vundle: Plugin 'mxw/vim-jsx' Plugin 'jelera/vim-javascript-syntax' Plugin 'marijnh/tern_for_vim' Plugin 'pangloss/vim-javascript' Plugin 'facebook/vim-flow' Config: " Javscript Config let g:jsx_ext_required = 0 " Allow JSX in normal JS files let g:syntastic_javascript_checkers = ['eslint'] [My config if that interests you.](https://github.com/SeeThruHead/dotfiles/blob/master/vimrc) 
try vue.js https://github.com/vuejs/vue/
Honest advice, for better life, you don't need to stay up-to-date with Javascript
People who downvote without commenting why.
I can see this both ways. I can see that I probably spend too much time browsing reddit and not learning anything, but also it's been invaluable to me to stay up to date with how things are changing in JavaScript. I don't think you can sincerely aspire to be a developer and not stay up to date. 
https://twitter.com/iamdevloper
What's the big deal with testing angular? I use nodejs + karma and it works pretty well.
Not exactly an implementation from vue.js team, but its close: https://github.com/ngsru/vue-server
But gulp and browserify are more configurable than webpack...
I just checked, after filtration `key` gives the same shifted numbers as `$index`. I'm not sure if I understand you correctly. 
I'm looking forward so much to webasm as a legitimate compilation target.
I don't think that babel and webpack are broken. They indeed require some setup but work pretty well together. &gt; 3 packages (why not 1?) to be installed - babel-cli, babel-core, babel-preset-es2015 That's actually huge improvement shift for babel. It used to be all in one package (kind of) before but now it's more modular and allow us to combine whatever we want. About your error: I'll suggest to use a `__dirname` in front so you refer the current directory. I recently blogged about webpack and babel so [here is my experience](http://krasimirtsonev.com/blog/article/javascript-library-starter-using-webpack-es6).
Aha, I see now. Yes, it's true.
Can you please explain what are the problems with Javascript in your opinion?
If thousands of people successfully use a software but it doesn't work for you because you have an issue setting it up then it is not 'broken by design'.
Well you should have downvoted his second comment. That comment bring nothing to the discussion, it's just a rant, and should be downvoted if we follow the rediquette. Also I wonder what he thinks downvotes are for. If you had to justify *every* time you downvote someone, why have downvotes on the first place.
&gt; Google seems to index SPAs fine now Their limitation is that they're not making AJAX calls, so most SPA still won't get rendered. 
&gt; Is node currently a mess? Well, what part of node did you have in mind? &gt; Angular 1.x, Angular 2.0, Ember, Backbone, Meteor, React Those are not node libraries. They have no relationship to node, except that they're written in the same language. &gt; Ive literally just been using rails + jquery Right, you've been using *Rails*, instead of *Backbone*, because *nodes* version number changes too fast, and it means you can't figure out whether *React* is worth using in production, despite the massive number of companies already doing so? 'k. Your core question might be okay, but I literally don't know what you're asking. "Should I use React?" "Should I use a JS framework on the frontend?" "Should I use a JS framework on the backend?" "Is it okay to use node in my dev environment?" "Which Angular version should I use?" All of those are valid questions, but they're different questions. Also: &gt; React doesn't have a clue what it is? With react mainly as a view system with MVC implementations, react native and such .. JSX is so alien to me. ...you have no idea what React is, do you?
The most "correct" solution would be throwing an error as input parameters are invalid for method to function properly. IE when you do fs.readFileSync( '/invalid-dir/invalid-file' ) it will throw error as parameter you passed to it does not allow for function to complete successfully. But in reality, I'd decide how often and what results it should yield again. If you are using averageSpeed() a lot in code, i'd fuck throwing exception to not bload all source code with try-catches. If it should display averageSpeed: 0 for your user, i'd just return 0. If it should change your program behaviour, I'd return NAN and check isNan() after. But the question is, do you really have to call averageSpeed() if your input data (array of widgets) are empty? I'd consider making check there as calling averageSpeed() without elements makes no sense.
How do you represent a stream that doesn't complete? Is that ever necessary? This is very cool btw :) interesting implications for unit testing.
Looks awesome! Can you use promises instead of callbacks?
Here it is. I try to stay objective, but it is hard :( { "name": "es6-tutorial-master", "version": "1.0.0", "description": "Start the tutorial [here](http://ccoenraets.github.io/es6-tutorial).", "main": "index.js", "scripts": { "babel": "babel --presets es2015 js/main.js -o build/main.bundle.js", "start": "live-server" }, "keywords": [], "author": "", "license": "ISC", "devDependencies": { "babel-cli": "^6.3.17", "babel-core": "^6.3.26", "babel-loader": "^6.2.0", "babel-preset-es2015": "^6.3.13", "webpack": "^1.12.9" }, "dependencies": { "babel-preset-es2015": "^6.3.13" }, "babel": { "presets": [ "es2015" ] } 
What does your webpack confit look like?
&gt;Is that meant to be so hard aka broken? No. You're probably doing something wrong or following a bad tutorial. There were changes to babel in the past couple of months and this tutorial might be out of date. If one tutorial you're following is hard, consider trying a different one. Broken doesn't mean hard. There are a lot things that are just hard to do. Software dependencies isn't a simple problem and there are a lot of different ways to do this. It's a lot simpler now than it has been for any time in the past. Sometimes people who make libraries make decisions that make the code that uses that library easier to use at the cost of something else, like new members understanding how the system works. When you phrase problems you have as "I can't do this, and I'm assuming it's broken" people tend to react without much empathy, because 99.999999% of the time, the bug you're experiencing is your fault, not the fault of the library you're using. We've all been frustrated trying to learn something and a lot of us have made comments about how stupid everything is with respect to that. When multiple people are telling you, "no, this shit isn't broken, you just don't understand it," it might be time to stop insisting your original thought is correct and adjust your understanding. *Especially* when you post something asking people for help on this and they answer you. A lot of people here have devoted a lot of their own time to helping people for no reason other than they enjoy it, either through answering questions or writing free software. Seeing someone with an attitude like yours makes people clam up and take the attitude of "fuck off, if the work I'm giving you for free isn't to your liking, go figure this shit out on your own." For two reasons: one because you've potentially insulted a lot of people with this post. And two, you need to grow up; maybe after actually thinking through the problems the people with the tutorial were trying to solve or the people making babel were trying to solve, you'll appreciate their solutions more and be more understanding of the difficulty in dealing with them.
If you have any code that's not written the 'Angular Way' testing can be downright impossible. Add the digest loop to the equation and there's mental overhead in testing Angular components properly.
I think there are many people who just straight up don't like dynamically typed languages. I don't like 'em either. But I have to admit that for a lot of the random little scripts I end up writing for the web, I still prefer that over the extra boilerplate of something like Java.
For myself, I created a minimal setup and did not encounter any problems: https://github.com/rauschma/webpack-babel-demo There is also the `babel-doctor` command (which is part of `babel-cli`) that may help: http://babeljs.io/blog/2015/11/03/babel-doctor/
Pretty cool effect. If you want to give it even more of an old school feel, force the fps down to 12. 35mm film is played back at 24 fps, and most western animation studios drew every other frame for budget reasons. (Really cheap ones did every third frame) This results in an effective frame rate of 12. You could also try 15, as later animations made for TV would have been drawn for 29.97fps for NTSC, so half would be around 15.
Did you do an `npm install` beforehand (while you were in the directory `webpack-babel-demo/`)? Also: you must be inside the directory `webpack-babel-demo/` when you execute the command `npm run build`.
So elm isn't actually JS, but it's been inspiring a lot of FRP type stuff that's been becoming popular in front end...Redux is particular is heavily inspired by elm! The way I see it learning elm or at least experimenting with it has upped my JS game and given me a deeper understanding of the concepts react/redux etc use :). 
It still has a lot of warts from it's early days. Things like not being to iterate through an objects properties easily, having to have "use strict" at the top to get some sanity on variables, the fact that there is no integer type, poor higher level tools for things like modules / libraries not built into the language and so on. Even casting is a bit wrong; for strings it's a function (parseInt) and for numbers it's an object function (toString).
spent a lot of time practicing TDD, something I'm new to but really wanting to get good at. The site was built on nodeJS, using a lot of libs. You can play with it here: http://codepix.io/ - you can see the source code here: https://github.com/MattMcFarland/codepix-client
Personally, I like using stateless functional components everywhere possible. Reading through [the linked Github issue](https://github.com/facebook/react/issues/5677#issuecomment-165125151) was instructive. The idea that using stateless functional components would result in a performance gain has spread, but this is overstated. They may enable *future* enhancements, but not yet. As of 0.14.4, they use the default `shouldComponentUpdate`, so it is impossible to implement something like `PureRenderMixin` without resorting to either `React.createClass` or ES6 classes. On the other hand... here's a comment from the linked issue above, **emphasis** mine: &gt; There are discussions about having a pureRender flag that you could set on the function, or allowing it to participate in the shouldUpdate lifecycle, but that's currently not implemented. At the moment, stateless functions can not be pure-render. &gt; **It is worth keeping in mind that sometimes people abuse/overuse pure-render;** it can sometimes be as or more expensive than running the render again, because you're iterating over the array of props and potentially doing things like string compares, which is just extra work for components that ultimately return true and then proceed to rerender anyway. PureRender / shouldComponentUpdate really is considered an escape hatch for performance and is not necessarily something that should be blindly applied to every component.
&gt; In the meantime, I'll deal with this shit. Nah, I'm sure you'll just find something to bitch about with the next language. The rest of the world is doing just fine with Javascript, now give any REAL reasons why it would be better off dead. It's easy to claim that you'd be happier, but considering you didn't even give any reasons, I'll just assume you're one of those that just likes to bitch.
And your `.babelrc` should be at the top level of your project, not in `~`.
JavaScript definitely had some early warts, luckily their have been many people working very hard to fix that. &gt; not being to iterate through an objects properties easily With the introduction of the iterators `for .. in` and `for .. of`, as well as the array prototypes `Array.prototype.forEach` and `Array.prototype.map`, this is no longer the case. &gt; having to have "use strict" at the top to get some sanity on variables You can also use a linter to ensure most of the warts are gone as well (such as implicit global scope of variables not properly initialized). &gt; poor higher level tools for things like modules / libraries not built into the language and so on This is also no longer the case, Mozilla Hacks did an entire blogpost on ES6 modules that is worth reading: https://hacks.mozilla.org/2015/08/es6-in-depth-modules/ &gt; libraries not built into the language and so on Unsure what this even means. &gt; the fact that there is no integer type JavaScript was designed with the purpose of being approachable for non-programmers, which I would argue it has been **extremely** successful at doing. How JavaScript models numbers is a much simpler approach, so given their goal with the language, I consider it a successful design decision. &gt; Even casting is a bit wrong; for strings it's a function (parseInt) and for numbers it's an object function (toString). I disagree that this is bad. In many languages the base object that everything inherits from has a `toString` method, which makes sense as turning an object to a string is contextual on what the object is. `parseInt` on the other hand strictly should have one meaning. I think it would be a poor design decision to just start dumping all utility functions on the base object prototype - especially if there would be no sane reason to override these. Luckily, JavaScript is extremely flexible and if you wish to add the prototype yourself, you can. 
I do like to bitch, but I've got good reasons. JavaScript could be a way better language. Supposedly it was designed in 10 days, and it shows. * lacks type safety * lacks native integers * it's easy to accidentally create global variables and confusing for newcomers to understand how and why not to * typeof NaN == Number * requires hasOwnProperty checks when iterating through object properties * doesn't require semicolons (who does this help?) * scoping and 'this' behavior are super weird and arbitrary much like the use of the == operator (vs. ===) * prototypal inheritance is annoying and messy (subjective, sure, but a popular opinion nonetheless) * there are inconsistencies between each implementation and you have to account for all of these if you are writing client-side code * no significant standard library of useful functions you'll find in nearly every other modern language * identity crisis: is it a functional language or is it trying to be object-oriented? * crap immutable support * every new version of ecmascript just tacks on additional syntax sugar to try and make the experience a little less shitty. You get the idea. Sure, the community has brought along plenty of packages which make programming in JS a bit less painful, but in the end I think it would do better as a compilation target. Clojurescript and typescript have the right idea.
Thanks for the constructive criticism. I think i could have constructed this a bit better. It was posted after several hours of getting no-where and i think my frustration may have seeped in lol. Regarding node, i had already edited my post to change "node" to "the javascript echosystem" as your right node is only one aspect and most of what i pointed out didnt even use it. My main point was that everything seems to have a significant con. Coming from opinionated systems like Rails and Laravel and just using jquery for any interactivity in my frontends I felt like i didn't even know where do start as everything had a significant reason NOT to use it. For someone who is either new to the javascript mcv/framework game or coming back after being away for a while its quite intimidating. The tldr after my research last night is: - Backbone is now mature and very reliable - Angular now has a migration path to 2.0 - Angular 2.0 is very light weight, refined and strongly typed ... this is attractive to me. - Node after all the hiatus is finally on a steady release cycle with LTS versions ... yay! - React is awesome however it has a massive learning curve in the fact that you need to construct it with varous modules before you can start using it effectively. Thats a long tldr but i now have a foundation to make some educated decisions. 
Prerender.io is a paid service that has all they're stuff open source (i believe). That might be what you're thinking of.
Give up. 
Thanks! Yeah, there's no easy way to represent an endless stream. I suppose you could use a doWhile(), but the sequence string is limited to 10,000 characters. Apparently, the newer RxJS unit tests are using marble-based approach as well ( wish I had realized that earlier :] ) And FWIW, they appear to support sequences that don't complete: https://github.com/ReactiveX/RxJS/blob/master/doc/writing-marble-tests.md
I think that you can split the JS community into two halves. The first half are the ones that use it purely in the browser, mostly because there are no real alternatives or the alternatives aren't that well supported. Their motivation for jumping frameworks is that the JS ecosystem gives you hundreds of different ways to shoot yourself in the foot. Angular, React, Ember, etc... are all incomplete and have severe problems. This chaos looks fun (and sometimes it *is* fun), but the truth is that other languages and targets have mature and well-designed frameworks that make you wonder why are the frontend frameworks so messy (the reason why is pretty obvious and is left as an exercise to the reader). The second half of the community are the fucktards who write their "web-scale" shit using crap like node.js and MongoDB while spreading this plague of willful ignorance using their buzzword-filled blogs. I don't get why *anyone* sane would want to consider themselves a part of this community. You might as well go get yourself a tattoo that reads "I am incompetent". The chaos is pretty much the reason why the JS community is so fun to watch.
Well, that's not true... Some guy said he encountered the problem with non-printable characters screwing with things and someone else posted a flag you can use `--display-error-details` to get more details. This is the nature of learning how things work -- one must be able to problem solve and identify problems. Lots of people use these tools -- encounter problems and are able to solve them.
Maybe because we are not programmers and you are? I mean it is not my job to write code, but I use code in my job. JavaScript is easy and gives me and people like me the ability to prototype. It's also not about web anymore, Nodejs has enabled us to code anywhere. If something I did took off, then I am going to ask one of you programmer guys to write it "the right way".
NodeJS isn't crap. Any language or tool always has a group who misuses it.
Lol I can't spell...
who hurt you
I get zero functionality on Chrome
But again, why?
it's really a rough draft. More of an experiment rrally. Thanks for the feedback.
[removed]
Actually I just tested it and it is no longer working. Im not sure what is happening. Wish i was at home so i could fix it will fix it asap.
Why what? Do you know a lot of frameworks with this kind of features? (in a NodeJS world)
Here you go: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match
This project is very awesome. Thanks for sharing with us, i'll be reading more when i get time. Can you answer if this project will be maintained for a long time?
I have had a look at that and this is the best I can come up with, can you offer further assistance? :) var test = /([A-Z])\w+/; var test2=document.forms["form"]["test2"].value; var test3 = test2.match(test); if (test3 == false)
Thank you for your help :) I will give it a go! 
that will work. You can also do: if(!test2.match(test)) or if( test2.match(test) === false) edit: ignore the above. I should have paid more attention the link I gave. do this: if(!test2.match(test)) or if(test2.match(test) === null) Your example will work too because null is falsy, but specifically checking for null with the triple equal is best
I am pretty sure we use the term "web-scale" as a joke. I remember there was a talk where a guy wanted to show his code --whatever that was-- he made a funny face and said "So, what is this thing? it's web-scale!". We all had a good laugh. I happen to know about the terms you mentioned and I have used them for stuff way beyond the web. I like the single-threadedness of JS and that we can use Promises and Workers to do some heavy lifting in the meantime. Can you please explain to me how "asynchronous", "non-blocking" and "event loop" are connected to weaknesses in JS and how other languages are doing it better?
I understand people don't like dynamically typed languages because they are wasteful in terms of hardware use, right?
&gt; lacks type safety Flow and Typescript are blowing up to address this exact issue. &gt; lacks native integers This was a smart design decision to make it more accesible for non-professional programmers. JavaScripts accessbility is one of the reasons it's so popular. This should be considered a win for JavaScript given this purpose. Language design is full of trade offs, this is one of them. &gt; it's easy to accidentally create global variables and confusing for newcomers to understand how and why not to This is a JavaScript wart that **can never be fixed** due to backwards comparability requirements. That being said, it's a complete non-issue considering it's removed behavior using `"strict mode"` as well as all major linters have this as a rule to implement. Annoying? Yes. But it's one of these often mentioned things that's really a non-issue. &gt; requires hasOwnProperty checks when iterating through object properties This actually makes sense in context to a prototypical language. &gt; there are inconsistencies between each implementation and you have to account for all of these if you are writing client-side code This has **nothing** to do with JavaScript spec, and the fact that it runs on a wide array of browsers which some did not implement the specs properly in the past, and that it takes time for companies to catch up to the spec. This would be the case with **any** language that would be supported in all major browsers (including HTML5/CSS/SVG). This is absolutely not a fair argument against JavaScript, this is the nature of the browser. &gt; typeof NaN == Number This is misleading to flaunt this as a problem with JavaScript if your read more into what _exactly_ `NaN` is (https://en.wikipedia.org/wiki/NaN). `NaN` represents multiple things, for instance both positive and negative infinity (this is why `NaN === NaN // false` must be the case, another often recited complain that's actually the correct behavior). &gt; doesn't require semicolons (who does this help?) JavaScript is very forgiving in syntax, if you don't like that (I don't), use a linter. A lot of people who like Ruby and CoffeeScript love this, so I would say "A lot of people" is the answer to your question. &gt; scoping and 'this' behavior are super weird and arbitrary much like the use of the == operator (vs. ===) The scoping makes 100% sense in the context of a prototypical language, I recommend watching Kyle Simpsons advanced JavaScript course on scoping. &gt; prototypal inheritance is annoying and messy (subjective, sure, but a popular opinion nonetheless) The fact is it's popular to hate on every single language in existence. This doesn't mean anything. JavaScript's greatest strength is it's flexibility granted via the prototypical inheritance in my opinion. &gt; no significant standard library of useful functions you'll find in nearly every other modern language Yet JavaScript has easily the most vibrant ecosystem of libraries, which don't suffer the issue of having poorly designed utility functions put in spec, as the libraries are community driven (Lodash, Underscore). I see this as a benefit, and one of the reasons the JavaScript ecosystem is so strong. &gt; identity crisis: is it a functional language or is it trying to be object-oriented? Every major language borrows concepts from both OO and functional paradigms. JavaScript is a widely adopted language so it makes sense to be flexible in what programming styles it allows. &gt; crap immutable support Yet Immutable datastructure are extremely popular these days (https://facebook.github.io/immutable-js/) &gt; every new version of ecmascript just tacks on additional syntax sugar to try and make the experience a little less shitty. The EMCAScript community has done a great job improving the specs in ES6 and the upcoming ES7, after being stagnant for many years. I don't really get what your complain is here. It is community driven, so if you don't like something in ES7 speak up! The community driven aspect of EMCAScript is excellent, and will help bring JavaScript up to the 21st century. 
Been waiting for something like this for a while. Definitely looks awesome. 
Might want to consider vue.js http://vuejs.org/guide/comparison.html Angular-lite and outperforms React in some ways. 
In your example there is no difference between `let` and `var`. In case of a conflict it renames the variable in the inner scope.
AFAIK all Babel caveats are well documented, so if the docs say nothing then you can just code away without any worries.
Alternatively, is there a subset of ES6 that is known to transpile reasonably using Babel? Do you guys just check the transpiled code as you start using a given feature to see if it compiled sanely?
That is not correct. The example is an `if` block, which provides scope to references declared with `let` but not references declared with `var` as `var` only recognizes function scope and global scope. Therefore they are not the same and the op's concerns are valid.
I just run my unit tests against the output in the browser environments that I support, and if something breaks it will hopefully be revealed there. `let` is probably the last thing i'd worry about the babel devs not being able to figure out. 
Got it, thanks. It can actually handle some pretty complex situations, if it has to.
In the *context of the example*, `let` and `var` are interchangeable. In the second sentence of my post I went on to address how Babel would work around issues with block scope.
Would love to: you can see the serverside code here: https://github.com/MattMcFarland/codepix-server and the clientside code here: https://github.com/MattMcFarland/codepix-client feel free to star and contribute
And then read https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
In my opinion though this only has value when done in more complex User Interfaces. Like the admin of an app. Doing this for mostly static content doesn't really make sense. It's becoming one of those fad things though.
Such a predictable response
Aye, good addition.
Do you know of any easy replacements for carousels?
??? I've thought those files are meant as global configuration for all my project, which is why `~`. Copying them over and over to every single project sounds like a lot of friction. 
I understand that with ES6, some of those warts are fixed to some degree. But trying to tell me that the lack of an integer type is somehow a "win" for JS is a bit of a joke.
Have tried it anyway and the same problem remains, still can't find the presets but only in a different directory.
I figured out what went wrong: The configuration data in `webpack.config.js` is _secondary_ = added to primary configuration data that Babel finds (in either `.babelrc` or `package.json`). In my case, there was no primary configuration data, which is why everything worked. In your case, it found faulty configuration data in `/Users/dz/.babelrc`. Download the latest version of the demo project from GitHub, it should work now.
Jason's article on ES6 modules was great -- especially breaking down the issues with not quite having a module 'loader' spec in place. If you ever get a chance to see him at a conference or user group, take it, he's a phenomenal speaker!
I'm thinking that it was updated incrementally, and the bit about having no `class` statement was true less than a year ago.
I thought `var` statements were *allowed* in blocks, but then the declarations were just hoisted to the top of their scopes; the only problem (pre-ES6) was the use of *function declarations* in blocks, which were handled inconsistently by engines.
And it's a wiki, so the community can [contribute](https://developer.mozilla.org/en-US/docs/MDN/Getting_started) to it.
I added info. about symbols on the left side of the [`in` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in) and it was accepted; I feel proud of myself now.
For a highly focused but short intro just give a class on scope. It should take roughly 20-30 minutes. Highlights: * Scope is lexical (nested bodies) * Global, function, and block (ES6) * Closure - crossing a scope boundary to resolve a reference * Not related to inheritance When I last demonstrated this concept I created a slide with a code example that had color backgrounds for global scope, a parent function, and a child function so that the scope boundaries is communicated visually. If you want to get crazy talk about how you can reassign values to references used in closure and what that means... shared data, controlled side-effects, leaky functions, and so forth.
I'm curious to know your opinion of frp and frp-alikes. Are you saying you don't see a value to writing whole applications in something like Elm?
That probably is the best way to go, but /u/rauschma just released [a book](https://leanpub.com/setting-up-es6/read#leanpub-auto-are-there-es6-features-that-cant-be-transpiled-to-es5) that partially answers your question; in short, there is no good way to transpile proxies, subclasses for built-in constructors, or tail-call optimization: The first two *could* be transpiled, but in a way that degrades performance unacceptably, and the middle one requires `new.target`, which was added in ES6. --- By the way, it's not a matter of transpiled code being too *complicated*, just too *slow*: As an example, generators require a large amount of code to be transpiled into state machines that rely on Facebook's regenerator library, but they run properly and fast enough to be worth it, so Babel does support transpilation of generators.
This article is unfortunately actively detrimental. The two cases that the post mentions are the simplest of examples and an FRP library is obviously overkill for them. FRP really comes into its own when you're doing complicated stream processing. Think about the case where you want to merge three streams together but you want to debounce one of them, map the other, and sample the third based on a timer, and then map the merged stream into a different object type? Using an FRP library this becomes trivial, and doing it manually is a nightmare. And yes, in reasonably complex UIs (think a spreadsheet with multiple realtime collaborators) this type of problem does come up. To dismiss a tool because it's the wrong fit for the job is an unfortunate thing to do.
Are you arguing the point that the JavaScript number model is not infact easier to teach a non-programmer than a more traditional number model? I assure you it is infact much easier to grasp as it more accurately reflects how every day people think about numbers. It's only a win in that context, which if you read up on the history of JavaScript, this was a cognizant goal of the language design. Personally - I am right with you, in my every day work I would much prefer a more nuanced type system. We were not the original target audience of JavaScript. You could argue that JavaScript should have not made this language trade off, and that would be a worth a discussion, but to not acknowledge that there is a benefit to the existing model is not a good place to start on such a discussion.
&gt; Are you arguing the point that the JavaScript number model is not infact easier to teach a non-programmer than a more traditional number model? Yes. Most number systems in programming do not match what people "expect"; with starting beginners integers are the easiest to understand, since they are readily used in for loops, array indexes, dates, items etc... (I used to teach non-programmers Python). &gt; We were not the original target audience of JavaScript I'm not sure why that's important in today's world. You even agree that a slightly more nuanced type system would be an improvement, which is why I listed it in my previous post. I actually use JS every day in my job (and I quite like it), but it's not as smooth as it could be.
&gt; Making it valid in both forms is trivial Still produces a ReferenceError in strict mode, mind you. So, this isn't something you could do inside a class or module.
&gt; /u/selfAwareWhileLoop is refering to the transpiled code Yes. The point was that the program was broken to begin with.
&gt; To be fair on Babel, if they were to handle these edge cases, I would bet that it would be a net negative on the software as it would significantly slow down transpile times to support weird, dynamic cases. It depends on how they did it. Imagine that instead of attempting to check for naming collisions they just replaced every let-declared variable name with a random name long enough that collisions were astronomically improbable. This wouldn't take a ridiculous amount of time to run. It would protect against the specific case I posted as an example, but it would also break other crazy uses of eval. You could no longer use an eval statement to reference a let-declared variable from within its own block because you wouldn't know the transpiled name (this is already true of the subset of let-declared variables which do get renamed). You're trading one crazy use case for another crazy use case, so why even bother. Properly sorting out which variables are going to collide when eval is used would be impossible. We could write up an example that randomly generates strings to evaluate that sometimes happen to collide with our let-declared variables; good luck supporting that case.
You are right on both accounts. Aside: Block-scoped function declarations finally landed in Firefox. Firefox 46 should support them, too.
Oh no, my haphazard example only runs without error in some contexts rather than every possible context you can conceive of! I'm going to go home and rethink my life.
Angular has generally made testing really easy, can you show some samples of your code? Not to be harsh, but if your code is ugly and hard to test it is possible you were writing bad code. Have you checked [John Papa's Angular Style Guide](https://github.com/johnpapa/angular-styleguide)? Does your code look remotely like the guidelines? As far as React versus Angular, I like both. I find Angular is really useful for apps with a lot of data entry because I found Reacts handling of form state super tedious. However that was well over 6 months ago, I imagine there has been a ton of development and fixing in that arena. I love developing view heavy React applications and think it has been super influential and great for the JS ecosystem but seriously forms were tedious as hell in React for me. As far as Angular 1.X not having a future, it'll receive long term support and have a really simple transition guide to 2.0. I think rewrites can be a really good idea and would definitely suggest doing so. Before you start though, document and analyze your app as much as possible. Not the code, but the features and purposes. One of my strategies that I've liked so far has been to actively duplicate a lot of things. Basically write some very WET code until I've got the bulk of my features down then I can decide where it should be dryer. This works for me because I've been the sole dev or in a small team but definitely doesn't scale up to larger teams. Hopefully you used a lot of the same patterns in your app, if that's the case then you can easily identify WET areas and DRY up your code. Whether you choose Angular, React or Backbone I'd think deeply on what you like and don't like when reading and writing the code, what can be simplified and what is okay being complex.
&gt; why not just pass that observable into the business logic? Sounds like a fine recommendation and one of benefit to potential readers -- unlike hyperbolic words such as "unnecessary", "detrimental", "danger", qualified only with "might", "I think", and "I feel". I'm puzzling over the purpose of your post when you talk about a websockets lib that isn't linked and when you talk of vague, general problems that apply to many programming architectures. Why crap on someone else's library and hard work without providing an alternative, or advice, or really anything of substance?
I love doing this on GitHub. Even just fixing a typo. 
&gt;In order to use Microsoft's fork, you need a Windows 10 machine with the November update. It’s a huge update, ... And with that &amp;yet jumped the shark in my mind.
I don't see your string of posts as a personal attack, I see them as an ongoing failure to recognize the singular the purpose of my examples. You're still going on about how horrible eval is, even though I said it was evil from the beginning. You're poking holes in cheesecloth to demonstrate its unsuitability as a handkerchief; my examples were written solely to demonstrate the edge-case behavior of Babel. As the warden and the prisoner said, "what we've got here is failure to communicate." I appreciate your attempts to spread knowledge, and I hope you have a nice night. You might consider rereading this thread in the morning to see if your posts still seem relevant given their context.
Theoretically they're eventually making it cross-platform. Until then this is obviously a deal-breaker, though.
I find Webpack, for all its hype and promises, too immature for now. Unpredictable, unintuitive config and barely helpful error reporting. No surprise most big projects are using Gulp, even React-specific ones. I'm with you on Flux and cleverness, Redux is simpler but the problem with both is - they are usually demonstrated on examples where they rather add the complexity than subtract. Not mention the number of tools to use just for the sake of apparent incremental benefits. Nothing bad to be said - some of these tools may really be great for the right use. I just prefer to focus on 1 thing at a time. The crux of it is to isolate your data/state from the Views and only update it via "actions". Which can also add to complexity and mess, e.g. when placing loads of listeners on the same dispatcher as advised by Flux. But Angular 1 already provides you with Module/Service structure to isolate and separate parts of your state. You can also easily make any parts "Immutable" inside the Service holding the data. Then you can make your data Services accepting "actions" directly, via events (Flux) or via "reducers" (Redux).
Vue looks nice but how much work would I need to invest to adapt any Angular plugin?
Also look at the new features of Angular 1.5 - easier component declaration and multiple transclusion, looks far from "no future" :)
The examples mentioned are the ones we most often come across in our daily work. I mentioned that this was part of an internal evaluation. I believe the examples mentioned are common for most front end work. I'm glad that you agree that RxJS is overkill in those cases. I do mention that Observables have a stronger case when dealing with multiple, plural asynchronous data streams. I also mention that those are rare. If I wasn't already using RxJS I'd try and use debounce and throttle from lo-dash before going for RxJS. &gt; To dismiss a tool because it's the wrong fit for the job is an unfortunate thing to do. To dismiss a sledgehammer because it's the wrong fit for the job of brain surgery when evaluating brain surgery tools is an unfortunate thing to do. 
I think it's too tempting to drag your OO knowledge from other languages in. It's a pitfall. At least calling it prototypical inheritance at least makes me realise we're talking about something altogether different here. 
Thank you! If it really doesn't exist, then these are good starters! 
Because it hides what is really happening behind the scenes and it strikes some people as pandering to the classical OOP crowd while not really helping people who already understand how prototypal inheritance works.
down voted because no TLDR
Well I've been using gulp and jekyll to build my websites for a while. I understand it enough to use it. I just can't make changes this substantial. Thanks anyway.
&gt; I think it's too tempting to drag your OO knowledge from other languages in. It's a pitfall. Is it actually a pitfall? If you don't touch the prototypes, this stuff isn't any different from other languages with classes. So, what kind of problem did this actually create? You expected things to be very similar and they are indeed very similar. That there are other ways to do this kind of thing does not invalidate this assumption. If you stick with the strong mode subset, you can't mess with the prototypes. They are frozen. So, it does exactly work like it does elsewhere and there is no other way to do it. In strong mode, `class` and `extend` aren't sugar.
Because with flux you add the flux store state to components, but actually a good pattern to use flux was always to get state at parent level and propagate it as props which is similar to that connect feature of redux. I agree that the redux way is indeed cleaner and nicer though.
A single, static image for your featured article. Below that, have a list of 2-3 other article with small thumbnails. I might also add that if you're going to use a carousel, then make sure you're using descriptive markers, not just dots or squares like I see a lot of places doing. Better yet, have a thumbnail and short description that indicates which story is currently showing, and the others that are also available. Ultimately I don't like carousels because people misunderstand them. They actively hide content that is supposed to be featured. Most people put the 3 most important things for their site in the carousel, when, as I said, only about 2% of visitors ever make it past the first slide. 
Thanks for the link. This actually looks like my kind of thing, so I'll look into it more!
If that's all you want to do, you probably don't need a framework. However, I would advise you to avoid no-scroll pages. People expect pages (especially document-focused pages like yours) to scroll. Preventing scrolling by using some other, unfamiliar mechanism is going to annoy people. Yes, you would use ajax to request either the data of the page (and then construct the html on the client) or request pregenerated html from the server (and then just inject it). Both styles have trade-offs. The main thing here is the history api/address bar. If you mess that up, people will hate you. You have to get it right. When users hit the back button, it had better go back. If a user makes a bookmark to some page that is not the homepage, it had better show them what they want to see. Oh, and it should probably work, at least partially, without JS. To my knowledge, React is the only thing that can render pages on the server, and then switch to data-loading mode after the initial mode, if JS is available (the so-called isomorphic or universal web apps). Other frameworks will soon have this ability too. I also personally recommend react for most things on the web that involve dynamic html, because of its airtight, yet simple api. However, as I said, you may not need a framework.
I don't think classes are bad, mess inside JS is bad. It was designed as a mix of class- and prototype-based OOP and it turned out to be a very bad design idea. I strongly believe that languages should be strictly either class or prototype based. ES6 added class based OOP, but did not remove prototype based stuff. WHYYYYYYYY??? So in the end we still have a mess, nothing really changed...
Yes, a parent component like a container for a set of features that share the same state can listen to that store and pass the state to the props
For op's edification: &gt; $.ajax() is actually jQuery. This is neither good nor bad, however might be confusing.
Good job! I especially like the use of ES6 array destructuring to make the `Promise.all` more legible. However, .then((promises) =&gt; { const [books, user] = promises; return pickTopRecommentations(books, user); }); Can actually be simplified further by putting the destructuring in the function's argument: .then(([books, user]) =&gt; { return pickTopRecommentations(books, user); }); Which can be simplifed further in turn, since now we only have a single expression: .then(([books, user]) =&gt; pickTopRecommentations(books, user)); The rest of the article was good too. 
Remove the jade focused part of the builds, replace it with an html moving task. Don't forget to use html file extension instead of .jade
Go with Angular + some template engine. At least you will get the chance to learn the most powerful (almost enterprise) frontend framework.
That is true as well
Agreed
&gt; but `output: './build/bundle.js'` doesn't You’d have to be more specific than this. I don’t have any problems. If the `build/` directory is empty, a `bundle.js` is created. &gt; Why make things easy if you can make them hard That feels like an insult.
Not sure what a Templating Library is.
Why is this your last?
nope... what I am looking for is an API to redirect each request through another gateway. e.g. from PhantomJS I crawl https://www.google.com/search?q=testQuery1 then i crawl https://www.google.com/search?q=testQuery2 and then ****testQuery3 etc... I would like each of these request to be redirected through different gateways so to the domain google.com doesn't see the fetch request coming from the same IP. Does this clear my initial question?
I started a personal project over the holidays, and went with the only stack I know very well (but also the one I really like :P): Django, Django Rest Framework, Angular and Gulp. I would suggest using a generator like Yeoman, but if it's your first time, and you're interested in learning these technologies, it might be worthwhile to setup everything yourself the first time. For what you're describing, it does seem like a fullblown MVC framework is overkill - I think it depends on what the future of the site is going to be - are you going to need more features? Are you interested in learning new tech, or are you just trying to get this project done? This isn't done particularly well, but if you want to see the basic setup of my project thus far...[repo](https://github.com/oowowaee/verbs)
I don’t think I have anything else to say about JavaScript that is useful and hasn’t been said already.
First generation of DOM manipulation was adding stuff to It directly. Think jquery or using browser API directly to modify web page. Second generation DOM manipulation was like good old server side rendering, you create a template of a piece of HTML, with variable names or simple logic for changing pieces. Then you manually render the template with arguments to a selected DOM node. Some popular choices are mustache templates or lodash templates Third generation of DOM manipulation is about web components. They are close to templates but components can contain other components and do not need to individually be initiated. Think Angular or React. If you want to learn front end, start with some library for Ajax and some simple templating language. If you want to go for production, maybe just React and something for Ajax
That makes perfect sense! All your points are right on. I may never need these functions again but if I ever do they're now a project haha 
I can see select and deselect being useful when I want to return query data in a NodeJS project where I only want certain fields being public. That's probably the best use case. It saves some lines and will make the Code more concise 
So state still exists it's just abstracted.
I agree with what you’e saying here too, but if every post that presents technique X also presents Y and Z and goes into enough detail to explain the various advantages and disadvantages of each, it would be simpler to write a complete book.
Haha, which is why we have reddit comments and other such things. :)
This might also be an artifact of me coming from the Typescript world, where they don't quite support all of the ES6's inheritance styles yet, and where they do it's a beast to try to get the compiler to understand what you're doing, without having to resort to casting to the __any__ type momentarily and then casting to the final interface type you know it to be. And because generic typing is the more important feature of typescript, you only manage to shoot yourself in the foot doing that, which is why I avoid it.
If you Google "caplin sljs" you should find this link https://www.caplin.com/assets/static_files/api/streamlink/6.2.8-3489-2f7a95d/streamlinkjs/ I just thought it was a distraction, I figured more developers would be familiar with WebSockets or Socket.IO than our own library. My understanding of the word hyperbolic is different to yours. The alternative was not to use RxJS and instead use functions and primitive data structures. The issue is that our code needs to be maintained for a very long time, Knockout/RxJS come and go but functions and primitive data structures are around a lot longer. Our Knockout focused business logic code is now worthless to us as we are moving to React. I didn't want to repeat the same mistake with RxJS. I hope that clarified the post, I can see that it wasn't too in depth but I didn't want to bore people with too much detail. It seems like I left out information that would have been useful to readers.
That method does not have to be specific to Redux though. The author of Redux wrote a similar higher-order component that does the same abstraction under the original Flux architecture over here: https://github.com/gaearon/flux-react-router-example/blob/master/scripts/utils/connectToStores.js
I agree, you're better off keeping it simple. Don't use a bloated framework if you don't need fancy logic on the page. There is also a learning curve for each framework, which will eat into your time. Simple JavaScript and maybe a bit of jQuery (for easier DOM manipulation) is all you need most of the time. On a related note, since you're a Python guy, take a look at RapydScript (rapydscript.com) to make your front-end more consistent with your backend. It's Python-inspired syntax for JavaScript that makes your code more legible. It's a CoffeeScript alternative. Disclaimer: I'm the developer for it.
For most use cases, however, this syntax sugar will behave like classical inheritance, so why confuse the reader with additional disclaimers?
Bookmarked. Thanks I'll check it out, and I mostly wanted to learn Django.
Actually typescript can express union or intersection types easily, it just can't build them itself. This is where momentarily casting out to the _any_ type is needed. For instance, one could do this: function mix&lt;T, U&gt;(a:T, b:U) { let c:any = {}; for (let i of Object.keys(a)) { c[i] = a[i]; } for (let i of Object.keys(b)) { c[i] = b[i]; } return &lt;T &amp; U&gt; c; } That's fine, just you don't let a junior engineer write this function, because the compiler won't be checking his work for him. This is where it gets interesting, as working with any framework that might have DefinitelyTyped definition files, but its own opinion of what a class is and how to build it (angular1, react, etc.), means you have a bunch of places where the __any__ type is used to smooth things over.
&gt; flux store state to components, but actually a good pattern to use flux was always to get state at parent level and propagate it as props which is similar to that connect feature of redux. I agree that the redux way is indeed cleaner and nicer though. You mean using "smart" components as store state retriever and pass it to "dump" components?
Maybe in a hello world toy app. The first pain of using callbacks is when you have simple conditional async stuff like if (passwordIncorrect) yield db.insertFailedPasswordAttempt(user.id) Building up a promise chain is one way to address this, and by that point you're pretty much using Koa. Koa and Express ultimately are just a few libraries away from each other. I use Koa because the simple abstraction is built into the framework and ecosystem. And Koa is made to work with async/await.
While they're very useful, type unions don't represent traits or multiple inheritance very well. let a = { doThing() { return 26; } } let b = { doThing() { return 'Hello!'; } } let c = mix(a, b); let result = c.doThing(); console.log(result); Here, `result` is inferred to be of type `number`, however in the actual implementation, it is a `string`. `doThing()` is actually inferred to have two overloads, one which returns a `number`, and another which returns a `string`. The compiler will pick one based on how you use it. You could very easily make it pick the `number` one and be led to believe that your types are working correctly, when in fact, are leading you to trouble. This because multiple inheritance, particularly as the post describes, *is not just a type union*, it's much more complicated and logic-based. Especially in some of the later combining policies, which could do things like pipe one trait's implementation to another. (reposted since original post had a tinyurl to a typescript playground link, which automoderator didn't like) 
Disclaimer: I'm a Java developer with very novice experience in JS. &amp;nbsp; From the outside looking in it appears that JS guys are really concerned with classical inheritance "extends" more so than the syntactical sugar that "class" provides. Am I correct? As a senior Java developer who often has to explain to my new devs why they shouldn't use inheritance I understand this frustration. &amp;nbsp; But do some of you guys also dislike the syntactic sugar that class provides as well? I would like to understand why that is if one of you could explain.
I have offered a bounty there. Guess someone can answer :-) 
Thanks, Haven't heard of that before. Will check it out.
I agree, I'm with /u/s-keww on this, I think it'll be good for standardization, IDEs and engine optimizations.
better managed... we had performance issues because we had store listeners in each individual component rather than at the parent component level... changing it to parent component level fixed these issues
That question pertains to uncertainty. Even if he says "yes", maybe he finds a beautiful girl, falls in love and will no longer have time to maintain it.
That makes sense. I think though that this is an issue of the components tree. It's a matter of creating the right high-order component at the right place and wire the children below via props.
It seems to me all Redux does is force you a specific structure you could achieve with default React. I'm quite new to React, I just want to figure out do I really need it, because it's role looks redundant / unnecessarily complex to me.
http://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/
Yes. The "compiled or interpreted" question predates Just In Time compilation, which is neither. (I've seen it called "interpretive"). So we should stop asking that question with only two options. But if you had to choose one of the two, you would reasonably choose interpreted, signifying that the code you share is platform-independent and there is no separate compilation step before you run code. Another reason to choose "interpreted": the fact that V8 and other optimizing compilers exist for JS doesn't mean that the *language* should be said to be compiled. If the language (rather than the modern implementations of it) was designed with a preference, it's clearly a preference towards interpretation.
Eh? What's wrong with having dependencies that you need to install after you clone? What's wrong with a required build step or launching of a server in order for your app to run? As long as theres are well documented, I see no issue with required steps for dependency installation or compilation.
Nice read, thanks for sharing
Thanks! :) I just put that on my todo list to get those functions added. I'll let you know if I have any questions about intent 
You don't like the syntax of generators? That's not something that koa invented or has any control over 
You can get a proper module system with system.js: https://github.com/systemjs/systemjs And coupled with JSPM you have every npm or github library just at the tip of your fingers.
Whether a language is compiled or not is an implementation detail. Modern JS engines use a just-in-time (JIT) compiler, but there are also pure interpreters. C is usually compiled, but there are also C interpreters. Language specifications generally do not specify how things are supposed to be implemented. They only specify how all those language features behave. How it's actually done is up to the implementation. Well, "compiled" doesn't necessarily mean that it's super fast and "interpreted" doesn't necessarily mean that it's super slow. If the generated native code is cluttered with inefficient garbage, it might be relatively slow. If your interpreter is lean and highly optimized, it might be fairly fast. Today's top JS VMs (V8, Chakra, SpiderMonkey, and JSC) are all very fast. JavaScript is one of the fastest scripting languages.
Here you go, I've redone it with canvas :) [http://nielstron.de/fun/?us=ameisenfutter.canvas](http://nielstron.de/fun/?us=ameisenfutter.canvas)
I don't mean to be negative, but is the any reason you don't just use lodash for most of those functions? I can see that some of them have slightly different behavior, but what about the "exact same" ones? 
Good question! The only one that is also in Lodash with exactly the same behavior if I'm correct is cloneDeep. I added that because it was trivial to add using a couple of the other functions. Are there any others im missing? Lodash is pretty large so it's definitely possible I just didn't know it had a function that already did what I wanted.
This is something I wrote for the National Contest of Informatics. It roughly simulates the food search of ants. Atm it's completely in german but that will change soon :) This version uses a canvas for drawing although the original version makes use of a gigantic HTML table with a gazillion cells. [http://www.nielstron.de/fun/?us=ameisenfutter.canvas](http://www.nielstron.de/fun/?us=ameisenfutter.canvas)
Oh, sure, that's why js looks like c, like most other languages of that time. There are probably over a dozen things that are 'unnecessary visual noise' in c-style languages. It's just that js engines let you get away with this one. If you really want to write in another language with a different style, why not use a transpiler?
You seem to already know. If you came out with like some random application and people really like it, so you make it more extensible and write a language that works, it's going to be toy-esque. The people who extend it are only going to be using it for little things in the beginning. Your competitors will adopt it but it'll have quirks. It's just what happens when companies don't know how big a technology will turn out to be. There are tons of things implemented kind of like how JavaScript was, but they're not big and you've probably never heard of them.
It is heavy-handed. "Composition over inheritance" means you should consider composition first for the sake of simplicity. The phrase has been skewed by some to mean "never use inheritance" or "you don't need inheritance", which is of course ridiculous. Always use the right tool for the job.
Escaping as in html entity encoding? hyperscript, virtual-dom, and react all do this: var vdom = require('virtual-dom') var hyperx = require('../') var hx = hyperx(vdom.h) var title = '&lt;3' var tree = hx`&lt;h1&gt;${title}&lt;/h1&gt;` console.log(vdom.create(tree).toString()) output: $ node esc.js &lt;h1&gt;&amp;lt;3&lt;/h1&gt; And the html parser takes care of the rest.
Not very rare at all. Think about an autocomplete search that hits a server. You want to debounce the user input so you only send out a request if they've paused for 300ms, and you only care about the response to the last request that was sent out. Doing that very common case with streams is extremely easy and natural. Doing it without streams is much harder.
Yea, runs a lot faster now. Good job.
It was this as much that it was the API wasn't consistently implemented (and neither was the DOM) so getting anything less-than-trivial done was all but impossible. AJAX didn't come around for over a decade after Javascript was around, too, making it much less useful.
What you are saying makes no sense. ES6 didn't add class-based OOP. It could be argued that ES6 didn't *really* change or add anything. Its all just sugar, and thats fine.
Would be nice if there were a counterpart to Promise.all() that executes promises serially. Yes, I know how to do it with array.reduce(), and use it every day. But it's such a common pattern that IMHO it should be added to the API. 
A lot of reference implementations of modern languages are not obviously compiled or interpreted, but somewhere in between with attributes of both. JavaScript is like this as well. For example, the reference implementation of Python (CPython) is usually considered an interpreted scripting language, but in fact the "interpreter" compiles Python code files into an intermediate representation of bytecode that will then be interpreted by a virtual machine. Java is very similar, except its virtual machine uses a JIT compiler instead of an interpreter. The V8 implementation of JavaScript takes a very similar approach, except it doesn't produce an intermediate representation. It JIT compiles JavaScript directly into native machine code. Does this mean JavaScript is compiled? Yes. It is definitely a compiled language when used with V8 (or any of several other implementations that use a similar strategy). Is JavaScript then no longer an interpreted language? That really depends on what interpreted language actually means. Does interpreted language mean you can fire up a REPL and hack away directly into a command line? If so then yes, JavaScript is interpreted. Does it mean you can run snippets of code without a full compile/link/build process? In that case, also yes. However, you could just as easily argue that modern C/C++ compilers that can do incremental compilation also achieve this. Are those interpreted? Most people would say no. The point I'm trying to get at is that the distinction between compiled vs. interpreted is not that meaningful in 2016 when almost all modern language implementations use multiple strategies that combine the most useful features of compilation and interpretation. 
I posted this above but I think it's worth a repost to your response as well: Koa is using generators and yield as a temporary stepping stone towards koa@2.0.0, which will be using asnyc and await from ES7. Understandably the generator + yield is not the perfect solution (though this this much closer to the direction node should be going for), I highly reccomend taking a look at koa once 2.0 and ES7 are finalized. 
Two wrongs don't make a right; please be civil!
The alternative is factory functions http://youtu.be/ImwrezYhw4w
Netflix developed Falcor as a solution to accessing data from their microservice architecture from their React-based Front-End. In essence, the frameworks look to make accessing your data model on the back-end simpler for your front-end. They are currently the major adopters of the framework since they are the ones who built it, making specific tradeoffs that make it slightly different than Facebook's Relay which works with GraphQL. Netflix made the technical decision to utilize React as the view layer of their application, and actively use RxJS to complement the behavior of the user interactions with their UI. RxJS does not compete with Falcor, in fact, Netflix built Falcor utilizing RxJS.
Not off the top of my head, sorry :/. I know that in the past though I've ran into situations where I required some form of hoisting for something to work as intended and so I used `var`.
It's not too bad on my phone (ios9), but something to indicate that I have to swipe would be great.
If we're transpiling, wouldn't there be additional overhead to const potentially? 
It makes no sense to use inheritance for the examples in this article, or traits in more powerful languages. Is there any reason why doing this doesn't make sense? # pseudocode class Color(val r: Double, val g: Double, val b: Double) { def to_hsl = { # ... } } # instead of doing inheritence for no reason, simply let `Todo` have a `color` property class Todo(val name: String, var done: Boolean = false, var color: Color?) { def do = { @done = true } def undo = { @done = false } } Edit: more complete solution # pseudocode class Color(val r: Double, val g: Double, val b: Double) { def to_hsl = { # ... } } class Todo(val name: String, var done: Boolean = false) { def do = { @done = true } def undo = { @done = false } } class TimeSensitiveTodo(val name: String, var done: Boolean = false, val deadline: Date) extends Todo { get color = { val slack = @deadline - Date.now() if (@done) Color.grey else if (slack &lt;= Duration(0)) Color.red else if (slack &lt;= Duration("1 day")) Color.yellow else Color.green } }
[removed]
I think var will be replaced by let and const when developers decide to do so by preference and that'll probably take as long as it takes people to start writing in ES6 (which is probably a long time). The only thing I know var can do over let is declare properties of the global object, which can be done with let if you explicitly use global objects like window anyway. let/const also aren't hoisted like var (they instead have a temporal dead zone). How much of a benefit hoisting is will be up to you. I much prefer let/const, but down the line knowing var will be useful for maintenance.
&gt; While there will be some specific use-cases for `var` There aren't any. If you want your `let`/`const` thingy be available one level above, just declare it there. `var` doesn't serve any purpose anymore. For example: let a = []; for(var i = 0; i &lt; 3; i++) { a.push(() =&gt; i); } console.log(a[0]()); // 3 Same with `let` which gives you the behavior you generally want, but lets assume you consider this broken: let a = []; for(let i = 0; i &lt; 3; i++) { a.push(() =&gt; i); } console.log(a[0]()); // 0 The "fix": let a = []; let i; for(i = 0; i &lt; 3; i++) { a.push(() =&gt; i); } console.log(a[0]()); // 3 If you *really* want that kind of behavior, you can have it. You can always declare a variable at the very top of the innermost function to get `var`-like behavior. This is actually the main reason behind the now obsolete "one var" style rule. If you declare them all at the very top, the code looks the way it behaves and there won't be any surprises.
And in 2016, a nice follow-up would be a guide to ES6, like http://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/ :)
[removed]
already has
A working node based game lobby with matching! Awesome and thank you!
You just have to check if someone attempts to write to your const within the block it was defined in. { const x = 5; x = 3; // error: "x" is read-only } let x = 7; // perfectly fine Also note that `const` does not make things immutable. It only prevents you from assigning something else to it. If the object itself is mutable, you can still change it. const a = []; a.push('foo'); // perfectly fine a = 'asdf'; // error: "a" is read-only https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze `Object.freeze` can be also used in constructors: class Foo { constructor() { this.x = 5; Object.freeze(this); } } let foo = new Foo(); console.log(foo.x); // 5 foo.x = 7; console.log(foo.x); // still 5
Is the plan that they will make it default to strict mode soon? I'd really like to start using ES6 features but I don't really know much about transpilers right now or how that works with nodejs.
That was interesting. I know a bit of C++ and looked at the V8 code and still have no idea how it works. The people who come up with this stuff must be savants. Write compilers for fun.
Who says the preferred method is to use const?
&gt; if(...){ &gt; var foo = 1; &gt; }else{ &gt; var foo = 2; &gt; } This should be written like so: let foo; if(...){ foo = 1; }else{ foo = 2; } 
Of course it's predictable. There's a new JS framework seemingly daily. A "why's this better; who needs this" is exceedingly helpful. I have a hard enough time with React vs. Angular, let alone the dozens of other alternatives.
I miscommunicated a little. Strict mode is not what will make ES6 work but it is a requirement for some ES6 features. Now as for ES6 features, not all of the official features will be implemented in browsers soon, if they are all even adopted that is. So how do we solve this issue? Through a transpiler like Babel, which turns all the ES6 code you write into regular ES5 (which already works across all browsers). You don't have to know all of ES6 to start using it through Babel, I'm even still learning a lot and that'll be the case for a long time. The first four chapters of [exploringjs](http://exploringjs.com/es6/) and reading the [babel site](https://babeljs.io/) is worth your time to get started.
The idea is to push in a series of thunks and then show how the scope changes depending on where `let` is: In the first example, each thunk returns a different integer, but in the second, each thunk returns the final value of `i`, which is 3.
Most of the time, we don't need to change the value assigned to a variable, and if we use `const` to declare these variables, the JS engine can perform more optimizations.
Native ES6 performance is very bad for some reason. This is probably outdated, but I've seen a jsperf that shows that arrow functions are like 10x as slow as functions bound to the current context, even though I believe they are functionally identical (someone can correct me if I'm wrong about either of these things). Kind of begs the question... why not just run the whole thing through a JIT transpiler or something?
I can't speak on the perf of arrow functions but the difference in an arrow function is that is that it's `this` reference is relative to where it's declared, rather than the context in which it's called. This would require a call to an arrow function to require some reference to the scope of which it was declared, which is likely where the performance hit comes from.
DI is awesome. IOC containers, not so much. There is an important difference.
Comparing `const` and `let`, I find that the situations where `const` saves you are so rare as to be negligible. The real problem with mutation in JavaScript is mutation of object properties, which `const` doesn't help with. Personally I don't find it worth the extra characters. 
Let offers nothing useful. It only exists because people refuse to learn the language. ES4 had an actually useful let block that was explicit (and also was performant when transpiled), but the C# and Java idiots from MS and Google want to push the language to look like their pet languages. The TDZ causes it's own host of problems both for the user and for the JIT when it comes to making the code fast (JITs should only be able to heuristically optimize a couple common use cases). There are other less-known related issues such as default parameters actually creating an intermediate scope. Babel and other transpilers are fairly open about not being able to detect all violations of the TDZ until runtime (meaning that you can write code that seems to transpile correctly into ES5, but breaks if it's actually run in an ES6 environment).
I'll re-format that post so that code is properly formatted (protip: begin each line of code with four spaces, beyond however else you would indent it). var app = (function () { var cache = {}; var kKeys = [], _header, _footer, _timeline, _scroller, _scrollbar, _stats, _scrollCoef = 0, _defaultAnimations, _animations, _animationFrameId, _renderEnabled = false, _latestSectionRoute = '/home'; var _sectionIndex = {'section-home': 0, 'section-agentsreport': 1, 'section-leaderboard': 2, 'section-about': 3, 'section-rewards': 4, 'section-tour': 5, 'section-profile': 6, 'section-tour': 7, 'section-about': 8 }; var _init = function () { $.support.cors = true; _initCache(); if($.cookie("legal_announce") != "1") { cache.cookie.show(); } else { cache.cookie.remove(); } _initBounds(); _initFacebook(); }; var _facebookLoaded = function () { _initControllers(); _initLoader(); _initRoutes(); _initStats(); _registerEvents(); _mediaChanged(); if ((env.device.mobile || env.device.tablet) &amp;&amp; user.isAuthenticated()) { setTimeout(function () { $.manageAjax.add('ajaxProfile', { abortOld: false, type: "POST", data: { id_badge: 4 }, preventDoubleRequests: true, cacheResponse: false, url: "badges/win" }); }, 10000); } &gt; It's similarly set up to the Konami Code shown below (which I managed to somehow work out) else if (kKeys.toString().indexOf("38,38,40,40,37,39,37,39,66,65") &gt;= 0) { kKeys = []; $.manageAjax.add('ajaxProfile', { abortOld: false, type: "POST", data: { id_badge: 24 }, preventDoubleRequests: true, cacheResponse: false, success: function () { liveupdate.fetch(); }, url: "badges/win" }); } &gt; which translated to U,U,D,D,L,R,L,R,B,A. The first part of the code isn't even complete; JSHint complained about a syntax error and also about duplicate object keys in `_sectionIndex` (specifically, `'section-tour'` and `'section-about'`).
Well I think one thing that might confuse people is the fact that Java/C++ people expect a `class` to be a full blueprint of an object. In JavaScript, this won't really be true if you don't use `Object.freeze`, like in this example: class Car { constructor() { this.miles = 0; this.color = 'white'; } drive(miles) { this.miles += miles; } } // A property like this can be added on at any time to the Car.prototype Car.prototype.paint = function(color) { this.color = color; }; Which is why it might be better for people to understand that using `class` still deals with prototypes.
Because it encourages OOP, and inheritance, which modern js developers consider bad practice.
Until fetch, with its polyfill, came along, jQuery (or some smaller jQuery-compatible library, like Zepto) was probably the best way to do cross-browser Ajax, if you weren't already using another library that had a perfectly good implementation.
`const` only means a variable binding isn't reassigned, not that the object for instance isn't mutated. It's totally possible to statically analyse `const`-ness. The only things that would break that is `eval` which Babel doesn't generally support.
This is true (if by "mutated" you mean "reassigned," because you can generally mutate an object declared by `const`), and it takes a little longer than being able to tell, from the `const` keyword, that it *can't be* reassigned.
const is a value that is constant and can't be changed... "The value of a constant cannot change through re-assignment, and it can't be redeclared." - MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const Meaning you should only use const when you know the the value your assigning won't change or you won't need to manipulate that data in any way shape or form. It's great for things that need to be hard coded like an API URI path for all of your server requests. Stick to var and let for most if not all of your declarations, why completely cripple your ability to change a value? 
The reality is, you probably don't need mutability, and if you don't need mutability, you shouldn't allow it, since it can lead to some nasty bugs as your codebase grows more complex. If you aren't already using const everywhere, try to go a week without using var or let. Some things take some getting used to (you won't be able to use for loops anymore, for example), but you should notice a difference in the quality of your code pretty quickly
Then your string-comparison would still have false positives; for example... '/r/javascript+jquery/' &gt;= '/r/css+design/' // true A better idea for matching part of a string is `String#indexOf`: if (current.indexOf(url) === 0) I'll edit the code above to reflect this.
&gt; Also, you should probably use for of instead of for in there What's the difference? Both ways seem fine to me.
Seems there is a `"tictactoe.css`. Would be helpful to have that stylesheet? https://css-tricks.com/ is usually pretty good if you are looking at styling problems. Without actually knowing what your css looks like, I made this http://codepen.io/anon/pen/MKJopa (which is great for testing out code). I made your box an inner container with the height and width at dimensions that would make the buttons sit in a square, or tic-tac-toe shape(play with the sizes and see what happens to the buttons). I gave everything borders just so you can see what's going on. I then made an additional container on the outside. To make your buttons sit on the right, you need to make the parent container (#container) have a position, and you need to have the inner container (#box) have a position. You can then set the #box to have `right: 0` so it is 0 px away from the right edge of the parent #container. http://www.w3schools.com/cssref/pr_pos_right.asp - This explains how 'right' works. If this is not what you meant by right side, consider clarifying your question or drawing a quick picture.
Just a quick note, In your example above you have this line ul.insertBefore(newli, list.childNodes[0]); list isn't defined as a variable, but the tab menu was as "ul" So would it be safe to assume that the proper way to write this would be ul.insertBefore(newli, ul.childNodes[0]);
Agreed, I think `const` was inspired by Swift's `let`, while `let` was inspired by Swift's `var`: http://stackoverflow.com/questions/24002092/what-is-the-difference-between-let-and-var-in-swift In reality, the only thing `const` buys you is making it a bit harder to shoot yourself in the foot. In my opinion, there are better low-hanging foot-shooting fruits in JavaScript to go after, such as throwing an assertion when performing arithmetic on incompatible types (`{} + "wtf"`).
But... variables are, you know, variable. Constants are more or less constant.
Using const is also a way to communicate to other developers who will read your code, that this value is one whose value should not change (or need to change). 
Based on the feedback so far, I've updated the description and purpose of this library to "A library for performing deep and recursive operations on objects and arrays" that seems to be the main factor that sets these functions apart from the ones provided by Lodash etc
Babel, among other things, is a Node command line tool! With not much setup at all you can switch your entire JS stack to es6 / es7. It's entirely worth it. https://babeljs.io/docs/setup/#babel_cli PM if you need help!
I was going to say the same thing. A const var is an oxymoron.
Sorry if that was confusing, all I wanted to say is that it would be more beginner-friendly for Webpack to support this basic syntax: output: './build/bundle.js' (It definitely wasn't about your implementation.) As well as it would be more beginner-friendly if the `babel` entry in `package.json`: * Wouldn't be needed at all by default. * If really needed, would at least be automatically generated when the preset is installed. That would save many people countless hours searching solutions for their problems and posting questions, and would let more experienced people like you to focus on more serious tasks, instead of answering those questions that shouldn't have been asked in first place. There is a problem out there, and what we have here is just one instance of it: https://twitter.com/floydophone/status/680226147213426688 I have great respect for your work and am really sorry if you feel insulted, that definitely wasn't my intention. Rather frustration by why things should be harder than they need to, and some irony. 
Hello Everyone, I am the author of the framework, and after reading all the threads taking out some time to share my views and answer some questions. Why not Express or Koa ? Express and Koa both are awesome, but they are libraries instead of fully featured frameworks. They do good what they do, but leaves it to you to make decisions on how to structure your application and get best out of it. Why not Sails ? It is not like i woke up one day and started writing Adonis, i had been writing applications in NodeJs and tried Sails myself, what all i feel about SailsJs is a hack over express to build a MVC framework. Sails starts by reading your routes file and loads all the controllers into the memory, which is fine for hello world application but not for real-time projects. Also testing is broken, they had shown some examples on how to test your sails code, but trust me, testing is much more fun than Sails makes it for you. Now Finally Why Adonis ? Ofcourse i am not comparing with Express or Koa, they are different breeds all together. But if you are in a need of a true MVC framework, then here you go. Adonis has a strong DI layer, and to make sure DI is not frustrating, we have IOC container which create magical instances of a class based upon its injections. More on Ioc container here http://adonisjs.com/docs/2.0/ioc-container. Next Adonis do not load any controllers or models in memory, infact on runtime your controllers are lazy loaded and cleared off the memory as soon as it is not in use, which is nice for v8 garbage collector to clean off things. Not even a single MVC framework takes care of error handling, Node has a behavior of showing errors on terminal, but for webapps we are more focused on browser. Adonis shows pretty errors on your webpage, so that you can read, understand and solve them without wasting time. http://postimg.org/image/f4g7e3zyd/ I am from a breed of programmers, who cannot write ugly code. Adonis is an attempt to keep your code free from unnecessary curly braces. Validation http://adonisjs.com/docs/2.0/validation engine is an example of same, i never had luxury to validate data this easily. In short 1. Adonis is for the one, who wants to write quick applications. 2. Likes expressive syntax over curly braces. 3. Loves all sort of testing ( I will releasing a provider for seamless testing soon ). Finally, @Democratica . I already have a beautiful girlfriend and still managed to write Adonis from scratch, don't worry it will stick around as long as community needs it. :)
True, still limits itself to a very small percentage of a application.
Well, you were right again. I didn't realize your select and deselect could go deep like that. And yeah, I don't believe lodash can do that out of the box. I guess my only critique now would be to put somewhere in the docs/description that the functions are especially suited for deep object manipulation. (since it looks like that is how it is distinguished from lodash) 
ES2015 let/const semantics predate Swift by many years. Also, "fixing" incompatible type arithmetic without breaking the internet is not low hanging fruit by any means.
I mostly agree with this statement and the general sentiment, but `let` does _let_ you create variables private to a block without having to use a closure or a different strategy, which I find convenient. Other than that, I'm on this with you.
Currently I write all my Javascript to ES6 standards and use Webpack to compile (transpile?) down for ES5. I only use "const" and "let" now rather than "var". I suspect "var" will be deprecated albeit useable for quite some time but eventually phased out.
Can't actually read that last sentence. Gotos and writing apps directly in assembly work "perfectly fine" too.
Fix incompatible arithmetic? Clearly we need operator overloading.
Wait...why would you ever actually want the "broken" behavior (where `a === [3,3,3]`)? Hopefully that is just for sake of demonstration, cause that's a thing most JS programmers have to "fix" at one point or another early in their JS career.
You should initialize it or you might run into issues with TDZ
This very much. Whatever system you develop will be defeated. Also your system is vastly over-complicated. Just generate an ID and sign it to make a key, and give both to the user. Then the client can just verify that the key is the right signature for the ID.
I can't think of any optimization that const would permit on a local scope. 
If you're transpiling to ES5 standards, shouldn't have problems. Otherwise, enjoy. http://caniuse.com/#feat=const http://caniuse.com/#feat=let
Depends, are you guys using an ES6 ready environment or compiling using babel already? Then I don't think there will be an issue, if not, you would need to set up the dev process for everyone on your team. Using let isn't a big change, if you were caucious about variables leking into other context before, so it should work fine after some practice.
Arrow functions simply resolve this via their closure (lexically) legacy functions locally override the lexical this instead. It should be no different than accessing a var defined as `that = this` or the like but I'm guessing there are legacy `this` fast paths which get involved (to not look up `this` lexically) and cause issues. 
a isn't [3, 3, 3]. It is an array of functions, each of which returns the value of the closed over variable i. Since the value of i is incremented to 3 before a[0]() is called, that is the value returned by calling the function. If you understand how closures work, this makes perfect sense and happens in other languages that have closures but don't scope their variables like JavaScript vars.
The answer's not quite that simple. In some cases the are a bit slower, but in other cases (especially in v8 IIRC) they are quite a bit faster. I believe they are slower if you are using `this` or `arguments` inside them (due to traversing the scope tree), but should be quite a bit faster when these aren't used because less setup and tracking is required. It'll take time though before these optimizations trickle down.
I've read about that `let`, but never really had a chance to use it. Thanks for the superb explanation.
&gt; {} + "wtf" That's not really an arithmetic issue. The parens at the front are an empty block, *not* an object, so they're basically ignored. That leaves us with `+"wtf"`. You can't do unary concatenation, so we attempt to cast to a number giving `NaN`. All this leaves us with is someone casting with `+` rather than with `Number()`, `parseFloat()`, or `parseInt()`. This is one of the smaller problems a person could have with JS in my opinion (especially as there are several alternatives). 
&gt; These blocks are functionally the same. Pretty much. Except that the redeclaration of "foo" in the first example is strictly speaking an error. &gt; Stylistically some people prefer declaring their variables as they use them. Declaring variables on first use is a good idea with block scope. &gt; It's pretty arrogant to say there are zero specific use cases just because you haven't thought of any. Because redeclaring variables is something you want to do? I wouldn't say that this is a valid use case. This is just bad style and not something you couldn't do without `var`.
Yes, this is just meant to show how easy it would be to opt into the old (generally undesired) behavior by moving the declaration one level up.
Yea, I think that turning your read-only `let`s into `const`s is something an IDE could offer as a "quick fix". This isn't really something I want to bother with as I write the function. Encouraging const-ness is something Rust does a lot better. `let x = 5` is read-only. If you want to make it mutable, you have to change it to `let mut x = 5`.
Thanks for your input! I will do that!
I wouldn't use const for objects I'm still going to mutate, as that only adds confusion for no real benefit. **Edit:** I was already convinced that there's a good reason for it after [the first reply](https://www.reddit.com/r/javascript/comments/3z74ok/will_let_eventually_replace_var/cyke57d) :)
`const` with objects is very useful, since it ensures that you continue to use the same mutable object whenever you use a particular variable.
["HOC"](https://www.google.de/search?q=HOC)?
I never memorize on purpose because Google is always available. That doesn't mean that I always need to look everything up, however, because the commonly used methods and techniques eventually become second nature. As a beginner you need to rely on Google primarily because you haven't had the time to build up muscle memory. It will come, 6 months is just a very short amount of time if you're new to programming in general.
You've been given Lego blocks, and now you complain that memorizing all the things (and larger Lego components that you can in turn use in other Lego projects) people built from them is too much. Oh well, I predict your life will be *very* hard :-) I on the other hand only ever tried to understand the basic Lego blocks and google the rest, *and ignore much more*. Of course, nature invented heuristics for all life forms to deal with complexity. One such heuristics would be to ignore anything a) not backed by an entity that will be around 5 years from now, b) isn't at least version 2.0, c) isn't at least in the top 2-3 in its space. Without having even *tried* to evaluate its individual merits, because they don't matter in the larger context of how stuff works in the real world. Reminder: The VHS format won, not the better format. And shitty Liberty ships and Sherman tanks won the war, not admired and over-engineered German Tiger tanks. You are using a microscope -- and miss the big picture. Learn less about code, learn more about (human) systems.
There is barely anything in that repo. If we start announcing 99.999999%-likely-to-be-abandoned-within-a-month "projects" this subreddit will be drowned in irrelevant and useless stuff. Don't announce *intentions*, announce *results*. There's nothing worth mentioning there yet.
Ok, I get your point. I will delete the post, and probably re-post when we have substantial content. Is that fair enough?
Your framework looks very nice:) Is it already in production use? Have you made any experience in high-frequent-requests-environments, yet?
Hey, that's a good tip. This is something I will definitely try to do every single time.
Solved, this was all I need to know, thanks. I'm not familiar with JS/Ajax etc so I didn't know what exactly to post, All the script required you to do was access the site using a mobile device in order for a reward (virtual emblem). Thanks again.
Maybe what you need is an IDE / editor that gives you code completion / suggestion (call _IntelliSense_ by Visual Studio).
TIL - thanks!
Oh, great. Now I want a JavaScript compiler that compiles code to an executable file. i.e. an executable file that isn't just a JavaScript engine with an embeded JavaScript code. Is that kind of software already available?
ES6 has block-level function declarations. You can use regular declarations wherever you want. In ES5, you could only use function declarations at the top-level and at the top-level of other functions. So, you couldn't use them inside some loop or if. This restriction was the reason why some style guides recommended to always use function expressions for inner functions, but nowadays there is no point in doing that anymore. Function declarations are shorter and they make the code easier to scan. E.g. this is how you could write a TCO-able version: function factorial(n) { function inner(n, acc) { if (n &lt; 2) { return acc; } return inner(n - 1, n * acc); } return inner(n, 1); } Using a named function expression, as you suggested, does of course also work: function factorial(n) { return (function inner(n, acc) { if (n &lt; 2) { return acc; } return inner(n - 1, n * acc); }(n, 1)); } This too can be tail-call-optimized.
Yes, but most of the time a variable could also be a constant, which allows the compiler to do better error checking. For example var x = 5; if(x=3) { console.log("x is 3!"); } is a common mistake that simply can't happen when x is declared as a constant.
Yeah I get that. But then it's not a variable. To say a "mutable variable" is redundancy of the highest order. I hope it doesn't just seem like pedantry, it seems like clear communication about program functionality is severely damaged when you discard well-established meanings.
You might like strong mode. 'use strong'; let foo = { bar: 5 }; console.log(foo.baz); Throws: Uncaught TypeError: In strong mode, accessing missing property 'baz' of #&lt;Object&gt; is deprecated
Wouldn't it be already faulty with `var` anyways? That it doesn't work with both `let` and `var`? Its not an antipattern if it doesn't work anyways. Or am i mixing things up that it will fail only with `use strict`?
The functionality of it, or the naming? Cause i still find using `let` a very shitty name for defining variables (cause lets face it, `var` is way easier to read than `let` on what it actually does. Let means nothing to me. #letitgo
I disagree with your view on variables. Variables don't have to be mutable to be variables. They just have to represent a value in an abstract sense. Take the following code. function (x, y) { const myThing = new myThing(x, y); myThing.goFishing(); return myThing; } I would still call "myThing" a variable because its value cannot be determined without knowing x and y. It varies. The fact that I can't say `myThing = steve` afterwards doesn't make it less of a variable, it just makes it a variable whose reference cannot change. In most mathematics, variables are all assumed to be "immutable". Their values don't really change during the evaluation of the equation, rather they change based on the input parameters to the equation. For example `V = I * R` The variable V, I, and R are all constant an immutable. I can insert values into any of the 2 and the 3rd will still be a variable and will still be fixed based on the other 2. Were I to write this as a program function (and were I able to declare mutability of input params) it would be function calculateVoltage(const current, const resistance) { return current * resistance; }
But for most things you will need to change variables as that is what logic does in an app. If its all static, there is really no way to define them anyways (apart from DRY).
Things you need to know to be a decent JS developer: * Most of the native methods. The object methods are helpful, but you won't use them extremely often. The string and array methods are used all the damn time. * Scope. This one concept is what makes JS the most different from most other languages. It is also the **most important single concept** to understanding anything and everything in this language. * Inheritance. Inheritance is entirely optional in this language, and I prefer to never use it myself, but you should know how it works to debug software you encounter. Things you don't need to know: * Patterns, named patterns, etc. Just use the right tool for the job. If you encounter stupid insanity wrapped in a bunch of boilerplate you may have uncovered a *friendly named pattern* and can destroy it appropriately. * The Date methods and all its quirks. When you have to deal with this madness just use a reference. * OOP practices. Memorizing patterns is something newbs do because it takes less critical effort than writing an original solution. OOP practices are conventions that come together to form friendly practices. If you understand scope and inheritance you won't need this madness either. * Gulp, Grunt, Broccoli, Webpack, and all the other build tools. Just pick this stuff up as the current project demands. Things you need to know to be awesome: * Node.js methods. You are probably still going to have to access the reference anyways when doing anything complex... such as recursive asynchronous access to the file system cross-OS. Knowing the Node methods will save you time when it comes to reading complex operations in a deep callback stack. * DOM methods. Most people don't bother anymore, so this is one of those things that separates the adults in the party from the merely tall children. Every interaction between JavaScript and HTML/XML boils down to the standard DOM methods. This includes query selectors, which can be very slow due to a parsing step and less precision. The demands of the current web makes the DOM perhaps the most optimized API ever written. * Familiarity with Lint tools. The major ones are JSLint, JSHint, JSCS, and ESLint. ESLint is about to become the most popular and its rules are completely plug and play. JSHint is currently the most popular and used in many projects. JSLint is the original JavaScript linter and most strict. If you code passes JSLint it will pass JSHint. Most people find JSLint to be too opinionated *(strict)*. JSCS is a vanity linter that evaluates code against a large variety of style rules. * A favorite beautifier. The king is js-beautify and uglify2 is also very popular. From looking at historical traffic on NPM my [prettydiff](https://www.npmjs.com/package/prettydiff) tool and [esformatter](https://www.npmjs.com/package/esformatter) may be taking marketshare. Native methods I use all the damn time: String: * indexOf * slice * toLowerCase * replace Array: * slice * splice * pop * push * join
&gt; The functionality of it, or the naming? Using function scope instead of block scope. Back then, he felt that function scope was good enough for those small "punch the monkey" scripts. But things are a bit different if you use the language more seriously and try to write actual applications in it. &gt; Cause i still find using `let` a very shitty name for defining variables (cause lets face it, `var` is way easier to read than `let` on what it actually does. Breaking existing code wasn't an option. They had to use a different keyword for this. &gt; Let means nothing to me. Let there be light. Let x be 5. It's kinda like that.
Cool. Thanks. Now this is becoming part of my babel preset. https://github.com/gajus/babel-plugin-transform-strong-mode
maybe not the case lately in chrome, here's a super simple example i just ran to check. it is still slower in firefox though. I'm pretty sure it's just a case of things not being fully optimized yet. http://jsperf.com/const-vs-let-vs-var
I understand that they needed a new keyword, but i still find `let` to be very shitty with it. Another benefit from var is that i can type it with a single hand. But the let x be y seems mediocre at best. Its just as generic as if they would have used `thing a = 5`
"Let" is used by a bunch of other languages. Scheme, Rust, F#, etc. They could have copied Perl's "my", but I'm not sure if that would have been any better.
Hello. Thank you for such big answer! So, I really dont want a SPA. I don't see how could I use react on multi page app, it's always rendering everything, and I would need to put a lot of ugly ifs to check the url, thats why I would need to us r react router, and its not an out of the box feature, so I don't know why you tell that react is perfect choice for multi page app. Also, I don't know how could I pass a data in a thymeleaf way to react, without making additional calls;) data is passed on the backend side, so if I will put thymeleaf into my react components it just won't work. App logic will be on the backend side. Its my private project, for m own use so I dont have a ui developer;)
HOC for Higher Order Component. Here's a small [snippet](https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775).
You shouldnt be using javascript at all. Render all the HTML with java templates and send static HTML and CSS to the client. If you want to finish the project even faster, just use Wordpress (PHP).
Right, with the normal limitations that once you have a `with` statement or a direct `eval` you can't do any of this. So it's only in scopes which contain them that `const` has any actual difference to the VM, really.
Keyword `let` is much older than `var`. Language BASIC used it. Keyword `const` is also very old. It is used in C/C++ for example. Although it behaves more like Java's `final` than C's `const`. Also notice that `var`'s hoisting exotic behavior is exclusive to JS. Any programmer coming to JS from any other language is caught by surprise &amp; suffers to learn about it!
&gt;Also, "fixing" incompatible type arithmetic without breaking the internet is not low hanging fruit by any means. Did strict mode break the internet? We already have a solution to this problem that prevents breakage to old code. Moreover, I think you'll have a hard time finding code that relies on the feature of implicitly casting irrelevant types to strings.
I guess that makes sense.
The design of this website could use some serious UX love
First of all with is not even available any more in strict mode and eval is severly restricted. I'm pretty sure javascript engines don't actually optimoze anything with const currently.
This is a decent resource if you're curious about the basics of TDZ problems. Babel docs used to be fairly open about not being able to deal with all cases of let/const and the optimization issues for non-basic cases (I think traceur makes note too). http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/
The TDZ is an answer looking for a problem (and the idea of a TDZ in the JS world isn't the usual way of handling block scoping). It "fixes" the "problem" by creating a bunch of additional problems. Originally, `const` was supposed to be the only additional variable type and was supposed to work the same way as `var`. This raised a theoretical problem because the `const` would be hoisted meaning that if a stupid programmer tried to access the const before defining it, they would get `undefined`, but accessing after definition would usually give another value. This would make the constant theoretically not constant (though it would be easy and fast for JITs to implement). The TDZ concept was tacked on everywhere to solve this "problem" for the programmer at the expense of complexity and unoptimizable cases. In their opinion, once you've added huge amounts of TDZ stuff across the spec, there's no reason not to add a mutable block-scoped variable too.
Lisp proves that "block scoping" isn't needed for large programs. Let blocks (which compile down to self-executing lambdas) make block scoping unnecessary. 
Directive prologues can solve some aspects of technical problem, but the idea of having two very different languages switched with a directive prologue (or, `&lt;script type="atsepkov"&gt;`?) creates many other problems that doesn't make it low hanging fruit. Now libraries have to say what mode they must be run in, users can't copy/paste snippets of code from Stack Overflow without making sure they read what mode to use it in, tooling has to worry about preserving modes when doing script concatenation, inlining, and other transformations, and more. No more modes other than strict are coming, in favor of 1JS. See also [Axel Rauschmayer's blog](http://www.2ality.com/2014/12/one-javascript.html) for more info. See also Python 2 --&gt; Python 3. &gt; Moreover, I think you'll have a hard time finding code that relies on the feature of implicitly casting irrelevant types to strings. It exists and is quite common as far as JS feature dependence goes. Eg. there is a very common convention of using `""+foo` to convert foo to a string.
If I may make a meta-comment: I see this sentiment all the time. A lot of people are working in the field (be it JavaScript or any other programming community), and do not have a mentor, and feel like they do not have competency. So clearly, this concern is something a lot of people share, and finding a good way forward is important for the community as a whole. What strikes me about many such questions is that people say they are a “beginner,” but go on to describe *professional* problems. For example, “I am a JS beginner, and I’m having trouble deciding whether to use Gulp, Grunt, Broccoli, Webpack on this project at work.” Your question is a good example of that: You are building a rather large app for an established organization, so you are clearly a professional. But you also describe issues with understanding JavaScript as well as issues being competent within the profession. The word “beginner” is a little ambiguous. There are students, and there are inexperienced professionals. A student applies themselves to a field of study, whereas a professional applies a field of study to solving problems. The needs of a student are to progress towards mastery. The needs of a professional are to be competent and to manage risk. Sometimes, both needs can be satisfied with the same advice. Sometimes, they are in tension. If you attempt to learn-on-the-job, you are going to hobble your mastery. This is true of almost any job. One of the most important ways to learn something it to experiment with it. You cannot treat a professional project--where people’s livelihoods are on the line--as a playground for experimentation and learning. That goes against managing risk. In our industry, we typically handle this dichotomy by first being students, where we focus on learning and aren't as worried about the practicality, then we focus on gaining experience. Some university programs have coöp programs, where the students alternate between being students and being apprentices. But not at the same time! They understand that if you try to learn basic programming from a profesional project, both will suffer. ### driving the bus If you constantly learn just what you need to do the job, and only work within the pragmatic confines of the practices that seem productive and are low risk, you will make progress, but at the expense of understanding. This is like learning to drive a bus, but being ignorant of how engines, drive trains and traffic flow work. Which is not a bad thing, provided you have little interest in anything except driving the bus. For example, if you are a pastor in a church, you apply your enthusiasm to your church. The church bus is just a tool for doing church things, and you are not that interested in whether the engine can be tuned to get better mileage. Whereas, if you wake up and decide that you are in the bus business, driving a flock to a church outing is just the way you pay for the bus. you are extremely interested in gas mileage, not just as a cost saving, but because you are interested in buses and how they can be made better. A lot of the things a “bus person” learns about buses don’t apply to the church. It rarely makes sense for a church person to spend a lot of time thinking about buses. But the bus person learns things that apply to a lot of different people who need to be moved from one place to another. ### back to the question at hand So back to the question, and to everyone asking a similar question. My advice is to decide whether you are a student who happens to work for a living, or an inexperienced professional who needs to learn. If you are a student who happens to have a job, I recommend that you consciously apply yourself to studying JavaScript outside of whatever needs to be done at work. You need the freedom to do things like play with libraries and frameworks that might not become the #1 or #2 way of doing things. Whereas, if you are an inexperienced professional who needs to learn, then focus your efforts on reading the way the wind is blowing: Your job, more-or-less, is to figure out what everyone seems to be doing, and copy it. That minimizes risk, while giving you experience. It sounds prosaic, but if you are inexperienced, that is perfectly normal. It’s a question of picking up the basics, of being able to ask a question and get lots of answers because you’re asking about something everyone is familiar with. Once you have more experience, you can explore a little outside of the mainstream, you will have the context to understand when a problem you’re solving has a unique requirement that is served by a unique approach. So... the summary is, **Decide whether you are a student, or inexperienced. If you’e a student, study on the side. If you’re inexperienced, choose a low-risk way to gain experience.** http://braythwayt.com/2016/01/03/advice-to-a-beginner.html
I thought arrow functions don't have arguments and have to pass them using spread attributes.
Seems they're about the same now, so that's good. I understand optimization is a process, but I feel like until that process is finished, there's no reason not to have it JIT compile to the faster way if the total time taken is lower than the current native step. Then, when the optimizer has gotten to the point where it's faster, just swap the native variant in for the transpiled variant. Ideally, we end up with no transpilation anyways. If there is transpilation, then it turns out JIT transpilation is fast! (I wouldn't be shocked if there were at least one thing better left to transpilation)
I agree with this a lot. Two IDE/editors that do this out of the box are [Webstorm](https://www.jetbrains.com/webstorm/) and [Visual Studio Code](https://code.visualstudio.com/). Also remember that the Chrome and Firefox dev tools have an editor built in (although not quite as robust as the editors I mentioned). 
Right. So not-function scope isn't needed because there is some other kind of not-function scope which could have been used instead.
Variable hoisting means that you can indeed access variables before they are declared in the code flow. The following code will log `undefined` because `a`is hoisted to the closure object, but is assigned to `undefined` as an intermediary value. function foo() { console.log(a);//=&gt; undefined var a = 5; } Without the TDZ, you could have something like this where a constant can be two possible values. function foo() { console.log(a);//=&gt; undefined const a = 5; console.log(a);//=&gt; 5 } With the TDZ, hoisting still occurs behind the scenes (that is, a slot in the closure object is created), but despite the variable being hoisted, it cannot be used before it's point of declaration.
Seems like a valid use case. There's a pretty steep performance penalty for Proxy but I can't imagine it matters for parsing command line args. Are you taking advantage of the deep object abilities of `_.has` and `_.get` for args? If not it would seem simpler to use a `target.hasOwnProperty(name)` check and a direct property access to `target[name]`. (I assume you don't need to guard against a command line option named `hasOwnProperty` :)
Yes, I understand that...sorry I simplified it myself for the sake of the question just giving the final value.
Okay, let's be clear: * A traditional web app relies (mostly, at least) on the normal request-response cycle returning pre-rendered HTML and (optionally) some JS to add additional features. Reddit works this way. * A SPA relies (mostly, at least), on delivering a "shell" of HTML and a large JS payload, which executes and fills it with an app written in JS that fetches additional data via AJAX and JSON which is rendered into HTML on the client. Gmail works this way. Both have multiple "pages" on the client, so saying you want a multi page app is somewhat unclear. On the other hand: * Full MV* frameworks are almost essential to making an SPA but are (usually) overkill for traditional web app. * Lighter JS libraries can be useful for making rich traditional webapps, but may not be enough for an SPA. So as for React and Angular: * React is "just" a way of rendering components. You could use React to do nothing more than make a fancy "next page" button, or a comment form, or whatever, and it'll work fine. But you'd almost need more libraries to build a full app with it, and you'd certainly want them. * Angular is a full MVC framework; you don't need anything else to write a full app, but it might be awkward to use it for anything less than that. &gt; So, I really dont want a SPA Fine; you probably don't want Angular. You could *use* React, but it's not needed. Depending on the scope of your ambitions, you don't even need *any* libraries (but you'd probably want jQuery at least...). What you should use depends on what you want to do. A contact form probably doesn't need anything other than a half dozen lines of JS to validate form input. A webmail client needs a lot more. (I mean, *I'd* use React for a project like this, but I really like React. But if all you want is a rich text editor in your admin interface, you don't need React (or any framework, really), and you certainly don't need Angular.) &gt; I don't see how could I use react on multi page app If you're talking about a traditional web app, just write whatever fancy React components you want, and include whichever ones are relevant for that page. There's literally nothing to solve; it all just works. &gt; it's always rendering everything, and I would need to put a lot of ugly ifs to check the url Umm...no? If you've got some nifty little comment widget written in React which should only show up on individual posts, then only send that JS to the client when an individual post is requested. The entire point of the traditional web app is all the logic lives on the sever, and the server knows what to send. I mean, yeah, if you need to check the URL then you should probably be using react-router, but if you need to check the URL you're doing something very weird indeed. Why would you be including JS code you don't want to run on requests to a URL that doesn't need it? &gt; Also, I don't know how could I pass a data in a thymeleaf way to react Again, this isn't making a lot of sense. If you're not writing an SPA, what data would you want to pass to React? Your logic is on the server, and the browser should be getting a bunch of pre-rendered HTML with (maybe) a couple placeholder divs where your React widgets will be rendered. (That being said: Just make Thymeleaf render out a `&lt;script&gt;PRELOAD=[...]&lt;/script&gt;` with all your data in it, and then you can access your data from React via the PRELOAD global variable. But again, if you actually need to pass a lot of data to React, you may need to rethink what you're doing, if for no other reason than React has no good tools to manage complex data; that's what Flux, Redux, Relay, Falcor, etc. are for.) &gt; I dont have a ui developer Ah, I misunderstood. But okay, I think you need to think about what sort of client-side functionality you need. You can make a barebones blog with zero JS at all, and it would certainly be easier. What does that not give you that you want? Once you have a list of what you need JS to do, you can figure out what libraries you need. I think you may find you need a lot less JS than you're imagining.
&gt; If you attempt to learn-on-the-job, you are going to hobble your mastery. I disagree with that sentiment. The industry is constantly changing, so there's no way you can learn a particular technology or framework in college then have it be applicable for years afterwards. New frameworks are constantly coming out, so everyone has to always be learning them. Almost all programmers get paid a flat salary, and most that I know work 50-70 hour weeks. So what exactly constitutes "outside of whatever needs to be done at work"? Hopefully your workplace has "20% time" to work on things that are not part of the regular burn down. There are always new ideas on the horizon, and new products being considered. I'd say, if there is some new cool technology, do a proof of concept about how it *could* be used at work - next thing you know you might be leading that project. All my employers have been grateful that I could learn on the job, and I've seen far more instances of an employer wanting everyone to "learn up" on a new technology than bringing in a consultant who is an "expert" at it (there rarely are such people if something is sufficiently new). So maybe @homoiconic just works are bigger, more stayed shops than I do, but for SMBs, I've never seen the world be as black and white as described above. (That being said, I have seen developers who advocate for using unproven technology X for a new project, just because they want to play around on a company dime, and this is not cool. Draw the line between PoC and product, test every solution that looks applicable, but pick the one with the lowest risk before green-lighting anything.)
You are correct, but they inherit them from their parent closure. Here's a contrived example to show what I mean. var add = function () { //the `arguments` in the arrow function are actually in the outer `add` function var doAdd = (n) =&gt; n + arguments[0] + arguments[1]; return doAdd(5); }; The `add` closure contains something like var hiddenAddClosure = { parentClosure: globalScope, this: getThis(), arguments: getArguments(), doAdd: doAddFunction }; And the `doAdd` closure contains something like var hiddenDoAddClosure = { parentClosure: hiddenAddClosure, n: someNumber }; When the `doAdd` function tries to access the `arguments` array (or `this`), it checks it's local closure object. If the variable isn't there, it checks it's parent closure and finds the value (note: if the value didn't exist there, it would check each parent until it hit the global closure at which point it would throw a reference error).
1. It's a common convention because someone suggested it as a faster way to typecast to string in current implementations of JS (https://jsperf.com/convert-to-string-bj/3). While I see your point and agree that we can't pull the rug from that now, I don't like this convention. To me it's no different than resetting the number to zero by XORing it with itself instead of assigning 0 to it (as was common in assembly days). Both `String()` and `toString()` are more readable and don't rely on a language quirk. 2. The operation you mention makes sense if foo is a primitive type. If foo is a hash, you'll simply get "[object Object]", probably not what the developer intended. Even if we leave primitives alone and apply the assertion only to objects, that would be useful in itself, in my opinion. Is it possible that some obscure code is relying on this feature? Sure. But even the article you linked explains the same issue with `let`. My gripes with JavaScript are mainly about its lax treatment of errors in code. An undetected error is much harder to debug when it causes unexpected behavior hundreds of lines of code later. Strict mode helped fix some of that, but not all. There won't be a panacea solution solving all cases, but that doesn't mean we shouldn't chip away at the problem when we get a chance.
I don't understand what your reply has to do with my comment. Of course you don't want to use const if a variable's value is meant to be mutable. My point was that even though you could just use var or let everywhere, const can be used as a way to communicate intent with readers of your code.
Apparently it has various meanings; I was using it in the sense from Scheme, as a function that takes no arguments and is used for lazy evaluation: http://c2.com/cgi/wiki?WhatIsaThunk
You code it... with html, css, and javascript. You can right click &gt; "View page source" with Chrome.
&gt; Even if we leave primitives alone and apply the assertion only to objects, that would be useful in itself, in my opinion. Usefulness aside, it is still very common to coerce objects to strings using this method. Consider arrays where it's a shorter way to do .join(). Consider objects with custom toString/valueOf methods. These usages are not obscure and are multiple orders of magnitude more common than the token sequence `let [` (I did the initial analysis on the prevalence of `let [` for TC39). Anyway, I agree with chipping away at the problem, my only purpose here is to point out that this area is not low hanging fruit but is in fact very hard to do.
&gt; I have great respect for your work and am really sorry if you feel insulted, that definitely wasn't my intention. Rather frustration by why things should be harder than they need to, and some irony. OK, got it. Irony is always a bit difficult in online communication. Same thing for the headline: you expect people who like Babel and webpack to help you, while (slightly) disparaging those projects. In general, I agree: it’s easy to feel overwhelmed by web technology, at the moment. Both webpack and Babel are powerful tools. Additionally Babel 6 is brand new, with a completely different way of configuration. It takes time to figure them out. Give yourself (and the tools) that time. Start as simple as possible, add more things when you feel you are ready. Initially, you will just copy and paste other people’s stuff, you should not expect to understand much. As you use the tools more, you’ll understand more.
IE might want you to declare the function as update: function(delta) {}, draw: function() {} I think the other browsers let you skip this syntax with "use strict." I could be wrong. 
I'd disagree with you again but then all of the downvoters above would kill me fatally to death. And that would have a very lasting permanence. So I won't. ;P
It's called "shorthand method syntax" and it's an ES6 thing that IE11 does not support.
Hmm, I didn't think about jade and gulp. Thanks
Sure, but ES6 isn't supported in browsers yet. In fact, this won't work in Safari either: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions
&gt; No, it's not. There is no one who would think that their code could need some more nesting. As it turns out, you seldom need extra scopes, so an explicit block when you actually do isn't a big deal and makes moving or copy/pasting the code far easier. &gt; And there is also no one who can't grasp that they can't interact with things which don't exist yet. Use before definition is an actual problem in JS because it hoists and because it's dynamic (especially when moving code). Try teaching that you can't actually trust `let` to catch these errors in all cases at compile time to people who are used to this not actually being an issue. &gt; C++ uses block scope. It has no problem being fast. Java and Dart are also very fast. The execution models for these languages are different than JS. Comparing execution models is pointless because the JS execution model cannot be significantly changed at this point. &gt; Also, JavaScript's semantics are a ball of nightmare fuel. You think this is even worth mentioning? It isn't. ES2015 was a chance to get things right rather than create even more edge cases. Using a let block would avoid creating more edge cases and would fit well in the existing JS paradigm. No disadvantages and a lot of advantages. What's not to love with that idea?
Hi /u/_sndy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
&gt; I'm just saying that my code is not wrong If the browser doesn't support it, then it's wrong for that browser. When you're using recent features in the spec and it doesn't work in a certain browser, you really only have yourself to blame. It's one thing if the spec is implemented incorrectly by the browser, but it's entirely different if you're choosing to code on the bleeding edge.
&gt; Use before definition is an actual problem in JS because it hoists and because it's dynamic (especially when moving code). Try teaching that you can't actually trust let to catch these errors in all cases at compile time to people who are used to this not actually being an issue. No, it's not a problem. If you try to use a variable before you've declared it, you'll get a squiggly line if you are using a decent editor. Same as with any other language. http://i.imgur.com/dFLoV9d.png If you editor is too shitty, use a better one.
@BoxOfSnoo, both JS' `const` &amp; Java's `final` affects the declared variable itself only. Whatever object it happens to refer to is unaffected by that. Remember that variables aren't objects but merely a fixed small number of bytes enough to convey a memory address value to point to an object. If we wish to make the object itself immutable in JS, we can invoke **Object.freeze()** over it. Below an example showing that `const` doesn't affect an object's mutability at all. Pay attention that we can also use `const` to declare a `for...of` loop's iterator: (function TestConst() { 'use strict'; const vals = new Float64Array([ Math.PI, Math.E ]); for (let i = 0; i !== vals.length; vals[i++] *= 2); for (const d of vals) console.info(d); } )(); And here's the corresponding Java example. Go to https://www.CompileJava.net/ in order to watch it in action: public class TestFinal { public final static void main(final String[] args) { final double[] vals = { Math.PI, Math.E }; for (int i = 0; i != vals.length; vals[i++] *= 2.0); for (final double d : vals) System.out.println(d); } } 
Thanks for your support. I've just published an overview of how it works here: https://medium.com/@endel/colyseus-minimalistic-mmo-game-server-for-node-js-a29fe1cebbfe
Here are my most common tools. Mocha, commonjs, webpack, chai, angular, node, mysql (or postgres), nginx, karma, and gulp (or npm scripts). That uses modular frontend loader (for speed), front/back testing, a single module system, a single style of test writing. I also use typescript because refactoring and code completion is awesome. 
I'm gonna say Array methods reduce, map, and filter are amongst the most important. Especially if you're dealing with any sort of JSON data . There are now very, very few times I use a for loop. 
TDZ = Temporal Dead Zone https://developer.Mozilla.org/en-US/docs/Archive/Web/Scope_Cheatsheet#Hoisting
&gt; Actually I was being sarcastic, proposing a solution that is unrelated but nevertheless desired in one way or another. Weeeeell, it's not actually unrelated. A language can either define what those operators in general do (e.g. Java) or each type can define what those operators mean for them (e.g. Dart). For example, in Dart, when you write "1 &lt;&lt; 12", you call 1's "&lt;&lt;" operator method with an `int` as argument. And the result of that will be another `int`, because its signature looks like this: int operator &lt;&lt;(int shiftAmount) So, if you do some nonsense like subtracting a string from a number, you get an error, because that particular '-' operator expected a `num`: 5 - 'foo' -&gt; The argument type 'String' cannot be assigned to the parameter type 'num' And if you do it the other way around: 'foo' - 5 -&gt; The operator '-' is not defined for the class 'String'
&gt; Also, i find let to be a terrible name to define variables with. Let doesn't mean anything to me. Its not self explanatory like var, for, if, etc. Actually let reads just fine. You are just too mired in the minutia of programming. You can't see the forest through the trees. var theMeaningOfLife = 47 let theMeaningOfLife = 47 "variable the meaning of life equals 47" "let the meaning of life equal 47"
I disagree, most variables initialized in your application shouldn't change. Only a few elements will be mutated, the rest stay constant. This isn't a foreign concept as we can see with the various Functional Programming elements being brought into JavaScript libraries and Frameworks. Just take a look at [Lee Byron's talk on Immutability](https://www.youtube.com/watch?v=I7IdS-PbEgI).
If the threshold for significant in this comparison is met by two letters, then it must be enough to also include the "negligible" use cases of `const`. Is he right about object properties? Absolutely. Is making everything _besides_ object properties immutable more significant than two characters? Absolutely.
It's certainly valid, though I feel proxies in general are pretty heavy in the majority of cases. It doesn't quite accomplish the same thing, but I'd probably instead go the route of named exports, then rely on linting tools to detect incorrect config usage, e.g. export const { 'disable-cache': cacheDisabled, // One for each config param. } = argv; then explicitly import {cacheDisabled} from './config'; Then moving forward, if you use an IDE for instance, it could verify that you are importing a config param that doesn't exist. Obviously this doesn't work in the general case for all objects though.
The idea of functional vs OOP has been a hot topic in JavaScript recently, so let me offer my two cents. Let me start by saying: Everything advocated for in this article are good things. Avoiding side-effects is a good thing. Declaring your dependencies as formal parameters is a good thing. Preferring pure functions is a good thing. That being said, I'm generally unimpressed by the functional "movement" because none of these are new ideas. These have all been best practices even in the OOP world for decades. But I do have one criticism I want to mention. At the end of the article, it links to a "part two," and there it calls out "this" for being non-functional because it's "magical" and because "how freely its meaning changes." But believe it or not, "this" is just a parameter, and its meaning can change from one invocation to the next just like any parameter's meaning can change from one invocation to the next. Consider, for example: function f(context) { return context.name; } var o1 = { name: 'James' }; var o2 = { name: 'John' }; var o3 = { name: 'Jane' }; f(o1); // returns 'James' f(o2); // returns 'John' f(o3); // returns 'Jane' Nothing magical here. I pass one of any number of possible arguments, and that argument is assigned to a parameter named "context". But what if that first parameter was automatically always there without me having to type it out? And what if instead of being named "context", it was named "this"? function f(/* first parameter is implicit and named "this" */) { return this.name; } var o1 = { name: 'James' }; var o2 = { name: 'John' }; var o3 = { name: 'Jane' }; f.call(o1); // returns 'James' f.call(o2); // returns 'John' f.call(o3); // returns 'Jane' And, of course, the "object.function()" calling syntax is just sugar for "function.call(object)". That is, "object.function()" implicitly passes "object" as the first argument, which then gets assigned to the implicit first parameter, "this". I hope that takes some of the magic out of "this". It's just a parameter, albeit an implicit one.
Benefit: others wil know not to assign to that identifier.
The language used in this article is irrelevant. What matters is the exploration of the Functional Style of Programming that can (and should) be applied to any programming language (unless it's forbidden by design). This is what the author says about his article and the motivation to write it: ***"This post comes out of a couple of discussions about the nature of functional programming. Particularly a chat with Sleepyfox discussing whether JavaScript could be considered a functional programming language, with the right libraries. My answer was an instinctive no, but thinking through why lead me along a very fruitful chain of thought."*** Regards, Harris
For very small examples this is true, but try dealing with error propagation and handling. Promises, Observables, and Async/Await deal with this very nicely and naturally. Callbacks do not.
You may consider them best practice but they certainly aren't encouraged by popular web frameworks for oop languages like rails and django.
That still doesn't require React or Angular. In fact, they would just make it more complicated to use a rich text editor widget.
I can understand that (and didn't know it at first) but still the word is not something to notice. There aren't a lot of words you use in programming that start with a v-. Plus the L is terrible to read. Is it a lowercase i? Is it a uppercase i? Is it a lowercase L or just a vertical line |. Many fonts won't display it clearly. But anyways, still hat the LET, but i won't need to get used to it for a few years anyways
Thanks. I see how how dependency injection works. Could you layout a very, very barebones app structure for how you would create modules for something like a todo list or contacts app? 
Yeah, should have used something else than 'web components'. Maybe just 'thinking in components'. 
Callbacks were around for the longest, followed closely by promises (also called "Deferred" by some libraries). These two you'll see around the most often, with callbacks being a little bit more popular when you talk to native browser or node APIs. I'd say the most popular overall would have to be promises. They make no assumptions about your toolchain or libraries (like async/await and Rx do) and can be implemented in a variety of ways across a variety of libraries, so long as it follows a basic contract. They're also so much better for handling errors than callbacks are. The "best" is always going to be a point of contention. C# has had async/await for a while but still had the reactive extensions pop up for it to explore alternative scenarios where async/await wasn't the most convenient or intuitive to use.
Why is this downvoted? Was something else meant by "arrow functions don't have arguments"?
I used to use knockout since it was just so dang simple. Especially when angular was really big. It felt like the simple yin to angular's complicated yang. However, I was really attracted to the ideas of react -- in particular components. Unfortunately for knockout, components in knockout are somewhere between tedious and impossible, depending on how you define them. The first-class support for *only* AMD doesn't help things, either. I didn't like how tied to classes for even simple components react was, so I ended up with [mithril](http://mithril.js.org/), which I feel has the simplicity I loved with knockout with modern design sensibilities. Components are trivial, code reuse is easy as can be, and you can learn the entire mithril API in an afternoon. 
Checking source codes of open source projects on Github is generally very good for learning. This repo may be interesting for you. https://github.com/tastejs/todomvc/tree/gh-pages/examples/vanillajs Note that this is a no-library implementation of todomvc app. You can find other implementations as well at http://todomvc.com/ TodoMVC is a simple app that is used to demonstrate how to implement MVC design pattern with different libraries. It is a fairly simple app, i would say that a larger app would need more structuring for modules. You may end up having modules providing complete features such as contacts module; or handling certain parts of a single page app such as floating header etc. 
&gt; For some people functional programming is better defined as Higher-order Functions. I've yet to understand the craze over higher-order functions. Even the "lowly" C language can pass a function pointer as an argument, or return one from a function, or assign one to a variable. Why do functional proponents act like this is some awesome new thing that will change your life?
Angular in general feels more in sync with Web Components while React had a similar idea but took their own approach. 
I've even seen people go so far as to describe angular as a separate language. I've seen more than my fair share of places that wanted knowledge with angular above knowledge with javascript. I agreed with the author entirely when he was talking about knowledge application; a lot of knowledge in angular simply just doesn't apply anywhere else, particularly when you get deep down and nitty gritty with the directive API. (and the awful `$scope` nonsense). 
You could even wrap this in a function and disable it in production: function protect(target, enabled=true) { if(!enabled) return target; return new Proxy(target, { get(target, key, receiver) { if(!target.hasOwnProperty(key)) { throw new Error(`Key "${key}" does not exist on protected object`); } return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { if(!target.hasOwnProperty(key)) { throw new Error(`Key "${key}" does not exist on protected object`); } return Reflect.set(target, key, value, receiver); } }); }
I'd say the best part of the article is him defining React as Unix-like in its philosophy. It being a compose-able library will be its biggest strength in the long run, IMO. He notes the huge churn in the React ecosystem currently, and that can be overwhelming, but that is a side-effect of the fact that it is a new, hyper-popular library and unlocking its true potential can only be found when pairing it with *other* libraries, just like Unix tools.
Good article thanks
I don't know, when it comes to Directives versus Components, I don't see what's preventing you from using Directives in a functional manner only. I've certainly used directives in the way you're describing. I know people kind of looked at me weird when I was using directives to handle things like view logic (though eventually I replaced with UI Router states), but it just made sense. Angular 1 always felt like a full version of Polymer, and Polymer felt like a Web Components demo to me. 
Because the way this seems to the ES5 syntax, it is as if you are doing something of a hybrid IIFE/function call...thing, with omitting the function part. That is why it expected a ":", you know, a name: property pair, not invoked functions within an object. (Also, the way you phrased "it is up to spec", I have to say that you got it backwards: it is mostly better to not write up to spec code when the compatibility is not around 98% or more. Unless you use babel and transpile it down to ES5 anyway. 
And then there's Cycle &amp; Yolk... both of which are awesome and well worth checking out if you like streams and data binding.
You need to keep track of the current slide. Best way is probably to add an 'active' class to the &lt;li&gt; youre currently on. If you are starting at the first one by default, then as soon as your javascript is initialized, addClass('active') to the first li.. ie $('li:first','div.slider').addClass('active')
I think his point was more to contrast the single purpose of react against the huge API of angular. In much the same way you can build up complicated UIs by composing small, single-purpose, well-defined components, and that you can build up functional applications by composing small, single-purpose, well-defined functions, you can build up the API that you need by composing small, single-purposed, well-defined APIs/services. It's easier to unit test and know these smaller pieces to be correct rather than an API with a huge surface area. Something as large as angular tends to attract "the angular way" as well, which can be dreadful when it includes things like `$scope`.
I'll second this, but at the cost of a few strings. Mithril is an order of magnitude easier to learn than react/flux/redux/whatever, but it also has an order of magnitude smaller (at least) of a community and environment. This means a lot less tutorials, a lot less blogs talking about how to do this and that, a lot less everything. This can especially bite you if you run up into some of the edge parts of the framework. An example that comes to mind with me when using mithril was having a textbox as part of a larger chat UI. It was surprisingly hard to find anything at all to get this dumb textbox to not cause tons of redraws as you type into it - which can be a huge problem if you have e.g a markdown-parsed backscroll with hundreds of messages in it. It turned out that the auto redraw system was causing redraws to occur with every event I attached to the textbox! I had to go through my textbox code and insert a bunch of mithril-specific "stop doing that" to get it to behave. There's things like this in every framework, but it's a lot harder to deal with this stuff in serious larger projects without a larger community to support. On the flip side, mithril is a fantastically simple API that you can learn in an afternoon or two and if you compare directly to angular 2.0 (or almost any other framework, including classful react) it blows it clear out of the water. Lot of the times my components can just be one exported arrow function, since the entire component can be expressed with just one expression. There's something fantastically zenful about it all combined with component-scoped css. 
I started with React mid last year after twiddling my thumbs waiting for Angular 2 to arrive. I don't think I'll be switching over in a hurry when it does come out. The article nails my reasons better than I could articulate - with web UIs, JavaScript and HTML become extremely closely linked and when this happens, you want JavaScript manning the helm, not HTML. After I got over my initial reservations and embraced JSX, the notion of embedding a custom scripting language inside HTML template strings just seems so bizarre and backwards.
Memorize nothing. That's why there are reference materials Ignore patterns as well. At one time there were 12 or so, I think, and they were recognized as being general suggestions. Now there are patterns for everything, which tells me people are writing software and analysing it for patterns. You can do that. Learn a few, 2 or so, you can name in an interview and whip together on a whiteboard. And assume any employer who wants you to have a massive number of patterns memorized is an idiot who favors memorization over software that works. Write software that works.
Could I be hired as a senior front-end dev on a React project with only Angular experience, do you think?
Did you try asking about your issue in the mithril gitter chat? It's pretty active there and there's a lot of friendly people there who can help you get unstuck.
&gt; In React, you don’t learn framework-specific HTML shims like ngWhatever. You spend your time writing plain ‘ol JavaScript. That’s the future I believe in. Because React doesn't have an API to learn? Jesus christ I hope people are smart enough to read through the bullshit. It's an interesting article that tries to not blatantly take a side but the author needs to step down off the hyperboles.
Not a senior, likely. But it shouldn't take you long to brush up on a new framework either.
Say we have a header component for a panel. The main thing that this component does is it displays some text in bigger font in a way that is standard for our website. However, headers might have some icons to the right of them which might do any number of things, or they might have some icons to the left, or maybe some explaining text underneath in a subtle way. These are all common things, so we'd like to capture all of that and encapsulate it into a component for all of the goodness that offers. With knockout, you can get part of the way there. Getting a component that displays the text in a uniform way is trivial with the `params`. But we start running into problems with our two sets of icons in either place. Remember, if we click on our icons, it might launch a modal, or it might just be a link to another place. Theoretically, we could capture all of that possibility as arguments into the component. So we'd have a `left` argument and a `right` argument. The component will then read that as an array, pick apart if the icon is a toggle icon or a normal icon, if it's a link to another part of the site, or if it's an action or . . . &lt;!-- for the header !--&gt; &lt;template &gt; &lt;!-- I want my left part here ... but how ? --&gt; &lt;h3 data-bind="text: headerText()" /&gt; &lt;!-- I want my right part here ... but how ? -- &gt; &lt;/template&gt; Now, knockout components do let us actually pass in arbitrary HTML to it. So we could theoretically do something like... &lt;my-header params="headerText: 'Hello'"&gt; &lt;div class="toolbox"&gt; &lt;span class="fa fa-gears" data-bind="click: ..."&gt;options&lt;/span&gt; &lt;/div&gt; &lt;/my-header&gt; ... but how you use this template in `my-header` will drastically change how this works. That is to say, you have to pass the outer scope of the template in ko-template that does the `$componentTemplateNodes` otherwise you're stuck to data that only exists in that component. Plus, you can only do this trick once. Remember that we had icons to the left *and* right. We can only pass in one set of HTML, we have no way to distinguish what goes to the "left" or "right" part of that. This all ends up being just so much effort if you even manage to get it working right. Knockout works against you every step of the way if you want a truly reusable component. Compare this to an **entire** mithril example: export default { view: (_, {left, headerText, right}) =&gt; m('my-header', [ left, m('h3', headerText), right ]) } We can now use it like this: import Header from './header'; ... m(Header, { left: m('.toolbox', [ m('.fa.fa-gears', { onclick: () =&gt; ... }), m( ... ) ]), right: m('.toolbox', [ m('.fa.fa-gears', { onclick: () =&gt; ... }), m( ... ) ]), headerText: 'Hello' }) ... Nice. We can pass in pretty much anything we want here, and the header component doesn't need to care at all. In fact, we don't even need to pass in anything at all. It's so trivial to make this component more reusable by adding in another hook, you end up using it more, which makes your app a lot more consistent. If we need to suddenly have something that isn't an icon in the left or right position, no problem. The component is totally agnostic, so we could put text in there, or ... really whatever: m(Header, { left: m('.cool-text', 'this is to the left of the header!'), headerText: 'Hello' }) I hope this helps to explain the difference. It's actually a pretty large philosophical one, since we lose the HTML and everything with it. React and riot and others are a little different, but this is all how they handle components in general. 
So you may have missed the part where Google is actually using angular 2 in production currently. And has more projects coming that use it. Regardless, neither company is betting the farm on their respective framework. They're just providing new options for others. Also, I don't see how Facebook would fail if react didn't take off. Would my grandma stop using the site? No. My wife wouldn't care either. They'd continue to use or not use it and nobody would notice.
I predict the winner of Angular vs React will be Web Components :)
What about CSS, where we decided such artificial constraint was actually beneficial to keeping HTML clean?
I think they're somewhat orthogonal issues. With Angular, there's nothing stopping you from using ui-router or restangular, if you don't like the out-of-box options, for example. There was a post a while back on HN about how some people had bad experiences w/ React router breaking its API willy nilly between releases, and in that case, finding an alternative is definitely a point that feeds into the js fatigue issue. WRT the issue of API size, well, I've got nothing to say in defense of Angular :)
There's a way to define react components as just functions that would be called for view which makes building some components super-simple
To be fair though we never kept HTML and the programming language separate. All the templating languages invented their own programming language (loops, components, etc.), and most did the language so poorly that we even had templating languages being advertised as having few features (eg mustache/handlebars). JSX feels like the least-worst. It does tags, and it only has a few quirks (className, htmlFor, key).
+1 for wordpress. I used to build my own websites, and despite giving me a sense of satisfaction they'd always take more time and look crappier than a generic wordpress template that takes a few minutes to setup and a couple days to fully customize. You can't get productivity like that when building it yourself. I've built my last 4 websites using wordpress (http://investomation.com, http://rapydscript.com, http://rakutenrewards.com, http://blog.pyjeon.com). If you're simply building a blog, 9 times out of 10 you'll be better off with wordpress. You can even install a plugin to plug your own JavaScript in for any fancy effects you wish. The RapydScript website, for example, has a JavaScript-based online compiler shell.
I haven't, actually. I'll try that next time!
Sure, stateless functional components are easy but beyond them, there's also the fact that what you're using is abstracted in the Virtual DOM, along with the hoops you have to jump through with the component lifecycle. If it's just javascript it'd be just doing `innerHTML` + template strings.
 function sum() { var res = 0; for(var i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res; } console.log(sum(1, 2, 3)); // 6 It's about the magical array-like `arguments` object. Arrow functions don't have those. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments In ES6, you can use rest parameters for this kind of thing: function sum(...values) { return values.reduce((a, b) =&gt; a + b, 0); } console.log(sum(1, 2, 3)); // 6 Using an arrow function: let sum = (...values) =&gt; values.reduce((a, b) =&gt; a + b, 0); console.log(sum(1, 2, 3)); // 6 https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters [CC /u/acoard]
[**@gdi2290**](https://twitter.com/gdi2290): &gt;[2016-01-04 02:04:18 UTC](https://twitter.com/gdi2290/status/683831288147480577) &gt;[#GoogleTrends](https://twitter.com/search?q=%23GoogleTrends): [#ReactJS](https://twitter.com/search?q=%23ReactJS) vs [#EmberJS](https://twitter.com/search?q=%23EmberJS) vs [#Angular2](https://twitter.com/search?q=%23Angular2) \(not AngularJS\) vs [#Aurelia](https://twitter.com/search?q=%23Aurelia) vs [#Polymer](https://twitter.com/search?q=%23Polymer) &gt;[*google.com*](https://www.google.com/trends/explore#q=reactjs%2Breact.js-jsx,%20emberjs%2Bember.js%20%2B%20ember2%2Bember%20js%202%2Bember%202.0,%20angular2%2Bangularjs%202%2Bangular%20js%202%2Bangularjs%202.0%20-angular%20acceleration%20-angular%20velocity%20-angular%20speed%20-angular%20momentum-angular%20displacement-angular%20frequency-angular%20momentum%202-web%20api%202,%20Aureliajs%2BAurelia.js,%20polymer.js%2Bpolymerjs&amp;cmpt=q&amp;tz=Etc/GMT%2B8) [*pic.twitter.com*](http://pbs.twimg.com/media/CX107t2UkAEvwir.jpg) [^[Imgur]](http://i.imgur.com/qndPtHg.jpg) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3zcqez%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Yes, `var` is gone in strong mode. 'use strong'; var foo = 'bar'; -&gt; Uncaught SyntaxError: In strong mode, 'var' is deprecated, use 'let' or 'const' instead By the way, they didn't just propose it. They also started implementing it in V8 and Traceur. It's not enabled by default though.
Google had plenty of projects that used GWT as well, but we see how well that worked out.
I'm a long time Angular 1.x developer, currently learning 2, but Ive got to say, React is looking better to me every day! The argument that I've seen many people make, that Facebook is actively dogfooding React in a way that Google just don't with Angular (I know they *use* it, but not for anything critical) is seriously starting to sway me. I have a new side project coming up, going to start out on it with React and see how I go!
&gt; Their tagline states "No callbacks or promises" As if not using promises would be a good thing. You can `await` promises, which is exactly the kind of thing they are emulating with that `yield` hack.
It's really hard to argue after angular that keeping the JS and HTML separate was keeping either very clean. Moreover, it's apples-to-oranges. HTML **is not** a templating language. It's a document layout language. When we use it for templating we add a bunch of stuff it was never designed to do. CSS is specifically designed for styles.
Assuming you're talking about moving from being a Senior at an Angular shop to being a Senior at a React shop, absolutely. It's probably less likely to make the leap from Junior -&gt; Senior switching companies who use different technologies, but it's definitely not impossible. It's a developer's market and has been for a while. My experience hiring at a number of different companies over the years has been that limiting yourself to people with the right skill level in the same tools you use means you ignore better options. You want a good developer with a reasonable output who fits in well with your team. The rest is icing. It shouldn't take a seasoned Senior dev a ton of time to become acceptably proficient in a completely new language, let alone a framework in the same language they're used to. And the reality is, if you're a shop that uses Framework A and you hire a guy who's used Framework A, you'll still have to make him familiar with your coding style, preference for third party libraries, tooling, et cetera. Consider how wide that margin can be right now in the frontend world. You want to minimize your time from hire date to actively contributing, but you can't make that number be 0. Even at places where it's their stated goal to make people contribute in the first week, they aren't making the same kind of impact they're going to be a month into the job. So, TLDR version... sure. But it'll depend on the company.
The "no promises" point is about not having to use the Promise API (eg. call .then, .catch, etc.). Promises are still used but are handled by `yield` and some library code (co). The semantics are similar to async functions.
You hit right on what's gotten me interested again in Angular 2. I spent years with Angular 1, and after the initial announcement video for 2, I jumped ship for React. I pretty much lost my shit like a three year old at the toy store over the syntax and different-for-the-sake-of-being-different choices like TypeScript, RxJS, extensive use of decorators, et cetera. I ended up picking up ng-book 2 and running through it and a few tutorials online just to give it a proper shake, and I was surprised at how many seemingly asinine decisions were actually well thought out and purposeful. The template syntax is actually the one place that makes me really prefer Angular 2 to React. The code is definitely Angular, but the simplicity of things like ngIf compared to using a ternary expression make me feel like I end up with better readability, and a better control over deciding where to split my components. I'm interested to see where it goes.
On my iPad or I'd link to a codepen of it. But a neat way imo is to keep track within two global variables of the slider length and the current index and increment the index on click. 
Google does use Angular in production, but no where close to the extent at which Facebook uses React in production - which was his point in the first place.
If you wouldn't mind i was also have trouble with the "whatever" function at the top of the JS. i was trying to hide the display so that i could put in shops and whatnot. 
Misleading is probably too harsh of a word. The statement just sounds wrong to me -- especially since their github embraces the use of promises as the very first feature. &gt; Based on Promises, which means no callbacks I suppose this doesn't really have anything to do with the original question, though.
Off the top of my head: First: It's under active development and in a high state of, if you'll pardon the expression, flux. Libraries, APIs, best practices are evolving quickly; feels like every Monday morning I start work by figuring out what's changed with the ecosystem since Friday. I mean, the good news is that we went from reflux to redux in ~6 months (a huge advance in my view), the bad news is that we went from reflux to redux in ~6 months. :) In addition, React+Redux solves a lot of pain points, but some areas are not well solved, such as: * Data fetching. There's Relay, Falcor, and at least a dozen different helper libraries like react-fetcher, react-resolver, react-refetcher, react-transmit, react-nexus, redux-solver, and probably three more since yesterday. * Styling. I threw up my hands and just stuck with webpack and CSS modules, but there's a ton of projects and libraries trying to do to CSS what JSX did to HTML. * Come to that, JSX is a solid solution and fine for the programmer types but...there's a lot of artist/designer types out there who are happiest in photoshop and can hack their way around some HTML and CSS when needed who aren't going to be productive trying to work with JSX. I think JSX is a big improvement over the Backbone or Angular 1.x style of doing things, but I'm not sold that it's the final evolutionary step. 
Learn node + gulp + react + jest + a router + browserify + node inspector + flux. Now you're getting started with react. You really trying to say there's a low learning curve ? 
&gt; Learn node + gulp + react + jest + a router + browserify + node inspector + flux. Now you're getting started with react. Grab boilerplate with working webpack config; start learning react, the end. You do **NOT** need to know node or a node inspector (wtf?) ever, you don't need to know gulp+browserify (or webpack) to get started, you don't need to know any testing framework to get started (and I wouldn't suggest Jest ever), and you don't need a router or flux library to get started. That's complete nonsense.
Now that you understand the basics I would recommend a good book. For example Javascript: The definitive guide by David Flanagan. Be warned though, its's a very content heavy book that goes into extreme depth on the language. Before you get that book or another I would go though the codecademy course and then build a few projects yourself (todo list, calculator). So atleast you will have a easier time when you learn more advanced concepts. Also if you don't want a book, mozilla developer network is the best online recourse https://developer.mozilla.org/en-US/
Thank you for the recommendations! I will definitely look into that! :)
Am just after the numbers, I implore you not to start a discussion about why either choice is superior or whatever. Just vote, share or ignore it.
Really? My instructor at my community college told us that HTML and CSS are scripting languages. Now I'm confused. He also told us that they are markup languages as well. Which is it? Would a scripting language just be the type of language and a markup language be the subtype of the scripting language? Or what is a "scripting language" exactly? I know a "markup language" is just formatting. I feel one could argue that JavaScript is a scripting language (in the name), while another could argue that it's a programming language based on its syntax. It sure does feel like a programming language though if it is. Regardless of what type of language(s) HTML, CSS, and JS are, they are very good skills to learn! And thank you! I actually just bought a raspberry pi a few minutes ago. Now I have a project to work on! :) I already have a few ideas for my first project :) It's really cool being able to program! :) I like that feeling of understanding something that not everyone would understand. I have about two friends out of a group of 20 friends that can actually understand programming while the others are like, "uhh, wut?". (Keep in mind I had that mentality, so I can't talk). I just love that "Ah ha!" moment that HTML or CSS never gave me; it feels amazing! I hope to spread the love of JS and programming in general! :) I recommend to anybody wanting a challenge! :) 
You are right, people seem to take it too personally unfortunately :( Still can't make my global `.babelrc` work instead of the extra settings in `package.json`. This looks like it belongs to the global setup, rather than to be included in every single project every time. Any idea if that is possible?
What about Aurelia?
Are you choosing a religion or a framework? You can actually use both for different things. Or both in the same thing! Or just your favorite, even if the project would be better suited with the other? It took me less than a week to get the gist of angular 2. Certainly worth knowing at least. I also plan on learning react, when I can.
you can't just say those things "failed" because they didn't become the de-facto standard, or win a mythical framework war. they opened their code to the community, it must have been worthwhile for them in some way... since they literally built their business on that code. 
I use jss, which dynamically adds stylesheets to the page containing json-defined styles applied modularly at the component level. All the benefits of dynamic styles, but with none of the restrictions that inline styles require (no way to style pseudo-selectors, or children, or css animations). https://github.com/jsstyles/react-jss
You do need them if you want to render to a browser, to say nothing of the complexities added to render server-side, too. React is great - I use it every day - but to describe it as something to use it in isolation is entirely disingenuous. IMO, Its greatest strength is that it does _one thing well_ - but you have to have supporting libraries in order to actually _do_ something with it.
So Angular?
If you want to update Widget from App, App would need to take a param to represent whatever it is you're passing in, which would be passed where the IIFE calls itself. It may look something like this: var App = (function(wiget){ ... wiget.update(); ... })(Wiget); Also you may have to switch the order in which the modules are declared in (in this case place Wiget up at the top). The following code works: var Thing = (function() { function log() { console.log('it works!'); } return { loger: log }; })(); var App = (function(something) { return something.loger(); // it works! })(Thing); But it would break would App come before Thing.
Most large companies are involved in patent wars, its been going on since the mid 90's. It's sort of a cold war in that each large company collects patents then threatens each other with violating its patents unless they too agree to not contest each others patents. It's a very large stale mate. Angular and React, if you adopt, ensures neither google or facebook can be subject to patent infringement by your company. Nor can you be subject to their patent infringement (so long as you don't try and ever sue them[1]) [1] https://github.com/facebook/react/blob/master/PATENTS
Please give us the name of your instructor, where he works and his email, so I can tell him to stop spreading miss information.....thats just nuts!!! No conditionals, no programming/scripting/samething language. Oh, and it makes my heart warm hearing how much your enjoying js :) And while Im here.... The difference between a scripting language and a programming language in the way I think your thinking is how they are executed. What I think you think of as a programming language is code that needs to be compiled before it can be executed. Where as a scripting language is one that is interpreted as its being executed, it is not compiled first....its kinda like each line is being compiled when its needed (its alot fancier these days tho, which is why js, even tho its scripted, is now really fast). But they are both called programming languages, its only the execution (compiled or interpreted) that is different.
&gt; With Angular, there's nothing stopping you from using ui-router or restangular, if you don't like the out-of-box options, for example. But it's hard to use things like ImmutableJS with Angular 1.x because of how it relies on mutable objects. So there are some options that aren't available to you due to how much Angular 1.x controls.
To get react working you need all of these things or an equivalent alternative. I'm not trying to be negative about React. I love it. I recommend it on any project where the team can handle the learning curve. But to assume every dev has experience with all these technologies is absurd. 
Sure, have fun learning *node* and *jest* so that you understand the "basics" of React so you can write a "well designed" React application that probably doesn't even use node, jest, gulp, or browserify. Have you actually written any React code?
I would do that, but the instructor seemed knowledgeable with what he was talking about (they all do). I got an A in Web design 1 (HTML and CSS) , and I have him again this coming semester for Web design 2 (javascript). So, emailing him about that probably wouldn't be the best idea in my eyes. lol. Maybe he misspoke or I miss understood; I would feel bad if I falsely accused him of something. I could've sworn he said HTML and CSS were scripting languages. Everyone obviously went with it, because we were learning the material. I however knew how to code HTML and CSS since I was in 9th grade. I guess I was like "oh, alright...didn't know HTML and CSS were scripting languages" and just went with it like everyone else. Oh, thank you :) I'm really pumped to get my raspberry pi. I plan on making a working pipboy out of it :)
Agreed.
I was using node, I'l look into async/await. I think the github is outdated relative to the website but there's some confusing stuff there.
&gt; To get react working you need all of these things or an equivalent alternative. 1. Not really; you don't need a router or a flux lib to write serious, useful, well designed React code (which is one reason why they're not built into the core lib). 2. And as for tests or build pipelines...you need all of those things or equivalent to get *Angular* working too. Or are you suggesting that unit tests are needed for React but not Angular?
mobeservable makes react fun!!! Flux makes me buy more aspirin :(
If you do use async/await, you will have to add a transpile step. It's very much worth it in my opinion, but just a heads up. On the other hand, `co` can be used natively inside node at the moment (assuming you're not using an outdated version).
Sorry, I didn't see that second part. Okay! I think I understand: A programming language is a language that is interpreted or compiled. HTML and CSS are *markup languages*, but need to be *interpreted* by the Web browser in order to run. Are they considered programming languages though? JavaScript is a programming language that needs an *interpreter* to run much like Java needs a compiler to run. Correct? I want to say no to the HTML and CSS question as they are simply formatting.
I hate to be `That Guy` but HTML nor CSS are, in any way, Scripting languages. I hate to use Wikipedia as a primary source, but I'm also lazy.. [Scripting Language](https://en.wikipedia.org/wiki/Scripting_language) The key focus here is that a programming language -- ANYTHING that qualifies as programming -- must be able to execute a set of commands and automate a task. In CSS and HTML, there is nothing being automated, no task being completed. Rather, it is just a set of instructions on how to display some text. Don't get too wrapped up in 'Scripting Language' vs 'Programming Language' vs 'Real Langauge' -- JavaScript is a fully capable language that can do some amazing things. While it has an out-dated reputation as a 'toy' language, today it is a first-class language in its own right.
Still not quite following the logic. I mean, your options are basically: 1. Adopt React and get a license to any relevant patents Facebook owns (albeit a license that does terminate in some specific circumstances, as you note). 2. Adopt, eg, Mithril and *not* get a license to any relevant patents Facebook owns. Both open the door to being sued by Facebook, but it seems like you're assuming that the first one has a *higher* chance of being sued, whereas from where I stand it looks like it is, if anything, lower. Unless you're assuming that Facebook has patents that cover some aspects of React code, but *not* any other framework or library? I find that highly unlikely myself.
What I said has nothing to do with how big google is or facebook isn't. I'm not bashing either company. What I'm saying is, it is in Facebook's best interest to keep React relevant, well made, and to not arbitrarily deprecate it to a greater degree than google. It's also in their best interest to keep it as replaceable as possible, which is a very import takeaway here.
Ok I think I got it now: HTML and CSS are simply formatting text. They are simply *markup and styling* languages. They are NOT considered programming languages simply because I'm making text look nice and changing the layout of a page. JavaScript is a scripting language, that needs to be *interpreted* by the Web browser in order to run. This is considered a programming language, because a set of commands is being executed. Correct? 
&gt; Everyone seems to be missing the point of this. I'm not saying google doesn't use Angular 1/2 in their apps But you are implying Google _hasn't_ put huge stock into it, and that it wouldn't cost them a lot of money to make arbitrary decisions. Which isn't really true, considering the amount of Angular apps they run themselves.
Why would moving modules around be hacky? If you expect a function/library to be available at the time a given line of code is executed, the declaration/importing of that should happen beforehand. This is no different. If you want both modules to depend on each other on the other hand, that's a circular dependency, and those are never a good idea.
&gt; investing knowledge in angular means you'll likely be throwing it away again in another year Yeah, tell me how many popular React libraries have come and gone so far in the past year? Now tell me how that's really any better in the long run than Angular switching once after 5 years?
It doesn't matter. The argument is that the angular symbols aren't valid html and considering JSX is even further from being anything close to valid HTML, /u/wreckedadvent doesn't even try to hide his bias about Angular. 
I will this coming semester. Oh, thank you! :)
But which boilerplate? And then there's still the matter of actually understanding what's going on, and with all the churn how do you know if the particular way that you learn is what's considered a good way by the community. All that said I'm firmly in the react camp and have been for a while, it's just not as trivial as you're saying.
I see. Thanks! One more thing, if HTML and CSS aren't read or *interpreted* by the browser, then how the hell are they "run"? How does the ____ know how to change the color of the text? How does the ____ know how to "execute"/read them? 
That's great man. Coding can be so much fun (: JS can be more of a programming language now instead of just a "scripting" language thanks to NodeJS which allows you to run JS on your system as opposed to within the browser only like it used to be a few years ago. The terminology is a bit fuzzy and like someone said earlier it depends more on the environment where the code is run. Before NodeJS javascript could only be run within the browser. HTML and CSS are definitely markup languages as opposed to scripting languages since you can't do decision making in them. However, CSS3 is a bit unique (things never fit into square boxes :D) since you can actually do some decision making and even animations and really it's becoming more of a scripting language with every new feature. Simply, HTML is used to categorize your content and CSS is used to style and position the content on the page (even animations). JavaScript is used to give functionality to your page (button clicks, xhr requests, live updates etc). NodeJS opens up a whole new world for JavaScript where it can be used as more of a traditional programming language (like python). Sorry for rambling, have fun!
They are interpreted by something, but they are not executed. You could write something to interpret them if you wanted, but in this case it the browser. If you where to "run" them nothing would happen as they dont have the ability to make anything happen on their own, their basically just sheets of data explaining what something should be, but have no ability to make that something be anything on their own. 
The original topic was *learning React* as compared to *learning Angular*. Any boilerplate will do as long as it runs. Writing a non-trivial production quality app that avoid bad practices and traps requires a lot more in both cases, but that's another topic.
And hes no expert, which is why you should be extremely careful on what you say. In the very least add "I believe/think" to everything you say.
&gt; No he doesn't. You're right, he literally said it: &gt; google isn't putting huge stock into it You might have a point in that Google is willing to sink all those investments, but there's no denying that they've invested a lot, with [several relatively high profile apps](https://www.madewithangular.com/#/categories/google) and hundreds of internal apps.
"I think/believe" is implicit to what anyone says. Precisely because he's a newcomer I took liberty in leaving out useless technicalities and instead tried to convey the overall bigger picture where JS lies within programming as a whole. I think ;) What I meant by my somewhat snarky remark was that if you'd be an expert you'd realize you're arguing trivialities. You're right though - obviously JS could be run outside of a browser. How else would it be developed? Realistically though, who would be doing that before NodeJS? The situation back then is so different it doesn't even compare to today. But I suppose you're right. I could've added a "pretty much" in there with "Before NodeJS javascript could only be run within the browser." - but then again anything can virtually be run anywhere. Technically mist is water but you don't see people going around drinking mist now do you?
Adwords has been ported to Angular 2.
Even if you did want to convert React to HTML just `renderToStaticMarkup` ;)
Thank you for doing this! Your explanation turns my silly Xmas joke into an actually-useful FP lesson :)
First up, sorry for telling you to fuck off, that was a little wrong. &gt; "I think/believe" is implicit to what anyone says. Believing and knowing are two different things. &gt; Precisely because he's a newcomer I took liberty in leaving out useless technicalities and instead tried to convey the overall bigger picture where JS lies within programming as a whole. I think ;) But you cant! The technicalities count! You have to be exact or things just end up getting blurred and no one will be able to understand each other unless they see things through the same blurry glasses. This is code, get it right or.....try again? ;P &gt; Realistically though, who would be doing that before NodeJS? You didnt look at that link did you? Ive been running js in the console WAY before node. And theres a bunch of other projects like it. Js is just a language, I think its sad that so many people have a hard time understanding that and just see it as something in a browser. &gt; Technically mist is water but you don't see people going around drinking mist now do you? Wtf?
The function passed to mouseenter is a callback for an event. My guess is that `this` is bound to the element that triggered the event, not the instance of your object. Inside your hover function declare a variable called `self` and assign `this`. Use `self` in your event callbacks. EDIT: As an aside, why doesn't your constructor assign these callbacks instead?
ok I'm gonna try this. Can you be more specific about your aside question? Is that not what I'm attempting by putting this method in my constructor function? thanks
&gt; Your right, Im wrong, have a nice day. We were both right and wrong. But at least you were technically correct - which as we all know - is the very best kind of correct (: https://www.youtube.com/watch?v=hou0lU8WMgo
Sure! The `hover()` function looks like it does initialization work which should be done by a constructor. The problem is that the constructor only defines the `hover()` function instead of calling it. You have this `init()` function calling it instead. Your initialization work is split across two different locations in your code. BTW, your init loop should start at index 0, not 1.
Constructors are just functions and behave like all others, except that when called with the `new` keyword `this` is bound to a newly created object.
cool! i got rid of the for loop and now am calling this.hover() in the constructor. Now just gotta get the event to work. Cheers.
&gt; As an aside, I never claimed to be an expert - always continue looking up stuff for yourself and make up your own mind, and keep learning. I'm just a ho-hum developer working yet another whatever job. Hope I didnt make any accusations about You? If I did I didnt mean to. &gt; And hes no expert, was about the OP, sorry for the confusion. THANK YOU!!!! I didnt read the wiki yet, dont have to, the answer I need you just gave me! Screw the words scripting language, which never did sound right to me....its simply interpreted language vs compiled language and a scripting language is as wiki says it (went and read most of it;) and you. Here's a little thing tho, not trying to start another argument, just truly curious on what you think. The lines getting really blurred now. If something is executed from a "script" by an application that compiles it to memory and runs it, thats a script, we agree? But then if that exact same code is compiled to an exe, is that a script? Because you can control qttabbar from an exe using its com interface, exactly the same as you do with its scripts. And the new ones running off .net can most certainly be compiled. Its just if that exe is a script it means every single app made for window using win32 api or .net is a script!! hahahaha, Im just being silly now. &gt; Lastly, @PAEZ_, you also have not predicated statements in this thread with "I believe/think". I know, your right and Im feeling rather ashamed of myself right now :( I think ;) I was right on the interpreted vs compiled, it was being vague on the scripting bit tha killed me. So once again, thanks for taking the time to explain clearly and help me understand clearly.....that damn scripting ;)
hahaha, thanks for that!
And to Landons_Games, Im really sorry about all this ;(
That's great! If you have any question during development please feel free to ask on gitter.im channel.
Wondering the same thing here! :( 
There where quite a few server-side implementations of JS prior to node, some predating it only by a year or few but some being much older. Netscape had a JS based server engine all that time ago, and IIS has supported JScript as an alternate to VBScript since at least version 4 (back in the NT days). Node is just the first general purpose JS-on-the-web-server option to gather significant mainstream mind-share.
Why? They could come up with a new and better framework, slowly replace the React components with new ones and let React die. Exactly the same thing Google does. Google has a couple hundred Angular applications and they are deciding which will be rewritten, migrated and "frozen".
Html and css are LEGO, static bricks. JavaScript is lego technics, add it, and things happen.
Great vid! 
You seem to think that the entirety of facebook.com is built with React, but it isn't. Sure most of the new stuff uses React, but they are far from dependent. Also the core concept behind React makes it actually very easy to replace it with something else in the future. If for example every browser implemented web components and because of their native implementation they become a lot faster than React, why wouldn't they create something new? It would be in their best interest. 
What about the C in CSS? Which stands for cascading, not “component”. Do you still have a global style sheet?
hehehe, I still think its all a little blurry....make a script that controls app=script, compile it=app that controls app?...even tho it has no interface and no other purpose....meh, doesnt really matter ;P And yeah I know, its not really an app, but a compiled script. And QtTabBars new scripting thing is actually a separate app that runs outside of qttb and when you click Run, it says compiling down the bottom. Plus the old stuff can also be run outside of qttb and compiled, so they really are separate. But still scripts, coz their run through wscript. But the new ones are dot net which is bytecode so there not scripts right? hahaha, dont answer, i dont really care ;P Oh well, if nothing else, all this has reminded me to donate to qttb :)
&gt; node if you already know javascript this isn't going to be too hard. you don't have to learn much beyond how to run npm install. most dedicated js devs today already have at least a passing familiarity with node &gt; gulp nice to have, but not strictly necessary &gt; jest presumable if you've done front end development you have a preferred testing framework. all of the major ones have react plugins (mocha, jasmine), so you're not learning anything new &gt; a router assuming you're making a SPA and that you want a router, but sure. &gt; browserify you can copy a one liner into your package json and it'll just work. &gt; node inspector unclear why you think this is necessary for react specifically... &gt; flux flux is not strictly required to develop react apps React is usable from a script tag without any jsx transpilation or bundling if that's what floats your boat.
Angular 1will win. 
But... *I'm* the senior dev.
This is the Ultimate Question everyone should focus on.
Is this /s ? :) Why do you think it is the ultimate question?
I'm just sitting here using [Vue.js](http://vuejs.org/guide/comparison.html) and not regretting a thing.
Angular fits well with established testing patterns. React requires a decent amount of setup to work with standard testing frameworks. It's another part of the stack you need to learn to be effective.
I have production react apps running for one of the biggest companies in the world...
Hmm, I feel backbone with something like handlebars/moustache is the easiest way to keep the designers happy as it's closest to standard html
Always bet on JavaScript 
The official name for JavaScript is ECMAScript. The term JavaScript is owned by Oracle and, so far, they have been ok with hundreds of books being published using the name, millions of blog posts, tweets, etc.. so, I think, until that changes it's likely that JavaScript will stick around. Even JavaScript's creator Brendan Eich refers to the language as JavaScript most of the time. Although personally I have seen a bit of a shift in terminology with ES6 and ES7 being utilized. Side note: I believe TC39 has agreed to name JS versions after the year so ES6 is ES2015 and ES7 is ES2016 - focusing on yearly iterations. These "languages" are very much JavaScript but since both introduce breaking changes that cannot be simply polyfilled we need things like Babel to transpile down to ES5. I think this is what makes people refer to ES6/ES7 as separate "languages" because our interaction with them is exactly the same as our interaction with CoffeeScript.
&gt;And the upgrade path is so good wtf. They have more options for upgrading than any framework I've seen before. I personally have already converted a project once now, and will begin an upgrade path conversion soon. This seems to be bothering you more than the jsx/html stuff, so let me explain this a bit more. With the beta announcement we got the news of ng-forward and such, and [this page](http://angularjs.blogspot.com/2015/08/angular-1-and-angular-2-coexistence.html). This is honestly a good step. It's certainly miles better than nothing - I'm even considering using ng-forward with some of the angular 1 projects I have that cannot afford to drop ie8 support. But, and this is a huge wobbly but. This news came far too late. When angular 2 was announced, we had no upgrade path, with none planned. Only much later we got the idea that could piecemeal the upgrade (with entire routes I believe), and I haven't even heard of ng-forward until that beta announcement. Problem 2, specifics. Being able to run 1 and 2 and rewrite your 1 code to 2 is fine, but that still assumes you know all of 2 and know how to entirely rewrite it to 2. Look at how [livescript](http://livescript.net/#coffee-to-ls) tells you how to convert from coffee. You get a rather long checklist of things to do. At one end, you have coffee, and at the other, you have livescript. This is more-or-less what I've come to expect out of major API changes in other libraries - here's what you need to do to get this 1 code to run as 2. I haven't seen any such thing for angular 1 -&gt; 2. I presume it's because all of the concepts in 1 are totally different and thus just require you to rewrite it.
The other project Google supports/advocates more: Polymer.
There's lots and lots of ways to organize code. With webpack and company, I tend to organize code by *delivery areas*. Example: app/ init.js home/ home.js home.styl home.readme.txt about/ about.js about.styl about.readme.txt components/ header.js header.styl header.readme.txt ... etc ... With this structure, imagine we're in `init.js`, which is setting up *some* kind of router, so we need all of our controllers/whatever ready. We would then do this to get these submodules in our init file: import * as Home from './home/home'; import * as About from './about/about'; import { router } from 'cool-library'; router .use(Home) .use(About); (`router` and `cool-library` are psuedocode) When we build this with webpack etc., it will ensure that by the time init.js gets to the `router` line, both `home.js` and `about.js` have fully ran. If they themselves have any dependencies (say home imports `header`) then it will ensure that that dependency is met first as well. With webpack, we can largely treat html, images, css as code as much as JS is, so we don't need some separate solution for managing our styles or other deliverables. The header component requires the header styles, the about area requires the about styles. Because the module managers take care of organizing the order of the execution, it scales very well, and becomes very easy to handle adding another dependency, changing a dependency, etc.
No, but if I wanted one, or if I wanted to do cascading styles using jss, I can.
&gt;Actually, yes. React.js is not even the first to do it https://www.facebook.com/notes/facebook-engineering/xhp-a-new-way-to-write-php/294003943919 Facebook has been coming up with ways to blur the lines for years
This seems like a major win for React to me. It's massively simpler and has a smaller API than just about any other JS view framework. It's about the least complicated tool for DOM manipulation that you can choose today.
Thanks!
Hi all! I'm happy to answer any questions or comments about the post..
The problem is we use a bunch of different ad services in a waterfall setup so it's hard to figure out which one is causing the issue.
I didn't actually say any of them "failed" right there. I might have said dart failed in the past since google had very ambitious goals for it which it hasn't even begun to met (being ran natively in all browsers). But if the business doesn't even use their own tried-and-true tested solutions for problems, why on earth would I use those things? If google thinks so poorly of GWT that they need to make dart just to continue doing basically the same thing, why would I want to use GWT?
OP didn't include a link to source?
Why not! Just that our team is small and doing this is substantial work, since right now it's just for internal uses. If we find there is sufficient interest, we'll definitely work on it. 
I actually am not a huge fan of JSX either for much the same reason. I typically recommend mithril or similar to people, which is just pure javascript.
&gt; Even JavaScript's creator Brendan Eich refers to the language as JavaScript most of the time. Yeah, I think the original name was Livescript. 
Sure, but those are orthogonal points. The claim was that being a library gives React unix-like properties, but it's hard to use immutables w/ Knockout or Vue even though they're libraries too. If React had built-in ajax, routing and i18n APIs, the ability to use immutables would still be there. And you would still be able to use koa-router or fetch or whatever if you wanted. Besides, as soon as we start talking about shipping actual features like drag-n-drop or file uploads or date pickers, every framework is "unix-like". The list of aspects uniquely "unix-like" for React can probably be counted in one hand, whereas the 20,000+ npm modules are there for you regardless of what framework you use. 
All you need is [one command](https://github.com/neurosnap/sentdemo/blob/master/Makefile#L7) and four dependencies -- [browserify, babelify, react, react-dom](https://github.com/neurosnap/sentdemo/blob/master/package.json#L24-L26) -- to start using modern javascript with [babel + react](https://github.com/neurosnap/sentdemo/blob/master/index.js). It really is that simple. What's great is that react lets you match the build complexity with the application complexity, plugging in what you need, and removing all the items in your list when they are not necessary.
I think it was Mocha =&gt; LiveScript =&gt; JavaScript
[removed]
Angular does not use web components.
[removed]
You don't have to convince me, I was just pointing out that the alternative syntax can be seen as a drawback re: adoption, or at least initial acceptance. It does impact your toolchain rather significantly.
Templates are the vestigal tail of web development. A properly designed React app still splits presentation from behavior, it just doesn't do it in a manner that splits it into entirely different file formats. React + Flux is also much much smaller than Angular. I recommend watching Pete Hunt's Rethinking Best Practices: https://www.youtube.com/watch?v=x7cQ3mrcKaY
I think this guy makes sense. Quoting from the site: &gt; Developers who are new to Node.js will have to start thinking in terms of asynchronous non-blocking code rather than synchronous blocking code. For many, this is the biggest disadvantage of switching to Node.js. You need to be careful while writing async code because if you accidentally write a synchronous piece of code it'll block the main thread (as it's single threaded) which in turn affects the performance of your app. https://hashnode.com/post/what-are-the-actual-disadvantages-of-using-nodejs-ciibz8fd3017yj3xtxqz1r9hs#ciibz8soa02pmj3xt87n0sj29
So from what I understand, the sticking point was this: The license granted hereunder will terminate, automatically and without notice, if you (or any of your subsidiaries, corporate affiliates or agents) initiate directly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporate affiliates, (ii) … If you file a patent suit against Facebook, even for something unrelated to React, your license gets terminated. This is broader than the [Apache patent retaliation clause](http://en.swpat.org/wiki/Patent_clauses_in_software_licences#Apache_License_2.0), which only kicks in when the patent dispute is related to the "Work" itself. I personally think patents are stupid and I'd be happy to agree to a patent draw-down with Facebook: the arms race has to end somehow. But my employer has cultivated a large portfolio of patents, and they aren't willing to base products on a UI technology that turns into a pumpkin should they ever become involved in a patent dispute with Facebook. (A million disclaimers, IANAL, everything I've posted here may be wrong)
angular 2 does
The biggest disadvantage is that using asynchronous callbacks makes analyzing and debugging code much harder. This requirement in nodejs comes from javascripts single threaded nature. A better solution is to use and reuse a single JavaScript runtime per request. Developers are expensive, we should optimize our platforms for ourselves. I am sure some nodejs fans will be upset about the prospect of not writing async code. There are legitimate places to use asynchronous code, for instance when querying several data sources in parallel. For most operations in nodejs however the asynchronous code would be unnecessary were JavaScript not single threaded. 
Ah, thank you! This is exactly what I was missing.
I may be completely misunderstanding this, but can't you just pass the query into the PHP? As in, make your call to /php/phpscript.php?search=x-men And then in the PHP you do &lt;?php header('Content-type: application/xml'); echo file_get_contents("http://thegamesdb.net/api/GetGamesList.php?name=".$_REQUEST['search']); ?&gt;
I really do wish the client side languages were more strict instead of trying to cover your ass for you. So easy to develop bad habits without realizing it.
I... didn't know you could do that, and it's beautiful. (not sarcasm.) Thank you so much!
Hey, no problem at all!
those who ignore the past are doomed to repeat it. unfortunately, we've been down this road before.
You won't be disappointed. Seriously - I was very skeptical when I first got into React and now I think about views totally differently than I used to. It is great
lol this is the problem I'm starting to get into at my company. I make lots of front end decisions, and right now there are just so many. grrr
Knockout has probably the best tutorial I have ever seen. I only ever used it for one project that never got finished, but the interactive tutorial is bloody brilliant.
We're using a global stylesheet today that is more concerned with layout versus being the kitchen sink. Primarily a grid system, typography, and responsive helper classes. Going full-blown inline seems silly at this point in time.
1) Facebook. 2) You take two already seperated concerns and then merge them into one file. 3)Shadow dom will be a standard and you will need to relearn everything. Very few developers can design for shit and like wise not many designers like designing with code so why ?? 
Of course it isn't, React is simply a view layer, but in large real-time apps that view layer starts to grow in complexity at an exponential pace and becomes a HUGE source of bugs, so it shouldn't be discounted either. And it's a pretty well known fact React can be subbed out very easily for something else. I'm not subscribing to React itself, I'm subscribing to how it has you architect your application. In the current JS world, having a library that is easily replaceable is one of the main features we should be looking for. Angular developers should be able to appreciate this more than anyone else, I would think.
You do realize code takes time, which costs money yes? Code especially can come with obscene costs, even moreso when looking at sweeping changes.
I may have chosen the wrong phrasing here, I tend to do that a lot. I meant stock relative to the company, and the more I think about it the less I dislike how I worded that considering one of React's main advantages to me is that it's replaceable, so ideally you want to invest little stock in it and get the biggest return. Let's keep the conversation civil regardless.
So we've gone from knife fights to `¯\_(ツ)_/¯`?
Really good post in which Jonathan Snook revisits his old slide show script and removes the jq making it modern and tiny. Really good explanations and always glad to see jq removed ;).
&gt; Angular fits well with established testing patterns. React requires a decent amount of setup to work with standard testing frameworks. This is simply wrong. Edit: Mind you, if you're trying to use Jest, maybe it's understandable you'd think React is hard to test. Try Mocha; it's significantly easier than equivalent, eg, Backbone code would be to test.
I thought it was "How can we run an infinite loop in one second flat?"
[removed]
[removed]
Not really. That's just DOM manipulation. 
Outside of the small components, it's actually much more similar to Angular. It is, however, much more simple than Angular.
You really think so? I've thought about solving the same problem and this seems like a pretty great approach
I would like to know how scalable is it
It really doesn't. It ultimately creates DOM elements when rendering, so in that sense web components, especially native ones with native shadow DOM, will be usable within Angular, but that's true of every framework including React. Angular 2 does not create web components though, so Angular 2 components are not easily usable outside of Angular.
Ransomware always has the best grammar. The other day a popup full screened itself playing some robotic voice about how their "system is compromised" on my parents brand new MacBook Air. Followed by my father calling me saying "the guy said Macs don't get viruses!" after telling him "put the mouse pointer at the top of the screen and click the red circle" all was good. Not looking forward to more native cross platform solutions. 
With jQuery, for each class: $('.classname').mouseover(function(){$('.classname').addClass('highlight');}); $('.classname').mouseout(function(){$('.classname').removeClass('highlight');}); Then create the "highlight" using a highlight class with css. Without jQuery, you'll need to use document.getElementsByTagName then loop through each item in the resulting array for each relevant class to bind mouseover and mouseout events to adding and removing the highlight classes.
Thank you for your intelligent contribution. It's only missing... intelligence.
 I just don't understand what you're referring to when you say this has been done before and later seen as a mistake. Virtually all MVC frameworks have an awkward middleground where M and V become tightly coupled. They all handle this in different ways, but - to me - React handles it fairly neatly. I'm not aware of any other view framework for JavaScript or otherwise that doesn't do things similarly?
I don't agree, vue is most clearly inspired by angular with a drastically paired down API and more web-component based directive model. Really, it's too late for me to go back to html-as-view. React and its kin have ruined my ability to enjoy that properly.
All of those are separate technologies. React only takes a couple hours to understand.