That makes perfect sense, I seem to have misunderstood the point of the article. I certainly don't think frameworks are inherently bad, I use React myself! However, I developed web apps using native JavaScript for years before touching a framework. It may be that I'm biased towards the way I came up, but I feel like that's the best way to go about learning the language/environment. Frameworks make it much easier to work in a team, maintain your software, and build tools quickly. This makes them a great tool. However, I've seen far too many "Front End Engineers" not know the basics. That's all I was getting at.
That's awesome, I may have missed it in the blog, but roughly how much did it cost to build? (assuming you only had to buy 1 sound board and 1 rp) 
one note, on unix anyway, you can use a separate file list easily with tr and backticks. And the file paths can be relative or absolute. babel `tr '\n' ' ' &lt;filelist.txt` --out-file out.js --presets es2015 --compact --source-maps inline filelist.txt Test.js Init.js 
Most of these you mentioned are in the shortlist of features I can't live without now. Seriously how did we manage before ES2015?!?!
Very cool - though I was a bit disappointed that it was about perlin/simplex noise, not, like "functions that generate sound" as indicated by the "LOUD NOISES" flair!
I love using parameter destructuring, but the example present makes it look awful (also, how would a promise be returning 2 values?).
Angular has been great over the last few years but I've been enjoying Vuejs a lot more lately. There's a lot of positives with React and Ember too.
Just thought the flair would be kinda funny, but yeah. Sound generation can be a great idea for the next project ;)
that example is a little confusing, updated.
Its something to note as I have had issues before with it. 
Webpack
Most of this (barring `let`/`const`) is just sugar, and people who wanted sugar before ES6 were probably using coffeescript. In fact, the syntax is pretty much the same. 
The example is a call back, not a promise. e: guess it was edited out
That's great, I was mostly interested in the touchscreen (on the road with dodgy wifi or could have looked myself!) now to just condense it! Ha 
It's not actually correct syntax, but it's JSX. It should look like: (&lt;MyElement foo={params.foo} bar={params.bar} /&gt;) 
the code highlighting didn't like elements inside of the code hency why I removed the &lt; and /&gt;
I have not tested the example but I think its valid, you can see other examples [here](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) too 
Thanks but is the var Button (x, y, width, height, imgurl, fn){}; correct ? I think it should be var button = function(x, y, width, height, imgurl, fn) {};
This is valid: var obj = {x: 1, y: 2}; var {x: one, y: two} = obj; But this isn't: var obj = {x: 1, y: 2}; var obj2: {x: one, y: two} = obj; So your example that does this: const test = (obj: {x: one, y: two}) =&gt; { console.log(one); }; Is a syntax error in all ES6 environments I tired, and produces the wrong thing in babel: var test = function test(obj) { console.log(one); }; I'm not actually sure why babel parses it at all, but I suspect it's reading it as flow/typescript and just ignoring everything after `:`, which would be a type annotation in those languages. 
When you write an application, use whatever Lin and framework you want. When writing a library however, is better to stick to vanilla js so you don't impose your choice to your users. 
Thank you all so much. Sorry it's been so long since I've posted anything, I would just like to say that every post here helped me out a lot. I obviously don't want to just copy paste anyone's code so I've been looking at every example and looking up the terms I don't understand so that I can write it myself. I can tell there's a lot more for me to learn about this language but you've all given me a leg up!
If your code is split into multiple files, shouldn't you be using modules? Wouldn't that solve the problem? ie. test.js class Test { static getItems(x) { return x + 10; } } export default Test; init.js import Test from './test.js'; Test.getItems(2); // returns 12 Warning: I'm on mobile, so there's probably syntax errors and formatting errors.
Hi, thanks for sharing! I'm going to let this one stay, but in the future, please use a proper project-hosting or code-sharing service. We're mostly just concerned with code here, and get annoyed by having to download, unzip, etc. just to see the source (which may explain the lack of participation in this thread). You can find some common means to do this in our guidelines. Additionally, archives distributed over the net are historically a security concern.
Fair enough, I did notice that. Also a great deal of medical videos. Pretty much any other method you can find online essentially picks from a list of pre-determined videos. Thats what I meant by ACTUALLY random. It is interesting to see what comes up though. 
Correct me if I'm wrong but I think the way you're demonstrating spread is not ES6. Object spread is still stage 2. (Though it may be built into JSX).
True, but that sugar sure is tasty.
I'm pretty sure that that's actually declaring _ as a parameter.
I think it can be beneficial for graphical performance in naively-built apps. In most cases, setTimeout and setInterval don't need to be exactly accurate, so with requestAnimationFrame, the logic fires within +-16ms of the target timeout/interval. What do you think of the idea?
You spelled const as cost in paragraph before the first sample. Just giving you heads up.
Damn you're right.. :(
I've loved JavaScript since I first learned about it in 2004 (ES3). I've never had major issues with the language and was even sad to see some of the bad parts go; had good times with `with`. So I was super skeptical about ES6/2015, it seemed like a lot of sugary bloat we didn't need and many of us didn't want. Oddly I was completely fine with classes, until I realized they skimped on property addition to the prototype. Although, I admit I was wrong after using the new features to author a somewhat complex library. I used: - Lexical scoping (Loops are so much nicer now) - Set/WeakMap (Amazing for object pooling, and emulating `jQuery.fn.data`) - Module syntax (`export default function` is soooo nice) - Template strings (Was building up Web Worker source code by joining a very large array, but now I can template out the JavaScript source and [meta-program the worker inline](https://github.com/tbranyen/diffhtml/blob/master/lib/worker/create.js#L44-L90) - Class syntax (To create custom Error subclasses) - Arrow functions (Almost always used with forEach/map/reduce etc) - Enhanced object literals (Amazing to just pass a variable name and have it map) Afterwards, I was nervous about the testing implications, so I ported the whole thing back to ES5(AMD) and it was a huge chore. There were things like lexical scoping that weren't too hard to fix, since you can just use unique vars that don't conflict. My co-worker helped me get testing on the right track and so I stuck with the ES6/2015 and I'm super happy I did. The codebase is so much nicer to work on.
Yup, javascript has no "ignore" parameter. Even worse, this is a pretty common variable name for lodash/underscore, so this will do entirely the wrong thing: _ =&gt; { _.map(items, x =&gt; x + 1); }
After the Paris attacks, my friend from Turkey wanted to put the turkish flag on her profile picture, in the same way Facebook offered to put the french flag on anyone's profile pic. So I made a tool to overlay any flag over any pic. Here is the flag choosing page: http://www.flaggify.com And here is the individual page for Turkey: http://www.flaggify.com/Turkey You can try with any country name, and it should work. ;) (If it doesn't then tell me and I'll add the country and their flag) 
Yes, sorry, I forgot the = function(...)
Not really clear what your question here is. If it's about calling async functions without await: All async functions return promises, and `await`ing a promise just waits until a value is available and returns it, or throws an error. Therefore, calling an async function without await will just give you a promise that you'd need to `then`.
I agree with the basic premise behind this post. If you're writing a plugin for your favorite framework, think about how you can generalize it for use with plain javascript and other frameworks. In cases where you're using a significant amount of a framework's/module's features, then its pretty acceptable. But one reason that writing plugins for these frameworks is limiting is the fault of the frameworks themselves. Frameworks tend to be opinionated, heavy weight, and incompatible with other systems. For example, React makes it very difficult to work with plain javascript modules, and so essentially makes the path of least resistance for people to build modules that only work with react. In contrast to frameworks like react, I wrote https://github.com/Tixit/Gem.js which is a view library rather than a framework. Gem components can easily be made children and parents of normal dom elements, and Gem.js makes styles modular too - which isn't something touched by react or angular.
Each method should be strictly *either* sync *or* async. You should make it clear to the user which of your API methods is which, using good naming and documentation. Also you don't have to wait for async calls if you don't care about the result or event ordering (race conditions etc). If order of execution is important the library should probably manage it anyway (eg: handle a call to remove() on an object that is still transitioning-in etc).
Of course ;) This is why I came back with the Drive link. But in the future I'll be more proper.
Except, if you're using ES6 modules, "library.method" is an unnecessary pattern unless you truly need to import the entire lib. `import { map } from 'lodash'` solves this "problem" easily. 
Its not ES7 ;)
Const and object freeze is not the same thing 
That's how they're commonly referred to online, but yes, you are technically correct that they are only stage-3.
Still neater than (). $ can be used too BTW
Did you try escaped signs for gt and lt ?
I did try that, but that just leaves you with a "Uncaught ReferenceError: require is not defined" in the console which is where the other tooling starts kicking in. edit: I also tried stubbing out require to see how it was being used, but it went into "magic" land after a few iterations of stubbing.
Smack it up on github
I guess like C# where it's common to have two duplicates for functions, add() and addAsync() for instance. I have played around with it a little and at least in my case it would mean heavy duplicating. And it would get really ugly. If async functions could execute immediately until they bump into stuff to be awaited, i think that would be the perfect solution allowing both atomic and async. For instance a call like this: view.scene.add(model); // async add(model) { this.children.push(model); await this.trigger("ChildAdded"); } console.log(view.scene.children.lenght) Could internally add the model to the scene and await events in the tail, but ran without await it would at least have the model in the scene graph just fine in the next console.log call. While this: await view.scene.add(model); console.log(view.scene.children.lenght) Would get the scene graph and return once the events are through. So, what i don't know is, do Promises always run in the next tick or frame? And is there any way to get something like it without duplicates?
The question concerns best practices. Because once you go async with a tiny little function you enforce the end-user to write the entire application async - or deal with race conditions. We base on three.js. You have 3d models, you can add, remove, destroy them. Doing it has repercussions because users start animations and so on. In es5 killing an object for instance was always a risk because webGL will go crazy if a model is still somewhere alive animating. You had timers and hacks like that. Async solves that completely. But this is an entirely new paradigm that our customers aren't used to. By allowing awaiting promises on these actions the atomic way of doing things is broken. Now it's async or nothing. This is where i believe i can't be the only one having that problem ...
Nodejs itself follows the pattern of duplicating functions in many places. 
[GIFV link](https://i.imgur.com/gD6PXuG.gifv) // [FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot)
Mac OS X only I believe, perhaps *nix too
It's not that i have troubble understanding async/await. They are clear to me, i know how to use them. I believe there's no easy solution, we're throwing ES5 users into callback hell for little adds and removes that may or may not cause async hooks, or duplicate half our codebase. What bugs me is that an add() that knows it doesn't have event listeners registered that must be awaited will probably execute next tick. :-/
I've never heard of Vuejs. I just did their Getting started page and it looks like two way binding and repeaters work very similarly. What advantages does it have in your opinion?
Seeing the AST of javascript code on GitHub? Buuut, seriously: this is really interesting to me just as a learning tool. It's very cool, if nothing else!
If your example is wrong please update your article as this is utterly misleading. Also, always check your examples in your blog!
It sounds like you need a bundler – such as Browserify or Webpack. Both are great tools, but I find Browserify has a smaller surface area and is easier to pick up. Grunt/Gulp is just a way to run these tools, and they aren't always necessary. I wrote a little GitHub example/template that uses Browserify to bundle CommonJS requires. It uses [budo](https://github.com/mattdesl/budo) for a nicer development experience. See here: [mattdesl/browserify-example](https://github.com/mattdesl/browserify-example)
&gt; Don't think that If it was that great idea then it would be popular in backend by now? No, because this is a front-end type of thing, specifically developed through years and years of HTML/JavaScript experience. it's not a back-end thing at all (though, it could be used on the back-end for server-side rendering). I don't use Redux, but I gave React a try, and let me tell you this: it is an amazing (and my favorite) way so far to manipulate your HTML structures dynamically, based on data that changes. Basically "Hey browser, my data changed, let React update my DOM automagically based on the new data, thanks". Tools like React coupled with libraries like http://aframe.io make for powerfully dynamic applications. Without React paired with something like react-famous, react-three, or aframe, you'll write a lot more code, and if you ever organize your code to be super clean and organized, you'll eventually end up with something like React (this is the reason AngularJS, Blaze, Riot.js, etc, exist, because they bring a higher level of organization to lower-level APIs). When you have an array of data, and UI elements the render based on that data, and that data changes and the UI updates automatically, without you have to write a loop to make that happen, your life has gotten easier...
I don't think the distinction is helpful. At the end of the day, 99% of what people are doing with these libraries is building *user interfaces*.
Right! I agree! They are building UIs, but the UI library is what is available via the browser's own native elements, user-made custom elements, or user-made canvas/webgl renderables. The other libraries (React, Angular, etc) simply manipulate and morph those things from one state to another. I really just can't view React as a "UI Library". Maybe a "UI-related library", but it's not like we can make any type of library with just React. Want some type of smooth 3D menu system? React won't give you that, you'll still have to code that, and then you can make it toggle between open and closed states (for example) with React.
Yea, I did had some issues with istanbul. Isparta works well, and similarly ava combined with nyc for coverage has been working well for me.
You can try browserify. Its possible to run it from cmd or grunt and it bundles up all your dependencies
The "easy way" is probably to use something like jspm, hit enter a few times, and forget that you're even transpiling ES6. 
I think /u/wreckedadvent is right actually. Looks like what your code is is actually going for is more like a default argument, `body = {result: body}` except you used a `:`. For some reason Babel seems to allow this without throwing an error but it's not going to do what you're aiming for. If you want to actually destructure the result argument into its body property you would just use `{body}` as your second argument.
Just something I read in [https://www.reddit.com/r/reactjs/comments/485ws8/mobx_simple_scalable_state_management/](https://www.reddit.com/r/reactjs/comments/485ws8/mobx_simple_scalable_state_management/) "Note that the reactivity and observability is unlike the reactivity and observability of RxJs. RxJs helps you deal with events, MobX helps you deal with values (again, like a spreadsheet). You will find that the latter works more intuitively and high-level in most cases. (but combining both is also a very powerful combination)"
I am on mobile so take this for your google-fu: javascript throttle function, javascript debounce function. I am sure you will get what you want. Oh and take account of that leading-trailing thing too. Many people use lodash/underscore's implementation but this pattern is trivial to implement so take a look at its vanilla code if you want to learn more.
i mean... that didn't look even a little bit like javascript. 
Not like ES5 but it is just ES6 + types
BTW, this is an example of Object spread, which is NOT part of ES6. It's part of ES7. It's also explicitly part of the JSX syntax. Also, the underscore isn't the same as providing empty parenthesis in the arrow function case. It establishes a lexical parameter `_` which will be accessible within the function. You can test this by running the following: const test = _ =&gt; _; console.log(test()); // undefined console.log(test(5)); // 5
There's a post a day about const not being what people think it is
Off topic, but what code editor and theme is that?
Exactly. I've never even heard it called a UI library... React also isn't an automobile. Or a mammal.
wat
I am trying to finish my degree since I'm on the verge, but I have actually rediscovered my love for code. So, what to do? I am not more optimistic, also don't want to die alone and poor. Also not yet good enough for a job doing this, probably, but also love Joyce and so glad you are enjoying the library and the literary reference. I was worried people would think I'm weird. But look where I am?
It looks like VS Code.
I hadn't heard of prelude.ls, but it looks similar except in LiveScript, not JavaScript. My library is in some ways a "proof of concept" sort of experiment, to show how you can implement Haskell style functions in ES2015, which has some features that make it (more) possible and slightly prettier. I do think it could be a useful learning tool, for sure. Whether the functional patterns themselves are useful will depend on the individual developer. I know some of them are a bit strange. But JavaScript has a big tent feel to it, so I figured why not give this a try. Since I used ES2015 syntax, I didn't use the prototype object directly. Everything in the API is a pure function, but many of those functions call static methods defined on classes. The only methods I defined on prototypes are toString, valueOf, and a type checking utility function. 
&gt;when all you have is hammer, everything looks like a nail React+redux is a good technological choice, but those "everyone" have no idea or experience about other good choices. And most likely do not the situations where react+Redux is a bad choice. backend is a completely different beast than frontend. I, for one, --if given a choice-- would stay away from any frontend tech which is not stable for at least 1 year. 
For dev/debug purposes? console.log(message); Open up your developer console in the browser (F12 in Chrome) and go to the "Console" tab and you'll see it.
This was really cool, thanks for sharing. Definitely going to try this out :)
Our pleasure! Let us know how it goes. 
Has anyone else noticed that if you have static types then you need an ioc library but you have dynamic types then ioc can be written more simply?
What you could do is keep a state variable to track whether or not the mousewheel action can be performed right now, then use setTimeout to reset that variable after an amount of time. Or you can have another function reset the state within another event (such as when the next page is loaded). Better to show than to tell, so [here's a fiddle](https://jsfiddle.net/92vwtrL2/12/) I threw together that might point you in the right direction. The mousewheel action (just incrementing the counter) is "disabled" for 3 seconds, or you can override that delay by clicking the button.
Sort of. `public`/`private` aren't basic javascript either. At least, [not yet](https://github.com/wycats/javascript-private-state).
I worked in JavaScript role for both Java/C# companies and Python/Ruby/etc language companies. This library is pretty much designed for people from Java/C# backgrounds. Most people from Python/Ruby would probably split code into Microservices by the time code base get big enough that you need to manage application life cycle. In Java/C#, you basically use IoC/DI containers to manage the life cycle. My personal conjecture is that in enterprise world, a lot of products are priced per core/instance/connection, so having fewer of those saves money. 
&gt;i=&gt;1 There is no =&gt; operator in Javascript. You probably want the &gt;= operator.
Kind of, I wanted to have group chatting function for my site. Where people could talk ( text only), I thought it would save money not using socket.io and having people communicate peer-to-peer. I've seen library's on github for webRTC chat applications, but I'm worried about scalablity. I feel like it might get slow connecting to a ton of peers
If this works, this could change everything when it comes to bench marking. 
How much is a ton? You should be fine if you only have a couple hundred connections
Is this not the only use case for jQuery's .one function?
[removed]
words conform to majority of people. not the other way round. if majority of people call apple mango. then rest of us have no choice but to call apple mango. So your distinction is simply too pedantic until it gains widespread adoption(highly unlikely imo)
https://www.npmjs.com/package/gmail-imap dont hurt yourself
Replace non-spaced characters that you want to keep like '$' with '(space)$' then split only on spaces only. When you split on a characters it doesn't store it in the array.
Peer to peer maybe but how would you handle connecting a hundred people to each other? Who would bootstrap the initial connection?
You still need a socket server to manage the RTC streams. Basically acts as the operator connecting everybody and sending notifications that streams are available.
Use this regex: `/\s|\b/` Note: the order of the regex special characters is important. So the above regex is not same as `/\b|\s/` for this context.
You know any good tutorials for getting started with es6? How to build it etc. This Babel thing is confusing
A quick and somewhat smelly fix is to use a flag that tracks your state. Something like: var disableObserver = false; var observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if(!disableObserver &amp;&amp; mutation.target.nodeName == "IMG" &amp;&amp; !mutation.target.src.contains(domain)) { disableObserver = true; fixImage(mutation.target); disableObserver = false; } }); });
Is there much load being put on this server? Would it need to be high powered or would a lowend aws server do?
IIRC Safari (including Mobile Safari) doesn't properly support a significant chunk of the webRTC spec. Luckily since you already have a working app you can check your browser usage and determine if the % of your users that would be unable to use webRTC. 
How about something like [lunr.js](http://lunrjs.com/) then? Don't know about the quality but at least this tries to copy off complete solutions like Solr. This is still assuming you're after 'full' full-text search instead of just autosuggestion or something.
`async` function is just a function that returns a promise, there is no need for the consumer to be an `async` function as well. If it wasn't an `async` function, it would either take a callback or return promise anyway..
In C# it's feasible for a long running function to be synchronous because you can just run it in another thread. It's not feasible in JavaScript at all and old apis that have duplicate synchronous version like XmlHttpRequest are deprecated.
text really isn't that heavy on bandwidth, i'd be surprised if loading the page didn't use more 
Don’t bother with it, buy a proper vps or colo.
Thanks, solved the problem, have never used undescore.js before but seems really good, instantly found more use cases for underscore in the project i'm currently building.
&gt; I wonder how you were able to build a trie out of 50mb without crashing the browser out of memory. It's 50mb of html but only ~50kb of unique words that are in the trie and searched.
Low end would be fine, unless you want to support a fallback where a direct connection wasn't able to be formed.
Underscore also has debounce, and it should be noted that it's implicitly designed for keyboard and mouse event throttling. It's the best solution to this problem. (also lodash &gt; underscore)
&gt; is it possible to avoid this situation? No. You're talking about a situation where you're giving the user the questions, the answers, *and* the code to check if an answer is correct. They have all cards at that point. In addition, you should probably give some thought to the next step: After the client code has determined the number of correct answers, what then? Are you sending anything back to the server, or just displaying the number for the users info? And if the latter, why even care about cheating?
That's right access modifiers are not ES6. But access modifiers to specify the accessibility of a type. So when I said ES6 + types, access modifiers is part of "types" for example generic types like `bind&lt;INinja&gt;` is not ES6 either but is just part of types.
I'm familiar with all the module loaders and module syntax (require, commonjs, browserify, system, webpack...). I'm also familiar with other JS IoC containers like the `$injector`in angular or `@inject` in Aurelia. But these depend on implementations not abstractions so you don't really achieve real decoupling.
That's a Fantastic answer it summarizes the issues. Cheers :) 
You'd need to use a language that could simulate keystrokes if you didn't have their API. Javascript wouldn't be able to accomplish this.
You should try Angular2's DI system. I've been using it on server in some [Koa](http://koajs.com/) projects. It can use parameters' types to inject the right dependencies, no need for stringy names (TypeScript compiled with `emitDecoratorMetadata`).
We use a similar library where I work, since a lot of the code is reliant on the browser having painted. We use https://www.npmjs.com/package/rifraf
Can even go one step further and say it can render html without the DOM, see renderToString
The OP is using a lot of global variables, I don't think that's a consideration right now. :)
Not from top of my head, I found this by googling https://github.com/tixxit/suffixarray
and I woke up to it being broken again... even with a file list.
Thanks. That looks like a good piece of JavaScript to start with. It looks like it's a concise implementation of some of the Suffix Array tools that are needed to make the most out of the data structure. Creating different suffix arrays out of input which has a small modification could help to understand how to make suffix arrays dynamic. My opinion though is that it's a complicated and in-depth subject which I find interesting but won't have time to study in great detail all that soon. It still looks like the easiest way to get some of the more complicated suffix array systems running in JavaScript would be to compile to JavaScript, and I'm more interested in making tools that help to do that, or at least better understanding that workflow myself.
Source?
Keep in mind there's almost always a way to cheat. A user could practice with a dupe account to learn the correct answers. Or write a bot to collect the answers if there are a lot of questions. Hopefully the incentive to do so is low. :)
&gt; enterprise software patterns or you could have used a module that returns a higher order function instead
Just asked on SO just to be sure http://stackoverflow.com/questions/36115656/angular-2-0-di-can-i-depend-upon-abstractions/36115798
Why not implement a Function in JS that runs only once no matter how many times you call it? var once = (function() { var didRun = false; // This function will be executed only once, no matter how many times // it is called. function once() { // ... } return function() { if (didRun) { return; } didRun = true; return foo.apply(this, arguments); } })(); 
I'm building but building has two phases design-time (before compilation) run-time (after compilation).
Yup. Functions are first-class members in javascript, and can be passed around like any other datatype. 
Could you explain the difference, please? I was under the impression that the pipe is commutative.
&gt; } else if (_.some(city, checkTemperature)) { checkTemperature is not being called with no arguments, javascript is different from ruby when it comes to calling methods with no arguments. The only way to call a function without arguments is with parentheses, checkTemperature in itself is an instance of Function, so it is actually being passed as a parameter to the functions like *some* and *every*, instead of evaluating the temperature and then running these functions. Simply put: foo(checkTemperature); //Sends a function as parameter of foo foo(checkTemperature(20)); //evaluate checkTemperature then send that value to foo (basically sends 'true' to foo) foo(checkTemperature()); //We're comparing the value 'undefined' with something else, always returns false.
This isnt true, webrtc vs object rtc are the same on the wire the only difference is how your peer group is structured. webrtc for the most part is pure p2p with extra hardware for signaling. The next level is using an SFU or "media server" to help process your streams and preform packet shaping. Object RTC is a formal spec for managing infrastructure/signaling/nat transversal since all these things are not in webrtc think of it like a superset not a rewrite like es6/es2015 is to normal JS.
ICE is already part of signaling (encoded in the offer/answer) and your browser vendor should provide both STUN and TURN servers. Why not just use those?
Does lodash have debounce also?
I would go to their github and ask: https://github.com/olivernn/lunr.js/issues Reading one of the other issues, it seems to be able to handle 5MB on the client-side, so I don't see why it won't be able to handle 50MB on the server-side. 
That'd be a very exciting project.
It's a nice example that helps people not familiar w/ modeling these problems learn about the topic. The code is "clean" and your data model is reasonable. That being said, your code is probably 1-200% longer than needed and weakly partitioned. I would encourage you to delete every single getter/computed property and just do straight data lookup. Demos don't benefit from that sort of "abstraction" and they make it worse for your audience (programmers) to hold the solution in their head. I would introduce useful concepts like "a renderer" which consumes Things and executes draw calls (canvas or otherwise). You also instantiate your MouseHelper in init before you have defined it which indicates you have not fully framed the problem for your readers and metering out the design "bit-by-bit". In practice, this makes your blog hard to understand and some readers will just give up. Finally, your rendering engine probably should have some minimal concept of layers. This is extremely helpful for new readers to gain insight into how these systems are designed once you're out of the domain of the minimal example. You could, for example, render all your Things first in a layer, then paint all their BBs, then finally paint the dragzones. This is better for performance but more importantly it highlights the decomposed nature of most renderers. 
Not as implicit as one would believe - the arguments are applied in a normal fashion, just out of sight. We could make our own `forEach` implementation kinda like this, assuming that we have an array `myArray` to work on: var forEach = function (fn) { for (var i = 0; i &lt; myArray.length; i++) { var index = i; var element = myArray[index]; fn(element, index, myArray); } } We take a function, then just call it with args like we would any old function. 
Probably relevant: https://zeronet.io/ Backend-less, P2P Distributed, Real-time updated websites with built-in SQL server. It has a P2P Chat application tutorial in less than 100 lines of code.
helpful link, thanks 
I also came from ruby recently and have trouble understanding this. I still struggle somewhat with how js handles functions. The "Eloquent Javascript" book is very good if you havent yet read it, its chapter on [Higher Order Functions](http://eloquentjavascript.net/05_higher_order.html) covers exactly this. 
I do have that book, I'll crack open that chapter
I see... So it isn't actually part of the web standards? I mean, like browser web engines agreeing on an non *standard-approved* specifications? If it actually is part of the web standards, which one? And about that modified scope chain... AFAIU, this is beyond the capability of JavaScript in a web browrser, is it not?
I agree EmberJs should also have been in the list, but it is very much suited for larger projects. I have been enjoying VueJs a lot and recently started using AdonisJs, i seriously wonder the less amount of code i am writing these days, loving Es6 generators and Adonis both
~~It's not that ICE is "already part of signaling". ICE is a framework you CAN use for signaling (and must use in real world scenarios, because well... NATs exist).~~ Sorry. /u/cjbprime corrected me. [ICE **IS** part of the webRTC draft](http://tools.ietf.org/html/draft-ietf-rtcweb-security-03#section-4.2.3). I am aware of (good and webRTC compatible) free STUN servers, but no TURN ones. It's been a while since I last worked with webRTC, though, and I was providing video and audio rather than just text, which might have made my project a bit pricey. I wasn't aware that browser vendors offered free STUN/TURN servers. It might be worth a look. At any rate, I was just stating that 100% "serverless" webRTC is impossible. There's always servers involved (more than you may initially think) and if you already have a working websockets project it's probably best to stick to that technology rather than the big effort of moving to a completely different one.
Here's something that will really help you understand this. Instead of having to just *think* about how this works, there is an easy way you can actually *see* exactly what is happening: trace through the code in the debugger. (Of course it's a good thing to think about the code! But nothing beats seeing it in action and interacting with it as it runs.) First, be sure you're using an unminified version of Lodash, not the minified production version. Add this statement at the beginning of the code you want to trace: debugger; Now load your page in Chrome, or pretty much any browser, with the Developer Tools open (F12 on Windows, Option+Command+I on OSX). The details below are for Chrome. The code will stop on that `debugger;` statement and you will see your code in the developer tools panel along with the call stack, local variables, etc. Find the button above Watch with a down arrow and a dot below it. The tooltip for the button reads "Step into next function call" and lists a keyboard shortcut or two. Click this button, or use the keyboard shortcut, and watch the debugger go to the next statement and update its display. Keep clicking the same button; when it reaches a function call it will step into that function and show you the local variables inside the function. Keep going and you'll be tracing through the Lodash code, and you'll eventually get to the place where it calls back into your function that you passed in. This will make a lot of things more clear; it's a great way to explore some code and understand it. Here are a couple of good introductions to the Chrome DevTools: https://developer.chrome.com/devtools https://developers.google.com/web/tools/chrome-devtools/
Truthfully if you have a gossip protocol passing messages... you can use it for chatting so long as distribution delay across the network isn't too large.
Awesome, that explanation on the forEach really solidified this. So the lodash every/some functions check the second argument for truthiness, running the provided function for each element. 
Reading posts DOES help commenters. ACK! I highly recommend you read what you're replying too ;) &gt; I was trying to grab a username from an instant messaging site(messenger.com). [messenger.com](https://www.messenger.com/) is the web client for facebook messenger, OP is trying to read values from a chat there.
If id's are repeated, it's bad html
Alternatively, use ES6 syntax: () =&gt; { }
Don't forget to flair as solved when you have your answer! =) 
Yes, this is possible. Here's a demo: https://substack.neocities.org/swarmchat.html Source code: https://gist.github.com/substack/0177839f57e8fe0fc294 You will need a server, but only to set up the initial connections. The actual messages are sent directly from browser to browser. In the code above, we're using a [signalhub](https://npmjs.com/package/signalhub) provided by mafintosh. To scale to more than ~10 connections, you'll need to implement a gossip protocol so that you receive messages created by other peers who you are not directly connected to. These can be very simple: forward along messages you haven't seen before to your other peers. The code I posted has one of these, although I haven't tested it extensively.
Ah, seems you are correct. I thought the use of ICE was just a common-use case, [but it seems it is part of the draft](http://tools.ietf.org/html/draft-ietf-rtcweb-security-03#section-4.2.3). Will correct my initial post. Thanks!
Not an expert by any means, but the discovery and handshake processes are the heaviest lifting. Once the RTC streams are connected, the server just sits back and waits for new connection/disconnection info. 
I still find myself using John Resig's solution from time to time - http://ejohn.org/blog/learning-from-twitter/ (code is at the end of the post)
It's called a callback. 
I started a library for making web components with react: https://github.com/richardanaya/webblock
I tried it (not exhaustively) and it looked like 'i =&gt; 1' was just being treated as a string. How does that work?
That was fun to watch, and educational as well.
Well, my suggestion to you, and anyone else, is not to have a solution in search of a problem to apply it to. Make a simple chat client front and back end, then try and get them to communicate with only HTTP requests. Really understand the problems that you're solving by applying a solution like websockets. That'll give you a concrete idea of what you need to use it for, exactly, and it should make it easier to find out how to do x or y with it. If you want to appreciate it even better, you could try something else, like sockets io or signalR, and see what's unique about faye specifically. Particularly in web development, technologies fly by so quickly you do not want to be stuck holding the bag when a certain library falls out of fashion or another one comes out that supersedes it. You'll want to be in the practice of learning techniques and solutions from these, adding them to your tool box, then having that tool box ready to go when you have a problem - like a live chat being slow with HTTP-only - that can be solved by one of the things you picked up.
for me the best of react is the virtual dom that makes so simple my life and actually react is not really pure or functional André Staltz have really good talks about that.
`=&gt;` is shorthand function syntax that has a lexical `this` binding. `i = function (i) { return 1; }` and `i = i =&gt; 1` are equivalent statements. 
It's because `getMags` is asynchronous, but its return value is synchronous (you are actually implicitly returning `undefined`). I see you have specified an unused `callback` argument in addition to `search`, so you should make use of that (or, better, use a promise). // this is just inside of `getMags`... request(url, function (error, response, html) { // all your code... callback(null, magnets) // `callback` is the second argument of `getMags` }) // use as follows: getMags('books', function (err, magnets) { console.log(magnets) }) If you'd prefer to use a promise as opposed to a node-style callback (though if you're struggling with this, you may want to understand callbacks first), it would look like: // arrow functions make this even smaller, but using `function` for clarity function getMags (search) { return new Promise(function (resolve, reject) { // same request code as in your example... request(..., function () { resolve(magnets) // this resolves the promise }) }) } getMags('book').then(function (magnets) { console.log(magnets) // promise has resolved, this will log your result }) 
How could they fix those problems you mention?
Cost. Firebase is expensive and having the client's do the heavy lifting would be ideal. My app's across the free line so I would have to pay $50/month to use firebase. It's just a side project thats free to use and don't really want to drop $50/month on it.
You are passing a callback to `request()`. That callback will be called at some point in the future when the request has been completed. `request()` returns immediately, it does not wait for the request to complete. Therefore the line `return magnets` executes before the callback has been called. If you want to act in any way on the result of the request (such as logging the result) you have to do that action in the callback, or in some function that you chain after that callback. You can't do it in the same function that calls `request()`, because that's just not how asynchronous programming works. 
I wouldn't discourage finishing the degree. It's a great accomplishment and I occasionally think about going back. In relation to being good at this, I might have a different perspective, perhaps due to being in Philadelphia, but I got a great job with zero experience and jumped contract jobs quickly until where I am now at a fantastic full time position maybe a year after deciding to learn me some programming, earning way more than I figured I'd be making in 10 years. maryamyriameliamurphies proves a hell of a lot of skill and from my perspective, you'd get a job no problem. Hell, we have openings. Again, not to discourage from the academic route which would also be very fulfilling. In relation to weird literature types, I've seen more than a few. Code is essentially poetry in real time. 
Instead of defining default values as `const`s and using default function params, you can do: const TextInput = ({ placeholder, onEnter, classes }) =&gt; { // etc. } TextInput.defaultProps = { placeholder: '', onEnter: () =&gt; {}, classes: [], } You should also define propTypes: import React, { PropTypes } from 'react' // etc. TextInput.propTypes = { placeholder: PropTypes.string.isRequired, onEnter: PropTypes.func.isRequired, classes: PropTypes.arrayOf(PropTypes.string).isRequired, }
This comment overstates the difficulty in using webrtc for practical purposes. The server components are a small part of the traffic load and many people offer this infrastructure. For example, as I mentioned in my comment, you can use a library like [simple-peer](https://npmjs.com/package/simple-peer) with a [signalhub](https://npmjs.com/package/signalhub), or use [webrtc-swarm](https://npmjs.com/package/webrtc-swarm). You don't need to worry so much about the underlying transports or protocols, these low-level details have been figured out by these libraries and this infrastructure is already fairly robust.
This still gives me the same result, no special characters were added to my array.
Thank you! I tried talking to some people on StackOverflow and they were just being unhelpful assholes, its nice to find someone who actually helps!
One way could be facilities to quickly build markup and diff into the page, setting up the right event handlers, firing life cycle hooks, reactive hooks from markup, implement transitions, and more... The end goal being a way to decoratively structure your application, and reflect a state produced by something like Redux. Simplifying the representation and inverting the control into the markup for component creation instead of `initialize` methods. I think there's a lot the browser could do to incrementally soften the weak areas of the DOM and provide more efficient high level APIs to do common DOM transformations.
But this is HTML. HTML -&gt; content, JS -&gt; behavior, CSS -&gt; styling. Those have been the Web's pillars for a while now. And I think piling more responsibilities onto HTML is maybe not the best way to go about it IMHO. 
No problemo, good luck with it.
Thanks for the tip! Will do.
&gt; Water started falling from the sky, so I think we're in the right track Spot on. Very creative teaching style, but I think he should have put more emphasis on the 3D aspect of three.js, his game ended up being almost 2D. Edit: Actually, his [second video](https://www.youtube.com/watch?v=P2q5M50x5Uw) fixes that, it is worth taking a look!
&gt;quickly build markup and diff into the page, setting up the right event handlers, firing life cycle hooks, reactive hooks from markup, implement transitions, what the hell does all that even mean? &gt;The end goal being a way to decoratively structure your application, and reflect a state produced by something like Redux. the point of spec is to provide functionality. how you use the functionality is up to you and if you prefer structured environment , then use a framework. that is what frameworks are built for, you know. And i really don't think that spec makers will make react +redux as html standard &gt;I think there's a lot the browser could do to incrementally soften the weak areas of the DOM and provide more efficient high level APIs to do common DOM transformations. browser can, but that can also happen through js libs and hence are not on priority list.
What desktop environment was he using?
Well, there's not a lot here to code review. Only feedback I have is I don't see people aligning their assignment very often, and `cn` isn't a very helpful variable name. You can however utilize some higher-order functions to get your component to just be one expression (presented without comments for brevity): const getClassNames = classes =&gt; cn(['ml-text-input', ...classes]); const getHandler = callback =&gt; ({ keyCode, target }) =&gt; { if (keyCode !== 13 || !callback) return; callback(target.value); target.value = ''; }; const TextInput = ({ placeholder = '', onEnter = () =&gt; {}, classes = [] }) =&gt; ( &lt;input className={getClassNames(classes)} placeholder={placeholder} onKeyDown={getHandler(onEnter)} /&gt; ); But that's pretty minor, and just something I like to do to make simple components easier to recognize. I'd say if you want more meaningful review, post something a bit larger. 
I wrote up a lot of thoughts and didn't want to spell out an essay describing them, but they don't seem very useful in a list without context. I'll elaborate below: - quick build markup and diff into the page - basically via tagged template strings and some new DOM APis this could make it easier to waste less resources on the frontend. I don't see why browser vendors would oppose a well defined specification. - setting up the right event handlers - meaning a way to specify event handlers contextually in markup like React does. something like what yo-yo (https://github.com/maxogden/yo-yo) does - firing life cyle hooks - what Custom Elements are doing when elements enter/leave the dom, and have attributes changed - reactive hooks from markup - Custom Elements can call your constructors instead of having to call a View constructor and pass an element - implement transitions - a way to block DOM modifications until a transition completes, makes it easier to build stateful interfaces that can transition declaratively
great work. I knew there would be library for this. but I was too lazy to search for it. 
&gt;quick build markup web components are *expected* to address this issue. the development is slow because there are too many browser vendors and too many difference among them. &gt;and diff into the page you mean as in virtual dom diffing ?. I don't think such facility should be an html standard. &gt;setting up the right event handlers - meaning a way to specify event handlers contextually in markup it must be my lack of knowledge of react, but how do you expect the context to be defined? when web components will work, then we can limit scope to the component. but, not now &gt;firing life cyle hooks &gt;implement transitions again, web components first, only then those stuff matters. &gt; I don't see why browser vendors would oppose a well defined specification. they don't, the problem is they have lots of well defined specification (some of them flawed) and it is their duty to pick one among many. the process is definitely too slow. 
yeah, I know. And I feel creepy waiting too. Thats why I actually think I will wait and see if they message me. But with web sockets, WebRTC data channels etc. Lots of "creepy" things can happen, but unlike many websites on this I am being transparent and showing what i can track since that may be something they might want. Also I can analyze the event streams and make changes based on how they interacted with the app. 
I'm sorry, id's are not repeated. Only classnames are.
source code looks like a serial killer wrote it. This is cool though
I asked a [similar question](https://www.reddit.com/r/reactjs/comments/3syna2/advantage_of_defaultprops_over_es6_default/) in r/reactjs once, got some decent answers.
Object with information is only logical solution const colors = { 'ff0000' : 'red', '00ff00' : 'green' ... } you will also would need to parse abstract values likes `fff` into `ffffff` and etc.
No one here has mentioned promises and generators. I urge everyone in here to learn both and understand how they work. You can create async functions if you combine these two ideas in your es6 code and is the main reason I push redux saga so hard for people using redux. 
Please elaborate or at least be a bit more specific. 
Insightful. 
Do you have any good resources for leaning about these?
It's not my job ;) I found it this morning on Twitter !
it's just so much because TJ went all crazy with it when it started in 2009/2010... the irc channel was maybe 20 people. everyone had an idea, some started writing stuff. myself on the other hand started implementing it and fixing issues in node itself. it's great when you're there when it starts because there is nobody stopping you or rubbing in his unwanted opinion. you just build and everyone helps. after a while it attracts attention, with node it took over 3-4 years. same with mongodb, same with laravel. I used to contribute to laravel, I don't do it anymore because it's too many people being dicks, too many use cases that need to be tested and the biggest issues of early technology projects, douche original owners. I totally understand anyone quitting after a while.
I'm sorry, but this really hurts my eyes. Drop shadow on all text makes it hard to read. Tool tips on icons that cover almost the entire screen with text. This website actually needs *less* interactivity. I shouldn't have to click everywhere and on everything just to get the "extra" information. Let your projects speak for them self and don't turn your CV in to another interactive playground. I'm sure HR would appreciate that. Nice and clean.
Hi! Um, maybe it's not directly related to JS but indirectly. Goo Create is a fantastic cool tool if you already know JS and want to start making 3D web content. Maybe it's too far fetched. Please remove the link if you think so.
aha ok xD
I used drawberry (http://raphaelbost.free.fr/DrawBerry.html) and inkscape to draw the logo by hand. PS: you can see a comment from drawberry in svg markup ( https://github.com/freemountain/vulp/blob/master/manual/asset/logo.svg?short_path=5f1bed3#L2 )
It's amazing, you can even use `Ctrl+B`, `Ctrl+U` and `Ctrl+I` to set the text bold / underline / italic
I have recently found BottleJS: https://github.com/young-steveo/bottlejs to be quite good for dependency injection and acting as a service container. It doesn't need any special annotations, has no need for interfaces (they might be nice if you use TypeScript, but otherwise I think you're better off without them) and it keeps your service configuration nicely centralized. Too bad it wasn't covered by this article, which should have been titled: The current state of dependency inversion in *Type*Script...
So, what made Doug Wilson call it quits and not trusting anyone??
What I'm hearing is replace platform agnostic language build tools with CLI. Your above script is very simplistic. One of my build processes for maximum optimization in Broccoli is over 50 steps to build my entire website, and I can easily chain together these transforms using the same language I code in. Efficiency can be increased using parallel builds and a myriad of other possibilities. I am unfortunately not sold on the idea of using only C/C++/native code
I don't even think the interfaces are necessary in typescript, due its structural typing. Anything that's compatible with the type is good to go - which is most of the reason for using interfaces in languages like C# or Java.
Using JavaScript as the language of JavaScript build tools has the benefit of being able to run on any system that Node can run on. Who wants to create build tools and then test them on Windows, OSX, and Linux themselves? Let Node handle that mess.
Quite frankly, I don't believe any of it.
Yeah. I should remove that text from the post, it's not helpful. :)
After the StrongLoop debacle, it was IBM being as slow as the mammoth they are and failing to communicate. Doug at some point simply didn't want to bother with trying to fix things with them anymore. There is a github issue somewhere that on the one hand shows IBM trying but on the other not actually managing (for whatever reason, many assumed red tape) to fix things with doug. I had the impression doug would have stuck with trying if it was just TJ -&gt; IBM without the Strong Loop period.
Content editable is buggy garbage on all browsers and hasn't seen any bug fixes in years, let alone new development. bah 
I think `.chain` is probably going to win out as the preferred interface name, largely on the back of fantasy-land (flatMap is also confusing because it contributes to the differences between map/flatMap in different languages). Native Arrays may end up getting flatten/flatMap methods: http://bterlson.github.io/proposal-flatMap/ at which point we might as well implement `.ap` as well. While native Arrays (aren't super interesting as Monads go)[https://medium.com/@dtipson/hey-let-s-make-a-monad-e276802fdb0c], there are some decent use cases.
Oh, right. Sorry. If it's used like that, it does achive the same result although the function body content would be different. Thank you for the explanation.
So what is Doug building now then?
`.then` is confusing as it mixes `.bind` and `.map` in one. I'm looking forward to use `Promise` (probably from monet.js) that will provide separately `.map` vs `.flatMap`…
It's just a really weird context to quote the guy... You recognize him, his talks, are aware of everything he says, but bring it up just to disagree? Most of what he does runs in direct contrast against your article, and is aimed at non-functional OOP programmers. And I mean, pretty trivially. In my example, you could name `Http` whatever you wanted to. The default export still news it up and returns that singleton, so consumers literally don't know and don't care - they're abstracted away from it. As for `depA` and `depB`, it depends. If they're not specific to that project, then I can just make them a node module and just have it import this: import depA from 'depA'; Now anything that fulfills the `depA` role can live in `node_modules/depA`. This will even work with typescript. I also usually have some level of path rewriting so there's limited relative imports. For example, the only time I'd be OK with an import like `./something` is if it was a dependency that was exactly tied to the current file, e.g some css. So in the case that it is specific to a project, my path would look something like this: import depA from 'ns/services/depA'; Now my module bundler can point this to *whatever* it wants. This module can even itself import something else and just be a dummy for a stable name. Even RequireJs had this. Usually this just aliases my folder structure, but it can be useful in unit-testing scenarios, if you wanted something automatically stubbed/mocked out (like a service that gets user credentials for example). afaik this doesn't work with typescript. 
What's confusing about it? It does whatever you need it to, and the behavior is understood already in the context of Promises even among people who know zip all about functional programming or monads. 
If there is a build process between you writing code on your localhost and executing code on your localhost then you are already slow. Making the build process faster will only make you somewhat less slow. Complaining that the build tools are slow is really insignificant. If you really REALLY wanted to be faster you would find a way to eliminate steps from your build process and ultimately eliminate your build process. If you compare your productivity to somebody who doesn't have a build step you will generally be slower, because the person without the build step isn't waiting idle for the duration of the build step. If you have a 30 second build step, 30 people forced to use the build step, and it is used an average of 20 timers per day per developer you have at least 5 developer hours per day being burned away. If that build process is 5 minutes and only used on average 5 times a day your team is burning away 12.5 hours of development time each day. That is a lot of wasted time not spent thinking about code. Save build processes for production and certification code pre-processors (like minifiers, media conversion, language conversion and so forth), unit tests, and other automation that doesn't prevent you from writing and running code.
“The needs of the many outweigh the needs of the few, or the one.”
I just mentioned Mark Seemann because I was expecting people saying that they don't need and IoC container because they do FP. I just wanted to say that I'm defending the usage of an IoC for those that do OOP not FP. So in yout `Http` module you are importing `depA`: import depA from 'depA'; But that is not what I asked because in the second project you ar enot using the npm package "depA" at all. You are using another package with the same interface. You can solve it importing dapA in another file not the Http one. In other words, by keeping your Http completely agnostic of its dependencies. Please don't get me wrong, I'm not saying that you can't do it, of course you can write SOLID Object oriented JavaScript code without an IoC container but the IoC container makes it much easier that's why frameworks like Aurelia or Angular include one. 
I've always found the BEM syntax to be really hard to swallow. Interesting to see plugins popping up for making it more palatable, but I'm still more partial to having css scoped to a component, or css scoped scoped to an element name. It seems to fit more naturally with the whole react philosophy than global style sheets for your components. Granted, I totally recognize (and agree) with the article when it comes to inline styles and how current solutions don't offer much thought in the way of theming. But I'm talking about something more simple, like (stylus): my-input background-color red Which is then imported by a react component which delivers a `my-input` element to the page.
What? That doesn't even make sense...
I sort of see that smartness as a problem: `.then` is _not_ just a `flatMap`, it's auto-detect map/flatMap with special error types. That's not a sensible generalizable pattern for all data-types. It's especially troublesome for Arrays, where you might want to map (and deliberately return nested arrays) OR flatMap (where you want unnesting).
It for e.g. prevent's from wrapping a Promise inside a Promise. I prefer using static type checker like TypeScript or Flow, and it's much clearer to use `map` for mapping and `flatMap` if you want to map and flatten. I treat `then` as unsafe method.
Any idea when some sort of stable 1.0 is planned?
Well, you're not going to get this sub to do your homework for you, if that's what you're getting at. What do *you* think you should do? I'd be quite happy to offer you some guidance if you meet us half way. 
You have some auth providers (inversify.config.ts): import GoogleAuthProvider from "./..."; import FacebookPlusAuthProviderfrom "./..."; import TwitterAuthProviderfrom "./..."; Kernel.bind&lt;IAuthProvider&gt;("IAuthProvider").to(GoogleAuthProvider); Kernel.bind&lt;IAuthProvider&gt;("IAuthProvider").to(FacebookPlusAuthProvider); Kernel.bind&lt;IAuthProvider&gt;("IAuthProvider").to(TwitterAuthProvider); Product owner ask for a new auth provider (inversify.config.ts): import GitHubAuthProvider from "./..."; Kernel.bind&lt;IAuthProvider&gt;("IAuthProvider").to(GitHubAuthProvider); Your auth service (auth_service.ts) does not require any changes: @injectable("IAuthProviders[]") class AuthService implements IAuthService { private _authProviders: IAuthProviders[]; constructor(authProviders: IAuthProviders[]) { this._authProviders = authProviders; } public login(token, providerId) { return this._authProviders.filter( (provider) =&gt; return provider.id=== providerId ).login(token); } //... } Of course you could do this in many other ways but this is just the first use case that came to my mind...
...where are you getting that babel was written in C? [v5](https://github.com/babel/babel/tree/5.x) and [v6](https://github.com/babel/babel/tree/master) were both written completely in javascript
Connect was also created by TJ.
I'm not saying that babel is/was written in C, what I'm saying _if_ it was, it could be faster then it ever could be written in JavaScript. The reason I mention v5, is because v6 brought in the plugin system, which as far as I know, would be much much harder to do compared to version v5.
* There's no way to pass data between components. You set string attributes on them, but there's no way to pass objects without implementing that yourself in your own components. But then your components become less reusable. * No good way of reusing shared logic. Two different components might need utils from something like lodash. Then you'll include lodash twice because there's no way to deduplicate the dependencies. * Managing the DOM is very imperative and fiddly. With most JS frameworks today (with databinding or unidirectional data flow) your views are a lot more declarative. Web components are just declarative for the first render, after that it's all imperative. * Web components aren't meant to be used for an entire application. You won't have a "MyApp" component that renders your entire app (simply because that's not what Web components are meant to solve) so you'll need some JS framework anyway unless you're just sprinkling some interactivity on top of a server rendered solution. The spec in its current form is way too big to only solve that.
Well, to be fair, it communicates an intent which I think is valuable, just not the same one as what unit `()` communicates. Consider, for example, we have a unit test and we're passing a function to something. We don't care what the function is called with, but we're going to return `true` anyway: const isValid = () =&gt; true; Doesn't look exactly right to me, since *we know* this function will get called with an argument. const isValid = _ =&gt; true; This looks better. We accept an argument, but don't care about it. It also would have been fine (though a bit needless) to give it a name: const isValid = x =&gt; true; Given, though, it's much less necessary than in languages which check the type, though. In functional languages, `_` is usually an "ignore" parameter, which nothing binds to. I just wouldn't go so far as to say the use of `_` is an anti-pattern, just that you don't want to use it in place of `()`.
Nice idea! 
I actually made a comment in this sub a while ago about using [generators for an unusual use](https://www.reddit.com/r/javascript/comments/458c3l/has_anyone_found_a_good_use_for_es6_generators/czw0bv0). They're ridiculously awesome. 
lol, someone calls out OP, OP deletes account.
I am not going to waste time describing the exact issues that arise from your suggestions because I am sure that you'll be able to deduce them even from a short description. The first main problem is caching. This is also the reason why nobody manually writes Makefiles anymore and CMake is used instead. Your suggestions don't take into account caching at all. The second main problem is usability. It is impractical to cram all the configuration into a bash script. The third main problem is that shell languages are ugly pieces of shit that need to be completely scratched and redesigned. JavaScript is shit, but it's nowhere near as shit as bash or other shells. In fact, the only shell I know of that I would actually don't mind using is PowerShell, which is Windows-only (it's pretty much the only well-designed part of Windows to be honest). And finally, I don't want to see build pipelines that literally include greping over the code.
Anecdotal evidence.
Could have just as easily been titled _The Sordid History of the Express Javascript Framework_. After the drama that ensued on Github I just decided to make the switch to Koa, which has been awesome, is ready to switch on async/await whenever it becomes stable in node, and I believe is already ready for HTTP/2. Plus the generator syntax is just nicer than Connect's callbacks.
Thank you very much sir, you explained it very nicely, and I'm pretty sure this will be useful for me. I also appreciate the offer, can I bother you with a message whenever I have more in-depth questions about these frameworks?
It seems like you have a good foundation for coding &amp; full-stack development, but where you're lacking (and is quite honestly something every programmer struggles with) is the design. I can see the base designs you have in mind, but there are a lot of mistakes among them that make it very difficult to navigate intuitively. I would add more spacing between lines, left-align text when you can, hit your biggest points early (e.g. who are you, what is this site, etc) &amp; make them short &amp; clear - so users know right away what they're looking at, your nav-bar looks good, stick to a consistent &amp; simple color-scheme - you use green on some pages, blue/white on others, etc - it gives me a headache to toggle between, try to also keep the same resolution/feel among each slide - some feel very zoomed in, others wider out, etc - nobody wants to adjust their browser zoom as they go slide to slide, also, try to get rid of cheesey animations like the slide-up animation on your home-page - it makes it feel like a powerpoint presentation. Anyways, definitely a good first-effort/starting point, clean up the design and make it feel more professional and you're in business. Good luck! Edit - I also noticed that monkey-top-right, when you choose to hide it, it still shows the cursor: pointer property for that element (despite the image being hidden), you should modify this CSS property in your JS/etc when you also hide that element, else the hover cursor pointer will continue to show. 
Sure.
&gt; Durandal (which was sort of the spiritual successor to Aurelia) Think you have that backwards. Aurelia is the successor to Durandal.
An approximation is to reduce the bit depth to 2 bits per component. Strip out the 6 least significant bits from each component, and you end up with 64 colors max. Otherwise, take the 16 standard colors and compare the (r,g,b) against your color, the closest one wins. Or you can do both, take the 64 "base" colors and compare them with your most basic colors, giving them the names. Then you have your lookup table. Edit: But there's already a CSS color table with 140 colors. http://www.w3schools.com/colors/colors_names.asp
really? It seems pretty smooth on my laptop, phone, iPad and computer library on chrome. Anyways. I fixed the Firefox issue what I did was check on the server if the browser is firefox, and if so I render out all of the HTML I normally dynamically lazy load. And then on the client side I disable the HTML fragment swaps. 
Money and rewarding people just doesn't work? Eh? 
wait, you were having issues with browser zoom? I thought my meta tag: **&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"&gt;** disables the zoom aspect. Anyways I think you're probably talking about the video carousel. Also I think the monkey thing is just the animation being applied to the containing div. While the fixed div I must have added the cursor:pointer property 
A Hideo Kojima javascript library, produced by Hideo Kojima, starring Hideo Kojima as Hideo Kojima in an original story written by Hideo Kojima and also edited by Hideo Kojima
That would work just fine. 
In non-ES6 projects, you can similarly implement testable singletons with the pattern service.js module.exports = new MyService(); consumer.js var service = require('service.js'); service.spec.js var Service = require('service.js').constructor; This is much, much simpler than having a service layer, and it's so much nicer than having to add bullshit '_reset' methods on your public interfaces. 
How does NG2's DI couple your code? I'm not that au fait with NG2 and how it does things - I checked out mentally when I heard they had to write their own HTML parser for their crazy markup syntax - but I'm curious all the same.
Are we just aying random words now? Turkey creampie
Right. And `.map` (and `.ap`) are both trivially derivable from `chain`. It's important that the behavior for all be consistent (and use matching, coordinated names) because that allows people to code in a pointfree-style that delegates methods to whatever type is passed in. i.e., for ANY legitimate Functor, `map = (f, xs) =&gt; xs.map(f);` and for any legitimate Monad, `chain = (cf,xs) =&gt; xs.chain(cf)` With that sort of behavior in place, we can compose Functors, Applicatives, and Monads with ease. And much higher-level abstractions are possible. For instance, in the case of [Lenses](https://medium.com/@dtipson/functional-lenses-d1aba9e52254), a simple implementation depends on being able to use a delegated `.map` methods for Identity and Const Functors that both precisely obey the Functor laws: that allows for a value wrapped inside a particular sort of Functor dodge mutation for one case but not for another. The same is true for Monads: complex abstractions are made easier as long as things obey certain basic expectations. 
You import the thing you want to DI through ES6 modules, then specify it as a "provider" for the thing you want DI'd. Scroll to about [20:30 in this video](https://www.youtube.com/watch?v=R62iQvZ0bdQ&amp;feature=share). You can also enjoy other [highlights I found in that video](https://www.reddit.com/r/javascript/comments/48stdu/angular2_beta_rxjs_typescript/d0m8enz). 
No, your coding for zooming/etc was fine, the aspect ratios you elected (e.g. how big your general design layouts were) fluctuated a lot and felt off as I went from tab to tab.
So I use an ES6 import just for Angular to parse my constructor's signature anyway? If my service has a unique type shouldn't that be unnecessary?
FWIW, React's community has a [catalog of composable, reusable components](https://js.coach/react). I've already found myself composing mobile user interfaces from React Native's catalog, which is one reason why I'd rather adopt React than Web Components. Another is that : &gt; &lt;link rel="import" href="http://example.com/elements.html"&gt; Is just plain old slow. So what if I have a page built of 100 elements? How do I manage all of those dependencies? In the React world, you just throw it into `package.json` and your bundler (Webpack typically) merges everything into one bundle which is sent to the client, only once.
I think it depends if you have a singleton or not. Those are "providers" on the app-level, and non-singletons and "providers" on whatever you need. My favorite part of the video is a bit later on when the guy gives a "helpful" tip of exporting an array of things you'll need provided often, for convenience. Then you can just import the export default provide array so that your module's provide's provider is more clean. 
&gt;As far as I know, CMake has nothing to do with caching, it organizes files and manages your Makefile. You can write makefiles properly by hand, but that is very time consuming. CMake makes everything much simpler. It's basically "convention over configuration". Sure, you can cobble up big blobs of bash scripts and makefiles, but why would you want to do that?
Looks like http://blog.vjeux.com/2013/javascript/jsx-for-the-real-dom.html
Thanks for clearing that up! I personaly like the way bash scripts work much more then how most build process are setup, either configuration (fx. webpack) or convention (fx. gulp). The sequential nature of piping in bash, seems so much more convinient, due to the fact that it's made with combination of different tool at heart. I guess we just have different opinions on the subjet!
Awesome! yeah I slapped this thing together in like 2 weeks (majority writing and doing the non coding parts like videos and "articles"), so there are many extra performance things I could do. 
Thank you for responding. &gt; There's no way to pass data You have couple options here. If you want a pure markup based experience you could nest the complex object inside the one you want to give it to, of give the ID of the data object to the target/receiver. Or in JS you just give it to a property or method on the receiver's JS API. &gt; No good way of reusing shared logic I would expect browser caches and the eventual ES2015 module loader to do this for you. &gt; Managing the DOM is very imperative and fiddly This isn't the problem Web Components are trying to solve. &gt; Web components aren't meant to be used for an entire application Web Components aren't a framework nor a replacement for a broader scope framework. There has been an awful lot of miscommunication and misunderstanding around Web Components, a large amount coming from proponents. The value of Web Components is that it provides a solid set of tools to encapsulate and insulate bits of DOM and code from each other, while still letting them share the page in a productive way. It provides the rules and tools for different components from different frameworks to not kill each other when they meet on the page. That's it. 
Yea, exactly - Like I was saying before, design is always the hardest problem. Your code itself seems lightweight, functional, etc - didn't find any issues there ;). Nice work &amp; good luck!
There's a tool called vulcanize that I refer to that can bundle html imports FYI. Additionally, you can set html imports as async ( since they are sync by default ) and not have them be a blocker to page load.
Oh design is really hard, especially since it's one of the most important aspects of branding. The color schemes and contrast, conveys a tone and affects how users value and perceive an app. My issue is I am on a race to finish it as fast as humanly possible, so that I can get back to normalcy. 
The spec may be in flux, but is there not value in the polyfill and Polymer.js and other libraries that make you not have to care about the state of the spec?
That's surprising it wouldn't work in PhantomJS, old chrome build? or is it built off something different.
I agree with you, web components need a more efficient way to list their dependencies. That'd make a great project.
What does writing games (which requires low level interaction with gpus/3D libraries like OpenGL) have to do with writing build systems? Plus most AAA game engines have and use a scripting language e.g lua (CryEngine, WoW, Civ), UnrealScript (Unreal Engine 3), Javascript/C# script (Unity). &amp;nbsp; It is also possible since to write node addons in C/C++ and use them from JS. This lets users of your module just write javascript but leverage the C/C++ libraries., check out node-qt for an example. &amp;nbsp; The main issue here is the extra complexity you are adding by switching languages and to ones that are harder to develop in and harder to maintain to boot. &amp;nbsp; With things like file watchers etc building just the files that change you are talking a few seconds per build while developing, usually the time it takes to switch back to the browser. When you need to do a full build, well your CI system complete with build box and test suites do that for you. I would hope your automated tests including selenium tests take around as long or longer than your build anyway so it isn't like it will ever be instant.
I never used anecdotal evidence, I am guessing you don't know what that means either (like you when you didn't know what experience meant a couple posts up). But no worries! I am here to help. Here you go (from:http://www.merriam-webster.com/dictionary/anecdotal%20evidence): evidence in the form of stories that people tell about what has happened to them. So see when you said "I don't care if animation/formatting is ruined. So the experience is not ruined for me. What does ruin the experience for me, is pages not scrolling when I want to scroll. Seeing a few out-of-place animations or whatever is a mild annoyance but I want to get on with consuming the content of the page and damn the animations." and used it to claim "your choice to prevent your users from getting to the content is harmful" You were using evidence in the form of stories to claim a point that wasn't based on science or data, but rather your opinion. No if you read mack through my posts, you will see that I never made a claim using anecdotal evidence. Hopefully now you understand the meaning and learned a little something. What's wrong with turkey and creampie? They are some of my favorite Thanksgiving dishes.
You've provided nothing but anecdotal evidence yourself, and having several people tell you of *their own experience* when it is the experience that is the topic is not anecdotal. There's your data, the statement of several people vs your anecdotal tripe "but there must be an exception!!!111!." I understand the meaning just fine, as I do of experience. You really do have a knack for forgetting things really quickly. Or rather I suspect just being obtuse for the sake of being a prick for prick's sake.
Hi /u/ethode-jables, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `ethode.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [ethode.com](/search?q=%28and+site%3A%27ethode.com%27+author%3A%27ethode-jables%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|100%
What did I forget? Please show me the claim I made using anecdotal evidence. Your comments are becoming less and less relevant, you can't answer anything correctly. Now might be a good time to just say you were wrong and move along. 
I'm not really sure where you're going with this? I agree with you that using JavaScript takes a lot of weight off the developers shoulders, and that's the main point of scripting languages! But as you say yourself, a scripting language is always backed by an engine or some sort of system, because the scripting language it too slow. Often if now always it takes longer to transpile/build the code, then it takes Alt+Tab to the browser! 
80% of the time, couldn't I just achieve the same thing with Promises? They handle rejections monadically too.
I'm using the latest PhantomJS (2.x) and latest stable Chrome. Chrome doesn't need to be polyfilled so it works as advertised. The polyfill does not work as advertised in PhantomJS. I don't know if it's a PhantomJS issue, a Shadow DOM issue, or something else, all I know is that it doesn't work and I'm not really surprised given the task that's trying to be accomplished.
i never argued it was faster, i argued that in a dev environment the performance cost is negligible. we're talking about the difference in milliseconds for common tasks after all. you have to have a pretty meaty build step (as in, you're probably doing too much) for the time lost with scripting to *eventually* be enough of a cost.
Reminds me of [this](https://xkcd.com/927/).
Except I never said that. I actually said that I agree for the most part scroll jacking is annoying, however, others might be able to find a way to use it in an efficient way that could improve an experience. I don't even know what a "listing screen" is, so I am pretty sure I haven't commented about that. I never even posted a link to my site. This was my first debate with a retarded person on the internet, it was kind of fun at least... good day.
What do you mean, more specifically? F# is a full member of the CLR, and as such has all of the mechanisms C# developers use to organize their code. Namespaces, classes, whatever. It can call into and orchestrate C# code just fine, and C# code can, for the most part, interop reasonably well with F#. I actually like it better for some OOP stuff since it's just so dang terse. The only unique thing about it is F# strongly encourages what is called "onion" architecture. F#'s compiler is a very *strict*, top-bottom, left-right compiler, meaning you have to organize your files in the way that they will be compiled. You naturally end up writing code where all of your dependencies are the top of the project, and all of the down-stream code is near the bottom. F# can just as easily power microservices/SOA. You can make tons of atomic F# projects that do one thing and only one thing in a .NET solution. F# produces assemblies that can be referenced, just like C#. If you're referring to the more functional side, then, like scala, F# is multi-paradigm. The functional paradigm is suited particularly well for some kinds of problems. For example, writing very functional code often means you have absolutely no need for DI or interfaces - the signatures of functions *are* interfaces, and trivial to stub/mock. One of my favorite talks is by Mark Seeman on the subject of [avoiding test induced damage by writing more functional code](http://www.infoq.com/presentations/mock-fsharp-tdd).
Promises are inherently asynchronous which would further complicate this would be otherwise normal synchronous code. But you can kind of look at this as a promise-like api on top of synchronous try/catch similar to what might be the opposite of what async/await is doing with promises.
Thanks for this insight. Have you ever had a chance of looking similarly in depth at Riot?
I can't honestly think of *any* language that would be comfortable with you having that much downstream code in one project. It'd certainly be uncomfortable to maintain. What do you mean by a "component" in this situation? 
 [data-component="news-menu"] .title { font-size: 18px; font-family: helvetica, sans-serif; } Why not, simply, news-menu .title { font-size: 18px; font-family: helvetica, sans-serif; } ?
Why without Babel? Couldn't you build it as a Babel plugin?
You can go back through the messages on GitHub to see. This is how I understand it: IBM were being very slow dealing with a security issue. Doug Wilson was letting off some steam to another contributor via text message... and said person then shared his complaints with a bunch of people at a conference they were at. When Doug Wilson found out, that's when he posted the ragequit. [edit]This is obviously just the straw that broke the camel's back.
I certainly can't speak to enterprise java, but I would say it's very unusual to have that much going on in one project. I haven't seen anything like that in enterprise C# - it's almost entirely onion-y SOA. However, in F#, it'd pretty much be the same organization if your project was 10 or 100 files. You have modules, which are made up of functions, which all accept all of their dependencies as arguments. You have a lot of tools, like piping, composition, and partial application, to make it easier to deal with that. 
Uhh, is this a press release? If you want to astroturf, I don't think this sub will appreciate that too much.
I doubt it's significant, but it's not cheap to unwind the stack, usually. It's one of the reasons people say to not use exceptions for your error-handling. e: from the page: &gt; [...] also because try/catch blocks prevents your function of being optimized so using tryfn MAY give you performance improvement
&gt; listing screen That was meant to be "loading screen" and somehow swype turned it to that. Though it was obvious what I meant, but eh.. deliberately obtuse prick gonna be obtuse. Still not going to address the lack of data on your part I see. Oh well, bye.
Wants are not needs. If "the many" wanted to donate $ to pay "the few" to build such tools maybe it would be different. As it is, most people do this for free out of generosity.
Here you go bud. Let me know if something is unclear. const playerManager = require('../whatever/path').playerManager; describe('loadPlayer test', function () { let spy; before(function () { // We will need to mock the pc object and the socket, so create them somehow this.pc = { /*Your pc object*/ }; this.socket = this.pc.getSocket(); // Spy on the once method spy = sinon.spy(this.socket, 'once'); // Now stub pc's getSocket method so it returns our special version of the socket sinon.stub(this.pc, 'getSocket', () =&gt; this.socket); // Run the function with our special pc object playerManager.loadPlayer(this.pc); }); after(function () { // Clean up after ourselves this.pc.restore(); this.socket.restore(); }); it('calls socket.once() with a data callback', function () { assert.equal(spy.callCount, 1); assert.equal(spy.firstCall.args[0], 'data'); assert.equal(typeof spy.firstCall.args[1], 'function'); }); describe('callback', function () { let callback; before(function () { callback = spy.firstCall.args[1]; }); // Test the callback here }); }); Edit: formatting
One of my most upvoted comments [was this one](https://www.reddit.com/r/javascript/comments/47s9o8/im_closing_down_express_50/d0fdm5m?context=3) attempting to explain wtf happened when he canceled 5.0. There's a lot of additional context in the children comments.
Well, I've had someone try and tell me what the "future" of javascript development would be quite a few times now, so you'll understand if I'm a bit skeptical. Can you give me an executive summary about why I would care, without buzzwords?
Here is the question link again: http://stackoverflow.com/questions/36136078/implementing-lll-algorithm-as-been-said-on-wikipedia-but-getting-into-serious-i
You should note that the inventor for Aurelia (who also wrote the impressive micro caliburn mvvm library) actually ended up [working with the Angular team](http://eisenbergeffect.bluespire.com/angular-and-durandal-converge/) before [leaving](http://eisenbergeffect.bluespire.com/leaving-angular/) to create Aurelia. You can get a lot of these opinions right from someone in the trenches by reading his blog: http://eisenbergeffect.bluespire.com/ 
Dunno if you reported it or not, but I did and it was quickly removed (from my perspective). Sometimes people have no idea how responsive the mods are, but on this subreddit the report button works pretty well for clear spam like this. (Though honestly he seems more like a True Believer than a simple spammer.) 
I evaluated Aurelia vs Angular 1.4 vs Angular 2 for my most recent project. We ultimately went with Angular 1.4 because we expected a production release in Q1 and didn't know if the other two would be out of beta. That and everyone was familiar with Angular 1.4. Have you had any issues with SystemJS? I seemed to do nothing but fight with it all the time during my evaluation. Aurelia now has webpack support, so I was going to check it out for my next project.
Can't say I'm a huge fan of the animated gifs everywhere.
React is definitely a "roll your own" framework
I'm just trying to understand why you want to use JSX without a vdom implementation. Do you plan on doing the diffing yourself? Are you just going to constantly replace the element on the DOM? Are you just going to use it for the initial paint, then do modifications by hand? I just really haven't heard of anyone wanting JSX outside of react.
It's awesome and I totally back experimentation with alternate JSX output. What I'm trying to dig into is what specifically makes you see "without Babel" as positive rather than a negative :) Are you thinking of Babel 5's "include everything" approach? With Babel 6, none of the transformations are bundled in and it is essentially a pre-packaged framework to do parsing + scoping + codegen just like you're doing. None of Babel's ES6+ plugins are included by default in v6 because we want Babel to be a framework for AST transformations so that developers can avoid custom-rolled transform logic like this module. Given that, I'm trying to understand the cases for when it would be more desirable to use a whole separate loader as you are doing, vs using `babel-loader` with a plugin to perform this transformation. 
Yeah, you'd do the diff elsewhere. I'm using JSX outside of React. I guess this is a start?
Agreed, looks terrible and drastically reduces readability. 
Saved for later, thanks! I'd suggest adding riot games' API too in the games section. It's fun to play around with such large amounts of data for their game!
While I don't necessarily feel like this is a hit piece, I do think that it tries to expose problems that aren't really problems. So I'll provide a counter-argument (where it's prudent) to some of these: &gt; * Boilerplate. If you compare an angular component to a react one, it'll be somewhere in the neighborhood of 25%+ more. Those numbers feel arbitrary and are going to vary based on what your component is doing. Furthermore Typescript is naturally going to be more wordy than pure JS. &gt; @input and @output are the most clear example of needless boilerplate I've seen in a long time Both of which are optional syntax that can be defined as properties on a component *exactly* the same way you'd define props or events on a React component. &gt; * DI. ... Honestly, no clue how they came up with this one, but it's by far my least favorite part of the framework. DI is just an implementation of a design pattern. And it's an odd "negative" given that one of the advantages it provides is reduction in boilerplate which was the first complaint. DI is "needless" in every language, since it's just a single design pattern for dependency resolution. &gt; * Silly confusing template syntax. There's no more room for the argument that angular uses HTML templates And React uses JSX and Ember uses HTMLBars. This is an odd complaint because there's no framework that doesn't use a templating languages. Judging by your bullet points, I'd say your problem isn't Angular, it's the paradigm they selected. There's nothing wrong with disliking event emitters (I don't either), but there's also nothing inherently *wrong* with them, any more than there is something wrong with DI or template syntax. They are just preferences, and I think it's prudent that we are all careful not to conflate our opinions with actual issues with any given framework.
JSX makes for a nice template language too by the way, even for people who don't want to do vdiff. I'd have happily used it over Handlebars and its ilk, and especially I'd love to use it instead of the angular goodness.
I'm glad Facebook has http://facebook.github.io/jsx. It helped me implement nativejsx with good coverage of most JSX features. My main point is that JSX is commonly lumped together with React and transpiled with Babel. nativejsx is just reaffirmation that JSX can and is used independently.
No worries! My main purpose is to help JSX stand on its own.
Using latest version of chrome with other tasks in background mine sits around 0.5-1%
We should write tools using [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly) and run our build tools natively in the browser! Who's with me!?
Woah, what's your 30 second build step, bud? 
That moment when templating engine compared to full stack framework
Interesting, Mac or Windows? I'm on Mac with Chrome version 49.0.2623.87 (64-bit) 
Good point
fixed!
Thanks, done! That also solved the firefox issue. 1 stone, 2 birds :D
I think it's a very cool project. Kudos. 
Windows 
Seeing as nobody seems to give strongloop any crédit, I'll chip in. I started a production level API with loopback 15 months ago. It's built on top of express, for sure, but it'd be more accurate to say it treats express as the route middleware of an app whose core value is in its ORM and multi DB engine connectors. There are at least 8 full time engineers working on loopback and zero working on express but, cmon, just how much else do you want to do on the freaking router? Add http2? No can do. Add anything that can be treated as a middleware? Doesn't go in the core of the router component. And so on. Thing is, I could have built this API on top of barebone, vanilla express, but it would have meant a lot of boilerplate code and I guess in that case, if loopback had not been available, I would have chosen hapi. So you might well say that, by building loopback, Strongloop contributed to keep express a relevant component in a world where express by itself doesn't cut it anymore. Okay, bring the pitchforks already.
I'm all for it!
What are people using as the M*C part in their react applications? Ive heard of people pluging in backbone, angular and even ember. So far it seems like many people use something like Exprss and then make build their own.
&gt;but with wasm you don't need to worry about that silly scripting language from the mid nineties Seriously? Does author know we have ES2015/ES6 nowadays? And the remark about Perl, I have no idea what you meant...
Or babel for transpiling syntax and bluebird to promisify anything and everything for which promises are desired and rely on the main branches of nodejs. 
No kidding? Thing is, I don't know the DOM that well and I probably couldn't reverse a binary tree or whatever the hell they ask you to do in tech interviews. Maybe I do have a skewed perspective, but then academia does encourage you to think overmuch about the challenge and necessity of obtaining mastery before attempting too much (why else torture people through the practically useless drudgery of completing a Ph.D. in the first place?). But you're also not the first person to tell me something like this. I guess I either have a hard time believing it, or my time as a grad student has affected my confidence. But I do love to code, and I've been doing it since childhood at least as a hobby on and off. I also agree about code as poetry. I wish I could somehow communicate that to my non-coding colleagues, though there is some interesting work being done now in "code studies" such as it is. My actual area of expertise is Shakespeare, which is fulfilling, but the job market is really tough. I started learning Haskell to stimulate a different part of my brain. I was also attracted to its alleged difficulty (well deserved). Then I thought the only way I could figure out monads was to implement one myself. Ditto a linked list. Then I thought, well, why not make a library? Why not put it on GitHub? npm? Hey, maybe I could at least get a job as a technical writer if I document it well enough. And so on. So, once again, thanks for your encouraging and thoughtful remarks. I can't tell you, really, how much I appreciate them—especially given that this is my first substantial foray into the open source world. Let me know if you have any questions or suggestions about the library (in a GitHub issue). As for Joyce, revisiting Ulysses is always worthwhile. In New York, there's a performance venue called Symphony Space where they host an annual celebration on Bloomsday and read/perform excerpts from it live. For many years, the actress Fionnula Flanagan would read the entirety of the Molly chapter. You were a pretty tough customer if you could last until the end (generally 3 hours, ending around 2 am, iirc). There may be some YouTube videos. Finnegans Wake, on the other hand, is hard to enjoy as something to sit down and read, but I had great success going through it with a regular reading group a few pages at a time one year. Sounding it all out is fun. Probably something the weird literature types would enjoy.
Hey there :) happy to see an other html5 gamedev :p I found some workarounds. This problem is the same on android ;) the reason is "you can't load audio/video file on mobile without user authorization" this is because it can be very heavy for the mobile bandwith. On android, it seems that's it's okay if you are on wifi. But anyway. To fix this here's a protip: - make a "touch to start" screen - inside this first event, start to play all your audio files with a short stop after 20 ms (very nasty hu ?) - now your file are loading, you can play/stop them when you want. I'm steel looking for the best solution but this one is the last I tried. Also you cannot play 2 sounds at the same time, it's very bad for "games" because in the most of case you are playing a BGM + SFX. The best is to only play BGM :/ otherwhise the music stop, play SFX, restart BGM, this is a bad user experience.
and I'm also looking to implement this trick inside my engine, but have to do more test first!
It's just, I'm on reddit, and there's tons of places I can go to find all manner of gifs that I want. I don't go to this sub when I want more gifs, and I don't expect prose here to have a gif for every paragraph, like some kind of buzzfeed tax.
Hey, I don't really want to get into a tic-for-tat, so let me clarify a few things. The problems aren't necessarily that angular has DI and angular as HTML templating. The problems are that angular's DI and their HTML templating isn't very *good*, and they have problems: * Their DI is a very unusual implementation of DI. I say this from working in a lot of enterprise C# code, where DI is pretty much necessary to fully understand. With DI, you want to try and make your code more *loosely-coupled*, and you want to use it to resolve dependencies without needing to know how to factory types. The latter is already provided to you by the ES6 modules, and the former angular actively goes against by requiring you to tightly-couple your DI's `providers` with direct references to what you want DI'd. (Also, a good 80% of the reason to use it at all is just to resolve interfaces, since otherwise your code wouldn't be unit-testable. This is a non-issue in javascript.) * Their HTML is silly and confusing. I say this because, compared to something like handlebars or JSX which has very little new syntax, the ng2 templating system seems to be almost entirely new syntax. There's code like `([ngModel])` which doesn't even *look* like valid HTML. It's case-sensitive, unlike any other HTML templating system since ever. And while yes, a lot of it is optional, that brings me to my next point ... * Angular is opinionated Yes. You can not use the DI in angular. Yes. You don't need to use all of the awful html syntax, and you can use more english syntax. Yes, you don't have to use typescript. Yes, you don't have to use some other parts of the library. But all of the documentation, all of the real-world code you'll come into contact with, and all of what the library *wants* you to do amounts to using all of that. This is called *the angular way*. If I wanted angular, without the DI, without the awful HTML syntax, and without stupid things like event emitters, **I'd just use vue**. If I wanted vue but I didn't want the html templating as well, I'd use react. If I wanted react but didn't care for JSX and wanted some things like routing baked-in, I'd use mithril. Angular is no longer the only kid on the block. It has to be competitive if it wants to stay relevant, and, increasingly, angular 2 is not competitive. I say that, recognizing I am not an unbaised person on this subject, but also recognizing that I'm not alone in thinking that here.
Express can't be compared to Backbone or Angular. Express is a server-side framework. Most commonly I believe people use Redux with React to set up an MVC-ish structure--it's not really MVC, but it gives "structure" to your application in a similar way. But the thing many people like about React is that you can plug it into almost any other library or framework and they work together.
I haven't really had issues with SystemJS on its own, it's more of JSPM + SystemJS combined causing trouble. Most of the time, the trouble comes about when there are multiple forks of similar dependencies. E.g. module 1 and module 2 both depend on module 3, but module 1 depends on module 3 0.0.1, and module 2 depends on module 3 0.0.2. Once I got it all working it's been fine most of the time, but every now and then I'll do a big dependency update and have to troubleshoot some weirdness. We use TypeScript, so I'm interested in seeing if I can make this work with Aurelia: [With Latest TypeScript, you may not need webpack](https://medium.com/@vivainio/with-latest-typescript-you-may-not-need-webpack-417d2ef0e773#.wc5i0kee4)
You can start playing a silent loop sound on first user touch capture and loop it forever. After that you can trigger sounds via code. You'll probably also need to look into AudioSprites. You should take a look at the Phaser.js source code (or use the awesome library linked above) for ideas on how to implement touch sound activation and AudioSprite management. Cheers!
I'd say that PHP is the glue these days. And I don't mean that PHP is *better* than Perl (or vice versa), just that it's much more common.
WebAssembly is here to complement Javascript, you won't see much high level stuff being coded in C/C++ for WebAssembly. Rather, you will see intensive low level stuff like game engines, computer vision, etc, being coded in C/C++ for WebAssembly and you will have a high level JavaScript wrapper on top of it. So, no, WebAssembly will not and is not even meant to break the JavaScript monopoly. It will probably make it stronger.
Hey a fellow canadian JS dev! :) Fun fact, the first time I had to face mobile audio challenges I did it on a little html5 game project called Jam and I stumbled on your company's website while researching the source material for the game. The website looks great good job! This was the game I made with the same name as your company: http://jam.tfo.org/jeu
[removed]
I prefer [esdoc](https://esdoc.org/). The documentation it makes seems nicer to me; it was built with extensibility and plugability in mind; it's been adopted by many frontend groups, meaning it's well integrated with flowtype and typescript and so on.
It's difficult to see why WebAssembly would make Javascript monopoly stronger, so it would be better to make your reasoning explicit. If anything, WebAssembly would intuitively make Javascript's dominance weaker, because Javascript would be just another language targetting a compiler, and not even the most performant one. And I think that even if Javascript is more usable (or even less), the difference in usability is probably not that interesting, versus, say, Swift, Go, or Rust. If anything, other languages might encourage more maintainable code.
How can I use Any of those in my javascript? Plugins or some already defined functions are their? 
npm install edit: glad I get downvoted for the correct answer.
This is cool. Gracias.
Front end and back end routing are 2 related but different concepts, especially as everything becomes more RESTful. 
You're going to have cross domain issues, have a look at the first answer on this. http://stackoverflow.com/questions/3076414/ways-to-circumvent-the-same-origin-policy
What if the client needs a component, or should they all be loaded at the start?
This. I often see these libraries advertising massive size gains over React, but the React team isn't stupid. These libraries are not doing some (many?) things that React does, and none of them talk about what those gaps are. It's for this reason I can't justify dropping in one of these, I don't want to be surprised when some weird user config 6 months from now breaks my production build because Joe Developer decided the React team was overlooking an optimization. 
You're not going to like this, but you'll have to JSON serialize it and then deserialize it. Usually, you won't need to maintain complicated relationships between your data that goes down to the client - what exactly do you need it for? As for synchronizing, you might be looking for an ORM like [breeze](http://breeze.github.io/doc-js/). Otherwise, that's going to be on you to do, as well, usually by some kind of API.
Neat. Is there any discreet advantages over just hitting the start key and typing? 
Awesome, thank you, will watch this.
Faire enough, you could use WebAssembly without JS. Heres some good read on this that might change your mind: http://www.2ality.com/2015/06/web-assembly.html https://github.com/WebAssembly/design/blob/master/FAQ.md The general idea is that yes, other languages will be able to be compiled for the web, but that JS will always remain the higher-level language. Which means that people will be able to develop libraries in other languages to be used in JS applications. It's true that this gives other languages a chance at staying relevant, but it also means that JS remains the dominant language. From the official WebAssembly repo FAQ: **Is WebAssembly trying to replace JavaScript?** No! WebAssembly is designed to be a complement to, not replacement of, JavaScript. While WebAssembly will, over time, allow many languages to be compiled to the Web, JavaScript has an incredible amount of momentum and will remain the single, privileged (as described above) dynamic language of the Web. Furthermore, it is expected that JavaScript and WebAssembly will be used together in a number of configurations: Whole, compiled C++ apps that leverage JavaScript to glue things together. HTML/CSS/JavaScript UI around a main WebAssembly-controlled center canvas, allowing developers to leverage the power of web frameworks to build accessible, web-native-feeling experiences. Mostly HTML/CSS/JavaScript app with a few high-performance WebAssembly modules (e.g., graphing, simulation, image/sound/video processing, visualization, animation, compression, etc., examples which we can already see in asm.js today) allowing developers to reuse popular WebAssembly libraries just like JavaScript libraries today. When WebAssembly gains the ability to access garbage-collected objects, those objects will be shared with JavaScript, and not live in a walled-off world of their own.
Polymer isn't the same as Web Components. Polymer is Web Components plus things that Polymer has added on top that probably won't be added to the Web Components specs. The sales pitch for WCs are a common ground for components, but if you build them with Polymer then I have no use for them if I'm not using Polymer.
I have various build steps that I have to perform for work (because its a Java shop). These builds can run anywhere from 4 minutes to 30 minutes. In my large personal project I have a build step that is only for unit tests, linting, file system checks, beautification, and some other stuff. The build step is not required to write or run code. I am between 8-24x more productive in my personal project than I am at work primarily because of this.
Yes, it's possible with [npmcdn](https://npmcdn.com/) but a bit tedious. We have a variety of other modules that are often used alongside `web-audio-player`, and we don't plan to roll them all up into a single file. e.g. - [detect-audio-autoplay](https://www.npmjs.com/package/detect-audio-autoplay) - [detect-media-element-source](https://www.npmjs.com/package/detect-media-element-source) - [ios-safe-audio-context](https://www.npmjs.com/package/ios-safe-audio-context) We use tools like browserify/webpack to create self-contained files. This way you can take advantage of npm for dependency management. :) 
We've gone on for, what, 5-6 responses? In that time, I don't see you robustly clashing at all. Your most robust response was a link to an FAQ saying, "No! We're not trying to replace JS!" If WebAssembly (1) can skip the JS bytecode stage and won't run in the JS virtual machine, (2) can have hardware support, (3) can call JS and is callable by JS, (4) can do everything interesting that JS can do but more and faster, (5) allows you to use your favorite language, then where is the need for JS? You seem to imply that JS will be needed for central coordination. Why? With DOM control, you can even have a multi-threaded React implementation in WebAssembly. In fact, any attempt to take advantage of multi-threaded shared-memory cooperation will mean that Javascript will be increasingly inept as a central coordination language.
YUIdoc you can use the @method tag for functions. You don't need to use @class.
Be patient, time will tell. I linked 2 articles including one from the team working on WebAssembly, and you still dismiss them with only your argument and not any other supporting your ideas. I might be wrong, these two sources might be wrong, and you might be right. But I doubt it. Cheers.
Hmm so on paper could you do a setup with an array of audio to silently loop on single tap then all of them could be called whenever I need to with code without interaction after that point?
I'd just like to interject.... but seriously this is just a partial implementation of [GNU Core Utilities](https://en.wikipedia.org/wiki/GNU_Core_Utilities) and some bash-like configurations in node.js. Little cocky for them to say "Cross-platform Linux without the suck"
I already use that shortcut for [Everything](http://www.voidtools.com/); I'll test Hain out soon, but it does look more extensible than either Everything or [Launchy](http://www.launchy.net/), which should compensate for the overhead of using Electron instead of native code.
Dr. Rauschmayer's site is a year old now, and so it's probably not his fault that the WebAssembly repo link you provided contradicts him with regards to skipping JS bytecode, not even running in the JS virtual machine context. I should mention the first planned deliverable of WebAssembly runs outside of the JS virtual machine. And if they're planning multi-threaded shared-memory features, then it becomes specially dubious for JS to be the coordinating language. It's not that the WebAssembly source is wrong. I think you just have the most superficial reading of it. Where do you think I get my ideas that the first planned deliverable won't be in the JS virtual machine? https://webassembly.github.io/, but you already linked there, so I thought you read it. I thought this discussion was based around (1) the MVP planned deliverable, and (2) pending features.
You might have a little help with the Javascript Deobfuscator extension for Firefox, or the standalone application from Kahu Security.
Got the same thing inside a zip as an email (spam) attachment. Looks gibberish. 
&gt; Also, if it's anything like Everything Highly amused by this phrasing
It's actually not quite true that sorting algorithms have the same goal. Maybe you want to do an in-place sort, or a stable sort, or maybe your data always comes mostly or partially sorted. Maybe you care about hard limits on worst cases, maybe you care about the average case. Maybe your arrays are mostly large, or mostly small -- there's sorting algorithms optimized for all!
This is correct, but it's ES6 only. You could polyfill it, but it may just be more straightforward to use a custom one, as unsatisfying an answer as that may be.
&gt; Awesome that gives me a better view of React projects in general. Would you say that an application can be built with mainly just react components and reducers, and possibly routes? Yes. Any CRUD-app fits what React offers. No unnecessary complexities. Just easy going fun, IMO :) &gt; Or is that really a case by case thing Perhaps. I've worked in complicated healthcare apps (with patient data, treatments, medications, doses, etc^infinity) - it would hold its own even there. I don't really see good reasons to complicate things further. &gt; or bad practice to try and cram everything in its own component? A component should be as specialised as possible, I think. Cramming more into 1 component could work if separating it wouldn't make much sense. After all, it'd be easy to separate it later on. For example: a FAQ page could simply be a page with a header, intro text, a list of questions and answers, and a "ask more" form. Or you could separate that in a `&lt;Route path="faq" component={Faq}&gt;` which consists of a `&lt;PageHeader /&gt;`, `&lt;PageIntro /&gt;`, `&lt;FaqList /&gt;`, `&lt;FaqElement /&gt;`, `&lt;FaqQuestion /&gt;`, `&lt;FaqAnswer /&gt;` and `&lt;FaqForm /&gt;` component. Might be useful. Might be unnecessary. Common sense kinda applies is what I'm saying ;)
I used to use Launchy, then swtiched to the Start Menu, now using Listary. http://www.listary.com/ Hain looks interesting, how's the speed and memory usage? It's probably a non-issue these days but seems like Electron is heavy for something like this.
Hmm, maybe. But PHP doesn't get used for automation at all. Still, I wouldn't want to put down a wager on the amount of PHP or Perl deployed in the world.
I just learned about that spread operator today. Pretty cool!
Thank you for the comment. I added your suggestion to the code but still no luck. I also added validate Gram Schmidt function to code make sure Gram Schmidt calculate is done correctly but still no luck. Feel free to download the code and test it on your machine. Thanks. https://github.com/amir734jj/JavaScript_EMC6_linear_algebra_tools
Hey sorry for the late reply, I've been away. To answer your question as to when you would use this style over EventSource based APIs, EventSource requires you to have specialised APIs which (would normally) only be consumed by HTML5 clients where-as chunked-tranfser style responses can be consumed by any HTTP 1.1 REST Client (even if they don't process the chunks as they arrive they can wait for the entire response body). EventSource clients also typically expect the resource to continue streaming indefinitely (or at least for a sustained period) requiring the server to add some kind of terminator to the end of the resource whereas chunked-transfer responses are ideal for pushing partial responses for large record sets (eg: sending 500 records to the client as the result of a `listAll` style API call. Hope that helps!
That's very helpful thank you. The project I'm working on isn't completely a CRUD app. I've divided it into two parts mostly, but they both talk to the same api (there are two apis). I'm still working out the best approche, and I'm even wondering if the separated part should be wrapped into a component for certain cases, or at least use Redux for it.
Easy Concat in native javascript : Array.prototype.push.apply(array1,array2); What you have up there is a combing deep arrays and making them unique. const array3 = [[],[]]; // Push the first set Array.prototype.push.apply(array3[0],array1[0]); Array.prototype.push.apply(array3[0],array2[0]); // Push the second set Array.prototype.push.apply(array3[1],array1[1]); Array.prototype.push.apply(array3[1],array2[1]); // All values are in but not unique // This is only easily done in modern browsers otherwise it gets // Very complicated. array3[0].filter( ( val, index ) =&gt; array3[0].indexOf(val) === index ) array3[1].filter( ( val, index ) =&gt; array3[1].indexOf(val) === index ) I hope this helped
Yeah it was sent from myself, to myself. Nothing in the contents of the message besides the attachment 'Document 2.zip'. The file is harmless overall, unless uploaded to a web server.
Now that is an interesting bit of construction. I'm going to have to dig into Array.from a bit more and see what it can do. 
Array#includes is a bit too bleeding, let's keep it in ES2015: Array1.map((v, i, a1) =&gt; v.concat(Array2[i].filter(x =&gt;!~a1[i].indexOf(x))));
Still not working. I ran `console.log(txt);` and the console output is still " "
Redux for state management, which builds on the ideas by Flux, an alternative to MVC. IMO you don't need an "M"! Just use JavaScript arrays and objects.
If it takes that long you are doing it wrong. A file watch based dev build system should not take long to build just the changes. I work with an extremely large codebase every day on pretty low power machines and running all the transpiling (we use typescript), unit tests, post css, linting etc takes 2-6 seconds on a file change and our build system is far from optimized. A distribution build does however take a couple of minutes. A distribution build is another thing and that will take longer but that should be expected regardless of platform/language.
Exactly this. Only distribution builds take any real length of time even with large code bases unless you mess up your build system settings etc.
So the C can really just be Redux, having actions change the state, which can be considered the M. Redux actions == C Redux store == M And inside your views is where you might want to do things like add interfaces for actions that might call a server? If that's all okay, then you basically get your framework for free with Redux and React-Router.
&gt; Do not fetishize DRYing up your code at the expense of introducing the wrong abstractions. I think this is a distinction many developers struggle with. They see two pieces of code that look alike, and assume they must share a common abstraction. But there are all sorts of cases where this kind of thinking can mislead: 1. Perhaps the two pieces of code refer to two different domain concepts, and their shared implementation is a coincidence; 2. Perhaps each piece of code is at the right level of abstraction for whenever it is likely to be read and modified; 3. Perhaps the generalization creates a single point of failure in a system that cannot tolerate such things; 4. Perhaps the generalization involves a kind of indirection that is harmful to maintenance (e.g. swapping composition to inheritance because it's "DRYer"). You might say that these generalizations "violate a principle of locality"; 5. Perhaps the generalization will force different teams to simultaneously work on the same code (which is always a source of friction). DRY is a dangerous principle, because it is easy grasp, makes sense, is straightforward to apply and only usually correct.
I agree with /u/gavrocheBxN , first WebAssembly is a compilation target for the web. This means that the languages that will take most advantages of this are statically typed languages C/C++, Java, Rust and co. I'm not sure dynamic languages will be able to be so much faster, in fact browsers vendors are putting huge effort in having the fastest JIT compilers possible (for JavaScript) in order to support heavy JavaScripts application (GMail, Facebook). JavaScript is already tightly integrated with the web (DOM API, JSON) and already has a solid toolbelt of frameworks and librairies. Plus the new features coming with ES6 will bring native JavaScript development to a whole new level of structured development. You also seem to forget that current implementation of asm.js, [which run UE4](https://blog.mozilla.org/blog/2014/03/12/mozilla-and-epic-preview-unreal-engine-4-running-in-firefox/) is a subset of JavaScript. If you keep some constraints, like not changing the type of a variable every time, speed of native JavaScript is more than reasonnable. Otherwise things like Three.js or Phaser framework would not exist. It will take years before you can write a client side application without JavaScript, with the comfort, support and current speed of JavaScript. And we all know years in this industry is like centuries in others so we cannot really say that JS will be obsolete at this time. And during this time JavaScript will continue to evolve, provide new features and gain momentum. So yeah I think JS will still be the de facto choice for webdev for a long time. Note : I'm very happy for WebAssembly, as a pro webdev and amateur gamedev I see this as a great opportunity for the web.
So far it seems to be most people are using Redux and React-Router to complete their framework. Using http://www.npmdiscover.com/ and removing all the tooling, it seems like the top choices are in order: react-router, history, redux, react-redux, lodash... redux-thunk, jquery... A large majority of packages are simply tooling and linting, with a large part of that being ES6 tools, and webpack transforms.
Assertion: Angular2 has a fundamentally weak proposition and will be regarded as a quiet failure by the end of the year.
Your argument seems to boil down to, "WASM won't render JS obsolete, just because that's not the project's specific intention right now". Forgive me, but if the last twenty years of the web has shown us anything, is that the industry rarely restrains itself to using technologies as _intended_.
&gt; Can you go into detail about where angular 2 fundamentally missed the mark? It wasn't React. /s
I'm not saying that Javascript is about to be in trouble as a job skill. But I am saying that WebAssembly won't require Javascript as a coordinating language. I am also saying that according to the document in the WebAssembly repo, the first planned deliverable will have its own execution context separate from Javascript. It will not be compiled down to JS bytecode. If you want to make the more modest argument that Javascript will continue being huge in the job market for years to come, then I could easily agree with you. I would question, however, your assessment of Javascript performance. I think even on reasonably fast computers, world-class apps like Gmail still have perceivable performance issues and doesn't feel like a native app. I am concerned with what it means to not have Google-level resources. This is especially true on phones, and even the 37 Signals of Basecamp fame, which once advocated adaptive web apps everywhere, are now going native. It's also disheartening that Atom is criticized for being slow even though it probably has a team several times the size of Sublime Text, and it's also disheartening because, while I'm sure text parsing is difficult, it's still just a text editor in a stripped-down browser. That being said, I have a feeling the low-hanging compiler optimization fruits have been had, and I also have the feeling that CPU improvement is not coming anytime soon. One more thing about JS performance. I think people are starting to have a thirst for Web Workers, but the problem is that the Javascript language has no support for multithreaded shared memory features, so you basically have to roll your own strategy for thread coordination. WebAssembly could solve this. We could potentially have a multi-threaded React.
Love the customer testimonial by the Paypal guy. &gt; Looks swell. Gotta try...
It's a special kind of `undefined`, similar to being deleted: var sparse = Array(5); sparse.hasOwnProperty(0); // =&gt; false var empty = [void 0, void 0, void 0, void 0, void 0]; empty.hasOwnProperty(0); // =&gt; true var toIndex = (_, i) =&gt; i; sparse.map(toIndex); // =&gt; [undefined x5] empty.map(toIndex); // =&gt; [0, 1, 2, 3, 4] delete empty[0]; // =&gt; true empty.hasOwnProperty(0); // =&gt; false empty.map(toIndex); // =&gt; [undefined x1, 1, 2, 3, 4] delete empty[1]; delete empty[2]; delete empty[3]; delete empty[4]; empty.map(toIndex); // =&gt; [undefined x5]
If you do not believe we will ever see optimising compilers for WASM, then you must surely also believe that WASM modules cannot provide performance benefits over V8-executed JavaScript. This seems to directly contradict your earlier assertion about the value of WASM to JavaScript authors - namely its suitability to high-performance, CPU-bound calculations.
trigger warning
I think you'd have to reverse engineer the resulting .exe in order to determine the vulnerabilities being used. All this script does is download a file onto the victims computer. I don't think that requires any vulnerability by itself.
the first place you return a promise from should handle errors. everything downstream from that should assume there aren't errors. in the case of an ajax call, the code that makes the request should handle the error.
That's right. If you're not running Windows you have nothing to worry about. If you are running Windows I believe you have to explicitly enable your browser (IE) to download ActiveX controls.
Damn bro. Good luck or look for a new job :)
Do browser vendors plan to expose DOM/Browser APIs to Web Assembly binaries? I always figured it would be sandboxes kind of like the Web-Worker API.
I'm pretty sure JSDoc doesn't support ES6 yet. https://github.com/jsdoc3/jsdoc/issues/555
If you want them to bubble up "as usual", just re-throw them in catch: .catch(e =&gt; { throw e; }); 
If that worked, that would be slightly better, but it doesn't look like it works. new Promise(function(resolve, reject) { // ... Aray.prototype.push // oops // ... }) .catch(function(e) { throw e; // doesn't leave this catch function; lost to the abyss }); EDIT: I half take that back. I've been running these examples in node. And in node, indeed nothing happens. But if I run this in Chrome, then I get the exception.
That depends on how you want to handle that re-thrown error. I use that to re-throw from nested promises (when needed). However, if you want them to reach all the way to console, you can wrap them into a timer for example: new Promise(function(resolve, reject) { // ... Aray.prototype.push // oops // ... }) .catch(function(e) { setTimeout(()=&gt;{throw e}, 1); }); Interestingly, while I wasn't expecting for my first variant to throw into console, Chrome and IE do resolve promises and throw, while FF doesn't.
The method which i have used in my projects is the same someone else already posted. It goes line this var length = 5; var fn = function(el,i){return i;} var arr = Array.apply(null,Array(length)).map(fn); Edit: fuck formatting on phone, i can't get it to format, it won't recognize the spaces-.-
Yeah, I'm seeing inconsistent behavior across implementations too. But even if this worked consistently, I still consider this only *slightly* better. With ordinary synchronous exceptions, if you're not able to fix an error, then you just do nothing, and the error continues to propagate. This was good because it didn't require us fallible humans to remember with perfect consistentency to pass an error along. But now with these catch clauses, we're required to catch after every new "then" clause, often for no other reason than to re-throw that very same error. If anyone on the team at any time forgets to catch and re-throw, then an error goes unreported, and debugging nightmares ensue.
Mentally replace `catch` in your second example with an actual `try/catch` block. The error handling semantics are similar. But again, nothing is lost to the abyss - the computation is failed, and the promise is failed. This only results in something being "lost" if nothing cares about that promise failing, which should be never. 
Wow, that's terrible. Basically the previous guy was defining interfaces in javascript and writing functions by passing parameters to a function that returns a function, instead of just defining the function. Maybe consider using TypeScript to get rid of that crud if you want some level of type safety. Also, it's not against the law to name things in Javascript. Seems like every effort has been made to write things inline without describing what it does, plus using extra level of indirection when unnecessary. E.g. instead of db.query('SELECT * FROM table', function(callback) { callback(); }) ; You can say function doSomething() { // something happens here } db.query('SELECT * FROM table', doSomething);
&gt; Mentally replace catch in your second example with an actual try/catch block. The error handling semantics are similar. I wouldn't need a try/catch block at all. Anywhere. That was the beauty of it. If I can't handle an error, then I do nothing and the error continues to propagate. And if *no one* can handle the error, then it kills the program and reports what went wrong. But with promises, I'm required catch or the error goes unreported. &gt; But again, nothing is lost to the abyss - the computation is failed, and the promise is failed. This only results in something being "lost" if nothing cares about that promise failing, which should be never. Not all promises are about returning a value. Sometimes it's just about *doing* something. saveResultPromise().then(function() { alrt('Saved!'); // oops }); I can't rely on this sort of error propagating on its own. *Every* "then" would need an associated "catch".
First off, note that promises have *better* error handling than callbacks, which is what they replace. You're comparing them to synchronous code, but if your code is synchronous, you wouldn't be in this mess to start with. Second, you are making a couple of mistakes that are hampering your attempts at using promises. Notably, you need to assume that errors can happen anywhere within your code, and remember that errors will bubble up to the top level. You can handle them wherever is appropriate, re-throwing them if you don't want to handle them, but you do need a handler at the top level. You keep stumbling on the idea that every then block needs its *own* handler, but **THIS IS NOT THE CASE**. Errors will bubble up until something handles it. function doThing() { return Promise.resolve('test') } function doOtherThing(foo) { return Promise.resolve(foo+'bar') } let result = doThing() .then(x =&gt; x.toUpperCase()) .then(x =&gt; { return doOtherThing(x) .then(x =&gt; x.toLowerCasse()) .then(x =&gt; x[0]) }) .then(x =&gt; console.log(x)) In the above code, the first innermost `.then()` throws an error, this means that the second inner `.then()` is skipped, and `doOtherThing` returns a failed promise (because there is no `catch()`, which means that the final `.then()` of the outer block is skipped, and `doThing()` returns a failed promise. *But your error is not swallowed*, the promise is your result, and in this case the result was an error. If you want to do something with it, like print a stack trace, feel free: result.catch(e =&gt; console.log(e.stack)) Boom, done. You don't need multiple `.catch()` blocks, you just need one. Just keep returning the failed promise until you feel like handling it, then handle it. (Also, a hint: Newcomers to promises often make mistakes by creating too many promises. If you're creating a basic promise manually, it's almost always a sign you've messed up. Creating promises is also a common cause of issues with error handling. Your network library should return a promise from making an AJAX request (or whatever), and then everything you do should just involve accepting that promise and returning it.)
Oh, wow. I never thought of using `!~x` in order to check for `x === -1` after a `.filter()`. This is really clever!
&gt; This means only the "root" consumer needs to worry about error handling - usually the one who started the promise. You're not the first person to suggest that, and I've asked the others for a code sample, but no one has provided one yet. I made my own that implements what it sounds like you and they are describing, but it doesn't *behave* the way you and they described. function f() { return new Promise(function(resolve, reject) { resolve(42); }) .catch(function(e) { console.log(e); }); } f().then(function() { // ... Aray.prototype.push // lost to the abyss // ... }); The error here *does not* go to the previously defined "root" catch handler.
&gt; But your error is not swallowed, the promise is your result, and in this case the result was an error. If you want to do something with it, like print a stack trace, feel free: &gt; result.catch(e =&gt; console.log(e.stack)) This is actually part of the reason that I feel errors *are* swallowed. With exceptions, I have to do absolutely nothing, and unhandled errors kill the program and get reported. But with promises, we're forced to manually check for bad results and manually log a stack trace. If anyone of the team at any time forgets to do either of those things (and we fallible humans *will* forget eventually), then an error goes unreported, and debugging nightmares ensue.
&gt; Your final catch block goes at the end, not in the middle. I implemented it that way only because I was trying to understand what people meant farther up the thread when they said, "single catch at the root of the promise chain. (i.e. the call that starts off the whole thing)".
I used [Ghost](https://ghost.org/developers/), which is a Node-based blogging platform, along with NginX. There's a set up guide [here](https://www.digitalocean.com/community/tutorials/how-to-create-a-blog-with-ghost-and-nginx-on-ubuntu-14-04).
&gt; You need a try/catch if you want to handle the error. I'm not really sure how to respond to "I want typos to blow up my entire program" so I'm just going to let that one go. Don't let that go. This is the whole point. When we're writing programs and we make stupid mistakes like typos, I for damn sure want the program to blow up. That's how we find the problem quickly and easily. With exceptions, we have to go out of our way to suppress an error. But with promises, it's the opposite. We have to go out of our way to catch and report that an error happened. If anyone at any time forgets to do that, then the error goes unreported.
Tipping towards "Yes". It was a little off-putting at first coming from Angular 1. Even more weird syntax and Angular ways of doing things. [(*wtf)] After diving into it more, it's growing on me. It still seems familiar and the original concept ideas transfer pretty good. Yeah a little overly complex on certain things but they've cleaned up a lot of other areas and incorporated react ideas. Hopefully someone releases a good ide plugin for styling and auto complete. 
I think /u/lewisje meant http://www.voidtools.com/
[Seems like they have made some progress.](http://usejsdoc.org/howto-es2015-modules.html) Probably missing a lot of stuff but they do have some basics down. Edit: Actually, [according to their github tags](https://github.com/jsdoc3/jsdoc/releases), they fully support ES2015.
Nope, it sucks. Errors are swallowed. But note that 1. you can do one .catch at the end since errors propagate down the chain (so each .then doesn't need its own .catch). 2. Unhandled promise rejection tracking is in Chrome and will hopefully be in Node and other browsers soon (not to mention a standard like window.onUnhandledPromiseRejection). 3. Async functions make this much nicer IMO :)
Kinda, but not really. If you have a a `.then()`, you need a `.catch()`. If you're calling a promise returning function, write both. Yeah, your code won't work right if you forget the `.catch()`; it also won't work if you forget the `.then()`. if you want to use `fetch` to make an ajax request, you'll end up with code that looks like this: fetch('/api/foo') .then(resp =&gt; {/* handle response*/}) .catch(e =&gt; {/* handler error*/}); And the equivalent non-promise code: request('/api/foo', function (error, response, body) { if (error) { /* handle error */ } else { /* handle response */ } }) Forgetting to handle errors is a recipe for disaster; you can't get away with not handling errors just because you aren't using promises.
And the cleverness is exactly why it shouldn't be written in any code that someone else is expected to understand ;)
Thanks for the link. Guide seems really cool. Too bad Ghost seems like a paid software. I don't really expect to put too much effort into it, so I'm not sure if I'll go that route. Good luck on your project though!
You forgot to return your inner promises. &gt; To solve this, each of these distinct promise chains would need to end in a catch: So don't have distinct promise chains. Edit: appReadyPromise.then(function(app) { return app.whenComponentReady('some_component').then(function(component) { component.lookupThiing().then(function(thing) { console.log(thing); }); }); }).catch(e =&gt; console.log(e.stack)); One `return` was all it took.
thanks, well, looking at the sourcemaps in dev tools I started noticing that you can actually do a lot of stuff with the local filesystem in chrome, and in a breakpoint the code suggestions are fairly perfect (it doesn't have to guess). It is kind of funny because it was the lure of classes and whatnot of es6 that drew me in, but now I'm much happier not masking the prototype mode and getting accurate code completion and immediate edit/compile/run cycles in ES5/chrome dev tools.
Async functions are promises with some generator stuff going on. You can make your own async/await with a generator.
It's free. It's like WordPress where if you want to host it on their servers you can, or you can just download it and host it yourself.
I wanted to inline it into an object literal, so I was wondering if there was a built-in single-function solution. I ended up doing essentially what you have there, just putting it into a function. As for ES6, I mostly used that because the fat-arrow function literals are a lot simpler to read in the context of a post. 
ES6 only: `[...Array(100).keys()]` If you don't need the index, you can just do: `[...Array(100)]`
You can split this problem into 3 operations: 1. zip two arrays, e.g. take `[[1,2,3],[4,5,6]]` and `[[2,3,4],[5,6,7]]` and get back [ [[1,2,3],[2,3,4]], [[4,5,6],[5,6,7]] ] 2. Flatten the elements of the zipped array, so that it now looks like: [ [1,2,3,2,3,4], [4,5,6,5,6,7] ] 3. All elements of the flattened, zipped array must have unique elements. [ [1,2,3,4], [4,5,6,7] ] Here's what I came up with (I haven't tested this code): function uniq(a) { return [...new Set(a)]; } function zip(a1, a2) { return a1.map((el, i) =&gt; [el, a2[i]]); } function flatten(arr) { return arr.reduce((a, b) =&gt; a.concat(b), []); } zip(Array1, Array2) .map(flatten) .map(uniq); This takes advantage of the `Set` type in ES2015; if you want to skip this, you can also use `filter` as shown in previous posts.
It saddens me that we couldn't get a more concise list comprehension.
&gt; You forgot to return your inner promises. You're right. Good news, [there's an eslint for that](https://github.com/xjamundx/eslint-plugin-promise), and I'm starting to think every project should include this linting check, because neglecting to catch or return promises results in suppressed errors. Bad news (for me), my project at work is still on jshint. :-/
Also just found [this](https://www.digitalocean.com/features/one-click-apps/ghost/). Seems pretty perfect.
While true that you can get most of the functionality, you need more than a generator. You need a driver function (eg. spawn or co or something, not trivial to hand-roll). This is also difficult to do when you want to install the async function as a method on a class or object. You also don't get the nice syntax of `await` (eg. compare the semantics of `yield p1 + yield p2` vs. `await p1 + await p2`, the former means `yield (p1 + (yield p2))` while the latter means what you expect). Also async functions will eventually grow in capabilities (eg. allowing decorators). You're right, just wanted to caveat that statement a bit :)
This is a fun project I've been working on lately. It's pretty easy to write songs, but I was thinking it would be interesting to use this to audibly represent data too. Thanks for checking it out, -G
 [].prototype.push.apply(Array1,Array2); 
I was skeptical before using it but it is great to use. I think people got way too hung up on the initial announcement.
I heard it was out.
However bash scripts wont work easily on windows, and some people tend not to use bash. So it's not the most portable way of doing things.
What do you mean [this isn't helpful](http://i.imgur.com/we89FVm.png)?
NPM just republished left-pad under a new owner: https://twitter.com/seldo/status/712414400808755200 NPM is now showing their true colors. They're a private company who puts other companies' interests first before the developers that rely on them. But the author should have given the developers that relied on his module some warning before he did this.
Amusingly, angular 2 will have to fight off *angular 1* as much as it does all of the other frameworks. They recently updated angular 1 to 1.5 [with a very simple component syntax](https://toddmotto.com/stateless-angular-components/) ... that's arguably more simple than angular 2! Not to mention all of the apps already in angular 1, that will probably to be maintained for years to come. Angular 1 isn't going anywhere, but angular 2 has an uphill battle. 
They 'un-un-published' his packages. (source: @iza) So just remember guys, when you publish a package on npm, they will and can (and just have) change ownership of a package to someone else without any kind of legal litigation actually taking place. NPM - the youtube/source-forge of JavaScript
In NPM's defense, I can't imagine they have the resources to fight a legal battle with a corporation due to a single module they host. They're going to change that one module to avoid losing their entire offering.
Good sir, I already bookmarked that page in my reference folder. Thanks a lot! :)
They changed ownership because he abandoned those packages and he offered for people to take ownership of them, [which people have](https://www.npmjs.com/package/left-pad). &gt; So just remember guys, if you depend on a package on npm, the author could remove it for no reason. FTFY 
&gt; when you publish a package on npm, they will and can (and just have) change ownership of a package to someone else without any kind of legal litigation actually taking place. It sure as hell can take place, as long as whatever license you use allows for it. His, it happens, do not.
Trademarks do not give you wholesale ownership of a series of letters. They give you the right to protect a mark from competitors. Dude made a js equivalent to yeoman. Kik Interactive has no such product. This was a shitty company being shitty.
*cough* then take all your stuff off github */cough*
Technically...no. Azer left npm, and removed his project `azer/left-pad` from npm, at which point camwest published their project, `camwest/left-pad` to NPM. Who exactly is doing anything wrong, in this story? Azer, camwest, and npm would all seem to be acting ethically and legally. Is npm obligated not to let other projects use a name on npm after the first user leaves npm? If we want to be outraged at NPM, let's focus on them yanking the kik name; *that's* questionable. The left-pad issue is a dead end. Edit: FWIW, the [NPM dispute policy agrees](https://docs.npmjs.com/misc/disputes). There's no obviously applicable rule that would have let them re-assign the `kik` package, but there are clear rules that would stop Azer from keeping the `left-pad` package. Edit 2: At the risk of being pedantic, you said &gt; NPM just republished left-pad under a new owner This is not what happened; NPM allowed the owner of the `left-pad` package on NPM to re-publish the v0.0.3 version after verifying that the code was identical to the originally-published version. The argument isn't about who should control the `left-pad` package, nor over whether the new owner should be able to publish it. The argument is about whether they should be able to re-publish v0.0.3, or whether they should be required to publish the code as v0.0.4. It's easy to see the importance of an author's ownership of his code, or tof following license agreements. It's harder to see the fundamental importance of whether camwest can publish his `left-pad` project to NPM as v0.0.3 or v0.0.4.
If you have lots of isolated calculations to perform and you don't need access to any DOM elements, they work quite well. But that's really not most web sites. Most web sites need to do things like manage DOM elements (and/or model data that's indirectly tied to DOM elements) or make XHR requests or that kind of thing. Web workers are off in their own completely isolated environment and any data that they need to function has to be shuffled in and out through serialization (e.g. a round-trip through JSON each way), which really eats into performance if you are constantly doing it. 
&gt; Left-pad was published under the WTFPL public licence. http://www.wtfpl.net/ For the uninitiated, WTFPL means "Do *What the Fuck You Want* to Public License". I'd imagine that doing WTF you want can include taking my code, and republishing it under the same name to a privately owned package hosting company, regardless of if I've disavowed contact with that hosting company. It is WTF you want, not WTF *the author* approves of.
I wonder why NPM rolled over on this one. Are they ignorant as well? Lazy? Fearful of ligitation that has no grounds in reality?
Ah! This is a fun one. Any element with an ID actually creates a global variable for you to mutate on the javascript side of things. Almost certainly this is due to legacy reasons, and I cannot recommend avoiding relying on this behavior enough. You can shadow `randomVariable` in case of collisions. 
I use web workers extensively but they are buggy and have loads of undocumented limitations. Snap city :-) They work well when you have long running jobs that don't have large data sets. I write medical imaging software, I use workers extensively to parse out DICOM files and build arrays that I write directly to canvas, among many other cool uses. Rhomboid talks about serialization inefficiencies but the API has evolved a lot since this was a problem, you can push most raw objects and references.
Thanks, I thought this might be the case, trawling through the W3C spec I couldn't see anything related so I wasn't sure if it was a JS engine bug or intentional behavior. I'll definitely be avoiding it :-) Very weird when you remove an assignment yet the code still works! Cheers. Much appreciated.
I spent the past week working on a MIDI file writer in JavaScript: http://grimmdude.github.io/MidiWriterJS/ weeeee
not yet, but it should be added later.
this is what happens when you are not exposed to monads heres what it would look like if a non-shit promise api was used appReadyPromise.flatMap(app =&gt; app.whenComponentReady('some_component')) .flatMap(c =&gt; c.lookupThing()) .mapError(e =&gt; e.stack) .onError(console.log); .onSuccess(console.log); 
I never even thought to use jQuery as a data model. Now it's hitting me why people hate on it so much!
I never said trademarks can't be over a series of letters. My point was that if I trademark "XTV" that doesn't mean no one can ever use that series of letters in that order. Furthermore, the obligation to enforce doesn't require that you enforce it when there is no violation. For example, if I made a shitty messaging app and someone else made a yeoman-like project generator, I'm not obligated to threaten them because they aren't similar.
Exactly - when you want something done in an async manner at the next possible moment. In those cases I want it to be as fast as possible and don't care about the arbitrary delay in setTimeout. Some nice Promise polyfills use setImmediate over setTimeout(fn, 0).
let old code remain as it is. as rewriting is not an option. make sure that code you write does not use `x`, `y` or `z`and is properly structured and commented. If it were me, I would ---in lack of better documentation--- write every single design decision taken by me in comments next to the code. regarding unit tests. just automate whatever manual tests (unit or integration )you actually do. that will save your time more than blindly writing unit tests which you will most likely not use 
You don't actually need `deferred` in your code, the use case can be fully satisfied with regular `Promise`. Just do function loadMetaOf(name, list) { return new Promise(resolve, reject) { // ... whatever is inside of loadMetaOf with deferred bits replaced ... }; } `deferred` is rarely needed in common application code, it is considered [antipattern by some](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns). It is only really required when you need to pass data between two different async contexts/pipelines that can't be merged via `Promise.all/race`. But very often when that happens, you are better of using a more complex data structure like a queue, scheduler, state machine etc. 
I don't anything about nodejs or modern testing. so can't tell. But i do have experience in refactoring shitty code(most of which was written by me). I tell you rewriting or refactoring complete code is not an option as you will never finish it. I, for one, ended up with a nasty bug and gave up. In my best attempt, I simply split code into small modules and refactored the modules as needed. thanks to git, I was able to remove ugly code and commented out code without fear.
&gt; That's easy: Angular found something unexpected. &gt; Just look at the stack trace. &gt; Oh... Lovely.
I have a question. If you do a return from a catch() handler will it execute the then() statements afterwards?
If you don't want something you remove being republished by someone else then don't release it under a license like the WTFPL (or anything similarly permissive). That's kind of the point of such licenses....
Or more people can start using things like this: https://github.com/rlidwka/sinopia
tbh i think they never added it in the standard library, you cannot compare arrays with operators `&lt;&gt;=`... because its very slow to do deepEqual nested array comparisons, so you have to roll your own. was bored solution, for your use case maybe something like isAllempty isAllEmpty=(arr)=&gt;0&lt;arr.filter((x)=&gt;x).length or isEmpty=(arr)=&gt;array.length==1&amp;&amp;array[0]==null var a = [null] if (isEmpty(a)) foo() or the whole array eq() (doesnt work on 2D nested arrays) eq = function(a,b){ if(!((a instanceof Array &amp;&amp; b instanceof Array) &amp;&amp; (a.length == b.length))) return false for(var i=0;i&lt;a.length;i++) if (b[i] != a[i]) return false return true } // ex: eq([null],[null])
seperate page: google 'meteor router how to', you need to make a router to a second page pseudo code: router.add('/page2', function(req,res){ req.write(templatefunction('foo.html')) }) how2 mongo: mongo stores json objects as 'pages' in a 'book', so you want to create a page called results (or results_poll1234), ex: `{ question1_answers: 0, question2_answers: 0 }` so google 'how to save fetch update and save again a page mongodb' psuedocode: results = book.query({name: myquestion}); console.log(results) results.items[question1_answers]++ book.save('myquestion', results) (or something, sorry tis been a long time, maybe someone can give u the exacts)
I just checked the repo on github. It's licensed as WTFPL so there are no license issues with reuploading his code.
1 use a wrapper div with a id or class name you can use absolute positioning on child elems if the parent elem is 'relative' positioned 2 input.onchange = function(){ ... } https://jsfiddle.net/geg7u9yd/ you'll have to do a lot more checking than my example, where its only 1 stat, and 1 card updated, and im not applying the buffs against eachother. but you already have a good start with your buffs array for that stuff.
The fact that this is possible with NPM seems really dangerous. The author unpublished (erm, "liberated") over 250 NPM modules, making those global names (e.g. "map", "alert", "iframe", "subscription", etc) available for anyone to register and replace with any code they wish. Since these libs are now baked into various package.json configuration files (some with 10s of thousands of installs per month, "left-pad" with 2.5M/month), meaning a malicious actor could publish a new patch version bump (for every major and minor version combination) of these libs and ship whatever they want to future npm builds. Because most package.json configs use the "^1.0.1" caret convention (and npm --save defaults to this mode), the vast majority of future installs could grab the malicious version. If I'm understanding this right, it seems pretty scary :| src: https://news.ycombinator.com/item?id=11341006
... Is the author of ... With Node and React
So he refused to actually act on a trademark request and then acts like a baby about it? &gt; And I didn’t want to let a company force me to change the name of it. Why the fuck do we care about this guy? Obviously he didn't care about the legality of the issue and just wanted to whine on the internet instead. Jesus, just because you're open source doesn't mean you're immune to the law. &gt; This is not a knee-jerk action TIL that unpublishing everything because you can't act like an adult isn't a knee-jerk reaction
I've been involved with Open Source and Free Software for a long time now and I think that NPMs reaction is totally reasonable for an organisation or company when they are carrying some else's code. They got a legal threat out of the blue, and of course they pulled it. Now they can take the time to gather some proper legal advice. It is unrealistic to expect NPM or Debian or any other organisation that distributes code to automatically take on a legal fight. (Debian is an interesting example. They refused to ship Firefox due to trademark issues. Instead they shipped 'Iceweasel'.) 
It seems to me that NPM, as a policy, should never allow modules to be removed. You publish it, it's there forever. Want to change it? Push out a new version. Allowing anyone to remove their modules from NPM is asking for anyone malicious or otherwise to knock over this house of cards we call a community. How can you ask someone to build software that depends on your shit if you can take away your shit any time you want. This is the internet. You can fight for intellectual property rights, sure, whatever, but you can't rewrite history and undo the past.
Javascript has two types of values: Primitives and Objects. Primitives are numbers, strings, bools and undefineds. Objects are everything else (e.g. Arrays). One of the key differences is that two individual objects are not considered 'equal', even if they have the same content. For example: [] === [] // false String([]) === String([]) // true var x = []; x === x // true Usually, if you want to check if two arrays have the same contents, you would use `lodash.deepEqual`. But if you're lazy, you can do `JSON.stringify(arr1) === JSON.stringify(arr2)`. Additionally, you should consider using the `===` operator instead of `==`. `==` will convert both sides to numbers if they are not already the same type, which can be confusing. 
It seems you are not allowed to publish a package on npm if the name was previously used by an unpublished package. What hapenned in this case is NPM stepped in to make an exception, after checking if the code was exactly the same, they manually replaced it by a fork.
And his blog is on medium.com... But none of those companies - as far as I know - did something like this. That's something [sourceforge did](https://en.wikipedia.org/wiki/SourceForge#Project_hijackings_and_bundled_malware) and wasn't well received (obviously).
how is this different than appReadyPromise .then(app =&gt; app.whenComponentReady("some_component")) .then(component =&gt; component.lookupThing()) .then(console.log.bind(console)) .catch(err =&gt; console.error(err.stack)) ?
except if it is defined as an extra function with enough documentation to explain the magic. // returns boolean: whether v is equal to the integer -1 // floats are rounded UP (i.e. -1.9 -&gt; -1, -0.9 -&gt; 0) // &lt;insert explanation for ~ operator here&gt; const isMinusOne = v =&gt; !~v;
I have not tried angular or aurelia. but from what i have heard, I would never pick up angular due to its lack of support. I think when it comes to tools, the most important things that matter are *learning curve* and *official support*. No matter how I look, angular 2 does not have good support. with lack of official support from google (or the actual team towards angular 1), I really can't consider angular as an alternative. On the other hand, aurelia has support from durandal inc, a company made specifically to support aurelia. If i have to pick between aurelia and angular, i would pick ~~aurelia~~emberJs which has excellent support and is production ready right now. PS: [importance of support]( http://www.commitstrip.com/en/2015/07/28/betting-on-the-right-horse/)
I think I'll give it six months. I agree that it can be very helpful, and I feel that I've learned a lot. But the saturation point should be reached in 6 months. 
That's still a less than happy situation. What happens if the author of some smaller project does that? Will all downstream libraries no longer work? The idea of a mutable repository seems fundamentally insane.
If I understand correctly that thing that annoyed him is that NPM ignored his stance where he would challenge the legal position of the trademark holders if it came to it. Instead they went around his back/directly against him and changed the ownership. One might say that Github does/has to do something similar with the [DMCA takedown requests](https://github.com/github/dmca), they comply with, though with more of an legal obligation.
I would expect [1] == [1] to return true and [1] === [1] to return false. Why == checks for identity and not equality?
I've been warning of the potential for issues like this for quite a while and would be really grateful for people's feedback on this approach to try and insulate your projects from them https://github.com/JamieMason/shrinkpack. Its not completely there yet, but I think there's something worth exploring further in this idea.
You are wrong. You can publish a package that has been previously unpublish, but you cannot publish it with a version that's been previously published -&gt; so (name, version) is unique, not (name) in this context.
&gt; IANAL Nether is NPM. It takes time to talk to a lawyer and in the meantime I imagine it was "all hands at panic stations" at NPM so did what they thought was the best course of action at that moment. It is entirely possible that pulling it wasn't really necessary. But as you said, IANAL and it takes time to figure out the right thing to do. 
&gt; I'm going to code like this 'feature' doesn't exist That is the correct approach ;)
Rrading the comment above yours though it seems that's not what happened - its identical to the package that waa pulled, just under a new owner. 
I guess Medium.com is reasonable enough, as his blog post is not critical infrastructure. When GitHub is down, or is forced (by lawyers, a bad financial situation, or whatever) to make strange moves, the entire NPM ecosystem will have a bad time as well.
*cough* why ? *cough*
Yes, it may be identical, but NPM offers no guarantee about that. When you install a package it's because you trust the owner. If anyone can take over an abandoned package name, it's a problem. It's actually not such a big problem is a completely unrelated package is uploaded. It will break and you will notice. The problem is if someone uploads a modified version, they're basically injecting whatever code they want in your app. Display ads for their profit, include links to steal your pagerank juice, steal your users' data...
Woah that's just ... absurd. These US trademark trolls are completely out of control. 
Ah cool someone told me that this was on their roadmap, didn't know they shipped it. On the other hand it seems that it still sucks because different versions still cause nesting.
&gt; Well, offering a name for grab the day the previous owner left it seems really dangerous. Yep. It's not a good look for a package manager. Mind you, it's less bad than it seems in *this* case because npm does prevent republishing the same version of deleted package. camwest could publish 0.0.4, but not 0.0.3. But by default everyone depending on `left-pad` would be pinned to `^0.0.3`, which would *not* match 0.0.4, meaning all those zillions of projects depending on it wouldn't automatically upgrade to the new potentially malicious package. But: * New projects deciding to use it directly would get the new package * If `left-pad` had been 1.0.3 when removed, then it would be pinned as `^1.0.3`, which would match 1.0.4, because semvar, meaning everyone would have automatically upgraded. Kind of scary.
&gt; some developer thought that it's a bad thing that JS is not statically typed It is. Try [TypeScript](http://www.typescriptlang.org/) some time and enjoy how much simpler JavaScript can be. You might even find that taking the time to refactor to TypeScript first will make your tasks much simpler as well.
Tests can be written after the fact, and are often a first step in refactoring.
To be fair, if we're concerned about open source infrastructure we should embrace GitLab over GitHub to begin with. GitHub has been shifting towards a more corporate audience lately and it never was open source to begin with (although e.g. Atom is).
How can you possibly believe this to be true?
Electron has a big overhead for RAM usage. (about 100mb for nothing)
now let us all switch to https://github.com/whyrusleeping/gx :)
i think it's done and over. iz removed the kik package from npm
No. Someone asked to explain what was meant by the article's statement, "Just like Perl is the glue of the internet". "Today" never entered the picture and I explained that Perl pretty much handled everything, script-wise, at one time and, to a point at least, still does today as I often see threads on professional boards discussing Perl scripts. &gt;How is a popular systems programming language more "the glue of the internet" than the most popular web-development programming languages in use today? I don't know anyone who would use a web language, specifically PHP, to do systems programming. I know a ton of people who would/could/do use Perl to do both if they had to. &gt;I'm just saying that I don't think it really holds the title of "the glue of the internet" anymore. And that is what I said. I don't know how true it is today but I do know there are a lot of people still using Perl scripts to run their systems and web sites cause I read about it every day (though not as much as I used to a few years ago).
Yeah. I'm a bit frustrated at the attention step 6 is getting, when step 4 is what really raises hackles. (And to a much lesser extent, step 5.) Especially since npm package name conflicts has been a problem for a while now; so much so that npm has an explicit policy on [resolving disputes](https://docs.npmjs.com/misc/disputes) which was (apparently?) completely violated here. Having broken builds is pretty bad; even worse is what's been revealed about the possibility of malicious code making it into production.
I didn't know that behavior existed for packages below 1.x, but the point I was trying to make still remains (the packages above 1.x as you said), meaning it can be a security risk.
Unless you are `callmevlad` this was ripped [word for word from the hackernews top comment](https://news.ycombinator.com/item?id=11341006). 
*cough* GitHub didn't remove his stuff from an email */cough*
I was thinking about the same thing, sinopia seems like a nice tool. I wouldn't use ied for production stuff however, since npm (the client) is super battle tested.
Agreed, someone should write an article on using polymer components without using polymer.
Good point. Taken and will follow with future submissions. I already have some stuff in twitter that people here could be interested in. Thanks for bringing it.
They aren't the same clarification just because they are both software and kik owns the mark for "kik" whole the package was called "KIK". This wasn't infringement. Kik knows that, as does anyone with a basic understanding of trademark law
What a mess this ecosystem is.
&gt; This situation made me realize that NPM is someone’s private land where corporate is more powerful than the people, and I do open source because, Power To The People Github is no different
that's not all, I always thought the following snippet would output `second` and then `first` but it doesn't setTimeout(() =&gt; console.log('first'), 100); const date = new Date(); while (new Date() - date &lt; 50) {} setTimeout(() =&gt; console.log('second'), 70);
Javascript has class syntax, but no class mechanism. It's still all prototypes all of the way down. Generally, I wouldn't recommend using classes for most things. In your example, you can trivially make a data structure with an object literal: let polygon = (height, width) =&gt; ({ height, width }); let square = polygon(2, 2); console.log(square.height); // =&gt; 2 console.log(square.width); // =&gt; 2 Classes are useful for standardizing how people add things onto prototypes - meaning, they're useful when you have objects that need a lot of methods on them. Though, keep in mind that due to javascript's typing nature, it's easy to make really generic functions that don't necessarily need to be tied to any object: let area = ({ width, height }) =&gt; width * height; console.log(area(square)); // =&gt; 4 console.log(area({ width: 3, height: 3 })); // =&gt; 9
Really, the most WTF part about this is not that it happened, but that everybody *knew* it could happen and still decided to put dependencies all over the place. At this point npm dependencies seem like putting a Wikipedia page or StackExchange post in your include path.
As far as I know that's exactly what happened. At the end there is one big issue - if you depend on some of the removed modules you are in a pretty bad situation because someone else could come and get the same name. Then release a new version and you get an absolutely different package.
Apparently, left-pad was published under the WTFPL, so it's debatable if this was an infringement of the author's rights.
the focus here is no npm siding with kik. not npm rehosting the left-pad package
http://tmsearch.uspto.gov/bin/showfield?f=doc&amp;state=4810:at49ki.6.12 That's the actual trademark application, rather than linking some random website. Furthermore, that is an all-inclusive list. It's a trademark class designed specifically for messaging applications. A code generator wouldn't qualify as a competitor under that class. By your logic, you can just cherry pick "storing text" and now a 2014 Volkswagen and a Toaster are in the same class of products. 
After having worked on massive (non-Javascript) projects in the past, that's just the way to go with dependencies. They're flaky. And do you _really_ want to chase down a _very, very specific_ version of ZLib (2.4.2 _but not_ 2.4.3) five years after the fact? Hint: you do not. So you keep your enemies close, and your dependencies closer.
... Then you are a JavaScript developer
&gt; Of course you can say "well, it's because NPM is a company", but it isn't the real issue. The same could very well be about PyPI, or any other package registry. The real issue is the underlying legal process: the companies have to defend their trademarks, or they risk losing it. Or the kik lawyers are just douchecakes with an over-inflated sense of their mark which apparently required them to demand the takedown of a CLI project boostrap tool over their marks in mobile instant messaging. &gt; Now, what the package author did was meant to harm the community, and that's an whole other subject - was he right to do so? Did he had the right? Personnally, I don't think so That doesn't even make sense, he obviously had the technical right to do so, and I don't see why he wouldn't have had the legal right to do so either. &gt; he deliberately decided to break an implicit contract that he had made with his users. So he broke an "implicit contract" that his projects be available by yanking them, but npm didn't "break an implicit contract" that his projects be available by yanking them? That's some gold-metal mental gymnastics right there.
Sure - as I said, I doubt they even know what is NPM, apart from some form of a file-sharing platform. But the thing is, it's an issue with the Kik company, not NPM. &gt; That doesn't even make sense, he obviously had the technical right to do so, and I don't see why he wouldn't have had the legal right to do so either. I was speaking in a moral sense. The fact that I can technically and legally choose to break my coworkers tools doesn't mean I should do it. It doesn't make sense ethically or professionnally. &gt; So he broke an "implicit contract" that his projects be available by yanking them, but npm didn't "break an implicit contract" that his projects be available by yanking them? That's some gold-metal mental gymnastics right there. NPM hasn't removed his projects (except Kik, because of legal reasons, please refer to my post above) - he did. We could of course wonder if this right should be available to the users in the first place, but I see little gymnastic in this.
Careful, most of those are eric elliot links. I wouldn't recommend his articles to someone who doesn't know much about JS, in case someone comes away with the idea that terms like "concatenative inheritance" are meaningful. They're easy to misuse, but classes have the same problem in any language. You can get away with using them pretty easily if you avoid lots of inheritance and complicated object relationships - the whole composition versus inheritance thing. 
Yeah, javascript has really awesome syntax for simple data structures, so you don't need classes for everything just to make them classes. 
http://i.stack.imgur.com/ssRUr.gif
I don't think he intended to harm the community, just to withdraw from it. This is one of those things we should ask him. Here is his perspective on the topic: https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c#.3b37p88g3 In addition, the fact that NPM republished the package with same name and same version number means I cannot trust anything on NPM to be what it claims to be. Who knows when they'll decide to have a package with same name and same version number but different code?
Yep. I am sure I will get down-voted but I really don't understand why companies are turning to Node for everything. It has its place but for a lot of things I see it used in, it feels more like a big liability.
There's bad code all over Github, too. Do you hold that against Github?
&gt; Sure - as I said, I doubt they even know what is NPM, apart from some form of a file-sharing platform. So? &gt; But the thing is, it's an issue with the Kik company, not NPM. NPM involved themselves in it by taking down the project. &gt; I was speaking in a moral sense. The fact that I can technically and legally choose to break my coworkers tools doesn't mean I should do it. It doesn't make sense ethically or professionnally. And that "speaking in a moral sense" doesn't apply to NPM how? &gt; I see little gymnastic in this. You agree that NPM has in fact removed his project from the registry. You assert that the developer is bound to his user "in a moral sense" and can't take down their projects. You also assert that NPM doing *the exact same thing* is just fine because "legal reasons" (not actually legal reasons, just taking the shortest path to covering their asses). Note that [the developer's perspective](https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c#.3b37p88g3) is precisely that *they* can't trust NPM because of their behaviour and have decided to stop sharecropping there. They haven't pulled a @why and deleted all their projects and presence, only removed them from NPM.
If you can't even understand the difference between github and npm I don't think there's much to be gained from discussing this with you.
npm is great. It allows to use abstractions EASILY instead of everyone making their own abstraction. Widely used npm module will almost always be better than your own abstraction, because it's tested in more use cases. Everything that is popular has bad parts. There are bad useless posts on reddit, but that doesn't make you not use it, because there is a lot more good ones. Same with npm.
I'm no rock star developer, but I went full WTF when I saw this. And fucking endless dependencies... 
Eric Elliot's "functional composition" really means "multiple inheritance with decorator functions". It's just a buzzword laden term for an old idea (functions that add things to structs) used for dubious purpose (multiple inheritance).
 function debate(a,b){ return `If you can't even understand the difference between ${a} and ${b} I don't think there's much to be gained from discussing this with you.`; } debate("twitter", "npm");
You don't have to go nuts with classes like in some other languages. But if you are writing OOP code it is best to use the `class` keyword. At least then everyone can instantly recognise what you are doing. Standardisation is nice. 
Seems to me it was how NPM screwed themselves, and then proceeded to ignore the rights of an author.
This can not be upvoted enough, This is the REAL problem. Not copyright or trademark issues. Too much modularity is just as bad as no modularity at all. Let's not bring back Windows DLL hell to JS please.
good thing we have gitlab :)
Yes, it's supposed to be a joke. But what the hell, the reality is not that far from it.
They are. But what I am interested to see is how this changes `node/npm` (for the better). I'm hoping to see actual namespace support. Even PHP, which everyone casts out as a leper language, has namespace support.
If you have needs of your own, you are welcome to write your own tooling. If others have the same need, your investment will pay dividends as they join you. It's simple market forces. If it's really better, the "many" will eventually adopt it.
There are some things to consider. First off, support for the `class` keyword isn't the best right now as far as browsers go ([ref](https://kangax.github.io/compat-table/es6/#test-class)). So if you're writing vanilla JavaScript without some build step to convert your code to a more compatible subset of JavaScript, its kind of a non-starter. Also, it really helps to know how JavaScript works. If you come into using `class` expecting it to behave like other languages, you're going to be in for a surprise. Most of the standard stuff is there, but the plumbing underneath is a little different, and you may find yourself running into collisions or issues with context more than you might normally think. As others have mentioned, JavaScript classes are implemented with prototypal inheritance, and not knowing the peculiarities around this could spell trouble. That said, if you're already defining "classes" with constructor functions with methods on constructor.prototype and are using something to make your code ES5 compatible, I'd suggest going ahead and using `class`. It's a cleaner syntax and more clearly shows the intent for the [constructor] function - it being a class rather than just a normal, callable function.
There are shitposts on reddit. Do you hold that against reddit? 
I might regret this, but I decided to make this its own thread: https://www.reddit.com/r/javascript/comments/4bn2j0/can_we_ever_trust_npm_again/ 
Are you serious? I hope not. Any third party can/will/may infringe upon your rights the minute your legal issues with another third party involve them. Gitlab is no exception. The whole open source community knows this and ignores the elephant in the room because it doesn't jive with the open source mentality.
Probably going to use [Sonatype Nexus](http://www.sonatype.org/nexus/go/) It has NPM support as well as a bunch of other types of repositories and there is a free OSS version. 
i think the title is a bit misleading. it does not seem like bad code broke all these projects, rather a dependency that all these projects relied on was removed from the repo. am i wrong? but what is wrong w/ that? open source is open source. If a developer want to pull his/her projects, it isn't their fault that others are relying on it without a back up plan.
So basically: * kik has legal rights and the obligation to protect it's trademark. (they can start shitstorms if they want) * npm has the right to remove any package from their registry they want or need to. (they can use package publishers and users as shitstorm shields) * npm package publishers also have the right to unpublish any pakcage from npm at any time (they can start shitstorms if they git hit by shitstorms) * **Node developers have absolutely no rights whatsoever to any npm pacakges and their code could break if it depends on any single npm package.** (takes all shitstorms head on, bad luck brian) Sounds like we need 3 things as developers to get back on solid ground: * npm needs to exert limited rights over any package published to npm. The developer can abandon it and unpublish it, but npm reserves the right to restore it if they want and mark it as unmaintained. This give developers a heads up warning.) Just needs to be added to the terms of service. * package renaming and aliases. Even if a project no longer calls itself kik, using npm install kik would automagically install whatever the new name is and ask you if you want to update your package.json to refelct the new name. * there needs to be a 3rd party full cache of npm like google caches websites. You can point your site to the cache and it will retrieve from npm if it doesn't have it or give you the files directly if it does have it.
I'm not certain that npm *decided* that it was acceptable to publish a different package under the same name as one that had been deleted, or even that they had *decided* that it was acceptable to be able to completely delete a package. Given npm's history of mediocrity, it's more likely that they simply failed to consider the consequences of allowing packages to be removed completely--that this would break other packages and that malicious code could be uploaded in place of it. In other words, I don't believe npm was being malicious. I think they were just stupid.
Sure. Enter the following into your browser console. function Person() { var firstName; var lastName; this.setName = (first, last) =&gt; { firstName = first; lastName = last; }; this.getName = ()=&gt; `${firstName} ${lastName}`; } function Employee(id) { this.employeeId = id; } Employee.prototype = new Person(); var anne = new Employee(0); anne.setName('Anne', 'Annette'); var bill = new Employee(1); bill.setName('Bill', 'Williamson'); Now see what happens when you query Anne's name: anne.getName() "Bill Williamson" Anne and Bill share the same parent implementation, and that parent has internal state. This means that Anne and Bill can both overwrite the same state that they share, with quite unintuitive consequences.
Though, just to keep in mind, this is only one way to set up a prototype chain. Here's another: function Person() { var firstName; var lastName; this.setName = (first, last) =&gt; { firstName = first; lastName = last; }; this.getName = ()=&gt; `${firstName} ${lastName}`; } function Employee(id) { Person.call(this); this.employeeId = id; } Employee.prototype = Person.prototype; Just two smallish changes and you get all of the instance that one is expecting in children classes. var anne = new Employee(0); anne.setName('Anne', 'Annette'); var bill = new Employee(1); bill.setName('Bill', 'Williamson'); anne.getName() // =&gt; 'Anne Annette' bill.getName() // =&gt; 'Bill Williamson' I believe this is actually part of the reason why class syntax is at least somewhat valuable - it railroads people into setting up prototypes in one particular way.
Here is some solutions I see reading : * Use somehting like Docker to create images of your app (cons another tooling to your build, may be incompatible with your workflow) * Put node_modules in dependency tree (cons : lot of noise in VCS, native modules) * Use an alternate registry, either local or maintained by someone else (cons : not necessarily up to date, add another point of failure) IMO we need to push for a change in NPM policy. Create an alternative (e.g. an offline registry, a cache registry) is just another workaround and another point of failure to mitigate issues. NPM must not allow users to upublish their package once it has been downloaded at least once, but NPM should provide a process to unregister modules on a per-case basis (e.g. security issue, sensitive info leak, ect.). 
It's 11 actual lines, seventeen with empty ones.
So, people should include the left-pad as a dependency, but also write the same code themselves in case the module suddenly disappears? Why add that complexity then instead of just using your own implementation?
I wholeheartedly agree here. We shrinkwrap our dependencies to lock deps further down from the tree changing. However, when a dependency vanishes. Fuck. This is were a need to introduce an offline registry may come in.
Test harnesses... easy to get up and running
Exactly!
If the package has no content, NPM would take it down if anyone complains. I had a NPM package that I intended to use for a hopeful hobby project that got took down cause I never got it started and someone else who owned a package with similar name complained. 
This is a tough one because you should be looking at the parts of the page you care about. It seems like you care about performance and the web platform, so it's totally fine to write about these things. You want to show that you care about the web and you have the technical skills to implement improvements to the things you care about. If I were given this task here's what I'd think about: *How fast does the page load?* Think about how the user will experience the site. Throttle your connections speed to Regular 3G, take note of the total page-load time, identify bottlenecks, and explain how you'd approach fixing them. *How smooth are the interactions?* I'd use the various rendering performance tools in Chrome to see if any transitions or animations are running at 60fps. *Is the site secure?* Chances are a recruiter site has a contact form on it somewhere. Is that form on HTTPS? Is it passing information to a secure endpoint? *How is it designed?* I believe developers and engineers can and probably should think about design. And not just adhering to photoshop comps. Do the interactions on the page make sense? Did you ever get confused while using the site? How could you improve that? *Are there cool, bleeding-edge things you could use today to improve the site?* A good developer understands not every site can have all the bells and whistles, but what if you had unlimited time and resources? What would you add? I'd probably do something with Web/Service Workers to add offline support and run any non-rendering logic in a separate thread. Maybe there's a framework you'd like to try out, or a new way of asynchronously loading CSS you've been dying to add... have fun with it. Once you're on the job you'll be expected to think up and implement new ideas so it's great to show that you have some.
Well done sire! Full support even if this break the whole internet.
This is a pretty good use case for ES6 maps, but unfortunately their API is so poorly designed 😞
See I'd be *all* for this, the only problem for us is the native modules. We have a handful that are platform dependent and require going through an install phase
Author [allowed to transfer the ownership of modules he removed from npm](https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c#.glzhyzsah), and npm allowed another guy to publish it. No hostile republishing occured as far as I understand
it doesn't auto-run. click "Run" at the top :) I use Step &amp; console to track regressions and timings.
Sure. Also, notice that it defaults to 100% mutation rate while the other benches default to 50%.
Yep, I saw that. Thanks for the heads up.
Not according to the subject article. While technically, you are correct in describing the recent publication history for that code repository it still appears to be a deliberate decision from an NPM co-founder. &gt; "Un-un-publishing is an unprecedented action that we're taking given the severity and widespread nature of breakage, and isn't done lightly," Voss explained about an hour ago. "This action puts the wider interests of the community of NPM users at odds with the wishes of one author; we picked the needs of the many. This whole situation sucks. We will be carefully considering the issues raised by and publishing a post-mortem later. "In the meantime, several thousand open source projects have been repaired, and I'm sleeping fine tonight." I am thinking through my options at this time. NPM can own the module namespace on their distribution channel, but they don't get to own my code.
The project license allowed republishing so I don't see why npm wouldn't be allowed to republish it?
No, it's likely the same people who abused the fuck out of jQuer by using plugins for trivial shit who get caught out by the same things with node: over dependency on 3rd party modules for doing shit you shouldn't use an external resource for.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Can we ever trust NPM again? : X-post \/r\/javascript](https://np.reddit.com/r/programming/comments/4bndxp/can_we_ever_trust_npm_again_xpost_rjavascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Who downvotes? This is true. Persistence layer is all about the Cassandra implementation. http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html
This is the best tl;dr I could make, [original](http://arc.applause.com/2016/03/22/javascript-is-the-worlds-dominant-programming-language/#.VvF-4bcghgA.hackernews) reduced by 80%. (I'm a bot) ***** &gt; More than a quarter of all developers in the Stack Overflow survey identify as full stack developers. &gt; Mobile developers 8.4%), desktop and front-end Web developers round out the most cited developer occupations. &gt; React-a cross-platform tool that relies on aspects of JavaScript-was the biggest trend on Stack Overflow, growing 311.3%. The biggest loser in the trend report was Windows Phone, down 65.2%. What else are all of these full-stack developers using to build software in addition to JavaScript? The most common combinations among full-stack developers are JavaScript, PHP and SQL, C#, JavaScript and SQL and C#, JavaScript and SQL Server. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4bnfk3/its_official_javascript_is_the_most_commonly_used/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.6, ~47014 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *keywords*: **developer**^#1 **JavaScript**^#2 **Stack**^#3 **year**^#4 **Overflow**^#5 
classList is almost criminally underutilized!
[Alert: NPM modules hijacked](http://www.drinchev.com/blog/alert-npm-modules-hijacked/)
&gt; I agree with your advice for a beginner. But if you already have a good understanding of how Javascript's prototypal inheritance works, I don't see any harm in using the ES6 Class syntax. I think the class syntax is fine even for beginners. Python, for example, works the same way. In Python, classes are themselves runtime objects, and inheritance also happens at runtime by delegation... just like in JavaScript. The only difference is the Python folks don't make a big deal out if it. The vast majority of the time, we don't need to know or care how the class concept is implemented under the hood.
There are lots of packages like `leftpad`. For example, [`isarray`](https://www.npmjs.com/package/isarray) - check the download stats. I saw a Tweet yesterday claiming it uses over 100GB of bandwidth per month. Here's the [actual code](https://github.com/juliangruber/isarray/blob/master/index.js) of `isarray`: var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; I do think things will get better as ES6 features gradually become available, making at least some of these things unnecessary, but this is a pretty deep problem that requires a collective effort to fix.
You still have issues with reference types, though: function Person() {} Person.prototype.names = []; Person.prototype.getName = function () { return this.names.join(' '); } function Employee(id) { Person.call(this); this.employeeId = id; } Employee.prototype = Object.create(Person.prototype); var anne = new Employee(0); anne.names.push('Anne', 'Annette') var bill = new Employee(1); bill.names.push('Bill', 'Williamson'); anne.getName(); &gt; "Anne Annette Bill Williamson" 
This. Also, the original code had an extremely liberal license (WTFPL) that allows for this, so there is no issue with copyright either (not to mention a piece of code this short might be too trivial to be copyright protected). You can argue about the author's moral right, but I think people should recognize that if you release a work as open source, then you do not 'own' that code anymore, and to claim otherwise would be contrary to the spirit of open source. 
Disregarding the legal issues raised by this, and the long term issues of losing support for a core dependency, the liability of an inaccessible remote dependency effectively ends, or at least buffers its fallout, if local or third party caching servers were more standard. Resilience hasn't been enough of an issue to bring this to the forefront before, perhaps, but many have advocated for hosting cache servers for dependencies of critical apps for some time, whether for resilience against this scenario, security concerns, or other, unforeseen issues. It isn't standard or inherently simple for many dev teams, but this could be a motivator for moving toward that kind of decentralization or independence. If we want resilience, we can't simply blame npm or authors, we need to acknowledge this as our own problem, because ultimately it is, to our POs and users. "npm/authorX/litigatorX screwed us" is not an excuse after the first few times one or more dependencies become unavailable and kill a build and deploy, which is what any disaster recovery and analysis efforts should conclude.
&gt; kik has legal rights and the obligation to protect it's trademark. (they can start shitstorms if they want) They do, but it's not completely clear-cut whether it applies in this case, given how distinct this package was from what Kik is. The only real thing they had in common is they're both some form of software. It certainly won't be the first time a company oversteps its bounds in "protecting" its IP. It's a pretty nasty situation though. Even if they're in the right, NPM doesn't want to get sued by some rich company over one package that nothing depends on.
In most cases it was a transient (not top level) dependency. For example, Babel and Ember certainly weren't using it directly. That's how it was able to affect such a huge number of projects.
I am going to experiment with jspm for distribution and attempt to publish directly from my domain. http://jspm.io/
Find a npm that is not called npm and the owner is not a corporate bitch.
I agree that it was stupid and not malicious, but it's extremely shaky ground. I mean, if they can do that... What else can they do? Case in point, WHAT ARE THEY DOING NOW? https://twitter.com/seldo/status/712673227630313472
This is not a story about NPM. It may be presented as such, but it's not. It's a story about stupid dependency management, and as such, DLL Hell is a perfect analogy.
Using the wrong database has nothing to do with Node.
In what sense does javascript not have a class mechanism? It has a syntax called class that creates a class-like hierarchy with semantics similar to (and yet, distinct from) normal prototypical inheritance. Sounds like a lot of class machinery to me.
One advantage of re-inventing the wheel, is that then it's YOUR wheel.
No. You can use single or double quotes inside backtick notation.
My reply was towards the content of npm. Availability is also critical, but it was well adressed until this point IMO. I hope this loophole will be closed and we can keep calm and continue using it.
&gt; The author chose a license that allows republishing There you go, everything else doesn't matter. He already waived his rights by using a license that permits this. By publishing under the WTFPL, he agreed that his wishes mean nothing. &gt;If NPM wanted to then "fix" the web they would have to violate their own terms to do so. Or they could change the terms, and act on the new ones.
I think amnesiac is referring to the NPM ecosystem. All the problems that one developer was able to cause shouldn't have been possible in the first place.
It's not remotely debatable. The WTFPL allows people to do anything with it. There's no way it's an infringement.
i do think it's fair to say "im removing my things from this platform, i keep it avalible at this other platform and anyone is free to take it and resubmit it to the platform as there own, but i feel a great injustice has ben done and dont trust the platform". and things did go back up fairly quickly. EDIT: in light of email chain i like to say: i think it's a dick move, he is in his rights to do it but it do seem like a dick move to me.
Ohh, your first tip is gold. Just tried to make that change on the new mithril diff engine and got a cool 10% improvement on the vdom-benchmark. Clocking a bit closer (28k) to inferno (20k) now :)
who can infringe my rights if i use the words "retard" and "retarded" on my self hosted gitlab? is that international law? 
For the argument's sake, let's say polyfill wasn't possible as in non-standard behaviour. Do you recommend everyone code their own lodash/underscore ? Concerning polyfills why not put them on npm ? Is it "it's not a dependency as long as I copy-paste it?" or should we implement one polyfill per developer ?
When people say JavaScript doesn't have classes, they're using Java/C#/C++ style classes as the gold standard for what is or isn't a class, where classes are a compile-time concept, and inheritance also happens at compile-time. But, of course, there are other languages out there. In Python/Ruby/Smalltalk, for example, classes are runtime objects, and inheritance also happens at runtime by delegation... just like in JavaScript. Personally, I agree with you. I think the abstract concept of a class is more important than the concrete implementation. I can write and use classes in Python and C++ — and JavaScript — without having to know or care how the underlying implementation works.
I'm surprised so many people in this thread recommend against using classes in JavaScript (either by using the class keyword or by adding things to a function prototype). I love them! They often force you to simplify your code, and they are much more easily optimized by JavaScript interpreters.
No. But most people never should have. AFAIK their recent behavior/policy isn't new, it just wasn't widely known. I'll be doing my NPM based development in docker for now on. I should have done that in the first place but I was being lazy, like most others...
Because people are using NPM as a build tool, not as a repository. NPM specifically says don't use us as a build tool, they have guidelines to set up your own local mirror for build environments and sync it and have your own packages, and people still use NPM as a build tool.
It's fine in this instance, since we're not actually adding anything onto the prototypes in either case, and it's illustrative. But you're right, in real code you'd want to not directly assign them together. 
[Kik's response](https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d)
Doesn't NPM flatten dependencies now? Like, a reduction in duplicate node modules?
The reason this is a story is because it broke many people's build process.
Yep. There is no gold standard for "class". From a developer's perspective, a "class" is an OO encapsulation mechanism that involves creating methods, defining fields, and producing instances and has some sort of inheritance scheme. Making the definition of "class" more constrained than this is not only incorrect but also not a useful distinction to make at all.
This is exactly why having small solid tested third-party modules is good. &gt; edit: there was a slight typo in the code ;)
Because it's all sugar over prototypes, so there's some limitations that make sense with that context in mind, but are otherwise baffling. The most obvious example is there are no class fields. You just assign onto `this`. `super` does not behave like someone would expect. It's a simple reference to the parent prototype, so if you're in a `meow` method you still must call `super.meow()`. And, of course, because they're only prototypes, the context of `this` is easily lost: class Cat { constructor(name) { this.name = name; } meow() { console.log(this.name); } } var whiskers = new Cat('whiskers'); whiskers.meow(); // =&gt; 'whiskers' var whiskersMeow = whiskers.meow; whiskersMeow(); // TypeError This again, makes no sense what so ever if you just go around thinking that javascript has full class mechanics. It's only when you understand that they're really prototypes does it make sense, and therefore, only when you accept that they're just sugar over prototypes can you really use them predictably. There's also nothing unique to classes that cannot be replicated without them, or it would be impossible to transpile. Yet we've been transpiling this kind of class syntax ever since coffeescript came out, ages ago. So that is why I say there is no class machinery. There's a facade of a class to make it easier to reason about the common uses of prototypes, but that's all it is. 
&gt; hahah, you’re actually being a dick. so, fuck you. don’t e-mail me back. Okay, I have less sympathy for Azer after reading this. This could have been handled much better from his end; I think Kik behaved in a professional way.
I find the Promise version more straight-foward, tbh. async functions show their value more when results are semi-parallel, rather than strictly parallel/dependent, imo.
yes, but it wasn't npm that broke it, it was having a silly dependency that broke it. We're talking about something so simple and trivial, that the time it takes to implement it yourself is less than the time it takes to manage it as a dependency. This is not a problem of NPM. It's a problem that can exist in any open package management system for any language. Basically, what is happening here, is a case of extremist DRY (Don't Repeat Yourself) resulting in a dependency nightmare.
ha but not really
I'm so angry about people giving shit to NPM about this. Azer unpublishing his module was nothing short of a irresponsible, unprofessional behaviour - and these messages only confirm it.
It doesn't solve that problem, unfortunately. The only way to really prevent that would be to run your own local npm repository (or have some other scheme saving copies of your dependencies). It does prevent someone from uploading malicious code in place of a commonly used package though, which I think is a much bigger concern.
&gt; So he broke an "implicit contract" that his projects be available by yanking them, but npm didn't "break an implicit contract" that his projects be available by yanking them? That's some gold-metal mental gymnastics right there. One huge difference is the fact that NPM removed `kik` because they were under legal threat if they did not do so. Azer removed his modules because he wanted to - he *willingly* broke everyone's code whereas NPM is trying to avoid a lawsuit, which I completely understand. The other major difference is that Azer removed his code with *no* warning or migration path. NPM at least had the decency to ask Azer to change the name of the `kik` package and provide a migration path - they gave him ample opportunity to do so but he refused.
Sure, if you're self hosting that's not an issue. 
run a private npm repo, problem solved
Beyond the fact that this example is a simple pipeline as you note, I think this version is generous to promises in at least the following ways: * Example does not require munging of params allowing simple passage of the function as the then handler * Example does not do any error handling (`await` allows try/catch error handling which IMO reads easier)
Of course they decided it. They have an entire architecture built around supporting unpublishing. It's not the kind of decision you make by accident. They likely weighed the downsides of breaking packages against the upsides of the package maintainers' ownership and "right to be forgotten". And this may cause them to revisit that decision. If they had made the opposite decision, you'd be seeing posts about "WTF I tried to delete my module from NPM and NPM refuses to delete it!!" and the other half of the JS community would be up in arms.
Please don't shift the goal posts around me. I was talking about the things that javascript could have to make it clear that they were was separate mechanics for classes, instead of just being sugar over prototypes. Since all of the limitations that we understand with prototypes are present in classes, it's a reasonable argument to make that there is nothing new going on here. This is not what a class "must" have for it to be a "class", but those are just some of the things that show that javascript's class uses the same mechanics that are already present in the language, in a more familiar format.
It depends on how good Node's ORM and DB connectors are.
I strongly disagree with Kik behaving in a professional way. You can't just threaten someone with your lawyers "going to be banging on your door and taking down your accounts" and expect him to take this peacefully. Kik representative tried to be professional, but he destroyed every positive image Azer could have of him with this single quote.
Angular... because sometimes you want to ensure that everyone writes controllers, models, and data-flow interactions in the exact same way, even if they don't want to and even if it doesn't make sense for their case at hand.
i love template strings
Not asking as a challenge, but more for an elaboration, can you explain the following a bit further? &gt; mainly because it doesn't solve everything To me it sounds like it achieves a similar goal to mirroring, it just lives static and compressed in your repository. Allowing a clone &amp; an `npm install`. However - if you have internal dependencies as other company projects, it would be nicer to remotely pull those latests that satisfy your version targets, versus having them statically included.
*In this case, we believe that most users who would come across a kik package, would reasonably expect it to be related to kik.com* Then name this package kikcom, kikdotcom or kikwhateverthefuckyouwant. "Kik" is already taken, deal with it. This is the stance that npm should take, but they didn't and it will have serious consequences in the future. Also, isn't this trademark thing one big pile of shit? Azer wasn't using name "Kik" in context of already registered trademark and/or its business (no competition in any way), so it shouldn't be even considered violation of it.
The user said do whatever you want with the code, not his account. It's his account and ownership of the kik package that's at issue
I think one solution to change the way of distributing packages to a more _distributed_ way. I suggested checking out IPFS. I just wrote a blog post on how this can be helpful: [How to use IPFS to fix NPM](http://amreldib.com/blog/HowToUseIpfsToFixNpm)
Thank you sir :)
what do you do when npm suffers an outage? I'm thinking from a work perspective, not a personal one. So my CI server will always delete node_modules before building, to ensure that npm install will always work. It won't work, if npm itself is down, or it renames or removes packages or whatever. I am not beholden to any third party at this point.
&gt; A multi-national company worth many millions calls up a guy and says they'll ruin him financially if he doesn't do what they want (it doesn't matter how big someone smiles while they're threatening you). He responds by telling them to go to hell. Exactly. A threat is not a threat simply a few words when you've got a loaded gun.
those are good numbers. maybe i regret giving you the tips now ;D. it's not that i *can't* get vdom-bench running, it's basically philosophical at this point. main.js is dead simple to make, i have one ready to go in the repo already. there is probably some more i can do to boost domvm's rebuild/diff to get a bit more out of it without removing the flexibility it affords. i think this will get me another couple fps on the high end and maybe +30% on the low end (which is the diff between your rewrite and domvm), but the architecture won't be able to touch Inferno, i have no such ambitions either. i do want to reduce gc pressure, which may mean JSONML abandonment in favor of hyperscript (have some experiment branches for v2.0), but my focus is getting a stable 1.0 out by 4/1, getting docs/demos written. the perf is more than sufficient already.
Perhaps I'm looking at this from the wrong perspective, but [shrinkpack](https://github.com/JamieMason/shrinkpack) continues to sound like it solves the same problem by keeping the dependency packages compressed in a vendor directory alongside your project. A problem would arise _only when attempting to upgrade_ one of these dependencies that no longer exists, which I assume both strategies would sttruggle with. But it's otherwise similar to a dependency lockfile, it just also has statically resolved all the dependency packages from when the packages were originally defined for the project.
Oh wow I had no idea ie8/9 didn't support it. Thanks! 
All my point was, is that 1. javascript has classes which 2. use the mechanics of prototypes and 3. aren't always necessary, since 4. javascript is duck-typed and has very light syntax for object literal data structures I'm not trying to say they're "fake" or anything like that, just that it's important to know that they use prototypes underneath, or it's going to be very confusing and seem broken when something like the context of `this` is lost. Most of my post was talking about how they're not necessary, anyway. 
Never a normal day in the javascript community, I guess ...
Why the everliving F would someone use that instead of just function(arr) { if(arr instanceof Array) { } }
I got an error when I ran it.
I agree, my painting analogy isn't very good, but no, NPM was not under legal threat and they wouldn't be for allowing someone to publish an opensource package that happen to have the same 3 letter name as a piece of commercial software. They can fight that one in court forever but NPM would never be found liable. The guy at KIK literally said that Azer wasn't being nice and giving them the name "Kik" for their own package. NPM was never in danger of any legal action and Azer would only have been if he had tried to release a commercial package using the name Kik. [HERE](https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d#.vps5wjadm) is the email chain from all parties involved. NPM took the name he was using for packages he had already created and gave them to KIK. Then, Azer said if you do that, just remove all my packages. Then when everyone realized what that actually had caused, they un-un published. Anyone could have gone on there and created another package that did the same thing as pad_left so it's not his code that's at issue, it's his account. So publishing a few lines of Javascript that are identical doesn't really infringe on Azer, but the root cause of all this was NPM's decision to take something away from him and give it to someone else. Which they are completely within their legal right to do.....but I wouldn't ever use them after this.
https://jakearchibald.github.io/isserviceworkerready/ it's not really ready for prime time I think. But definitely interesting to explore. I tink web workers make sense when you have split out your actual business logic from your view manipulation.
Could post the error message? 
OK, so Kik used passive-agressive-laywers-in-cc technics and Azer responded by including "corporate dick" in each of its message. IMO both sides are act like dicks here, NPM should enforce a better deletion policy to prevent these kinds of disputes to annoy and discredit the entire JavaScript community.
well, I don't commit those dependencies to an RCS. Which means this doesn't offer a guarantee that the developer beside me who checks out the project can build it.
Surprising enough, I now have to learn to use this with a bit more advancement for my job lol, *crinch*
They also didn't break things with 11 lines of code. They broke things by un-publishing packages. Rather annoying how clickbaiting this whole situation has become :(
I thought you could, isn't that similar to the whole Nissan car manufacturer and http://www.nissan.com/ ?
Cool idea! I'd suggest adding a description of the functions possible parameters. Maybe something like `match( a : T, b : T ) : boolean` `match( a : T, test : PredicateFunction ) : boolean` ( where `PredicateFunction = ( w : T ) : boolean` ) Just to give a quick overview of all the possible things if someone needs to look up something.
They removed the docs for that because their pushing their enterprise solutions such as private repo and on-site for $$$. http://mixu.net/npm_lazy/ is a good place to start that makes it easier to do this. https://github.com/rvagg/npmjs.org/blob/6793c71165934423f1989f54a754a6691a94f3b0/README.md This was the official doc. It's a bit involved.
That is a case of well documented prior use. Azer doesn't have that, as his project started up in Oct 2015 whereas Kik was released over 5 years ago.
tldr: everyone involved is a dick
Thank you.
Nice. Thank you. I will add that. 
I'm not sure if this has been answered before, but is there a valid technical (that is - non-marketing) reason for it's crazy popularity? I do recognize that Javascript's a bit loveably quirky, and that it has a natural marketing ally because of it's inseparable association with web development and web apps, and I love tinkering in it myself, but I can't think of a valid technical reason for it to be any more popular than another language. Maybe it's just me? Sometimes I wonder if it's luck, or marketing, or simply because the suffix "js" sounds so *damn nice* at the end of my pet project names. ^^^furby.js ^^^a ^^^framework ^^^for ^^^an ^^^alarm ^^^app ^^^that ^^^never ^^^shuts ^^^up ^^^its ^^^gonna ^^^be ^^^big
The only unprofessional here was Azer
Uh. Failure to protect your brand name causes the loss of your brand name. Ask any attorney involved in such things.
&gt; just that it's important to know that they use prototypes underneath I think we JavaScripters exaggerate that importance. I realized this when I discovered that Python also uses delegation for inheritance. Except the Python community doesn't make a big deal out of it. The vast majority of the time, we don't need to know or care how the class concept is implemented under the hood.
Bringing up lawyers isn't a threat, it happens all the time for stuff that is legal-related. A threat from a lawyer is a threat. That's common sense right? And no, I don't think trying to be diplomatic makes rational people do crazy things, this specific individual had an ego.
&gt; What implicit contract is there? I don't know, ask arcanin they're the ones arguing there is one.
First off: * C++ is a language with classical inheritance, which uses the `class` keyword. * There are other languages without a `class` keyword, which still have classical inheritance. * Then there's JS, which as of ES6 *still* has zero elements of classical inheritance, but now has a `class` keyword, apparently just to screw with people used to C++/C#/Java. :) &gt; My question, then, is whether it is now considered a best practice to make use of classes and class declarations, as opposed to continuing on with the non-class system of old Javascript. Using the `class` keyword is absolutely compatible with current best practices. However, the `class` keyword is sugar which sets up a chain of JS-style prototypal inheritance. JS is not C++, it's not really *like* C++, and with ES6 it's not *becoming* any more like ES6. It just, confusingly, is starting to *look* more like C++. :) &gt; it was very strange to not have class declarations in Javascript. Yep. Learn more about JS until the lack of classical inheritance feels natural. Then, if you like, go nuts using the `class` keyword; just remember that it's still not classical inheritance. Remember, if you ever feel like the `class` keyword is letting you do something you couldn't do without it, you're badly confused and are about to write some very bad code. ALL `class` does is fiddle around with the prototype chain. It saves some keystrokes, but it's not a new feature.
&gt; One huge difference is the fact that NPM removed kik because they were under legal threat if they did not do so. That's not a huge difference. &gt; The other major difference is that Azer removed his code with no warning or migration path. NPM at least had the decency to ask Azer to change the name of the kik package and provide a migration path - they gave him ample opportunity to do so but he refused. Did they? I may well have missed it, but I've seen no mention of that so far, only "kik tells azer to cease and desist, azer says no, kik tells npm to cease and desist, npm tells them yes"
Not really... I worked at a company that had the name squatted on GitHub. Took two emails and some negotiation and we were able to secure it from the previous owner. Just because a name is taken doesn't mean you have to find something else.
In regards to your "what if I download malicious code this way" the source is open and easily hashed. RubyGems provides the SHA hash for all gems for you to verify and I can't believe NPM doesn't or wouldn't, or that the paranoid among us wouldn't check this themselves
LOL. I Promise I won't
Well you're wrong, azul stated on a GitHub issue thread that anyone is welcome to re-publish and further maintain his modules. How is it a problem then when NPM themselves republish it?
No one with any sense would confuse a command line utility with a messenger service. Trademarks do not have to be defended against unrelated products to be valid.
As soon as Kik intended to publish on NPM, a failure on their part to pursue trademark protection against a pre existing `kik` module can void their entire trademark. We know Kik wanted to publish on NPM. They should have sent legal notice, not a personal letter, but other than that events transpired exactly as the law states.
The lawyers wanted "kik" taken down, the module that broke Babel etc. was "left-pad", collateral damage of the author's knee-jerk reaction to unpublish all his modules without any warning. Also, it didn't happen immediately at all.
No. I am angry with: &gt; This action puts the wider interests of the community of NPM users at odds with the wishes of one author; we picked the needs of the many. NPM took steps in violation of the code author's intentions. The author wishes to separate their code from NPM, but NPM decided to break that intention (deliberately) and bump the version number. NPM has never done this before. The troubling implication here is that code authors should, now moving forward, **never unpublish any package from NPM**. If you do unpublish NPM can republish your code without your wishes while simultaneously transferring ownership of your packages without your permission. The former is a valid means of preventing the latter, but now the former is no longer valid at all. The licensing allows republication of the dependency, but it also conversely allows the code author (as well as anybody else down stream) to tell everybody else to go fuck themselves and break everything along the way. There is no liability, warranty, or contractual agreement associated with the code.
It might as well have been a huge, important library instead of the tiny "left-pad". It's besides the point how big it was. The module author chose the suicide-bomber way of dealing with things to call attention to his pathetic legal dispute and it even worked, people are starting to jump the bandwagon of lawyer-hating, calling for "free software for free people" and other unrelated shit.
I've been helping a bit with the crypter project before I started this. I don't believe facebook do block it. Not intentionally anyway. But it is possible.
Check out this: https://addyosmani.com/resources/essentialjsdesignpatterns/book/ which gives a good overview of the JS patterns out there with working examples. I personally prefer the module design pattern over prototypes (and I've seen it more often). 
Is it just me or does it take more work to find a package to add padding on the left on a string than to actually implement this one-self?
What? Azer is a person, Kik is a huge company who cold-emailed him with the threat of a lawsuit. Fuck that, Azer doesn't owe them "professionalism," ESPECIALLY in response to the flippant and casual language of the message he's responding to.
What you are saying is there is no way someone would come across or use both products and that's not true. &gt;A brand is about so much more than a name. Exactly. That's why corporations protect them. &gt;your example implies there's a similar functionality (providing food), just in a different style. No. My example is to show there would be confusion. If someone came out with Subway packaging then it might make someone wonder if Subway uses that or endorses it. &gt;They're both businesses, but their goals and audience are entirely different Hence, one of the purposes of trademarks and protecting them. So someone will not mistake your company and its products with those of others. What if Subway Kindergarten became synonymous with a kitchen that poisoned its food?
&gt; it happens all the time for stuff that is legal-related And is pretty much always presented as a threat, so I fail to see your point.
Protect your brand name... Where? Npm packages? Ruby gems? Gulp packages? Photoshop extensions? iPhone apps? Where does a trademark enforcement stop?
&gt; We don’t mean to be a dick about it, but it’s a registered Trademark in most countries around the world and if you actually release an open source project called kik, our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that — and we’d have no choice but to do all that because you have to enforce trademarks or you lose them. In other words, if you don't do as we say, we'll hurt you and make you. Have a nice day. This both meets the definition of "dick" and includes a "fuck you." The civility of the language does not make it polite, just hypocritical. 
&gt; NPM was not under legal threat ... They can fight that one in court forever but NPM would never be found liable. I wish we lived in a world where that actually mattered. The fact of the matter is that NPM cannot afford the time, energy or money required to take this to court, even if they would have won. And if you know the details of trademark law, this is far from a slam-dunk case for NPM. They would literally be betting the entire business on the outcome of a single case. That's just a terrible bet that isn't worth the benefits they would get from a positive outcome. &gt; The guy at KIK literally said that Azer wasn't being nice and giving them the name "Kik" for their own package. He was clearly trying to resolve it amicably before involving lawyers. If NPM had not conceded, a C&amp;D + lawsuit would almost certainly be on the horizon. Again, you don't have to be right to sue someone and make life suck for them. Anyone can sue you at any time for anything. &gt; they un-un published ... it's his account I don't really understand you here but I think you are claiming they re-published it under Azer's original account username - [this is false](https://www.npmjs.com/package/left-pad). &gt; Which they are completely within their legal right to do.....but I wouldn't ever use them after this. Then you are in for quite a wake up call when you realize that nearly *every reasonable company in the world* would have made this same decision. Companies generally don't involve themselves in legal battles unless they absolutely have to, unless they have a death wish.
The worst action in all of this is NPM giving ownership of kik to Kik. Unless they have a lawyer/judgement telling them to do so, it's ridiculous. You wouldn't expect github to give your repo to someone else if they ask nicely? You wouldn't expect gmail to give your e-mail address to someone else. NPM needs to be called out on this one. 
So ... anyone can review all existing software packages and register them as trademarks and then take over the names from the devs?
He has a sharp tongue, but I would argue that the only unprofessional one here was the allegedly Open Source package manager. And they probably know it too. There's tons of users ready to hear about a new, stable, better alternative.
thats a graet resource, thanks!
&gt; If you do unpublish NPM can republish your code without your wishes If you do unpublish, *anyone* can take that package name and republish *any* code, including your own, against your wishes. If NPM hadn't stepped in, a malicious actor could have taken the name, published a "minor update" with malicious code, and exposed thousands of users to a security hole. Instead, NPM smartly shepherded it to ensure the same code was republished, from a new maintainer. This seems like the best possible outcome to me. &gt; The licensing allows republication of the dependency, but it also conversely allows the code author to tell everybody else to go fuck themselves and break everything along the way. I'm not sure what you're claiming here. No one is arguing that Azer was not within his rights to remove the software, of course he had the right to do that. What is at issue is whether or not NPM has the right to re-publish it, which they very clearly do.
I don't want to learn it because I get paid to do so, I'm just really interested in writing the best code I can
Your examples are those of one who obviously no understanding of how trademarks work so I'll leave you the time to read up on it.
&gt; That's not a huge difference. I suppose it's subjective. In my mind there is a HUGE difference between "I'm removing this to avoid getting my ass sued off and bankrupting my company" and "I'm removing this because I want to". When you publish your code and publicize it as being ready for production use, you don't have any obligation to maintain it or support it, but IMHO you *do* have a moral obligation to *not willingly and purposefully break all the shit that depends on your shit*​. &gt; Did they? Yes; the recently published e-mail chain confirms what we've been hearing this whole time - that someone at NPM reached out to Azer and asked him to republish the package under a different name, he refused, and only then did they take it down.
Telling someone that touching a hot stove will hurt isn't a threat. Even if, as here, the stove belongs to you and you're responsible for it being hot. If you accept that it's okay for Kik to have a trademark on the use of the term "Kik" in relation to computer software, then, as Kik said, they *do* need defend it and Azer releasing a computer software project under the same name *will* result in a call from trademark lawyers. &gt; The civility of the language does not make it polite, just hypocritical. Actually that's...exactly what it does? Civil is a close synonym of polite; the nice tone you deem hypocritical is *exactly what being polite means*. You're focusing on the substance, rather than tone; "polite" is a description of tone, not substance. Yes, polite language is very commonly hypocritical. And?
It's worth noting that their threat was incredibly broad and threatened far more than targeting a single project with removal. The only two actions they might have required were contacting github and contacting NPM. Neither of these require banging on doors, taking down accounts, or other vague actions. &gt; We don’t mean to be a dick about it, but it’s a registered Trademark in most countries around the world and if you actually release an open source project called kik, our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that — and we’d have no choice but to do all that because you have to enforce trademarks or you lose them.
You define your functions, and then "reveal" the ones that you want to be public. The advantage is that your public methods can no longer be overridden, so anyone who wants to fix a bug has to go in an do it the right way, instead of monkey patching it.
If you regularly use JS, you've probably heard of Lodash. Lodash can do this.
Umm yes they did? Read it again. &gt;Is there something we could do for you in compensation to get you to change the name Then he replies with the demand of $30,000 which is obviously not a realistic compensation for an npm package name
I'm going to wait and see what the official response from [npmjs](http://blog.npmjs.org/) is. Until they have time to make a decision about they want to move forward and implement that decision I can't be sure how I'm going to respond.
The web is popular. The client side of the web can only use JavaScript. JavaScript is popular by extension.
The most important thing is that we always have an AbstractServiceProviderLocatorSingletonProxyFactory.
&gt; Kik was polite Threatening people is not being polite. "our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that " That is an ultimatum, not a request. How cool would you be if someone started threatening you? It was Kik that first started using the word Dick. Not Azer. He used their own phrase. 
They don't have to offer him anything, they could have just gone straight to lawyers since it's their trademark and they legally have to protect it if they want to keep it. The point is they tried to settle the matter without the fuss of lawyers (something they didn't have to do) , and the npm author acted extremely immature and short tempered. 
This "gotcha" is such a great example of why so many people find value in JS micro-modules.
The package was released under the WTFPL, which literally states that you can do "whatever the fuck you like" with the code. This certainly includes the ability to republish the code.
By extension are you not going to rely on any package that relies on such a package all the way down the dependency chain and check that it hasn't been introduced every time you type `npm install`?
That's not a threat. He's letting him know that if he doesn't comply, they'll have to get lawyers involved in order to defend the trademark. That's how trademark works.
I wonder how no–one brought up a in-house repository manager, like JFrog Artifactory or Sonatype Nexus? We usually hear a lot of rationalization why it’s OK not to use one (the dependencies are few, their updates are rare, the repository is an overkill), and here we are. The only ones who weren't affected are the ones that took the time to install it.
Exactly. It has the largest install base, by far. 
Just because you work on an open source product does not exempt you from obeying copyright and trademark law. What makes anyone think it would be okay to use those names in the first place? 
&gt; Threatening people is not being polite. "our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that " That wasn't a threat, it was a fact. You are obligated to defend your trademarks, or you lose them. Kik, not wanting to lose their trademark, was stating the fact that if they could not come to an amicable agreement (and they were offering compensation), they would have no choice but to litigate, or risk losing their trademark altogether. It wasn't an ultimatum. It was a statement of fact. Had they not had the obligation to defend their trademark, in would agree. But the fact remains they were in a position where, if NPM didn't cave, litigation was their only option, and were simply. Stating that as fact.
I completely agree with you. Kik is a very well known brand, and frankly, they were very lighthearted about the request. They could easily have led with a cease and desist. Instead, they sent a fairly friendly request, and even offered to try to find some kind of fiscal agreement. If I were the developer, I'd have been a lot more amenable to their requests, not because they are a company, but because they do have a large and legal reason for their request, and, frankly, because they were nice enough about asking.
Interesting!
&gt; The team behind Netflix.com has switched from a Java-based HTML renderer to a JavaScript one that they can run on both the server and the client. &gt; To decrease the time users spent waiting, Netflix has removed the Java server-based renderer and reduced the amount of HTML sent down the wire. In a post describing the change, Kristofer Baxter, said that by not rendering pieces of the app that the user will never see (among other changes), they've been able to speed up the time til interaction by 70%. sauce : http://www.infoq.com/news/2015/08/netflix-universal-javascript which references netflix page : http://techblog.netflix.com/2015/08/making-netflixcom-faster.html 
Alot of feelings on both sides are being stirred up in this thread. Guys, the bottom line here is that if Kik wanted, they could of started with the lawyers. Azer was breaking copyright and trademark law. Sure - alot of open source products do this. That won't make it okay. I can empathize with Azer a lot in this, but the bottom line is he should of either beaten Kik to the trademark, or chosen a different name. Sometimes, that's just how the world works.
Agreed. Kik handled this quite well. This is how trademarks work. They did what *they had to do* as politely as they could.
You're right :)
`this` changes every time you call a function. `var self = this` and `this.name` are in different functions, so that means they don't necessarily have the same `this` value. If you want the value of `this` from an outer enclosing scope, then creating a variable like `self` is one way to do that. &gt; From my limited understanding of JS, I thought an object must be fully constructed before its variables can be referenced by anything. Preventing code halfway through the object referencing something earlier in the object. This seems to contradict that. You seem to be missing the difference between defining a function and calling a function. `forEach()` is not called on the object until after it's been fully defined. It's mentioned in the definition of a function, but that code doesn't actually execute until you call the function, which only happens on the last line. 
I think you don't know how trademarks work
We are looking into a solution of using Docker to make a volume container which is just our node modules folder. So 1 of us can build the image, and we all (including production ) will be able to just use that locked image. Updating or adding new node modules would just be building the new image. 
Bob needs a sucker punch and then a lesson in etiquette. If you feel the need to preface a statement with "I don't mean to be a dick about it, but"... You're inevitably going to come off as a exactly that. In addition, the irony of a patent guy not doing the due diligence regarding the person he was addressing is priceless. Fuck you Bob. You're a dick.
To answer your question, trademarks only apply to certain categories. The argument here is that kik is software, and kik is software, so kik infringes on kik. You could make a strong argument either way. Your examples would not hold up in court (although in fairness, npm might not fight requests, but it'd be much fairer to yell at them in your examples). There is no reasonable expectation of confusion between large beverages sold at a convenience store and a build manager. The fact that you must protect trademarks to protect them (which leads to more trademark complaints than is ideal) sucks, but trademark is actually one of the sanest and least abused IP laws out there. Copyrights and software patents, for example, can be awful. If you're going to worry about something, worry about those. 
Then learn it, but understand that the best code often completely avoids certain structures. In my opinion, js prototypes are one of these: well written code without prototype manipulation results in better code than well written prototype manipulating code.
A trademark is not a copyright. "Trademark infringement" claims are valid when people might be confused about the origin of a particular term. As the only people using the kik package are presumably reasonably tech-savvy enough to realize that there's no confusing a command line tool with a messenger...there's no valid trademark claim here.
They didn't offer any money. He gave them an offer and they refused it (and refused to negotiate). 
Prototypes are an example of a part of a language that yields better code if avoided. Js is simplier and less error prone when avoiding new, this, and prototypes entirely. If you do it right, it's as efficient or more efficient than an equivalent prototype based pattern.
reddit is a shitpost goldmine.
I commented some code and explanation and it's not showing... not sure what's up...
It was a fact. Trademark is, as they say, use-it-or-lose-it. They couldn’t *not* get their lawyers on the case or else they might have to eventually rename the whole company 
Agree - being polite and being an asshole are not mutually exclusive. Kik basically said "we're taking your cheese - we can either do this the easy way or the hard way", and unfortunately NPM decided to just go with the big dog.
Haha what the fuck? How can anyone stand behind Azer? What kind of unprofessional email response was that? Kik (the company) has every right to protect their trademark. And hell, I thought kik the library was made by Kik the company. I'd much rather have the candid conversation the Kik guy offered than get a cease and desist.
Which shows how we sell out. The dev pulling his packages and causing pain to many is a useful event as it goes above the pain threshold and gets people starting to ask questions. I'm wondering if kik's packages bring as much value to the community as the removed ones. I'm also wondering if npm's maintainers' choice to serve a corporation contradict the core values of the ecosystem. If yes, this is a case of said values getting corrupted by competing ones. 
If you tell someone "if you jump from the 38th floor of this building you will die" is this a threat? I saw no threat in those emails. They even said they preferred to compensate him (without having to), just to avoid that bad result they stated would happen.
I guess Kik would have been better off going straight to the lawyers since their attempt at informal contact seemed to have backfired according to the community.
&gt;our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that — and we’d have no choice but to do all that because you have to enforce trademarks or you lose them. That's not even remotely comparable to what they said. This isn't even a thinly veiled threat. 
I believe the fact that those names were used in commerce beforehand would make it harder to [enforce such a trademark](http://www.uspto.gov/trademarks-getting-started/trademark-basics) (idk the history but I believe the Kik app was released before this guy's open-source project): &gt; Be aware that any searches you conduct on [TESS](http://tmsearch.uspto.gov/bin/gate.exe?f=tess&amp;state=4807:dxmmha.1.1) are limited to the USPTO’s database of federal trademark applications and registrations and do not include the marks of other parties who may have trademark rights but no federal registration. These rights, known as “common law” rights, are based solely on use of the mark in commerce within a particular geographic area. Common law rights may be stronger than those based on a registration, if the common law use is earlier than the use that supports the registration. Also, if a name of a software package is generic (like `leftpad`), it can't be protected in its category; the "in its category" bit is important, because that's how we can have both an "O'Reilly Automotive" and an "O'Reilly Media" and in fact there are several non-conflicting trademarks with [`O'Reilly`](http://tmsearch.uspto.gov/bin/showfield?f=toc&amp;state=4807%3Adxmmha.1.1&amp;p_search=searchss&amp;p_L=50&amp;BackReference=&amp;p_plural=no&amp;p_s_PARA1=live&amp;p_tagrepl~%3A=PARA1%24LD&amp;expr=PARA1+AND+PARA2&amp;p_s_PARA2=O%27Reilly&amp;p_tagrepl~%3A=PARA2%24COMB&amp;p_op_ALL=AND&amp;a_default=search&amp;a_search=Submit+Query&amp;a_search=Submit+Query) in them. BTW open-source projects often do register trademarks, like Mozilla.
You seem to fail to see many points. I just don't know if it's on purpose or not. They said that if he kept infringing the copyright law there would be problems, but they *didn't want it*. Not only that, but offered compensation while they owned him nothing. If that is a threat, than in your logic the following statement is also a threat: "Jumping from a building is going to kill you, and I don't want that. Here, let me compensate you in exchange of not jumping." Only an absolutely evil person would threat someone like that, for sure.
&gt; "Kik" is already taken, deal with it. Oh, the irony. That's exact the argument to make Azer drop the name. Kik.com took the rights over the name. It was already taken. And he got angry at having to deal with it.
Hilarious. Thank you, sir or ma'am, as this made my entire day.
That's...probably a good thing. Use `window.postMessage`, you uncultured brute!
Odd... I still can't see it... the body of the post says "there doesn't seem to be anything here." If you look through my comment history though, I think you can see my response. Odd...
 var $$ = { id: document.getElementById.bind(document), cn: document.getElementsByClassname.bind(document), etc, } Something like that. Off the top of my head and on a phone so sorry if it's incorrect. Just a super simple selector alias library. I never needed anything more or anything less. I also don't use it that much anymore thanks to the advent of frontend UI frameworks like Vue and React.
It is still stating a fact. Their lawyers *WILL* do that. That's a fact. It's not even because they want to, but he *is* using a name to which they own the trademark. Companies spend money to get that trademark, and they spend money marketing their trademark. I don't know exactly what is making you upset here. Would prefer npm supported a trademark infringement? Isn't that even worse?
Local mirrors do not solve anything. If an important package disappears from npm, you'll still have other packages depending on a nonexistent package. Even if every single existing user of these packages has set up their own local mirror, new users will be out of luck. NPM (if they ever actually said this) is wrong when they say that their repository is not a build tool. Package repositories are build tools. There are no possible mitigations when code simply disappears from where it is supposed to be.
Empirically speaking, you seem to be mistaken.
https://m.youtube.com/watch?v=Gc2QULKScco
No, you cannot just register a bunch of package names as trademarks in order to acquire the rights to npm package names.
It's the two methods for referencing an object member (not just property): dot and bracket notations. Any notation can reference an object member as many levels deep as the JavaScript engine can or allow. e.g. window.document.location.pathname.substr(0,1).toLowerCase().length window["document"]["location"]["pathname"]["substr"](0,1)["toLowerCase"]()["length"] 
How about this: people create whatever packages they want, but if the legal owner of that trademark asks for it they comply instead of helping infringe it? That is better than simply preventing people from creating whatever package they want. That seem like a good rule. We could even extend that. A better rule: if the legal owner of the trademark asks, npm first let them talk to the owner of the package. If the owner answers with stuff like "fuck you" and refuses to talk, npm won't help infringing the trademark. That also seems like a good rule. If that rule were in place, things would have happened as it happened. So... no reason to get angry.
I don't like that they say that they "taking down your account and stuff like that" as something inevitable. The fact that they have some rights on url in private package management system is very disputable. Like, if i have "rogaikopyta" trademark doesn't guarantees that I have full access to manage apple.com/rogaikopyta
Being amicable, which is what NPM strives for, isn't fully the same as being polite: polite *- adjective -* having or showing behavior that is respectful and considerate of other people. "they thought she was wrong but were too polite to say so" synonyms: well mannered, civil, courteous, mannerly, respectful, deferential, well behaved, well bred, gentlemanly, ladylike, genteel, gracious, urbane; amicable *- adjective -* (of relations between people) having a spirit of friendliness; without serious disagreement or rancor. "there will be an amicable settlement of the dispute" synonyms: friendly, good-natured, cordial, easy, easygoing, neighborly, harmonious, cooperative, civilized, nonconfrontational **Kik ^TM** fucked this one up from the get-go. Hypocritical speech ***is not amicable.*** Using implied threats of seeking legal remedies through the courts ***is not amicable.*** Doing an end run around the developer, who created the *kik* JS project prior to **Kik ^TM Incorporated**'s existence, seeking to override the developer's rights by pressuring NPM with the same implied threat of court action, ***is not amicable.*** Another view: http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/ Maybe **Kik ^TM** and NPM would have seen that discretion is the better part of valor, if they'd bothered to investigate who exactly they were fucking with - a dev with serious roots in the community, with major software dependent upon his benevolence.
If you're in my house trying to steal my TV and I point my shotgun at at you and say "please put the television down and leave immediately or else this will go bad for you", I'm threatening you. Politely yes, but still a threat. However, that doesn't make my threat *wrong*. You're the one breaking the law. Think about it this way: if Kik was in the wrong then why would they want the legal system to take a look at their claim? If Kik was in the wrong then the last thing they'd want to do is get lawyers and judges involved.
I'm *pretty sure* he was trying to sound casual, but threatening legal action and being casual don't really mix very well.
Since when does being an open source developer give you the right to ignore laws? Kik had every legal right to rain down on Azer, but chose not to. Azer's responses were insulting and childish and his actions were equally as irresponsible and I'm a little worried how anyone can support this behavior as a member of the OSS community.
&gt;npm won’t suddenly take your package name. We totally did take his package name, but that was different, because we say so. &gt;This incident did not arise because of intellectual property law. Also, we weren't legally obligated to do so, we just wanted to. - - - My main take aways from this are these two: * We will make it harder to un-publish a version of a package if doing so would break other packages. * We will make it harder to maliciously adopt an abandoned package name. I'll be interested to see how these shake out. The security implications of taking up an abandoned package name is *huge*.
It's more that good examples needed more work than I was willing to do for Internet points. But even if the examples aren't top notch, the point stands. NPM should have required something more official and legally compelling than a forwarded email from a non lawyer. The standard for YouTube DMCA take downs is higher than that. 
The first paragraph reads like a threat. That is not how they should have approached this situation. Lawyers should not have been mentioned at all. Their first email was reasonable, but instead of saying "Can we get you to rename your kik package?", they should have instead phrased it more like "Would you be willing to discuss with us the possibility of renaming your kik package". That would have encouraged a more open and friendly first response from Azer, even if he originally declined. In their second response, they should have elaborated more on why they are keen on using the package name. Explaining who they are, what their product is, and why the name 'kik' is important to them. Then indicating that they are willing to offer fair compensation. They should have also been willing to move on with an alternative package name if Azer continued to refuse. Besides, though I'm not a lawyer, I don't think Kik would have won a trademark dispute in court, since a trademark doesn't give you unlimited rights over the name in all situations. It has to meet certain criteria in order to be considered infringement. NPM also fucked up in this situation. They shouldn't take sides in trademark disputes without a court order. NPM has always been first come, first served with names, and that's how they should be.
&gt; We totally did take his package name, but that was different, because we say so. The Kik package fell under their dispute process while the rest were unpublished by the author. The final name and version were taken over due to the extraordinary circumstance of it being foundational to the ecosystem. You can debate their dispute process but `left-pad` is pretty clearly not something the vast majority of package owners should worry about.
I'm pretty sure it would have been a non issue if there was an `@azer/kik` and an `@kik/kik`. ~~BUT, so long as it costs [$7 a month](https://www.npmjs.com/private-modules) for scoped packages, that ain't happening for most packages.~~ Most people I know of who want a private npm package would just put it up on a git repo or install it from a local directory or something. e: I guess it doesn't [cost anything to have a *public* scoped package](http://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages). This indeed now does raise the question, couldn't they just have made them both scoped?
Then debate their dispute policy that informs their decision. The policy isn't secret and isn't new.
Unsurprising and unremarkable. Another very widely distributed technology is feces.
That's rather...aggressive use of styling. &gt; Hypocritical speech is not amicable. I'm not sure it's been demonstrated that kik was being hypocritical, but it's certainly true that to the extent that kik and Azer both wanted the package name, they were in disagreement, which isn't amicable, by definition. But I think it's clear that, of the two people at odds, Azer was being less civil. Do you think that had no impact on npm's decision? &gt; Doing an end run around the developer, who created the kik JS project prior to Kik TM Incorporated's existence Kik Interactive was founded in 2009, and their app was publically released in 2010. The kik repo on github's first commit was in November 2015. Hell, *npm itself* dates from 2011; meaning every package on npm is newer than kik. &gt; if they'd bothered to investigate who exactly they were fucking with - a dev with serious roots in the community, with major software dependent upon his benevolence. That's...factually inaccurate. On every level. Plus, it doesn't matter: Package names shouldn't be yanked from anyone without some semblance of due process, regardless of how unimportant you are.
I think you are stretching the idea of "class" here. **JavaScript does *not* have any concept of encapsulation, methods, fields, or inheritance in the classical sense.** In JavaScript, there are only objects, which is a collection of properties. Properties can either be the object's own, or delegated to another object. That is, when you refer to a property that is not defined for an object, it will be looked up in the prototype chain. Objects and their properties, and that's it! No members, instances, variables, or whatnot. In practice, they can mostly be used for a similar effect to a certain degree, but they are in fact very different. Trying to reason about the prototypical model in terms of class-based concepts *is* the source of many unnecessary problems and confusion (and unnecessary work, apparently, because prototypes are markedly less complicated than classes). As another example, you can also get an object system with just closures. You would get things like encapsulation, methods, fields, and you can do parasitic inheritance. The usage would be like that of a class-based or prototype-based system, but again it's very, very different.
Under what trademark law are they allowed to make such demands from a non-commercial venture that targets a different area of technology? If they "rained down" on Azer, their hope would be to drive him bankrupt because they'd likely lose a legal battle if both parties could pay to play the legal system.
Its not really like that. You don't have control over the lawyers. They just go to war with whomever the people in control want them to attack. The precedent in trademark law is clear - kik had a valid legal point. Its like me opening up a McDougals. Even if I opened up McDougals 20 years before McDonalds became popular - they can STILL argue that the name creates trade dilution. Its more a matter of perception and power than fairness - and the lawyers don't care about fairness. The dev was warning the guy that they would strip it from him if he did not surrender it. Blame the system. It was not the dev's choice to wade into this water. Nor does he have control if the lawyers pick a fight. I love Azer's response. I really love that he broke thousands of nightly builds with it. I can imagine the massive pager duty spike all over the world. But- Azer should have just understood the game and tried to play ball. He probably could have capitalized on it a lot more than any of the clout he gained by having a world famous pad left (Its worse than getting famous for Flappy Birds).
The old men that write this laws and think the internet is a series of tubes is not going to understand or care about API subtleties.
I am not confused whatsoever and you are only adding information the clueless redditors are, as I've said twice, oblivious to. While we are not aware of what the trademark covers, which service or product it is assigned to, these are similar in that they are software products and any "same name" used can cause confusion or ambiguity leading one to believe they are from the same source and I believe this is the reason the contact was made.
Obama is. /s
&gt; ...and we’d have no choice but to do all that because you have to enforce trademarks or you lose them. That's the important part that people are missing. Kik (or whatever their name is) is laying out their situation, they have to pursue this because they want to retain their trademark.
That isn't how it works. 
or the `className` property, because not all old-school browsers support `getAttribute` and `setAttribute`
&gt; They weren't really asking nicely. &gt;Unfortunately, your use of kik (and kik-starter) mean that we can’t and our users will be confused and/or unable to find our package. Can we get you to rename your kik package? Sounds nice enough to me but here's the thing. They don't have to be nice. They have had their trademark infringed and are in their right to come down on them in court. Here's a paraphrase of the letter I saw to a company I once worked for: &gt;You are violating our trademark and must change your logo immediately, submitting it for our approval within 30 days, or lawsuits will reign down on you! This is business and the law. You want to know how many times this happens where a business thumbs their nose at this? Every day. It costs money and time to chase down these people. Kik sounds like they were being reeeeeally nice.
&gt; there needs to be a 3rd party full cache of npm like google caches websites. I think you're thinking more about archive.org; regardless, there are [ways to get content removed](https://archive.org/about/faqs.php#20) from the archive.org cache (FAQ uses the word "copyright" but the answer is generally about "intellectual property"), and Kik would surely have the cached version of the trademark-infringing repo removed or renamed too.
Ah, must be the Java! Yeah, really long build steps tend to kill productivity. Is it really necessary to do ALL of that on the local machine? Probably not. 
Down with the server-side!
&gt; I am now considering removing my packages from NPM. One of which is on track to get 550,000 downloads this month. WAAAAAAA! MY CODE! MINE! 🚼
(Insert system) is a shit(system subject) goldmine. Twitter? Check! Facebook? Check! GitHub? Check! NPM? Check! Jquery plugins? Check!
Have you looked into using binary repositories? Nexus and Artifactory are some good places to start. You can use them to cache your third party dependencies. Then your CI build would resolve dependencies from them. They version and track all your dependencies, both third party and upstream, and have support for all major package management systems.
KIK has no Trademark over the `kik` name, nor its use as a command line tool, nor software library. KIK has made no reference to a valid registered Trademark that would apply in this instance. How can NPM make this transfer without even *looking* at an actual Trademark registration? Are you aware of the `facebook` and `square` packages on npm?
A lot of broken builds. Better yet, what if he published malware instead? Dev boxes, CI boxes, and prod boxes all with malware.
You can't trademark (or more correctly *defend* a trademark) something that can show "prior use." If my software package, "Beejee," has existed since 1995 then in 2014 Beejee Inc trademarks the name "Beejee," I can show prior use and not be subject to their trademark. However if I created my software package *after* the 2014 trademark, then I am absolutely in violation of the trademark.
Agreed 100%. Long term development and maintenance *requires* that a project - in any language - pin its entire dependency graph down to the byte. I've had a lot of good results using Synopia in an 'offline' mode (not using proxying) as a npmjs.org cache of sorts. New packages come in, and are manually registered to that local npm server as needed, all kept in sync with a well-configured .npmrc file. Shrinkwrap does the rest. The problem with adding `node_modules` to the repo is that `git status` takes forever while it checks everything to figure out what's staged and what's not. In practice, I've found that you're just better off not hammering the git repo like that. &gt; Updating your dependencies is not a trivial operation and should only be done for good reason, not because "later is greater". This raises an interesting question: where does one go to find "critical updates" for JS libraries, like security vulnerabilities or mishaps with project repos?
&gt;Azer: We’re reaching out to you as we’d very much like to use our name “kik” for an important package that we are going to release soon. Unfortunately, your use of kik (and kik-starter) mean that we can’t and our users will be confused and/or unable to find our package. Can we get you to rename your kik package? That was the first message. Seems polite enough to me. No mention of lawyers, trademark, etc. Just "Hey, you're squatting on our name. We'd like it back." An email politely requesting someone to *stop infringing a trademark* is not a threat. A cease and desist is a threat.
KIK went overboard by threatening to sue to opensource dev over command line utility.
Trademarks name exist in field of use. If azer was making a competitor project to kik, then he would come under trademark infringement. However that is not the case, hence by law, azer's claim on name 'kik' can not be denied by Kik company. PS: I am not a lawyer, but this is what I heard on wiki and Reddit 
Ok, I know some people like the openness presented here by Kik and don't like Azer's response, but I just wanted to point this out from the perspective of a teacher who works with children from kindergarten to the 9th grade. If you get a short response like this as the first reply: &gt; Sorry, I’m building an open source project with that name. This indicates that the person feels an emotional attachment to the name. Also, since the response is short and to the point, it is clear that they don't see any logical reason to give in. When responding to this, you **need** to use empathy (honestly, something severely lacking in a lot of these types of conflicts in the programming world). So rather than responding with this: &gt; We don’t mean to be a dick about it, but it’s a registered Trademark in most countries around the world and if you actually release an open source project called kik, our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that — and we’d have no choice but to do all that because you have to enforce trademarks or you lose them. A good, proper response would have been something that: 1. Explains that Kik is their company's name and why not being able to use it would put them in a hard spot. Yes, it would be reiterating the point from the first email, but objectively, that first email wasn't exactly clear. No company links, no explanation of what this "important" package is, etc. **NEVER** expect someone that you are asking a favor from to go out of their way to figure out what you are saying. That's your responsibility. 2. Don't mention trademarks or lawyering up. That's a power play and all teachers know that you don't need to wield the authority stick most of the time. With something like this, it's worse because you are threatening a person's livelyhood. If that's your go to response, you will 100% get instantly shut out both emotionally and logically. Expect compromise to end right there. 3. When asking for a favor, cause this is a favor, and trying to compromise, don't ask them what they want. They obviously want the package name. For those of you who have been in salary negotiations before, this should ring a bell. This is a power play by Kik to give up as little as possible for what they want. **Kik** is the one asking a favor. Say the word **favor**. Make it known that **Azer** would be doing a good thing by compromising and helping you out. Make the first offer. Give Azer something to think about and go from there. Having seen Kik's initial attempts at communication, I can now 100% understand Azer's response. It's the obvious result. Immature? Overblown? Honestly, this is pretty much par for the course with most humans no matter the age. Some of us are just better at stopping and taking a moment to think before replying. On the internet where you cannot see who you are talking to? There is even less of a barrier. I can make a lot of parallels to teaching and working with children, but I think what I wrote should be clear enough. Kik is in the wrong here and really needs to apologize for their actions - to the community and to Azer - and should put in some effort to helping NPM fix this fiasco. 
&gt; I get a call from the Coca Cola company saying that the painting is infringing on their copyright. copyright != trademark Also, I'm not sure the Coca-Cola Company has a trademark over that name in a field similar enough to fine artwork. Then again, Vincent van Gogh died 2 years before the Coca-Cola Company was founded, and 4 years after Coca-Cola itself was invented.
http://i.imgur.com/BMdYLSf.png
What if the malicious actor replaces the hashes too? 😱
I would have believed it if court has said it, but your and my speculation are just speculations. Real issue is that Kik threatened azer and npm transferring ownership while knowing that one party wholeheartedly disagreed.
Clone the source and check it yourself? This is a problem with sole central repositories and not signing code. Look at how the Arch repos and AUR handle it, for instance. Mirrors, hashes, and strongly encouraged to required signatures.
Uggghhh.. That site though.
&gt; the ausense of functions and regexp in JSON It took a while for me to see that you meant "absence" in that phrase.
Sorry and thank you. English is not my native language :)
I learned a lot. And was my very first npm module so I break the ice with the community. I hope to contribute more to this community that has given me so much.
&gt; I'm entirely focused on npm just deciding to take packages from people ***when they feel like it*** because it's horrifying. This part didn't sit well with me. And I wasn't entirely sure how npm's post-mortem would be written to make this seem the right (ethical?) move. Interestingly, @izs thinks that if Azer's kik module was sufficiently 'popular', then it may have been a different story: https://twitter.com/izs/status/712817000632811520 Unfortunately, @izs destroyed any and all opportunities for Azer's kik (the js project) to grow as a publicly consumable npm module. ------- I would bet that within 4 months, kik (the company), wouldn't be publishing ***any code*** to either http://npm.im/kik or http://npm.im/kik-starter (how on earth was kik-starter disputed?). 
So, Kik was polite and every right to threaten to get the name back? Is it? The only reason they went after a single developer is because he cannot have array of lawyers. They didn't go after this Kik http://www.kik.de/, even when they're "active" in EU. I don't think Azer's first response was polite enough, but given the conversation, even that wouldn't help him. Bob was hell bent to get the name at all cost. 
So you're proposing systematic unpublishing of potentially established package names, much like what happened with left-pad? 
You don't think people trying to install Kik's official npm package which presumably integrates with their chat service might be confused by the existence of an unrelated npm package named Kik? 
If that's true then things are different. I guess we'll never know what really happened because there are different accounts of the story. 
They way Kik (and then NPM) reacted, even namespaces wouldn't have prevented this fiasco. Anything kik, must be of Kik's, that's the clear message.
"Use npm" they said. "It's secure" they said.
Seems to me the author must have been willing to go to court and argue that there was no confusion, no damages, and thus no trademark infringement. That's only if Kik is willing to argue with a straight face that the code **did** cause likely confusion/damages, which is laughable. Instead they took their frivolous claim to npm, npm's handling of it pissed him off, and here we are.
Thinking that you are legally obliged to do something doesn't make it ethically right. And they had a chance to do the legally and ethically right thing; pay the requested 30 gran.
All the armchair lawyers in this thread need to shut the fuck up. You all have no idea what you're talking about.
Indeed. What Mike keeps saying as *polite request* is actually considered by most people as *veiled threat*, especially those on the receiving end of it. It amounts to almost criminality to use such statement without an intent to actually pursue a lawsuit.
Yes but the guys who wrote Lodash, surely they would just write their own left-pad? They would not use the left-pad module that broke some npm packages yesterday?
your toggle logic is incorrect. You should update #something to #tempatureF only if #something is not currently #tempatureF. And vice versa. if (something !== tempatureF){ something = tempatureF; } else if (something == tempatureF) { something = tempatureC; } $(".bob").html(something); Simply replace code inside document ready to $("#1").on("click", toggle);
&gt;kik has 200 million whatever users, but how many of them are node developers? kik presumably has dozens (hundreds?) of employees by now but none of them are likely to fit your conception a kik user. The point is not whether a kik user would be confused that `npm install kik` installs a different kik. That doesn't even make sense, as you said. The point is whether an arbitrary developer, sitting down at their computer to code something that uses a well-known library put out by kik, would think to `npm install someothernamenotkik` rather than `npm install kik`. Like, they read some blog post from kik, and think, "Gee, I could really use that in my latest project." So they hop over to their terminal and try to install it...but nope. Given how big kik is these days, it seems reasonable that, even if few node developers use kik the app/service, more of them are likely to associate `kik` with kik rather than with Azer. There was a way out of this, and it was for kik to pay off Azer for the name. 30k doesn't sound like a lot to avoid any possibility of bad publicity or bad blood, assuming Azer was serious about accepting it, increasing the offer to ridiculous amounts if necessary, then just publishing it as `someusefulnameincludingkik` until they could convince Azer they really wanted the name. Like Valve and steam.com, for example. Or Microsoft and windows2000.com.
I don't understand. Doesn't npm download your packages when using npm install? Isn't it all offline? How exactly did anything break then?! 
Looks Great!
Don't even think about this. I think the JavaScript community is grown to big to just abandon a major big player in this world. Also they will never go away completely. I am still using them. And many others will too. Beside this, I don't think that there is a great alternative.
It was not taken on npm. There is no discussion here.
Many people and companies are using continuous integration services like Travis CI, Codeship or Jenkins today. These will build and deploy your app once a new commit was pushed to the projects repository. When these services are building the projects they normally run `npm install` to install all dependencies, because the dependencies itself are not included in the repository. This command now will download all dependencies from the registry http://npmjs.com Therefore when this registry is down or one dependency on the registry has gone missing by unpublishing it, every `npm install` will fail. Once you installed all dependencies, after running `npm install`, of course there will nothing fail, because the dependency is on your local drive.
If anyone ran `npm install` again, installed babble, react, or any other module that depends on it, then that would have broken said module rendering your app useless. For those that didn't touch anything, it should've been fine. But for everyone trying to get babble running, there were some issues.
I can agree that they went with option three only if we both agree that this Kik guy was extremely bad negotiator and blown up whole process almost at the beginning. Instead of going for "we know it may seem not fair to you, but we have to do it or we lose trademark", he went for "we will take everything from you and make your life terrible, but I'm not ok with it because we have to do it or we lose trademark".
You weren't affected if you had already installed the module, and you didn't try to install any new modules that included it as a dependency (which was a shitload of modules.) But that's actually quite a rare case. You're really underestimating how frequently people run `npm install`. For example, it's common to test your code by starting with a blank slate and installing all dependencies and then running the testsuite. That ensures that you aren't accidentally relying on some aspect of your local machine. There are automated CI servers that do this all day long. There are also people that deploy software by doing that, i.e. when you release a new version into production, you start with an empty directory on the production server and install all dependencies. Again, this is meant to make things repeatable.
It's a problem with the package system if you need to checkin your dependencies. Other package managers don't allow for pulling the rug out from people like this. For example, NuGet allows you to unlist your package, but because people may have dependencies, you can't pull them completely. The npm way is complete insanity.
I'm not familiar with Smalltalk, but it seems like classes in Smalltalk are still *blueprints* for their instances, like other class-based languages. That is, they *define* what data an instance would hold, and what methods could be used to manipulate them. It may be true that there are class-based languages where methods are inherited by by delegation, but in Javascript, instead of blueprints, we are building prototypes, *based on which* new objects can be built. So there's no "is a" relationships at all (more like a "like a" relationship, maybe?). Inheritance in JavaScript means *only* delegation, nothing more.
I wasnt paying attention closely but npm might have given them indication that they were going to give them the name. If so that might have been why they didn't negotiate. I did find that strange as well. It seemed a bit excessive price but kik didn't even make him an offer or counter offer. 
mmmh I need to do more tests to be sure about it but it seems that on mobile you only need "user permission" to play an audio file. Once you got it, even if the file is loaded or not, you got the permission. Now it is possible in fact that you need to wait the audio file to be loaded a minimum, in this case there is an event for this: 'oncanplaythrough ' Look at buzz source code.
&gt;&gt;npm won’t suddenly take your package name. &gt; &gt; We totally did take his package name, but that was different, because we say so. I believe "suddenly" here means "we won't take your package name without first entering conversation with you as part of our dispute resolution process". i.e. your package name doesn't get taken without warning. That conversation with the left-pad author was published here: https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d#.fynnrzcw7
I think that if there was a pre-existing package called kik and I did an "npm install kik" I would expect to get kik not some social messaging thing. It seems like either we should move to username/package name like Ansible Galaxy so we don't have conflicts in a global namespace or the rule should be first come first served and the kik messenger guys could have gone with kik-messenger or something and not have contacted NPM in the first place... This is presuming that kik messenger even had a package that they wanted to publish in the first place and weren't just looking to cause trouble because of 3 letters.
The $30,000 was never meant to end up with a formal exchange of money. Azer ended the same sentence with "corporate dicks". In the event that Kik did pay Azer $30,000. Azer would probably have still kept the Kik name for himself. Npm is broken.
Indeed, it is a replacement for the npm client.
Thank you for this thoughtful post, I feel a lot of people would benefit reading this.
&gt; The security implications of taking up an abandoned package name is huge. This whole issue made me reconsidering how to safely use a package manager. If you use NPM to install a package you have to trust NPM, their CDNs, the current package maintainer and any future package maintainers. If any one of them chooses to integrate malware into their package it would just quietly slip into my software which could have huge consequences. The most likely candidate to do this are future package maintainers (as they haven't been vetted yet), so making it harder to maliciously adopt an abandoned package name will be a tiny step in the right direction. This still leaves the issue of current or future maintainers releasing a version that is compromised in the existing repo however. To combat this I'll probably have to configure static version numbers and manually update packages when needed. This only leaves me to trust NPM and their CDNs which, hopefully, should be ok.
so close, i need one for 6.
no
As experienced desktop software developer I'm just starting to get my feet wet in web development. I saw "npm" used everywhere, and in the back of my mind I always wondered why everyone depends on this. It kind of is what CPAN is to Perl, and having something that takes care of downloading the dependencies for you is good and reduces your web hunting time for packages a lot. But it introduces a single point of failure in your builds. So I don't exactly see the problem. You put your trust into someone else hands and you got burned. That didn't happen to me with CPAN in the last 12 years, but if it did, I would just deal with it myself. But I would never blame CPAN, as CPAN is a free service and I don't pay for it and am just grateful there are people out there that run this for free (probably from some donations or something). I see that npm Inc has some policy that makes it easy for some corporate guys to push into the namespace like this. Well, we all know this now and will treat npm accordingly. Maybe I overlooked something, maybe you have to sign some contract with npm that they suit your needs and does "no evil" and you get to make a fuss about it when it is not there to drive your builds.
Well, I'd like to see the same thing as with debian, fedora and other repositories. They already solved most of the problems like content trust with gpg, mirroring etc. decades ago. I wish NPM, Maven and Docker-Registry would adapt some best-practies from them. I'm feeling everything is repeating some way. Solutions from older technology doesn't get polished and reused. We just make new things and redo the same mistakes to some step.
Trademarks are specific to the type of product etc. kik.de sells cheap clothes and stuff like that. It's a whole different thing. A trademark dispute would be fruitless.
You've touched on a huge issue which isn't getting much attention. There are too many package managers out there which just insecurely download random stuff and bake it into your projects. One fairly simple way to make CDNs more secure is to not just specify a dependency as a name and version number, but also a secure hash. Effectively this but for package.json: https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity Then as a developer I can be mostly certain that people who run 'npm install' on their git clone of my stuff will get the same dependency code as what I have. Ultimately we need to be moving towards digitally signed packages/modules (i.e. PGP) and fully [reproducible builds](https://wiki.debian.org/ReproducibleBuilds) like what Debian is working on. 
Politeness should not be the deciding factor here. Also the job of that Bob guy basically is to be well spoken and diplomatic. Attributes I wouldn't ascribe to most devs I know including myself. On releasing the mails: I think if anyone of the involved parties could have released the mails it would be Kik. First of all azer already released parts of the thread [here](https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d#.c31dee4sb). So they only put things in context by publishing it. Also a release by Kik is more credible than from "the dev that got cranky and broke all the builds" since his emotional investment might have made him more prone to tamper with it. Which thankfully he didn't.
On a more technical side NPM should NEVER transfer ownership without the permission of the previous owner. If the name or the content infringe on some copyright or trademark than disable it. Otherwise I could acquire the trademark for some popular package, go to NPM with that and simply publish malicious code. Everyone depending on that package would involuntarily spread my malicious code. Even if the new owner does not publish malicious code it would break the builds of everyone depending on this code. A change of ownership is something that should be well coordinated by all parties to minimize complications and ease migration.
To quote the EFF on this: &gt; Quite simply, the view that a trademark holder must trawl the internet and respond to every unauthorized use (or even every infringing use) is a myth. It’s great for lawyers, but irritating and expensive for everyone else. And when done clumsily or maliciously, it chills free expression. Some random dude who has no idea how the Internet works decided to abuse his lawyer cred because a module author told him to fuck off and you roll over for him? If my lawyer writes you to delete the whole registry, will you do it? You have let your users down NPM. We will remember. 
People usually don't ship or deploy the node_modules folder, they let npm install download everything so they only have to track their own code with version control. But when you do that (and your node_modules folder is empty), a single missing dependency fails npm install completely.
To the ones that say kik shouldn't have claimed the "kik" package. What if I look for startups and register the package "startup-name", do you think that I should be the one owning the npm package just because I got to register before them?
Hah. Shows just how observant I am. Thanks for pointing that out.
industry, sometimes: &gt;DON'T REINVENT THE FKING WHEEL, JUST USE A LIBRARY THAT MANAGES THE COMPLEXITY FOR YOU industry, other times: &gt;DO YOU IDIOTS EVEN KNOW HOW TO PROGRAM? WHY ARE YOU USING A LIBRARY TO PAD LEADING SPACES? GOD!!!!!!!1 ok. Screw this guy and his opportunistic, riding-the-wave-of-what's-popular-to-get-my-name-out post with no real content.
If you released 3 versions of completely unrelated software package under that THREE LETTER name then yes.
Merp. https://github.com/ipmjs/ipmjs God bless open source.
I have no idea how that analogy makes any sense. Is npm the bullied kid because it deleted someones module for no reason? Or because they took his deleted module and published it again? They are not victims in any sense, they are now getting what they deserved for acting against common developer sense.
Kik is messenger, they don't trademark of code over third party source. If they released their own api, hosted on their server then nobody should've any problem
I don't know. I know I live in Brazil and yet I can't publish something using Mickey Mouse. How does that work? I have no idea.
Aren't libraries and APIs part of a product? APIs doesn't exist in a vacuum. They provide an interface to *something*.
I like this idea a lot. Although they would have to migrate in order to not break backwards compatibility with the current global namespace system. Maybe discontinue npm as it currently is in favour of something more robust/namespaced...
Who contacted Azer was not a lawyer. So it *was* someone other than the ground that made that statement.
Apparently they are not listed in Kik registered trademark. Go read the trademark description.
I saw that too. But how specific is that? Is "software product" a field? Is someone could explain it more I would appreciate.
&gt; No one blindly does "npm install kik" expecting to install a messenger client. That is completely wrong. I have watched developers do that time and time again.
Sorry but what you wrote is completly unreasonable. There is no powerplay here, they explained why things are like they are and why lawyers would be involved. It is true that if you have a trademark you have to protect it - simple as that. They were pretty polite about it and wanted to resolve this nicely. I'm an open source developer and also had some law classes in university related to patents and trademarks (on a CS track) - precisely so I can avoid shitstorms like this. I don't see any argument why it is OK to act like an asshole here.
Get a camera, popcorn, and stage battle of the titans between their lawyers?
Not so simple. He's not using the trademark in a way that breaks copyright rules. He's been developing this package independently for 3 years.
Just yesterday, I type "npm install kik" expecting to get an API connector to [KiK Textilien und Non-Food GmbH](https://en.wikipedia.org/wiki/KiK), the 1.2 Billion Euro manufacturer that has been in business since 1994. I'm shocked that anyone would think Kik referred to some pithy messaging client-of-the-week.
npm said one can request the name kik. I’m now discussing if I should write a small lib to provide a JS API for interfacing with the webstore of kik.de And then request it to become npm’s `kik`.
Which developers are these? Can you record them and put them on TV for us per chance?
"software category" that's a bit bloody broad, don't you think?
They think that because they hid their entitled intent behind acceptable wording they get a pass. Makes my skin crawl. I say give props to Azer for not mincing his words. I'd say that's more polite.
&gt; Are you aware of the facebook and square packages on npm? No. But I said "if the owner of the trademark wants it". If Facebook contacts npm asking for the `facebook` name, I think npm should definitely give it to them. As I said somewhere else, even Stallman defends trademarks. Among all his crazy, Stallman sometimes say very smart things. I don't remember his exact words, but his point was that giving Coca-Cola the exclusive rights over the name is good because a) if I drink a Coca-Cola and I like it, I know that every other Coca-Cola is going to be same by the same company, and b) if I ever have a problem with a Coca-Cola product I know exactly who to blame. If someone over there uses the name Coca-Cola (or Kik) to something like a npm package or a Mac app and it *does harmful things to my computer*, the Coca-Cola (or kik) trademark will be stained. They have to enforce their trademark and I think it's totally fair that they have the rights over the name for that reason. People won't stop and research if the coca-cola package on npm is really from the Coca-Cola company.
Kik owns their trademark which covers trademark class 09, which is the class of software in general. Kik is itself software. Don't see how there isn't a case there. 
They wrote their own. I'm not going to write my own, I'm just going to use lodash.
Kik's trademark only covers [audio/visual/text sharing](http://tmsearch.uspto.gov/bin/showfield?f=doc&amp;state=4801:r39pik.2.1). They have a whole bunch of trademark for Kik, but in general, they all have the words 'messenger' or 'transmit audio/visual/text' within them. Trademarks must be specific. You can't get a trademark for "software of all type for any purpose". Azer could pretty easily get a trademark for Kik in the field of code generators, and programmer productivity tools. Heck I could probably register a trademark for Microsoft, a fruit selling stand. 
Just search it. Which I did. They have a trademark in the class 09, which is the class covering computer software in the general sense. The only class for software. So yes, they do have a trademark over kik as a software library, or a command line tool, or most things in a computer system. Weird to assume that NPM did it blindly, you know nothing of that process. 
Azer's Kik was intended to be a code generator to "kickstart projects". That'd fall under "software programmer productivity tools, and code generation" if he wanted to file for a trademark. What makes trademarks messy is that some people think they need to defend their mark in all places, and since its an utterly civil law situation, you're going to spend a lot of money fighting them even if they are utterly wrong.
This was from the perspective of kik, though, not of npm. Any discussion, if there was any, between npm and azer, has not really been disclosed - all I'm aware of is kik cc'd him on all of their npm support requests, before @izc kowtowed. 
A brand new trademark won't stand as well as a messaging app of 270M users. Regardless, when you get control of the package name you can't publish malicious code over the current code. You are required to publish your new code under a major breaking version change. If the existing project was at 1.0.3 you must publish at 2.0.0 No project should be automatically building from a new major version change, or it would break anyway. That's the point of a major version change.
&gt; I don't see any argument why it is OK to act like an asshole here. Please point to where I said that it's ok to be an asshole. All I said was: &gt; I can now 100% **understand** Azer's response. It's the **obvious result.** I even acknowledged that his response was immature and overblown. You are projecting an argument that doesn't exist onto what I wrote which completely derails from the intent of my post. So I'm going to keep my response to your post short. There is a power play here. I know from my studies and experience in my own profession that language and approach can make all of the difference in reaching someone no matter the age. You may not think of it as a traditional power play in the business sense (or from whatever angle you are coming from), but it is one. And it makes a world of a difference.
Where i don't agree with you is that they are not asking him for a favor, they're the ones offering him the favor of compromising (and asking what kind of compensation he would accept) before lawyering up. They really didn't have to do this, and a dry "Please cease and desist from using our trademark or else" would have been largely sufficient, and an easier situation to deal with. What he's done is make compromise the more complicated / conflictual solution, and that's the real superpower of toxic people. They make you hesitate to do the right thing because you know it's going to be more difficult than just being a dick. Where i agree with you is that apparently, if you're dealing with Azer you're dealing with a child so it might be a good idea to take advice from a teacher. But then again, when you're running a business you don't always have the time to deal with entitled kids, and ignoring the PR risk you'd have every right to just shut him up with a slap on the wrist.
Well, we've had other package managers before, but nothing has really stuck. Bower, volo? What's interesting to me is that npm has a lot of other mechanisms for installing packages other than the registry. You can install over git+ssh or from a tarball, for example.
Well good thing you're not a trademark lawyer. Kik holds a valid trademark for software. That's how the law works.
&gt; Please point to where I said that it's ok to be an asshole. All I said was: It was a more general remark on some of the comments in this thread. Not related to your post. Sorry :-)
&gt; the robber remains the villain in this situation well technically Azer is the robber in this situation. Not necessarily with an intent to harm anyone, but he's robbed them of a trademark they paid for. &gt; Azer did make a (non polite) counter offer of 30.000$. To me that seems very reasonable It is not. Ignoring the ridiculous tone of his communication, he cannot sell ownership of a package on NPM for 30K, mainly because npmjs.org/kik is a property of npm inc and the kik trademark is not his to sell, especially if he intends to sell it to people *who already own it*. If the roles were reversed, and some company tried to extort 30k from an open source project for the right to use a trademark they actually owned, the internet would be on fire and NPM would be heroes for sticking it to the man. This kind of edgy ideological bullshit does no service to the community.
See Nissan Motors vs Nissan Computers. Nissan Motors came to the USA and filed suit against a 20-year-old business demanding nissan.com. Nissan Computers was a 1 man owned business. It had the moral and legal high ground, yet for the next decade, he was embroiled in a legal battle simply because Nissan Motors didn't want to give up, and could continually pay lawyers to fight a losing battle. That's how civil suits are. They suck the life out of you because whoever has more money, can continue to fight until the other party just gives up or the judge rules it dismissed with prejudice (which is honestly rare).
Because if you can there's a market for that kind of entertainment.
So you are venturing off of the original point that this was a threat. This analogy could lead to many discussions about Trademark and the rules surrounding it but what we are discussing is that there was a threat to Azer from Kik team members to pursue all legal routes. Now that may not have been a threat, but saying "our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that", to me, is very much a threat.
US trademarks would likely not apply unless a specific agreement has been made between the countries. (The Trans-Pacific Partnership Agreement is one such scenario which allows for trademarks to be acknowledged between countries I believe)
Thanks for the clarification. I was not aware that you can't override versions in NPM. But it still would enable you to spread malicious code. I don't know about how other do it but I try to keep my dependencies as up to date as I can. And when I start out fresh I always pull down the latest release. On the point of the size of Kik. I don't think that matters very much when go to NPM and play the trademark card. This story illustrates that they seem to cave fast.
"Oh yeah, this guy asks us 30k for the right to use our legally obtained trademark. Also, 30k is 6 times how much it would cost to just send him our lawyers. Perfectly reasonable proposition, isn't it?"
I'm lazy. I prefer to just believe you're not lying. 
Somebody has posted it here that Azer was not in violation of trademark with kik name. In same of not able to find source, I'll put it to rest for a while. If I come across I'll let you know too
Trademark class 09 covers computer software in its entirety, and this is the class in which Kik holds a trademark. So your analogy doesn't hold well. In the eyes of the law, it is confusing computer software kik with computer software kik. Kik does indeed hold a valid trademark over the npm package. 
&gt; Where i don't agree with you is that they are not asking him for a favor, they're the ones offering him the favor of compromising... Sigh... please read the first two emails (the one from Kik and the first response from Azer) and forget every other email. Then read what I wrote. I setup the context at the very beginning and you are ignoring it and reading into what I wrote in the wrong way. The tl;dr of my post is basically "be human." A lot of conflict in the world can be solved if people just put themselves in other peoples shoes. To Azer, the name belongs to him. No court has ruled otherwise yet. Until that happens, Azer has every right to *think* that *he* is the one doing a favor for Kik. If you just think about it that way, cause that is the human thing to do, the proper response becomes so simple. &gt; But then again, when you're running a business you don't always have the time to deal with entitled kids, and ignoring the PR risk you'd have every right to just shut him up with a slap on the wrist. Like I said. Be human. It goes a long way. I guarantee that the majority of issues will not take long to resolve (certainly shorter than dragging someone to court). I've reached so many kids that others have labeled "unruly", "troublesome", etc. just by treating them as equal humans. I just wish others would do the same.
It would depend on who registered the trademark first and what the utility of the name usage was -- these things are decided all the time in court.
&gt; yet for the next decade How can a case like that not get resolved in 10 years... WTF.
Why would they have any authority to take down something from a private website? If I made a company called 'foobar', to which I had a trademark to, would I be obligated to take down www.kik.com/foobar ? What about if there was *another* company called kik, [as there are](http://kikstore.com/)? Would they be obligated to take down www.kik.com? (spoiler: no) 
No five.johnny() // 'is alive!'?
Correct, but one of the arguments npm is making is that the users should be able to type something in and get what they expect. It's a pretty flat argument if you asked me. 
Well I'll provide a source. [This is Kik's actual US trademark](http://tmsearch.uspto.gov/bin/showfield?f=doc&amp;state=4802:hude9o.2.1) Pertinent information: &gt;Word Mark: KIK Obviously, their trademark includes the word Kik. &gt;IC 009. US 021 023 026 036 038. G &amp; S: Computer software for use with mobile phones and portable computing devices to exchange, share and create text with other users; computer software for electronic messaging services; computer software for use with mobile phones and portable computing devices to exchange and share digital photos; computer software for use with mobile phones and portable computing devices to download audio, video, digital photos and programs; *. . . (more descriptions from here)* The main thing here is &gt;IC 009. Which is international class 09. [More information on class 09](http://www.nolo.com/legal-encyclopedia/trademark-class-9-computers-scientific-devices.html) Again, pertinent information: &gt;You would choose Class 9 if you were registering any of these types of goods: ... all computer programs and software regardless of recording media or means of dissemination, that is, software recorded on magnetic media or downloaded from a remote computer network.. and &gt;Software, computer software, recorded, computer programmes [programs], recorded, computer programs [downloadable software], electronic notice boards, juke boxes for computers, monitors [computer programs], Games software, computer game software. The link has a lot more detail, but that should be enough to show that class 09 thoroughly covers all aspects of computer software. The other information that I quoted: &gt; Computer software for use with mobile phones and portable computing devices to exchange, share and create text with other users And others are descriptions of their product. For infringement however, the important metric is the G&amp;S class. And Azer's kik falls in the same class as Kik the company &amp; trademark. Have registered trademarks myself so know about the process. 
That's what courts are for. And you're not correct, disputes just like that happen all the time, and domain names do change hands. http://www.bitlaw.com/internet/domain.html Being ignorant of the law doesn't justify anyones cause.
No problem. I quit reddit for a good chunk of the past year because people would project things that I never said onto my posts a bit too often, and I tend to take those comments too personally. So when I read that, it made me instantly regret starting up reddit again. Hence the terse, accusational reply. Sorry if I went overboard there.
Quite strange then out of all of the companies called [kik](https://en.wikipedia.org/wiki/KiK), only one of them has kik.com! npm themselves said that this was not an issue over intellectual property, trademark, or copyright law. Only kik themselves are saying that, which they obviously have great incentive to. 
When it comes to a trademarked name for a popular internet business that has publicly published APIs -- yes i expect the module to be about that service. It not being about that service is just a minor annoyance, as i read the description and move on, but it does make npm less fun to use. 
https://trademarks.justia.com/858/93/kik-85893307.html They are correct in asserting that they hold a trademark on it. I don't think the other kik's have any choice in the matter.
Not hard? Writing a polyfill if you must have sugar or concatenating a string with your variables is easy. 
They are related products, they are both computer software. That is the relevant trademark class, class 09, in which the Kik trademark is registered. They are entirely related products.
&gt; Kim I like to think this isn't an auto-correct error but rather you not wanting to type Kik without the trademark symbol. You are correct that the trademark would have won a legal case in a number of countries where trademark law is terribly out-dated. However, it wasn't a matter of courts and laws according to NPM.
To add to my other comment, the "be human" rule also applies the other way around. No matter what you think of "corporate dicks", the guy on the other end of the conversation is a human being too. He may or may not be wearing a suit, but you have no idea what shit he's going through, and just because he represents a ~~semi~~ successful startup doesn't mean he's Rockefeller. *edit : well apparently kik is valued at 1Bn$ so semi-successful might be an understatement of sorts but my point still stands i guess*
No, they threatened legal action against a single open source developer. That's what I meant about "getting it unpublished". 
I don't necessarily disagree, but I would like to see court orders involved instead of "we have this trademark and we promise that it entitles us to hijack this name". Also, perhaps it wouldn't be a bad idea to set up a policy where names that are contested in this manner are unpublished and barred from future publishes, instead requiring each party to publish in their own scope. 
I [can](https://trademarks.justia.com/775/67/kik-77567654.html) [do](https://trademarks.justia.com/859/56/kik-85956277.html) [that](https://trademarks.justia.com/770/10/kik-77010015.html) [too](https://trademarks.justia.com/735/97/kik-73597097.html). Their trademark isn't over "kik", it's over "kik" stylized like the way your link specified. There's *tons* of trademarks over just the three letters "kik".
Related question, doesn't npm not purge packages, so you could just call `npm i@someversion` and be ok? 
Devil's advocate, NPM is a private company and can do what they want if they want to avoid legal battles.
A better analogy would be: There was a kid with a Coca-Cola stand on his school. Coca-Cola company got in touch and offered to compensate the kid in exchange of the stand. The kid said "fuck you, corporate dicks" and the school principal intervened by seeing there would be no dialogue and giving the stand to Coca-Cola. Edit: Expanding the analogy. Then the kid went on a tantrum and destroyed all of his own drawings that were in the school. But as they were licensed in a way that allowed free copy and redistribution by anyone, the school put them back.
My understanding of what happened is that NPM changed ownership of the kik project to Kik. Kik would then be able to change/delete the existing project and replace it with their own and Azer couldn't do anything as he wasn't the owner anymore. Is that accurate? (honest question) 
&gt;If a trademark is being violated, your site/system is also violating it. you are of course correct. but the thing is -- using pepsi's analogy-- user/pepsi was registered and is owned by user. transferring ownership to company --when the user has shown disagreement-- is also unethical. so what to do? Answer is **maintain the status quo until it is proved wrong**. as user/pepsi owned the pepsi, user continue to own pepsi. the matter is between user and pepsi. they should settle the matter between them or go to court. taking an action under lack of knowledge can not the right action. &gt;Trademarks of the company that not only got the name Kik first, but also went through all the hustle of registering and marketing that name even before Azer thought of using it. I will not deny it but question is do those trademark cover names on npm, gmail, github, reddit, twitter etc? yeah, names exist everywhere but trademarks are not applicable everywhere. kik's word on the matter can not be trusted. with this being a grey area, whether trademark is applicable or not is up for court to decide, not kik's ~~lawyer~~ bully. 
Library != one function
Here is the solution I am going to run with: https://github.com/prettydiff/prettydiff/issues/291#issuecomment-200854422
npm already has (optional) scopes. They could pretty easily just disallow new publishes to the global namespace and require everyone to start publishing under their scope. 
JSPM's management system is pretty neat, though you can npm install over git or a url like it does. 
Proving harm is a very important concept in trademark dispute (and this becomes more important as the case against a company becomes less obvious). Proving that an open-source build tool hurts kiks brand would be close to impossible. That said, trademark law concerning software is 100% broken. Software isn't a field of business -- it is ALL fields of business. The only software field that is not is meta software (software for creating and running software) which would include compilers, kernels, drivers, and similar. Kik's main purpose is to allow people to communicate and the software is a means to an end, but not the end itself. This would be like UPS claiming that their trademark applies to any vehicle or vehicle part or tool to work on a vehicle with "ups" in it's name because the company uses vehicles to deliver packages. A second point about trademarks in general is that they are evil. They grant monopolies of vocabulary on an indefinite basis (and due to large corporations of today, that really is forever). You should not be allowed to trademark something that you couldn't get a copyright for. A copyright on the word disney would not be allowed, but a copyright on the disney logo is very much allowed. People don't trust words anyway (they associate the abstract words with the concrete logo). This leaves us with the moral argument. Lets assume that the law is completely on Kik's side and that they would definitely win any case they brought. Do they have a moral right simply because they have a legal right? If your answer would be some form of yes (eg. yes, because they have a responsibility to stockholders to protect their brand), then put that same answer in the context of America in the early 1800s. Would protecting stockholders and a brand be a good enough reason to own slaves? At this point, the only fallback is either the claim that copyright law is just (then make a case for this perspective) or that hurting people is a gray area and it's okay to hurt someone a little sometimes for my own benefit (which is a slippery slope. If you agree that robbing a bank is bad, but stealing a dollar is okay, then stealing millions, one dollar at a time, should also be okay)
&gt; The matter is between user and pepsi But the matter is between the user, Pepsi, and *you*. You are also infringing the trademark, if there is a trademark infringement on your platform. By being the platform, you are also involved in the problem. You can't say "that's not on me" while **you** are publishing the problematic thing.
Have a package dependency for appending spaces to a string in your project, you say? Sorry, not complicated enough. I tell you, let's do an HTTP request as well! Might as well sign up for the enterprise licence. I'll gladly pay for a 24/7 uptime guarantee for the string concat library in my app. Haha :)
Nobody's saying otherwise, but that doesn't shield them from being taken to task over it.
Yes, that almost is accurate. But they wouldn't be able to affect the already published versions. Kik could publish new versions of the project under a different version number. And Azer would be able to new versions of his project under a different package name.
Fair... but my cynical nature believes that there are at least some countries whose courts lack the technical knowledge to make such distinctions... basically, I'm pretty sure they would have won in some number of countries greater than 1.
[Wrong](https://www.eff.org/deeplinks/2013/11/trademark-law-does-not-require-companies-tirelessly-censor-internet).
&gt; But when you want it to be taken seriously don't end your demand with for a bunch of corporate dicks. The corporate dicks in question started that up two emails earlier by quite literally telling Azer &gt; We don’t mean to be a dick about it [but] our trademark lawyers are going to be banging on your door and taking down your accounts and stuff like that To which Azer logically replied that they were in fact being dicks about it, a reasoning I find no fault with.
People are too quick to jump on the threat bandwagon. A guy **that is not a lawyer** said "Our lawyers will do X, and I want to find a solution that is good for you before they do that". It doesn't seem like a threat. I work (not as a lawyer) for one of the biggest companies here in Brazil. If I get in contact with you about a package saying "hey, guy, our lawyers are going to do something bad to you, let's find a way to compensate you so you get some advantage before they take it from you with no compensation". It is not a threat. It is even good for you, isn't it? I'm giving you a heads up *and* offering you a compensation that I didn't even had to offer.
&gt;You are obligated to defend your trademarks, or you lose them. ...[sometimes, after 20+ years](https://www.eff.org/deeplinks/2013/11/trademark-law-does-not-require-companies-tirelessly-censor-internet). And it would have protected their trademark just fine if they had given him a $1 license to use it in his project, in exchange for a trademark notice in the README.
Those are bad developers 
They _didn't_ get lawyers and judges involved.
Or [ask the EFF](https://www.eff.org/deeplinks/2013/11/trademark-law-does-not-require-companies-tirelessly-censor-internet)?
Good thing you're not a trademark lawyer either. Trademarks aren't blanket universal ownership of names.
Most people affected by leftpad getting pulled probably didn't even realize they had a dependency on it. Furthermore, I highly doubt very many developers went out looking for a library specifically for this purpose - they just inherited it along with many other dependencies. Shame on them for not managing a local package repo (a sin I bet many if not most JS projects are guilty of), but "lrn2code"? Seriously?
All of those points are determined in COURT. The trademark or copyright is not ordained by some kind of manifest destiny allowing a piece of paper to let them do as they please. An impartial legal system with judges or arbitration has to determine actual infringement. For instance, "fair use" with media, or "no reasonable person" would mistake the two, or the industries are different enough that no trademark was infringed, etc. These are arguments that our legal system determines. The gun was jumped.
4) Offer the guy a limited license to use the name "kik" in his modules, on the understanding that he places a prominent notice in the README that Kik is their trademark. And get over the fact that they don't get the "kik" module name.
I'm glad someone other than me has spotted the elephant in the room. The npm guys managed to remove a package and then replace it with different code -- same package name, same claimed version number, different contents. If they can do that, someone who hacks their infrastructure can do it and plant malware.
Correct me if i'm wrong, but all they had to do was send a cease and desist to NPM (not even to Azer). I don't think those cost 30k to produce.
It's actually simple to read the description of goods and services in the trademark. https://trademarks.justia.com/858/93/kik-85893307.html 
David Haney's talking out of his ass, stackoverflow probably uses NuGet and are susceptible to the same kind of issue, unless someone pointed out that they need localized caching, which honestly plenty of people in the Node ecosystem basically didn't give a shit about and that's their fault. This is more people taking pot shots at Node without using it trying to feel superior for "reasons". Also calling anyone from Stack in 2016 an industry expert is tenuous since their .NET code has to be written in a byzantine format to scale. You wouldn't want to work on their code base.
Yes, so EFF are saying you don't always need to protect trademarks _even in cases where infringement is much clearer than this one_.
Downvote the Kik app in the app store if you feel their actions were innapropriate.
Depends if they work.
There is little risk that NPM inc. will refuse to comply with a cease and desist. Contacting Azer about it was (legally speaking) optional. And considering the flak they got, i'd say it was a waste of time.
NPM should not have taken down the package without a legal order. That was not part of their policy. They took down code to put up no code. They didn't contact the owner of the package but just bent over for Kik. NPM is 100% in the wrong here, more so than any of the other parties. And he didn't immediately call them corporate dicks, he said "no", and they couldn't take "no" and started making horrible threats.
Is this some sort of joke? Just like this? https://www.npmjs.com/package/is_maybe
Nice! I was gonna go with [NASDAQ Private Market](http://npm.com)
How do I use this with React.js?
They did do it blindly, and [admitted it](http://blog.npmjs.org/). 
OK, but the context of this fact is a threat. You can use facts to threaten people. This is the point that is being made - not that they're being *in-factual*, but that they're using strong-arm tactics. I'm upset that npm kowtowed to some company without any legal obligation on their behalf to do so. Even in this response, they say that this was not an issue of legalities, and they willingly resolved this "for the good of the community", reasoning that if you `npm install kik`, you'd expect a kik messaging client.
WTF?! I did `npm install node` and expected to get the Joyent Node version, but instead got the io.js version!
The hero we needed in these times of darkness
I read that some of the most popular packages such as Babel were using it. *Babel*.
Considering he didn't take their trademark away from them, he didn't steal anything from them. In addition, various people with more information on the law than myself or yourself are saying that this would not be a cut and dry trademark case and that kik might have lost if they took it to court and both sides had good lawyers.
hah! TIL. I need to be a shittier developer and start blindly `npm`ing. To even implicitly excuse that behavior at the top leadership level of npmjs blows my mind.
You can use npm shrinkwrap to prevent updates further down your dependency tree.
This is not a good analogy, since the gunman is acting against the law. And Kik tried to compensate the guy, not take money from him. In the Azer/npm/Kik case, the one closer to being against the law is Azer. Not only that, but the one that acted in a way that harmed all other projects was also Azer.
Well, prior to this incident, npm policy (and likely code) was that this behavior was not allowed. NPM broke their API contract. NPM allows users to control their packages and to do with them as they wish. Azer told NPM what his desire was by using NPM's unpublish functionality and NPM's software did what it was supposed to do. NPM didn't like the result of Azer's legitimate action, so they effectively reversed his action, by un-un-publishing the exact package that Azer told them to remove. NPM has pretty much 0 credibility at this point. Now we know that NPM will jack your package contrary to their policies (no reasonable discussion among the parties took place according to the parties' accounts), and that they may arbitrarily decide to override documented APIs whenever they feel like it. On top of all that the `kik` package that was jacked currently has no usable code in it and is being squat (contrary to NPM's written policies) by NPM itself instead of containing KIK's important package they they claimed they needed the name for.
Also, it's not like trademarks mean you get to say that anything that consists of your trademark is yours. They're pretty narrow in *just* the specific thing that they're representing. Specifically, kik has the trademark over [this stylization of the letters kik™®, followed by a blue dot](https://www.kik.com/assets/Uploads/Homepage/logo-kik.png). When we find this specific logo on azer's kik package, and only then, will I agree that it was the correct decision for them to take the package down.
I'm glad you know exactly how every developer in the world works. I'm sure the profession of law could use your vast expertise in somehow knowing everything.
I think people are missing the point on this one. It is not relevant that left-pad is a tiny library. So, the argument of whether you should reimplement 11 lines of code in all of your projects to improve dependability doesn't make any sense. Also, in this case, the political arguments only arise from bad design decisions in npm. There are two fatal problems with npm: 1. Global namespacing. Scopes are optional and even though they exist, few people use them. What is more, there is no ownership verification. In Java, you can't publish to the Maven Central Repository from com.google if you don't verify you own the domain. You also can't publish just 'guava'. It has to be com.google.guava. If npm actually had a consistent, reliable and verifiable scoping scheme, there would be no argument over the ownership of the global namespace "kik". Neither kik would have it, nor Azer. 2. npm is mutable - and this is the most fatal flaw. So, Azer unpublished a 11-line library, big deal. But, someone else could just as easily unpublish a database driver. The result will be the same. **As long as published packages can be removed, renamed or modified in any way, by their authors or npm admins, any build that uses npm lives at the mercy of the authors of packages on its dependency tree. Your build is not reproducible.** In most big projects, that's at least several dozen people that can break your build, at any point, with no warning. In Java, once something is published to Maven Central, it cannot be deleted, it cannot be renamed and it cannot be changed. You need to fix a bug? That's great, bump up the version and create a new release. Seems to me that these two problems compounded to expose npm's rather poor design as a package management system.