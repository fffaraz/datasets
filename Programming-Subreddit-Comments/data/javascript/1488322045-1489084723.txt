`Array.prototype.forEach`, notably, is for arrays. When iterating over objects and hashes, I'm far more accustomed to getting either `key` or `key, value`. In JS, for example, you'd use... `Object.keys(obj).forEach(key =&gt; ...)` `for (let key in obj) {}` `for (let [key, value] of obj) {}`. In perl, you've got `foreach my $key (keys %hash) {}` `while (my $key, $value = each %hash) {}` Those are the languages freshest in my mind. Do you have some examples of built-in syntaxes for iterating over a hash or map where the key isn't the first/only value?
I wrote a little bit about this: http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html . TLDR; 0.1 is an infinite repeating decimal in binary, so binary floating points (like JS numbers) can't do exact arithmetic with numbers like 0.1. Please nag TC39 for decimal floating points in JS :)
The spec finally agreed upon. https://lists.w3.org/Archives/Public/public-webassembly/2017Feb/0002.html?#options3 &gt; From this point forward, future features will be designed to ensure backwards compatibility. Basically, now people can write transpilers / compilers without worry about breaking changes. Also, major browsers are going to start supporting it out of the box. So I bet within 6 months there will be a couple different transpilers / compilers out there.
I will be messaging you on [**2017-03-01 00:20:21 UTC**](http://www.wolframalpha.com/input/?i=2017-03-01 00:20:21 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/5wqujr/what_makes_webassembly_fast/decfz6t) [**1 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/5wqujr/what_makes_webassembly_fast/decfz6t]%0A%0ARemindMe! 3 seconds) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! decg06b) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; Is there any projects in the works to 'transpile' JS to WebAssembly? The result would be larger and slower. If you want more speed, you've to use a language with different semantics.
I ended up changing my strategy decide not use the database for this page. I was able to still do what I wanted too thanks for the help. One thing though why is it bad to share that information?
It probably is mimicking lodash and others where value is first. I have never iterated over an object wanting primarily keys though, always values.
How does this compare to PouchDB?
haha, not quite yet. garbage collected languages are tricky, because there is no wasm gc right now, so you pretty much have to compile the python interpreter and ship it in the browser.
[removed]
The binary has to include the runtime. You need the standard library and garbage collector. You also have to generate quite a lot of code to cover all possible code paths. &gt; especially if using a typed version of Javascript. Yeah yeah... types, fixed shapes, frozen everything... aka not JS. Dart can be AOT compiled, for example. Wasm still doesn't make much sense, though.
IE6 support... why? I mean, I'll be honest, nowadays I don't even bother with anything less than Edge. Maybe IE11 if I'm feeling backwards compatible.
HTML can be run offline, you can use file://your/path/here to see for yourself. also if i'm not mistaken I believe atom uses something more than vanilla js considering it can manage files, something normal js just can't do 
update: I just remembered it uses something called electron, which is a software framework to enable people to make applications using html/css/js, I'd look into Electron if you're interested in making stuff like atom
StorkJS does
JavaScript is dynamically typed and all modern JS engines rely on type feedback just-in-time compilation for tolerable performance. It's also garbage collected. WebAssembly doesn't include GC and (I may be wrong about this) doesn't allow you to generate and execute WebAssembly code at runtime. In order to compile JS to efficient WASM, you'd basically have to include an entire JS runtime — type feedback collector, JIT compiler, GC, etc. — with your application.
&gt; Dart can be AOT compiled, for example. Wasm still doesn't make much sense, though. Right, without GC, WASM isn't a good fit for Dart or other managed languages.
Very cool! Been looking for a good intro.
I've just spent a lot of time googling and reading up on floating point numbers, and nothing made as much sense as this comment. I figured pretty quickly how floats or stored (base 2 binary), but couldn't for the life of me figure out how that would affect arithmetic to get those values. Thanks!
50 - 100 line files that consist of documentation and an object literal exporting constants....as far as the eye can see :) Or the dozens of files which just consist of a single export statement. 
Assuming you're using Web Audio API, then [this](https://www.html5rocks.com/en/tutorials/webaudio/intro/#toc-volume) might help you.
I don't understand how this is supposed to complement JS as opposed to replace it. Someone on hacker news mentioned that DOM manipulation is on the road map for web assembly. If that's introduced, what's the point of even having JS? I haven't read many resources about web assembly recently aside from this article. I might be missing something completely. 
How about GMail? It's just one big memory leak. 
Dev time.
Love Ramda. It's helped me get a better grasp of functional programming. Still more learning to do though.
Still looking for the actual function definitions in ramda
Ditto about Google Docs. Why a word processor needs several GBs of memory is beyond me.
Redux, Apollo, Storybook, Pure-Redux-Router, Express, Koa
Depends on the code. Some stuff doesn't work the same across browsers. 
The ecosystem, tooling and developer mindshare is still largely with Javascript. In time, though, I would indeed not be surprised if it started to become a fringe language (though it might as well remain for the reasons I mentioned).
From where I stand, JS has become just as valid a choice for many kinds of app development as Python, Ruby, etc. It does have some cruft from its origins in the browser, but it's got a lot going for it as well.
Shit. I already know what you mean.
What's the problem you're having? I assume you're going to make 4 connections (or have 4 pools), and decide which pool to use based on request? Also on the face of it, 4 schemas seems like overkill. 4 tables could be easier to work with.
Ship it as part of the browser binary, or as a binary downloaded along with the rest of a webpages assets?
Atom uses electron. Electron ships with a small version of chromium browser, to display your Html and css and execute Frontend js. At the same time your application has a main process that can interact with your OS (open windows, show notifications, etc.) The embedded browser is the reason, that the smallest possible application is still far over 50mb
You are welcome!
Yes, what /u/seiyria said: The underscore/lodash `each` method uses `value, key`, but that's a third party library. jQuery's `each` method does it differently: `key, value`. A built-in syntax using `value, key` would be `Map#forEach`, for example. Btw: In your example you do `for (let [key, value] of obj) {}`, but remember that only works on iterators, not your regular `Object` instances. You would need to do something like `for (let [key, value] of Object.entries(obj)) {}`. I don't think that makes the code any more readable, and certainly not more performant.
Well you might not be missing anything but the implied assumption in your statement is that nobody would use JS if they didn't have to. I personally like JS and I know others who do as well. So there is at least that.
Well, I am still sleeping so just using common sense... but maybe the easiest way for you will be just remove floats afterwards.
Well, I didn't say it would be the same regex. :0)
Filtering afterwards is definitely the way to go. `/\d+(?!\.)/g` also fails on strings like `12.3`, since the `1` isn't followed by a period so it matches. You might also want to consider strings like `1.2e3` and `-1`, depending on your use case. `/-?(?:\.\d+|\d+(?:\.\d*)?)(?:[+-]?[eE]\d+)?/g` should work for parsing all of the above cases.
If it a small/medium-sized app, then the performance might look the same to the end user. So it doesn't matter if one runs faster than the other. 
The idea was that you would filter the results afterwards. For that you need an expression that matches ALL possible numbers first, otherwise you will run into issues like "-.2e+3" matching the "3" since you only read part of the number. A complete solution would look something like: const number = /-?(?:\.\d+|\d+(?:\.\d*)?)(?:[+-]?[eE]\d+)?/g; const integer = /^-?\d+$/; function getIntegers(str) { return (str.match(number) || []).filter(s =&gt; integer.test(s)); } Where getIntegers("39, 344, 'hello', 4.5, -700-.2e+3+99,.123") # → ["39", "344", "-700", "3", "99"] compared to "39, 344, 'hello', 4.5, -700-.2e+3+99,.123".match(/\d+(?!\.)/g) # → ["39", "344", "5", "700", "2", "3", "99", "123"] 
Thanks. I guess I was just expecting it to be much easier than this for such a seemingly simple task
There's a lot of chaff in the js world, the biggest lessons I've learned are: 1. Realizing learning everything will burn you out. 2. Just like (human and computer) languages, a lot of the concepts are transferrable if you have a deep understanding of a framework. 3. The easiest way to discover pitfalls is to implement something small but complex. 4. The smaller the community, the more likely the framework will be abandoned. I started by picking one stack to learn well, and then, once I had a sufficiently complex project, switching out one piece at a time and timeboxing it. For instance, I have a ton of experience in AngularJS 1, grunt, and HapiJS. So I decided to try out webpack for a sample app using an existing HapiJS back end. Angular 1 and webpack have some pretty glaring issues together, but exposing pain points is the goal for me, not necessarily finishing the app. Next I tried the same concept with react, then angular 2, express, system js, typescript, so on. Similar concept for learning data flow libraries - I built out an app in reflux, converted it to alt, then structured out redux, always with a primary goal of finding limitations and pain points. That said, you still have to pick your battles. I make an effort to try 3-4 new frameworks a year, more than that and I'd be sacrificing family time and personal sanity. 
Most people who'll use it in the foreseeable future will probably just use Wasm modules for heavy computations and continue to write the application itself (well, the entry point and the UI) in JS/TS/Dart/etc. http://webassembly.org/docs/modules/
&gt; If that's introduced, what's the point of even having JS? For the UI, you don't need all the speed. What you need is all the convenience. You want to be able to quickly iterate, easily debug your code, and so forth. So, most people will continue to use some scripting language like JS, TS, Dart etc for the entry point of the application and the UI and only use Wasm modules where they need the speed.
You would have to include your own standard library, GC (if that's relevant to the language) etc. so if you're only doing some light DOM manipulation and AJAX you will have much smaller download sizes with JS.
I find the mess mostly exciting. It is easier to judge new things if you know how the old things work. I wouldn't have appreciated webpack as much if I hadn't ~~tried~~ suffered through grunt/browserify. So I don't chase all the trends, but (especially with tools) I love finding something better. A full-stack dev should at least try to aware of the technologies/frameworks and how they stand out, I don't work with D3/Canvas/React, but know what they do. It's enough. Almost every tech/framework is stupidly easy to pick up and try these days. 90% of the popular shit on github have stupid-proof readmes. No reason not to try if you're curious.
Absolutely, I have found write CLI apps in JS (through Node) very rewarding.
 $(document).ready(function() { $('#example').DataTable({ columns: [ { "width": "20%" }, null, null, null, null ], initComplete: function() { this.api().columns().every(function() { var column = this; var select = $('&lt;select&gt;&lt;option value=""&gt;&lt;/option&lt;/select&gt;').appendTo($(column.header())).on('change', function() { var val = $.fn.dataTable.util.escapeRegex($(this).val()); column .search(val ? '^' + val + '$' : '', true, false) .draw(); }); column.data().unique().sort().each(function(d, j) { select.append('&lt;option value="' + d + '"&gt;' + d + '&lt;/option&gt;') }); }); } }); }); Try something like this. Notice how I merged column section from second config in to first config
As /u/Helvanik has said, don't try to learn every framework out there, as you don't need to know them all (and in many cases, it might end up dying out or losing popularity by the time you get proficient at it). Let the market decide what sticks in the long term and play around with it on your free time. At NodeBB, we made our tech decisions years ago, and have been watching the market. As I see it, opinionated frameworks make sense if you only code within the narrow boundaries of that framework, and the advantages inherent in having **fewer** frameworks (especially when you want to get new contributors) outweighs the advantages of a complex framework.
Works fine on Chrome 43. Maybe one of your browser extension is interfering.
I'd suggest to first become comfortable in one language first and after that play around with different things. Programming can be very overwhelming, especially for someone with such a different background.
FWIW, GC support for WASM is in the works: https://github.com/WebAssembly/design/blob/master/GC.md#native-gc
Anybody has a use case for web assembly ?
if you just want to test that your string only contains digits (and maybe a leading minus) `^\d+$` (`^-?\d+$` to allow minus) should completely suffice, since only ints only contain numbers from start to end of the string
I keep a mental list of what tools exist and what they do, but I don't go learn them. If there are several tools in the same space (e.g. HighCharts and D3), I do some quick research to find out the high-level differences. *If* the need arises for one tool in a project, then I do a quick trial mini-project to evaluate ease-of-use and whether it fits my needs. This includes looking at the documentation and deciding against it if the docs aren't up to snuff. My rule of thumb is one or two new tools per project maximum. So, for example, if the project is going to use ElasticSearch and the team never used it, that counts as one new tool. Or if the client requires integrating to a 3rd party SaaS we never used, that counts as one new tool. It's quite possible for there to be more than two new tools in a project, but crossing that line comes with loud warnings about risk of severe code debt ahead. If the project is a boring cookie cutter CRUD, then it's allowable to try out Vue or RxJS or Falcor whatever, but again, the rule is one or two new techs maximum. This is for *peripheral* tools, i.e. tools that may or may not be used from project to project. I also have a *core* set of tools that I try to master to the best of my abilities (for me those are Mithril.js, Express, PostgreSQL, Redis. YMMV) Replacing a core tool requires an overwhelmingly strong argument. For example MySQL used to be my go-to database, but I learned PostgreSQL feature set is much more powerful. `returning` alone can save a ton of network requests in a typical app. Express replaced .NET MVC because that's what my current company uses. etc. Btw, notice that I listed a lot of technologies that aren't javascript per se. Full stack means being able to quickly evaluate and use a very wide range of technologies, so when you have room to learn new tools, then prefer one that will enlarge your toolset (e.g. there's very little to gain from mastering Vue coming from React - since there's little to learn to begin with - if you compare to learning ElasticSearch, or RabbitMQ or Twilio or Docker, etc). There's a third category of tools that I call *nice-to-have* tools. Basically, if a tool (and its competitors) didn't exist, and you could still finish your project within your deadline, then it's a nice-to-have. For me, Babel is an example because I can write ES5 without whining. Maybe for you Babel is a hard requirement for team dynamics reasons, but maybe HMR is nice-to-have. Or browsersync, or PostCSS or whatever. For a nice-to-have tool, I learn enough to get by if I'm stuck with it in a legacy project, but for new projects, I don't generally bother with them at all since I usually end up picking another tool to fill my one-or-two-new-tools budget in boring projects. 
The most important thing IMO is that your overall programming skill is up. Stuff like algorithms and data structures, paradigms and so on. You'll have them with 5-6 years of experience with C/C++, but do you feel comfortable with them? After all Webpack, Babel, React, Vue,... they are all trying to solve a problem. You don't need to use them all. It is far more important to understand WHAT problems are they solving. When you know what problems they solve, you'll not only know when and WHY to use them but will also learn to master them much faster. Have a small project. Like a TODO list. And implement this project with the new tool. Compare them to the other implementations and evaluate pros and cons. Having less tools in your repertoire, but having good skills in the one you use is far more useful and fun.
Regular expressions are only simple for a very small subset of string matching tasks, namely those that occur within a "regular language"... Most data doesn't fit that requirement. Sometimes things can be done with a regex in a non-regular language, such that it will work 90%+ of the time, but you will never be able to prevent all edge cases. In this case, I can imagine a multi-layered set of non-capturing groups that might make this possible, but instead, why not just split on the commas, trim the results, and test them to see if they're integers? It's pretty much guaranteed to be faster and more readable than a regex.
It's mostly [confirmation bias](https://en.wikipedia.org/wiki/Confirmation_bias), however Vue has a much lower learning curve compared to Angular. That is it's biggest strength, IMO. Also, from my Angular 1.x experience, it felt like I was solving problems with a framework (i.e., "the angular way"), not with javascript, if that makes any sense. Some people may really like that, I'm not the biggest fan. I think Vue is vastly underrated and it's nice to see it getting a lot of attention. Vue 2 with single file components are definitely worth a look. The vue-cli gets you up in running with webpack in no time.
You're not showing us the showPicture function, so it's difficult to troubleshoot, but I suspect this function does not know which picture to show. I would temporarily remove the images (to reduce complexity) and see if I the onclick function actually affects the expected td - I suspect it doesn't. Here's a related problem (an array instead of a table, but it should give you an idea on how to solve it), hopefully this will help you: http://stackoverflow.com/questions/6400320/javascript-array-addeventlistener Good luck!
making of: http://szymonkaliski.com/blog/2017-02-28-building-wallgen/
I assume you're referring to `const MyComponent = React.createClass({})`, vs `class MyComponent extends React.Component`. The `createClass` approach still works, but it will be deprecated in React 15.5 and moved into a separate package in React 16.0. ES6 classes are the recommended approach. The docs have been updated to use ES6 classes in the examples, and the vast majority of real-world React code uses ES6 classes. Modern browsers fully support classes, and have for a while now. Also, since you said you're learning React: I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. 
This
This is the only acceptable format: if (a &gt;= b) { return a; } else { return b; }
Just read posts on Reddit and HN, you'll learn enough. I've never used React, never written any JSX, but I know why React exists, what it is, how it compares to other libraries, how it differs from frameworks like angular and ember, what problem it is trying to solve, when a project warrants the consideration of its use, and what react code looks like. That is all I need to know until it is time to use it on the job.
Doesn't matter... use a beautifier to make this decision for you.
I have always found that reading JavaScript books are the best way to learn JavaScript. Books let you work on your own pace, arent as distracting or time consuming as videos and you can easily use them on your commute or whatever little breaks you get throughout your day. After going through a number of books through the years, these are my picks for the best JavaScript books (https://reactdom.com/blog/javascript-books) in 2017.
Why not just do this in CSS directly?
&gt; doesn't require some complex asset pipeline to work or some third party language to function properly. Bingo
I found why: It work fine when I use the http://output.jsbin.com/xuzeguf URL but don't work when I am in the edit mode cause there is CORS conflict with Chrome policy.
I personally prefer the K&amp;R style (see /u/ChutneyRiggins' example), but it doesn't matter as long as brace positioning is consistent throughout an entire project.
Thank you for the invaluable feedback. In terms of a more favorable ORM, might you have any suggestions? I'm not the stubborn sort, so I'm totally open to alternatives. Any feedback would be much appreciated. The only things I know as alternatives are Objection.js and Bookshelf.js. Would be grateful for your guidance. Thanks again!
There's a bunch of table and column relations we're going to have implement in our data schematic, and we want to segregate clients from one another by giving them identically structured (but separate) schemata within the database. I was just wondering what the best multi-tenancy approach would be when using an ORM, such that the ORM would know which schema to use and query based on a given user being associated to that schema's data by some sort of "orgID" property (orgID = ID of the organization/business/client) that they are a user of. So, for example: We have a client named TittiesNBeer, and a another client named BeersNStuff. Each of these bars has users that will log in to use our app, who belong to one of these organizations. Incidentally, both organizations have employees named Joe Smith. In our users table, we'd have a user named joesmith whith an orgID = 'tittiesnbeer', and a different joesmith with an orgID = 'beersnstuff'. When Joe Smith from tittiesNBeer logs into our app, we want to identify him as the right Joe Smith (the one who belongs to tittiesNBeer), and then make sure our ORM knows to point all the queries coming from that joesmith user to the tittiesNBeer schema in our application, rendering the correct data for the company that he belongs to into the app, for the duration of his user session, until we destroy that session object in memory. I know it sounds contrived, but it's a pretty common case. I hope the explanation is clear enough lol. Thanks!
This is the coding equivalent of "should I get a Mac or PC?"
I think a more interesting question is what makes it slower than pure assembly. Sandboxing and security can be done in the parsing stage, so they shouldn't introduce runtime performance slow down. And yet, reportedly web assembly is half the speed of actual assembly, or less. 
I've read a bunch of books through the years, these are the best JavaScript books (https://reactdom.com/blog/javascript-books) that I think everyone who wants to learn JavaScript should read. Let me know your thoughts!
Thanks! I always thought that the rounding error was due to an over/under flow on the mantissa, and that the rounding error was a side-effect of it. --- EDIT: Actually seems like we both are right.
I million times over ES6 and, in fact, whatever babel plugin allows rest/spread for objects. Because react relies on passing objects and subsets of objects all over the damn place, this syntax sugar is extremely useful for writing clean, intelligible code.
I don't stay up to date with the latest tech. I familiarise myself with the landscape at most every 2 to 3 years, pick a 'winner' for my project then use it for the next 3 years. Currently its Babel, Webpack, React, Tide, MobX. 
Going forward you should definitely care about ES6. Everyone's talking about it because it is a major step up, however older browsers don't support it so a state of the art solution is to write your code in ES6 and then turn it into ES5 whenever applicable so it can run on most platforms. TypeScript for example is one of these tools that turns ES6 into ES5/3, other popular solution is Babel. In addition to that, TypeScript also introduces a Typing System, now, it is still JavaScript but you use it to tell the compiler beforehand what your variables are going to be (string, number, object, ..) so that if a variable is supposed to be a boolean and you try to assign it a string at any point you get notified. Or you try to access a variable that doesn't exist because you made a typo. It's especially useful if you have a large codebase with multiple people. Since you're new to JS I would definitely start with ES6, chances are your code doesn't need to run in older browsers so just grab the latest browser and have a go at it.
Do a search in the source code for `speed`. It'll return some interesting things for you to play with.
Pretty neat-o! This is only in Safari Technology Preview right? Can't wait for this to land in Firefox!
Open the dev tools and go to the sources tab. Open 'default.js' and set a breakpoint somewhere after `var g_typingSpeedMs = 75;`. You can do this by simply clicking on the line number itself. Refresh the page and the browser will pause at your breakpoint. In the console type `g_typingSpeedMs = 10` or whatever number you want and click the 'play' button to resume loading the page.
Partly for the same reasons every other targetless language is slower than pure ASM and partly because they designed it to be something that can be added to existing web compiler backends rather than a split world.
how do I search? (please forgive me if I am coming off as highly dumb)
I don't think this answers my question…
Ctrl+F
What part is unanswered? You asked why it is slower than native assembly, I gave two reasons it is slower than native assembly (and neither were related to the reasons you posited it was slower). Besides, a portable abstraction can never be better optimized than a equally optimized native abstraction could.
I wanted to know how to do it, and the community has already helped me. I did try to do it - but for some reason the page reloaded over and over again, until I figured out how to pause the debugger. Also, I am not familiar with javascript (Usually do C++) so I needed some help, but since it uses normal looping etc I just wanted a general idea how to do it. Edit: The site url was given as an example. I understand that forums don't take kindly to specific code problems. My bad. Sorry.
Thanks.
By the time the onclick is invoked, the img variable is now assigned to the last img created. It's a weird scoping issue that's used as a common JavaScript interview question. It *looks* like it shouldn't have this issue because the img is defined inside of the for loop but I believe JavaScript is hoisting the img variable to the top of the init function. Here are a couple styles for forcing a scope to your variable. td.onclick = function (imgCard) { return function(){ showPicture(imgCard); } }(img); or function(imgCard) { td.onclick = function () { showPicture(imgCard); } }(img); (You can actually reuse the "img" name instead of "imgCard" but I made it different to make it clearer how this works.)
no problem!
You should look for tutorials that teach React with [create-react-app](https://github.com/facebookincubator/create-react-app). These should be most likely up to date and you can use ES6 without any configuration. You can learn plain React.
There's a larger issue here: developer preference vs. team cohesiveness. It could be about how you format your `if`/`else` statements, whether or not you use ternaries, whether you indent with two spaces or four, etc. Of course every team handles these things differently, but the general consensus is that you want your team to agree on a standard, and then enforce that standard with a tool like ESLint. Individual developers who want a different format are welcome to reformat files (possibly again using ESLint, or a different tool) to their own preference, as long as they re-format them back to the team standard on check-in (you could even do this with a git pre-commit hook). But the important thing is to understand what formatting standards are "required" for your team, and meet those standards. At the end of the day, which is more important: you avoiding adjusting to a style you're not familiar with, or your team not having a mess of code formatted twenty different ways (so no one except the original author can comfortably work on it)? I'd argue the latter. If you can find a way to work with code that indents `else` differently from how the team does it (eg. by auto-formatting your code before/after you edit it), great, but ultimately that's less important than having a codebase that everyone can comfortably share work on.
&gt; LLVM IR isn't as golden as you think - see http://webassembly.org/docs/faq/ "Why not just use LLVM bitcode as a binary format?" for more details. LLVM is of course more elaborate and evolving instruction set. But my question wasn't "why didn't they use LLVM" so this FAQ doesn't answer my question: why is WebAssembly so much slower. I'm not asking about fringe features like "fast-math" or proprietary vector instructions, but basic algorithms implemented on top of baseline instructions available across all modern CPUs. &gt; Again, nobody else you're comparing to has the code-&gt;abstraction-&gt;recompile-&gt;run model because the ones you are comparing to are actually not designed with the portability abilities you describe. Also I think it's still actually at the code-&gt;abstaction-&gt;abstraction-&gt;recompile-&gt;run stage until emscripten has a truly native pipeline. Just because it has the name "assembly" in it doesn't mean it's low level to the end machine it actually runs on :). AFAIK Emscripten is not part of any production WebAssembly pipeline shipped in browsers today. This was only necessary for bridging WASM to ASM.js before WASM support was available. Adding abstraction levels can be harmful to performance, but not by default, it has to be demonstrated why that'd be the case. Especially not when the abstractions are so similar, and mostly about mapping one "add" instruction to another "add" instruction, so this alone can't explain the slow-down IMHO.
I don't use firefox, but my best guess is that they realized it's useful, but it probably just opens files deeper or at the same level of the page you are currently viewing. This could be a security risk if you can open files with paths like: "../../file.png". I'd advise you to put a HTML page at "C:/index.html" and try to load things like your documents folder from inside that page, if you can, there's your security breach that everyone is trying to avoid. Also, if that is possible, it almost certainly is a bug. For anyone needing cross origin to work in chrome, here's the shortcut snippet &gt; chrome.exe --disable-web-security --user-data-dir="%appdata%\..\Local\Google\Chrome\User Data" "index.html" --profile-directory="Default"
Interesting, I had asked a question about the new `import` semantics for accessing local modules using `file://` on Dr. Rauschmayer's blog here: http://www.2ality.com/2017/01/import-operator.html#comment-3106422611. Bradley Meck of Node.js said it'd adhere to the host environment's loading mechanism. This could allow better local import usage, completely replacing the need for something like AMD or a build step :O.
Angular 2 isn't that complex, IMHO. I think the point of Angular is the same as with that of Ember in that they are tools for big teams and big codebases. DI and other decisions the Angular team took may look like ceremonious complexity but they do start to make sense as your app grows bigger. Vue is an excellent tool if you have complete control of your project, I've never gone big with it but I feel that it quite capable of handling a big codebase with proper planning ahead. EDIT: Also important to note how both Angular and Ember have great build tools to simplify your workflow with the Ember CLI deserving greater praise based on how much heavy lifting it does for you
You could easily remake that using photoshop.
You can do it for example like this: document.querySelector('select').addEventListener('change', function() { var markerId = this.value; map.removeBy(function(marker) { return parseInt(marker.id, 10) === parseInt(markerId, 10); // Because of === we need to make sure we're matching numbers against numbers }); }) I'd recommend giving that `&lt;select&gt;` an ID and change the code to reflect this (`document.querySelector('#yourId')`). This snippet will be used on the first `&lt;select&gt;` element it finds. **Edit**: I noticed you use `===`, which might not work if `marker.id` is a number (select options are strings), so I've updated the snippet.
/r/ghostfacedcoder, /r/toffeescaf for sure, just the question of the fucking thread isn't that and the folk just wanted to show what is the most correct answer when there is need for `else`s and `else-if`s. But yea, as about that, i almost don't use `else`s and always trying to use ternaries where it looks more clean.
https://github.com/localForage/localForage seems to be better
Good tip about Chrome. Just stopping by to hint that %appdata%\..\Local\ == %localappdata% HTH!
can't imagine writing React without ES6/Babel anymore. Arrow functions, Promises, etc. Go for it.
So in hindsight, it will be easier for me if the value is not a number, but an appreviation of what I'm filtering: &lt;select id="ddlSector"&gt; &lt;option value="AaNR"&gt;AaNR&lt;/option&gt; &lt;option value="AMaE"&gt;AMaE&lt;/option&gt; &lt;option value="BaCT"&gt;BaCT&lt;/option&gt; &lt;option value="BaFI"&gt;BaFI&lt;/option&gt; &lt;/select&gt; So I have this now: document.querySelector('#ddlSector').addEventListener('change', function() { var markerId = this.value; map.removeBy(function(marker) { return marker.id === markerId; }); }) But it doesn't seem like it's doing anything.
You can use a non-numeric value, sure. It does not matter much, and it might be easier to deal with. Do you know how to use the browser developer tools ? Add a `console.log(markerId)` inside the event listener and see if it is getting caught (possibly also in the removeBy part to see what you're matching against). If it does not work, it's most likely because it failed to bind the listener (element not found, or bound before page is rendered completely) or that the `markerId` checking fails. Make sure that the event listener is added when the page is loaded, ex: document.addEventListener('DOMContentLoaded', function() { // document.querySelector(...)... }) (You don't mention jQuery, so I assume you're doing this in vanilla JS)
this. ffs.
Come to think of it, the `change` event might not be the best choice. Adding a button that uses the selected entry in your `&lt;select&gt;` might be a better: document.querySelector('#yourButton').on('click', function() { var value = document.querySelector('#yourSelect').value; if ( value ) { map.removeBy(function(marker) { return marker.id === markerId; // Assuming an id is a string, since value above is always a string because of &lt;select&gt; nature }); } }); 
&gt; Add a console.log(markerId) inside the event listener to see if it is getting caught document.querySelector('#ddlSector').addEventListener('change', function() { var markerId = this.value; console.log(markerId), map.removeBy(function(marker) { return marker.id === markerId; }); }) Looks like it's passing the right value: http://i.imgur.com/Nhz0x6P.png &amp;nbsp; &gt; possibly also in the removeBy part to see what you're matching against document.querySelector('#ddlSector').addEventListener('change', function() { var markerId = this.value; map.removeBy(function(marker) { return marker.id === markerId, console.log(markerId); }); }) Also looks right: http://i.imgur.com/JfZcDyS.png &amp;nbsp; This project is beyond my knowledge base, I'm sorry. I'm not sure where to add the code you mentioned. This is my full script file: (function(window, mapster) { // map options var options = mapster.MAP_OPTIONS, element = document.getElementById('map-canvas'), // map map = mapster.create(element, options); var marker = map.addMarker({ lat: 36.539256, lng: -119.838402, content: 'AaNR', icon: 'mapicons/AaNR.png', sector: 'AaNR' }); var marker2 = map.addMarker({ lat: 36.633133, lng: -119.672568, content: 'AaNR', icon: 'mapicons/AaNR.png', sector: 'AaNR' }); var marker3 = map.addMarker({ lat: 36.580831, lng: -119.614615, content: 'AMaE', icon: 'mapicons/AMaE.png', sector: 'AMaE' }); var filter = document.getElementById("ddlSector"); document.querySelector('#ddlSector').addEventListener('change', function() { var markerId = this.value; map.removeBy(function(marker) { return marker.id === markerId, console.log(markerId) }); }) }(window, window.Mapster)); I'm not using jQuery, but the tutorial gets to that point, however the code they have for removing markers: map.removeBy(function(marker) { return marker.id=== 2; }); Wont work, as they have you recode everything for jQuery and remove that functionatlity. So i'm working with the step _before_ they start changing it all.
Usually, in my experience, they hire contractors for that because contractors are easier to fire when the trendy framework is no longer trendy. If they want to retain the contractor for longer they will provide an offer for employment. Frameworks come and go. Also, in my experience, nobody is hiring for a framework leader. Such responsibilities are filled by architects who do more than trip over framework trivialities. After all frameworks are architectures in a box. If frameworks didn't provide architectural guidance or greater technical leadership were demand the company wouldn't invest in the framework. Frameworks aren't free just because they usually don't come with a license fee.
Many scripting languages can be used for event-driven stuff. Anyhow, Dart is somewhat similar. It got Futures (Promises), async/await, and actor-like concurrency (similar to Web Workers).
&gt; I understand ES6 is a next gen for plain JS No, it's *previous* gen. ES2016 (the one which came after ES6) is plain JS. &gt; I understand [TypeScript] is not a dynamically typed language TS and Dart are dynamically typed languages. Type annotations are optional. &gt; bad thing IMO You should document your types anyways. Type annotations are much terser than doc comments and you get significantly improved tooling in return. It catches silly mistakes (like breaking changes in libraries) and it lets you auto-complete virtually everything. The type definitions of a library are useful for JavaScript, TypeScript, Dart, and Kotlin users.
 document.querySelector('#filterButton').addEventListener('click', function() { var value = document.querySelector('#ddlSector').value; if ( value ) { map.removeBy(function(marker) { return marker.id === markerId; }); } }); Now I get "Uncaught ReferenceError: markerId is not defined" when I click on the button: &amp;nbsp; **at script.js:39** return marker.id === markerId;
&gt; console.log(marker) Ah, it looks like it's put putting all values no matter what I select. I have three markers, and when I filter it, I get three results in the console regardless of my selection.
Cool, glad you got it worked out. &gt; I understand that forums don't take kindly to specific code problems. My bad. Sorry. No worries! The more specific the problem the easier it is to solve. Your post was removed because we need some minimum standards due to the amount of people trying to get us to do their work/homework for them, or exploit a website in some way. Not saying either of those were your motive, but typically you either need to post some source code, or talk about source code.
if you want to build static website, adjust CSS directly is more familiar than use this. but if you want to adjust CSS dynamically, it will be useful for javascript developer.
Ah yeah, setting the breakpoint should have paused it for you. Glad it worked for you!
Care to elaborate?
As long as you don't nest them it's all good.
Nice one. I would add Bower and jspm to the package manager alternatives so that you at least have some alternatives there. In the bundle section, I would also mention the good oldie requirejs, jspm (edpecially if you are going to add it to the package manager list) and rollup which seems to be the up and coming bundler =) Edit: This was the wrong thread. Sorry...
I think Brunch is a worthy alternative to Webpack and Browserify. It just worked the way I expected it to, with 20 lines of config vs 100+
Ohkay!
The video about the callstack was great. Thanks!
&gt;&gt; If not any other better sites out there that can transform you to a beginner to a pro. That will only come with years of hard work. &gt;&gt; Any good books on javascript? eloquent javascript and YDKJS (you dont know javascript), a series of books on js, come to mind. They are all free online. &gt;&gt; Also is reading a book on javascript more helpful than trying to learn to code in javascript? Writing and reading code are the most important things.
Hey, when I first started getting myself familiar with JS I used codecademy as well and they provided a really good introduction to the topic for me. So if you never ever read or coded any JS I think it is a good starting point. I also checked out the "Javascript Basic" course on Udacity but I didn't really like it all that much. As for books, yes there are good books. I would start with this one, since it's interactive (you can solve a problem set at the end of each chapter) [Eloquent Javascript](http://eloquentjavascript.net/). This should get you started and provide a really good introduction and overview. Once you are done with that you can move to more detailed material: [You don't know JS](https://github.com/getify/You-Dont-Know-JS). This helped me to get a better understanding of the ins and outs of JS. Another really good introduction is provided in this Video-Series, this shed some light into concepts that were opaque to me: [CS50 - Javascript Bootcamp](https://www.youtube.com/watch?v=IWccrYBqu8s&amp;list=PLxfArCURpD2CtCDrjdl1dd4XDm9XzVh1e) Hope this helps :).
It's not really a fundamental property of the language. You can write an asynchronous framework in any language. And any language can be single threaded, even if it supports multi-threading, just by not using that. Some common examples of popular asynchronous frameworks in other languages include POE (Perl), Twisted (Python), EventMachine (Ruby), Boost.ASIO (C++), Netty (Java), etc. In many ways, JavaScript is playing catch-up, because other languages like C# and Python lapped it in adding native async/await support as a core language feature; those features are still pending in the EcmaScript 2017 draft standard.
&gt;&gt; 1. JavaScript is a client side language: The JavaScript code is executed on the user’s processor instead of the web server thus it saves bandwidth and load on the web server. Except that's not strictly true and is contradicted later in the post by point #7. &gt;&gt; 2. JavaScript is an easy language to learn: ...It uses the DOM model that provides plenty of pre-written functionalities to the various objects on pages making it a breeze to develop a script to solve a custom purpose. js does not "use" the DOM. Perhaps I'm being pedantic, but I do think that saying that "js uses the DOM model" is not entirely accurate. Browsers expose an API for the dom. Also, `DOM model` is redundant; Document Object Model model... &gt;&gt; 6. Easy to debug and test: Understanding syntax of JavaScript is easy. Any person can learn it very easily and use it to develop dynamic and scalable websites. dubugging and testing are more-or-less entirely unrelated to language syntax. Also, why include a 5 year old infographic? It's outdated as shown by the coffeescript reference. 
"Google SEO works fine with SPA" It really doesn't, unless you go through substantial hoops, using separate static pages or prerender paths.
The whole comment is that there are ways 
&gt;&gt; Avg page rendering for the first time is taking about 600MS, but after first time Avg HTML response time is 10MS, it’s because of Node.js require caching and service caching itself. &gt;Are you sure the time delta is not due to the browser caching the webfont from index.ejs? That's me quoting the page. 
Another post by some kid on Medium. They let anyone write anything on Medium.
It is in indian i belive ehehe, somebody told me that
But surely this can be achieved with CSS and `Element.classList` manipulations.
Lmao
When I was digging around this, I also noticed that SharedArrayBuffers is about to be a thing, which I also wondered if they might be usable (my thinking was to glob big blocks of arraybuffers in webworkers, and then access this memory from the main thread). Fibers sounds interesting, but seems to be a react specific? 
https://bugzilla.mozilla.org/show_bug.cgi?id=1342012
wow, that would be the first JS library I have seen that has more annotations than actual code
It's working! I just forgot to add the value for "id" on the marker! Thank you so much for all your help!
"If anything on this short list still confuses you, you’re not ready for Node." lol.
Sure, if you can do it with vanilla js and it works cross browser, that's ok. If you need something more, you can add jQuery in.
What are `points[0]` and `points[1]`?
If the URL is like below. http://site.com/page?template&amp;service&amp;client Use below code instead. var URLfilter = location.search.substr(1).split("&amp;"); Then for clicking the matching checkboxes... for (var i = checkboxes.length-1; i &gt;= 0; i--) { if (URLfilter.indexOf(checkboxes[i].id) &gt;= 0) { checkboxes[i].click(); } } 
`this` either has no element at index 0 or 1 (or in property named `"0"` or `"1"`). Or has, but its value is `undefined`.
Sliding a sidebar out of view. Animations of all sorts.
I love Js but this is stupid. Students should be taught a strongly typed language as their first to properly learn.
If you'd like to use D3... Search treemap [Example](https://bl.ocks.org/mbostock/4063582) [Docs](https://github.com/d3/d3-hierarchy/blob/master/README.md#treemap) 
I disagree. The ecosystem/community is nowhere near as big.
I've been a full stack JS dev for a while now. I would pick this exact setup, too ... though I would recommend Sinon over chai-spies on the testing stack. I'd also drilldown a little more and suggest React Bootstrap for UI components (I think it's better than Material UI - if you want the material look you can use the Paper theme from bootswatch) - several UI component frameworks exist with some attached hype, but none seem to work as well and be as complete as React Bootstrap IMHO, ... React-Router, Axios, and Redux-Promise are other useful tools I use in almost every app. 
&gt; I'm just trying to give newcomers a startup kit to get them up and running without the stress of making decisions they have no information to make. I think this an area where Vue actually really shines. With its great documentation, official supporting libraries, and cli tool it's super easy to get up and running on a full project. One of the major issues I had doing anything nontrivial^tm in React was banging into the paradox of choice at every turn. I mean I probably spent the equivalent of weeks worth of man hours trying to create a sensible React boilerplate. And that's after having to eject from create-react-app and end up back on my own just to get sass support. Sure I should just be better, but if the point is newcomers shouldn't be burdened with all this stuff that's not really a fair out. This wasn't a problem with Vue because I could simply install the vue-cli, init a new project off the webpack template, install the sass loaders, and everything just works. Sure, there're probably awesome teams out there working on giant projects where React and its ecosystem make the most sense. But for newcomers and even experienced folks who aren't working on teams that have time (or the hard earned experience) to constantly parse through that large ecosystem Vue is a really solid contender.
Thank you! The problem with my code is that im loading the video with an href link. If I can I'd like to possibly media elements to swap my image back, without the use of video tags. Media tags to target each specific src video, .mp4. 
Why? MIT and others started students out with Scheme and now Python, neither of which could be accused of being strongly typed languages.
Look... I don't know why people find it so hard to keep track of a conversation, but my original question was why, in direct comparisons, WASM is twice slower than ASM on the same machine. This is for comparable low-level code, so how you got there is actually **absolutely relevant**, as in **literally it's not a part of the test**. It seems information is hard to come by, instead, people who know, don't talk, people who don't know, talk.
It doesn't have to be as big to match it. React requires a lot of 3rd party libraries to write maintainable code, Vue doesn't.
 &lt;script type="text/javascript"&gt; function change (){ var image = document.getElementById('image-that-changes'); image.src = "image-2"; if (.mp4 ends) } &lt;/script&gt;
You have mismatched capitalization with the class_name variable. The parameter is 'class_name', but when you try to use it, you have 'Class_name'. It's case sensitive. Tip: View the developer console for error messages to help figure out what is broken.
&gt; people who don't know, talk. Seems to be true since you still think it is 1:1 machine level assembly after I've told you two or three times now it's not - it isn't a native ASM, it doesn't compare to native ASM, you can't get a comparison because you are asking for apples to oranges. It's up there with "why is Python slower than C" and "why is JVM bytecode not as fast as native assembly" - because it's an abstraction layer higher and by the time you get to native arch instructions you've lost viability in optimizations through the abstraction layers! Go take CS 101, or Google how higher level language abstractions provide restrictions. That it is named "WebAssembly" is a complete misnomer, if you can look past that and actually take the time to understand why everything I said is relevant as a result you'll see why it's similar to every other abstraction.
It's rather about maintainability. When you write using React+Redux, you absolutely need 50 different components, libraries, middlewares and helpers just to get started, otherwise you will almost certainly end up with something ugly, non-modular and not reusable. I'd say, it suggests about fundamental design flaws. React and Redux creators' primary concern is purity of the concepts they implement rather than helping the developers in creating applications. At least that's how I see it.
I have a list of concrete reasons why Python is slower than C, and it's not just "because Python is abstraction layer higher". Things like dynamic typing, and overall lack of static invariants that you can analyze statically in advance, and express statically, vs. at runtime, being the biggest one. While with WASM, we remain firmly in the area of hand-waving, I guess.
Maybe `split(/[,\s]+/)`
Damnit.. I've been working on this for at least 10 hours.. and 5 minutes after I post this I find the answer.. and I only had to add one tiny word to my existing script in the for statment... for( **let** i=0; i&lt; elements.length; i++)
This is an age-old debate. The college I went to switched from using C++ (or "C+" as my professor jokingly used to call the subset of C++ they use for the intro course) to python for the intro course while I was there. --- There are advantages both ways, but I lean towards dynamic, personally. I don't think the important thing to teach students right away is strong typing: I think the purpose of an intro course is to teach them how to think programmatically and get a basic sense of how programming works (and if they're lucky, to experience some of the joy of programming). You can always learn strong typing later, but if your first experience programming is a horrible experience fighting a compiler and all the other baggage that generally comes with a strongly typed language, that's going to be a hard first-impression to shake. And, a REPL is a wonderful tool for learning the basics of programming.
Perhaps it's improved since I tried it. If I ever need tree shaking (I had to google it) or code splitting, I'll give it another try. Must admit, I'm happy with Brunch, though.
Imagine you load a large library, like three.js. You use a single feature, say a Vector3, but a whole megabyte gets added to your bundle. Webpack users get a couple of kb because it shakes off unused dependencies (in this case 99% of the lib). Code splitting is another very effective way to cut down on load times as you load parts of the application when they're actually needed instead of fetching the whole chunk at once. This is great for routes for instance.
&gt; When you write using React+Redux, you absolutely need 50 different components, libraries, middlewares and helpers just to get started No you don't. Stopped reading after that.
The code should work as it is. Just make sure it executes after the `&lt;video&gt;` element is built. Either by placing it after or have it run on 'load' or 'DOMContentLoaded'.
I don't think the bare stdlib been that beneficial for node. The 'competition' hasn't really led to superior quality libraries compared to, say, stdlib of Python.
i kind a figured it out what happened to this code and works now but thanks
i kind a figured it out what happened to this code and works now but thanks
i kind a figured it out what happened to this code and works now but thanks
This is really cool. Are these lectures going to be available on youtube?
Neat but on mobile when I was zooming in and out a lot at one point the graphs flew off the screen as I was zooming out and they never came back til I reloaded.
Well... That's trickier. It *might* be possible if the video is on the same domain as the page you've opened it from, but it's probably better to do it in another way. This *might* work, but I'm not on my regular computer now so I can't test it: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;img id="image-that-changes" src="originalImage.jpg"&gt; &lt;br&gt; &lt;a id="videoLink" href="javascript:void(0);"&gt;video link&lt;/a&gt; &lt;script type="text/javascript"&gt; var image = document.getElementById('image-that-changes'); var w; document.getElementById('videoLink').addEventListener('click',openVideo,false); function openVideo() { w = window.open('videos/video.mp4'); w.addEventListener('load',attachEvent,false); } function attachEvent() { w.document.querySelector('video').addEventListener('ended',changeImage,false); } function changeImage() { image.src = 'changedImage.jpg'; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
"the question of the fucking thread" And when have Reddit comments *ever* limited themselves to answering the question of a thread?
I don't think so. Sometimes you need a sanity check for things you don't use very often. W3 clearly shows parameters for things like fillRect, etc. 
Oh, my bad.
&gt; I'm beginning to think I should give up and just learn Angular 2's components +1 or look into react or vue.
I learned JS as first language and I was fully able to grasp the concept of types and what it implies. It works both ways really. Also, for most people not having a real visual feedback can be hard. I think this is a good choice for other reasons.
First of all you need to remove all elements except body in your fiddle. Second add css/js dependencies on the left side under external resources. Third: In the upper right corner of the javascript console select angular 1.4.8 and Load Type: no wrap - in body. I've updated your fiddle: https://jsfiddle.net/b7tvbuxe/6/
As long as ruby isn't the first. Teach any c-syntax language first. Then ruby. Just not ruby first.
Isn't python a strongly typed language? I thought the difference between a weakly and strongly typed language, is that a weakly perform language may perform implicit type conversion. e.g. Python is strongly typed because 1+"1" gives a typeError. JavaScript is weakly typed because 1+"1" is equal to "11"
Ancestor selectors. I have this node, but I want to select the parents which fit a certain CSS class. Sibling selectors are similarly helpful in jQuery. Now you *could* say.... but TurkishGold can't you write this all yourself, its only 2-3 lines in Javascript? Well yes, 2-3 lines of 40 or so situations that I'll have to write. I could write it all myself, but why bother making something and worrying if its cross-browser compatible? It's not as if I have to 'learn' JQuery, I already know it thanks to working in the industry pre-2016. Jquery is really useful if you want to do some extensive dom manipulation on pre-existing nodes. 
Ugh.. JavaScript is making programmers lazy
This is an intro class. 
I've said this in this thread already. I agree you should leverage standard DOM whenever possible. The post even says jQuery is a smell. But then again, and to steal from the Zen of Python "Practicality beats purity". If you can't do it with Vanilla js (and have it work cross-browser), you can probably do it quite easily with jQuery. It looks like this point isn't clear in the post so I'll make sure to make it more expliscit. Thanks for the feedback!
Started out with scheme? That sounds like an odd choice. Although I can see the upsides
 function change () { var image = document.getElementById('thumbnail'); image.src = "images/picture-2.png" setTimeout(function() { image.src = "images/picture-1.png" },500) }
You can just attach one .catch at the very end. You just need to make sure you return promises from callbacks somePromise.then(function() { return getItems().then(doStuff) }) .then(function() { return getOtherThings().then(doMoreStuff) }) .catch(function(e) { //handle errors here })
This is wonderful. :)
callback hell (antipattern) in the picture :D nice work!
Yes, I meant that you must return it (as opposed to not returning anything) *if* the value to be returned is a promise, so you can catch its error later
This sounds like a designed question used to show people learning about Promises the features of Promises (:
Perhaps, but its time to move on. I am sooo tired of hearing the whining from the programmers who believe themselves to be *computer scientists* because they have a *Bachelors of Science in Computer Science*. They must be scientists because their title mentions the word science twice. I hear this loudest from Java developers... probably because my industry is archaic and lost in the cobwebs of 2004-era Java. I worked with so many of these guys through my career that completely suck. What's worse is that the travel industry is total wrapped in legacy Java, so anybody who doesn't program in Java is automatically inferior. This means a horrid Java developer is a scientist therefore superior to a fullstack developer in any different language. This means once I have finish solving my code problems in the UI which comprises a variety of languages I have to go help the sucky ones understand things like asynchronous logic, distribution, server vs client segmentation, markup theory, recursion, and the list goes on. Worse still is that they absolutely cannot figure out JavaScript, probably due to lexical scope. Therefore JS is a shit language and its not their fault when their code sucks and they need me to maintain what they wrote, because its crap. It is time for Java to die. Yes, yes, I completely understand there are shit JavaScript developers too. At the very least I don't have to listen to them bitch and whine about how the technology is out to get them. For shit UI developers I can just give them coloring books, crayons, safety scissors, and put them in a corner with jQuery and a 1000 NPM modules.
i don't really understand but you don't need to return anything :) all errors will be caught no matter if you return something or not new Promise((resolve)=&gt;{ throw "01 error"; }).then(()=&gt;{ // will not be executed }).catch((e)=&gt;{ console.log(e); // -&gt; "01 error"; }); or new Promise((resolve)=&gt;{ resolve(10); }).then(()=&gt;{ // do nothing }).then(()=&gt;{ throw "test error"; }).then(()=&gt;{ // this will not be executed due to error }).catch((e)=&gt;{ console.log(e); // -&gt; "test error"; }); 
What you're hearing is paranoia 
You're thinking of statically typed.
Ok, here's an example: //no return statement somePromise.then(function() { getItems().then(function() {throw "oh noes"}) }) .catch(function(e) { //ain't catching nothing from the getItems() chain }) //with return statement somePromise.then(function() { return getItems().then(function() {throw "oh noes"}) }) .catch(function(e) { //e === "oh noes" })
Plenty of strongly-typed languages have REPLs (Haskell being the most notable). And personally, I'd think itd be much easier for a beginner to fight a compiler than chase down bugs in runtime.
Scheme *is* a strongly typed language, though. You probably mean static, or not-dynamic. From wikipedia: ``` Scheme uses strictly but dynamically typed variables and supports first class procedures. Thus, procedures can be assigned as values to variables or passed as arguments to procedures. ``` Strong or weak typing determines what the program will do if it is passed an argument of the wrong type, such as 1 + "1". In weakly typed languages, that will compile - in Scheme it won't unless you explicitly convert it.
I didn't at all say it was a challenge. Strongly typed languages will force you to think about data types, which is hugely important.
Goddammit. That's what I get for posting pre-caffeine in the morning.
Here is your fiddle working: https://jsfiddle.net/b7tvbuxe/10/ All I did was include Angular through the jsfiddle options instead.
Elm would be a fantastic first language too. The functional parts of elm are somewhat hidden and the compiler error messages are so friendly
&gt; Most end-to-end curricula are in one language, whatever that is. I don't think this is the case, generally - it certainly wasn't in my program: over the course of college I had used C++, Java, LISP, Objective-C, JS, Perl, PHP and even Prolog for one class or another. And if it is the case, then that's the real problem, not the choice of language for the 101 class.
The truth is that any extremely selective institution can pretty much use any tool and the students will figure it out. That doesn't mean that the tool is really appropriate or the best available. For most beginners, I think JS is probably not the best choice in most cases but that's mostly due to tooling. I wrote a bit about it here: http://cestlaz.github.io/posts/starting-with-js (I also wrote a bit about starting with scheme: http://cestlaz.github.io/posts/starting-with-scheme/ Over the years, I've started out kids using Java, C, Pascal, C++, Python, Scheme and JS and there's no universal best choice. 
Yea so start with C/C++ and then just go to JS. If you can code in C nothing in Java will seem very complex. But Java is an important language no doubt, but I wouldn't say it should be their first language since C is so much better for exposing students to CS.
It's not stupid. Here's why: you can build an interesting application in JavaScript that goes beyond a console window. You're not going to even get them to care about strongly/weakly typed languages if they aren't having fun building to begin with. And seeing text, or computations, or results of a data structure, on a terminal is hardly inspiring.
I used notepad++ and the Java compiler for my intro to Java class. It doesn't take much. Android does but Java is pretty easy.
Different tools in the toolbox. JavaScript could be great for beginners just because it's so flexible.
At least you get that much. I swear the last 10 emails I've gotten have said "...looking for someone with your skills in_________". Seriously there was a blank line.
but would you like a 3 month contract in New Jersey?!?!??!
Sorry accidentally deleted my other comment. This course: https://frontendmasters.com/courses/javascript-basics/?u=99ef211e0b71e089624b136ec91e8e5b6b748878 Kyle Simpson is great. 
The cat that it found in the github demo gif was only semi fat :(
cross browser is usually not a problem, since most use some chrome-ish engine and firefox is pretty good, too. the issues i face mostly are mostly with older browsers or weird ass things like in-app-web-view-components (had a bug yesterday, cause i used window.open and that doesn't work correctly out of the box in an ios webview). for older browsers i recommend [polyfill.io](https://cdn.polyfill.io/v2/docs/). it gives you the ability to use modern js apis in any browser by dynamically polyfilling based on the user agent. pretty cool tool.
In my university, we had a core curriculum that used the 'standard' language---first C++, then Java---but that was only 6 classes in 4 years. Every optional class was free use whatever language the professor desired. Most professors liked C. Some liked Python. No one used Lisp or Scheme. One used Haskell. One professor mandated we use a different language for every single course project, and no one was allowed to use Java or C/C++.
Try freecodecamp.com I made the switch from .CA to FCC and haven't looked back. It's more interactive and at the end of each bulk unit you have a project that has you use all the skills you learned IRL it's honestly great. 
Awesome will def check it out thank you
Yeah no problem. Just spreading knowledge and fun. Good luck with your coding adventures. 
Yeah for sure i want to major computer science but im scared because i will prob make mistakes 
Neither is better than the other when it comes to to Enterprise Apps, choosing which one to use depends on you or your team. Angular offers you the more traditional OOP model of programming with some of functional reactive programming being thrown in with RxJS(extremely useful tool). Everything you need to build your app is provided for you including routing, animation library, state-management and UI-design(Angular-material - optional) Typescript is a great plus when it comes to big apps as it offers type safety, It isn't unique to Angular but using it with Angular is definitely more streamlined than with React. The Angular CLI is also a a great too as it automates a lot of your programming and gives a great out-of-the-box build configuration. In short, if your more comfortable imperative programming then Angular is definitely for you. React/redux offers a more composition-based, functional programming paradigm. React handles the view layer of your app with the help of jsx whilst redux handles the state, everything else is left up you. Create-React-App is react's CLI which offers some automation and an excellent build environment. React is for those who have embraced the functional side of JavaScript. I mostly choose Angular mainly because of personal preference, It does not solve problems better than React or vice versa it just fits more into my programming style. 
Underscore or lodash?
JS dev world is already full of shit, so no worries there :)
I disagree - I would say that it has everything to do with a lot of things. 
Have we taken JS too far? We're one NPM package away from sentience...
so add it with a comma , it doesnt work but now i see how to use them together , thanks 
I'll check, thanks
Yep! Options to .DataTable are passed as JSON object ( {} ) Inside those curly braces you can insert any properties comma separated in format property: value For example { property1: 100, property2: "reddit", property3: {} } Hope that helps! 
I think that form handling including validation is a complex problem that should be solved by a framework targeting this problem, built on top of a more general framework/library like React, Vue or Angular. The set of required features would include: input validations, both sync and async; input formatting; value conversions; customizable error and warning message display; custom validation of multiple inputs; reusable fieldsets (subcomponents) with own validation rules; externalizable validation rules; form submitting with technical and business error handling; loaders, overlays, etc. Unfortunately, there is a lack of really flexible and universal form handling frameworks. As for what to do, I would suggest you looked at [Vuelidate](https://monterail.github.io/vuelidate/) for Vue. 
I wouldn't say it's too difficult, but a lot of things definitely clicked for me after going from JS to C#.
sorry! will repost r/typescript.
Thanks! I'd used such sites before but they all appeared to be down now - didn't know about feed43.
The whole event system makes sense to me (Built a medium-size app with Angular 2 years ago and the 2-way binding made me crazy). We thought we should create components for single fields because some fields have a more complex validation than just "required" (e.g birthdate or phone fields). But I get your point: Why should we introduce so much abstraction for simple HTML fields? I will probably propose to discard the whole idea and just build a simple HTML structure in a Vue component. We won't create thousands of widgets in the next couple of years and a simpler structure is probably much easier to digest for new people joining the team. 
Damn. You're right. I was blinded by the simple Vue Syntax that I totally forgot that Vue is just the "MV" layer.
When I took the PSAT in high school, they asked what I planned to major in, and I checked "still deciding". Of course, they then sent that out to colleges so they could send me junk mail. Mostly, I got pretty generic spam, as you'd expect. But I'll never forget Drexel University, whose letter noted my interest in Still Deciding, and claimed that they had one of the best Still Deciding programs in the country. Apparently, they even had an internship program, so that students could get hands-on Still Deciding experience in the real world.
https://threepanel.com/t/cube-drone/18/152 
[removed]
Hah! I have worked with some folks (usually pretty young...) who reach for some sort of style checker right at the beginning of every project. I guess they've learned somewhere along the way that it's an essential tool in every JS coders toolbox. Of course, depending on how it's implemented, when other developers are affected by it, a discussion about coding style conventions needs to then happen, either in-person, or by e-mail, or on Slack, etc., and, well, meh. I dunno, I suppose if you're like, say, Airbnb, and growing fast and bringing on lots of young JS devs all the time, maybe some forced adherence to coding style conventions is worthwhile. Everyone is able to have certain expectations whenever they open a source file for the first time. And that helps speed things along, I guess. But, since, like I said, I have a "rich media" (don't think that term is even used anymore; er, "creative coding") background, and had an arts-based education, and am accustomed to working closely with graphic designers to implement whatever crazy vision they might have for a UI (and, with Flash, anything used to be possible, of course), telling anyone how they need to handle whitespace around brackets or whatever seems a bit like telling a painter how he has to organize his paintbrushes. Individual coding style can also offer a unique insight into other people's brains, something someone's non-coder friends just wouldn't understand. Sharing code can be strangely intimate in that way. For example, you've made it clear just how much you hate curly brackets being on the next line. Seeing it makes you downright suicidal! That's a pretty intense reaction to line breaks. So, I'm not a big believer in style rules and if more or less whitespace helps someone to be more creative, great. That probably means that I won't be working for Airbnb anytime soon, though. Oh, well. :)
`vue-expose-inject` looks promising. Thanks for your feedback 👍
&gt; I've tried using object notation like [0][1] and so on without success You need to show exactly what you tried if you want us to tell you what you did wrong. After you've parsed the JSON, you've got an array containing a single object. The name can be accessed from that object. &gt; let foo = '[{"id":2,"name":"example","start":"1000-01-01T00:00:00.000Z","end":"1000-01-01T00:00:00.000Z","user_id":12}]' undefined &gt; let parsed = JSON.parse(foo) undefined &gt; parsed[0].name 'example' 
The portion I quoted is discussing certain aspects of JavaScript such as Objects, Numbers, Strings, etc. What made me "laugh out loud" was I know plenty of people working with node that are still confused by certain esoteric aspects of JavaScript / JS methods. What I understood from the quote was if you are still confused by even one small part of JavaScript than you're not ready for Node. Which, of course, is absurd. And, yeah, he did preface his article by saying some of the node questions he listed he couldn't even answer. 
If you use flow, you can just comment out the types https://flowtype.org/blog/2015/02/20/Flow-Comments.html . It's a little bit uglier, but your syntax highlighter probably already support this form of annotations, so you probably won't even notice the difference.
Awesome!
So the main difference are with this CLI you can choose to use React or Preact but there is a `create-react-app` equivalent for preact too. As I see it the main difference is that it's **simplier** bc it takes less decisions for you, that being you don't want to use css? ok don't. Do you wanna use less/stylus/sass? pick your own change the configs and you are all set. Do you wanna use standard / airbnb / other styleguide? be my guest. Also the configs are not hidden from you. On `create-react-app` you only get access to the source of the app unless you `eject` and then you get all the configs ( that are a lot of files since it comes with a dev setup, a production setup, jest and so for it . This CLI just adds the basic webpack config and the babel configs. ``` $ cat webpack.config.dev.js | wc -l 217 ``` That's the number of lines of the dev config ejected by CRA ``` $ cat webpack.config.js | wc -l 19 ``` This is the one created with this CLI. I'm not saying one it's better than the other but for **me** I like to avoid boilerplate configs as much as I can, because I like to choose my configs however there's always a minimal amount of configs that are the same and that's what is on this tool.
As someone going from weakly typed (JS) to strongly typed now, I definitely agree that it is hard going from 'It doesn't matter if this is a string or a number, JS will figure it out!' to 'Okay, now I need to define an interface for this and then...' But I think that's the major selling point for beginners to programming and a language like JS. It's a very low bar for entry and you can immediately start testing ideas and ways of programming without having to first design your system with types. 
This. Getting people to write lots of code is more important. You can always add types into the mix after they understand assignment, comparison, functions and objects. Plus javascript lends itself easily to functional style, focusing on input and outputs instead of state manipulation. Then you can introduce more bare metal manipulations with c++ and oo/types in something like c#. But being able to write programs with nothing but a browser and a text editor is pretty nice.
Lucky you! Man, "HTML5" is a far cry from Flash. Killing Flash was a great leap backwards for creative coding (in web browsers, at least). This is a pretty good take on it: https://qz.com/863467/how-adobe-flash-once-the-face-of-the-web-fell-to-the-brink-of-obscurity-and-why-its-worth-saving/ "If bulletin-board systems marked the modern internet’s infancy, and AOL chat rooms its childhood, then Flash was the web’s adolescence—its weird, rioting teenage years. Flash wasn’t just a tool or a technology; it was its own genre. Quirky Flash-based cartoons and video games proliferated in the oughts, identifiable by their vector art style and striking departure in tone from traditional media. The world had never seen a cartoon quite like Homestar Runner or a video game like QWOP before Flash made such things possible." I think the fact that young developers/artists/developer-artists can't just pick up the basics of a tool in a day or two and start publishing whatever wacky interactive/animated stuff they can dream up to the internet right away is a real loss. And "Flash hate" is particularly unusual because it's a bit like hating leaf blowers because Steve Jobs said that the only proper way to gather dead leaves is with iRakes. Like you said, the end user doesn't know or care how their app/game was made, it just needs to work in a way that's satisfying to them. Jobs, on the other hand, REALLY cared about how people would be able to access experiences on Apple devices (through their store, and preferably paying for them, with Apple deciding what's good enough to run on one of their devices), so killing Flash was certainly a good business decision for him. Do you do any mobile app dev with Flash or is that something that's just not attempted anymore? I haven't used Flash in quite a while so I'm not up to date on how anything Flash (I guess just the run-time, in your case) is being used these days. After my recent experiments with "HTML5", though, I might have to just get back up to speed with Flash (and I'll have to look into Haxe if I do) and give up on "creative coding" in web browsers. It's amazing how difficult it can be and how inconsistent experiences are across browsers. Flash might have been full of security holes, but it was also pretty great.
you have an array of objects so: var example = jsonObj[0]['example'];
Yeah, to be fair I'm sure I have a similar bias in the other direction. I just recently spent some time trying to get into elm and came away frustrated at feeling like I wasn't smart enough to figure any of it out. Someone with no experience probably sees programming as a whole as magic, with tons of arbitrary rules, so elm could be no different.
Reminds me of this: https://www.youtube.com/watch?v=BKorP55Aqvg
it's funny i recognize it from AS. i was just joking.. but yeah style comes later
This was exactly what I was looking for! Apologies if my question too vauge.
The answer is in the quote: &gt; Authors should not use most of these features directly, but instead use JavaScript editing libraries. There are many libraries to choose from. For example [CodeMirror](https://codemirror.net/), [Ace](https://ace.c9.io/), [ProseMirror](https://prosemirror.net/), [Trix](https://trix-editor.org/), [Slate](http://slatejs.org) and [Quill](http://quilljs.com/) are great. I would stay away from older libraries like TinyMCE and CKEditor because they are inflexible and heavy.
You're trying to dabble in stone age web technology. Install Node, a "vanilla setup" makes about zero sense, you're just making it harder on yourself. `npm install webpack --global`. Set up your project running `npm init -Y` in it and you're ready to go. A simple `webpack.config.js` like this is enough: const webpack = require('webpack'); module.exports = { entry: './index.js', output: { filename: 'bundle.js', path: __dirname + '/build' } }, }; Now you can import any module in index.js, as deeply nested as you like. It's Node aware, so if you need something, say lodash, simply `npm install lodash --save`, then `import _ from 'lodash'` in your code. Add a loader for Babel and you have es7 (classes, etc). Webpacks inbuilt dev-server lets you develop apps without getting blocked by browser security (you couldn't in your setup). This guide: https://webpack.js.org/guides/get-started/ explains it all.
I actually do it everywhere (Java, PHP, etc.; any language that uses curly brackets, I guess) because I think it creates a nice separation between a function's name/parameters and its body code. It's interesting how some people are more tolerant of vertical smushing while others (like me) are bothered by it but then go crazy horizontally (I love getting as much done as possible in a single line; I have to really stop myself from going overboard sometimes). Those style checkers force conformity on coders, though, which is kind of creepy to me. May as well make developers all wear the same shirts like they're working at a Best Buy or something, too. Or, you know, just replace them with robots (which should be happening soon enough anyway). For now, though, for human coders, vive la différence! :)
Childish comments, and childish the idiots who are downvoting me
Document.querySelector only returns the first matching element, so you would probably use document.querySelectorAll instead. Something like this would start things off: document.querySelectorAll('li').forEach( element =&gt; { element.addEventListener("click", liClickHandler); }); function liClickHandler(event) { event.target.innerHTML = "Clicked!"; // some code that fades the element } I've used an ES6 style arrow function, but you would use an old style anonymous function if you want support for older browsers. (Disclaimer - I've not tested this, it's off the top of my head...)
Browser doesn't matter. Babel takes care of it. But anyway, just curious, whhyyy IE11? :)
You may want to read this, it has samples of output from a rnn trained on Linux kernel code: http://karpathy.github.io/2015/05/21/rnn-effectiveness/
Thanks for the suggestion ! 
Node is a standard, there probably isn't a single production site in the internet that doesn't rely on it or manages dependencies by hand. There is nothing "non-standard" about npms dependency management. "Standard modules" have not "arrived in browsers" in a way you could rely on it. "1000s of dependencies" in node_modules do not go on the server, just a single bundle + index.html. Webpack also does much more than just bundling. Anyway, you're seriously recommending a doubleclick on index.html and *vanilla import.* ? 👌
I saw this as a black magic feature in the new bundler FuxeBox: http://fuse-box.org/#auto-import You could do it like that, even though it's kind of weird bundling a backend project. If you're tired of writing them and you use vscode, you could try my plugin: https://marketplace.visualstudio.com/items?itemName=capaj.vscode-exports-autocomplete Another way you could go would be to put dependencies you've got in package.json onto `global`. While it's hacky, it would be trivial to implement and it would work quite reliably I presume.
Yeah programming still feels a little magic to me. It's easy to take for granted the concepts we think of as second nature now, but at the time were incredibly mind bending. I remember learning about closures and even for loops and having major difficulties. If you're ever interested in taking another crack at elm, feel free to send me a pm or ask questions on the slack or the subreddit! It's really powerful once you get the hang of it.
This operation/pattern is in a few functional utility libraries. Depending on whether you want the initial function to be able to take multiple arguments or not, it can be pretty simple: const pipeP = (...list) =&gt; acc =&gt; list.reduce( (acc,fn) =&gt; acc.then(fn), Promise.resolve(acc)); or: const pipeP = (fn, ...rest) =&gt; (...args) =&gt; rest.reduce( (acc,fn) =&gt; acc.then(fn), Promise.resolve(fn(...args))); Where the list is just any functions that take arguments and return either Promises or values. `a -&gt; P a` or `a-&gt;a` Your load function is accepting prebaked arguments instead of chaining a -&gt; P a, which seems like a fairly unlikely use-case for a sequential operation (i.e. if you already know the inputs to every function, why run them sequentially?), but even so .bind isn't the only way to do that. Another is to simply apply a curried version of the load function to the list of arguments, then pipeP or reduce over that: const args = [1,2,3] const loadThunk = arg =&gt; _ =&gt; load(arg) pipeP(args.map(loadThunk))() 
The official/not quite official yet but will be designation is Angular vs Angularjs. Oh and I agree that you will be fine with whichever one you choose as a starting point. But if you do choose angular use the [cli](https://github.com/angular/angular-cli).
This is a lot of white washing of flash. Having to install a 3rd party binary plugin into an open standards browser? Adobe's careless attitude towards security holes? Annoying flash pop-ups and ads and everything else? Maybe it made content creation easier but it wasn't worth the price of admission. Oh and none of that has anything to do with Jobs or Apple. Flash was garbage before he was even the Ceo of apple for the 2nd time.
You can get an array of names if you want with var names = obj.map(o =&gt; o.name);
I wish we could stop talking about one paradigm vs some other. The examples are almost always misleading, and none of the paradigms are best in every way. &gt; Reusability. In functional version, the open function can open anything that has a boolean locked property. That's neither functional nor OOP. It's [generic programming](https://en.wikipedia.org/wiki/Generic_programming), which manifests in other languages as [generics](https://en.wikipedia.org/wiki/Generics_in_Java) or [templates](https://en.wikipedia.org/wiki/Template_(C%2B%2B\)#Function_templates). In C++, for example, we'd write: // open anything that has a boolean locked property template&lt;typename T&gt; auto open(T obj) { obj.locked = false; return obj; } &gt; Immutability. As the codebase grows, it will become harder to keep track of myDoor object in OO version (has it already been opened on line X?). You can write OO *and* still be immutable. And some of the best programmers [have been advocating for that](https://i.imgur.com/Zn2mApB.png) long before this recent functional craze. &gt; In FP version, myDoor is pure data — it could be imported from a JSON file or received from a REST API. In OOP version, myDoor is an object that stores some data as well as methods to manipulate that data. I said earlier that none of the paradigms are best in every way, and I consider this one of the bad parts of FP. Pure data means no encapsulation, which means as your program grows -- thousands of lines, millions of lines -- every part of your program is responsible for knowing and adhering to the rules that make your data valid or not. It would actually be better to have just a small handful of functions that directly manipulates the data, and have the rest of your millions of lines interact with the data only indirectly through one of those few carefully crafted functions.
&gt; Vue I've never even heard of Vue, tbh. Might look into it some.
Ah, that's really cool! Really nice to see some type-checking brought into this sort of thing. I'll give it a whirl this weekend and get back to you, but the README has got me pretty excited (particularly RE: type-checking recursive types!)
I'm happy to hear that :) Also, great blog post! Good luck with your series.
_Definitely_ Folktale - I wanted to use `data.task` as a good example of where the Applicative typeclass comes in handy. As for Ramda, I can imagine quite a few functions popping up as I go (particularly `map`, `liftN`, `traverse`, etc...), but I hadn't thought of covering it specifically! I can see myself writing about some of the particular concepts behind it, and how to use it to solve given problems, definitely. (e.g. I think it's probably better to explain how to use `traverse` for something practical, rather than spend time explaining what `keys` does). Really happy to hear you're interested, though - watch this space! :D EDIT: I _do_ think Ramda's currying is quite messy, though. [I wrote about an easier approach](http://www.tomharding.me/2016/11/12/curry-on-wayward-son/) and [created a tiny library](https://github.com/i-am-tom/wi-jit) as a result of a couple late nights with Ramda debugging. Is this plug shameless enough yet? :$
Check out [Electron](https://electron.atom.io/)
This is a bit different from what I was hoping for but it looks like what I need, thank you.
Literally every name is Indian in the emails I receive. It must be a booming business in India. I used to call to bitch at them, but I 100% could not understand what they were saying. I already have trouble with accents, but their accents are sooooo bad.
At my job we currently went through this same question. Right away we eliminated Angular 1 because it's not the latest with Angular 2 out. We actually moved with React because it fit better with our application, the documentation/tutorials/resources were better in our opinion compared to Angular 2. Don't get me wrong though, Angular 2 is a great framework and is very powerful, but depending on the needs it's up to you. To answer your question on which you should learn, I think learn both because there's no right or wrong on what will benefit you in the future. 
That's to maintain company wide consistency, not really a political decision. Ive been at some enterprises that go Allman, some go K&amp;R. It all depends on the preference of chief of engineering or the consensus of the group. 
I wrote something to accomplish that. In my case it supports a mix of sync and async functions within a same pipeline. Take a look at the source and see how it is simple to do that using "reduce" https://github.com/DiegoZoracKy/pipe-functions
To replicate jQuery's fade, you would need to use animation, with display:none at end
I am recommending, if the OP hasn't started yet, to just be patient and wait a couple of months for a standard approach instead of immediately jumping into something that is about to become obsolete. Node provides a well documented API, but that doesn't make it a standard. Standard implies agreement from multiple external parties, like TC39.
So first I have no issues with flash in a standalone application. That's whatever. And second, yes Jobs refusing flash on ios was key to its demise on the Web. And yeah it did enable some things which weren't possible at the time due to web standards moving at a glacial pace. We can even probably thank it, to some degree, for getting the w3 off their high horse in those regards. But none of that excuses it from also being horrible. It was a binary blob so security holes couldn't be properly addressed except when adobe felt like it. Yes, everything has holes. Which is why it is a horrible idea to increase the surface area for attacks by adding yet another sandbox that can be a vector. And even worse when it's a binary blob so that users become beholden to Adobe to correct any flaws. And again, even though it did give some power to content creators it also gave power to annoying advertisements and that sort of junk. Flash was like giving a 3d printer to everyone. Some people created interesting stuff. But most people just created more dicks.
I will but it is really slow at this point. All it can do is simple hello world. Actually Hello World is even to difficult for it because at this point it is all random. The next step is to add in some sort of learning so that I can reuse parts of an AST in subsequent generations. I am in the process of cleaning up the code so I can publish it on GH and hopefully get some human help with it. I have only implemented very simple expressions right now.
I have done quite a lot of work in angular 1.x and backbone in the past. I still use angular at my day job everyday. Recently I was at a similar crossroads to figure out whether I should go the react way or the angular 2 way forward. I started with react and quickly found that react alone simply caters to the view part of the framework and nothing more. To effectively use it for a complex application you have to learn a few more things like redux for data management, webpack or some other bundler, transpiler etc. I found an overwhelming number of tutorials that all did things differently and the learning curve pretty steep for the react eco system. At the same time I also decided to give angular 2 a try. I found it surprisingly easy to set up and pick up. Angular is a full fledged framework so CLI basically sets up pretty much everything for you. I was hesitant about typescript but a few days in, i could see how organized and clean everything was. So I have gone forward with angular 2 and no complains so far. As a disclaimer, angular 2 concepts might have been easier for me to pick up because I have worked in the angular world for so long... So take my experience with a grain of salt. But I think one of the major considerations for new tech stacks should be how fast you can get from 0 to 60. For me angular clearly stood out there. Good luck! 
I'm a senior developer and worked for about 1.5 years on Angular 1.x, a bit on Angular 2 for an open source project and now am working on a React project. Angularjs 1.5 added a way to create components similar to Angular 2 and that made its component lifecycle much more predictable and easier to use. Overall I'd still say Angularjs 1.x has the most quirks you need to know to work with it. Its two-way binding is not always obvious and sometimes causes problems. With Angular 2 you will most likely spend more time learning to work with Typescript but overall it is very similar to React when it comes to the components. Angular 2 just gives you essentially a full package and a way to work with it whereas React allows for more mix and match. With React if you use Redux you will most likely be most confused with how to integrate Redux to work with your components and containers. Overall a lot of the skills you learn doing Angular 2 will transfer to React and vice versa. Which one you pick depends on what kind of work you are looking for. There may be companies using Angularjs 1.x on existing projects so that might give you a foot in the door whereas Angular 2 or React might be more attractive for startups or companies that like to work more on the cutting edge. At the company I work for we did Angularjs for several years, then moved to React+Redux pretty much exclusively. I suggest you consider which one seems to work best for your project and which one appeals to you the most. I would probably pick either Angular 2 or React out of your options.
I've googled it and you're right. But it is supported in newer versions of chrome and firefox, so I suppose I've been using it not realised the cross browser support is missing. The simplest cross browser alternative looks to be the for of loop: var elements = document.querySelectorAll('li'); for(element of elements) { // act on each element }
I was agreeing with you :)
ng2 or react. ng1 is going to still be supported (stated by google) until the web traffic from the ng1 docs migrates to the ng2 docs. Once that happens, support will cease. https://toddmotto.com/future-of-angular-1-x
Most people use `[].slice.apply(document.querySelectotAll()).forEach()`
Note that Electron requires separate compilation for each platform.
How would I add a fade transition to this? ^^^^
I thought you needed brackets for the fat arrow style anonymous functions - eg: ``` const listElems document.querySelectorAll('li') listElems.forEach((li) =&gt; { li.addEventListener('click', (e) =&gt; { //Do something when clicked }) }) ``` Or if your browser doesn't support forEach for this: ``` const liElems = document.querySelectorAll('li') for (const li of liElems) { li.addEventListener('click', (e) =&gt; { //Do something when clicked }) } ```
This is like asking "should I learn to develop for PCs or mobile phones?": there is no right answer. There are companies building Angular apps (both versions; Angular 1 didn't just disappear the moment Angular 2 was announce), and they want people who know Angular. There are also companies building React apps, and they want people who know React. It's six of one and a half-dozen of the other. But that's not very helpful if you're trying to pick one to learn now is it? So, recognizing that there is no "right" answer, here's my advice: Angular 1: don't do it. There are LOTS of people still using Angular 1, but (unless Google truly screws up Angular 2) Angular 1 is the only one of the three pretty much guaranteed to get less popular over time. So that leaves Angular 2 vs. React (or Vue, also a good option technology-wise, but not nearly as popular with your average software engineer-hiring company). No wrong choice, but here's a simple question that cuts to the heart of both frameworks: do you want logic in your HTML, or HTML in your logic? Angular moves lots of logic in to the template/view, ie. HTML, layer (eg. all those Angular directive things). Conversely, React (and its JSX technology) puts HTML in to the Javascript logic. If you believe that small bits of HTML inside JS logic sounds good, pick React. If you think moving more (but certainly not all) of your logic in to your templates sounds good, go Angular. P.S. Again, there's no wrong answer, but just to give you one more data point, personally I fall in to the "why on Earth would you want to put more logic in to the view/template layer where it's harder to abstract, test, etc.?" camp, so personally I vote React.
You can omit the brackets in the case of having only one argument. You can even omit the curly braces too when you just a simple return expression. A simple example: const exampleArray = [{a:1, b:1}, {a:2, b:2}]; // how you'd expect exampleArray.map( (item) =&gt; { return item.a }); // results in [1,2] // simplified, still valid ES6 exampleArray.map( item =&gt; item.a ); // results in [1, 2]
Well, there are lots of UIs out there, not just the ways that people interact with products from Silicon Valley "unicorn"-type businesses. And however proven any concepts are, they are still just, well, a limited set of ideas. Are you a fan of Brett Victor at all? I certainly am. If you haven't seen his "Future of Programming" presentation on YouTube yet, check it out sometime: https://www.youtube.com/watch?v=8pTEmbeENF4 Some quotes pulled out in the video description: "The most dangerous thought you can have as a creative person is to think you know what you're doing." "Once you think you know what you're doing you stop looking around for other ways of doing things and you stop being able to see other ways of doing things. You become blind." "I think you have to say: 'We don't know what programming is. We don't know what computing is. We don't even know what a computer is.' And once you truly understand that, and once you truly believe that, then you're free, and you can think anything." Obviously whitespace around brackets doesn't matter all that much in the grand scheme of things, but the underlying motivations for enforcing rules about such things (in an organization or a team or whatever) might. Does just the feeling of being stifled or controlled in some way maybe have some negative effect on creative coders? Or, as Steve Jobs might put it, by trying to guard against mistakes that could potentially be made by B- or C-players, are you scaring off the A-players that bristle at irritating, unnecessary hand-holding? Also, I'll have to disagree with you about people becoming great at UI because they've become advanced by solving problems efficiently. Again, there are lots of UIs out there. Brett Victor uses the example of a hammer in one of his popular blog posts. There are lots of human "user interfaces" out there that will never even be thought about by CTOs. And even interfaces that require a bit of software should look and feel and behave entirely different from what we're accustomed to now (what Victor calls "Pictures Under Glass") in probably just a decade or so. A CTO who is maybe a bit too sane might miss a significant transition in the ways that people are interacting with tech and waste his or her company's resources holding on a bit too tightly to proven concepts. But, again, whitespace around brackets: really just a personal choice. I'm cool with whatever.
Hah! Yeah, I'd imagine that a bit of complacency set in at Adobe since everything cool on the web was tied to their plugin at the time. That's a risk for any company, I guess, even Apple (or whoever else) now. Trying to stay innovative, while also protecting users from the gazillions of hackers out there these days, is trickier than ever. You have to be able to continue doing both, and well, at all times. Fail at either and your business really suffers as a result. Apple is really aggressive about locking people in, though, which creates some uncomfortable experiences when interacting with their products. Apple demands to know absolutely everything about their users, throws up massive legal documents constantly (which South Park made fun of pretty well with their "HUMANCENTiPAD" episode) that users have to agree to, and is constantly trying to take money from users by any means necessary. I'll take the freedom of Linux and web apps over that any day. Even if it means suffering a few Flash dicks every now and then. :)
Angular 1 is already out of question IMO (unless you plan on working on legacy projects). I've worked with both React and Angular 2, and it might be because I started working on Angular 2 right after it was released, but I lowkey hate it. The documentation for it is pretty sparse, finding it is hard because if you accidentally forget the "2", all your results are about Angular 1, and all projects using Angular 2 that I've worked on were bloated. React on the other hand is pretty well documented, it's easy to pick up if you have general knowledge about Javascript. But you can't use it on its own (unless you really reall want to), you have to plug Redux or something similar into it, which can complicate things.
&gt; enforces solid front-end practices I'd disagree with this. Yeah, the component model is very good, but I've seen so messy flux/react codebases that I know for sure react doesn't enforce those practices. It merely encourages. It merely opens the door for the programmer. Programmer still has to walk through it.
My current solution is to import every related modules into a single file and export it, ex: controllers.ts import Home from "../controllers/home"; import Account from "../controllers/account"; ... export { Home, Account, ... } This way, I just need to import one single file and still get all thing i want: controllers.Home,controllers.Account ... The benefit of this method is I can get IntelliSense suggestions from IDE And since it just sit inside a single file, it is very easy when I want to refactor the code. I also avoid dynamic module loader ( like fusebox auto-import above) since I don't want to lose the IntelliSense ability.
Yes, as of ES2015: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
[I removed the node to remove the space the element takes up.](http://codepen.io/anon/pen/jBrEeE)
Yep, totally a fair point. This was put together to respond to a specific issue we were having with our WordPress site. To give some background: Our site is peppered with several self-contained, stateful react components needing read and write access to our database. Before the REST API was released, we initially had to either dump JSON data in the page source using `wp_localize_script`, or create ajax endpoints and retrieve using XMLHTTPRequests the old-fashioned way (which was a giant headache). Enter the REST API and that solved a majority of our issues, however, `wpapi` and/or standard AJAX calls to the REST endpoints resulted in large promise chains for a relatively small amount of data because you have to write requests separately for each endpoint. That wasn't ideal for readability. `wp-graphql` performs the exact same number of requests as you'd have to make using the `wpapi` library or with standard ajax, but it _greatly_ reduces the amount of code you need to write to make them. Also, it enforces a stricter, declarative pattern of data fetching so that you are only getting back _exactly_ what you need. So, in short, we justify it because we get some of the added benefits of GraphQL without sacrificing anything from using the REST API the old-fashioned way. It's working extremely well for us. Figured others out there might be having similar issues we did. Thanks for the feedback! 
FYI, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. That includes a big section on [Webpack Tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md).
If neural networks could read code and write it, we'd already have fully fledged AI right now. Neural networks aren't as smart as you think. You can't train it on an episode of game of thrones and have a story pop out. I mean you could, but the story wouldn't be coherent. Neural networks work on patterns but that doesn't mean they have intelligence. It would pop out stuff that vaguely reminds you of a game of thrones story but it wouldn't have an overarching plot line, character development, or deeper concepts. If you train it on code it may write code that looks syntactically correct but it wouldn't actually do anything. There'd be no goal or problem it solved. It would just be gibberish that replicated code. It would look like code but it's not like it would actually do anything useful. Yet. 
But flash is like the antithesis of Linux and oss
I dunno, this one's a little different. It recognizes that we do need build systems, but suggests that we go all the way and pick other languages that compile to JavaScript, not transpilers.
&gt; My point is wrapping ajax calls into a "GraphQL API" isn't GraphQL. This is a good point, but technically incorrect. Under the hood the GraphQL language is most definitely used. The only difference to perhaps the server-side graphql you're used to is that it's using a client-side transport layer. Instead of the resolvers interfacing directly with server-side methods that interact with a database, they are interfacing indirectly with ajax (again, totally aware of the limitations of doing it this way; we spell that out at the bottom of the readme). The end result is the same data you'd get if you implemented server-side, but with extra trips over the network (similar to standard REST). &gt; GraphQL is a language, not an API. Agree. I don't believe I suggested otherwise. If I did, forgive me. &gt; The implementation details are supposed to live server-side. It would have make much more sense to implement GraphQL in WordPress. Yep, agree that would be better. We initially were going to go that route, but it ended up being difficult to pull off because composer and WordPress aren't super friendly with one another (and more importantly, our small team doesn't have the capacity to figure that out). We're using server-side GraphQL in some of our other projects. This works well for us for the WordPress site because it follows the pattern that we've all grown accustomed to. Again, great points. Appreciate the discussion.
I would assume each instance would be allocated separately. I don't have a reference for that, though.
I don't think it can produce invalid code right now. There is only variable declarations and they must be either a literal string or binary expression. I guess I could also make it generate just a definition without the declaration and then prevent that. Good suggestion!
Page doesn't load. Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security.
Event listeners execute on the same tick as the event was emitted. Streams (in pause mode, now the default) happen in order and pull data from the source as they are consumed.
 sinon.stub(DB, 'Request'); ?
Vue definitely is easier to plug in with Rails.
I've done a ton of production web apps using knockout, angular and some react and others, but Vue is by far my new favourite. I think you'll see it rivaling the others in the near future in business apps. We're using it all ours moving forward.
`sinon.stub(DB, "Request").returns(Promise.resolve(rows))` perhaps.
It's very nice. Especially for small projects and as a tool for learning how modern frameworks work. Worth investigating for sure.
Nah, I'll take flowtype over typescript for functional applications, like React+Redux/MobX
Huh, would not have guessed
Web components is what Angular 2 is doing. Almost fully compatible with the spec.
You should do projects that interest you and choose tools suitable for the projects. Node.js is a great platform and it's suitable for a wide range of projects, but if it's the wrong tool then you shouldn't try to force it in. Ultimately it's not about the tools you use but what you're trying to build. **Don't learn tools for the sake of learning tools, do great projects and learn whatever you need to learn to make it happen.** "Should I learn Node.js?" is not a good question. Your question should be "I want to do ____, is Node.js a good platform to build it on?" Stop asking questions until you have something you want to make.
I've never done it for ES6 classes, but in objects, I use @member instead of @type. 
[removed]
Vue.js
You can never be too sure, I use React with Apollo Client. This seems like a dangerous assumption to me
Yes OOP, MVVM are superceded by better paradigms. But the masses are still swimming in there and sometimes never experienced anything else. Better off are those that already moved to FP and reactive architectures: they are ahead of the curve.
I sure was :)
 It looks like copy paste from other articles, with one of them referencing Vue 0.11.
The issue is they're not separate concerns, and having ngFor and ngIf ngModel in your HTML is not separation at all!
what is RC? 
As someone who uses the SOLID and heavy OO at work, but prefers more functional/reactive design patterns it seriously kills me inside. To me it just seems absurd, so much time wasted considering the responsibility/state that each object holds and always later finding out that some unthought of functionality becomes super complex when the whole system of hierarchies does not support such a task simply. I have yet to ever think "Whoa, this really works". Honestly, only in video games does OOP make any sense. 
I feel the same brother. No not even in videogames actually. I was a game developer once and we used ECS (Entity Component Systems) because OO was both inadequate and slow. Engines like Unity and Unreal actually use ECS too. Just like FP, the realisation is that data is better off decoupled from code. A lot of entreprise devs still fail to see this and are just following recipes dubbed as "good practices" but are actually bandaid.
Cx uses two-way data binding and context to provide powerful and developer friendly form validation + you get all fields out of the box. https://cxjs.io/v/master/docs/widgets/validation-groups https://cxjs.io/v/master/docs/examples/form/validation-options https://cxjs.io/examples#forms
React has everything to do with killing OOP in the web. These are functional components: const Say = ({ what }) =&gt; &lt;span&gt;{what}&lt;/span&gt; const Hi = () =&gt; &lt;Say what="hi" /&gt; Functions taking data, returning functions that describe layout, masked in a simple mark-up dsl. Invoked like functions. No one said it's a new concept, but the way React presented it was revolutionary (mixing traditional OOP with pure functions and uni-directional data flow).
Here is an implementation of the example: https://cxjs.io/fiddle/?f=JbL2XUCG
Downvoted cause some people are either unaware of how Vue is working underneath or they don't like facts. Link #1 https://vuejs.org/v2/guide/installation.html Describes Vues functional underpinnings (to the point that it can take in JSX). *All* templates are parsed to functions internally. There's even a penalty if templates are used in a vanilla setup which adds a runtime parser. Single file components parse to reactive at compile-time. Link #2 https://vuejs.org/v2/api/ 60 A4 pages of API documentation. This is the bulk that template syntax and observables introduce. If you strip that away what remains is React. In contrast Reacts documentation https://facebook.github.io/react/docs/ Starts with a hello world, explains what "render" is. Explains class and JSX semantics, that's it. May have some advanced stuff that's usually for library authors, like context or proptypes.
you're wrong. I've cumulatively spent 30 seconds on this conversation and the books you've written won't change my mind. ASI makes the following return undefined in your method, which is incorrect. return { 'thing': 'whatever' }; return { 'thing': 'whatever' };
DSL way is kinda new, everything else is an old story if you've ever stopped out of JS world. OOP is not going anywhere.
This is a shortcut syntax, no one is forcing you to use that.
If you don't use it you don't have dynamic components. If you just want to present static components you can can just as well leave Angular and use web components + polyfill as is. 
FB hasn't taken any credit for it, they have all said that functional has been in evolution for over a decade now. But it has reached a point of maturity where it defines declarative UIs with ease, something traditional OOP MVC struggles with. Which is exactly why you see *all* new libs, including Vue, which you seem to use, base on it. It's also the reason apps are breaking out of the browser because we're venturing into universal codebases thanks to functional. 
Sorry, can't think of any tutorial. There is [a chapter](http://www.deeplearningbook.org/contents/rnn.html) on RNNs in [the Deep Learning book](http://www.deeplearningbook.org/), not sure if it can be considered simple or detailed enough to write your own implementation. There is also [a lecture on RNNs](https://www.youtube.com/watch?v=R1rXkuJ5w20&amp;list=PLLvH2FwAQhnpj1WEB-jHmPuUeQ8mX-XXG&amp;index=10) from cs231n course. A [lecture from cs224d](https://www.youtube.com/watch?v=nwcJuGuG-0s&amp;index=7&amp;list=PLcGUo322oqu9n4i0X3cRJgKyVy7OkDdoi) and [notes for it](http://cs224d.stanford.edu/syllabus.html).
Lol ook.
The rc fiasco? Who cares? The framework has been solid since actual release. You know, the version that actually matters? Heck, I think calling it a fiasco isnt even right. The old router sucked. Rather than spend forever trying to patch in the features developers were asking for and making a mess of it they wrote an entirely new one that actually handles the stuff people were asking for. Again, before release. I'd rather use a framework that the authors made necessary changes to than be stuck with bad original decisions forever that can have far reaching consequences.
You are better off using the DOM methods for this instead of querySelector because of the performance difference and because your selectors are sooo primitive that they map directly to values that can be passed into the DOM methods. var li = document.getElementsByTagName("li"); Save querySelectors for when you need something with multiple steps or when you need to get something by attribute.
WPF and XAML was close to torture. We're a traditional .net shop as well, made huge apps in it. Currently transferring them into the web using modern principles. If you think XAMLs OO 2 way binding MVVM architecture was proper you've missed what's going on. Even Telerik now acknowledges that it has undervalued FP. 
[removed]
Looks good
JavaScript?
In the introduction I say the challenge is in Python but it should be useful to any coder, and there's a section on javascript later :). I see javascript devs using console.log statements too often to debug their code, and the main goal of the article is to show that a "real" debugger is better
This isn't a new library. It's been around for a while. Took them a bit to get to version 4. Worth checking out though. 
Oh no eBay you can't fool me, your site is a disaster and you want me to use your library??,
Quite faster than React! 
I mean, for small quick little components, this is really nice. You do have a lot of other options in that category though. Vue, Mithril, Inferno, heck even straight jquery. Nonetheless, it's always good to have options. 👍
Are there any examples of it in use? This is over my head but seeing new engines at work it amazing. 
Where are some examples of atomics to help deal with locking on shared buffers?
Right, I'll admit it is looking much better. I'm on mobile as of now and have not seen this. Is the same to be said for the desktop version of the site? What I was referring to was older site/desktop site. I always remember the URLs being very confusing and long, design being very 90s-esque.
My iPhone sucks ;( I'll give it a shot on the MacBook. 
Because I'm not smart, I can't tell whether or not you're joking. Is this worth looking at?
Going for cheap namecalling now, nice. That's still gibberish along with ngIf, ngRepeat and all the other code-in-HTML stuff. What has any of it to do with standards. 
Hah! But you understand why that doesn't work, right?
Cool can't wait, that's truly the best way to do it, mobile/desktop all with the same code! Blow my mind!
I'd want to see marko added to the existing UI benchmarks. So far looking at the code it would seem their their benchmarks are quite simple and it may not be as peachy in the real world.
This is cool. I wouldn't recommend using it until there is a license though. The owner of the repo has not explicitly given permission to use this code.
Returns `t` :P
Hah! I actually would like to know why you're arguing about it. Why do you have such strong feelings about line breaks?
i don't carry on.. maybe you can start leaving out the var/let statement because it looks better too
Hi /u/stefmonge, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `serverless.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [serverless.com](/search?q=%28and+site%3A%27serverless.com%27+author%3A%27stefmonge%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|14|100%
I do not understand why people are approaching the marko prejudices. Before Marko, I tried all sorts of template engines and I always saw the weakest ring template engine in the node.js stack. When I met Marko, this problem went away and now I can make applications and web sites with the same gentle power both on the server side and on the client side. I definitely recommend Marko because the Marko is equal to power, flexibility and performance! Marko is also a very fast developing library. I have been using this library since version 2, and now version 4 is available. The development team works for the needs of users and is always trying to help you when you need them.
I believe marko is based in morphodom, which diffs the DOM directly. This is cool, because it's one abstraction less (although you still need the library and its dependencies), but unfortunately, diffing against the real DOM has quite the overhead cost in operations 30%~40%. For example, compare choo, also based in morphodom against any other using a vdom engine: * https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html The evidence is overwhelming: Inferno, Preact, Mithril, etc.
It's true that linters are very efficient to catch those kinds of errors. It's also true that I did not think about linters when I wrote this example (I prototyped it directly in the browser). Resources to linters for each language are given at the end of the article. Linters are also referenced as a way to debug your code (maybe that reference should have been higher). Thanks for taking the time to give feedback ;). It gave me an idea for another article
Hah! Okay, here's a question for you, though: even if English isn't your first language (it's mine but I don't have any great love for it), you clearly don't care much for its rules, so why the double standard? Code is only ever going to be read by other coders (and machines, of course), but words published here could be read by anyone (they're not going to be, but still). Even just dropping the comma after the second word in your last comment really changes its meaning. I am (seriously) not being critical of your writing, I really don't care how people write comments on the internet. It's just that you seem so particular about how things are written in a programming language but not this, er, human one. And, again, I have no great love for English. I wish my first language was something more beautiful like French or Italian or something. Instead, I'm stuck with stupid, clunky English. And, ugh, I submit to all of its damn rules, I guess.
I think there is one more interesting kind of tools for debugging. I mean tracers, i.e. tools that record all call function calls and show this in logs. In some languages there are tracers in standard library (for example in Python: https://docs.python.org/2/library/trace.html ). I've not seen anything like this in JS, so I've started making my own library: https://www.npmjs.com/package/san-escobar (for now it's just proof of concept, there are many things to improve in this).
I downloaded a html file that uses dropotron.js, skell.js they depend on jquery how can load those i was trying require.js to load them but got confused trying the found webpack and browserify but dont wanna download nodejs so i guess my question is how to load and use tgem with requirejs or do you advise using nodejs and webpack
Not bad! I'll advertise it
That's actually not true and the benchmark is not accurate. [morphdom supports diffing with both a real DOM and a virtual DOM](https://github.com/patrick-steele-idem/morphdom/blob/master/docs/virtual-dom.md). Diffing with the real DOM is much slower, but Marko is using morphdom to diff with a virtual DOM and it is extremely fast. I think the numbers speak for themselves: http://markojs.com/#benchmarks
The DOM (document object model) is a set of specifications for object interfaces that correspond to document elements. For each possible element that can appear in a document, there's a corresponding object type. For example the &lt;img&gt; element corresponds to the type [`HTMLImageElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement), and the &lt;p&gt; element corresponds to the type [`HTMLParagraphElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLParagraphElement), and so on. These objects are created when the browser parses the markup, and they exist regardless of whether you select them. You can refer to each object type's documentation to see what properties and methods it supports. Keep in mind there's quite an inheritance hierarchy. `HTMLImageElement` inherits from `HTMLElement` which inherits from `Element` which inherits from `Node` which inherits from `EventTarget` which inherits from `Object`. MDN documents all of these. For example, for accessing attributes of an element, look at the [`Element` interface](https://developer.mozilla.org/en-US/docs/Web/API/Element), which includes the `attributes` property, and methods like `getAttribute()`, `hasAttribute()`, and `setAttribute()`. 
No it doesn't. `t` is last in the chain. Also I just tested it in the dev tools console in chrome, and it does indeed return `t` (or rather the value of `t`).
Teams are free to choose, but certain requirements must be met. The page needs to perform well since we are targeting users with all different types of devices and different connection speeds. Depending on the page, server-side rendering may or may not be required. Localization must be supported. Etc. Teams have experimented with other technologies and even used React for certain internal admin tools so we are definitely not ignoring existing technologies. In fact, a lot of the features in Marko were heavily inspired by features in other UI libraries. Single file UI components were heavily inspired by Riot and Vue. The functional approach to UI came from React. In the end, React (including React alternatives) and Marko offer a very similar paradigm for building webapps, but Marko performs much better (especially on the server, but also in the browser) and I'm really happy with the syntax and the simplicity of Marko UI components. Marko is also much smaller than React and Vue: Marko: 31,894 bytes minified ( 11,647 bytes gzipped) React: 42,802 bytes minified (132,943 bytes gzipped) Vue: 51,557 bytes minified ( 18,295 bytes gzipped)
I understand that but just wanted to avoid all those script tags
will you be adding marko to krausest/js-framework-benchmark ?
&gt; Marko is using morphdom to diff with a virtual DOM and it is extremely fast Ah, that makes total sense. &gt; the benchmark is not accurate What's not accurate? I can reproduce the results (actually worse) on my local machine.
I'm not opposed to that, but it's been pretty low on my priority list.
Isn't the js number spec something weird, not exactly a doublep float?
I don't believe this is the case. If we change his code to be Math.floor(Math.random() * Math.random() * Number.MAX_SAFE_INTEGER) then it outputs both even and odd numbers. I think this means the issue isn't with Javascript and its floating points, but more likely that V8 isn't giving us as many random bits as we expect or as firefox does.
This looks pretty cool, nice work.
&gt; imo if named SAFE it should works safe If your integer is &lt;= MAX_SAFE_INTEGER, you know that it can be safely stored as a number. If it's larger, the value cannot be trusted to be accurate.
on FF results are the same as on Chrome, ~55 and ~74 for examples above
Please for the love of god tell them to implement a simple feature that allows buyers to mark purchased item as received. Keeping track of which package has arrived is a real pain in the ass when multiple orders are in shipping.
Could still make sense. I have never seen a number over 54 for the Math.random() one on Chrome, so if you are seeing 55 on FF, maybe its just one extra bit. If the biggest number we see from Chrome is 54 and the biggest from FF is 55, and we subtract 2 due to the "0." that starts all those strings, that would mean 52 bits for Chrome and 53 for FF. Since Number.MAX_SAFE_INTEGER is 2^53-1, that extra bit could be the key. 
I was wrong, I guess they're only beginning to use it now. Check out eBays mobile site on the general pages. I was impressed!
You are correct. If you are doing anything that needs to be secure you should use crypto.getRandomValues. For example: var array = new Uint32Array(10); crypto.getRandomValues(array); will generate you 10 random 32bit Uints Check out http://stackoverflow.com/questions/5651789/is-math-random-cryptographically-secure if you are interested in some more info. 
You're using a strict equality check, which means you're checking for an integer of 1, however since you're slicing the "numbers" out of a string they're also strings. Try using a `parseInt()` and that should solve your issue. E.g. `if (bits[i] == 1)`
What's wrong with passing a property through several components?
In all browsers, elements with IDs get turned into globally scoped variables automatically for historical reasons.
Way beyond.
This isn't really currying, so much as partial function application. Unless I misunderstood what the author is doing. 
That doesn't surprise me. Read up on [how numbers are stored in memory](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) in Javascript. Notice how the significand 'technically' has 53 bits but only actually stores 52 of them since the top bit is always assumed to be 1. In other words. Math.random() is going to give you 52 random bits, but Number.MAX_SAFE_INTEGER is 53 bits long, so you're going to get one bit that isn't randomized. It seems that the nonrandom bit ends up at the lower end, with a value of 1.
Write a lot of code. Read a lot of other people's code. Focus on writing/reading a lot of different types of applications. Read advanced JS books. Read and understand the ECMA Script language specification.
I believe you might violate separations of concerns if you're just passing props to a component low in your component tree. Usually this would happen when your UX design sucks and you've got a component hidden inside some unrelated one. In this case you should either change your design or subscribe to the store in that child component itself.
I just read that and it actually blew my mind. This honestly changes a lot. I am curious how this works does it support obfuscation and minification of css class names. Are there tools that you can use with this code to refactor. Finally does this allow css to be added into webpacks tree-shaking? 
Eh for me I like to think of a component as a pure function, whatever it's children. So if there is a property that affects the way a child node renders, then it affects the way the node in question renders and I want to know about it!
I'm pretty sure you could just try `if(bits[i] === '1') count++` instead.
What's t?
doesn't work :( Time: 328ms Passed: 1 Failed: 4 Test Results: ✔ Test Passed: Value == 0 ✘ Expected: 1, instead got: 0 ✘ Expected: 3, instead got: 0 ✘ Expected: 2, instead got: 0 ✘ Expected: 2, instead got: 0
Guess all I have left is to read the standard front to back.
My only thoughts are that safari on iOS tries to do some weird stuff where it delays certain data structures until after the page is loaded. Does your code work if you delay it until DOMContentLoaded? 
You're `push`ing the result of `split()` -- which is an array -- into your array called `bits`. So bits will be `[ [ "0", "1", "0", "1"....] ]`, a single array within an array. Instead of `bits.push(...split...)` you just want `bits = ...split...`.
that's a shame. Lot of people are looking at that benchmark and choosing a framework based on that. If the performance is really that good, it would be a wasted opportunity to not include marko there.
You don't. It's turtles all the way down. Well, you can make it look more like synchronous code by using async/await.
&gt; Mastery isn't always about knowing everything, it's often about knowing what's relevant to know and knowing how to find the answers to everything else. This
You had me worried there for a second, but I verified that `NODE_ENV` is being set to `'production'`: [isomorphic-ui-benchmarks/init.js](https://github.com/marko-js/isomorphic-ui-benchmarks/blob/f5f3da9ab885ce08175cd3a1432918d953dbb4f4/init.js#L3-L5) `init.js` is called as the first thing during bundling: [isomorphic-ui-benchmarks/scripts/bundle.js](https://github.com/marko-js/isomorphic-ui-benchmarks/blob/f5f3da9ab885ce08175cd3a1432918d953dbb4f4/scripts/bundle.js#L1) I add some debug code to verify that `process.env.NODE_ENV==='production'` when the rollup config is loaded for `react` (and others) and that check passed. If I am missing anything please let me know, but it appears to be set correctly.
I think your definition of curry might be a little narrow. &gt; In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, **each with a single argument**. Currying is related to, but not the same as, partial application. Source: https://en.wikipedia.org/wiki/Currying (emphasis mine) A curried function does not have to "return a callable for all of the arguments you provide, up to the arity of the original function". My `add` example is the classic one used in lots of "intro to currying" material. The same material that also demonstrates the "up to the arity" version of currying that you do here, but doesn't assert that it's the only way to curry.
It would be like below. Name,Phone,Email,Timezone Bob,513-468-1573,bob@yahoo.com,EST Joe,517-861-2487,joe@msn.com,MST Sally,759-873-1874,sally@me.com,PST i.e. each line is a record (with different fields). First record can be the field header names, which is an optional record.
You think you do, but you don't.
Maybe they use pooling to mitigate GC? If they're using WebGL they probably use a depth buffer - having built-in object sorting would still be useful since it's needed for any translucent objects
Because they can be useful.
And looking to the Partial Application wikipedia page: &gt; Intuitively, partial function application says "if you fix the first arguments of the function, you get a function of the remaining arguments". For example, if function div stands for the division operation x / y, then div with the parameter x fixed at 1 (i.e. div 1) is another function: the same as the function inv that returns the multiplicative inverse of its argument, defined by inv(y) = 1 / y. That's exactly what the add example is doing. Almost to the letter, with the exception that the second invocation always calls the result. See the partial application section of the same page that you referenced: https://en.wikipedia.org/wiki/Currying#Partial_application There's a note at the end of the section: &gt; This example is somewhat flawed, in that currying, while similar to partial function application, is not the same (see below). Following the link provides this explanation, which spells it out in no uncertain terms: &gt; One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two. That whole section gives a very good explanation of the differences between currying and partial application, and the usefulness of partial application.
&gt; Some UIs will make use of SVG and others will not. Awesome svg support: https://github.com/marko-js/marko-vdom/blob/67fbc13680a998c9ff0ce5b03d06394fd2b6e68c/src/HTMLElement.js#L101-L103 &gt; We intentionally created more real-world benchmarks and you can take a look at the code in the main repo: https://github.com/marko-js/isomorphic-ui-benchmarks Real-world benchmark that doesn't flush dom ops before updates, nice job :)
You are looking at the code in the wrong place. The marko VDOM implementation was merged into the marko repo: https://github.com/marko-js/marko/blob/master/runtime/vdom/VElement.js And, yes, `xlink:href` is the only namespaced SVG attribute that we needed to support. &gt; Real-world benchmark that doesn't flush dom ops before updates, nice job :) If you are going to suggest that Marko is not flushing DOM updates then you should be prepared to back that up. The entirety of all DOM updates are absolutely being flushed for every iteration of the benchmark: [isomorphic-ui-benchmarks/benchmarks/color-picker/marko/client.js](https://github.com/marko-js/isomorphic-ui-benchmarks/blob/f5f3da9ab885ce08175cd3a1432918d953dbb4f4/benchmarks/color-picker/marko/client.js#L14) `component.update()` causes all changes to be flushes to the DOM: http://markojs.com/docs/components/#codeupdatecode Feel free to add debug breakpoints if you are skeptical, but we have no intention to create a misleading benchmark.
Well touché then good sir. Do you know how much faster this is compared to other frameworks? Inferno is supposed to be the benchmark to hit. 
I think it's interesting. It seems like you do great work and it's nice to see how a successful front-end developer spends their time during the work day.
&gt;Why does react get so much larger when gzipped? http://stackoverflow.com/questions/19807946/why-is-reacts-filesize-so-big-given-its-small-api I believe this should answer that question well.
I appreciate the feedback - glad it can give some value.
Absolutely! I'd kill for more post like this. Very informational. 
Any good viewers out there that show all the bits? Like text nodes inside buttons and such?
I'll keep it up! Maybe this can encourage other people to do similar type blogs.
Unfortunately, the only thing someone in your shoes can do is gain more experience. When I started out in web dev (2005 era) all of this stuff was kinda mysterious. Granted all the frameworks weren't around back then but there was still a fair bit of opaque complexity. Eventually, if you keep at it, things start to become clear. Something like jQuery UI is meant to save you time so you don't have to reinvent the wheel every time you want to use a common GUI convention. The consequence though is that you are rail roaded a bit on how to implement said convention. Pros and Cons. If you want complete control over the interface, then you are on the hook to develop the interface yourself, which at your stage of the game, isn't a bad thing at all. In fact I would encourage it because that's how you develop deep knowledge of the fundamentals. It's only after you have hacked away at making interfaces on your own for a while that you start to see the benefits of using all the fancy new frameworks. The advent of the frameworks came along because developers were having a hard time maintaining really large code bases using only traditional web dev methods. It just wasn't scaling to their needs. Just a couple things about the points you were making: You mention AJAX being "slow" but that is really dependent on the back end that is powering the AJAX endpoint. Google's search suggestions are AJAX powered as well and they are acceptably fast. If an AJAX endpoint does a lot of processing before returning a result, than it may be unnecessarily slow due to performance issues. As for the graceful degradation of large scale apps that use something like react, it's true that they don't degrade gracefully. The reason for that is there is an unwritten expectation that in order to use the web app, you absolutely need a capable browser, no exceptions. This is what I have found anyway. The reason being is that developers/architects feel that the amount of effort required to accommodate older browsers just isn't worth the effort when you compare the amount of work involved in actually building the app itself. Inconvenient for those who don't have access to a modern browser, for sure, and I remember a time when developing a site that didn't accommodate at least 5 browser generations previous was sacrilege, but things move so much faster now, it's just not feasible for large scale apps. As for the author's message from the article, I think the point he is making is that complexity isn't bad, it's just that everyone is going to the extreme end of the complexity scale when building *anything* these days, and I agree that that is frustrating. People need to use the right tool for the right job. If I was building a brochure style site for a local business that isn't going to see a ton of maintenance, then I'm definitely not going anywhere near something like react or angular. It's overkill. That's a skill in itself though, recognizing just how complex a project needs to be so that it can be sanely maintained in the long run. It takes time to develop that skill. 
I was at this meetup! Loved it
There are a lot of functions called hundreds of times per frame which return anonymous objects or arrays; after commenting I also noticed a large number of function calls where the only argument is an anonymous object. Still, their usage seems to be short lived enough that all three big browsers seem to have no trouble eliminating them. It's not webgl; it's a JavaScript software renderer drawing to a 2d canvas context.
[How about 30 of them?](https://javascript30.com/)
As it stands, you add links yourself via the extensions pop up. I would love to write a nice long list of fake news websites, but I don't doubt it would be rather contentious 
That makes sense. So it's really just an extension that blocks a list of user-defined domains; it doesn't, strictly speaking, need to be used for news at all (be it fake or otherwise)? 
You return the `fetch` - this will resolve to a promise and you can get the value out. If you get rid of that 2nd `then` block and instead just `return` the fetch, from the calling function, you can get at it like so -- myFetchFn() .then(body =&gt; { console.log('you have body!', body) } This is the nature of async code... you can only access the resolved value from either a promise; or a callback, if using that style. EDIT -- Aside -- you can always assign the result to a variable outside the scope of the fetch... but it won't be set until after the promise resolves.... i.e., var scopedBody = null fetch('./whatever') .then(res =&gt; res.json()) .then(body =&gt; scopedBody = body) .then(() =&gt; { /*use scopedBody?*/ }) This can be useful if you want to pull out the result of the fetch and do something with it later - and the promise chain has its own resolutions that might eff with everything else.... i.e., each promise can only return one value.
I would be kind of interested in this, but it enforces [standard.js](http://standardjs.com/) linting - which is not at all standard. For example it will strip all semicolons from any code you run through it, and there doesn't seem to be any way to turn that 'feature' off. Given that any arguments with regards to how code should be linted have nothing to do with modernising a code base, this seems very unnecessary. 
I would recommend [Nature, in Code: Biology in JavaScript](https://www.edx.org/course/nature-code-biology-javascript-epflx-nic1-0x) (free edX course from the Swiss Federal Institute of Technology in Lausanne) instead of a web project. It has a nice different angle and I think it's better, you learn some *really* cool (and stille easy enough) modeling of natural processes in addition to basic Javascript skills. I enjoyed the course immensely, and I sure didn't take it for the Javascript but for the biology modeling. A skilled JS programmer would do a few things differently, but over 90% of what is taught is very reasonable, and when looking at the context and how the code there are no really bad parts (no modularization and "higher level" concepts that help you organize large projects, but everything done in the course is done within the context of a single file). If you insist on web development, make GUIs for the models so that a user can fiddle with the parameters and see the result (some results are only logged to the console and there is no real output, others use a single graph).
I make the best judgments! The best! Everybody says how fine my judgements are...
What ui framework is this, custom built?
yea it's custom.
You could also use async/await with the latest node (7.4) with KoaJS. It will let you use async code as if it was sync, kind of. https://blog.risingstack.com/async-await-node-js-7-nightly/
[removed]
This is also the approach I use. I disagree that this should not be used as some suggested in other comments. The point of modules is that they are an abstraction and the way import/export works now either forces us to use this workaround, know pretty much the complete code organization of a module on a higher level or screw with code organization of the module (more definitions per file, etc, ..)
Apollo client uses redux. 
It looks amazing, great job! Are there any plans to open-source the components?
We've been using Marko v3 in production for quite some time, and it works great. I'm excited to switch to Marko v4.
Sweet, thanks! 
Cool, that seems different ill check it out. 
This really helped me learn more about event handling and bubbling. I used your advice targeting the body and it works! Thanks so much
Every single website does use Javascript today - those that dont are just either extremely old or some kind of a concept like [this site](http://motherfuckingwebsite.com). To see how websites look without Javascript you can install the NoScript extension to your Chrome or Firefox. This extension removes all Javascript from sites so you can see how most sites don't even make sense or function at all without Javscript. &gt; For any of you who know more than one language - is it hard to transition to learn a new one? The hardest part was learning the first one, and trying to learn 2 firsts at the same time just makes things exponentially harder and confusing. From my experience it is best to learn one language really well, and then later you can learn others quickly.
Softskills.
COBOL programmers have huge salaries because they are so rare and a lot of critical legacy code in the banking systems of the world is COBOL code. It's a tough and risky specialization though and requires more than just learning the language - also there is absolutely ZERO overlap with your HTML/CSS abilities. 
do you have a degree?
Yup, very good point about the likely asynchronous nature of the external script. Also, good idea about the DOMNodeInserted mutation event. I so rarely use the DOM Api directly anymore. Although it looks like that is now deprecated and being replaced with Mutation Observers. https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver Didn't realize that until looking it up after reading your comment. So thanks for that. 
Cool lib, but from someone who has degrees in both music and CS, this seems a very convoluted way of composing music. It doesn't really show what's possible in computer assisted composition. It would have been a bit more interesting if he'd done some examples of adaptive or generative music where the algorithms do a bit of the composing. For instance, pull down a twitter stream, process it through some logic, then pipe in real time through OSC to ableton without writing to a file first.
"An awake neighborhood is a safe neighborhood."
 class Game { objectArray; constructor() { this.objectArray = []; } }
There's just so much ridiculous "functional everywhere" group think in this comment that I'm not going to go through and reply to each of your individual points. I'm just going to leave at a difference of opinions.
In the constructor: this.foo = []; Elsewhere, access it via `this.foo`.
`var` inside a method makes a local variable that is specific to the scope of that method call. It is not defined in any persistent location that is accessible elsewhere in the class (unless you use something like closures to capture the variable, but that is not the case here). It lasts only as long as the function call itself, and any additional call to that function makes a new instance of that variable. Presumably, you're only ever calling `init` once, as a static initializer for your Game. In that case you can simply define the variable to `this` which represents the Game class itself. This would make a static property of Game which you could access from other static methods through `this` or instance methods through `Game` (not `this` since in instance methods `this` represents an instance not `Game` itself). class Game { static init() { console.log("Game is being initialised"); var player = new Player(0, 0, "Player"); this.objectArray = []; // &lt;- this, not var this.objectArray.push(player); initialised = true; } static update() { console.log(this.objectArray); // also using this } } Game.init(); //-&gt; "Game is being initialised" Game.update(); //-&gt; [Player]
Sketch is a lot of fun.... but has a bit of a learning curve. I've only learned the basics, but you can find lots of resources on youtube. It's great that you wanna learn the whole flow from design to launch - Even if something you do fails, it's a great experience. Keep learning and trying, and enjoy the process!
I heard the music as soon as I saw this
How do you rate Phabricator? Any opinion vs team foundation server?
Field declarations only work if you're using something like TypeScript. In TypeScript you can combine the declaration and initialization into one line. Behind the scenes, this initialization is essentially moved into the constructor. class Game { objectArray = []; }
Honestly seeing this just made me realise I don't have a fucking clue what I'm doing. I'm the only designer for a medium sized logistics and transportation company. My site looks like shit (compared to modern sites), I struggle to implement new features my boss wants. I literally don't know *how* to do it and have to research the shit out of it. Might as well just stop this career. No way I can compete with this. I don't even know or wouldn't know where to begin for most of the things you did. 
&gt; Does this make you a senior? it's hard to tell. senior engineers are often defined by the things they do that *aren't* coding. we'd have to see how OP: delegates tasks, handles themselves in meetings, unblocks people, handles emergencies, designs features and products, architects systems, communicates with engineers, PMs, and designers, works project management, mentors others, takes advice, admits mistakes, communicates outwardly, feels about the domain they work in and any other number of things to get that sense. &gt; I do know the front stack tools they you use, but I'm still having trouble finding employment. Might be because I'm young and only have 6 months of experience, but dammit I know I can do it. keep at it! if you know you can do it, then you'll do it. all you need is your foot in your door for your first job! once you find someone to take a chance on you, you'll be able to get other people to trust that you can work well. keep your chin up and don't give up!
Something like `/^[A-Za-z_0-9\-]{3,20}$/` should do it. May be better ways, I'm not a regex pro, but that seems to pass my 'seems ok, but should test' sniff.
Not every comment has to praise something. I also have a music degree and /u/tencircles makes a reasonable point. 
Hang?
I'm sure he doesn't tell you about the disappointing or difficult times in his career. Keep your head up :)
1.5 years is not a long time. If it was an engineering degree you wouldn't even be half way through yet
As a side note, if you're using ES6 never use `var`.
Don't use `static` methods. Store your variable under `this` and create the game a.la `const myGame = new Game()` 
`.checkTextExists("div:nth-of-type(2) &gt; div &gt; div &gt; div &gt; form &gt; div:nth-of-type(2) &gt; div:nth-of-type(4) &gt; div:nth-of-type(2) &gt; button &gt; div &gt; div", "Send data message")` Do you find that when you change the structure of your page, these kinds of tests become a nightmare to update?
You're intuition is right, that's not really scaleable. You might enjoy reading about the Object.assign function. http://jsbin.com/pisatitena/edit?js,console
Thanks but i am a bit confused.
While I appreciate that you took the time to respond, I'm not really sure what your point is? Furthermore, I'm not entirely sure I agree with you. The first 1.5 years of an engineering degree would involve a lot of pre-requisites, electives, and college life in general, whereas i've been staring at code 12 hours a day 7 days a week. I think I am beyond a 4 year degree as far as hours put in coding, but probably behind quite a bit in certain fundamental knowledge. 
Last line of displayResults you need to use $("results").innerHTML = textDisplay:
I wouldn't use static, or use an init function. The whole point of the constructor is to set defaults when a class is created, so your init should be in the constructor. static is used when you want to use the function without creating a new class class Game { constructor() { console.log("Game is being initialized"); this.player = new Player(0, 0, "Player"); this.objectArray = [this.player]; this.initialized = true; } update() { /*code here*/ } } let game = new Game(); 
This is probably the most useless article I have seen? At every step it is basically go to this website and read the docs...
Business Intelligence
I must ask... Do you ever get bored? Or feel unchallenged? Do you see yourself being a developer in the future too or have you thought about merging with another field? Like maybe starting a business that requires your skill? 
&gt;Do I have a wrong perception of the movement, and where the market is going toward? Honestly, look into what more suits you and just don't forget to learn and try different approaches and methods. OOP - good Functional - good React - good Vue - good. Don't listen to fanatics. Everyone would say one thing is more popular than another, if he's/she's not open minded and not looking into the future. Someone would say functional is dead by definition. Some will say this about OOP. There is no total truth.
I've run into this before. I believe three.js uses an AJAX call to load in some of the images, and AJAX won't work on some browsers if you load in from the file. If you've got a web hosting service, just run it from there, or if you want to run from a local machine, you'll need a web server (XAMPP is pretty standard, or if you have Python installed you can just run a quick server with python -m http.server from the command line.) 
Glad you like it! Most of the credit goes to our designer Kevin who gave me great comps. I'll have to discuss open sourcing with everyone at work but it's a possibility. 
I always wanted to create an app to let me schema some data in JSON and then get a whole heap of dummy data for use in early development. 
I definitely agree with that each approach matches a certain usage and we need to look at what need to do and then evaluate which will be more suitable. You're right, I have heard people ranting against OOP and in favor of functional programming, and have heard the opposite too. So it's never a good idea to say a blanket statement about an approach. I just wanted to get a sense of what others think or do in their daily work. Thanks for the reply.
I totally agree. I myself come from a Java background and so I've always been in favor of OOP and pushed toward it even after I moved to Javascript, and I do see objects defined and so on (less inheritance maybe, but other concepts definitely used in different applications).
[removed]
Data Warehousing &gt; Business Intelligence Software &gt; Open Source Business Intelligence http://www.1keydata.com/datawarehousing/open-source-business-intelligence.html
Here, didn't make it works .Wanted to target element with Object.assign but not working. https://jsfiddle.net/e08e525t/ 
Thanks.
&gt; 1- Is OOP bad for an application with complex UI? No. &gt; 2- Is OOP just not useful for Javascript because we all know various things we can get wrong while working with JS? No. &gt; 3- Do I have a wrong perception of the movement, and where the market is going toward? Perhaps. Look... regardless of language, platform, framework, pattern, or technique code can be written horribly or beautifully. Kids today don't know the hell we have been through in this industry and so we are rehashing lessons previously learned. That's all well and good, and to be honest quite healthy. However, any time someone asks is X bad or is Y good the answer is almost always... "it depends". The only fundamental truth is that bad coders are everywhere. Focus instead on producing results. Only after you have succeeded in delivering something does it make sense to look back and ask, "what could I have done better?". Learn from those mistakes and move on to the next project. I have seen way too many programmers argue about the smallest of things when they have yet to produce anything of significance.
https://codepen.io/snuggles08/pen/qrNzvd I fixed it up for you! Read the comments to see my changes
&gt; the unique selector for an element I mean... why not just use an ID?
A centralized state has nothing to do with OOP. State management has been a hot topic for a really, really long time. I remember reading debates about state management in the 2000s and even before. I don't know why this isn't talked about more, but having a centralized state like Redux is mostly done because quite frankly it makes things easier. Why bother with complex data access when you can just throw all the shit into one huge global store from anywhere in the application. Same with NoSQL databases. Yes there are times when a flat storage solution is best, but it's not "better" than SQL by any means. It's just a different solution that works better in a few scenarios and worse in many others.
Where did I say that "every comment has to praise something"? For the record, here's an example of constructive criticism versus the above comment. - **Constructive criticism**: I think this painting of your dog would look more realistic if the sky was a bit lighter and less saturated. - **Not constructive criticism**: This is a convoluted way of painting dogs. It doesn't really show what's possible with paint-assisted dog imitation. It would have been a bit more interesting if they'd done some examples of attaching a GPS device to their dog and painting with GPS trails on a map where the dogs do a bit of the composing. I'm not saying that attaching a GPS device to your dog and painting with GPS trails on a map wouldn't be cool (in the same way that adaptive or generative music would be cool), but the first 2.5 sentences of the above comment were smarmy and unwarranted. If I could recommend an alternative comment: &gt; I'd love to see some examples of adaptive or generative music where the algorithms do a bit of the composing. For instance, it would be cool to see the the code pull down a twitter stream, process it through some logic, then pipe in real time through OSC to ableton without writing to a file first.
Have you checked any of these? - Airbnb superset https://github.com/airbnb/superset - Metabase https://github.com/metabase/metabase - Re:dash https://github.com/getredash/redash https://redash.io/ 
OOP is inferior paradigm. Many will tell you its subjective, but its not. Yet you can ship quality apps with it, its just way more difficult than lets say typed fp (which has initial cost, but then is breeze)
Google has a great library called "PageLoader" which makes testing things like this a lot easier. It's only for Dart though. Maybe there's a JS equivalent
OOP isn't about inheritance, people start explaining inheritance because it's easy to explain how "Cat extends Animal" but none of the design patterns use inheritance if you notice. It's irrelevant. Also, basically all of the big UI frameworks on the market are OOP. Windows, Mac OS, iOS, Android and browsers. If that's not enough to prove OOP, I don't know what would be :D
Well said. Looking back and always improving your code - whether it was written in an OOP style or not. 
I hate to sound whiny, but the website layout/color makes it very hard to read. Perhaps a css upgrade is in order?
First thing is that i don't like to scatter id's around too much - starts getting messy (I almost never use IDs). But the main reason that ID's won't work is due to my code being highly componentized. for example, if i added an id on a dropdown button, it may be in 5 other dropdowns as well, and of course you can't have 5 id's that are the same. If I used a unique class, which will work programmatically, then in the test I have to specify which of the 5 elements matching the class selector is the one I'm targeting, hence the need to have a smart algorithm to generate the most beautiful unique selector possible which will aid in debugging and adaptability (which means a test not breaking too easily when changing it's context or when the page markup changes dramatically). Also trying to get the recorder to work even if you can't touch the code.
I don't know why you were downvoted like this is StackOverflow. Not everyone knows what BI stands for, and many companies still just call BI "reporting". I upvoted your comment, because it's really easy for us to get lost in jargon and assume everyone knows the same terms as everyone else.
Also, when finished on a project, start a clock on how much cost is given to maintenance of the project and all projects - very quickly the cost of "knowing" multiple frameworks adds to a BAU team. Look at the pain/ease new developers have when joining. It takes a strong tech lead to resist jumping to a new framework because its hyped - most frameworks are "good enough" to resist every new one.
&gt; (I'm learning Elixir ATM) Have you checked this out? https://www.futurelearn.com/courses/functional-programming-erlang Pretty good intro to functional programming.
Could you provide the arguments for your answers please? And also examples of cases where "it depends"? Thank you.
&gt;there wouldn't ever have been a GUI This statement is ludicrous and unprovable.
I wonder if it's true that with FP we could build even more. I've been using Clojure and ClojureScript lately and have been more productive than ever.
Here's some of what Rich Hickey, the creator of Clojure and Datomic, has to say about it: https://youtu.be/-6BsiVyC1kM
&gt; the main reason that ID's won't work is due to my code being highly componentized. for example, if i added an id on a dropdown button, it may be in 5 other dropdowns as well, and of course you can't have 5 id's that are the same. I mean, the ID could be on the component, and the rest of the selector based on that (and hopefully there would be some good classes so you can avoid trying to identify things based on their exact location in the DOM, as is being done here). &gt; hence the need to have a smart algorithm to generate the most beautiful unique selector possible In my experience this sort of thing is ridiculously brittle, and I wouldn't call this a beautiful selector by a long shot. To be honest, this sort of feels like dogmatism to the detriment of maintainability.
But why an ID and not a class? I guess I'm hung up on why you think that's a good idea. Also I didn't say the selector is beautiful - i think it's really bad and needs fixing. But it's a good idea to put a unique class on a component. I think the algorithm should be able to see you have a unique class there on purpose and default to that and let you decide if it's good enough. Nothing dogmatic about trying to save time.
I did read it of course. Sorry if came off aggressive, I'm really interested in discussing this and in doing so I have to challenge your opinions. The answers where No, No and Perhaps. You say "we're rehashing lessons", how do you know that? When you say "anytime someone asks is X bad or is Y good the answer almost always is it depends". If you can't prove that statement I won't take it as fact.
Is his statement good or bad? "it depends"... eh?
POO
I don't understand the downvotes.
&gt; look into the history of Smalltalk But smalltalk isn't what modern oop is like. 
OOP is not bad, but it simply doesn't solve the problem of dynamic web UI's, which is what stateful frameworks like React are trying to solve. In order to understand this you have to be familiar with the DOM and the browser interaction. In other words, OOP would be great if all you code is static pages, because it gives you possibly the easiest way of conceptualising your code. Unfortunately the dynamic aspect requires you to deal with the simple problem of having to tell your browser what to render when some event occurs. That's what state is all about.
Lots of cool stuff here and I love the focus on the server side! Someone PLEASE tell my why frameworks are still making the fatal mistake of trying to put JS's features into HTML, rather than what React did and put HTML into JS? 
But it could be represented as basic data structures like what React does. At the end of the day the screen pixels are actually redrawn many times per second.
[Programming paradigms](https://en.m.wikipedia.org/wiki/Programming_paradigm) and software design techniques are different. OOP is weird to be because it's both. Wiki says it's a paradigm, but to me it's a design pattern (the inheritance model which IMHO isn't often the right choice) that employs aspects of many of the other paradigms. Domain driven design, the actor model, the central state container/reducer model, and even many aspects of OOP are all software design and development approaches. Different problems are solved and modeled best with different techniques. Evaluate what is best. Use it to solve the problem. Implement in whatever paradigm is best suited (that your style/language/restrictions allow).
Non-Mobile link: https://en.wikipedia.org/wiki/Programming_paradigm *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^39954
I can only compare it to JIRA, which seems slightly superior to me. In terms of the features I care about, Phabricator is fine. We use Diffusion which is a replacement for github, but it's hard to beat githubs experience.
This is my jam
I never had a problem, but if the keys are that far away for you, consider a smaller keyboard, or one of those ergonomic ones that Microsoft sells.
With Marko v3 they are separated into a couple of files (one for renderer handling and one for markup) but with v4 they will all be the same file.
&gt; functional is dead It kills me as a mathematician to see these three words put together. To me, there's nothing so beautiful as a dense, layered functional expression that is so impenetrable that your job is guaranteed for life because no one else can figure out what the fuck is happening. :)
I know this has been answered to death, so I'll just throw an idea or two your way. I tend to lean pretty heavily toward functional programming. I have a degree in math and lambda speaks to my heart. But with that in mind, there is a lot of stats management that happens as you get close to the ui. React attempts to make the ui state functional, but I tend to like having my state be more OO in design. However, as I move farther from the stateful ui, my code gets dramatically more functional. This is not the only way to design a program. In a broader sense, I think it is valuable to investigate different designs, tools, patterns and paradigms. Though everyone you talk with will have a different opinion on how to accomplish a task, each approach toward solving a problem will have its own pros and cons. It is your job as a software developer to sort out how best to solve a problem. The more you understand about approaches which can be used, the better you will be at flexing to solve tricky problems. So with this in mind I would say, if you are programming in Javascript you should really learn both functional and object oriented programming, just remember, even with the introduction of the class keyword, Javascript is still a prototypal language. All of this adds up to a flexible, dynamic language which, in itself, introduces benefits and challenges. In the end, there is no one size fits all answer. No single methodology will answer every question. The onus is on the programmer to uncover the best solution, so no, OOP is not universally bad, and functional programming is not universally good. --- Now, regarding where the market is going... That is a tough question. I am currently working in a predominantly .Net shop, so there is a strong rallying cry around typescript, but I personally think that very same language is a bad idea. (my opinion, not fact) this means everyone is trying to program Javascript like it is C#. Very strong OO tendencies in this group. On the other hand if you work in a JVM language shop you might lean toward either raw Javascript or you might do clojurescript, Scala js or even purescript. This will take you down a much more functional path. None of these answers are flat wrong (except trying to write Javascript like C# because it actually doesn't work the same way). The temperature of the market is going to appear to be different depending on the kind of shop you're in, so there will be no definitive answer, so it is best to learn programming fundamentals as best you can and then expect to roll with the punches. Javascript as a full-solution answer is still very new, so people are trying to get their bearings and the landscape will seem pretty rocky for a while. Eventually things will get clearer, but it is hard to gauge when that will happen or where the path will lead. 
You have some very good points and lessons in your comment. Thank you. This was the best way to answer my question. I'd love to know your opinion on something I believe in. You are right that bad coders are everywhere, but there are ways to limit what they can do wrong. Don't you think so? I feel things like centralized state try to avoid people unintentionally making things complex. The same goes to microservices, if I write the worst service you only need to throw that away and rewrite one service rather than remaking the whole monolithic application. Am I making sense?
Centralised state isn't really about preventing bad programmers from making things too complex. They can definitely do it regardless of how you manage state. If you think about distributed state (or non-centralised if you will), it's like a mesh of dependencies between all your components. They all have bits and pieces of state and try to keep each other updated. As you add more components, that mesh grows more complex. Every component needs to keep more components updated and ensure there's no disagreement about state. Centralised state is a single source of truth. Components no longer depend on each other and changes are made explicitly through a single mechanism. Instead of components updating each other, they simply react to changes in the bit of state they care about. This means adding more components doesn't necessarily make your application more complex. However, such a system often brings *more* complexity initially. It's an abstraction and you need to design the state so it serves all components well. It tends to pay off in the long run, but it's often much harder to make a good centralised state than just pass data among the components.
God thanks for having this opinion. 
https://github.com/rchipka/node-osmosis
Have you tried Clojure? IMHO it seems more intuitive and easier to learn.
You are absolutely right. Thank you for perspective. I hate when others do it as well and I fell to same trap.
Here's a [nice image](https://docs.angularjs.org/img/guide/concepts-module-injector.png) from the docs that might help
My point was the reason stateful frameworks came to exist is because OOP was not enough to handle the dynamic web page problem. I don't think adding OOP on top of reactive components makes sense. It's like people who want to write javascript but they really want to write ruby :D
Jeeez, could you stop please? Stop right there? (No worries. You can all leave your fingers off the downvote button. Really. I'm not going to contradict this. Not at all.) **It's just too painful.** Much too painful. You know... On the one hand, you're perfectly right. Framework hyping is a truly a bane of our industry, and having to select "the best" framework for your project (i.e., the one that's least likely to turn out to be the very worst possible choice after a few months) is one big ass sucker of a challenge. On the other hand, I have only recently convinced my bosses that we should really, REALLY start using a framework for our customer facing site. All the homebrew shite from my predecessors was getting completely out of hand, and once you start manually fracking security into an existing pile of garbage, you're pretty much done with handcrafted coding. I mean, even if I were a really, really excellent programmer, if I started to do anything production scale by hand, chances are I'd just end up with a half-baked *framework*, and it would be way worse than any one of the major frameworks out there. But of course, hey, come on, ain't we all coders? Ain't we all the same, really? Ain't we all little big framework designers, at heart? Am I not coding the next MVC framework on my weekends? No I do not expect it to become a success, but it's where all the fun lies.... making up concepts, trying new ideas, messing around with really fundamental stuff. Bottom line: It's a completely unsolvable problem. All you can do is try your best not to burn yourself too hard.
Wasn't really aiming to disparage his work, if I wanted to do that I'd point out that everything he did in the video is not only possible, but vastly easier to do in any modern DAW. Which kind of renders the "javascript and nodejs" bit a strictly more clumsy and entirely redundant means of note input. However, I didn't say that. I pointed out primary advantage programming languages offer with regard to musical composition which the speaker is ostensibly unaware of or unexperienced in, and I provided an example to illustrate that point. But by all means, let's all just pat each other on the backs 24/7. That sounds like much more fun than learning or having our views challenged.
What are you having trouble with in regards to Haskell? I found that with a bit of time and effort everything came together quite nicely. It's now my favorite language to program in. 
Relevant as always: https://s-media-cache-ak0.pinimg.com/736x/a3/83/bd/a383bdc6cf0d11695573a4aac661aaf9.jpg
HTML 5 doesn't officially support [anchor tags around buttons](http://stackoverflow.com/questions/6393827/can-i-nest-a-button-element-inside-an-a-using-html5) so I see no alternative/issue with using JS for the navigation buttons. Is there a problem with using a resource that is available on all modern browsers and has little/no impact on performance within this context? Edit: You could use a form for each navigation link but adding more DOM elements implies structural changes not functional changes no? That and the fact that forms typically imply input; using JS seems the most logical choice.
Qt comes to mind.
Second everything. Beautifully said. &gt;any time someone asks is X bad or is Y good the answer is almost always... "it depends". Or perhaps "vague question". Asking about trade-offs of X vs. Y yields better answers. 
The design of the web and the major operating systems is not up to popularity. The people who created those standards and products were not elected by democracy, and the design was not created by committee. Instead great engineers and scientists have come together to form the backbone of the modern software landscape, and then *the successful results* of those efforts are what became popular. On merit. So you can drop that argument. In the larger picture we are talking about empirical evidence. We have plenty of empirical evidence that OOP is viable for complex UI, especially when GUI is literally a hierarchy of little visual objects holding certain state and expressing given behavior (which is what OOP is about), and little evidence that something else is. GUI and OOP have been invented together and are tied together. In a way, the entire branch of GUI *is* just the graphical arm of OOP.
Are you by any chance on a non English keyboard layout? I switched to the US Keyboard layout a long time ago, because the german placement for curly braces was terrible.
It is called a scraper. Try googling that. 
Yah i see
OOP is a legitimate and good way to write Javascript, but there is no "one and only one" good way to write Javascript. Though, OO code tends to be bigger than functional approach. 
No, I guess I'm not used to that level of pinky stretching. I'm putting in some practice time, it looks like there are some online lessons that actually focus on brackets and braces
You can create a promise: async () =&gt; { const loaded = new Promise(resolve =&gt; { window.onload = () =&gt; { resolve('hehe'); }; } const result = await loaded; //result = 'hehe' } 
thank, do you have any other way ?
I enjoyed this. I'd be interested to hear a critique too. 
A small little project I've done on the side to resolve some issues I've had with content editors and with general CMS's in the past. Hopefully you find it somewhat useful. Feedback is appreciated :) It's not feature rich but it gets the job done. ᕕ( ᐛ )ᕗ or at least I hope so ¯\_(ツ)_/¯
http://redux.js.org/docs/introduction/Motivation.html, as mentioned in OP. Love me my w3m.
why does the author think scraping with Python makes him old?
Be careful about thinking of microservices as a solution to coupling, you can achieve exactly the same thing in a monolith, and it's actually easier. Doing microservices well takes discipline, more than your average engineering team has. Whether you're doing services or a monolith, the important thing is to define APIs that don't expose internals. If all your domain models are talking to each other directly via an ORM, you're going to have difficulty decoupling in future But if you define a strict data access API for each domain, you'll be able to refactor the underlying domain to your heart's content as long as you don't change its API. The benefits of services come when different domains would benefit from different languages, databases, or scaling characteristics. But this comes at the cost of an increase in the overhead/latency of communication between domains.
Maybe I'm misunderstanding, but what I understood is that you have these big selectors in order to specifically target a single unique element on the page. This to me is precisely what IDs are good for. There's a school of thought that says never use IDs under any circumstances, but I think this is overly dogmatic. Assuming this is the case here, I think the solution is clearly much worse than the 'problem' it was trying to solve.
OOP, or more precisely its MVC pattern, isn't inherently bad for application building, it was s major step over the previous paradigms. But it most certainly brings its own, severe pitfalls, which are now being addressed by its successors. React and many of its clones are in between purely functional and OOP. They cherrypick what is convenient in OOP and merge it with a data driven, functional architecture. This allows for *plugin-in state handling* (for instance Redux) and brings the approach closer to the functional paradigm. Redux is nowadays often being used in traditional OOP frameworks (Angular via ngRedux) and even native land (.Net, Go and Swift), but in order to work in these environments it has to to inject, mix-in or event-delegate itself because there's no natural place for it to fit in. This is the biggest oversight in traditional OOP, to [treat state as dispersed models while views depend on them unpredictably](http://iweave.com/assets/blog/mvc_v_flux.png). This is the actual outcome or lesson learned: state lives in its own, central and portable container. The user interface is just the dress covering it up, declaratively describing its visual appearance, while driving properties flow from top to bottom. This is what makes all the difference to the older approaches. A very good article that explains this in more detail is from Wolk: http://blog.wolksoftware.com/the-rise-of-functional-programming-and-the-death-of-angularjs
Why are you storing it as a key-value pair when you could do this: ``` var chips = [ { "name": "cheetos", "quality": "good" }, { "name": "doritos", "quality": "better" ]; ``` Which you can then access with: ``` var name = chips[0].name; ``` 
React discriminates between stateless and stateful components. A stateful component is wrapped in a class, it is OOP in the sense that you have an object interface and class inheritance. class Stateful extends Component { // It can declare local state here, as well as react to lifecycles render() { return &lt;span&gt;{this.props.text}&lt;/span&gt; } } A stateless component is a pure function, given the same input it will return the same output. const Stateless = ({ text }) =&gt; &lt;span&gt;{text}&lt;/span&gt; Or the same in ES5 function Stateless(props) { return &lt;span&gt;{props.text}&lt;/span&gt; } Both stateful and stateless are handled in the same way: &lt;Stateless text="hi there" /&gt; &lt;Stateful text="hi there" /&gt;
This reminds me a lot of [Jekyll](https://jekyllrb.com/) and other static site generators. Why not use that instead of making another one?
A stateless component doesn't get state, unless you mean const A = () =&gt; { let state = "im state"; return &lt;span&gt;{state}&lt;/state&gt; } State in stateful means it is reactive. If it changes, the component renders. Stateless also don't have access to lifecycles. They're designed to be "pure." But i believe internally they're a wrapper for createElement, which does have OOP semantics.
Good question. Difference is that this is not a static site generator. Generators like Jekyll is a framework where you would create an entire site within it's constraints. Something like Bazooka is more "API" driven. You spit out a json file, with this file you can do whatever you like with that data. Use that data with a framework you're comfortable with and have the ability to reuse the same data across different sections of a website or event in a sub site etc. You can, if you want, host the output on a separate cloud server if you want your single source of truth to not live in your main site. Thus you can point your multiple websites across different server to fetch a blog post from the one location. Hopefully that makes sense :)
[removed]
I understand how props are static and states are not. My point is more that they both act as instance variables only the former isn't mutable. Props seems to act as a constant class variable following construction (obviously this wouldn't be possible but props act in this manner). Maybe I'm just looking at components and their instances differently to you. 
I'm not sure I've ever typed a right brace while writing code. Maybe in a template literal.
man, that's a hell of an advice! thank you so much!
What you have is already more or less correct, the only slight issue is that you're returning a Promise, when the return value of an async function is already wrapped in a promise. You also haven't used var/let/const on your promise declaration, so it will become global. You could either remove the 'async' modifier and return the promise directly. function getUrl2(url){ let i = document.createElement('iframe'); i.src = url; return new Promise(resolve =&gt; { i.onload = e =&gt; { resolve(e); }; document.getElementsByTagName('body')[0].appendChild(i); }); } Or, if you want to include the async modifier, just 'await' the result inside the function async function getUrl2(url){ let i = document.createElement('iframe'); i.src = url; return await new Promise(resolve =&gt; { i.onload = e =&gt; { resolve(e); }; document.getElementsByTagName('body')[0].appendChild(i); }); } This will resolve to the caller when the inner promise has resolved.
React isn't OO in disguise, by the way. Flux is. React is (potentially) pure functional. 
Have to go look at the unminified source. Drink from the fire hose padwan! 
I remember my very first project as a developer - I used IDs a lot, and it bit me in the butt... things I never thought would be duplicated ended up being that way, and had to go back and change the IDs to classes a lot. It just limits your options using an ID... oh yea, they screw with css specificity as well which is not fun.
It's a good way to separate content form presentation. For instance you can put markdown docs in a git repository and enjoy perfectly readable version control. But it's a strange beast. Not specific enough for programmers and scholars, not easy enough for general public. You can't really offer that to clients. They want shiny buttons and visual previews.
Did you see what happens when you sign in? Just put any character(s) you like in the box to get a websocket. Then the right side starts to come to life. If you join the group "test", a sample todo list will appear. Or, you could start your own. There is also a place on the right side for sharing text messages with fellow group members. Maybe a centered page should load at first, and then shift to the left to make room for the other things after logging in. First impressions are important, so I am seriously considering this. I am inclined to keep the black background. Is lowering the contrast a matter of making text colors duller (further from white). I changed the basic font color to a brighter shade (closer to white) in an effort to make it more readable. It seemed like an improvement but I wonder if it is. Maybe cream colored text on a dark brown background would work. I didn't start off with images in a header and other flashy stuff. I was concentrating on making the code perform well. Even the definition of the basic class Monad went through many changes and everything was refactored over and over until I had eliminated all direct manipulation of the DOM and purified functions so that nothing outside of their scope gets mutated so they receive values only through their arguments as opposed to fishing for them in the global space. It was very gratifying to see complicated game traversal code boil down to the simple, readily understandable form it is in now. When the code became concise and straightforward, and all relevant parameters (except the index number) were placed in a single monad, side effects disappeared and fixing the remaining bugs was child's play. Now its time to make my work more presentable, and to add eye candy judiciously and as tastefully as I can. At the same time, I need to think about whether I have the makings of a functional reactive programming tutorial or a small library of core classes and functions. Maybe my site should set the background for a blog. I have to remind myself that what looks simple to me would have been mind boggling before I got used to the concept of methods taking functions as arguments. I want to do something useful, so I have started to elaborate on the details of what happens when a monad's bnd() method takes a function as its argument and returns another monad. I also want to show developers that interesting things can be accomplished without resort to elaborate frameworks. In a Cycle application, reactivity comes through drivers and my minimalist drivers show how easy it can be to define them. Anyway, I want to thank you again for you insights and suggestions. Your comment didn't strike me as being whiny at all. It reminds me of an old dandruff shampoo advertisement that said "Even your best friend won't tell you". Thanks for telling me. Your comment was very helpful and any follow-up will be much appreciated. 
Using Node to compose basic music and writing generative/adaptive music algorithms are completely different things that require much more skill with both music and programming. If you'd chill with the condescension we wouldn't be having this talk in the first place. Alternatively, spend more time in /r/iamverysmart to see if anything looks familiar.
interesting question. I "like" it but maybe that's because it's so common now and a competitor hasn't risen up to challenge it or take its place. Before MD there was TinyMCE, which I believe WordPress still uses. As a front-end dev I would never be satisfied with the HTML markup that TinyMCE created but for non-tech clients it was fine. So yeah, I guess MD is aimed at programmers. I guess it's nice not to have to deal with writing HTML markup for simple things like commenting in reddit and creating READMEs in Github. Also, it allows sites to use styling in comments without having to worry about stripping malicious code. TinyMCE allowed you to switch between the HTML and the WYSIWYG so you were still needing to worry about dealing with that when sending it to the server. I would imagine that was one of the biggest reasons it was created. An interesting fact, [Markdown was co-created by Aaron Swartz](https://en.wikipedia.org/wiki/Markdown#History). I had no idea. 
&gt; When the C language came along, Assembly programmers would say it wasn't really better. It wasn't. It was better for *some things*. For example, back in those days hand-optimised assembler would always beat C for execution speed, number of instructions and general and efficiency. On low-powered hardware, slow processors and with limited memory, that was a significant issue. However, C made code *more portable* between architectures, and allowed programmers to reason at a higher level. Over time hardware got faster and more diverse, so the efficiency gains became less important and the portability and ability to easily do high-level reasoning became more valuable. **That's a tradeoff**. There is no "objective" statement, *even in the case you offered as an example of an objective improvement*. There is merely a hidden tradeoff that you gloss over without recognising/acknowledging it by hand-waving around "for most applications [for most developers, these days, on non-embedded consumer hardware]". Sure, well-factored code is "objectively better" than spaghetti code (at least assuming we aren't being silly and factoring in things like "job security" as considerations) and modular code is "objectively better" than monolithic code, but it's actually really, really hard to make absolute statements about code architecture that aren't sensibly context-dependent... and simply waving away important context or including unexamined assumptions or unacknowledged tradeoffs doesn't fix that problem - it just shows that the speaker is operating from an incomplete or poorly-specified understanding of the problem-space. Likewise, there *is* no "objective" answer between FP vs. procedural vs. OOP, or arguably even Angular 2 vs. React/Redux/ vs. Vue ve etc...
[Does Google execute JavaScript?](https://www.stephanboyer.com/post/122/does-google-execute-javascript)
Thanks, from the link you posted, the second answer is taken directly from Angular source. Looks like they are manipulating the function's string with regex just like I said, I wish there was a more elegant way but oh well.
Hi /u/Haid1917, please keep it civil.
It's clear that he isn't looking to do things as easily as possible, he's tinkering with Node.js. Of course it's "strictly more clumsy", it's a learning experiment. You're missing the point. &gt; But by all means, let's all just pat each other on the backs 24/7. That sounds like much more fun than learning or having our views challenged. This sounds like a reasonably informed comment that's completely directed at me and the words I've said, and is *definitely* not a case of you bottling up your opinions and unleashing them on whoever will hear them. Totally. In the future, feel free to read the comment you're replying to so you have some context of the conversation. I don't know what argumentative baggage you're bringing into this discussion, but deal with it elsewhere.
I really love the way you have setup this PersonalWiki in Github and Gitbook and all the different ways you can download for readers as well. Very inspiring. 
Thank you. It has been pretty popular for a while now to trash OOP as a horrible paradigm, but the fact of the matter is that OOP is a very effective tool for certain kinds of problems. All languages and paradigms are better at solving certain kinds of problems, and worse at solving other kinds, so instead of treating them like religions to which one must convert and be faithful, one should treat them like a box of tools to choose from. This analogy has been thrown around for decades, but that's because it's apt: you wouldn't ever expect to hear a carpenter try to convince their peers that all problems are best solved by a hammer and that all other tools are inferior, and it's just as absurd when programmers do effectively the same thing. 
I have some critique: First, there's no One True Way to build applications in Swift. It's not a framework, it's a language, like Objective-C, C++, C# etc. It's a flexible platform in which you can implement any architecture at all. React, on the other hand, has a very particular way architecture for expressing UI state. So if you would try to compare both, you'd be comparing not "React" and "Swift" as much as "React" with "one of a million ways to approach the problem in Swift". It's true that learning the true native platform may take more time than slapping some JS together with a simplified React API, but I wouldn't say spending a **couple of hours** learning each platform is representative of what your experience will be over *days, months, years* of using them for real-world applications. Second, I don't find measuring FPS and memory for so simple "Hello World" apps is meaningful. One key point here is that React has a built-in performance hit that directly corresponds to the amount of state in the app UI. I.e. the more tabs, widgets, controls and so on you have, the slower React becomes, because you're essentially rebuilding the entire UI state from scratch on every mutation. The React engine will, of course, only intelligently apply the differences from one build to the next. But you're **still building the full UI state in virtual DOM, regardless**. You don't have to do that in Swift. Which means if you have a very, very complex app, in Swift you can use an architecture which is as snappy and fluid as this "Hello World" app. While React will be slower and slower as the app size and complexity grows. I like React, I use the browser version for many components in web apps, but I never make my apps 100% React, I never tie them to React. I just keep it at the level of components. There are situations and types of UI, where React is simply sub-optimal, and you need to have the freedom to go with a different architecture. This is possible in browsers, but I don't see how you can freely mix Swift + Cocoa Touch with React Native. And maybe that's the biggest weakness of React Native: flexibility and lock-in effect. If you want to code an iOS app the "quick and dirty" way it's probably an excellent approach. But I'm be cautious for anything else. BTW, the Facebook app, is it using React Native? I don't think it is.
What you said about the virtual DOM is on point. I love React Native but especially on older devices the virtual DOM becomes expensive and slow really fast once you start adding tens, hundreds of components per screen, which can easily happen on tablets. About intermixing with native UI components, it's not as hard as you think. There's a great and very straightforward guide in the RN docs about how to do it. 
Oh, thanks for you appreciation. And even though GitBook is not really widely used for writing document, it's a good choice at all.
Haha, I guess it is due to the fact that all the people he meets these days are all over JS based frameworks. That's how a large number of people actually learnt to code! PS: I am the author :P
How exactly is it condescending to point out that you're making flawed analogies to try to basically prove I'm an asshole with nothing constructive to say? &gt; Using Node to compose basic music and writing generative/adaptive music algorithms are completely different things That was kind of my point, if you're going to put the GPS on the dog (use Node js), then maybe use it instead of dipping both the dog and the GPS in paint and then smearing them over the canvas? We already have brushes for that. &gt; If you'd chill with the condescension Says the guy saying: &gt; That would definitely be cool, please let me know when you've implemented it and I'll make sure to make a comment disparaging your work. Cheers! Not sure if you're just trolling or actually fail to see the hypocrisy in accusing someone of condescension by making a snarky passive-aggressive comment of your own. If you'd chill with the tone policing we wouldn't be having this conversation in the first place. Alternatively you can spend more time /r/upyourownass and see if anything looks familiar.
Thanks for the feedback! JSX makes JavaScript more like HTML. Marko makes HTML more like JavaScript. In the end, the approaches kind of meet in the middle, but I believe you get much less boilerplate and that the the view code is easier to read if you start with HTML. With that said, I have seen a lot of HTML templating languages that restrict what you can do and don't allow the power of JavaScript or introduce a complex language on top of HTML when JS would have been much better--marko is not one of those templating engines and we embrace JavaScript wherever it makes sense.
Use the scope var tmp={}; fetchAuthor() .then(response =&gt; { tmp.asdf=response; 
lol that is neat :P
[removed]
&gt; there doesn't seem to be anything here
Ah, fair enough.
Like I said, this creates side-effects and you won't be able to move the function into it's own declaration. I don't really like it.
you can use a transpiler like babel or traceur, in which case it doesn't particularly matter what version of node you use. the harmony flag for async await has been available since node 7, so i wouldn't say it's super experimental
Funny idea :D. I would position the x y point in the center of the corresponding eyeball - would be better for size animations :D
Use a "struct type" fetchAuthor() .then(response =&gt; { const authorId = response.id return fetchLatestIssues(authorId) .then(issue =&gt; {authorId, issue}) // issueByAuthor struct }) .then(fetchCommentsByAuthorOnIssue) function fetchCommentsByAuthorOnIssue(issueByAuthor) {/*...*/}
[removed]
I would say that we make the same mistakes but then come up with different solutions. Sometimes those different solutions are better. One example (admittedly doesn't exactly match), is that Apple didn't invent the MP3 player. Other companies, particularly Creative Labs, had them before. But it took the right mix of technology, services, and design before the world was overtaken by the iPod. Sometimes the new solutions are just better because the fit their time better or combine multiple newer things better.
Marko supports shorthand attributes based on CSS selectors: http://markojs.com/docs/syntax/#shorthand-attributes (also try online: http://markojs.com/try-online/?file=%2Flanguage-guide%2Fattributes%2Fshorthand.marko) This feature was inspired by Jade/Pug and most developers find it as a really nice way to reduce typing and noise (to make templates more readable). Sure, you will absolutely need to understand the basic syntax of Marko and how to use it (just like with any JavaScript library/framework), but there is a reason behind every decision. React JSX has its own set of quirks (e.g. `className` instead of `class`, expression-only children, `this` binding for event handlers, etc.). &gt; Cool, maybe there's an onClick method in my component? hmm, i don't see one. Ohh, I do see a function called increment in the class - maybe it's calling that! Hopefully I don't misspell it. It's an event handler mapping that uses a string to reference the name of the event handler method. Why a string, you might ask? It's because functions are not serializable down to the browser (without hacks), but strings are. In addition, there is no confusion around `this` because event handlers method are invoked with `this` as the component instance. Also related, unlike with libraries like React, Marko _does not_ require the UI to be rerendered in the browser if it was already rendered on the server. The UI boots up instantly since the browser can just pick up where the server left off and you don't have to think about how to serialize state/properties down to the browser. Even sending down the UI rendering logic is completely optional. Referencing event handlers by name was required to make all of this work. So yeah, while I would not disagree that you need to learn new things to fully use Marko, those things are meant to make your life as a developer easier, not harder, and I believe it is worth the investment. 
I don't think you want a loop here -- instead keep a track of which entry in the array youre displaying and increment it when you click the button. Like this: https://jsfiddle.net/andersevenrud/yoxurn98/
A for loop runs the loop right away, it won't wait for you to press the button. You want one variable that tracks where in the array that increases when you press the button (and updates the image shown) and resets to 0 when it gets too big. Edit: also you want .setAttribute("src", images[i]) rather than just .images[i]. 
Right, but mathematicians create *beautiful* obfuscations. Idiot CS majors just create uggo waffles. ;)
[Relevant XKCD](https://xkcd.com/1270/)
The blog linked in your link states that generally no websites need to have snapshots and that Google will be able to understand nearly all websites. If that was true, I wouldn't have had to go through all the server side code. The website in question is essentially one long list (paginated), if Google cant crawl that (in its own Framework nonetheless), then something "deprecated" like escaped_fragment crawling is necessary.
You make bold statements, and then you fail to provide your examples. Awkward. Where are those "things other than OOP"? I've seen functional and reactive concepts laid on top of OOP GUIs. They are opinionated shims, not actual standalone GUI systems. They prove only that some functional and OOP concepts are complementary, not mutually exclusive. If you feel that is wrong, provide your evidence.
Last one should be `return await`, no?
-1 for using JSX, JSX has no place in a general purpose tutorial.
Fun programming project. I took a different approach that IMO results in more Mondrian-looking results, in terms of the grid lines: https://github.com/fogleman/Piet
Actually I stumbled on your code but I couldn't get my head around it haha
You haven't given any examples or evidence in the first place that OOP is all that great. Why is it assumed to be great just because you say "all guis are OOP" with no evidence. 
So you're not objecting that all major GUI platforms are OOP, you're objecting that I can't prove they're "great" when compared to... nothing, because you're giving no counterexamples. That's some amazing and very unique mental construct you have there. Cherish it, preserve it, pass it on to future generations.
If nosql is never the right choice, how come companies like Netflix use it in integral parts of their infrastructure? I think it's pretty obvious nosql is a very useful tool for the proper use cases.
WalMIK. Lol his voice.
Lol what. JSX is the conventional way to write React, AND it's the clearest way to write elements. Of course it's going to be used in a tutorial. If you're gonna poopoo someone's hard work, at least have a valid criticism. 
Super cool! I love seeing build-your-own tutorials, it's the most enjoyable way to learn how things work. 
Use dev tools maybe. Go onto sources and save all the JavaScript files that you see. Can also get CSS and maybe images but I'm not sure if you can get those from just the cache. I've not tried in a cache-only scenario but that would be the first place I'd look.
The part about the virtual dom leading to slower apps i don't understand. Could you elaborate? The v-dom should just be a slim representation, like the visual and logical tree in most UI systems. I got into situations where render cycles were wasted causing a parent to update and it starts to render *all* of its siblings for no valid reason. Or deep-diffing for changes. But isn't this what Redux/MobX explicitly prevent? It seems to me this is a major tool to get to very complex applications in the first place, i've seen [Swift](https://github.com/ReSwift/ReSwift) and [.Net](https://github.com/GuillaumeSalles/redux.NET) developers adopt it for these exact qualities. Is there something in RN that breaks this somehow?
 fetchAuthor() .then( res =&gt; Promise.all([res, fetchLatestIssues(res)]) ) .then( vals =&gt; console.log(vals) ); The `Promise.all` seems overly verbose. I much rather capture the variables with scope etc.
Yes that would work yet in a bigger chain, that would be a problem. Imagine having a 5 step chain and you need the first step's results to be consumed by the fifth step.
That would be a problem in a bigger chain. Imagine having a 5 step chain and you need the first step's results to be consumed by the fifth step
Thanks for the kind words! Glad you enjoyed it.
That's different than saying the graphical user interface would never have existed without OOP. Do you think humans would have just looked at text on a screen forever?
Can you post a sample of the exported HTML source here? What email client are you using to view the sent email? Very likely "the styles are being stripped" is your answer. Working with html email is a real nuisance I'm afraid.
most of those gui platforms are a very bad hybrid of OOP
Cool! Never heard of Siteleaf until now. Thanks for sharing!
It's likely from Node callback hell.
&gt;JSX is the conventional way to write React Yeah for people who know how to write react already. For People who don't know react/JSX this would make no sense. 70% of people who bounce off react do so because basic tutorials like this require taking 5 other tutorials in order to understand the code. &gt;AND it's the clearest way to write elements. That's a matter of opinion, there are several libraries that I think do it much, much, better than JSX does. https://github.com/uber/r-dom https://github.com/trueadm/t7 https://github.com/mlmorg/react-hyperscript JSX is general agreed upon as the most hated part of react. I don't know if you're just being a huge dick, or if you're just ignorant.
Thats not how you should unit test. You'd test the function retrieving the info to ensure its correct rather than whats being stuffed into the variable.
Slightly off topic: if you don't care what the value of `currentImage` is, you can use `images[currentImage%images.length]` to loop round.
Is a tutorial about building React Router a general purpose tutorial? What does that mean?
Thanks Tyler! Your tutorials and courses have been a pleasure to work through.
What is the free quota for it if any?
So the game doesn't require anything from a server? If that's the case, I think a simple right click-&gt; Save As... would work. Make sure you select "Webpage, complete" so you get all the assets. (This is on MacOs btw. Not sure about the other OSs but DevTools is another place to look if necessary).
I'm sorry, I don't know where you keep getting these facts, but it's just not even close to being true. I'm happy to believe you've been using React for two years (so have I), but it really appears you haven't got a good grasp on how to create a *performant* React application. Sure, immutable data structures have *different* performance characteristics than mutable data structures, making them more beneficial in some scenarios and less so in others. But the thing is, if you use them it allows you to perform nothing more than reference equality in shouldComponentUpdate() instead of deep comparisons, which makes them so compelling to use in combination with React. I'm not saying it's a free lunch, but it is a solution to the very issues you keep insisting React suffers from. Also, MobX is actually an entirely different approach to the problem and they *don't* use immutable data structures at all. It actually uses mutable state and events. And again, it solves the very issue you insist React suffers from.
&gt; But the thing is, if you use them it allows you to perform nothing more than reference equality in shouldComponentUpdate() instead of deep comparisons Do I have to spell it out that the decreased cost of comparing immutables is offset by the increased cost of producing changed replicas of them, which is proportional to their size? There's no such "proportional to the state's size" correlation to performance with mutable state and events. I've said that several times, but you're focusing on the best parts of immutability and kind of glazing over the tough parts. &gt; Also, MobX is actually an entirely different approach to the problem So what's the point here, I'm starting to talk in detail about a specific approach and you quickly point out that it's different than some different approach. So I shift talking from mutable state to immutables, and now yet again, the problem is this is not like observables. Why are you doing this? Are you even willing to have a conversation, or just jumping around topics and cherry-picking the strengths of each technique you like instead of having a balanced conversation?
As far as I can see - none? I'm sure there's some limit lol
Ahh, yesss ... OK, done that and I'll test it out when I get home this evening. Thanks!
Thank you! And you're very welcome.
I don't know why you are giving all of this extraneous information. The OP said, and I quote: &gt;without OOP, there wouldn't ever have been a GUI. This is making the claim that WITHOUT OBJECT ORIENTED PROGRAMMING, the graphical user interface would have never been invented. For all we know, if OOP wasn't envisioned, a form of functional programming could have developed the first GUI. Just because it happened at that exact date using that exact paradigm DOES NOT MEAN that it would not have happened otherwise, end of story. 
&gt; and for browsers it's even in the damned name: DOM (Document Object Model). Well that's funny that you use that example, seeing as the DOM is just data, there is nothing inherently object oriented about the DOM besides the name having the word object on it. You can easily implement the DOM without OOP by just treating them as dumb data. In fact it has been done in Haskell (take a look at `reflex-dom`, a Haskell non-OOP DOM). &gt; It's awkward to ask me to "prove" things which you should already know very well as a developer, or which you can research on your own with Google. You said "... that **all** major GUI platforms are OOP", so do you have proof that they ALL are? I know some are, but I'm not convinced that all are. So because `c2` doesn't have any implementations then none exist. Here are two I know of for front end web dev: `reflex` / `reflex-dom`, and then there is also `react-flux` (the Haskell package). Hell have you even heard of functional reactive programming? It's pretty well known, and obviously isn't OOP considering the name. Here are some other gui libraries for Haskell: `gloss`, `shine`, and this entire list [here](https://wiki.haskell.org/Applications_and_libraries/GUI_libraries). Another example of a non OOP GUI is XMonad, it's a tiling window manager written entirely in Haskell.
Hi /u/This_Is_A_Robbery, please keep it civil.
&gt; Well that's funny that you use that example, seeing as the DOM is just data, there is nothing inherently object oriented about the DOM besides the name having the word object on it. I mean if you'll be calling the DOM "just data", we have to start from programming 101, because you don't know the difference between "object" and "data". DOM is the kind of "data", where the "data" is split into small independent, reusable units, where access to each unit state is done in an indirect, abstract, encapsulated fashion, by sending messages and receiving back messages from so-called "methods", which are implemented by the "data unit" themselves. The "data units" can be mutable (and in DOM most are), and one "data unit" can access another "data unit" by its reference. Once you have a reference to that "data unit", you can call its "methods". And this is what we call OOP, in a very brief nutshell. Ta-da! Sigh. &gt; You can easily implement the DOM without OOP by just treating them as dumb data. In fact it has been done in Haskell (take a look at reflex-dom, a Haskell non-OOP DOM). I think you're confusing "implementing the DOM" with "accessing the DOM", because Reflex-DOM doesn't implement any DOM, it's simply a thin layer to let Haskell utilize an existing browser's DOM. To say you've implemented DOM entirely functionally, you have to basically write a working browser entirely functionally (or at least the GUI/DOM part of it). I won't say you *can't do it*, because Turing completenes and so on, but such an effort would have very hilarious results, actually. &gt; Hell have you even heard of functional reactive programming? It's pretty well known, and obviously isn't OOP considering the name. Dude, read carefully what I said [right fucking here](https://www.reddit.com/r/javascript/comments/5xpel5/is_oop_objectoriented_programming_bad/dekxe5r/). You're not paying attention at all, and then whining I'm too hard on you. While you can't even be bothered to read the replies I'm writing to you before you close your eyes and start hitting that keyboard with a hammer to post a reply. &gt; Another example of a non OOP GUI is XMonad, it's a tiling window manager written entirely in Haskell. XMonad is not a "GUI", it's a window manager for X11. You should [read what a "window manager" does and doesn't do in Linux](https://en.wikipedia.org/wiki/Window_manager#/media/File:Schema_of_the_layers_of_the_graphical_user_interface.svg). It's a tiny fraction of the GUI pipeline and not where the actual GUI controls are rendered. Plus, XMonad implements windows in an obviously brutally basic way, so let's not set the bar so low. I can probably also write something like XMonad with papersclips and chewing gum.
Where do you hear these complaints? Most new people freak out at"mixing HTML with JavaScript", but never with jsx as an implementation. And even then, once they get used to that paradigm, they're fine. I mean, it's so simple, it takes virtually zero learning. I'm not troll here, but in the 2 years of using React and been reading about it, you're the first to really complain about jsx. Also, given the fact it's probably in 99% of react code, it makes sense it's in tutorials because it's what everyone knows and understands.
Pretty late to reply, but here you do dude, performance doesn't suck: http://mathieuancelin.github.io/js-repaint-perfs/stemjs-optimized/ I also submitted some test code on the other benchmark. Performance was never an issue I was trying to solve, it was keeping code maintainable and flexible, no matter what development paradigm you want to use
I wouldn't say "super" experimental, it's getting popular rapidly. My team mostly develops with react-native and async/await transformation comes out of the box with packager. I assume some devs are not even aware that this is not part of ES6.
So well done, thanks for doing this!
You seem to fundamentally misunderstand how immutable state works. It doesn't create deep-copies but quick and inexpensive 1-level shallow-copies that re-use untouched nodes. There is about zero overhead in creating shallow-copies. This is what allows Redux to test subscribers with simple reference equality checks. It doesn't need diffing, dirty-checking or mutable-state-setters. const state = { a: { content: 1 }, b: { content: 2 } } const newstate = { ...state, b: { content: state.b + 1 } } state.a !== newstate.a // FALSE, components linked to state.a will not render state.b !== newstate.b // TRUE, components linked to state.b will render state !== newstate // TRUE, components linked to root will render (discouraged of course) The state-tree can grow to millions of entities without the UI breaking a single sweat as only the components that are directly affected will ever get a render call. The only overhead now is number of subscribers. Run this in your console to find out how fast it would be if you had to test hundred thousand state-connected UI components, i get about 1ms: console.time("test") for(let i = 0, a, b; i &lt; 100000; i++) a === b console.timeEnd("test") Redux filling `shouldComponentUpdate` automatically with the aforementioned equality check and `React.PureComponent` which doesn't render children on update is highly performant, likely faster than native MVC could ever be due to bindings being extremely slow.
Your options are: store your variables in the closure scope, store your variables in an object that is passed down the chain, or use co-routines (async/await or generators).
I think you've some strong false-consensus bias. Perhaps you will take the down votes as an indicator of that.
This seems like a relevant read: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s19.html I would say that the main concern would be enconding on the db regarding the allowed set of characters. Please remember this: Use the SAME validation rules on backend and frontend. They shouldn't be different to prevent issues. If it is true that frontend will display the guideliness to the final user, backend validation is probably more important in terms of security, not validating correctly there for the rules and to avoid sql attacks could allow someone to introduce un-wanted strings on your db.
Looks like convincing each other means nothing to both of us. One might wonder why we're talking. One of the mysteries of Reddit. Have a good day.
You too. Although I would seriously suggest trying to be more civil in future. It is pretty darn annoying and just straight up won't fly in certain environments or even subreddits. 
&gt; What? No! You don't have to organize into binary trees. You're confusing plain Redux with immutable.js! I gave you both options: no trees (like Redux) and with trees (like immutable.js) and I told you what's the problem with both of them. Your math sits off with me when you say this: &gt; `foo.bar.baz.qux = 123` simply swaps references and overwrites 4 relations. Are you sure your "action" doesn't mutate the original state? Not only would writing the above expression in a pure way be annoying as f\*ck, but you'll also have to clone (i.e. "spread and mutate") objects at every level of the tree, which might not be small at all, and compares horribly performance-wise: // Mutable state.foo.bar.baz.qux = 123 // "Redux" var baz2 = {...state.foo.bar.baz, qux: 123}; var bar2 = {...state.foo.bar, baz: baz2}; var foo2 = {...state.foo, bar: bar2}; return {...state, foo: foo2}; The Redux example above doesn't show "simply swaps references and overwrites 4 relations", that makes no sense, in fact given the internal layout of this object, I can't even understand the words you're using. "Swaps references"? "Relations"? This will clone 4 full objects (yes shallow, but that's not something to call home about), each of which may have dozens, hundreds, thousands of keys in some cases (in one of my apps it's be hundreds of thousands), just so you can change one number in there. That's fucking awful. What I can't understand is... what is Redux doing for you anyway? It's not a library implementing something of substance, as much as it is a guideline for implementing immutability from scratch in one of the least efficient ways, with every action. Unlike MobX and immutable.js there's no underlying engine optimizing state changes, or adding features like granular observation. At every step you have to manually and painstakingly preserve purity, and then have code that's harder to read and get performance that's much worse than simply mutating in place.
Functional reactive programming really is the best way to handle these types of problems. I'm surprised it isn't more widespread.
Hence my question. JavaScript is certainly event driven in programming but it can now also object oriented at the same time? Maybe you could shed some light?
&gt; JSX is general agreed upon as the most hated part of react. I don't know if you're just being a huge dick, or if you're just ignorant. I don't know what React developers you're talking to but, no this is not the most hated part of react. I and all of my team for example love JSX.
&gt;performance doesn't suck But it is significantly slower than virtual dom implementations. Especially it has a huge overhead in slow cases [1]. [1] https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html
Yes. Also you only need a Chrome extension rather than a web page if the domain you want to access the JS from isn't the same one hosting the script.
Ok thanks! In C#, I use the webClient.DownloadString method and hold it in a string variable. Is there a similar method in JS?
Will check into it. Thanks!
[CSRF](https://en.m.wikipedia.org/wiki/Cross-site_request_forgery)
I always complete the brackets first then go back inside to add in the data/expressions. That way helps be reduce the error rate from the dangling closing brackets. 
That's interesting and frightening. Thank you.
Look at [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) and [GitHub's polyfill](https://github.com/github/fetch)*. Digging into jquery's Ajax methods is entirely unnecessary if you're just trying to implement something quickly. *You don't need the polyfill for a chrome extension
I personally really like [this](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html) for learning that hierarchy.
Thanks!
The React home page and official tutorial don't use anything other than JSX: https://facebook.github.io/react/ https://facebook.github.io/react/tutorial/tutorial.html
Thanks! 
No problem! I am always happy to help more people learn Haskell, the more that learn it the more libraries / development / jobs there will be for it.
Wow, you sure have to put in a lot of effort to use react router in your app... ;)
I'm sure your tutorial on rebuilding React Router 4 without JSX would be wonderful and super relevant.
How can you run without a headless browser? I think vue desperately needs a testing library. Yes there's great docs, and you can figure out how to test most things by reading them. But I ended up writing my own abstractions in each test. I use this library for my own tests and it helps me write tests a lot faster and a lot more concisely 
Lol. But yes that looks fine. Nothing nefarious in that. 
&gt; Can't really offer client a markdown editor... so its for tech people but not html. Reddit uses Markdown. Most of its users aren't "tech people". It's easy enough if you display a live preview and instructions next to it. Markdown is nice because the result is a simple structured document without any WYSIWYG garbage which clashes with the site's overall design.
&gt; state.foo.bar.baz.qux = 123 That's not what's happening. It goes through memory intensive setters, then calculates and notifies relations and bindings. Redux and immutable.js are two separate things. Redux is optimized, by the browser. It has granular observers, what the hell. It does many valuable things the other two can't, which is why it's being used practically everywhere, but read the docs when in doubt. Either way i realize now you are guessing your way through these discussions, it's fruitless to go on.
You forgot to think about the “why”, and answered the “how”. But the answer to the “why” is: This is stupid. Don't do it.
It might be set up with a serviceworker so it can run offline (and without server), and I'm not sure you can get all the resources with a 'Save as' when it's a serviceworker. You can check if it's ran by a serviceworker by going to devtools, then Application tab, and check if a serviceworker is running for the specific domain in tab Serviceworkers.
Did you look at ActivatedRoute? https://angular.io/docs/ts/latest/api/router/index/ActivatedRoute-interface.html
[removed]
Pay attention to lines 21 22 23. action is undefined on line 22 and 23 since you pass nothing to map and catch closures. ... .mergeMap(action =&gt; authenticate(action.payload.email, action.payload.password, "/login")) .map((action) =&gt; loginSuccess(action.payload.email)) .catch((action) =&gt; loginFailed(action.payload.email)); ...
 fetch('https://jsonplaceholder.typicode.com/posts/1') .then(result =&gt; result.text()) .then(result =&gt; alert(result)) You can open the browser console and try it. Then adapt it to your needs.
That didn't work, but removing references to the action entirely made the epic work. So I guess referring to the action is causing all the issues.
&gt; My understanding is that people fall into two camps, those who take issue with adding extra syntax to JS instead of using what is already there, and those who like the template file type patterning (and don't think JSX adepts well to that). Of course they take issue. Because templates are on their way out. JSX is doing exactly what you say it doesn't, *it uses what is already there.* That's why we don't need runtime templating engines, crippled script evaluators, code-in-HTML extensions, standards that take a decade to propagate only to end up doing a small fraction of what functional components do today. The majority of people bitching about JSX haven't used it. [You can see it reflected in surveys, too.](http://stateofjs.com/2016/frontend/) A minor amount of developers is against it (compared to alternatives smallest amount in 2016), the staggering majority enjoys it (highest rating in 2016). Let's be realistic, JSX won't go, it's too late for that and it has more than proven its worth. 
Tyler you magnificent son of a bitch! You're articles are always awesome! Keep up the good work! 
&gt; That's not what's happening. It goes through memory intensive setters, then calculates and notifies relations and bindings. You know, JS engines change all the time, so I'm putting your hand-waving descriptions in Google and I'm finding... **absolutely nothing**. Most JS engines have two most common representations for internal objects. Those are: - Hidden classes. - Hashmaps. There are also specialized representations about dense and sparse arrays, but those are another story. Hidden classes are an optimization in that they can store an object's properties as a compact tuple (as an array of references) without copying the hashmap buckets and lists, because all objects with the same "shape" (same properties) will share a single hashmap. None of this optimizes the case when we have two objects with even *one different reference* among its properties. Can you point out the source of your fantastical beliefs? Because there's apparently a bug filed about optimizing Object.assign recently, but **nothing has been done about it**: https://bugs.chromium.org/p/v8/issues/detail?id=5988 In fact, it says: &gt; Currently Object.assign is kinda naive Which proves the opposite of what you're saying. &gt; Either way i realize now you are guessing your way through these discussions, it's fruitless to go on. You're projecting, and trying to weasel yourself out of having to be specific about your B.S. I'm not. Here are links to how V8 represents objects, that corroborates what I said above: https://github.com/v8/v8/wiki/Design%20Elements http://mr-aleph.livejournal.com/288023.html http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html https://gist.github.com/twokul/9501770 &gt; It has granular observers, what the hell. Do you even understand what "granular observer" means? It doesn't mean firing *all listeners when any change in the app-wide store takes place*. &gt; It does many valuable things the other two can't, which is why it's being used practically everywhere, but read the docs when in doubt. I didn't just read the docs, I read the whole source of it, because it's so small, and you're full of B.S. Which is why when I ask for something specific, you respond with generalities like "does many valuable things".
Thanks for that. I need a small bit of the HTML body though, not the &lt;head&gt; so much. Basically I want to see if there's inline styles and what they are. (Plus table cell attributes like `border` etc if any).
This might yield some results: https://www.indeed.com/jobs?q=junior+javascript+developer&amp;explvl=entry_level
Great post, I've just begun to run into this problem (and many others) myself at my company since we're starting to roll out service workers for the first time. A few notes I've taken: - Unit tests work smoothly for testing only the service worker code. It gets tricky though when you communicate between the worker and client since you need to test the units in the client as well. The challenge here is that the unit tests for the worker code &amp; client code probably don't live together, and so some context is inherently lost. Code sharing can become a bit more of a headache than it should be here. - A lot of our internal tooling (both testing &amp; non testing) reference objects that service workers don't know about, such as window. I've had to fork &amp; shim one library too many at this point (does anyone even try to avoid side effects nowadays?) - Acceptance tests that run test A in chrome, but test B in some other browser. I'm sure there's a solution out there for this and I just havn't looked hard enough. - Sadly, I've already begun to see inconsistencies between the service worker API in each browser / browser version that supports them. It's been painful to manually test each new spec we use across browsers to make sure they work consistently. We need better service worker documentation, and we need an established, well vetted list of features that can be polyfilled, and features that need to be feature detected before using. This problem will only grow as specs evolve. - Not testing related, but error monitoring with something like sentry or newrelic is still an open question for us. Can we catch lifecycle failures (such as failure to activate)? 
Thanks for your answer. So one book can supply the other one, not like I'd read the same topics again and just wasting time, right?
Sadly I've found that the vast majority of companies want Java developers. :(
Sadly Java exists. 
I've got this book on my shelf and even had a chance to read it but my feeling are really mixed. 1/3 content of this book is something I've already knew before, 1/3 was really useful and 1/3 I don't really get. Guess I'll need second look on this book.
Nice. I tend to just use `create-react-app` these days without ejecting, can't be doing with configuring webpack! Nice to know something exists though.
I've forgot to mention one important thing: Resources about application architecture, Design patterns and knowledge how to plan your application, how components should talk to each other, make it scalable and maintanable, etc. all stuff that someone should to consider before jumping into code, these are my weak fields. Looking for good resources (books) on these.
I liked Eloquent JavaScript mainly for the code examples and exercises at the end of each chapter. The Definitive JavaScript is the best resource I've found to date that explains, in detail (the book is 1000+ pages!), what something is and why it works that way. He does give little code snippets to demonstrate, but the book's value is in the quality of the writing. It is excellent technical writing. The first 11 chapters are about the language itself. No browser or DOM cluttering up the explanation (that was a big deal for me). Then he has a chapter about server side JS (dated, but does make the point that JS isn't just for browsers). The next several chapters are about the browser. JS has changed since he wrote the book, but there is enough core stuff there to make it worth reading. I don't think I was able to properly separate JS the language from JS in the browser until I read that book. Now the language and the browser are clearly separated in my mind, which makes it easier to figure out WHY things work. Easier to reason about things. Good luck 
I don't even think that my company has a Jr position, it is just called "Software Developer". I would not worry too much about whether a specific job offering is for a Jr or mid-level or even Senior developer. You should apply to as many positions as possible and take as many interviews as possible. It's really a numbers game you have to play to build up your interviewing skill and experience. Yes, if you apply for a Senior role and land an interview, it's possible that you'll find yourself under-qualified and in an uncomfortable interview situation, but it will be a really valuable experience that will help you out a ton with your other interviews and in the future. (It's also possible that you land the job!) Good luck!
Doesn't work for me (Chrome 56, Windows 7). Console: `THREE.WebGLRenderer: Error creating WebGL context.` ` Uncaught TypeError: Cannot read property 'getExtension' of null`
Yay! All good stuff with web-workers. Those changes will help make using multiple threads produce even faster processing.
Yes! We are currently building it :-) https://firstdevjob.com/ It's specifically aimed at helping people find their first dev job(currently 76 jobs for junior frontend devs. Adding more every week). There are three parts that help with different aspects of the process: - **Jobs:** jobs for junior positions(through AngelList, HN etc.) - **Posts:** knowledge in the form of articles. (from learning to code to interview prep) - **Stories:** interviews of people who have successfully made the career switch to development from other careers. Happy to answer any questions!
I also suggest you checkout https://www.jrdevjobs.com/jobs#query=javascript&amp;page=1 They only post remote jobs.
As I suspect, what's happening here is the styles within the `&lt;style&gt;` tag are being removed and thus leaving your email body unstyled. Many email clients do this (GMail and Outlook are very aggressive at doing so, but iOS Mail.app leaves it intact for instance) for security reasons so it's not unexpected. To ensure this works you're going to have to inline the styles (preferably around the `&lt;td&gt;`s) which may not be an option for you. There are plenty of JS libs that do this, though, so you may be able to take that route. I've not worked much with JS in Google Docs to advise anything for certain. Related, I've built an app that enables you do this kind of thing, but although it's very cheap it's a paid service so much not be viable for your needs. Hope that helps.
When you're further into your career you'll get over this edgy opinion and realise Java is a really useful language. Even performance wise, it has the fastest web framework. 
d3 lets you use nonlinear scales, doesn't it?
Not sure why I expected a conversation here. What does "significantly slower" mean? There was one test that sucked, "replace all rows". All others were within 20-30% of react, which to a user means pretty much the same thing. And that's without doing all of the framework optimizations I could have done. Pretty much all of those frameworks seemed to be within 2x of vanilla js (except choo), so performance is no longer a primary concern, unless you generate tens of thousands of DOM nodes. Designing frameworks for 20% extra performance, while ignoring maintainability is something you do just to win benchmarks.
No problem. I have a huge amount of sympathy for anyone working in email. Most of my grey hairs were caused by dealing with email!
This. you shouldn't be storing the password in the database regardless. you should be storing some representation of the password - often time these are some kind of crazy hash that doesn't even look anything like the original password. it's been a while since i've done any password handling in my job, and things have changed - it used to be you'd just store the salt (but evidently that's become insecure as well?... citation needed). *(If you're worried about what you need to be storing in your database, there are scores of articles on google about the topic. I'm currently unqualified to give advice on it. There are tons of people here, though, that are more than capable though)*
Good effort though not very readable on an iPhone using iBooks
Often when someone wants to learn a language they focus 100% on that specific language, but if your goal is to be a great programmer it's imperative that you learn a lower level language like C to grasp datatypes and know why you might parseInt() in javascript or how data is referenced to pointers (the JS engine is written in C). I'd also recommend learning more about object oriented programming to understand how "this" works, you can do that looking at ES6 classes... if I were to add anything to your list I would set aside X-amount of minutes each day just to read up on lower level programming concepts as you go through your list 1-6, and add reading through the Javascript guide at [MDN Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) right after Eloquent Javascript.
20 yrs dev... Know better. 
Great video! Thank you! Would love to see another video that integrates two micro services using rabbitmq
"There are only two kinds of languages: the ones people complain about and the ones nobody uses" - Bjarne Stroustrup
I would go far as saying apply for senior roles anyway because even though you arent qualified and will probably get rejected, you never know who's looking at your resume. Source : I got my first junior position by doing this when my hiring manager didn't know he needed a junior position until he saw my resume 
3 book about prototypes ? WTF ? I'm surprised you can make even one (not a 10 pages book, we're talking *decent book*) book worthy of content with it. If you have time, learn C then C++ then learn how JS is made. JS will be a piece of cake if you pass the C/C++ hurdle.
same
You should probably let all the big smart companies know main stack choice is bad. You will be hailed as a hero. 
Unless you want to do oop in C, which is fun though, I advice you to learn oop with C++. You'd have to recreate all the features. I've done it, it's fun if you like it. Otherwise it's reinventing the wheel and it's painful.
I guess C# applies to, as C# has better use to me personally than C++. Unless they are different at OOP level.
yeah, there are multiple problems with the question and /u/bisteot’s answer 1. don’t restrict what data users can enter 2. don’t use shitty APIs that make injections even possible. use parameterized queries or an ORM 3. store only salted hashes, no passwords
Fair question. Job listing is just one part of it, two others are also equally important - Posts section has content specifically targeted at people trying to get their first job. Lots of practical advice. (more to come) - Success stories matter a lot. I personally find it really motivating when I read about people who were in my situation before and got where I want to go. YMMV, of course. Other than that, I am always available to help if anyone needs personal attention(questions about portfolio, prep etc.). I answer few emails like this every week. PS: It's my hobby side project. Not trying to compete with LinkedIn or anyone else :)
I agree, but search for front- every company handles our position differently (frontend, front-end, front end, frontend engineer, frontend developer, etc.).. also, if it matters that much, set a minimum of 40k to filter out front desk positions.
messed around with it yesterday but it honestly feels so barebones like i'm drawing the lines on the canvas manually, but i guess beggars cant be choosers.
&gt;I've decided to learn Vue.js Bro, buy this Udemy course today, https://www.udemy.com/vuejs-2-the-complete-guide/ It is a fantastic intro to vue/vue-cli/vue-resource/vue-router/vuex and webpack. &gt;Now, I spend a significant part of my day commuting, and the tablet I use for reading on my commute doesn't have mobile data connection Me, too, exact same situation. So what you do with that Udemy course is you download the Udemy app from your respective app store which will allow you to download the above Vue course onto your tablet. So you can watch the videos on your tablet. Trust me, do this today. Vue does have a low learning curve especially when you compare it to Angular. React is similar to Vue as well so you could make the move to React if you wanted without another huge learning curve. There's also http://devdocs.io/ which has the Vue 2 docs. You can enable offline reading for this. It's a great resource site as well, though last time I checked it only had Vue 2 docs, not things like vue-router, vue-resource, etc.
SharedArrayBuffer is something I really wanted to see implemented widely asap. Mutex here I come !
how about this. http://www.cprogramming.com/tutorial/c-tutorial.html Really, there are a ton of material on the net concerning C, just search a bit. For the book, I don't remember the name, mine are covered in dust somewhere in a box, if you're patient, I'll send you the names later. But you don't really any book, everything is on the net.
Agree with this one. This one goes over everything you probably learned, and digs a little deeper. Most importantly, it is easy to read (unlike, for example, Crockford's *JavaScript: The Good Parts*). 
Would love some feedback on the general approach here. My goal wasn't to build out a giant boilerplate, and I'm wondering if you think this would be useful, misses the mark, or has some areas I could improve on to make it more accessible.
Can't recommend egghead.io enough. 
Try Angelist. Many startups looking for junior devs there.
That's awesome. Is there a way to make it list only remote jobs? I don't have the financial means to move to those places, so for the moment I can only work remotely, unless the job is in my area, which is extremely unlikely.
I recommend [Javascript Allonge](https://leanpub.com/javascriptallongesix/read), it is free and is very good at explaining functional javascript. There's also an ES5 edition that's free online. I found it through ["12 Books Every JavaScript Developer Should Read"](https://medium.com/javascript-scene/12-books-every-javascript-developer-should-read-9da76157fb3#.ngc5mj28z)
Play
Learn Typescript, it's the Java version of JavaScript - strong types. If you know that you'll understand Java well enough to pick it up quickly. Better yet just learn all three!
Seriously? In 2017? But why?
But no, this is all wrong.
 document.getElementsByTagName('video')[0].addEventListener('ended', function (e) { this.parentNode.removeChild(this); });
So.. Did I miss it, or am I correct in that nowhere in that article does it detail what qualifies a library version as 'vulnerable' ? We're talking about front end js libraries here, what exactly are the security concerns? Unless the library itself is malicious, I'm having a hard time seeing the problem. This article was interesting as a curiosity, but I'm clueless on what's being referred to when we talk about, for example, a version of jQuery having a vulnerability that raises a security issue. 
works for me
That page was horrendously slow, perhaps have a look at the KISS pattern for once. 
Monster, indeed post: jr js dev needed: requirements 2 yr web dev xp. Xp w/ nodejs, angularjs, magneto, something I've never heard of, etc
Yep, that's not a bad list. Here's my overall recommendations (which I usually gave for people who are starting out, so YMMV as needed): The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
The article uses the same definition for *vulnerability* as the source article: &gt; The last step towards building our catalogue is aggregating vulnerability information for our 72 JavaScript libraries. Unfortunately, there is no centralised database of vulnerabilities in JavaScript libraries; instead, we manually compile vulnerability information from the Open Source Vulnerability Database (OSVDB), the National Vulnerability Database (NVD), public bug trackers, GitHub comments, blog posts, and the vulnerabilities detected by Retire.js. Overall, we are able to obtain systematically documented details of vulnerabilities for 11 of the JavaScript libraries in our catalogue. 
Very cool, thank you for your help!
Cool! I'll definitely use that in the future. Thank you! 
Interesting: So now after my video completes, I can't click to play the same video again. Is there a line of code we can add to refresh the page after the end of a video?
I saw that in the article, it notably does not contain the definition. But anyways, moving to the source as you pointed out &gt;One specific, significant attack surface are vulnerabilities related to client-side JavaScript, such as cross-site scripting (XSS) and advanced phishing So the main example it gives is XSS, which is kind of what I was assuming and is the part I'm skeptical about. Shouldn't the server be in charge of that? So if not, what we're saying is that the only thing keeping your users secure from malicious scripts injected by other users is the jQuery that prints it out? The assumption is that you'd actually be storing the malicious code in your db and depending on your client to secure it on every single user visit, forever. You'd be just as susceptible to future library versions or your own bugs. What if a browser extension conflicts with something? One break at any point in the future, and all of a sudden every script injection ever attempted is suddenly active for every user. The whole premise is ridiculously, you really want to be cleaning this stuff up when it comes in, not after it's gone out. *** One valid example I can think of is if you have a client that is loading content from an external source which you do not control. If you want to protect your users from that source, sure, makes sense. But then we're getting into the topic that the vulnerability is context dependent, and entirely irrelevant on many websites. Point being, these statistics on widespread usage of 'vulnerable' library releases is kind of worthless when the vulnerability only applies to certain types of websites with certain features. Good to know if you're implementing such a thing, but indicates nothing about any widespread issues with the web. 
I would love to do away with the dreaded undefined errors. However, it will be tricky to decide whether we'll include null also. What about other falsy values? Existential check in Ruby does check for null also, which I don't think would work well with JS. 
Personally, I would include both undefined and null as they both represent nothingness. Likewise, I think only true falses should be includes. I mainly use existential checks to see if it's safe to perform some operation on a target like `someString?.length`, `input?.focus()`, `someArray?.count`. Falsy values are okay because you can still check for length of an empty string/array.
Looking at what others do isn't a bad thing, even if it is paid software. Siteleaf does a lot of things, including hosting, which always cost money. 
"Electron Creator"? by that same logic i'm Firefox Creator...except no, no i'm not.
that's excellent advice as this course aims most part of my weaknesses and I can pair it up with advices from guys below about taking a look at C. Thanks for that.
There hasn't been a better time to write Java with Java 8 well established and Java 9 on the horizon. Personally I don't, but I do use the JVM.
The language isn't that useful now that there are plenty of better JVM languages, but it gave us a good VM and tons of great libraries.
Thanks, it's not exactly what I want but I'll be able to build my service with it. I'd known about ActivatedRoute but didn't realise the params were an Observable, mostly worked with snapshots.
Yeah, that was a weird misrepresentation.
It sounds like [this from AngularJS](https://docs.angularjs.org/guide/security) would be classed as a vulnerability; that if you allow user generated templates or eval user generated expressions then your app is vulnerable to XSS. Well, no shit.
&gt; I'd also recommend learning more about object oriented programming to understand how "this" works, you can do that looking at ES6 classes... That's the common point of confusion though... `this` doesn't behave as it does in common OOP languages and ES6 classes are syntactic sugar to make js look more like classical OOP.
I am fine with using lodash .get(). 
Agreed. And, more importantly, a situation like XSS was always a vulnerability. The library in question didn't become more insecure...
I'd love to see some performance benchmarks like we have with DBMon.
No prob. Lemme know what you think. I made my own fork and put my solutions up, so if you wanna look [here's](https://github.com/cmatzenbach/Introduction-to-Node.js) my repo. They have the solutions for the main files up, but not for the unit tests, so if you get stuck feel free to look at mine. They do give you enough hints though so try to work through it (took me some time on the unit tests) :) Everything's in the my_work folder btw
I ditched Gulp for npm scripts on certain projects a couple months ago and I'm glad now that I did it, but it wasn't as simple a switch as I thought it would be, and there are definitely limitations to it. There's a point where your build 'scripts' (commands) get too complicated and need to become actual JS files and at that point you might as well just use Gulp or something similar.
Highly recommend http://wesbos.com/courses/
Hi! I subscribe to a few different JavaScript subs and try to post a variety of things to each of them, seems as though I overlooked this one (probably because it's general JavaScript rather than a more niche category). Sorry for the oversight I'll be more wary of this going forward!
I used [AngelList](https://angel.co/) extensively during my search. Startups are a great place to look for a first dev job.
Isn't it more browser than library vulnerability? 
&gt; While web assembly is keeping to evolve, do you think C/C++ will be a standard for web developers in the next 5 or more years? no? &gt; So.. what do you think? I think you're vastly mistaken about what webassembly is.
&gt; As a web developer, Is C/C++ important to learn? Absolutely not
More often than not, things are getting useful when you need them. In my opinion, just read what interests you now, jump from chapter to chapter but don't try to read a technical book from cover to cover as if it were a novel! Nevertheless, keep the book within reach. It's usually when you face a specific use case that you'll appreciate an elegant way around it!
Keith Cirkel had a good [post](https://www.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/) about this (back in 2014 even). I wholeheartedly recommend it.
i like using npm modules instead of raw shell commands ([trash](https://github.com/sindresorhus/trash) instead of the native counterparts, for instance) for this exact reason. 
The authors have an "about" page... https://theinitialcommit.com/about/ 
Maybe if you aim to be in the frontlines of games or AR/VR targeting web and work on the low level frameworks, but otherwise it is unlikely.
This is satire, right? You're creating your own build pipeline as your build tool, and it's more complex than using the build tools with a DSL or simple API for the plugins that do precisely what this NPM script does.
I would argue it's better to use the command line utilities when you're doing things within the scope of the command line utilities. You probably shouldn't be using task runners if your task can be condensed to _node-sass -w dev/sass -o app/css_ - you're drawing in a bunch of dependencies and creating a bunch more potential points of failure to do something the dedicated tool can do simply and easily. If you're running a full CSS production pipeline - sass to postcss to cssnano to whatever and beyond - a task runner can make that a lot easier, and has the added benefit of being much easier to grep than a single line in your package.json. But basically do whatever you want. The post is "you might not need," not "you should exclusively use."
Cleaning it when it comes in leads to double escaping though. I think with modern front end frameworks like React there is no reason to escape it server-side.
make, fake, cake, grunt, gulp, npm, bash [scripts], batch [scripts], msbuild, etc are all command-line and capable of the same things. Minus nuances (like platform compatibility, how they are configured, etc), the only differences are what your dependencies are, and where they come from. Tools exist to help us and make our lives easier; kludging a package manager into a build tool is, one, **still using a build tool** and, two, making things more difficult with no real advantage.
Ahh I was closing the `mergeMap` bracket too early! Thank you! I've tried to use RXJS's ajax methods but they seem so poorly documented that I'm resorting to making an observable of the fetch call. The problem I'm having now is even when the fetch errors out, it's being mapped to loginSuccess rather than triggering the catch. Is is viable to use this inside mergeMap: `let auth = Rx.Observable.fromPromise(fetch(api, {options))` and then `auth.subscribe(() =&gt; loginSuccess(), e =&gt; loginFailed(e.statusText))` It seems to tell me im providing 'undefined' instead of a stream. Edit: I think the problem was the promise is resolving, I'm just not handling when the `response.status !== 200`. 
K&amp;R The C Programming Language is probably the most widely recognised resource.
:) I wrote that article. Thanks!
You should always be cleaning input on server-side no matter what you do on the frontend. You don't know where else it might get used or they could be doing something that targets backend code ("; DROP TABLE anyone?).
Sorry, my mistake, it is in fact Gruntfile.js.
I maybe agree with you if "NoSQL" == "Mongo", but there is a huge range of very high quality data storage and indexing solutions that are not SQL and often the right tool for the job. Here's a very incomplete list of extremely useful "not SQL" data storage and indexing tools: Elastic Search, Reddis, CouchDB, neo4j, influxDB, hstore and JSON in Postgres, S3, plain old file system. RelationalDB is not always the right answer.
.
the problem, as the error message quite clearly states, is that you have not created a task named `default`. the fix is to create a task named `default`. please consider reading the grunt manual. 
The only reason I can think of C/C++ being even remotely useful for web dev is that it gives you an intro to learning golang
I clicked on the link to the [personal site](http://jlord.us/about.html) that was given, and they had this quote on their Work History section: &gt; Most recently I was a desktop application Node.js engineer at GitHub where I started the Electron team. During my 3+ years at GitHub I also worked on Atom, github.com, and front-end design projects... So she might be? idk
so server doesn't clean the posts, but vulnerable jQuery? If I don't use JQuery (pure JS), is my site more secure? Unless jQuery of those versions used `eval` to parse JSON, we only can blame library in not patching browser's bugs. I think it should be solved by 1) by communication protocol 2) language (Javascript) 3) Browser 4) Server 5) www governance 
 chrome://settings show advanced settings under the system section, check "Use hardware acceleration when available" restart chrome.
This is very well written and easy to follow! I might try and do a serverless setup for my next project and this guide will be invaluable.
[removed]
Is there a built-in solution to keep functions running? i.e. to ping them continually. And is it a few hours, not a few minutes? If you have many functions/endpoints, there may be a high likelihood of requests encountering the 200ms setup. The person I talked to is the founder of a Serverless startup (https://www.graph.cool/). It was a few months ago. They chose to build the actual web endpoints on docker, rather than Lambda, for the precise reasons I'm stating. You're telling me it's blazing fast to ping lambda/api-gateway endpoints? I think as soon as it's not a problem, it's gonna become extremely popular. I want to use it, but if the 200ms setup is still a common problem, and perhaps worse than what you're saying (i.e. occurs after a few minutes rather than "hours"), it's a no go. Are there any performance benchmarks? 
For people interested in cross-domain postMessage calls without React, can I plug my own project called [PM.js](https://github.com/ajbogh/PM.js/tree/master)? I don't want to take away anything from this post, but it's a good alternative and maybe the developer of xcomponent would like to use some of my ideas. For the record, I used to work for Disney and created their cross-domain login system used by Disney Infinity, Disney World, Disney.com, ABC News, and we demoed a couple times for ESPN before my contract expired. &gt; Post messaging doesn’t work consistently across different browsers, especially between parent windows and popups. [PM.js](https://github.com/ajbogh/PM.js/tree/master) handles this. &gt; Post messaging is also fire-and-forget, with no good built-in way to see if a message got through, handle errors, or get responses for our messages. PM.js has error handling too. &gt; Loading iframes after a page render is really noticably slow. PM.js allows you to preload iframes &gt; Passing down data to an iframe involves serializing everything and putting it in query params in the url — or by sending race-condition prone post messages, when you think the iframe has loaded. PM.js handles race conditions using "ready" events. Just fire the event and the async response will occur when things are ready.
I think you have it a little backwards. Today JS is a great language for defining front-end. This is why it's currently conquering mobile and native. Many of the desktop apps people run everyday are already based on web technology. It could come in handy for complex calculations, game engines, constraint solving, physics, legacy libraries, lower-level back-end stuff basically, etc. But other than that, these languages, including the others like C#, would look pretty silly or even choke if they wanted to create rich user interfaces.
I don't think the whole industry will just switch to using webassembly just like that in a snap of a finger but to be honest, I wouldn't be surprised if companies started expecting frontend devs to know C/C++. Many companies in my area seem to prefer employees with knowledge of dozen of frameworks and even Java on top of that over devs who focus on less things but do it right.
Could you be a little more specific?
Anyone got decent tips on animations and transitions in react?
Yes but much cleaner and you can read a foreign code base much easier. I think it is fine to use it in personal or small hobby projects. But when you reach a certain size of code, this becomes very very annoying, because if bugs appear, **and they will**, it is extremely hard to debug Dependency Injections.
Am I missing the dataset containing all framework versions they count as vulnerable?
Nice! Might use this :)
I don't think you're taking into account the possible damage to a brand that this might incur. To newspapers there's no difference between "React vX.Y.Z is vulnerable" and "Facebook is vulnerable" - except the latter is something the public can understand. There are plenty of XSS scenarios that can look very bad for a company, so as developers we should probably pay more attention to what versions of what libraries we use.
It is their definition (not mine) regardless of how much you don't like it. For some reason when non-security non-managerial technical people hear the word security they immediately jump to *leet haxor* and need immediate examples of compromised systems or malware.
 (function () { if (typeof(Yamli) == "object" &amp;&amp; Yamli.init( { uiLanguage: "en" , startMode: "onOrUserDefault" } )) { Yamli.yamlify( "arabize", { settingsPlacement: "inside" } ); //Please note that "arabize" in the function call above is an id to the &lt;textarea&gt; tag above } }()); Now it executes without a call, so you can put it into an external file.
So.. which part is wrong? I never said anything about UI, you can't trust your UI to escape anything. It doesn't matter where it came from, you clean it at the server level. If it's cleaned when you store it, anything beyond that is precautionary/redundancy. 
XSS doesn't happen because of eval. XSS happens because of innerHTML or server-side rendering without escaping. And innerHTML is most likely what you'll use if you don't use a library.
I really like the look of this. I can see it having a few really good use cases.
This is the whole code if it would help: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; .button { background-color: #1a8cff; border: none; color: black; padding: 12px 15px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer; } &lt;/style&gt; &lt;script&gt; function setValues() { } function beräkna() { var takyta = Number(document.getElementById("Takyta").value); alert("takyta"+takyta); pris.value =takyta*1942.63; energi.value =takyta*135; var elpris = Number(document.getElementById("Elpris").value); var takyta1=parseInt(takyta); var solpanelpris = Number(document.getElementById("pris").value); var energi = Number(document.getElemenyById("energi").value); var tjänar = Number(document.getElementById("tjänar").value); solpanelpris=takyta1; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div align ="center"&gt; &lt;p&gt; &lt;input name="display" id="Takyta" placeholder=Takyta(m²) style="width:127px; height 60px; text-align:right font-size:30; border-radius:4px; margin:3px"/&gt; &lt;/p&gt; &lt;p&gt; &lt;input name="display" id="Elpris" placeholder=Elpris(Kwh) style="width:127px; height 60px; text-align:right font-size:30; border-radius:4px; margin:3px; margin-left:100px"/&gt; &lt;input type="button" class="button" value="Beräkna" onclick="beräkna()" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;Pris för solpaneler: &lt;/label&gt; &lt;input type="text" size="5" id="pris" readonly /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;Energi per år: &lt;/label&gt; &lt;input type="text" size="5" id="energi" readonly /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;Hur mkt du tjänar per år: &lt;/label&gt; &lt;input type="text" size="5" id="tjänar" readonly /&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
That wouldn't work: const B = () =&gt; ` &lt;h1&gt; &lt;${A} color="red"&gt; &lt;span&gt;hi&lt;/span&gt; &lt;/${A}&gt; &lt;/h1&gt; ` Both starting and end tag receive the full function body. What is this even supposed to mean: var a = function ({ children }) { return `&lt;span&gt;${children}&lt;/span&gt;` } var b = `&lt;${a}&gt;hi&lt;/${a}&gt;` // "&lt;function ({ children }) { return `&lt;span&gt;${children}&lt;/span&gt;` }&gt;hi&lt;/function ({ children }) { return `&lt;span&gt;${children}&lt;/span&gt;` }&gt;" Then `A` would have no idea that it's supposed to receive props and children. You'd need a runtime parser to make sense of it. And it still has all the downsides from above. I couldn't imagine something less equipped for making UI than string literals to be honest.
Huh? You mean, like moving the content of the second `&lt;script&gt;` block to a file and refer to it in the same way you did in your first script block?
hey! 8 days late but thanks for the comment. Yours got me thinking and self-reflecting about readability vs micro-optimizations. Like you mention, .map is the most readable yet if I need to iterate more than once, I find myself questioning whether I should run multiple .map methods. FWIW, in my case, I did end up using .map's and and much happier looking at the code now. Like you said, these optimizations are non-existent and come at the expense of readability. How big would a data set have to be for you to choose the micro-optimization over readability? I know I could playing around with jsperf but I'm curious about your answer.
As a recent CS graduate who's been programming for 5 years, and has just started trying to learn Javascript through Codecademy, one thing I've been concerned about is precisely what you've just mentioned. It holds your hand a lot. I'm not sure if that's a good thing or a bad thing at this point, but one thing I do know for certain is that it's important to know how to think as a programmer, rather than just knowing a single language. I've been able to pick up the basics of Javascript fairly quickly due to my knowledge of how programming languages typically work. I shall try to give you some suggestions: Try and learn the concepts. Most languages use similar concepts to each other. Common features include: * Control structures (if-else statements, while and for loops, switch statements, etc.) * Arrays and Lists (groups of values that belong together) * Objects/Classes/Structs (ways of grouping data together) * Using functions/procedures/methods (whatever the language calls them) to allow you to reuse code, rather than copy and pasting the same code everywhere. Once you know these concepts, learning a new language becomes a matter of learning how those concepts translate from Javascript to Java, or to C/C++/C# or whatever you move to. You learn language-specific stuff as you go along. Three more suggestions: 1. When you follow a tutorial, try and figure out the reasons behind what they are doing, rather than just blindly copying what they do. You can always google how to do something, but you won't know to google that if you don't know what you're trying to accomplish. 2. Find small projects to do, and try and solve them in code. When you don't know how to do something, Google it, and try and see how you can do it. Google (or Bing, or Yahoo, or whatever) is your friend. A lot of programming is knowing how to look up how to do something you can't remember. 3. After you have a bit of a handle on one language, try to learn another one. (Maybe a typed language, like Java, C#, or if you're feeling really brave/crazy C or C++) This will help you go from someone who can do some stuff in Javascript to being a Programmer. I'm sorry if this seemed rather unstructured... it's late here, and I'm sorry I can't think of any one place to point you to for quality learning. I learned to program at University. Hopefully others can recommend excellent material for you to learn the art of programming.
Dumb question but what's a practical use case for this? Not familiar with python's range function and I see your v-for example at the end of your readme.
... have you considered reading their manual? because it turns out i'm not aws, i don't get paid by amazon to give tech support, and i'm also not google. these things are all very easily looked up. if you wait on reddit to do these things for you, it'll take you 22 hours to get yes/no answers that you could get under your own steam in minutes. also very often the reddit answers will be dead wrong. . &gt; If you have many functions/endpoints, there may be a high likelihood of requests encountering the 200ms setup. no, that's not even slightly how it works. they're all in a single package together. you're making up problems that don't make sense because you don't know how the platform works, and are trying to out-think your imagination so that you can show to everyone how a platform you don't understand is bad. it's really annoying. . &gt; The person I talked to is the founder of a Serverless startup well, either they don't know what they're talking about, or you did the same jumping to conclusions incorrectly with them thing that you're currently doing with me . &gt; They chose to build the actual web endpoints on docker, rather than Lambda, for the precise reasons I'm stating. well, then either they don't understand lambda, or you don't understand them notably, serverless doesn't do anything with docker, and serverless very heavily stees your architecture from day one, so the story you're telling me doesn't really make a lot of sense to me . &gt; You're telling me it's blazing fast to ping lambda/api-gateway endpoints i didn't say anything on the topic in either direction, and also, i never would "blazing fast" is a stupid thing to say. people disagree about what number that means, the thing you build might be terrible, lambda hosts multiple programming languages with differing consequences, it has a lot to do with your choice of call architecture, et cetera what i actually said was that the claims you were making were false please don't put words into my mouth so that you can argue with them . &gt; I think as soon as it's not a problem, it's gonna become extremely popular. the problems you describe never existed, and it already is extremely popular . &gt; if the 200ms setup is still a common problem, right, because i didn't already tell you that you were completely wrong about this, so it's reasonable to keep being worried about it frankly, i think you're mostly just talking. if you were as worried about performance as you say you are, you'd probably know that docker imposes *significant* network overhead through its `fabric` layer (oftentimes north of 60ms,) and you'd have checked whether the author of the service you're looking at had produced something fast (which, of course, he hasn't.) . &gt; Are there any performance benchmarks? what did google say when you went looking on your own? oh, right. you didn't http://lmgtfy.com/?q=aws+lambda+benchmark notably, it would have been much faster for you to go through their seven line tutorial and then just measure the response speed than it would have been to spend 14 hours asking questions here and making up news-style alternative facts if i get on my us-west-2 ec2 instance and ping my us-west-2 lambda endpoint, i get responses in under 20ms real world attempts will be dominated by network time. if you try that from home, your request won't even get *to* amazon that fast. if you're measuring speed, measure from the same datacenter. but let's be honest. you're not going to measure anything. you just wanted to be able to pretend to understand the downsides of lambda.
 **[The comment above likely has (one or more) prank links]:** "Rick Roll" ___ _^^#bot_ 
I like it for the sheer potential of extensibility which JS seems to catalyze and the possibilities that ensue. Running circles for me means [breathing live into dead output](https://github.com/vshatskyi/black-screen/raw/master/README/json_decorator.png). Running webpages inside the terminal by clicking links. Using trackpad to scroll through git diffs, etc. There are tons of plugs that make a pimped out zsh look pretty old. If a native app decides to go for a special feature, to actually get there means an odyssey in frustration for the developers. Native extensions for instance are rigid, hard to implement and set up, weak in what they do. What their community has produced in 5 years, Hyperterm has had in a week. JS can just take it in, npm either has it fully baked or node gets it in a couple of lines. I love this about JS in general. You can't easily compare languages like lua, c++ to JS. It has drawbacks for certain, but also does things other languages simply can't due to their minor communities or major inflexibilities. When that potential gets to other platforms you see an impact. That's why node floats over .net and java, or why it's getting ready to hop into mobile and desktop. Only the means aren't perfect yet but this will be fixable.
Maybe something like https://panopticlick.eff.org/ https://github.com/jackspirou/clientjs looks good.
It was built with Serverless functions in mind :)
Agreed, I wasn't claiming that cleaning on the out isn't good practice, just that it isn't strictly necessary. And yes, I was talking about UI, but only to make the point that escaping on output alone is inadvisable, as the person before me had made the claim that there was no reason to handle it on the server. 
 function change () { var image = document.getElementById('video-thumbnail-img-1'); image.src = "images/thumb1_color.png" setTimeout(function() { image.src = "images/thumb1.png" },5000) 
You could do something like this. I changed to use fetch instead of ajax. [JS Bin](https://jsbin.com/zenaxaresu/2/edit?js,console,output)
I don't know what exactly doesn't work for you. Here is a JSfiddle with your code: https://jsfiddle.net/0cavzqdq/1/ Seems to work for me. Only thing I had to change was the HTML onclick-attribute into attaching the event listener via javascript, since JSfiddle loads the javascript inside window.onload and therfor the HTML onclick-attribute doesn't find the function. For debugging use the developer console. (press F12 in any browser)
I'm not too familiar with Vue, what is the advantage of this being a plugin as opposed to a regular [function](https://jsfiddle.net/5c3z33wa/1/)?
I guess in a more general sense my question would be what is the benefit of a plugin? Do I have to wrap all the functions as plugins to use Vue? Thanks
There's definitely nothing wrong to go with PHP, but i wouldn't recommend it specifically. Every language should be suitable to do that job. Back to your initial question: There's nothing wrong to go for javascript in the backend. IMO meteor is overkill if you don't have a realtime requirement. There are several advantages* to use js for this job: - you have a long running process that can do stuff in the background (e.g. the scheduling) - you have the responsibility to manage this process properly (restart/graceful reload) - different (better?) request handling in comparison to PHP You can pull out a lot of learnings from using a different language than one you already know. * these are also disadvantages. Make youre mistakes and learn from them! 
If I'm being honest, I've never had to work with big data before. Which is really sad because I have a degree in pure math from a university with a strong math program, so it seems kind of like the thing I ought to be doing instead of pushing paper for a living. :) I imagine I'd run a bunch of tests, but personally if I were working with truly big data, I think I'd seriously look at a microservice that is written in C or maybe Assembly if I wanted to ensure job security for a long time ;) If my company were talking about this and what language to use, I'd probably start from the position of advocating something other than JavaScript rather than being like "hell yeah let's do a Node.js app!" (the Assembly part was a joke btw - one time I disassembled some DLL for a big energy company to reverse engineer the engineering algorithms that were in it but the source code had been lost, and I felt like I had attained buddhahood)
Thanks. Let me know if you have any questions or if you run into any confusing parts.
N, You don't have to. I just did it that way as I wanted to make it more useful - instead of importing it in every vue component, you can just simply install the plugin and use funtion in all other components
If you own the content being loaded in the iframe, you can modify its Window prototype (in the src file): Window.prototype.new_prop = 'this is strange'; However, you would need to wait for the src of the iframe to be loaded for `iframe.contentWindow.new_prop` to be accessible. iframe.onload = function () { console.log(this.contentWindow.new_prop; }
STOP. OVERLOADING. COMMON PROGRAMING TERMS. Have fun googling that "component manager".
Hmmm interesting point. How do you think it might be better described? I tried to use the most basic and straightforward words to describe Bit. Well, it's open source and it's a manager for code components. I will really appreciate it if you help me come up with a better way to describe it? 
Even with tools like Nodemon to automate it, having to continually restart a whole program sucks! Not being able to automatically update just the bits that change is something that has irked me for a long time. If you already strive to write in a self-contained functional style that minimizes errant state, I see no good reason for your projects not to update on the fly. The other day I decided to revisit the problem of live-updating JavaScript modules, but this time see what's the shortest possible bit of code that is aware of changes to its source file and updates its `module.exports` accordingly. This is what came out. Since it's so short and sweet, I'm now sharing it with the public to see if anyone finds it useful. Or perhaps finds any flaws with it - all criticism is welcome!
Iframe is an friendly iframe, so no src attribute. Also I don't have access to the content being written into iframe and the property must be accessible before something is being written into it.
&gt;I wanted to loop through numbers, say from 10-30. You can't do it in v-for without doing that in a function. Cheap and hacky, but do'able, https://jsfiddle.net/cvru1aqw/ of course the style binding can be outsourced to a function, so it sounds like you've been down this road. Couldn't get it in the string interpolation with a similar ternary, it would output empty `&lt;li&gt;` bullets for the first 9 entries. You should submit your `range` method to the vue team. I think Evan is on this forum.
Oh damit, you are right. I had an extra c in my callback function: function DropzonesSuccess(successtype) { alert('got here success ' + succcesstype); } I am still a bit confused as to how javascript knows the scoping of the variables two functions deep like that, but at least it is doing what I want. Thank you!
&gt; As written, this should work You are correct, I just had a typo and was confused by not really understanding the code I wrote. Thanks!
It sounds like you have a lot to learn about programming in general. Good luck!
Haha, that's funny. I'm 50 and I got my first job programming 8080 assembly when I was 16, been programming professionally ever since. But always lots to learn!
That's certainly true from a PR standpoint. The fact is, none of these libraries can be vulnerable to xss without a server sending them data containing a vulnerability in the first place. I agree we should be more aware of these things, I just don't like sensationalist headlines.
Games, photo/video editing, audio processing; anything that requires higher performance than what JS can deliver really. Also, [DOM access is coming](https://github.com/WebAssembly/design/blob/master/GC.md).
Even without DOM access I could see it being useful for: * Crypto * Math like Matrices and Transforms * Compression * Advanced Data Structures * Image Manipulation
This is awesome. Great for onboarding new devs (instead of just "Check this list of 20 NPM scripts, figure out the differences between our 5 test scripts"). Gonna give this a shot!
So, if the data is only coming in a .xls file and you truly only want to program in JS that will be executed in a browser, then you're kind of S.O.L. In short, you would need to understand how to read a file locally and convert its base map into something tangible. However, I did find this old stack overflow post that covers that exact concept (http://stackoverflow.com/questions/8238407/how-to-parse-excel-file-in-javascript-html5), but who knows what cross-browser issues exist with the underlying architecture. More than likely this will work 100% in IE, but it may fail in other browsers (Chrome/Mozilla/etc). I would first give that a try. Otherwise, if you only care about supporting IE, you could use Microsoft's activeXObject to open Excel and then just read the contents directly through Excel's API. e.g. (again note this would only work in IE on a computer that has Excel installed): var excelApp = ActiveXObject('Excel.Application') var someExcelFile = excelApp.Worksbooks.open('C:/someExcelFile.xls') console.log(someExcelFile.cells(1, 1).value) excelApp.quit() see =&gt; https://social.msdn.microsoft.com/Forums/vstudio/en-US/3a3f7161-3581-47d1-a79c-98c0351ece38/how-to-launch-excel-application-from-client-side-javascript-?forum=netfxjscript
I changed my `setNext` to `this.head.setNext(this.head.getNext())`. I no longer get the `too much recursion error`, but now it only adds the last item pushed (or, the print function in my Node object is not printing every node in the list).
There have been a number of such articles and tutorials on the web for a few years now outline all that. https://github.com/WebAssembly/design
The name doesn't bother me, but I need to see some solid use cases solved with bit. I'm having trouble seeing why I'd use it instead of yarn/npm/bower. Does it just skip the install step? When I a send project to a friend, how do they get all the bits I used? I don't get why tests are mentioned, is the documentation being preachy or is that a core part of bit for some reason? Same with JSDoc, is that a core part of this? Why?
No, how do I import this in JS? src="http://api.yamli.com/js/yamli_api.js"
The idea began by trying to avoid duplicating code across repositories. After trying to use NPM as a reusable snippet database, we gave up since it was taking too much time to be practical. So, we thought that if we are going to build a way to make components reusable more easily and quickly, then this tool should also manage them like small components. So, Bit is different from NPM (and others) in a lot of ways, but mostly because it doesn't handle packages - but rather small components. We lowered the barriers to publish of initial configurations, we used simplified incremental versioning, faster dep resolution (on export) and decided that it would be best if Bit also took care of build and test. Philosophy-wise, we wanted our components to be "good to go". Collaborating is pretty easy after you've set a joint Bit Scope (where you store, manage, test etc.) your components. You can also connect Scopes to one another... Bottum line - small components are not packages, so Bit was built from scratch to manage them differently. Does that make more sense?
you need to save the old head push: function(data){ var oldHead = this.head; this.head = Object.create(Node) this.head.setData(data) this.head.setNext(oldHead) } 
And how did it go? :)
Oh you... 
BIT ? Why not BYTE or OCTET ? Shorter ? I think I'll call my next calculation program FLOAT. 
Well, we spent a lot of time thinking about this name, it wasn't simple. BYTE was an option, but when you read it it sounds like biting... We loved Bit because bits are basic units of information. Bit was built to handle the most basic units of logic. In the voting it was either that or "Sloth" so we ended up with bit :)
You should just be able to install mongodb as a windows service. ``` mongod.exe --dbpath="c:\data\db" --logpath="c:\data\db\log.txt" ``` then type 'services.msc' into windows start bar. Find mongodb service -&gt; right click -&gt; properties -&gt; set it to automatic and make sure the service is started. I usually use mongoose when working with mongodb so you might want to check that out! http://mongoosejs.com/
Not bad at all actually. I get the message too
It's worth brainstorming for a while. A name is serious business. Write down words with some people, anything that can describes the program, then mix it randomly. Try to compare your program to stuff in real life. The trick is to reduce as much as possible the size without losing the concept :P. That's how I would do it. For conductor, I was thinking about something that manages, organize and brings other things back and forth. Loving classical music did influence that pick though, that's why it's worth bringing other people in the brainstorm session. 
You can. In fact node does this with their [util.inherits](https://github.com/nodejs/node/blob/master/lib/util.js#L922) implementation. But generally you don't need to. If you're setting up inheritance between classes, you use `class` with `extends`. If you're creating a new object that is to inherit from another, you can use `Object.create`. Ideally you want to avoid changing the inheritance of an existing object from one thing to another.
Design a website/app in your head. Write down what you think 'done' means to you. Break that into smaller parts. Maybe you said 'done' meant a user could submit a form. Break it into 'create a form' and 'create a user'. Break those down into their smaller parts. 'create view for form', 'create server for form' and 'create user sign up', 'create user database'. Keep breaking each piece of what 'done' means up until all you are left with are questions that you can google and find the answer on stack overflow or some tutorial. From the example above of form: - Put `form` element on screen - Know when form submits - Gather values from the form that was submitted - Send server the form data in the format that it needs All of those are questions that all applications are going to use ( putting text on a screen, interacting with user input, talking to the server ) and all of those are questions that you can google or maybe break down another step and google, and have a plethora of code/tutorials. Now if you want to use Angular or View or React or whatever library/framework, you still have to answer those questions but you can say `Put 'form' element on screen using Angular`. The steps are going to be the same.
Are there any examples that show dependencies? For instance, think about Lodash. If I want to use an array function from Lodash, it may have an internal dependency on Lodash collection. How are dependencies managed? Will I be able to just import lodash/arrayfunction, or will I need to include all of the internal deps too? 
OOP paradigms are useful when you have data and functions to operate on that data which need to by tightly coupled, especially if the data may have relationships to other data in the system. Functional paradigms are useful when you have a data you want to operate on with a series of functions, especially if the intermediate state is not important, or if avoiding side effects is useful. In reality, both paradigms are almost always helpful, and they work well together. It's rare to run across JS (or non-JS!) code that isn't partly OO *and* functional, and for good reason. &gt; Recently I've seen move toward taking state out of UI components and moving it to a central place That's a good design principle for both OOP and functional code. &gt; wasn't one of the rules of OOP keeping state of an object hidden from the world? Sure, but another rule is separation of concerns. A redux state tree or a mobx store or whatever is a perfectly good OOP object. :) And just because *your* internal state might be hidden doesn't mean that all state for the entire application should be "yours". OOP is about objects working together. &gt; Is OOP bad for an application with complex UI? Complex UIs are typically solved with OO; FP driven UIs are very rare. &gt; Some libraries/framework recently advertise making application/UI state central and immutable, is that against object-oriented concepts? Immutability is largely tangential to OOP, but overall the change is closer to adhering to the principles of SOLID, and is more OO. It's certainly not *against* OO. TL;DR: Your questions are driven by the notion that OOP and FP are on a spectrum, and that it makes sense to ask "where are we on the spectrum", "which direction are we heading in", "what position on the spectrum is best for solving this particular problem". They are not opposed, and there is no spectrum; they're both useful tools to apply to whatever you're working on. If you're trying to decide between, the answer is generally "yes".
can you explain?
Hard to argue with you there - we primarily build [server side] microservices at my current job. For other projects, the largest app I work on is still &lt; 3k lines of code. Perhaps I wouldn't have lasted 6 mos on larger apps - I'm not really sure.
Looks like [HTML5 spec](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Security_considerations) has the same opinion as I am. &gt; Although this may look like a cross-site scripting attack, the result is harmless. HTML5 specifies that a &lt;script&gt; tag inserted via innerHTML should not execute. 
Are the Polymer elements all ported yet?
So at this point I've been building react apps professionally for over 2 years. I've tried polymer 1 a couple of times and I just can't get into it. Polymer just feels like writing assembly where react feels nice to develop in. What does the release of 2 change? 
&gt; Laanaa! Archer reference?
As much as I like JS, I think frontend is getting way too messy and I moved away from it a while ago, but I really do like Webpack and Sass. Just would be nightmarish to focus on the frontend of things only. &gt; New technologies can teach you different design patterns, architectures and coding styles that can help you with your daily work. Yeah I have to agree with this.
Mostly. Use the 2.0-preview branches
Honestly it looks to me like you're rebuilding npm and renaming a lot of the common idioms. npm is a staple of javascript development. It permeates everything these days. I think if you're going to try to replace it you need to have a really good reason other than "it's kind of easier in some ways we think", and let's not forget simple != easy. Every other attempt to replace npm has failed (bower, jspm). I also take issue with your use of the term "distributed", what exactly do you mean by that? Is the "bit server" a distributed system of some kind? It's not clear if you're merely using it as a buzzword. Sorry, but it's hard to imagine why anyone would ever use this. I'm sure you learned a lot building it, and hopefully you can apply the learnings to future projects. 
I've also recently been testing out a few libraries for end to end testing and think I'm going to stick with testcafe - http://devexpress.github.io/testcafe/ It's still pretty new, but the main selling point for me has been - "TestCafe automatically waits for page loads and XHRs to complete, as well as for DOM elements to become visible. You do not need to write custom code for that." It's also really simple to setup - I just run our tests from an npm script. The one gotcha I ran into is that I have to run tests in browsers using incognito mode, since extensions can bork your tests. I've gotten pretty into testing JS/front-end code (we use a similar react with chai/sinon/enzyme/mocha stack), so shoot me a message if you want to talk more about it!
Nobody appreciates answers delivered as snarky responses dude.
Do you have a test case? You can use `reduce`: function findLongestWord(str) { return str .split(' ') .reduce(function(acc, w) { return Math.max(acc, w.length) }, 0); } You can take advantage of `Math.max` taking many arguments: function findLongestWord(str) { var wordLengths = str .split(' ') .map(function(w) { return w.length; }); return Math.max.apply(null, wordLengths); } I am not sure if you are going for concise, clear or fast code here. I'm just giving some "functional" examples to solve it. Let me know if they need some explanation (especially the `Math.max` example).
Thanks! I really appreciate the reply. I'm going to do some reading on Math.max. In the meantime, the test case(s) you asked about: findLongestWord("The quick brown fox jumped over the lazy dog") should return a number. findLongestWord("The quick brown fox jumped over the lazy dog") should return 6. findLongestWord("May the force be with you") should return 5. findLongestWord("Google do a barrel roll") should return 6. findLongestWord("What is the average airspeed velocity of an unladen swallow") should return 8. findLongestWord("What if we try a super-long word such as otorhinolaryngology") should return 19. Since Math.max looks like it can handle the task I'll be excited to learn about it. I think more than anything I'm trying to just make sense of the way it occurred to me to solve the problem. I can't shake this feeling of being incredibly insecure with the solutions I try. I wasn't sure if anyone might have general commentary on the way I'm going about my approach, and whether or not it's overtly flawed or points to red flags, for example, if you were reviewing someone's code and it looked like what I posted above. 
 function findLongestWord(str) { wordArray = str.split(" "); max = 0; for (var i = 0; i &lt; str.length; i++) { if (wordList[i].length &gt; max) {max = wordList[i].length} } return max; } 
https://oncode.github.io/handorgel/ the demo is in the /docs folder ;)
I don't understand why google is persisting with polymer while they have Angular 2+, it's so much more awesome and easy to develop with 
https://avatars0.githubusercontent.com/u/70067?v=3&amp;s=400
I didn't get AMP because it's not explained in this article or in any of the linked articles. Even the AMPconf page doesn't mention that AMP stands for Accelerated Mobile Pages. There's barely any mention of mobile at all, so it's hard to infer that it's about performance and how web page performance is important on mobile.
I'd need to setup so many aliases to ensure all the combinations of `a`, `n` and `a` run the script laaaannnnnnaaaa 
Oh interesting - definitely haven't heard of testcafe before! Out of curiosity, does testcafe replace your existing stack of chai/sinon/enzyme/mocha?
Angular has web components 
I actually have to develop in react now and I absolutely hate it compared to polymer. Everything feels unnatural compared to "pure" HTML approach. Not sure why would you claim its "assembly", you just "extend" HTML to have new node types that you want. Maybe it depends on what you start with. 2.0 mostly changes the semantics to the 1.0 standard + brings ES6. The API's are similar.
Hm, for me angular 2.0 seems more complicated compared to polymer. Not sure why ( I liked angular 1.x). Besides Polymer is building on top of standards and is really small compared to angular. I think google and other enterprises try to push for more web platform standards. Taylor Savage already mentioned on polymer summit that polymer is probably their most important framework and is used very heavly in google because they want to use web platform without reinventing the wheel all over again. Interoperability and small footprint probably is also a factor here. https://www.youtube.com/watch?v=8ZTFEhPBJEE - watch this, some interesting points here.
Angular has directives which behave as if they were web components, Polymer is using native browser functionality instead. Less dependency on frameworks is usually a good thing IMHO.
I didn't test this but I'm thinking that 'first child' is what is screwing you up. When you hit space bar or enter are you making a second child?
Nice thanks for explaining it.
&gt; read Tim Kaldec's concerns and listen to Gina Trappioni Yeah, there's a reason I linked to that article in the first paragraph. I'm responding to it. And I listened to Gina Trapani's concerns, because I was in the room when she said them.
I feel like Linus' point wasn't all that much about how debugger sucks but about the fact that people don't think too hard about how their code behaves until it's too late because they rely too much on debugging.
First of all, thanks for your questions, you raise some valid concerns. Bit is not about rebuilding or replacing NPM (nor any other dependency manager - as mentioned before, it's designed to be language agnostic). Bit solves another problem. I would like to refer you to another comment here that explains more about why this tool was built, and why NPM was not enough for our needs (we still use NPM a great deal, it was just not the right tool for some of the jobs we tried to do with it) - https://www.reddit.com/r/javascript/comments/5y8qwz/bit_open_source_distributed_code_component_manager/deopxat/ I would like to add something on top of that - Bit does not handle packages. It handles something called code-components; testable, reusable definition of certain atomic functionality that handles a single and well-defined responsibility. Unlike NPM which handles programs. We tried splitting our code to micro-packages, but ended up with more work to do in order to manage them. The other option was to duplicate code, or migrate our (many) git repositories to one mono-repo (there's a third option - copy&amp;paste, but this is a bad practice). Instead we tried to imagine a better tool that is designed to solve this problem from end-to-end, instead of hacking our way through NPM and the rest of the eco-system to hack a solution. As for your second question - the system itself is distributed, it's not a buzzword. Unlike traditional package managers, which work in a centralized manner (client-server system approach), Bit takes a peer-to-peer approach to package management. Instead of a single, central repository on which clients synchronize, each client's working copy of the package is a complete one. This brings more flexibility to the development workflow (just like Git, you can mimic a client-server like approach), and still be very resilient.
&gt; The AMP Project is an open-source initiative aiming to make the web better for all. The project enables the creation of websites and ads that are consistently fast, beautiful and high-performing across devices and distribution platforms. From the [AMP project home page](https://www.ampproject.org). It's about performance first and mobile is just part of that.
A templated MVC on top of the dom without natural top-down control-flow depending on registrations to circumvent the fact that they don't have scope and can't interpolate variables. In reality Polymer doesn't have components but plug-n-play templates. Try this in "pure" Polymer: const Header = ({ text }) =&gt; &lt;h1&gt;{text}&lt;/h1&gt; const Title = () =&gt; &lt;Header text="title /&gt; These are literal "pure functions." I wonder, what exactly is "unnatural" about it? These principles elegantly solve real problems and allow us to transcend the browser, the vendor wars and policies, the committees. The browser has *finally* become a render target. They're enabling mobile and desktop apps, tv's, watches, unix consoles (seriously, [check](https://github.com/Yomguithereal/react-blessed) this [out](https://github.com/gaearon/react-blessed-hot-motion)), etc. If i see what React has done without breaking a sweat or a single standard and comparing it to the standard we've been waiting for many, many years now, then web components appear luke-warm. We've been waiting for the browser to come along for a decade, i'm not naive enough anymore to give them the benefit of a doubt. And masking arbitrary code in markup as "standard HTML attributes" doesn't fool anyone.
I prefer functional style programming. /u/penguinmandude's solution is imperative (and seems to be preferred by this community). Another solution would be using recursion. I think it's healthy to see different ways for the same solution but if imperative/object oriented is your style and way of thinking you should use /u/penguinmandude's solution. Besides the indentation issue, I don't see the reason for all the extra variables. It is usually enough to have one variable for each value you want to return. In this case the maximum number so `var max` should be sufficient instead of `var foo` and `var bar`. Another bug is `split("")` which will split on every character. `"hello".split("")` would be `["h", "e", "l", "l", "o"]` when you really want `["hello"]`. This problem is fairly small so I don't have much to comment on the solution unfortunately.
I'd recommend to take a look at functional languages which are designed to be what Ramda.js tries to bring into JavaScript. When the whole system follows some rules it is easier to understand where and how those rules should apply, so you can translate this knowledge onto JavaScript later. If you want to learn functional style only, do not dig into PURE functional languages, they have more concepts like monads etc. which are might be not exactly what you want.
https://www.manning.com/books/functional-programming-in-javascript
There is no such thing as AngularJS 2
Doesn't say anything about onload and link handler. Actually the source you have explicitly states that innerHTML should not be used.
&gt; I strongly prefer React. Much simpler, much more vanilla, no weird surprises. How can react with JSX that is actually javascript considered more pure HTML than... HTML? I worked with both, I like Polymer better, its perfectly ok to like react better too. But if you want to apply react knowledge directly to polymer you will have a bad time.
Actually I think Angular 2 can output web components?
Try cloning a Polymer web component DOM node vs. try cloning a JSX DOM node. The former loses all dynamic attributes you thought would be cloned as well, the latter works exactly as you'd expect. Web components add a whole new layer of boilerplate to the browser. It feels like going back to framesets. It's just different, I know, but for no good reason that I can think of. Angular, React, Ember, Backbone, etc. all do a much better job. All of these can do anything Polymer can do, and they can do it better.
haha I was going to write the same thing. The article just says it's a subset of HTML5 and nothing more. So what, I just limit the kinds of tags I use and that's that?
Strictly from an end-user perspective: I've found AMP to be a poor user experience, and it's actively pushing me away from Google.
Google for timeout and XHR
Ah that's interesting. It works but it creates another problem. I'm building a basic modal and when I use your solution it closes if I click on the content window too. The solution I posted was the only way I found to stop it doing that. 
Render a form to the page with one input and a submit button. Upon clicking that submit button, save the text from that field into the database and render a success message. This seems like a pretty simple thing to do, but its implementation should expose you to client side rendering (ANgular), API end points (Express), and NoSQL document design and insertion (Mongo). There's your MEAN stack. Google what you need to do to get this done, then you've got the building blocks to go from there. You'll always, ALWAYS, need google, so don't feel overwhelmed if you find yourself returning to it often. 
What would you like to have done? (doesn't have to work but maybe you can sketch out what you intended/desired)
Var modal = $("#modal").
 $('#modal').on('click', function(event){ if (this === event.target) { $(this).hide(); } }) So when you click on the content window, "event.target" will reference it, but "this" will reference the element it was bound to (#modal, in this case), hence the condition will fail and the modal should not be hidden. When the #modal is clicked, both "this" and "event.target" will reference it. Personally, I would add/remove an "active" class and move the visibility stuff to CSS, but that's not really all that relevant.
Honestly I wouldn't get any books. I would head over to [exercism.io](http://exercism.io/) and try some of the functional languages out: `F#`, `clojure`, `schem` or `haskell` if you feel like smashing your keyboard across your desk :D
I was just doing some practice in JQuery, I wanted to create a modal and close it, then maybe throw a few features in later. 
That works perfectly, and your explanation was great. Thanks!
[Professor Frisby's Mostly Adequate Guide To Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/) is a great book for this purpose. A lot of the examples use Ramda.
IIRC the dom object that is passed into the callback is always a regular JS dom object, not a jQuery dom object, so you could wrap it like $(event.target) I believe the other issue is using === to compare dom objects. I can't double check this at the moment but I believe you want to use .is() However, it seems like none of this is really what you want to do, put the event listener on .modal instead, like others have suggested 
Ugh I know! We're using es5. I forgot es6 helps a lot with this issue. I think we just need to use different technologies.. We're also using redux already. 
await-ing on a non-Promise does do something useful: it returns the value, immediately. for example, in an async function, `await 5` evaluates to 5. That means if you have a (non-async) function that might return either a Promise or a normal value, you can await on it from an async function, and not worry about which one it might return.
Nice! I'll look into that immutability-helper library. Thank you!!
I doubt many people here use Safari since Apple stopped releasing it for Windows 5 years ago.
You're looking for debouncing. Throttling a function will make sure it only gets called once per X milliseconds. Debouncing a function will not call it until it's been at least X milliseconds since the last call. 
No, actually i *do* get AMP. It's a proprietary subset of HTML, with gutted javascript which diverts traffic from your pages to a centralized Google overlord. Which is why I avoid it like the plague. Just learn to write fast sites, FFS.
You can start by reading the documentation about the arguments being passed to your event handler. Or just do a `console.log(arguments)` in your "do stuff" block, and see where you can go from there. It might be as simple as getting the lat/lon properties from the event itself and assigning them to the form's elements.
&gt; You can use polymer-redux or uniflow-polymer just fine. "Just fine" is really sugarcoating it. We've been doing it, and Polymer's programming model is absolutely not conducive of it. It works, but it doesn't really lead to a clean architecture like you almost automatically end up with when using it with React.
Why not simply: `if(event.target.getAttribute('id') == 'modal')`? If you insist in only using jQuery you could get the DOM element using this: `$('#modal')[0]` [See this.](https://learn.jquery.com/using-jquery-core/faq/how-do-i-pull-a-native-dom-element-from-a-jquery-object/)
That is correct.
Indeed. So is the ping pong paddle. Lana also means 'wool', and I've become overly excited about fb yarn recently.
Thanks, but this is what the documentation says: &gt;This example alias task defines a "default" task whereby the "jshint", "qunit", "concat" and "uglify" tasks are run automatically if Grunt is executed without specifying any tasks: grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); It seems that 'default' is often passed without some prior creation/initialization, as per the following StackOverflow questions from folks who've tried to do similar things, and have not been told to create the 'default' task: [Grunt Warning: Task “default” Not Found ](http://stackoverflow.com/questions/22974122/grunt-warning-task-default-not-found/22984439) [Gruntfile.js - Task “default” not found ](http://stackoverflow.com/questions/29148082/gruntfile-js-task-default-not-found) As you can see, in the second link, OP was told to *define* the task 'default', like this: grunt.registerTask("default", [ "lint", "test", "coverage" ]); but not, I don't think, anywhere else in the code.
I can't wait until the AMP astroturfing is over with.
Im guessing that you have two separate js files? map and clicker? If so put the clicker reference second and then it can see everything from the map file.
Indeed. const foo = (async () =&gt; 'foo')() console.log(foo.constructor.name) // "Promise"
Oh, cool. You guys are making huge steps it seems! Are there carousel solutions out there that have this "infinity" scrolling working? That specifically was a problem I ran into: When you scroll through a carousel and reach the end you want to continue again with the first item in the carousel. This typically means cloning the first element and putting it at the end of your DOM again. The problem used to be: It's impossible to clone a Polymer element and maintain its dynamic properties. Addy Osmani had a carousel solution and it did not include infinite scrolling. And the many open-source tried-and-tested carousels out there that did have a lot of features present were not made with web-components in mind. Cloning old-fashioned HTML elements (what these solutions do) is painless and fast, cloning web components... impossible. The `paper-carousel` project doesn't seem to include it. I've seen a few others that also don't feature it. Also, you can say enterprises use it. I know that. Very well aware. And I am still 100% convinced it is always a bad choice of tech.
I've thought about that too. Also, unfortunately *sh doesn't like exclamation marks, so no yelling: "Lana!" 
No, it can't.
https://toddmotto.com/emulated-native-shadow-dom-angular-2-view-encapsulation#viewencapsulationemulated I think it can. You will end up with shadow dom enabled elements.
Thanks for all the recommendations so far. I have read parts of Brian Lonsdorf book - aka Professor Frisbys , but maybe I go back to it in more detail. ditto with the Manning book, but personally I love Lonsdorf's style. 
Why do you want the modal to close when you click on it? Surely you want to close it when you click outside it?
I found it: https://gkoberger.github.io/stacksort/ 
Just the first line of the readme gets me more interested. Will 100% be looking through this over the weekend. Thanks
I think it meant you could do cost x = I i; in the loop body 
Gladly. I am a multi-tab user. This isn't a FF thing. I looking at my error console ui and there seemed some extra .js thread(Z) like expired cookies and different libraries from previous caches. Libs are piggybacking on browser channels from other content providers. tl;dr - chrome function calls in my ff console.
Didn't know that, thanks
Forget custom logic to control throttling; debounce and distinct until changed are my jam.
You are welcome. Well I have to tell you that i have the opposite experience - yes - I can find almost everything for my needs in react. But it needs to be "react thingie" - at least that was my impression, I don't like ghettos. With polymer so far I grabbed whatever I wanted and things just worked for me. When you grab your `INSERT-NON-REACT-DEP` that does its own DOM manipulation then things also get tricky with react right? Thats not to bash react - but I'd expect things are to be integrated more easly in polymer - and so far that was the experience for the people on the channel. Too bad it didn't work out well for you.
But not custom elements...
You might want to look into the 'onchange' event. That, combined with a longer timer, might be a reasonable combination.
Mh first of all, I don't think it you should go all in with one paradigm as there are good parts on both sides. For your situation I suggest you take a look at stuff that is changing: When adding an element to a collection, only the collection changes, not the added element nor the existing elements, so you don't have to touch these. You can keep the references to your subscenes and only rebuild the parent. Another way (which even is a bit more functional) is, to separate data and behavior. On the one hand you have all the data for your existing scenes and on the other hand you have functions, that can work with your data. 
Side note: You polyfill APIs that aren't yet implemented and transpile syntax features that aren't yet incorporated. Async Await for example are syntax features, while Array.prototype.includes is an API. 
well, then you won't get help at all next time, will you this isn't stackoverflow, "dude"
🙌Pedantic but true thanks for the clarification. 🙂
And koa 2.0 that uses async/await is finally out as well.
&gt; How can react with JSX that is actually javascript considered more pure HTML than... HTML? "Vanilla" does not necessarily mean "HTML". When working with React it really feels like you're working with vanilla Javascript, whereas in Polymer you're really working within the framework's concepts when doing Javascript (which is most of the time).
I vote Rxjs but it's a pretty large lib. I would only bring it in if you're sure you would use it in other parts of your application/site. Rxjs makes debouncing and other niceties so simple and effortless.
Ha ty, stupid phone needs a programming jargon dictionary add-on
I'm still waiting for some proper typescript support. I haven't heard much about it recently and even the typescript branch has been dead for 6 months. I'll keep an eye out for sure though as I'm very interested. 