&gt; Stable is good to an extent Stable is great, period. This "if it's not new, it's dead" philosophy belongs to the fashion industry, not software engineering. I'm willing to have my mind changed, but I won't abide trashing on Backbone/Marionette strictly because it's not hip. It gets the job done and works like a well-oiled machine. I'll concede that "stagnation" is a happening to the core (Backbone), but that's because it doesn't need to be more than it is (an MVC library), and it's *done*. "Left to die" is blatantly inaccurate. They're still closing tickets over there. Marionette is what makes Backbone a competitive framework, and it's also actively closing tickets with new features apparently under discussion. Lodash picked up the torch of underscore and is thriving. I can't speak to other plugins, as I haven't really needed more than Marionette.
Oh yea, it's the same issue for sure -- I was more referring to the parenthesis it injected
&gt; Stable is great, period. Yes and no. Stable is great for a certain amount of time while it's still relevant. &gt; This "if it's not new, it's dead" philosophy belongs to the fashion industry, not software engineering. I agree, nobody should look at it this way. The iPhone isn't new but it's not dead. Same with Rails, Django, Erlang, etc. If you would ask "so what makes backbone dead?" the answer would be that it has stopped growing and is stuck in its own way. It's evolve or die, not new or dead. &gt; Marionette is what makes Backbone a competitive framework Not saying it's false, but not many people would share that opinion to be honest. &gt; Lodash picked up the torch of underscore and is thriving. Because Lodash is evolving and continues to do so. The 4.0 release is very well done.
Build tools, ES6, finding better ways to do what they already do. The reason projects like Marionette and Ampersand.js exist are because they didn't think Backbone does enough for them. I haven't looked much at Ampersand because it's just modular Backbone from how they've sold it and I'm not interested in that so I'm not sure if that does improve it.
Why not define a static method on each component that does async work and run the routed one before rendering your DOM: _(components).map('fetchData') .compact() .map(method =&gt; method(stores, params)) .value(); In your component: class Test extends React.Component { static fetchData() { // return a promise with async work } render() { return &lt;section&gt; test &lt;/section&gt; } }
Glad I saw this before I tried to help you. 
Yes, I've seen that one. Unfortunately, it only says how to work with the code. Not how to start to use it.
[removed]
Backbone is a very very thin framework. I'm ripping backbone out of my current system because after review we found out that basically Backbone is doing nothing for us either in streamlining fetches from our API or helping with view templates. The only part of backbone we consistently used was the event system and routing. Events currently are being replaced with ES6 promises, and routing alone isn't enough to keep Backbone in the codebase. I think Backbone was originally used because backend devs didn't know how to structure their code in the frontend, but Backbone gives you nothing more than the structure, the skeleton, the Backbone (har har) and I want a framework with a bit more meat in its system. 
For routing there's page.js which is inspired by Expresses server side router. You can use it with decorators if you go with ES7; which leads to simple code like this: class App { @page('/hello') world() { ..... } } As for models; I think they're going to be different per every site. Since we're not querying a database directly, there's no real need for an ORM like model layer. Your model layer can be more targeted to your actual application with the kind of abstractions that make sense; just like desktop applications are handled.
A few times, yes
Thanks for sharing your perspective. I use static languages on a daily basis and for some unbelievable reason I haven't dug into an alternative for JS's type system. The enthusiasm tells me I need to pick one–I'll go with Flow first, then check out TypeScript. I really wanted to use TypeScript at first, but I just can't stand how fragmented JavaScript is getting. TS (and Elm) look awesome, but hopefully Flow gets me most of the way. If not, I'll maybe I'll join you in TypeScript one of these days. :)
Also recommend looking at his other videos, if you're interested in functional programming with JS!
I don't know. Backbone never really solved my problems well. It was a very thin framework and didn't aspire to be anything more. I can understand why some people would love it if it became a richer framework, like a Flask is to Django, but that was never the authors intention. I wouldn't trash it personally; but I wouldn't use it today when other tools better fit my needs.
[v6.5.1 got released soon after with a hotfix](https://github.com/babel/babel/releases/tag/v6.5.1)
For Chrome, there's TamperMonkey, and for Opera, there's ViolentMonkey; for Safari there's NinjaKit, for old Safari there's GreaseKit, and for old Opera you can load UserScripts natively. (To round it out, there's an old and poorly supported extension for IE7+ called IEPro, and it supports UserScripts too.)
I agree. Angular isn't something I'm a fan of or have fun using.
yea I know, but I have been coding like there is a gun to my head over the past week, and just want to have a few prototypes up for my job applications. But anyways, I took your advice and switched to postgres POSGIS and built a ruby api to handle the queries since their middleware is better for Sql stuff. Anyways, it's way way way faster!
Try the [Bing API](http://datamarket.azure.com/dataset/bing/search) (free for fewer than 5000 searches per month) or the limited [DuckDuckGo APIs](https://duckduckgo.com/api).
I tried using Marionette last month but the documentation for 3.0 doesn't seem complete yet (and I'm not sure 3.0 is even out yet), and all the examples I could find referenced 2.0 or even 1.0. More so there doesn't seem to be any community around Marionette. The last blog entry about it is from February 2015. 
This question is pretty vague. You'd have a better chance of getting helpful feedback if you provided more details and asked a more focused / narrow question. That being said, you could use a JavaScript search utility (like mine, [js-search](https://github.com/bvaughn/js-search) or [js-worker-search](https://github.com/bvaughn/js-worker-search)) to filter your list. This assumes you have an array of keywords you care about and you index headlines by something unique (like URL). For example, using js-worker-search you could do something like this (totally not tested): import SearchApi from 'js-worker-search' const searchApi = new SearchApi() // Assuming your scraper loads a map of URL to header text... var urlToHeaderMap = {} // And assuming you have an array of keywords you care about... var keywords = [] // Index each of the URLs you've loaded (you'd iterate on data returned by your scraper here) Object.keys(urlToHeaderMap).forEach(function(url) { searchApi.indexDocument(url, urlToHeaderMap[url]) }) // Find all URLs matching at least one of your keywords, // And then reduce to the minimum set of unique URLs... Promise.all( keywords.map(keyword =&gt; searchApi.search(keywords) ) ).then(searchResults =&gt; { const uniqueUrls = searchResults.reduce( (reduced, urls) =&gt; { urls.forEach(url =&gt; reduced[url] = true) return urls }, {} ) // TODO: Do something with uniqueUrls }) **Edit** for example code
Sorry I wasn't very clear... ill try again. I am using kimono and it pulls headlines in like this... "Headlines": { "href": "http://www.bloomberg.com/news/articles/2016-02-08/it-s-existential-for-anglo-american-as-ceo-faces-his-investors", "text": "It's Existential for Anglo American as CEO Faces His Investors" Is there a simple function I could write that would display this headline only if "CEO" is contain within the string? 
I updated my initial reply to include some example code :)
By the looks of it, t should work. if the whole snippet is inside a function. Note that where *this* points to is defined on call time, not on write time. So in getTall *this* should *not* point to 'return this' object, but to 'this.resource' object. Try these: ``` getAll().then((function(result){...}).bind(this) ```` and ``` getAll().then((function(result){...}).bind(this.resource) ``` My hunch is that latter will work.
yeah, but .getAll() is called with this.resource, thus inside .getAll this should point to outer scope *this.resource* not *this*
They are easy to do, but would need some session db - I'd need to move it to a real host.. The point for the whole thing was to show a friend how to start with node.js and that plain js is not that hard. Then I thought that it might be useful for others as well.
https://phabricator.babeljs.io/T2765 still blocks upgrade for one of my projects :-/
I don't get that bug, care to show an example? 
You would have to modify your boilerplate with the [changes in #93](https://github.com/gaearon/react-transform-boilerplate/pull/93/files) to make a production-ready build. To develop with it, you just need to `npm start`.
http://www.w3schools.com/jsref/jsref_indexof.asp
We have to implement custom stuff on both sides of the scale - huge pieces of new functionality (possibly suited to a plug in system) and minor tweaks to existing functionality (for example, "when I change the value of this drop down, the text should say 'this' instead of 'that'" - while keeping the original behaviour for all other clients). I'm not sure I could solve the latter case using just plugins. If you have any ideas how I could, I'd be really interested to hear your suggestions though!
Google for IIFE
Heh, good job on the homework! Okay, so a little bit of background. The app is a mostly legacy CodeIgniter PHP application. There's a custom bit of code during the CI application bootstrap that says "if the requested controller/function/JS file/CSS exists in the client's personal directory, use that version instead - if not use the default version". The CI application is mostly unstructured spaghetti code, and generally just not very nice to work with, but this is how the all custom functionality has been implemented up until recently. There has since been a Laravel application added - if the requested route or file exists in the Laravel app, it use that version, otherwise the request is forwarded on to CodeIgniter. This is allowing for a gradual refactor of the app away from CI to Laravel, and this is working nicely. As far as I'm aware, the company policy has always been to do anything the client wants (long before I started working here) - it has just always been implemented in a less than ideal, almost hacky, way. This has resulted in the spaghetti I refer to above. Since I started working here, I've been trying to find ways to improve everything, from the way that the application repositories are structured (we've gone from one CodeIgniter repo, plus one default Laravel repo, plus a forked Laravel repo for all ~20 clients, to just a single repo containing everything), to automating what was before a manual, error-prone deployment process. Regarding the book/ISB example - I had been reading a lot about BDD at the time when I wrote that, and reading about using the correct terminology (the ubiquitous language) that the business uses in the code. I think what I was trying to get across in that example was that when building custom functionality for a client that uses terminology different to everyone else, how to handle that conflict? You're absolutely right that the core should be more flexible, and that's always at the forefront of my mind. Although the CodeIgniter code base will never be flexible (and we will just have to live with it), we have a real opportunity with the Laravel code base to make it flexible enough for all clients, while adhering to modern practices. We really feel we're in a good position on the Laravel side of things now (using dynamic runtime service container configuration) - the last piece of the puzzle is how to do achieve similar results with the existing JS/SASS using within the Laravel app, and any new JS/SASS that we write, which is proving a difficult problem to solve, hence this post :)
nevermind, i was using it wrong... decorator has to be defined as a function that takes a class returns another class extending the input rather than a function that defines properties on the input class. was following the guide [here](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.eehzcpxjj)
You should check out tape. On mobile at the moment but I can provide links if that would be useful?
Ill have to look at it later, when im not on mobile. But on line 12-13, keep curly brackets on the same line as function declatation, to avoid automatic semicolon insertion errors
&gt; deleted reply here if you upload your ffile once more
alright then, good luck ;)
lol no, stop using Backbone. Marionette is a framework that tries to fix a bad solution with more bad solutions. Don't even use that.
&gt; Backbone.js gets some undeserved hate from fans of other frameworks Backbone solves no relevant issue. the biggest issue in front end development is the view, not models or routers. Backbone doesn't solve the layer problem AT ALL. Backbone is useless, it just gave developers the illusion that it was solving something. The worse is Backbone.View, that basically does nothing and isn't even composable. While React is far from perfect , it solves the "view layer as a tree of components" and that's exactly how one solves the view layer problem. Not with models and event listeners or a router . 
You can't put Backbone and Modern in the same sentence.
Is there a JS MVC framework that does things "the right way"?
Went from an 8 second build, to a 7 second build. So I don't know if that means ~3x faster is only for the code generator or for babel as a whole
Did you try the new passPerPreset option?
Thanxx for that and can you plz tell me what is the diff. b/w the code i cut it down to half and your new code window.addEventListener("keydown", function(e) { if (e.keyCode === 13) { var allExpandedST = document.querySelectorAll(".expando-button.selftext.expanded"), allExpandedV = document.querySelectorAll(".expando-button.video.expanded"), allExpandedVM = document.querySelectorAll(".expando-button.video-muted.expanded"), allExpandedI = document.querySelectorAll(".expando-button.image.expanded"), i = 0; for (i; i &lt; allExpandedST.length; i++) { allExpandedST[i].click(); } for (i; i &lt; allExpandedV.length; i++) { allExpandedV[i].click(); } for (i; i &lt; allExpandedVM.length; i++) { allExpandedVM[i].click(); } for (i; i &lt; allExpandedI.length; i++) { allExpandedI[i].click(); } } }); The only diff. i can tell is you make it more small in size, can you plz tell me what are the error and mistake in my previous code ......and what will be diff. in performance in this code and the previous code and as for the language can you plz tell me is there is any maths in the javascript if there is i dont think so i will learn it in several months :(
When I first started learning Javascript I tried to pick up backbone. It was so fun to read the source code, especially on the website where the API is described right next to the source. VERY VERY educational if that's what someone is after.
Haha you caught me off guard. It's nice to see someone else posting it :D. As always, if anyone has any questions or feedback, I'll be keeping an eye on this thread. 
PHP won only in a certain segment of the market, namely small businesses and hobby users. Since there are a lot of WordPress powered blogs, there are many PHP powered sites. But if you'd look for economical relevance, than PHP wouldn't be the winner, I think. Worlds biggest commercial sites are mostly based on Java.
I would definitely consider adding that feature if we can do it without sacrificing other benefits. I really like that feature of AVA. I will add it to the feature proposal list.
Here's a one liner that'll get ALL the text on the page. Array.prototype.slice.call(document.querySelectorAll('*'), 0) .filter(function(element) { return element.textContent !== '' }) .forEach(function(element) { console.log(element.textContent) }) This gets all the text and filters out empty tags. This includes script tags, style tags, meta tags...everything! If you only want the text inside a certain types of tag you can change the `*` to `span, p, h1, h2, h3, h4, h5, h6`. The selector works the same way as a CSS selector.
Have you tried with the textContent property of the DOM element? It works in IE9+. If you need support for older browsers, you could manually strip tags from innerHTML property.
Not what he wants but I don't care this is funny
Holy crap that website is atrocious on mobile. All I wanted to see was how to make a whole course on a simple syntax?
I just ran a variation of the same code on your comment Array.prototype.slice.call(document.getElementById('thing_t1_czs6vp1').querySelectorAll('.usertext-body p, .usertext-body pre'), 0) .filter(function(element) { return element.textContent !== '' }) .forEach(function(element) { console.log(element.textContent) }) And I got I can do something similar to this, but what i need to do is remove all the html tags from it. say I have this: &lt;p&gt;Hello Hi&lt;/p&gt; I want the code to return just this: Hello Hi But I want it to do this for the entire HTML doc
fuck your no semicolon shit. go do something useful.
That's exactly what my answer does.
That's a fair criticism. Backbone's only had 1 minor update last year, to v1.2 in May. We're still using Marionette v2.5.4 which fits our needs fine.
A &lt;pre&gt; element is all you need to render Tetris (the original version was text-only). Are you asking how to implement the game logic or just how to render it without using &lt;canvas&gt;?
Do as you wish, of course, but... I would suggest that you learn html, then css, then javascript. Css doesn't make much sense without html.
XPost Subreddit Link: /r/aureliajs Original post: https://www.reddit.com/r/aureliajs/comments/44raof/bouncer_an_aurelia_filter_component/
That's not saying it is true. That saying if this character matches the same character when capitalized then evaluate to true. If the letter is a lower case letter that if condition will be false. It would be true if you didn't include the equals.
Not sure if I just don't understand you, but "It would be true if you didn't include the equals" that was my question- why can't I just say if (before.charAt(0).toUpperCase()) then Im saying if it evaluate to true then ..execute the code..
I never ask "gotcha" style questions, and nothing that would only be possible in JS. I like to ask about the whole stack, too. E.g. walk me through a typical HTTP request, starting from the initiator, all the way to the data later, and back to the response generation and handling on the client. I leave it open-ended so the candidate can get as deep/technical as they want. For my coding question, I ask something that would require critical thinking skills, edge case considerations, performance tradeoffs, and discovery of interesting test cases.
This seems to work... function myReplace(str, before, after) { if (before[0] === before[0].toUpperCase()) { after = after[0].toUpperCase() + after.slice(1); } var word = str.replace(before, after); return word; } console.log(myReplace("What in the world is this?", "What", "how")); //How in the world is this? console.log(myReplace("what in the world is this?", "what", "how")); //how in the world is this? I changed the charAt stuff to just using bracket notation; seemed cleaner to me. I got rid of the else as you seem to want that. All seems good. Am I missing something?
Forgot to add html5+css ...............thanxxx sticking till the end with me 
Great thanks. Could you give me a quick coding question example?
Nah, just search for programming interview questions and you'll find plenty. If the company you are interviewing for is big, you might be able to find some specific questions on Glassdoor.
Not a problem! Glad to help!
I would be very interested to hear how you get rid of mocking. Are you now using dependency injection or a similar strategy?
if you can't use canvas, i'd suggest making the grid out divs and spans. each cell is a span, contained by rows of divs. I'm not sure your skill level in JS but you can keep track of them with an array of objects (though using immutable maps and lists would be better). this translates your grid into an array of objects. each object corresponds to a cell that keeps track of the things like the color, if its 'frozen' (a piece has been locked there) etc. i'd also very much recommend just writing out all the different positions of the pieces instead of trying to come up with some algorithm on how to rotate them.
Maybe I'm mistaken, but I thought Babel removed support for decorators.
Hi /u/loveforcode, for questions this simple just use the search please.
Your code only checks if the first letter of the first word in `str` is capitalized, not the first letter in `before` which can occur anywhere in `str`.
I think it's weird that you're introducing a pattern that is completely foreign to the language because you don't have an understanding of a well documented feature
You are right. I wrote that article from my iPhone, the app doesn't allow to load gists. Will fix it later. Thanks.
Why do people keep sharing articles on TypeScript that are 1 or 2 years old?
Glad you got it!
I'm not convinced by any of these articles. Every one of them argues javascript sucks by using examples that are built to fail. The most common example used is over the ambiguity of `this` var greeter = new Greeter("world"); var unbound = greeter.greet; alert(unbound()); This one is used against all three JS languages (typescript, JS, and coffeescript) to demonstrate some grand pitfall of javascript, but with the failure to mention this is just extremely poorly written code. Like sure, to a developer who doesnt understand how JS works, this would look ridiculous, but to anyone who actually knows what theyre doing, they'd point and scream and pull their hair out over seeing that example in a pull request. var unbound = greeter.greet.bind(greeter); then the coffeescript article ACTUALLY tries to argue that the following CS code is perfectly normal, dissects it, and claims CS is not the answer because of the syntax func 5, { event: (e) -&gt; if e.something 36 else 45, val: 10} neither the comma, nor the curly braces should be there, which makes all the arguments made against the code fall apart. then proceeds to give examples on why coffeescript isnt the answer because of the chaining, and optional parens. like man, just cus you CAN chain list comprehensions to death doesnt mean you should. Just because you CAN leave off parens doesnt mean you should All of the arguments are 'this is compilable code. it sucks, therefore JS sucks'.. even though every example can pretty much act as the poster child of improperly written JS
Copy this code directly into your browser console: /*global define, document, exports*/ // a function to get DOM nodes by nodeType property. If you do not supply a value // I will give you every DOM node. // // global examples: var allComments = document.getNodesByType(8); var // allComments = document.getNodesByType("COMMENT_NODE"); // // or use locally: var a = document.getElementById("item"); // item.getNodesByType(2); // // The accepted string values are the actual node type names, so that the // typeValue argument can be supplied dynamically from other code. // // // Please try http://prettydiff.com/ for all your web development needs! // // // Keep in mind that the following node types are valid in the W3C DOM standards, // but have been deprecated in the WHATWG DOM specification. // // 2 - ATTRIBUTE_NODE 4 - CDATA_SECTION_NODE 5 - ENTITY_REFERENCE_NODE 6 - // ENTITY_NODE 12 - NOTATION_NODE // // This means all node types are still valid in the standard, but the deprecated // types may not be retrievable from certain DOM implementations. // (function wrapper() { var getNodesByType = function getNodesByType(typeValue) { "use strict"; var types = 0, valueTest = (typeof typeValue === "string") ? typeValue.toUpperCase() : "", root = this; // Normalize string input for case insensitivity. if (typeof typeValue === "string") { typeValue = typeValue.toLowerCase(); } // If input is a string and supported standard value associate to the standard // numeric type if (typeValue === "all") { types = 0; } else if (typeValue === "element_node") { types = 1; } else if (typeValue === "attribute_node") { types = 2; } else if (typeValue === "text_node") { types = 3; } else if (typeValue === "cdata_section_node") { types = 4; } else if (typeValue === "entity_reference_node") { types = 5; } else if (typeValue === "entity_node") { types = 6; } else if (typeValue === "processing_instruction_node") { types = 7; } else if (typeValue === "comment_node") { types = 8; } else if (typeValue === "document_node") { types = 9; } else if (typeValue === "document_type_node") { types = 10; } else if (typeValue === "document_fragment_node") { types = 11; } else if (typeValue === "notation_node") { types = 12; } // If input is type string but the value is a supported number if (isNaN(valueTest) === false &amp;&amp; (valueTest.length === 1 || valueTest === "10" || valueTest === "11" || valueTest === "12")) { types = Number(valueTest); } // If input is a supported number if (valueTest === "" &amp;&amp; (typeValue === 0 || typeValue === 1 || typeValue === 2 || typeValue === 3 || typeValue === 4 || typeValue === 5 || typeValue === 6 || typeValue === 7 || typeValue === 8 || typeValue === 9 || typeValue === 10 || typeValue === 11 || typeValue === 12)) { types = typeValue; } // Identify the starting point. When used globally the root element is the // document's root, which is typically &lt;html&gt;. When used locally this is the // node on which the method is executed against. if (root === document) { root = document.documentElement; } // A handy dandy function to trap all the DOM walking return (function getNodesByType_walking() { var output = [], child = function getNodesByType_walking_child(x) { var atty = [], a = x.childNodes, b = a.length, c = 0, d = 0, e = 0; for (c = 0; c &lt; b; c += 1) { if (a[c].nodeType === types || types === 0) { output.push(a[c]); } if (a[c].nodeType === 1) { // Special functionality for attribute types. if (types === 2 || types === 0) { atty = a[c].attributes; d = atty.length; for (e = 0; e &lt; d; e += 1) { output.push(atty[e]); } } //recursion magic getNodesByType_walking_child(a[c]); } } }; child(root); return output; }()); }, el = [], len = 0, a = 0; // Create a document method document.getNodesByType = getNodesByType; // Add this code as a method onto each DOM element el = document.getNodesByType(1); len = el.length; for (a = 0; a &lt; len; a += 1) { el[a].getNodesByType = getNodesByType; } // Ensure dynamically created elements get this method too Element.prototype.getNodesByType = getNodesByType; if (typeof exports === "object" || typeof exports === "function") { //commonjs and nodejs support exports.getNodesByType = getNodesByType; } else if (typeof define === "object" || typeof define === "function") { //requirejs support define(function requirejs(require, exports) { "use strict"; exports.getNodesByType = getNodesByType; //worthless if block to appease RequireJS and JSLint if (typeof require === "number") { return require; } return exports.getNodesByType; }); } }()); document.getNodesByType(3); That code will walk the DOM of the entire document and will grab all text nodes. It will return an array of every text node. With that you can modify all text in the page directly without modifying the page structure. The code is from: https://github.com/prettydiff/getNodesByType
Did you know Shift+Enter in the Firefox web console lets you do multiple lines?
Interesting article, my team is looking at migrating to Typescript. But quick question - Wouldn't this two-step build ruin sourcemaps? Why not use webpack with ts-loader?
cannot disagree.
Everyone loves strings How about this. Given a string find the longest palindrome. I like it because there is a n time solution (maybe it's nlogn? Aka I don't know it) but it's really involved and the interview solution is n2 or even n3 but those will cause panic 100% of the time. How do you react kind of question. After typing it out... I realize it's kind of an unreasonable question for a junior dev. So how about angle between hands of clock. Lots of ways to solve it and easy follow up questions. 
Not sure what you mean, if my code would check only the first letter in str, not in before, then when I call the function with myReplace("His name is Tom", "Tom", "john"); wouldn't work, but it works, Tom which is not the first word becomes not john but John. 
Awesome, thanks.
This article doesn't address the benefits of typing. It is described almost as a tool that gets in your way. I thought it was generally understood that writing untyped code at sufficient scale is difficult. That is why typescript was created along with other similar tools like Flow. Does typescript solve all of JS issues? No, but that's not it's purpose. It is probably not even the best type system. Look to Haskell for better examples. I see a lot of benefits to typed JavaScript. You get to turn runtime errors into compile time errors. No more undefined is not a function. The decision comes down to whether the added benefit is worth the extra effort for you.
It's basically like an infomercial where the person can't perform a simple task. "Drr... I can't pour a drink into a cup! I must need to buy something."
&gt; if my code... Again, I was never referring to your code. I was replying to /u/vertebro's code.
I honestly wish the FF people had kept all the extras as addons rather than including them in the base browser. It keeps the functionality that most people don't need completely optional and it keeps the software simpler to use. If they absolutely must have those features in the download that most people are getting, then include them as part of the install but as addons/extensions so they can be disabled rather than going the old Mozilla route and having a billion features that aren't needed by default. FF shouldn't have a javascript debugger of any sort built in.
ah okay haha
Our build went from ~58s to ~43s. Perf improvements are always welcome !
Thinking about finally trying out Webpack, look forward to reading this. Just as a small side note, I think arrow functions DO work in browsers: &gt; With babel, this code, which would be rejected by any browser &gt; `const square = n =&gt; n * n;` It seems to work fine in Chrome and Firefox. Am I off on that?
Oh wow you're right. That must have been a new update to chrome because this functionality didn't exist a while ago. I'll amend the example.
Any time I'm doing something in the console beyond a one-liner I write it up in my text editor and then paste it into the console. That way I don't have to worry about losing track of it, and it makes changing it a lot easier and more convenient.
I didn't mean it like being sarcastic.
&gt; Neither of the things being discussed are features of JavaScript yet Fat arrow functions are a feature of JavaScript. ECMAScript 2015 was finalized last year. The year it was named after. It's now waiting for browser vendors to implement them. Babel just implemented the ones that can be transpiled back to currently implemented versions.
Pour la vitesse, le plus proche que te rends à la vanille, le plus rapide que ça va être (un des dernier accent circonflexe que je vais écrire de ma vie)
Personally I find keeping form/input state in a global app state (like... in a redux store) is really beneficial. This makes it easier for other parts of your application to read from a form's state to do meaningful things. What if I have several forms with tied validation logic? What if I have some component for displaying existing validation errors outside of the form itself? Naturally, if you know ahead of time that your application does not have these concerns, you can save yourself some over-engineering by not accounting for these cases. I don't think forms are that different from anything else in your application, honestly. Generally, keeping local component state will be easier to do in a first run, but can turn out to be restrictive or result in difficulties down the road.
I'm not referring to arrow functions I'm referring to assigning an arrow function to a Class instance property which is _not_ spec yet. 
I rushed to it! HAHAHA Thanks for posting it. As you can see, I'm following it closely.
Now thats cool. Was not aware of that!
&gt;FF shouldn't have a javascript debugger of any sort built in. That's ridiculous and it doesn't affect your browsing experience at all when its not turned on. If it wasn't built in to the core code it wouldn't work as well, either. Firebug was great but native debugging is massively better in terms of performance and features.
Derek Banas on YT recently released a MEAN stack tutorial, its basic though
I don't think so, since Go is not significantly better than Java (actually you'd be less productive with it). But this topic is about PHP and Js. 
Build an object that will serve as a container for info about each city. Put an event listener (probably change or input) on the drop-down/select element. Have the event handler get the value of the select element and, depending on its value, use the object as reference to populate the fields by assigning values to them.
I switched from Firebug to DevTools 2 years ago or even more. DevTools is fast and Firebug was freezing my browser. Can't wait for Firebug3 to land in Nightly since that is what I use at home. I use DevEdition at work since it has e10s and it looks fancy. 
I have to agree with the article... Though I do prefer Redux+React as constructs, and though there are arguably better implementations of the ideas behind the frameworks, they seem to have the best chance of persisting the next few years. Angular has very strong support as well, and with either you can rest on your laurels for at least a year or so, and not have to keep up with the churn.. I think getting to where you are using webpack, babel and your framework of choice at this point is a good place to be for the near future. There's going to be a lot of shake out/down regarding web components and other competing frameworks over the next couple years, and it will take that long for broad browser support. For me, I think I'm more excited about getting to where async/await, fetch and promises are common features.
&gt; Any tips on what kinda things would come up? * arrays * objects * functions * inheritance * scope * closure * ajax/xmlhttprequest * unit testing * node.js * DOM * favorite tools * code organization * thoughts on build tools/dependencies * accessibility * security * events * event loop * promises * callbacks * A/B testing * thoughts on frameworks: angular, react, ember * thoughts on code extending utilities: lodash, backbone, jquery, express * thoughts on vanilla js If I were interviewing you I would start with abstract subjects I would expect experts to know and then gradually dial back my questions until I can pinpoint your approximate level of expertise. I wouldn't ask anything super specific, because that is what references are for and I am not trying to be an ass. I also wouldn't ask you to solve any code problems, but I might ask you to demonstrate an answer with code if words aren't enough for me to understand your position. A good interviewer wants to help the candidates relax and feel comfortable because they get much better (and honest) answers to consider. Not everybody is a good interview though.
As an og dev, I remember when I finally groked how pub/sub/events work (we're calling it observables now, ok) Oh the magical ways they can be applied :)
[removed]
Instead of trying to force a square peg into a round hole I think you are much better off stepping back and re-examining your approach.
whats the question? best bet is trying to get a tutorial for filezilla/sftp (sftp is annoying)... i used the sublime sftp plugin in the end and it wasnt too bad. and piece together a couple examples of wheelnavjs. and try to get a jsfiddle together 
&gt;Angular has very strong support as well, and with either you can rest on your laurels for at least a year or so, and not have to keep up with the churn.. Angular 1.x's user base is so huge there's already forks of the code to maintain support for IE8. Even if the developers drop it like a hot potato now that 1.5 is out, there's a huge vested interest in keeping 1.x alive for as long as possible. I'd say, given 1.x has already lasted quite a few years, and that 1.5 was such a good update, it's going to be relevant for at least a few more years, then refuse to die for a while longer still. With react, I'm less certain. The native implementations in typescript and babel makes me feel it'll be around for a while yet - but we've already moved from flux to redux, and I'm getting some heavy deja vu from when UI router became a thing in angular world. Only, I don't know if flux is the "now this is definitely the best way to do it"-good that UI router inspired in people. Still, predicting the web in 5, 10, 15 years is a loser's game. 
I didn't think about how that is storing the data in the view, that is pretty ridiculous. I am going to give this a try, thank you!
By the way, it's labelled the January update but I'm pretty sure it was just released today. I use VS Code daily and check that page for updates frequently.
cool!
were those all things that the Mozilla Browser had? 
Agreed.
Thanks for this! I'm trying to get it running but hit an error. I've cloned the full repo, run npm install and made sure node is higher than 4.0 (5.5) npm run test gives the error: "Cannot find module './sinon/util/core' I don't suppose you ran across it? npm run old_test works perfectly with everything passing
Why are you so hostile? You came to a programming reddit and asked how to do something. People point you in the right direction to do it and you insult them. You say you don't know JS, that's fine but as far as we know maybe you're looking to learn for this purpose. 
I'd like to point out that you didn't ask for a program (or as you put it 'a shelf'). You asked for a way to "insert something (like a small calendar) on a specific domain for my favorite website". In a developer forum. Full of a bunch of developers who build things. Semantics aside, I now see what the intention of your original question was. While we didn't provide you with your 'preferred' answer, realize that we did provide you with 'an' answer. Both equally valid. The answers provided, like many things, come from many perspectives and provide multiple approaches to problem solving. Pushing your perspective as the one-to-rule-them-all is pretty dismissive to the opinions of others. Wheaton's Law stands.
I am sympathetic to your position. After all, people wrote large scale, maintainable web applications long before the advent of Backbone and Angular. You had objects that owned parts of the DOM and were responsible for their own rendering. You had localised event systems that would allow components to render internal state. You had to be aware if what you were doing, and disciplined, but what changed? You still have to exercise discipline and thought in any kind of modern framework, and the glut of "best practices in Angular / React / Flux / Elm" articles prove that. The only value to an abstraction is when it allows the developers who are already thriving - already thinking, already reflecting - more power and productivity. I have seen teams yearn over and over for magic frameworks that will "structure all our code for us" and make building scalable, pivotable software a join-the-dots exercise, and it simply never happens. I saw it happen several times at my last gig with Angular - teams that can't write JS, won't write JS, adopting the tool that promises to do as much of the thinking as possible. Except it didn't work out, because - surprise, surprise - it turns out you cannot sleepwalk into writing a maintainable, performant Angular app in exactly the same way you cannot sleepwalk into writing a Ruby-on-Rails app, or a Java Spring app, or a vanilla webapp, or much software generally. Programming is the practice of crystallizing human intent into computer instructions. It requires that the developer think as clearly about the intent as they think about the machine. Good developers create structures that intuitively and reliably map to their intent. Bad developers "program by happenstance" - they create structures that have only an incidental mapping to their intent. But that work - the expression of business logic into a model that is robust and flexible because it is _right_ - that work happens somewhere that no framework can touch.
"The author" doesn't really apply in an open-source project with many contributors. https://github.com/jashkenas/backbone/issues?q=is%3Aissue+is%3Aclosed
But why?
The rendering of the game without a canvas was a challenging part, especially the blocks and how to handle them using html elements,with a canvas this would be rather easy but considering its a college project I've certain restrictions and no canvas is one of them.
I'm playing with it now, it has some pretty awesome sounding benefits. It's a true build system, so it takes care of your images, JS, CSS, html, etc... It links them all together, does work on them as necessary, excludes anything you don't explicitly need or use somewhere, and it does so pretty fas all things considered. Modules are actually modules. CSS, images, and JS are all isolated in their module away from global. It's pretty cool writing CSS in a sane way... The downsides, its fucking complicated! Like stupid complicated. It also doesn't help that the documentation is terrible, and it suffers from the "10 ways to skin a cat" problem. Still, I'm getting to a point where I'm finally building a toy project, (I started today about 6-7 hours ago), and its starting to "click". But compared to my "traditional" gulpfiles, the webpack config is ugly, complicated, and confusing. I'm still not sold... At this point I feel a well crafted gulpfile is easier, faster, and provides about 90% of the same features. But I still haven't really used webpack in a true application yet, so it might shine once it gets up and running.
I shall give this way a try,thank you.
Not to mention the barely readable font size/weight.
Haha well said
The article is about how you should not be "fatigued" and how you can view the wide variety of frameworks as a good thing.
JavaScript still remains, to me, a strange choice for embedded programming.
And the Feb update is slated to include code folding, the #1 voted-for feature.
Another way to think about writing it: function mutation(arr) { return arr[1].toLowerCase().split('') .every((letter) =&gt; arr[0].toLowerCase().includes(letter)); } 
Still not gonna read it. 
Why not? 
Am I the only one who thinks that predictions are not of any value here? Are there JavaScript Framework futures that I can invest in? I know this is silly to dive into a teardown of these predictions, but it's entertaining. &gt;but the past is the best indicator of the future. This is, at best, is a gross over-simplification. Also, the author goes on to contradict this a little later. &gt; I’d expect to continue to see the evolution of existing frameworks and libraries and the creation of new ones that advance some new idea or concept that make creating webapps easier and more fluid. This is a meaningless non-prediction. Of course existing tools will develop and new ones will be created. In other news, I predict the earth will continue orbiting the sun. &gt;The larger frameworks will likely cherry pick from the best ideas in the aggregate. We’ve already seen this with Angular 2 adopting superior forms of internal rendering over v1 and having the ‘Component’ as a first class construct. Another risk-free conjecture that doesn't tell us anything useful. Cross-pollination of ideas? Yes, it is bound to happen. Also, Angular 2 and React share similarities because those teams collaborated a bunch, so this isn't necessarily a good example to prove a larger trend. &gt;Angular 2 will be successful to some degree More noise. Also, if the past were the best predictor, then wouldn't Angular 2 be a huge success because of the success of Angular 1? And also because Angular 2 has cherry-picked the great ideas from React? &gt;...but probably be overshadowed by React mainly due to momentum. This likely won’t change for a while, especially given the still ‘not ready for production’ state of Angular 2. Think Xbox 360 and how it hit the market long before the PS3, the PS3 was always playing catch up. Not a perfect analogy in light of Angular 1.x, but it has some parallels I think. So, this is a prediction based on a flawed analogy? Even putting that aside, this is pretty vague and qualified. &gt;There will be some new library or framework X that will be introduced and gain momentum eventually though it will be a while. React and Angular have enough hold and mindshare that any new major framework will have a very hard uphill battle to establish any sort of major dominance barring a new revolutionary approach like React popularized. How many times can this author make the same empty prediction? So, barring a "new revolutionary approach", nothing will easily disrupt the current environment? So, in other words, barring something that entirely changes the landscape, the landscape will remain more or less the same. &gt;There will be many new micro-frameworks and ‘nextbestthings’ that come out, but none will experience the large success of React and Angular for some time. Wait, is this the same thing as the previous one? This one isn't very comprehensible, so moving right along... &gt;When React version 1.0 is released it will be a very significant milestone as a successful implementation of the original concept and goals. A prediction that a significant milestone will be a significant milestone. &gt; I see the momentum only increasing for React not decreasing. There will undoubtedly be an arc at some point, but not soon. OK, this is perhaps his most bold prediction. A strong assertion that React's popularity will only increase... but only for some unspecified length of time. Again, it ends up very qualified. What is 'soon' here? A prediction is "it will rain tomorrow and the day after" or "the Broncos will win two more consecutive Super Bowls", not "a popular framework will remain popular for an unspecified amount of time." All in all, I don't blame the author for making more concise, actual predictions, because he clearly does not have any real data or analysis on which to base such predictions. So, of course he make pretty tepid claims. I only blame him for including predictions at all, and devoting so much space in his article to them. 
Signed up — though your site does leave you wondering what it actually looks like. API, dev environment, etc. :)
Am I reading this right? Does this give me immutable data with the traditional methods of access? That's the only thing I didn't quite like about ImmutableJS: I had to remember to use different methods and couldn't duck-type.
Check out https://github.com/gcanti/tcomb if besides immutability and standard interop with native data structures you also like runtime type-checking [author here]
Broadly speaking, there are two ways you can do immutable data structures. First, you could take a basic JS object or array, and then *not change it*. To make sure you're not changing it you could use `Object.freeze` (recursively, ideally), and to allow you to create a new object when you need to make a change, you could write some helper methods, all of which boil down to "do a shallow clone of the object or array, mutate the changing node, and re-freeze". For a large data structure, that is going to have some major memory impacts. If you're implementing an undo queue, and your global state is a million objects in an array, and every user action mutates one of the objects, then after 100 user actions you now have 100 million objects, 99.9 million of them duplicates. Even if you're not keeping the old ones around, that's going to be some godawful memory churn as your GC kicks in. Then again, most apps will still work fine. :) Second, you could use *actual* immutable data structures, aka [persistent data structures](https://en.wikipedia.org/wiki/Persistent_data_structure). These are pretty hard to code, which is why as far as I've known they've only been implemented twice: Once by the Mori project, and once by Facebook in the immutable JS project. The advantage is that their performance is really quite good when dealing with large data structures, because you can completely avoid doing shallow clones and using *structural sharing*, ie, re-using the unchanged nodes in the new data structure. But the downside is that if your "list" is actually some sort of crazy functional data structure, then it's *not* actually an array. &gt; Does this give me immutable data with the traditional methods of access? Yes! But immutable data is pretty easy; just be disciplined about not mutating your data, or if you can't trust yourself (or the libraries you use) then sprinkle `Object.freeze` around as needed. Seamless-immutable does just that, but so do a dozen other libraries. Immutable data is not hard; what's hard is high performance immutable data structures that give your the benefits of structural sharing. Does seamless-immutable give you that, combined with a friendly API? No, because that's actually completely impossible in JS. :) Personally, I agonized over it for a while, and eventually settled on the excellent `tcomb` library (I see the author has already posted here); it gives you some very strong runtime typing, seamless-js style immutability, with standard immutability helpers stolen from the React project. Nothing super magical, but it's solid, and it works great with lodash and underscore. And it's *really* nice for validating and hydrating JSON from REST APIs, if that's something you need to do a lot. :) I like the idea of Immutable.js, but frankly nothing I use *needs* the fancy data structures; my global state is "a few dozen records and a few booleans", and it changes rarely. And the API is painful. And since premature optimization is the root of all evil... :)
Was going to write the same thing, then I got write the same thing about fatigue farigue fatigue.
I'd rather do geometry with my grandmother than explain why naming a post after the antithesis is a shitty idea.
&gt; you could use actual immutable data structures, aka persistent data structures. These are pretty hard to code, I don't know why you would think that. The secret to implementing immutable data structures is trees. It is just manipulating trees, nothing more. 
Rich Hickey of Clojure fame explains it here in this talk (about 2/3 through) https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/AreWeThereYet.md The whole video is worth watching too. 
But this article was actually about why you don't have to feel this fatigue. The title could have been better.
Where was the screenshot taken from?
From the [Mozilla's keydown event reference page](https://developer.mozilla.org/en-US/docs/Web/Events/keydown)
Like is said, if you use jQuery, you can use e.which. Otherwise look at the source to see what they use so you can safely use this.
Yea, that deprecation is pretty meaningless since you have to use keyCode for now. MDN really isn't helpful there. The new UI Events spec will make this a bit nicer, but it isn't finalized yet nor is it fully implemented by the evergreen browsers. https://w3c.github.io/uievents/
Yes. It is a mess.
Well okay, that's better. It helps me understand what you really intended with your comment. I didn't meant to be a dick, just wanted to know why you referenced jQuery for this
SFTP is annoying in comparison to what?
My current fave is CodeWars
Tell me when and where, and I'll help with explaining equivalent angles. 
Or you could put a ".bind(this)" after the method, or am I wrong?
Why? IOT doesn't really need to do much processing, generally it doesn't need to move all that fast, and writing in a higher level language means getting more done with less developer time. You don't need crazy JITs or extreme speed, just fast enough to handle the problem. It's better than using yet another BASIC variant or fucking around with custom C compilers that will never be updated, or a strange offshoot of Java that won't run most java libraries.
Should we merge this sub with r/microsoft ?
Learning, curiosity, boredom, demonstration. All four?
Not really. It's not as if `event.keyCode` will be removed any time soon - huge swathes of websites will stop working if it is. A lot of times parts of APIs are deprecated not because they will be removed any time soon, but simply because there is a better option available (`event.key`, in this case), and the API designer wants to nudge people to use that option. 
have a look at http://fmarcia.info/jquery/tetris/tetris.html it's dom based, using table cells. source is available and pretty easy to grok.
I think that's probably an issue with enzyme. Did you make sure to npm install exact versions of all the npm packages? Try npm i enzyme@1.2 and make sure your karma.config looks like the one in my repo
We're testing a reasonable sized codebase (20k lines of app js, 40k of tests), which is ran on both client and server with webpack, using sinon and proxyquire. The trick we found is to not run/build your unit tests through webpack. Instead, [use `node-hook` to run your tests under 'regular node'](http://joshhunt.is/testing-webpack-universal-javascript-in-node/) and take advantage of all the other mocking/dependency replacement libraries out there.
Nah. Vendor lock-in is when you write C# in visual studio, check in to TFS, do your kanban through TFS, add bugs and stories through TFS, build through TFS, and then deploy to azure websites with SQL sever for the data store. Typescript's syntax is similar enough to flow that you could move to that without too much hassle. Most of TS syntax is also ES6, meaning if you tell typescript to compile as ES6, you could just take the output and use that as your new source.
_ is a word character. Yes, this is illogical. From regexr.com: &gt; Matches any character that is not a word character (alphanumeric &amp; underscore). Equivalent to [\^A-Za-z0-9_]
Cool. Thanks for that. I watched a webpack tutorial video a few months ago when getting a project started, trying to decide on build tools. The main thing I remember about webpack is that the configuration seemed pretty involved. I decided on gulp/browserify and I'm happy with it. I think I'd need a pretty compelling reason to switch at the his point.
This is, to my humble opinion, the best way to deal with sequences of promises: (you can do this in ES5 as long as you have promises) const idsToDelete = [1, 2, 3]; // Mock DB deletion method dbDelete = id =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(`${id} was deleted!`); resolve(); }, 500+ Math.floor(Math.random()*500) ); }); }; // Actual code idsToDelete.reduce((previous, id) =&gt; { return previous.then(() =&gt; dbDelete(id)); }, Promise.resolve()); PS: Some promise libraries, like bluebird, include a helper method Promise.reduce that reduces this code to almost nothing. http://bluebirdjs.com/docs/api/promise.reduce.html
which uses keyCode, doesn't it?
Yep, it does. That's the problem, there isn't any real polyfill because at the time no browser has implemented `event.key`
I'd learn ES6 first. You don't need to be an expert or create a huge project-- just understand what ES6 is, how it's different from ES5, and how to use it. This is so Typescript doesn't come off as a brand new language, you'll see that it's just Javascript (and that's important!). 
X-Post referenced from /r/reactjs by /u/acemarke [React-Redux Links - a curated collection of links on React, Redux, ES6, and more](https://www.reddit.com/r/reactjs/comments/44xa3l/reactredux_links_a_curated_collection_of_links_on/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Sure, but that doesn't change the fact that what it's replacing is deprecated. This happens because of the fact that the designers of the API is separate from the people implementing it. Again, nobody says you can't use the deprecated parts. `event.keyCode` is something that has been in browsers since, what, IE4? Given how widely used it is I don't see it being removed any time soon. 
Something like the following could work: var myArr = [1, 2, 3, 1, 4, 1, 5]; var deduped = myArr.reduce(function(accumulator, value) { accumulator[value] = accumulator[value] ? accumulator[value] + 1 : 1; return accumulator; }, {}); **Edit:** You could also then generate a de-duplicated array using: var myUniqueArr = Object.keys(deduped);
Its nice that he has some idea of where that traffic is coming from. I still have no idea where my traffic is coming from.
Nothing wrong with using it if it's the only alternative, as long as your code seamlessly picks up the correct (non-deprecated) variable if/when it's supported. var x = e.keyCode; // key not supported is naughty and you should feel bad for doing it. var x = e.key || e.keyCode; // legacy fallback if not supported (or equivalent) is just fine. **Edit**: Obviously this isn't technically correct code because `key` and `keyCode` aren't interchangeable fields, but the fallback functionality (`= x || y`) is the important part - I probably should have used e.x and e.y in my example to avoid confusion. Turning this non-specific approach into functionally correct code for the OP's specific example is left as an exercise for the reader. ;-)
Okay, that's better. But `e.key` wouldn't be an int. It will be more complicated than that, thus you code example isn't really a polyfill. Look [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) to understand what I'm talking about. It's string ( `e.key` ) vs int ( `e.keyCode || e.which` )
This article seems to be aimed at people who are quite new to javascript. In case you are, I'd recommend starting off with JSPM first - for the most part, to get 90% of what this post describes, all you'll have to do is: npm install jspm -g cd my-project jspm init Then answer a few prompts, and start writing code. If you want that last 10%, you can mix it with livereload [as seen in this video](https://www.youtube.com/watch?v=iukBMY4apvI). As you get more comfortable with module building and the like, it'll make more sense about when to loop in something like gulp or webpack. 
Ok sorry I completely missed it: https://github.com/atom/electron/blob/a367934b956ed190642b5b9d3f0916ab6b530331/docs/development/build-instructions-linux.md Please feel fee to comment with any additional advice 
&gt; but if you're developing a future-proof application and you want to target only recent browsers and future versions you shouldn't use a deprecated property, because it won't probably last much. &gt; My concept of deprecated is "stop using it asap, we will remove that soon". You can't deprecate something and not give an alternative (which should be already implemented) These are all untrue (see my comments elsewhere in this thread). `keyCode` has been around for a very *very* long time. Browser APIs are somewhat unique in that many a times browsers themselves have to bend over backwards just to make sure older websites work. Think IE and it's compatibility mode, which essentially emulates all the bugs in older versions of IE just so websites that depend on those bugs won't break. With that in mind, do you really think browsers will be removing something that nobody before 2015 codes for? Of course not. Like I said, the deprecation notice exists because there exists better, more standard alternatives,not because browsers are going to remove it. 
Yea, I ran up against this last week. MDN could really benefit from a couple practical examples here. The polyfill was overkill for my use-case, so I had to look elsewhere fort the best approach. 
I have a working demo here: http://ngalluzzo.github.io/dropbox/ Still need to make a few changes but the whole uploading / pausing works. Let me know if you have any questions.
&gt; IOT doesn't really need to do much processing Efficiency translates to power savings. You can't get much more efficient than C or assembly when trying to make the most out of your 8mhz atmel chip with 1kb of memory. &gt; generally it doesn't need to move all that fast, Actually in many cases it does. PWM is important for a variety of IoT stuff such as heaters, light dimming, motor speed control and so on. Sure, you could use a slower language that sends HIGHs and LOWs to an IC dedicated to PWM, but that's complicating matters. &gt; and writing in a higher level language means getting more done with less developer time. Not true in the least. Tooling, skills, and an understanding of your environment, will determine how fast you can get stuff done. &gt; It's better than using yet another BASIC variant citation needed? &gt; or fucking around with custom C compilers that will never be updated Because they work as is? You're talking about microprocessors here, not full blown ARM / x86 architectures with ram, gpu, cpu, that you have no control over. It's an extremely limited environment with almost no wiggle room whatsoever. And this is done intentionally, as it is far more efficient. 
Here is the pre-built binaries: https://github.com/atom/electron/releases
awesome, thanks for sharing. 
Are you worried about your access token open client-side? 
No its a test account :) thanks for looking out tho
phew! haha. this is very helpful. in the event I use some of this code in my own project, I'll be sure to credit you at the top. cheers.
I've dealt with microcontrollers a lot in the past, and i'm glad that there are more options now. &gt;Efficiency translates to power savings. You can't get much more efficient than C or assembly when trying to make the most out of your 8mhz atmel chip with 1kb of memory. And the number of IOT things that need to run on battery for long periods of time is small compared to the number that can just use wall power. This isn't meant for a self-contained weather probe that needs to run on battery for months on end, this is for scripting your coffee pot. And increasing the power consumption for the chip there is going to have literally no effect on anyone. &gt;PWM is important for... And that's the level i'm happy to get away from. I don't want to write my 100th routine to deal with this shit, i want to call a function and have it do it for me. It's not complicating matters, it's abstracting it away. &gt;Tooling, skills, and an understanding of your environment, will determine how fast you can get stuff done. Eh... When all i want my little chip to do is to respond to a ping and turn on the lights, i don't want to care about securing buffers, writing my own TCP stack and DHCP server, having to deal with finding a way to get a fucking serial port on my laptop, or having to buy a $300 breakout board to program the damn thing, i'd love to be able to drop off a few js files and be done. Plus it opens up the doors to have "consumer" modifiable stuff. (just to note, i'm not talking about js specifically here, python/lua/etc would have the same argument). If i need to choose between an iot thing that can't be modified, or one that has a usb port where i can change the software by dragging and dropping files, i'll choose the latter every time. &gt;You're talking about microprocessors here, not full blown ARM / x86 architectures with ram, gpu, cpu, that you have no control over. It's an extremely limited environment with almost no wiggle room whatsoever. And this is done intentionally, as it is far more efficient. **but that's what i want to get away from!** I don't want to have to deal with a no-wiggle-room platform, i want to be able to program in something other than c89 or BASIC. And i'm more than willing to pay $5 a chip vs the $0.10 a chip + $300 breakout board + $100 compiler suite + $50 in special cables + $20 in breadboards, timing chips, resistors, and other shit. Yeah, you won't be using this stuff in mass produced products where saving $0.10 means making a few hundred thousand more, but for prototyping, for hobby work, and for products where the "consumer" is expected to be able to modify/tweak the programming on them, this is perfect! 
Ohhh boy. First off, you're using HTML comments in a JavaScript file. That's throwing errors. To do a single-line comment in JS, you use // - example: // This is a comment If your comment is spanning multiple lines, you use /* comment */ See how it is highlighting "if" and "in" blue in your "comments"? It is looking at those lines as valid JS code. You need to fix your comments first. Can you post the HTML code so we can see which variables are being passed from the HTML? I don't think "Hello_value" and "Hate_value" should be being passed as strings (by putting quotes around them, you are telling the console that they are strings, and not passing them as variables), but honestly to understand what the heck is going on here we need the HTML code. The snapshot of the website does us no good, besides seeing how it looks. Send the full code and we can help further. 
Thanks! Didn't even realize it lol. We need the full source code from your HTML. Go to the website that you pictured, right click and click "View Source". You built the HTML, right? You have to store the values the user puts in the JS somehow Also, to do the colors you want, it is possible, but again I need to see the HTML to see how your page is setup and tell you how to do it.
&gt; And the number of IOT things that need to run on battery for long periods of time is small compared to the number that can just use wall power. All the more reason for efficiency. All those microamps do add up after a while. &gt; And that's the level i'm happy to get away from. I don't want to write my 100th routine to deal with this shit, i want to call a function and have it do it for me. It's not complicating matters, it's abstracting it away. At the microprocessor level, abstractions are not a helpful thing to use anyways. You are coding to the point. Be specific, drop all that design pattern nonsense. &gt; Eh... When all i want my little chip to do is to respond to a ping and turn on the lights, i don't want to care about securing buffers, writing my own TCP stack and DHCP server, having to deal with finding a way to get a fucking serial port on my laptop, or having to buy a $300 breakout board to program the damn thing, i'd love to be able to drop off a few js files and be done. Depending on what you're doing, you don't need an expensive breakout board to program anything. It's not complicated to build your own atmel loader on a breadboard. &gt; Plus it opens up the doors to have "consumer" modifiable stuff. (just to note, i'm not talking about js specifically here, python/lua/etc would have the same argument). If i need to choose between an iot thing that can't be modified, or one that has a usb port where i can change the software by dragging and dropping files, i'll choose the latter every time. Ultimately, you want embedded devices to be full blown computers. and I'm saying this is not desirable because it is highly inefficient. Javascript and all other high level languages sacrifice efficiency for other features like classes and objects and promises and removing responsibility from the programmer, which in most cases is fine. But not on that tiny atmel chip of yours its not. On this scale, your responsibility as a programmer dramatically increases. And that's fine, because it's actually VERY liberating. I've written much code for Arduinos, so maybe PIC is more difficult, don't know. But what I do know, is that it is blissful to code. there are no design patterns, you don't have a collection of third party code whos behavior you don't fully understand. And C is about as simple of a language as there is. There is no magic, no middlemen, no bullshit. You don't need to worry about dependencies, operating systems, or anything else. you're just a few steps away from flicking electronics directly down the circuit. Coding C for an arduino, is the most straightforward, no nonsense code I've ever written and seen, and I have complete and total control over it.
Thank you!
&gt; IOT doesn't really need to do much processing, generally it doesn't need to move all that fast These statements are broad, sweeping generalizations. I'm working on an IoT project right now that needs to respond in real time; not "real time" like web socket "real time" but real time meaning something in the world just happened, and the time spent on an IRQ is too expensive, so the hardware and software are ready to execute on demand. &gt; and writing in a higher level language means getting more done with less developer time. Not necessarily. C has a huge set of libraries and macros that speed up development time greatly. It's not as if C developers write everything from scratch. &gt; You don't need crazy JITs Modern JavaScript engines utilize a JIT compiler, but I agree. You don't need a JIT on a microcontroller, especially because your microcontroller is probably working on such a small task that it's pointless to worry about JIT compiling machine code. &gt; custom C compilers that will never be updated What, like using an Arduino board that will run code compiled through an IDE that was last updated on 12/17/2015? Or perhaps Atmel's compiler and tookit that was last updated on 11/2015? Or ARM's? Microsoft's x86 compilers? Gcc/g++? LLVM? What the hell are you even talking about here?
Eclipse is a great example of the power of community but fuckin hell is it slow.
&gt; ... i don't want to care about securing buffers, writing my own TCP stack and DHCP server ... This is exactly what /u/i_ate_god is addressing when he says "Tooling, skills, and an understanding of your environment, will determine how fast you can get stuff done." If your first thought to get your chip to turn on lights is that you have to write a TCP stack, DHCP server, and worry about memory pooling, then you don't have a good understanding of the tools available to you, or you lack the skills necessary to utilize those tools, or you're very unfamiliar with the environment you're operating in. &gt; And i'm more than willing to pay $5 a chip vs the $0.10 a chip + $300 breakout board + $100 compiler suite + $50 in special cables + $20 in breadboards, timing chips, resistors, and other shit. Dude this isn't the era of proprietary Motorola microcontrollers. You can accomplish all of this with an Arduino or similar and a free toolchain. Also, if you need additional hardware or electrical components, your choice of language isn't going to change that. I don't mean to be rude, but get out from under your rock!
&gt;Modern JavaScript engines utilize a JIT compiler Not the one in the post we are talking about... That's why i brought it up. &gt;What the hell are you even talking about here? I think my personal experience overshadowed the point there. I've worked on microcontrollers professionally for a while. Like $0.43 per chip that have 128 bytes of memory. Generally with those you need to work in C89, some strange assembly for a custom arch, or BASIC (which is most common). Still, look at the rest of this thread, i think i've made the point i wanted to make. Whether you agree with that or not is another thing, but honestly at this point i don't care. I just wanted to put it out there that to me, a microcontroller running javascript is no different than one running java or python or BASIC. It's a language that more people will be familiar with, and it is better suited to some tasks than something like C is. Like for example, i don't want to write code for something that calls a REST endpoint and turns a relay on/off in C (tooling, libraries, and whatever else aside, it's just a poor fit for C to do something like that). In JS that would be like 20 lines total. And that's the kind of thing i tend to want when i'm doing my own IOT shit. it might not be what you traditionally think of as microcontroller work, but it's a valid use case, and i'm sure we are only going to see more and more of it.
Management flip flopping on which project I should work on on a sometimes daily basis.
Before you reply to every one of my comments, read the whole chain... I get that an arduino can replace that, but so could a javascript-based board just the same.
Thanks for the details. I'm aiming to create a visualization of the JavaScript event loop and how asynchronous execution works, as a learning resource. Do you know of any diagrams or resources that visualize what's going on under the hood? Here's how I'm imagining the broad parts of the state of the engine, which could be drawn out as a diagram. Can you tell me if this is accurate? - a particular active execution context - zero or more suspended execution contexts - a queue of event callbacks/resolved promises that are waiting for the current execution context to end - a list of event listeners and their corresponding callbacks
You could also just do: `return str.toLowerCase().split('_').join('-');`
Evaluating the countless frameworks that love to increase complexity for marginal gain... The JS world is tiring
Not sure why you want to do this, but this is a terrible idea. You should really look into handling whatever issue you are having differently. Also, people can still force close Safari or disconnect from the internet.
Screenshot? What categories? Let me see your code now
I think we should keep in mind that it's going to take a while for the consequences of this to really crystallize
Hm weird. Oh well, glad it worked for you. No prob, take care man
&gt; you are talking literally cents per month, it's a completely worthless amount of money to choose an entire system over... Not when you have numerous devices throughout your home controlling things. &gt; As per the rest of this, I think we have 2 different use cases in mind. I just want to have a small, cheap chip that i can get up and running as fast as possible with as little bullshit as possible, you seem to want a low-level coding experience. Arduino is about as bullshit free as it gets. You want an OS, package manager, third party dependencies and all of that needless overhead that doesn't actually help you in any whatsoever to turn a light off or on. &gt; That kind of freedom means that while you sit down to write something in C for your arduino (with it's 3 shields and 2 custom-made mounts and screens), by the time you have it compiling, i'm done a 40 line javascript file that calls an endpoint on our CI server and turns a light on/off depending on if the build passed/failed. That's because you don't know what you're doing. Turning off and on an LED can be done in two lines of clean code, one line of messy code. that's it. Want to do that over wifi with arduino? Yes you'll need the wifi shield but so what? you'll need a wifi adapter no matter what. Want to use a Raspberry Pi? You'll have to use a USB wifi adapter. No different than a shield except it's over USB instead of serial pins. big whoop. #include &lt;WiFi.h&gt; char ssid[] = "yourNetwork"; // the name of your network int status = WL_IDLE_STATUS; // the Wifi radio's status void setup() { status = WiFi.begin(ssid); // if you're not connected, stop here: if ( status != WL_CONNECTED) { while(true); } } void loop() { WiFiClient client = server.available(); if (client) { char c = client.read(); if (c == 1) { digitalWrite(14, HIGH); } else { digitalWrite(14, LOW); } } } there you go, 24 lines of code for the microcontroller to turn a light on when it receives the character 1 over wifi (maybe needs a few typos fixed). Then it's trivial to write the client code to send a 1 or 0 over a socket in any language, based on input from whereever. See what I mean? &gt; That kind of freedom means that while you sit down to write something in C for your arduino (with it's 3 shields and 2 custom-made mounts and screens), by the time you have it compiling, i'm done a 40 line javascript file that calls an endpoint on our CI server and turns a light on/off depending on if the build passed/failed. you don't know what you're talking about which is why you think it's long and hard. When I got my first arduino and started exploring electrical engineering, it was hard. It's still hard. There are concepts that I have difficulty wrapping my head around. But I am not adverse to learning and growing. And since I learned, it seems like I will be able shine a light of different colors based on build statuses faster than you, and more efficiently than you. When I first bought an arduino, that would not have been the case. Basically, you can't call something hard because you don't know much about it. And you don't know much about it if you think I need 3 shields, custom mounts, screens, and long compile times for a program as simple as one above.
I got a package for ya.
Uh, just use Atom for free?
Why are you forced to use Eclipse? I use Atom and it's amazing.
Well i thought we were having a good conversation, but now i don't know what i'm talking about... Regardless, there are plenty of small systems that include bluetooth and wifi on the board for under $25. Hell i just got my CHIP a few weeks ago from a kickstarter, and it's got a raspberry-pi zero sized CPU + wifi and bluetooth for $14 total ($9 per chip + $5 shipping) &gt;there you go, 24 lines of code for the microcontroller to turn a light on when it receives the character 1 over wifi (maybe needs a few typos fixed). And you skipped over the annoying part, calling a REST endpoint that's already up and running from some other product, and parsing the result. in js! fetch('http://stuff.things.co/endpointA/coolstuff').then((response)=&gt;{ if(response.body.build.status === true){ digitalWrite(6, 1) } else { digitalWrite(6, 0) } }) Set that in a setInterval and add some stuff for authentication (even oauth if you want it!) and you are set! That's the part that sucks when working with C. And i'm not saying it's impossible, just that you need more tooling, more libraries that are fairly non-standard, more custom code to support things like oauth, and even more libraries to properly parse stuff like JSON. The JS code above would work in your browser! (aside from the digitalWrite functions). It's Now please don't reply with your code that can do all of that, really i don't care. I'm just a guy who has no idea what he's talking about. And finally: &gt;It's still hard. I'm doing this for fun most of the time. Hell even when i'm not i'd prefer to enjoy making it instead of not. If i prefer doing it in JS and using boards that support JS, it's just as valid as your preference of using C on boards that support it! There is room in this world for both of us to be right! I don't want to be frustrated dealing with "hard" things when i'm building my automated cat scare-er... Oh, and: &gt;Not when you have numerous devices throughout your home controlling things. Fine, tens of cents per month... Even (GOD FORBID!) Hundreds of cents per month! But you should be the one making this argument, since the Arduino takes more power than a Espruino does... But regardless, if the power difference per day between the 2 is less than a few minutes of having the thing it's powering be on, it's pointless to argue about. We are literally talking about a 0.01-0.1 ma difference...
Same here. Atom is the best. Also, Sublime isn't half bad either. 
So far I've been using the EAP version of IntelliJ Ultimate. I have an old license at home but due to policy I'm not allowed to use my personal license at work. It's a political middle management decision. Most UI development is using GWT but my stuff doesn't work in GWT. Basically they refuse my IntelliJ license because of a battle between GWT and Javascript inside the company. 
That's what polyfills do. They can't magically make the browser understand new syntax, they have to implement the new syntax using old syntax.
What kind of a ridiculous place won't let a developer use his own tools?
You can display a confirmation dialog by using [window.onbeforeunload](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload). Simply return a string with the message you want the dialog box to say. DON'T create your own dialog box in that function. The redirect is a little trickier. Since PHP is actually a server-side language, there's not much we can do to stop the script from redirecting other than editing the PHP script itself. Just remove the section of code that initiates the redirect and you should be fine.
angular. 
download the runtime of sublime
I think that's the ideal solution. I'd probably externalize the reducing function to make it easier to read, but that's pure preference. var itemize = (acc, input) =&gt; { acc[input] = acc[input] ? ++acc[input] : 1; return acc; }; var myArr = [1, 2, 3, 1, 4, 1, 5]; myArr.reduce(itemize, {});// -&gt; {1: 3, 2: 1, 3: 1, 4: 1, 5: 1}
&gt; Well i thought we were having a good conversation, but now i don't know what i'm talking about... Ignorance is a problem that can be fixed. People taking it as insult need to chill out. You don't know what you're talking about, and that's fine, but you shouldn't continue talking about it as if you do, because it's not productive. And I will keep saying that because you have made some rather outrageous claims about difficulty and complexity that simply are not true. &gt; And you skipped over the annoying part, calling a REST endpoint that's already up and running from some other product, and parsing the result. &gt; Set that in a setInterval and add some stuff for authentication (even oauth if you want it!) and you are set! That's the part that sucks when working with C. And i'm not saying it's impossible, just that you need more tooling, more libraries that are fairly non-standard, more custom code to support things like oauth, and even more libraries to properly parse stuff like JSON. The JS code above would work in your browser! (aside from the digitalWrite functions). you're not thinking simple enough. Who cares about REST and HTTP? All pointless fluff that you don't need! Communication can be so much simpler dude. These technologies and concepts solve problems that you shouldn't really be having on the microcontroller world! &gt; Now please don't reply with your code that can do all of that, really i don't care. I'm just a guy who has no idea what he's talking about. The latter problem seems related to the former. &gt; Fine, tens of cents per month... Even (GOD FORBID!) Hundreds of cents per month! But you should be the one making this argument, since the Arduino takes more power than a Espruino does... There are plenty of things that use less power than the arduino, my point is that the arduino is far more efficient, and offers far better timing, than a raspberry pi, or anything else running a full blown OS with a language interpreter.
I'd use vim before I use notepad++ anytime 
You say I should think simpler, so how would you do it? How would you interface with a 3rd party secure REST endpoint in a more simple manner? Setup a server to relay the requests into a more simple method? Work with a second third party to relay it for you? Use undocumented heuristics to get it for you (the response that's over 3000 bytes is the pass, under is the fail, etc...)? Because I can't think of a way to make it simpler than just parsing the rest request on the device... I get that you like to work closer to the metal, but there is a time and a place for everything, and just because I am talking about a different use case doesn't mean I'm wrong or that I don't know what I'm talking about. FFS I spent a few years working on microcontrollers that had less than 128 **BYTES** of RAM, I assure you that I know about working close to metal, and I know about working 10+ layers of abstraction up. Higher abstractions are easier to work with, faster to develop with, and generally slower, but that gap is surprisingly (almost magically IMO!) closing every day. 
If the source is on GitHub, you can clone the repo, apply your patch and then reference your patched version in your `composer.json` or `bower.json`. If there's a new version released, you should be able to merge those changes into your clone. (Or if your issue is fixed, switch back to the primary.) I don't know if this is the best practice, but it's what I've done before.
ExtJS. Don't get me wrong, it's a very powerful framework...but since its propietary, the community is small and limited and that makes it very hard to find support outside of the developers own channels.
If you have two massive GeoJSON blobs that were constructed independently, and you're trying to efficiently generate diffs or detect if they're identical, then immutable data structures won't help you. Consider this code: let blob1 = Immutable.fromJS({1: {2: {3: {4: ['a','b','c'], 5: {6: 'test'}}}}}); let blob2 = Immutable.fromJS({1: {2: {3: {4: ['a','b'], 5: {6: 'test'}}}}}); let frag1 = blob1.getIn(['1', '2', '3', '5']); let frag2 = blob2.getIn(['1', '2', '3', '5']); console.log(frag1 === frag2) // prints 'false' console.log(frag1.equals(frag2)) // prints 'true' The efficiency gains from immutable data structures is that when you change one, unchanged nodes are still the same object, and the identity operator will allow for cheap equality checking. But in this case, frag1 and frag2 are different objects (despite having the same JSON representation), and the cheap identity check (`a === b`) gives a different answer than the expensive equality check (`a.equals(b)`). On the other hand, if you're mutating large JSON blobs, then you do get gains: let blob3 = blob1.setIn(['1','2','3','4',1], 'z'); let frag3 = blob3.getIn(['1', '2', '3', '5']); console.log(frag1 === frag3) // prints 'true' console.log(frag1.equals(frag3)) // prints 'true' Here the cheap equality check works, because the unchanged nodes in blob3 are literally the same objects as the original nodes in blob1. But, you don't need immutability here, you just need to not mutate your data. let blob4 = {1: {2: {3: {4: ['a','b','c'], 5: {6: 'test'}}}}}; let blob5 = R.set(R.compose(R.lensPath([1,2,3,4]), R.lensIndex(1)), 'z', blob4) let frag4 = blob4[1][2][3][5]; let frag5 = blob5[1][2][3][5]; console.log(frag4 === frag5) // prints 'true' That uses Ramda (a functional helper lib) to shallow clone of the blob and then modify the new object. (seamless-immutable, freezer, tcomb, the React immutability helpers, etc., would have done the same thing.) Of course, it's "just" a shallow clone, which may or may not be appropriate for your use case. Also, nothing stops you from mutating the data in place unless you use Object.freeze, but recursively freezing a large blob is pretty slow. And so on. If you really need to diff large, independently generated JSON blobs, you may need to think outside the box. For example, you could create your own tree data structure that calculates a checksum for child nodes and caches it on the node; then to detect difference you could start at the root and descend until you found matching checksums. Of course, keeping the checksums updated would be a challenge. :)
Developers bikeshedding over front-end tooling.
https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis &gt;Check if page uses too much memory &gt;Discover objects not cleaned up by garbage collection &gt;Narrow down causes of memory leaks &gt;Determine garbage collection frequency &gt;Memory Profiling Resources 
Well it worked on me!
~~Using search within the repository you can see that the variable is referenced in three different files. [From here](https://github.com/facebook/react/blob/c569b329e9334b59baf64e0c706af56521099383/docs/js/react-dom.js#L37) it looks like they use it to expose an instance of a singleton (ReactDom) to the global (window or server) object. It's like they're carrying ReactDom in the React namespace until they have access to the global object, at which point they instantiate it as a global variable.~~
Download to desktop and double click bruv
I have used Eclipse PHP during my good times as a back-end dude, pretty much anything will be better, except Notepad.
I use Firefox and do see how it uses less RAM overall than Chrome... But when I was on a low RAM 32-bit machine, the Firefox process would get too big in size and the process would get killed off. Chrome on the other hand has multiple processes each taking much a small percentage of RAM and those processes didn't seem to get killed off. So the perception was that Chrome was leaner. 
I don't know if the author really did due diligence in presenting both sides of the argument. Which is OK, but a bit disappointing. The case where I like using const by default is situations like this: const foo = {}; ...Some number of lines of code... foo.a = 'A Change'; Because you use const when I see foo.a even if I'm skimming the code I know that foo is the same object as the one described above so I know exactly what foo.a does. By comparison if you use let you could have something in the middle that does "foo = this.getOtherFooObject();". In terms of watering down the const keyword... I don't think that's an issue. For top of the module definitions you're either going to have import statements (which won't be const or let with ES6 style modules) or you have 'true' constants. In the case of true constants you should be using the CAPITIAL_UNDERSCORE naming scheme anyways so there's STILL no doubt about what's a true constant or not. You could argue you should be able to define something like "const trueConstant = 5;" at the top of your file, but that's just bad naming and will cause confusion. The second that definition is off the programmers screen/out of view they'll see it at just 'trueConstant' in the code and it'll be totally ambiguous regardless of if other variables are defined using let or const. I think there's good arguments for using let liberally, but there's some gaps in there when discussing why const liberally isn't good. That said it doesn't really *do* much either. It mostly comes down to which your team feels is more readable and if you value speed (by not changing consts -&gt; lets in some cases) or forcing developers to think about their variable usage (by having them not being able to arbitrarily reassign consts).
http://crashsafari.com
I was. I was in love with Angular2 during late-alpha and early beta. It's extremely powerful and logical and really felt productive using it. However, I still like React more...
i've used both and i prefer immutable-js. last time i checked seamless-immutable was lacking lots of basic functional features. when you're working with map/reduce etc it's really useful to have setIn, merge, mergedeep, updateIn etc
You don't use it over gulp, you use it together with it. To bundle your modules. Similar to Browserify. I love Gulp but wouldn't be able to do this with it: https://github.com/dmitriz/min-webpack
Just use key 
I use const for everything I can. I'm kind of annoyed that it's two extra characters, but hey, if I don't, my linter puts a big red line underneath. 
~~Because it's supposed to be a singleton is my guess. This could either mean having two instances of ReactDom breaks functionality in some way, or it is just a conscious design decision.~~ 
Key isn't implemented yet
Mission accomplished. ;)
I've mandated all ad code has to be in an iframe for this very reason. I don't think iframes block the main thread.
It's more about having massive geojson that pieces of changes over time and updating the DOM for only parts of them. 
I guess I'm too used to Django where people clearly communicate what they're intending to do and what progress is being made on it directly on their webpage, not Github. &gt; More so there doesn't seem to be any community around Marionette. What I meant by this is that there's not a whole lot of blogging, and bookmaking going on. It's like the gitter chat is it. Now that's not to say there's *nothing*, after all I did read reams of blogs from 2012-2013 about Marionette but current day stuff seems pretty sparse---probably due to the fact that 3.0 isn't out yet, and 2.0 seems deprecated.
I use const pretty much everywhere I can because it's closer to the intent I have when I write code. It also forces you to write an expression to evaluate a variable, which I typically find easier to read, maintain, and reason about. const message = TEMPLATE.replace(PLACEHOLDER, name); if (name === SPECIAL_GUEST) { // Wait! You can't change a `const` like this! message += ' You old so and so'; } A typical way this can be done with const is just to move the variable modification *to another variable*. If you give your variables meaningful names, imo this improves legibility: const hydratedTemplate = TEMPLATE.replace(PLACEHOLDER, name); const message = (name === SPECIAL_GUEST) ? `${hydratedTemplate}, you old so and so!` : hydratedTemplate; Which of the two reads better is of course a personal choice. My experience with functional language has tinted the way I see the two. Honestly, I haven't heard anyone yet say that this style improves performance or that you should change const to let when you need to modify a variable. I'm not sure where the author picked this up, but I find both arguments very silly, and mischaracterize the reasons to use const. Maybe the author confused when people were talking about *immutable* data structures, and understood this as *all constant variables*? Not sure. The main reason to use it is to make your *intent* clear, something which has tremendous value. 
How often do polyfills test if they were actually needed and NOP instead?
Disregard everything I said. There's a thread about it [here](https://www.reddit.com/r/ProgrammerHumor/comments/3nhk5e/secret_dom_do_not_use_or_you_will_be_fired/?). &gt;Basically the React team doesn't want to remove the DOM rendering code from React-core as of 0.14, but they want to introduce ReactDOM now so that by the time 0.15 rolls around devs will be used to the new semantics. In 0.15 they plan on moving all the DOM code fully into ReactDOM. - [comment by Novacrazy](https://www.reddit.com/r/ProgrammerHumor/comments/3nhk5e/secret_dom_do_not_use_or_you_will_be_fired/cvo8fyt)
In that case, yeah, you may be able to save time by ensuring you can do cheap identity checks instead of expensive equality checks. And you can do *that* by making sure that you never ever mutate an object. let blob1 = {a: [1, 2, 3], b: {'foo': 'bar'}}; let blob2 = React.addons.update(blob1, {a: {1: {'$set': 'z'}}}); console.log(blob1.a === blob2.a); // prints 'false' console.log(blob1.b === blob2.b); // prints 'true' Which is great; two quick identity checks and you now know what's been modified. But if you directly mutate an object, then it breaks: blob2.b.foo = 'baz' console.log(blob1.b === blob2.b); // still prints 'true' Ensuring that you never mutate your data is solveable via multiple methods (discipline, `Object.freeze`, Immutable.js, etc.). As for DOM updates, that'll be closely tied to how you're rendering, but if you're doing anything with React then immutable data + identity checks in your `shouldComponentUpdate()` lifecycle methods will yield dividends.
Yeah, it's weird to say that you use const only until you need to mutate something. In reality, I didn't want you to change the reference, that's why I made it const. 
Yea fuck those guys
1. JavaScript. 2. Developers badmouthing anything because they are unfamiliar with it. 3. Creating ads.
Isn't webstorm like 30 bucks?
Summary: If you like re-assigning variables a lot, you should probably use `let` by default, since you'll waste time going back and changing `const` to `let` every time you decide to re-assign variables. (Left unstated: Why anyone would think it was a good style to re-assign variables a lot...) As for his specific arguments: &gt; By const being the default declaration, let rises as the more visible style of declaration. The idea is that let flags where something funny is happening. However, function arguments like function(a,b,c) { are also allowed re-assignment, so it is a false sense of security to suggest no let means no funny business is happening. Variable re-assignment *is* "something funny", so this makes sense. However a good style guide (eg, Airbnb's excellent one) would already disallow re-assigning function arguments for this exact reason, and thus be caught by your linter. "If you have a bad lint config you can write bad code" is not an argument for writing *more* bad code. &gt; What is “expressed” by const itself when used this way? Since you are intended to refactor the declaration to let if the situation requires it, it can only express “this variable wasn’t being re-assigned when I wrote this code, but feel free to change that”. This is basically meaningless. In comparison, the expression of const in liberal let it akin to “this should not be re-assigned, proceed with caution!” which is far more useful. Again, valid logic. If you use `let` (or `const`) everywhere, then when you see the uncommon form it sticks out as something unusual. But I think it makes a lot more sense to make `let` be the unusual form, because variable re-assignment is (or should be) rare, and it can certainly lead to an entire class of bugs not otherwise possible. The author seems to think unchanging values are what's rare and dangerous, and, well...they're certainly not rare in *my* code, and I'm struggling to see how they'd be dangerous anywhere. Also: &gt; Some adherents of this style even suggest developers should use const but change to let only after their build tooling complains! To opt into such a slow process for little or no benefit is just short of madness. This is phrased as if that's actually difficult, but `eslint`will catch this *literally as you type*. If OPs setup doesn't do this, then this strikes me as "argument by use of my broken dev environment as example". &gt; Second, choosing const first really means choosing to think about every declaration. Will the next line of code change this assignment? Unless you have an eslint config that will catch this as you type. Except OP thinks that's "just short of madness". &gt; When declaring i, it is unreasonable to suggest any developer would declare it with const first, just to type i++ a few characters later then go back to make the declaration let. This kind of second-guessing happens all the time when developers choose const-first. So... "If you apply a good rule blindly, then it becomes a bad rule. We should just start with a bad rule instead."? I default to using `const`, but to then suggest that this means I'd write `const` *knowing* that I'm about to replace it with `let` is absurd. It's hard to interpret this as OP arguing from good faith; he has to know that he's attacking a straw man here. (Right?) The actual argument for `const` by default is that most variables don't need to be re-assigned, and if you don't think yours will, then you might as well denote that. (And if you *do* think you need to re-assign your variables, maybe you should think about a more functional solution to your problem? OP uses the example of a `for` loop, looping over some sort of iteratable. Left unsaid: Why `forEach` wouldn't have been clearer and avoided the entire question.) Tl;DR: Colour me unconvinced.
&gt;&gt; When declaring i, it is unreasonable to suggest any developer would declare it with const first, just to type i++ a few characters later then go back to make the declaration let. This kind of second-guessing happens all the time when developers choose const-first. &gt;So... "If you apply a good rule blindly, then it becomes a bad rule. We should just start with a bad rule instead."? I default to using const, but to then suggest that this means I'd write const knowing that I'm about to replace it with let is absurd. It's hard to interpret this as OP arguing from good faith; he has to know that he's attacking a straw man here. (Right?) This is even more of a straw man than you might think. Typically when you go all out const you avoid things like for loops since they are *explicitly mutation-driven*. This is what we have Array#map and Array#foreach for. 
Vanilla DOM ! Or it would be like saying using Spring or Hibernate is not "Vanilla java" which makes no sense. There is the language and the Web APIs. It's frightening that a majority of javascript developers can't even tell the difference ! there is no document.createElement in any javascript spec. 
If you're talking about jQuery then sure, absolutely. I haven't used jQuery in months and it's been really nice. Now that Microsoft has stopped support for pre-IE11 the need for jQuery will rapidly decline I think, and fetch certainly helps. Dropping jQuery should be something all developers who've been using it all this time should consider doing in 2016. That said, many front-end stacks are more complicated than what's described here though (I noticed you never mentioned a framework which leads me to believe you're not talking about a web app). Interesting thought about using template strings as a handlebars substitute. Seems pretty doable to me.
/r/hailcorporate An ad for New Relic, wow!
This is interesting because my Enterprise company decided on Scala with ReactJS/Flux the front-end. When we started the refactor (from C# .NET) this wasn't around. It's obviously still an infant but I hope it flushes out to be something we can justify working with. I'm looking forward to playing with Scala.JS now that I know it's a thing that exists.
What Web stack do you use in your company?
It's called content marketing in this case, and if you learn something from it, who cares?
We do this at my job, it's shit. 0 JS frameworks/libraries other than highcharts. I write new ghetto Lodash functions every week 😔
Sorry! Forgot that there'd probably be a lot of Node devs in this sub. I was basing my definition off http://vanilla-js.com which is where I started really paying attention to the idea a few years ago. Pokedex.org is a lovely example! The development post[1] is great and I love the focus on performance. PouchDB is a great use of a tool without being dragged down by it. Using third-party libs where appropriate is keeping in the spirit of Vanilla JS I think. My favorite part of Pokedex.org is that is uses ES2017 async/await (with Babel to transpile.) [1] http://www.pocketjavascript.com/blog/2015/11/23/introducing-pokedex-org
See reply above! I was basing my definition off http://vanilla-js.com. Apologies for any confusion.
Pokedex.org is by Nolan Lawson (unsure if comment OP) and you can read about the development here: http://www.pocketjavascript.com/blog/2015/11/23/introducing-pokedex-org :D
I was basing my definition off http://vanilla-js.com. Apologies for any confusion!
I totally agree! Maybe I'll write a followup about responsible lib use. &gt; Unlike something like lodash or jquery, where tons of people immediately know the API and can recognize how to do things with it. I agree here but I don't believe that's a reason we should just blindly use the flavor of the week (not saying Lodash or jQuery are.) I also think that since Vanilla JS is standardized and the language is more widespread than its libraries by definition, it still has a legup over external APIs. If you really can't clone a DOM element without resorting to jQuery you have a bigger problem. For the record we also use Lodash at work, but I didn't mention it because I was looking into replaceable, large-scale things.
There's no bias in this case. Did you even read the article?
Love me some property spread + dynamic keys var itemize = (acc, input) =&gt; ({ ...acc, [input]: acc[input] ? ++acc[input] : 1 })
&gt;I also think that since Vanilla JS is standardized and the language is more widespread than its libraries by definition, I mean yes, ES6 will be, by definition, but not so in practice. There's at least an order of magnitude more people who can read/write jQuery than use ES6, if not more. This is a pretty important consideration to make if you're working on a team, or on an open source project. Just some moderation is in order. Just because you *can* doesn't mean you *should*. 
Its important to remember that in JavaScript const doesn't behave like in, say, C++, where someConstant.mutableMethod() wouldn't work. So self = this, self.mutableMethod() is fine. For this reason its probably still best to use const since you are stating that self = this and will never = anything else. Some might argue the reverse and say "use let to make it clear that you can still call mutable things on it".
Sounds like a fun project to refactor in Vanilla JS! :D
&gt; There's at least an order of magnitude more people who can read/write jQuery than use ES6, if not more. This is kind of sad in itself. :( I would also say that if I were in charge of hiring at a tech company, knowing only/mostly jQuery and not straight ES would be a huge red flag. Sure, it expands your pool of talent, but how shallow or deep is that pool? I am in complete agreement about moderation. My concern is that the pendulum has swung too far in recent years toward the new and shiny. I recommend getting back to basics not because it's glamorous, but because recent developments have made it easier than ever. :) 
Agree with all the other comments that are pro-const. Further, I disagree that using const everywhere adds an "additional distraction" -- it actually simplifies code because the possibility of re-assignment is eliminated. Knowing what piece of memory a variable a bound to and knowing that this will never change makes debugging way easier over a lot js code I see in the wild where variables are re-bound at will. Furthermore, it reduces mental overhead to development. When I say "foo is a const" I am saying that this block was written with the assumption that foo will always point to a specific thing, and I didn't **need** to take into account the possibility that it may get un-bound later in the block. If I or someone needs to change the `const` later, I know that the change should be done with care. And as many have said, a `const` in JS is not like a constant in C, but more like a `final` in Java. It has nothing to do with mutability, though many of us wish there were a standard way to declare immutable variable bindings. I still use ALL_CAPS often for real, shared "constants", and the const keyword changes nothing about that.
&gt; I don't think iframes block the main thread. http://stackoverflow.com/questions/11510483/will-a-browser-give-an-iframe-a-separate-thread-for-javascript They may, they may not, it's not specified and every browser will do it differently. The only way to be sure code is running off the main thread is via web workers.
&gt; moving I'm willing to bet that has a lot to do with it. Or they don't know.
It'll be interesting to see what happens with HTTP2 and tools like webpack or rollup. HTTP2 is The Solution for asynchronous modules, but ES2015 `import` enforces rules that enable static analysis, so you can import small parts of larger libraries and bundle exactly as much code as you need in bundles. Essentially the same problem (complex dependency management is hard to do efficiently in the browser) has been solved from different directions.
No, I didn't. I was distracted by the shiny "hey, look, someone who's bought the content marketing bait" line. 
But then when it stops working you can blame the library and javascript tooling and convince your employer to switch Elm.
I think you can install atom without admin rights, or at the very least compile it without admin rights, but that work environment you're in is absofuckinglutely insane.
So you have all packages downloaded? 
1. Don't use `in` with arrays. It's usually a bad idea. It's not really a great idea with objects either, to be honest. Consider using `Array#forEach()` or just the typical `for` loop with an increment variable. Also, you should declare `i` and `h` with `var`. 2. When you loop over `away`, you're checking to see if *each* element matches your `word.toUpperCase()` comparison. What you should do is check to see if *one* of the elements matches. If you find a match, increment that object's `occ`. If you don't, then push the object to `away`. Probably a good use case for [Array#indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf). *edit:* Actually, i take that back. Array#indexOf() probably isn't a great choice, since you have to use strict equality with that. Forgot it doesn't take a callback. `Array#find()` would be better, but check the [compatibility chart](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) to make sure you can use it.
hmm, you also need keyboard support, type "esc" to close the dropdown overlay and other things I may be forgetting. Still not a big plugin but would rather rely on a plugin that has passed a few rounds of user testing and caught those bugs we never think about :)
In my opinion deprecation of something based on unfinished and unimplemented specs is throwing poop on a fan. I'm going to continue using keyCode property because UX is more important than this stupid browser battle.
Only thing that can justify such a shit salary is if your job is to click "Install" in WordPress and add a theme. Anything that requires more logical thinking should be rewarded an higher salary. 
anguar 2. 
I work with both 3d animation and javascript development. I usually have to make changes in about 4 different projects per day. Breaking the flow doesn't even begin to describe it.
Ah but we're in 2016! And language rankings are notoriously fragile. In February 2016, TIOBE says that Scala is #30 and F# is #36 http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html So it looks like Scala is becoming more popular than F#, at this point ;)
i think ecmascript needs a removeWhere(fn) and maybe arrayreset() normally when i delete multiple items, i do `arr = arr.filter((item) =&gt; !item.prop)` but for people who use obj.observe, doing that or something as simple as resetting the items `arr=[]` unbinds the object.observe function. so no change events are go through. it makes sense, but is a pita to debug. its kind of silly to say hey we added object.observe and array.filter and array.flatten, but dont use them together cuz you wont get events!
This is not an issue as Object.Observe is not going to be added to ES anymore. In fact it is not in V8 from version 50 onwards (the current version of v8 is 48, so 50 is only a couple of months away).
X-Post referenced from /r/node by /u/keithwhor [Easy Node.js GraphQL implementation, interfacing with PostgreSQL](https://www.reddit.com/r/node/comments/4520u2/easy_nodejs_graphql_implementation_interfacing/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I don't see lodash on there
From internet users everywhere: FUCK YOU!
I'm working on a library myself. In part for practice, in part because as of now it's 2kb gzipped and already covers most of what I'm aiming for. It's modulair with little overhead and quite straight forward. JQuery is quite impressive, but has a massive amount of boilerplate and is quite slow. It's not bad, but I don't need support below IE 10 anyway.
It's a NR blog post but it is pretty informative. The agenda isnt hidden, but the content has value. Get over yourself.
OP's article has an interesting link at the bottom with an article talking about what http2 means for packaging: http://engineering.khanacademy.org/posts/js-packaging-http2.htm tl;dr: it seems loss in GZIP efficiency and lack of support in browsers offsets many expected gains from using http2 + many small files over bigger bundles.
I stopped reading when he started using Typescript
Graphic: https://twitter.com/suarezgolborne/status/568010816479498240
 const FULL_NAME = Object.freeze({ first: 'Bob', last: 'Marley' }); // this will now raise an error FULL_NAME.first = 'Jeff'
Some links that may help: [JavaScript Interview Questions](https://github.com/malachaifrazier/JavaScript-Interview-Questions) [More of the same](http://madole.github.io/blog/2014/07/19/javascript-interview-questions/) [Links to even more](https://github.com/MaximAbramchuck/awesome-interviews#javascript) If you want to try testing yourself in a friendly and supportive environment try doing some of the JavaScript exercises on [exercism](http://exercism.io/). Most of those problems are typical of interviews, this will let you try them then see a bunch of different ways people solved them. I learned a lot of new techniques reviewing other peoples solutions. 
The headline says it's an article [about Map()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map) - but it's an article about the Array.prototype.map method. Two completely different things, capitalization matters.
I disagree with flatMap. Each function should be responsible for a single action. We aren't talking about a CPU instruction set where these kind of optimizations are critical to performance. The compiler(s) can optimize `.map(...).flatten()` for us if there is optimization to be had.
Because cost of living - of what use is a Bay Area salary to anyone with a family? Also, you can't buy your friends for money. once you leave them behind that's it. Yes yes yes - just make new ones. Okay, have fun - because a decade or two of friendship history don't matter...
I feel a major turn off cluttering my code with proprietary ugly and lengthy properties such as `componentWillReceiveProps`. If that is not framework lock-in, then what is it? Plus no respect for prefixes. In Angular I see `$watch` and know instantly it is Angular. In React I can only guess. Looks like recipe for troubles, for no reason. 
Interesting article, though I think the author overrates the ~5% compression savings they're getting. I think browsers have a long way to go with their bandwidth management over HTTP/2 connections. Chrome hasn't implemented dependency based prioritization, for example, which means that in the real world, a lot of HTTP/2 based pages are seeing equal or slower load times than HTTP/1 because big CSS downloads are being slowed down by other assets. In the HTTP 1 world, the CSS is downloaded *first*, and we can get a page render done quickly.
The goal is to be a good programmer. What ever methods you use to get there are fine. I have my preferred method of working, you have yours.
I think this approach is ok. If you really want to avoid the DOM lookup, you could make your components globally accessible (maybe through registry pattern) and then instantiate them inline when outputting the component markup by giving them a unique id. Something like &lt;div id="dropdown-123"&gt;&lt;/div&gt; &lt;script&gt;YourRegistry.getWidget( 'Dropdown' ).new( document.getElementById( 'dropdown-123' ) );&lt;/script&gt; I don't think you gain much with this approach, though I might be wrong. Another approach is to switch to frontend rendering.
Getting a plain vanilla "Hello World" with no TS, no Rx, no ... bs, with minimal dependencies. How large is the minimal A2 example again?
Yea, I think the prioritising needs to be addressed. Something explicit would be nice. Currently I kinda like having my assets and content on different (sub)domains using CDN's and sharding. Does http/2 offer much here? I don't want my application server to touch dumb bytes, not even for pro-active server push. Time will tell I guess, it is still early.
I don't like flatMap by itself, either, but it would seem to be quite useful when part of higher-level functions. For libraries that need such a functionality, maybe it would be good for them to have something 'standard' to wrap around. True, it's not some CPU-level optimization, but it might be in the JS engine or JIT code.
So many of my projects have devs adding libraries to use one function - I've even seen both lodash and underscore in the same project. Most of the time this one function takes 5 lines of vanilla JavaScript. All this really does is inflate the package size needlessly.
A truly visionary module!
I'm kind of confused... Do you really need the radio buttons? Walk me through your setup on high level... Like "A user opens your page and sees four images. The user can click on of the images and x happens... If they click a different image, y happens..." kind of thing.
You should use "data" attributes: $('[data-dropdown]').each(...); You can put this code at the end of your component. Take a look at bootstrap's js components...
We'll see now that 1.5 is out!
So, the way it needs to work is that a user opens the form and sees a number of different questions, with the answers presented as a grid of images, of which the user can only select one for each question. When an image is clicked, it's swapped out for another image to indicate it's been selected. If the user changes their mind and clicks another answer, the one previously selected needs to revert to it's previous state and the new answer image is swapped out to indicate it's selection.
Sanders is more a plain javascript start over type.
I think flat Map would be .map(...).flatten(1)
Done: http://codepen.io/anon/pen/jWXrBV
Your specific use case was to turn lights on or off based on build statuses from your CI. So the simplest approach, microcontroller or not, would be for the CI to tell someone a build status, not to ping it for a status. As for talking to a 3rd party secure REST server, it all depends. As someone who plans to setup lights that will respond to various "stimuli", the only approach that makes sense to me is to use a raspberry pi as a relay server, and use individual microcontrollers per set of lights, communicating with the rpi over RF since let's face it, the lights themselves only need to know "what color, what brightness" and nothing more so they will never change once in place, while REST services, especially third party ones, can and do change. As well, it's a lot easier to move the lights around. Far less wiring, far less mess, far more flexibility, barely an increase in effort. &gt; FFS I spent a few years working on microcontrollers that had less than 128 BYTES of RAM, I assure you that I know about working close to metal, and I know about working 10+ layers of abstraction up. Higher abstractions are easier to work with, faster to develop with, and generally slower, but that gap is surprisingly (almost magically IMO!) closing every day. Look, maybe I was being a bit harsh, but you were making egregious and patently false claims about working with microcontrollers.
Just wait. You'll get bug reports somehow. Doesn't return a 3 when expected so it doesn't fit my use case. Please fix.
&gt;So the simplest approach, microcontroller or not, would be for the CI to tell someone a build status, not to ping it for a status. The problem is that doing that would end up taking more time and effort because i'd need to make a "custom" process for this one application. It's much easier, faster, cheaper, and more "fun" to do it without having to modify the CI's code as the CI already has a pretty comprehensive API that includes authentication, encryption, WAY more info than just pass/fail (if i wanted to do something cool like blue for project A failure, green for project B failure, etc...). Not to mention that in our case we don't own the CI code, so modifying it would take a LOT of work... I mean look at the paragraph you typed up there!? a raspberry-pi relay server, RF communication, multiple microcontrollers... How is that in any way better than having a single $9 chip that pings a REST endpoint via wifi every 5 minutes and flops a relay on/off? That's what i'm trying to get across. Sometimes working closer to the metal is important and extremely useful, other times it's a headache that stops projects before they even begin. And while i'd laugh in your face if you wanted to use javascript to do something like video encoding, it's a perfectly valid language to use for something like this.
If it is a single action on a data structure then couldn't the name reflect that? "flatMap" seems pretty awkward, I think you will just find a lot of people misapplying "flatMap" as flatMap().flatten(). I understand "bind" is probably not the best choice.
atom-ternjs This is my default .tern-project file { "ecmaVersion": 6, "libs": [ ], "loadEagerly": [ "lib/**/*.js" ], "dontLoad": [ "npm_modules/**/*.js" ], "plugins": { "node": {}, "complete_strings": {}, "doc_comment": { "fullDocs": true, "strong": false } } } Our structure is that all our source files are in `lib`, and I'm a back-end dev (hence `node`). Read the docs on how to customize it (https://github.com/tststs/atom-ternjs) but for the most part it works great out of the box. I've also set my autocomplete popup interval to a larger value because having it come up after every 100ms was **extremely** distracting because my screen would constantly pop as I was typing (and I code fast), and I expect, it was a resource drain. http://imgur.com/EPVgZTU 
You'll get same effect with classes, data attributes its just a good practice.
Marketing is a reality. At least content marketing provides some value to the reader, and it's generally better researched than half the blog entries Google pulls up when you're trying to solve a technical issue. Plus, you're on reddit, which is a fantastic example of an echo chamber that lacks critical thinking (in many subreddits). If that's your concern, you're in the wrong venue.
Obviously browser support is bad, that's just a reality for any new feature. At least now all major browsers auto update. And it doesn't really matter if you lose 5% compression if your bundle doesn't have 100kb of unnecessary modules. I'm very interested because tree shaking lets you get rid of unused code within an imported file. Ideally, webpack/other tools will just update and provide asynchronous modules when there are environments that support it. With server side rendering, tree shaking, and HTTP2, we seem to be about to enter a golden age in complex app efficiency.
Yes, but keep in mind with things like lodash and modernizr, you're supposed to customize the build when you go to production to only take what you need. When tree shaking becomes more popular, this will also become much less of an issue, since whatever you don't use just won't be included, and will get automatically included when you *do* use it.
https://jsfiddle.net/c86a29uL/ Works fine with Chrome 49. It doesn't work in Firefox yet though. https://bugzilla.mozilla.org/show_bug.cgi?id=449811
Yep. I wasn't trying to make any kind of point there I was just pointing out that by default `flatten` is recursive. My point is that the `flatMap` method is a generic operation that can apply to a lot of different structures, whereas `.map().flatten(1)` is not.
Maybe, but `flatMap` is the choice a lot of other languages made too. So there is some cross-language consistency. If they're going for the monadic interface thing they called the same operation on promises `then`. Makes sense, but isn't totally consistent.
the lack of `removeWhere`is still an issue if you want to filter `this`: List extends Array { random() { this = this.filter(item =&gt; ...some random ones) } } because `this` can't be explicitly redefined with a new array, and `Array.filter` does not modify the original array, something like `removeWhere` would be handy. instead i had to loop through the array and `splice` items.
Just keep in mind the differences, you can still take things from this article. It actually outlines some really intriguing paradigms for angular 2.
Eslint is better.
It is, people just aren't using strict mode for some reason that is way beyond me.
Right. I don't run into this issue on node where we're explicitly putting everything in strict mode and not transpiling.
cool, i'll check it out. 
&gt; I see "a" logged three times I get: a, b c, x, y, z (as I should) &gt; I had expected it to fail when it reassigns the variable on each pass through the first loop. You get a fresh binding with each iteration if you use let or const (for-loop iteration scope). That's why const works and that's also why you can close over the loop counter. for(let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 0); } =&gt; 0, 1, 2 for(var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 0); } =&gt; 3, 3, 3
where does the `?levevalueOf` fit in? Why is it not `level`
eslint is the way to go. and yes, javascript so very desperately needs good linting.
To add to that: Webpack is a *bundling tool* for static assets (html/css/js + whatever targets those), while Gulp is a *task runner* for automating your entire workflow. The difference is that Gulp can do other things, like run a local test server for your code (and can also run Webpack for you as one of its tasks).
Yeah, I wonder what the numbers would have been if he used ab or siege (not sure if they have the same shortcomings) 
SystemJS is a module loader. It can load any module format for you in the browser, including ES6. It's used heavily by [Aurelia](http://aurelia.io) and [Angular 2](http://angular.io). JSPM is a package manager + bundling tool: it makes it easy to both install packages either from npm or bower &amp; bundle your modules with those packages into something easily consumed by SystemJS. Aurelia uses this, but Angular does not. You can use Babel to compile your modules into SystemJS format through [this plugin](https://babeljs.io/docs/plugins/transform-es2015-modules-systemjs/).
&gt; Hi everyone, some background. I'm generally been a back end developer that is trying to move more towards the client side. While i have dome some minimal client side work its not much. I wouldn't waste your time with a bunch of build tools. Build tools come and go. Mastering a build tool or a configuration process makes you a master of configurations, which has no bearing on your ability to actually program. If you want to get into client-side development then you clearly need to learn the technologies: * JavaScript * HTML/XML * CSS * DOM (an API from JavaScript to HTML/XML) If you want to be a less crappy client-side developer you will learn accessibility, seo, and a little bit of micro-architecture. Since this sounds like it is really about jobs lets talk about that: * There are about 11x more Java jobs in the US than JS/UI development jobs. * There are a lot of UI developers in the marketplace. * Senior UI developers are extremely hot commodities. In my geographic market I get an average of 3-12 job solicitations each quarter. The math there clearly doesn't make any sense. If there are 11 times more Java development jobs than JavaScript or UI development positions then clearly the front-end positions are substantially more rare. I said there are a ton of UI developers in the market, which is true. These things mean there should be absolutely no demand for front-end developers because the market is substantially over-saturated. The discrepancy is that there is a very real and very noticeable talent gap in front-end development. Web browsers are extremely forgiving platforms. If you write completely horrible code it will still render in the browser and might even not look like garbage in your favorite browser. Obviously, this doesn't mean you have mastered the field merely because something appears to work (kind of). If you want to be in demand and want to have a foothold in the market place then don't even bother trying to cut corners with tool and configuration madness. This insanity **might** help you get a contributor level position, but has no bearing your ability to solve valid problems.
You are getting downvoted because you are clearly trying to pick a fight about React vs. Angular on a thread where that clearly isn't the point. There's a big difference between saying "Angular2 is way more nice to work with than React" and "I personally prefer to work with Angular2 instead of React."
Angular is a framework. React is more like a library.
I only downvote whining about downvotes.
Ah I don't think either camp (React or Ionic) should blast each other. They're both progressive which is great to see. Let's just discuss the good and bad of both without getting into a competition. I've used them both, but definitely have used Ionic a lot more. I'm interested in React (specifically Native).
How about NeutralORM? Neutral cause it doesn't decide your backend and ORM cause that's what it is. Or NeutralSyncORM if you wanna emphasize the syncing part. Or NeutralSync. Tough to decide. Good luck! :)
Uh, where have you been? It was like that for **years** with Angular, and even worse when react started catching up. Angular sucks
&gt; This is a little controversial, but if you're finding that the majority of your website's visitors are blocking ads then you might want to try displaying a friendly message asking them to disable it. OR, you could change to an advertising scheme that doesn't incorporate the kind of privacy, performance, energy, and security abuses that third-party ad networks never fail to deliver. Look at what small time blogs do with their personalized, first-party ads for specific products that the site operator thinks is a good fit for his audience? Or ads that are integrated into content, not as ads, but as sponsorship of products directly related to the content. Or patreon, or amazon affiliate services, etc, etc. If most people are already blocking your ads, you've already abused them too much to hope for that kind of change.
That address doesn't look safe to click on.
Shouldn't people be using the most effective tools to get the job done? I don't get why you would write a SPA In pure vanilla JS. Does your boss hate tools?
If you want a more detailed opinion and why do I personally prefer ionic/angular2 over react, then here it is: 1) As a developer, my goal is to make apps, not to do some plumbing of different libraries to create a "stack" that isn't even standardised. 2) Angular2 offers everything we need to make apps, in a clean and structured manner. Typescript is also a bonus and now I feel myself more confident when writing code and use my old and still useful objet oriented patterns that I learned in my software engineering classes. 3) React isn't full featured and needs other libraries to make it like a framework. In less than 6 months, we already saw more than 10 ways of writing full featured react apps. This makes it hard to work with other people and integrate new devs in teams. I hope that this answer doesn't frustrate anyone this time.. 
Wow, how much space?
ooo, that's nice. Explanation: azium is returning an object, defining that object as all the properties currently in acc via the object rest parameter syntax, and then overwriting the current item key with either the old value, incremented, or 1. Very cool, and avoids creating a new block. Unfortunately, rest params in objects aren't actually in es6 or usable in browsers yet: they're an experimental plugin Babel and still a proposal, but they could still be removed/rejected or just never get incorporated: https://github.com/sebmarkbage/ecmascript-rest-spread If you still wanted to avoid creating a block but wanted to do something that modern browsers support without transpiling/plugins, you could use Object.assign maybe? var itemize = (acc, input) =&gt; Object.assign(acc, {[input]: acc[input] ? ++acc[input] : 1});
I have a problem including stylesheets. Ideally I would like to be able to define my layout, styles, and interaction all in the same place.
Would that work in Atom as well ?
No doubt there's a lot of bad actors in the advertising network space and probably endless sites that have abused their visitors, but we think there's going to be many positive changes coming to the advertising industry because of ad blocking. I totally agree there's huge potential for sites of all sizes to run more first party ads and affiliate offers that are relevant to their site's niche &amp; audience's interests.
I have questions about cycle.js though!
`somePromiseOperation` must be a function. Promises are eager, so you can't rerun their body.
Can you elaborate?
Not only are they eager, their result is stored when it is completed and cannot be changed. This is why the examples are confusing, since it looks like it's retrying a promise, not a promise-returning function.
Neat. Why export a class instead of a function though?
ugh, i actually use it in one of my projects. wtf
yes you are correct, I initially had it as a function and will adjust it :)
Problems might be an overstatement but having a space show up as a syntax error? It all seems a bit overkill! It wouldn't be such an issue but my lecturer docs marks for JSLint errors. 
Seemed like the right approach - I want to add more functionality later. Plus you only need one reference to the class as you can just pass new functions to it.
I think SVG would actually beat canvas in this situation... Actually, the more I think about it, yeah, SVG is your winner. You would just define the, what, four? unique shapes and &lt;use&gt; elements for the game instances. From there the transform code is incredibly simple.
1. Because it's geared around creating large applications. It's overkill for a hello world example, but when dealing with real-world data models being worked on concurrently by large teams, it becomes very useful very quickly. 2. The 3 .ts files could easily be one file, and would be pretty much the same code length/complexity as the react example. Conversely, the react example could easily be structured as 3 different imports. Again, this is just an artifact of different approaches to a "hello world" example. 3. Your React example uses ES5. The Angular example is using Typescript transpilation. For one thing, this is generally done at build time, not runtime, so a lot of the scripts in index.html are really only to make it work in plunker. You are welcome to develop Angular2 apps in ES5, the code is just a lot easier to work with in Typescript (for example, I see you don't use JSX in your React example). TL;DR : The React example works but does not reflect best practices in any way. The Angular example attempts to provide guidance towards proper application structure. 
Blitting images and drawing rectangles is cheap and hardware-accelerated. You have to use WebGL if you want to beat it, but there would be no point in doing that unless you use an insane amount of particle effects. SVG isn't a good fit for games. Board games, maybe.
But how often do you need to re-use that instance across different functions (especially when you pass the `delay` or `onFail` options)?
Nice - looks good. ES6 for the win :)
This is -tetris- we're talking about. It practically is a board game. There's like 100 polygons, max, SVG wouldn't even blink at this.
Who is this JavaScript character, and what gives him the right to promise us a free course from Udacity?
If you need to keep it client side, you might want to put your data into something like this - https://github.com/mourner/rbush and then run your spacial queries against it. Its very fast - I'm not the dev, just a happy user.
Sure. But it wouldn't be faster.
I agree 100% it's just when people make statements like "Angular2 is way more nice to work with than React" it's just an effort to derail the actual conversation.
Well our site for the most part isn't a single page app. There's one section of it that is like a faux SPA powered by some really atrocious code. I think we're nearing a tipping point where we'll benefit a lot from having a more modern setup.
1) The thing you *really* want from a front end framework, whichever it is, is data binding. When you get new data from a server response or from a click event handler, you want your view to update on its own. Pretty much every framework choice has this baked in for you. As for which one to choose.. well that's a different question, but a lot of people will say React lately and I tend to agree. 2) Tooling can be confusing, but it's totally worth it once you get setup. It's not super important which tools you choose, but ES6 transpilation (babel) and module loading (webpack/browserify) are lifesavers. Also after you get it setup once you don't really have to worry about it again.. that being said there are a TON of boilerplates ready to go if you don't want to bother setting it up yourself. Update: a linter can go a long way. I use Atom as a text-editor and eslint with a very minimal set of rules to keep me from hitting runtime errors. 3) Don't panic! If there's anything I've learned over the last few years its that the internet is full of people who will go way out of their way to help people, including me. PM me whenever you feel like! Join some gitter or slack channels, where people mill around just to help out. This sub and r/learnjavascript are good too. Happy coding! EDIT: noticed you posted this in r/webdev, just want to add an "un"warning. A lot of people will say React is 'just the view' and because of that you need to add a bunch of stuff to make a 'real app'. I wholeheartedly disagree. I've built a large React app with Redux &amp; React-Router, which are pretty small additions to the stack, and I've built several small/medium sized apps with React alone. It's pretty powerful all on its own! Only go down the "flux architecture" path if you have a ton of components that nest fairly deeply, or have multiple apps talking to eachother (mobile + web, for instance)
Best practices for building large applications. In a significantly large application, you wouldn't be bootstrapping your app inside a script file for a component. You'd also be using JSX, which would increase your toolchain complexity. You'd probably also be using ES6 at the very least, but probably some kind of tooling that allowed model schema like Typescript. Also, I think the word this week is that stateful components are like totally last Friday. 
You know that Angular example [is from their official site](https://angular.io/), right? (See the first example). I've worked with Angular for around 6 months, went through it's source code, watched days worth of videos, Misko Hevery, John Papa, Dan Wahlin.... all the people. Have been working with React for around a year now. Angular 2 still has horrible faults that 1 has, the Tag for components. After using JSX HTML becomes a joke, using Tags are a way to specify component name to be used in the template, you need: `mycomponent-header` `mycomponent-panel-header` `mycomponent-panel-footer` fuck sake this shit :D Because in React the view is just JavaScript i can reuse variable names without causing collision when rendering. It's not about "Angular vs React", it's about technology. Utilizing the full power of a turing complete language vs a hacked DSL (how angular needs to adapt HTML to it's binding/event syntax) for describing the view of a component. And not even talking about all the OOP waste of time they've built. Comparing [Elm](http://elm-lang.org/) with Angular i just can't understand the mindset of the whole team, no wonder [Rob Eisenberg left](http://eisenbergeffect.bluespire.com/leaving-angular/) to start [Aurelia](http://aurelia.io/). The whining about needing lots of stuff to use React is bullshit, look at .Net, try to build a MVC app, you hear .NET devs complaining?? There's a looot of libs to get an MVC app with Entity Framework + Injection and stuff... but I still have not seen complaints like the ones from front-end devs, why? because Visual Studio. Tools that make it easy to get started. Seems like theses people nether heard of [Yeoman](http://yeoman.io/), and one could also throw Webstorm with all its plugins on top. npm install -g yo npm install -g generator-react-webpack-redux yo react-webpack-redux And that's it, you're ready to go, it's done, just code! Want hot-reloading, [here!](https://github.com/gaearon/react-transform-boilerplate) I use this boilerplate to get started on any project quick. I've seen many frameworks/libraries e.t.c... Elm looks great, [Om](https://github.com/omcljs/om), [CycleJS](http://cycle.js.org/)... but Angular disappointed me a long time ago (i even made a [tiny project](https://github.com/thelambdaparty/TangleNgTumblr/blob/master/TangleNgTumblr.js) with it)
Yes, look at this sample app, there's a link of the hosted version. http://coenraets.org/blog/2016/01/ionicrealty-new-ionic-2-sample-application/ 
Yeah.. It would be really really nice to have this exact same article written but starting from a perspective of "this is the behavior I observed when I did X" rather than "this is the benchmark I ran". It's got a bunch of useful info but it's a bit muddled by the benchmark.
Thanks for the response and the offer for more help, much appreciated. I'm happy to hear the positive feedback of React; my company is starting to use it a lot so learning it now will make me that much more valuable at work :)
It might seem like overkill now but part of it is about productivity in the long term and reproducible. A space here or there doesn't seem like much but added up over the course of a project life-cycle across a development team these little extra keystrokes at weight to the files and take up time that equates to consuming budget for things that don't add value. It's also one of those things that is really getting you to think about attention to detail because sometimes some little thing like that, that seems nonsensical is what takes hours and hours of time to debug (i.e. missing brace, missing semicolon, extra brace, trailing comma, period instead of a comma, etc.) 
Does GraphQL and Relay work outside of Facebook yet?
ExpressJS is a webframework and offers no opinion over what you use for CSS. It doesnt restrict how CSS is done. Are you asking how to incorporate a SASS preprocessor into your build process? I dont use SASS much but you can grab something off npmjs.com that would probably do the trick: https://www.npmjs.com/package/gulp-sass 
Honest question. How does standard/semi-standard play across multiple devs? Like the advantage, imo, of those configuration files is devs on the same page via version controlled files. Checkout project, everyone is on same page. I do like the sound of the whole "I won't have 50 million .eslintrc files for different team projects" thing though.
I'm a little confused as to actually start an express project with all the tools i want to use as a lot of tutorials gloss over that and get you started with the bare minimum. Do i need to use something like gulp to process my jade and sass files? When i created my first express project it came with jade files already set up and just processed them on the fly 
Isn't Redux the de facto Flux solution?
Good point that you're comparing .NET to build an MVC app: it is called ASP.NET MVC. ASP.NET MVC is a full featured framework that comes with all the necessary libraries and tools to build a complete application. All those libraries and tools integrate very well, are stable, used since a decade and have some kind of conventions and best practices to follow, and are developed by the same people. The developer doesn't feel that he has to make a decision, that he has to do all the plumbing, that his code will be obsolete in 2 months because some other library will pop up on GitHub and have 5k stars in 1 weeks... Now, try to find a JS framework that is like this, front end or backend. Angular and Ember are the closest to this, no wonder why they are the most used for big and serious apps. And by the way, in only this message, you made me try to decide between TWO boilerplates, which means TWO different bases, which means maybe TWO different structures and apps in the future... wonderful !
Gotta Love promises!
it's considerably simpler to use plain javascript. all these abstractions on top of it accomplish very little.
PM sent! Here's the source we published: https://github.com/ParabolInc/action I think you're right saying that Falcor hasn't quite taken off as quickly as the Netflix team had hoped. When we started writing our foundational code, most of the examples surrounding Facebook Relay were very tightly coupled to managing the React state directly. We didn't like this. Falcor seemed like a much more straightforward path to getting what we wanted (never to write a plurality of CRUD routes on a private API, caching, batching, etc.). As the world is moving very quickly now, there have been some great examples published recently of using Redux and Relay together. Here's one we like a lot: https://github.com/mattkrick/meatier Spiritually, Meatier is very similar to what we just published. It uses just about all the new fangled things that are new for the next few weeks ;) We're using a bit more of what we're familiar with. In any event, we're very happy with what we've built and been working well in development and in our testing.
Facebook, Wordpress, Asana, Airbnb, Yahoo, PayPal, Wolfram Alpha, Doist, WhatsApp, Reddit, Instagram, Netflix, Khan Academy, Atlassian, Mozilla... oh no, sorry, these aren't big and serious, let me just go learn Angular 2.
I do. it's all fluff. Just use a simple ajax library and the DOM API and you're good to go.
I appreciate the thoughtful reply. It was actually more about doing what i enjoy to do over the job situation. Where i live i can already command a great salary being a senior backend .net developer. To be honest though i'm getting tired of .net &amp; microsoft in general. I want the freedom to develop on any platform i want and not have to run an overly bloated visual studio. Maybe the rewrite of asp.net (asp.net core 1.0) will change that but that has yet to be proven. If i could move to node.js i would but there is no market for it where i live and i don't have the flexibility to move right now (unless of course i could work remotely). In my area its almost impossible to find a descent client side developer. Almost all shops use asp.net webforms or mvc and do very little work on the client side instead they do all rendering on the server side. I actually was motivated recently in a recent project to work motivated and end up coming up with a prototype of a new project we have and did most of the logic was in raw javascript (with a little jquery interspersed in some areas (jquery animation)). Also used knockout and bootstrap for presentation. Company loved it and we end up using it. Learned a bunch and most important i LOVED what i was doing. It was so much fun. While i won't consider myself an expert most of the technologies your talking about i descent at. Am i so good at javascript that i could do a responsive design without the help of a framework (like bootstrap)? Probably not at this point but i'm getting better every day. I did have to learn some javascript concepts in the recent project that, i've heard about, but never got to use. Promises for example. I've heard so many asp.net developers complain about javascript. I actually love it. Its a simple language but is quite powerful thanks to it being async by default, its callback system, and dynamic in nature. Sure there are things i don't like about the language but i have never found a perfect language out there. 
This philosophy may work with pet projects, but not if you intend on doing any real work with web apps.
1998 called, they want to speak to you.
We already have flatMap baked into things though. Promise.resolve(5).then(x=&gt;Promise(x+1)) returns Promise(6), not Promise(Promise(6)). That's .then() acting like .flatMap instead of .map
[removed]
You could as well embrace the coming web components standard and try Polymer. Very lightweight but doesn't support IE9. You'll learn much more about the DOM API (which you'll probably won't get around for more sphisticated apps anyway) than using a framework like React (:p) that abstracts it away.
I.. I think he's trolling, but I'm not sure. 
Honestly, I'd recommend Vue over React if you aren't very experienced with js. I know you can do a bit more with React, but the learning curve is insanely higher (imo). My skill level with js is close to yours and I found Vue made sense to me right away.
I think we're talking past each other. I agree that with cloud hosters like you mentioned you have the freedom to use whatever software you wish to use. But as far as I know -- correct me if I'm wrong -- you also responsible for maintaining the system on your own. Which IMO is the big (and maybe only) advantage of shared hosters: they take care of the whole server management.
What's the point of this? Can't I just use [the JS standard style](http://standardjs.com/) [eslint config](https://github.com/feross/eslint-config-standard) to ensure I only use semicolons when absolutely necessary?
FYI, there's [webdriver IO](http://webdriver.io/) now which has automatic retries for things like stale reference errors.
FYI: That project tends to be a bit controversial around here, primarily on account of its name. It's not "the JS standard style", it is a style that happens to be called "standard", but it is not even *a* standard, much less *the* standard, nor is it very widely used (and it enforces some style choices, by no means limited to semicolons, which are little used and widely disliked in the broader JS community). To try and avoid confusion, I prefer to refer to it as `feross/standard` (which is the repo name). That being said, you're right: The real answer to the semicolon debate is to pick whatever damn eslint config you want (or use whichever one your project/company has picked) and then just stop arguing about it. It's the worst kind of bikeshedding, and everyone should be using a linter anyhow, so who cares?
&gt; You know that Angular example is from their official site, right? Who cares where the example is from? If you're making a comparison, it falls on you to make it fair. The parent made some perfectly valid points about why he prefers Angular, but your file count argument is utter BS, so I called you on it. Does Angular 2 still have framework design issues? Absolutely. But come on, that jab about file count was just silly. 
No one cares about how you use semicolons
If you write code that will only be read by a computer program, by all means do whatever you like with the semicolons and let the automatic insertion do its magic. If you write code that will be read by another human..... use semicolons. If you ever want a job in industry.... that means your code will be read by another human, so ... use semicolons. It's really not that difficult. Think of it as coding "manners." And like manners, it helps smooth things along with other people. If you don't like exhibiting good manners, that's fine. Just expect to not get along with other people, as well as you might. 
1) React is just the presentation layer. The quantity of user interaction is not really relevant. React has a unique approach, and coming from the world of beautiful code that is python, you might find the whole HTML mixed in with JS to be jarring, even distasteful. It's not a required way to approach React but most examples and tutorials will be this way. That said, if you're used to the Flask way of doing things, then I would recommend http://www.backbonejs.org with http://marionettejs.com/. This will probably come off as a lot more familiar to use and have less of a learning curve. 2) Depends. You will want a build workflow to compile, test, and possibly package your project. You could use tools like Grunt, Gulp, Webpack, and so on to do it. But coming from python, you've probably done all this already using custom setuptools/distutils commands and setup.py. You can accomplish the same thing in a package.json file. Webpack has a neat feature, that works REALLY WELL when using React, called hot module loading. Basically, webpack can spool up a web server to host your webapp in, and as your change your JS, it will swap out old code for new code on the fly without having to reload the page. I believe it pulls off this really nice trick with [websockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API). This will work with or without React. So unless you care about the unique features of Webpack, then your decision should be based on what you're more comfortable with since it'll all end up with the same result anyways. I've never used yeoman, and I used to use bower when there was this weird desire for different packages for NodeJS and for the browser a few years back. That desire is long gone and NPM does a lot more than Bower does. The last time I used Bower, it was just a frontend to git, where as npm is just the Javascript version of pip and pypi, which means you can host your own private mirror of npm, a very useful thing to do in an office environment. 3) JS as an ecosystem is in a state of chaos, especially compared to python. If you don't want to drown, then pay attention to the differences between good objective technological view points, and people jumping on the latest fads and trends and whatnot. There is a tendency for new things to pop out of nowhere, followed by a large group of people claiming that whatever that new thing is, it's the best and everything else sucks. This will eventually go away but it'll take years. 
If you want to fix things automatically, you may try [google's closure linter in fixjsstyle mode](https://developers.google.com/closure/utilities/docs/linter_howto?csw=1). Or for something simpler, try http://jsbeautifier.org/ I'm also willing to bet there's a plugin for your text-editor that does it for you. For example, [here's one for atom](https://atom.io/packages/atom-beautify)
Not to nitpick but when it comes to technology... age is definitely important. Too "young" and there's a good chance it hasn't been stress tested enough to make significant business investments into. Too "old" (at least in the web context) and there's a good chance the community may have actively moved away from developing/supporting/etc. In this specific case though the joke was referencing an outdated style of web programming. Both browsers (ES) and developers have come a long way in the last ~20 years and it would be naive/foolish to suggest that there have been no significant improvements (or that 18 year old paradigms are "just as good").
Dude, you're so last Tuesday: https://gist.github.com/idibidiart/04e4cf24e5d2c7aba92c
Readability
Hey, don't try bringing reason into the slap fight. These people are heavily invested into specific frameworks and libraries. Any criticism towards the tools is obviously a personal insult and should spark a proper war.
IMO Polymer isn't very lightweight (at least not in terms of performance). And as for whether/when Polymer's version of web components becomes widely accepted...we'll have to wait and see.
No, no atom support. Sorry about that. 
&gt; Readability. FTFY
Stopped on 2nd page when I saw: a = b ++ c This is valid: a = b++ This is also valid: ++c This "test" is stupid. Where and whether you place the semicolon depends on what you want to accomplish. IMO you are not likely to write code like this anyway so the whole thing is a moot point. *Edit* formatting
I think `Array.prototype.flatten` sounds nice. It's not hard to do via reduce but this would be more concise and nicer semantics.
Is the performance better on Android? I know that Ionic 1 was great on iOS, but it was performing poorly on Android. Any remarks on this?
I really like design patterns in Javascript! But I think most of them should he adapted. For example the observer pattern. You don't need do add observer objects, because all u want is the update method to be called. Just keep an array of functions in the observable, that will be called. 
AFAIK [gl-matrix](https://github.com/toji/gl-matrix) is the best library for this. Even if you're not doing WebGl work gl-matrix is really useful. It's heavily optimized and has even thing you would expect in a 3d maths library. If you're doing DOM animation, check out transform-style: preserve-3d and transform: matrix3d(...), if you haven't already.
You don't have to do that. I use alt and have been pretty satisfied with that for some time now. I do agree that there is a lot of annoying changes in the popular libraries surrounding react (router, different flux implementations) but it is not THAT bad.
&gt; Now, try to find a JS framework that is like this, front end or backend. Angular and Ember are the closest to this, no wonder why they are the most used for big and serious apps. That does not seem to be true. Angular/Ember seems to be a better fit for middle-sized applications than large. Those with the largest dev muscles seems to go with React over Angular or Ember.
By then we'll have found something new to argue about. Good times.
Use cases I find important: * They make it much simpler to implement ES6 iterators. * They help with writing asynchronous code. Soon there’ll be async functions. Until then you can use [the library co](https://github.com/tj/co) plus generators. * They can be used similarly to handle data you receive via streams. 
That has to do with Android single core performance being much worse then iOS. 
I think this https://github.com/yelouafi/redux-saga one of the best uses of Generator I have ever seen. 
Watt (https://github.com/mappum/watt) provides asynchronous control flow utilities using javascript. 
Used a wrapper to determine mouseleave on the lot, see [forked pen](http://codepen.io/anon/pen/eJbjry). (includes tiny bit of extra css) Also changed the mouseenter handler to apply to an endless list, as long as they are in the same wrapper. This would work a lot better if you were to nest them like you would with an expanding menu. That way, the mouse doesn't leave the first item when entering the second, but then you would need wrapping divs like crazy.
Hey, thanks for the answer! Your version looks really neat, and I actually got an answer just a while ago on the /r/learnjavascript thread, which was to use the event.toElement method, which solved the problem for me. Thanks for the pen though, I'll look through it and see if I can learn anything! :)
Yeah, that's a non-standard property and still ties the second element to the first by ID and so on, instead of simply relying on their order in the DOM. Depends on your use-case, I suppose.
They are used to represent Effects triggered by an update function in https://github.com/salsita/redux-elm. I love it as an alternative to returning the equivalent of a tuple from updates. 
Don't use 8 loops, use two nested loops. Have the outer loop keep track of columns, and the inner one keep track of rows. for(var x = 0;x&lt;8;x++){ for(var y = 0;y&lt;6;y++){ /*Your code here will output a desk You can set some values to "flip" the count to ascending or descending as needed And also some trickery for the 4 shorter columns */ } } Is that of any use?
He's just a real good guy.
I would love to learn javascript one day :D
When will this promise be resolved?
FWIW most of Ember's terminology comes from Cocoa/Smalltalk. If you're familiar with that, Ember will probably be easy to pick up. One thing to note that's changed since your original comment is that views have been deprecated in favor of components. Both Angular 2, React and Ember have coalesced around a similar component model; it's the application architecture around those components (or the lack of one, in React's case) that's the differentiator.
As an example of using generators for monads https://github.com/russellmcc/fantasydo
You just want to hop onto the cool bandwagons in the hopes of being cool yourself. HTTP hasn't changed since [1999](https://tools.ietf.org/html/rfc2616) and everyone is happy with it. When people make arguments like "this project hasn't be updated in years!" they never say what they expected to see as updates, suggesting the project has reached a point where it is nearly bug free and no new features are needed. Technologists who go "new is better because it's new" are people whose opinions one can safely disregard. -- EDIT -- Actually, HTTP 1.1 has been around since 1999. HTTP 1.0 has been around since 1990.
Just to note, Angular 1.5 now also has dedicated components with the .component() function.
I'd be more amenable to trying something else, but the added benefit of my company starting to use React is a pretty strong motivator to take the plunge. Also by learning React, I'll essentially be learning JS as well which is yet another benefit, right?
Hey, I build https://github.com/evantahler/actionhero. Let me know if you want any help. You can join our chat here: https://gitter.im/evantahler/actionhero
or because you can make tonnes of money writing COBOL. COBOL is a great language for what it was designed for.
Minifying it with Webpack (or whatever else) does prevent it from being loaded from the cache. So you have a decision to make. - Deliver React inside your minified JS. This adds 26 KB. This adds 0.03 seconds on the average US internet connection, 0.01 seconds on an ADSL2 connection, 4.3 seconds on dialup. - Deliver React from an external CDN. This adds 0 time for users who already have that version cached, and the above times *plus request time* for users who don't. Request-and-response time can be up to 1 second. Adding a twentieth of a second for all users is often preferable to adding an entire second for some. 
&gt; The fact that there are two likely possibilities is the whole point of the test. But it's a strawman comparison. No developer would actually write a = b ++ c He would write either... a = b++ c Or... a = b ++c Both of which work as you would "expect" sans semis. 
so you have a very narrow mind when it comes to software engineering
Yes, writing a modern day web app is still like being in the wild west. Yes, there are a lot of choices. Yes, it is a struggle to get your first app up and running with the right configurations. But, in this guy's case, he is trying to learn both configuration and proper React development all in 3 days. Of course you are going to get frustrated. The key here is to take it easy, fully understand what you are doing, and enjoy the learnings from it. Everyone goes through the same stages and this story isn't unique, but it is heightened because frontend is not your day to day routine and the gradual learnings over time have now been compacted into a week long experiment.
When in doubt, post a question in /r/javascript asking what the standard library would be for configuration. They would have mentioned webpack. This is the same for any new language, there are standards and new "hotness" and then there are dinosaurs that still work, but have strayed away from the rest of the pack and are thus considered "old".
Well, it's only generator-based until async/await lands
I guess my question is: why is a professional developer picking Browserify because of the name or the logo? 30 minutes of research would help you figure out if Browserify is more or less likely to be the right choice. There's no lack of people willing to weigh in on these various technologies, so it's not difficult to figure out the pros and cons of adopting any particular thing. That's kind of my big point here: preparation, research, and making solid decisions is going to continue being a big deal for developers. There's no getting around that. I can't see a future where there are fewer choices, which means we have to be good at separating the good from the bad.
There is also [gl-mat4](https://www.npmjs.com/package/gl-mat4) and similar modules for `gl-mat2`, `gl-vec3`, etc. which are a more modular subset of the `gl-matrix` library. :)
https://github.com/tj/co This is a great all around utility for flattening all sorts of async operations as well as spawning off of independent async processes using while loops and channels.
It did indeed, It found the div based on an ID captured from the URL # and I was able to find the previous element using previousSibling and change it's class using className. I honestly thought previousSibling was only applicable to matching elements like a set of li's in a ul so I'd not even attempted to try the first time around. 
&gt; part of being a professional is staying up to date on your field, and learning about new tools and trends. Sure, you don't have to use them but you need to know they exist in the first place. this. once wrote a XML parser in 1999, !@#$ those are !@#$ to write. a thousand lines of strncmp/substr, took two days to write and a day to debug... few months later i figured out theres libraries for that but you have to know they are called xml nodes / to search 'xml node traversal' or the library name 'nodexml'.
Not every language feature requires a good use for your day to day role. When was the last time you used `Math.sin` or `Function.prototype.call`? Those are functions designed for specific use cases. Likewise, generator is a feature for writing Collections library and async programming, if those are not in your daily workflow, you will not likely find a "good use" 
Odd... did you see my CodePen example? previousSibling gives an error, but previousElementSibling does not...
If Relay wasn't ~220kb, it might be.
As a backend dev, I would not tell him to use Vue, React or Mithril. A more complete framework like Ember (or Angular 2) is more appropriate for a backend dev, especially for someone who used good old structured and opiniated frameworks. I personally did some JavaEE/SpringMVC, a little of Rails, Grails and Spark (which is like Sinatra but in Java) and very little of front end (just plugged some HTML templates in my views and basic javascript) What I miss now since I'm in the JS world are conventions, best practices, structure and standards. I take more time trying to decide, understand and compare libraries/micro-frameworks than coding, and when I code, It doesn't feel right because there are 10 other ways of building the same app with the same framework. If he'll go the react (or any other similar view library) way, he'll waste a lot of time (I'm speaking from experience) since he hasn't all the front end knowledge and all the little things that he has to add and decide by himself. If his goal is to become fullstack and do apps quickly he should use a framework that has everything he needs and that doesn't make him take too much decisions. I'm in the same situation as him, I still didn't find a front end framework that suits me well, but I already understood that for someone like me (backend dev, with little of front end knowledge, that is used to structure, conventions and standards and that wants to make apps without taking too much decisions, like he does for his backend), those libraries/micro-frameworks are really not suited for me.
&gt; Using a YYYY-MM-DDThh:mm:ss.sssZ format is fool proof, but most people veer a bit from that ideal (understandably) Understandably? How?? The ISO format is unambiguous, and using it with UTC time (almost) eliminates issues when handling dates. If browsers were stricter, we'd eliminate whole classes of bugs that affect developers and users every day. 
In order to build an app you have to gain basic mastery of the tools. Sounds like you spent 10 days learning the basics of the available tools, not working towards building a solution. Once you get serious about completing a project, you don't continue to swap out tools willy-nilly. You work with what you have, solve problems as they arise, and ultimately work to deliver a product. This is the same story in every language.
If your function returns either null or undefined and both sorta kinda mean the same thing, you really fucked up. Only functions which never return anything should (implicitly) return undefined. Same deal with properties. You can either omit the property *or* set it to null, but you have to chose one.
&gt; when you say "js fatigue" I really just read "I have issues making decisions." That's a good way to put it.
You don't have to be an expert on the 100 kinds of hammers there are, but you should know about most of them and their purpose. And you need to know when the basic claw hammer will not work and you really need a specific kind for the task.
That's a shitty post
Sorry man but this is classic FUD. &gt; I take more time trying to decide, understand and compare libraries/micro-frameworks than coding But you don't need to do this... you can just choose some and go for it. It's not wrong to suggest Ember or Angular 2.. those are perfectly good choices.. but React *is* a good choice for any developer. It has a huge community and it's very good at what it does. I'm sorry you had trouble with some libraries, but I assure you it's not so hard to get into. Let's not assume what will suit well for OP just because he's typically backend. 
I think this is mostly sensible advice, but the problem I have is that even when I take the time to try to make a good choice, I'm unsatisfied. I don't have any problem not worrying about, say, TypeScript or Babel. I'm perfectly content not using them until they've matured. But I've been doing the SPA framework thing for years now. I've taken the time to know the landscape, and I _still_ don't have a good pick. The tools are _not_ interchangeable, they're very different and have different strengths, but for each of them it's one of those "[3 must-haves]: choose 2" situations. I'm not feeling fatigued because of too many solutions; I'm feeling fatigued because when I make the effort to understand and compare the tools, all I can do is 'just pick one' which is _almost_ what I could have done to begin with. 
&gt; Ok, let's examine this. Do you have infinite time in your week to constantly weigh the merits of new frameworks that pop up? Don't do that. I understand the technologies are constantly evolving, but web technologies are generally additive. This means old ways of doing things remain valid so long as there aren't negative issues with those older ways. The problem space is finite. That means there are a limited number of problems to solve, and once you have solved most of them enough you don't need all this tooling bullshit. If you are confident you can do the same thing that a large framework provides then you can also probably build something without that framework much faster. Most developers are certainly not that confident. If you are forced to operate without frameworks and utility libraries you are forced to provide original solutions (the so-called reinventing the wheel) to very simple (extremely trivial) problems. Providing your own decisions to common problems is really stressful to some people. Either except that you are a worthless code monkey or fucking get over yourself and accept that you need to make a simple decision. Clearly, most JavaScript developers have absolutely no idea what it means to operate without handy little utility helpers if operating without means they cannot move forward unit they write a handy utility library themselves: https://www.reddit.com/r/javascript/comments/44yw1t/choosing_vanilla_javascript_in_2016/czu5so4 If that is you, then yes, you are probably a code monkey afraid to make original decisions as a problem demands. While this may sound trivial it bears second and third order consequences that influence everything from writing simple CSS to designing large enterprise architecture solutions.
Heh calling 1.6 recent is a little bit of a stretch ;-)
And the answer was neither, dojo was and still is superior to both. :-D
Afaik, most mobile devices lack a console, or any kind of debugger UI. You can try including firebug lite in your html, though.
ISO 8601 is love. But some people try to roll their own serialisers and parsers and fail on edge cases. Especially when you have multiple buggy steps in the mix. I'd always use a library if I can, saves so much hassle and doubt. And be in control of what is going on with the timezones or you'll regret it.
No, I'm not saying don't choose frameworks and libraries; you definitely should. But that is not what js framework fatigue is about, at all. Framework fatigue comes from the constant new approaches to largely solved problems; those new approaches are often objectively better in some regards, but you now incur cost to adopt them. Learning curve. Migration of existing code. Dependency conflicts. Feature gaps. Instability. And I'm not even going to tell you that you should only adopt mature frameworks - they seem to have their own issues, like feature bloat, increasing opinions, etc. But these aren't the point I made. The point is the fatigue, and that comes from the constant flow of hot! new! frameworks! that we just discard tomorrow in favor of tomorrow's hotness, often before today's has had a chance to mature, and today's is often finding itself making drastic changes to adapt to that reality. Including, but not limited to, versioning where version next may as well be a fork instead of an incremental upgrade. If you have time to keep up, great. I have a bit of time to pay attention. I don't have time to spend on the constant learning curve required to learn each one just to properly evaluate if it will meet all the needs I have if I'm going to replace yesterday's view framework with tomorrow's.
Interesting article. Some thoughts off the top of my head: Proxies are presented as a possible candidate to improve performance, but in conversations w/ some vdom library authors, I learned that proxy performance is far too bad to make it a viable option for high-performance vdom engines (in addition to having abysmal cross-browser support today) Another issue is that observable overhead must be offset by savings in number of DOM operations in order for change propagation to be worth it. For example, a `reverse` operation would not benefit much, if at all, since it requires touching almost all DOM nodes in a list, and would incur worst case overhead on top of it. While naive vdom can lose in needle-in-haystack scenarios, vdom libraries often provide other mechanisms (thunks, shouldComponentUpdate, per-component redraws, etc) to cope w/ those scenarios. In addition, the field of vdom performance has very strong traction currently. Authors of vdom libraries often share knowledge and implementation ideas and there are now libraries than can perform faster than naive vanilla js in some cases by employing techniques like DOM recycling, cloning and static tree diff shortcircuiting, as well as libraries w/ strong focus on granular localized updates.
im glad you asked! I wrote this image loader with concurrency setting. https://gist.github.com/pr1ntr/623a9e8255750f5f9116 
I totally get You bro, I really love frontend webdevelopment but it can be really frustrating. I guess that one of the problems is that JavaScript and its environment grow up much way faster than browser and protocols are actually doing.
Webpack &gt; gulp &gt; grunt. Unfortunate that such a new technology can be so dead!
thank you!
&gt; But that is not what js framework fatigue is about, at all. Its about the symptoms. That feeling of helplessness of trying to keep up with the trends that seem to come out faster than can be learned is a symptom. All of this insanity has a central cause. You can ignore the illness and cure the symptoms, but that isn't really helping anybody. The biggest cost to framework insanity, that everybody seems to conveniently ignore, is that they entangle your code. A framework is a tool, and software tools go out of date. Eventually you will have to move on. You often cannot drop one framework for another without rewriting your app from scratch. If your supporting business unit is willing to throw a nearly unlimited flow of cash at that and doesn't mind waiting forever for a solution while supporting 4x the number of developers then its absolutely not a problem. In many cases the people who are competent enough (if there are any in the company/department) to solve the problems that frameworks solve often have other responsibilities with higher visibility fighting for their attention.
We're using it in a product rolling to beta in q2... It's fantastic once you get it set up. The documentation is definitely lacking though. 
[I made a comic about that!](http://cube-drone.com/comics/c/relentless-persistence) [And also a different one!](http://cube-drone.com/comics/c/the-many-angular-ones)
Why do you think rollup is better than webpack? The only benefit that comes to mind is tree shaking, which is not too useful right now with the limited number of libraries which have a native ES6 format.
it depends what the data type of the key is, and if your actually mutating the element. if you assign a variable to a value that is an array, the variable will point to that array, not create a copy (same goes for a hash). If you mutate that array, then the variable will change with it var pointer; pointer = activeUserData.nearPeople; ... activeUserData.nearPeople.push('cool'); console.log(pointer); //=&gt; ['cool'] but if you just overwrite the value, the variable will keep pointing to the old array var pointer; pointer = activeUserData.nearPeople; ... activeUserData.nearPeople = ['not cool']; console.log(pointer); //=&gt; ['cool'] that being said, i'm not convinced utilizing pointers is the best way to go about solving your issue. I think it will work the way you want it to, but theyre tricky. I'd suggest just making a getter function with the help of a closure that retrieves this information whenever you need to access it.
I wouldn't trust this subreddit as far as I could throw an average-weighted subscriber
Something that has always seemed odd to me is how opinionated angular is, yet how little conventions it has. 
I know, we'll build a website where javascript developers can rate the packages they've used to write applications, so we now know which libraries are good or bad. We'll write this website in typecoffeesasm.js.
Mustard is not code. If someone stops making a mustard you use, it's not as big aproblem than if a tech you choose stops being supported, which happens all the time in software, so you need to use more wisdom when choosing frameworks/libraries than which mustard to buy.
For me it is the tree-shaking that makes the difference, because coupled with the usual minification, it trims off a substantial amount of kilobytes from the final file. However saying that I do use both, but I prefer Rollup at work where every kilobyte counts -- especially on mobile. When tree-shaking is finally implemented in Webpack (as far as I know, it's still in its testing stage) I will *probably* prefer that over Rollup.
ES6 is adding so much good stuff to Javascript and it's going to really bring it in line with Java and other OOP languages with being able to define classes. Unfortunately, at this particular point in time, we're still waiting on it to be standardized so people have to weight the pros and cons of using a transpiler like Babel. Also, there's been a shift towards components which has changed things up a bit. We're kind of waiting for things to settle on the new standard but they are all good changes that will empower the language significantly. I'm actually looking forward to the new frameworks that are leveraging the new ES6 features. Honestly, I just make sure to keep up to date with the most popular frameworks and use a new one everytime I have a new app idea or just want something to add to my portfolio and resume. My primary concern is having the proper knowledge and skills to get a job. I don't need to know ALL Javascript frameworks, just the most prominent ones (they are prominent for a reason) and prove my ability to pick up and learn new things, which I think is the most important bc in this field, things are always gonna be changing, but the underlying core concepts of coding apply across most all coding languages.
I thought it was a GWT example.
Factories, generating infinite sequences such as the Fibonacci sequence, and simulating [coroutines](https://github.com/turtlemay/routines) in games.
While they have some fair points, I think it would be a major mistake to move from GitHub. You can move your repository, you can't move people. Not to mention integrations, etc.
I don't think polymath means what you think it means.
Variables can only store 1 value at a single time. And when we assign a variable to another variable, it 1st reads the current value stored in the former before assigning to the latter. var dog = { food: 'bone' }; var cat = dog; console.log(cat); // { food: 'bone' } dog = 'Rex'; // dog points to a string "Rex" now console.log(cat); // { food: 'bone' } // but cat still points to the same object { food: 'bone' } Variable _cat_ still points to the same object even though _dog_ had changed to point to a string afterwards, b/c assignment is always about value transfer replacement from the resultant expression on the right to the variable on the left. Of course both `{ food: 'bone' }` &amp; "Rex" are reference/pointer values. That is, the value in both those cases represents the 1st memory address of the contiguous allocated memory block of those 2 objects. var dog = { food: 'bone' }; var cat = dog; console.log(cat); // { food: 'bone' } dog.food = 'beef'; console.log(cat); // { food: 'beef' } // Since both cat &amp; dog point to the same object they display the same state // no matter which variable was used to change the object they both point to. 
Pulling numbers out of the air, but I'd say... * 80% of the time, `==` versus `===` doesn't matter. * 18% of the time, using `===` instead of `==` can prevent some really obscure bugs. * 2% of the time you can use `==` to exploit type coercion and yield more concise code. The reason most linters ban it is because they can't tell the difference between "dev who knows what they're doing writing concise code leveraging JS type coercion" and "dev about to be bit by a type coercion bug", and the bug case is both much more common (and much more important to avoid) than the ugly code case. &gt; Is there any reason to avoid value == null as opposed to value === null Because if you write that a bunch, maybe you'll slip and use it when you shouldn't (or a junior dev will see your code and copy the style without understanding the subtleties). Also, while concise is better than verbose, explicit is better than implicit. It's not obvious to me that leveraging type coercion is a good idea, even if you do know what you're doing. &gt; Is there an pattern that you would recommend to use instead? Yes, actually: My current project uses Ramda, so I just use Ramda's `R.isNil()` helper, which checks if the argument is `undefined` or `null`. And if I wasn't using Ramda I'd be using Lodash, which has an identical `_.isNil()` method. (Also, it's kind of unusual to have a value that might be `null` *or* `undefined`. If you find yourself needing to check for both frequently, it may be a sign that you're not using them correctly.)
What makes ES6 ‘shakeable’ opposed to ES5? What is ES5 lacking?
That code would be a bad idea even if it worked, which it doesn't. null == 0 // false
 var color = "blue"; "white", "red" Should be: var colors = ['blue', 'white', 'red']; Anyhow, put it on JSFiddle, JSBin, or CodePen.
&gt; Having a lot of choices is not a bad thing. http://www.ted.com/talks/barry_schwartz_on_the_paradox_of_choice
It's pretty funny how `var color = "blue"; "white", "red"` even compiles. Even more funny business without var and the semi: `color = "blue", "white", "red";` Kind of unfortunate.
You'll probably get a better response if you don't lead off with "what the fuck" :) That being said, I share d357r0y3whatever's opinion. It's very trendy lately to post links with the word "fatigue" in them. It is a little irritating because (IMO) most of them are just saying the same thing. It adds noise without adding much value. PS. This is a good read: http://www.2ality.com/2016/02/js-fatigue-fatigue.html *Edited* to add link.
Oh sorry, I'm such an idiot. I just read "bin" and defaulted back to pastebin. I've been staring into this way too long. As for indentation: I'm aware of me doing it wrong, but I am horribly confused by the concept as I'm a beginner. Sorry. I'll try to find out how to indent code properly. Is this working now? https://jsfiddle.net/#&amp;togetherjs=3D2AtyxjjJ
You had: guessInputText.indexOf(colors) == -1 Instead of: colours.indexOf(guessInputText) == -1 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
Ideally always. If I want to use the new MagicFoo class, and it's polyfillable, the first step in the polyfill should be: ```if(!window.MagicFoo) { // define the magic ...``` [For example, see the MDN page on Array.prototype.includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
It's almost expected. On second iteration of the first loop it should throw the error. It looks like the engine ignored the first assignment to the constant. It happened in second iteration. In first one the constant was undefined. So, it looks how the engine works: when the const name is read it's created but in undefined state. Or it isn't? Or it's first created, then assigned (in second iteration) and then cannot be reassigned again. All options seem quite valid for the interpreter. Since the code itself doesn't make sense, so there is no outcome which could be called valid. No - an error thrown on beginning of for loop would occur in compiled language. It of course could occur during the lexing phase or be thrown by JIT, but maybe it's faster this way for valid code. It's pretty common that invalid code doesn't produce immediate error, but rather unexpected outcome instead. I can't think of a way of exploiting this. The behavior would probably differ on different engines. There's a little use in telling a bit how the engine works, but it's too little information. BTW it's one of the reasons I don't like JS and... C. In both you can do lots of weird stuff which most of the time are not hacking but bugs.
Ah, agreed with the need for pragmatism - familiarity is a big factor - but for a new person yet without a favourite, it can be challenging :)
Most people don't need task automation all the time, they just want a build tool.
Ah, that makes sense. Would definitely make the address preview on browsers look a lot nicer. I'll work on that, thanks!
Not really. It's not mapping or flattening an array. If you look at [the NPO implementation](https://github.com/getify/native-promise-only/blob/master/lib/npo.src.js) you see on Line 153 that if the `msg` is thenable (a promise), reset the state and use the returned promise to resolve or reject the current (outer) promise. That way the references remain intact but the internal state is updated.
Another tip is that you can use a.host just like window.location.host it has the same properties to access the query string too. Perhaps you could use this to reduce the amount of parsing you do. if(window.location.host === a.host) Instead of: if ( host.test(dest) === false ) { You can also avoid your splitting logic by using the properties on the anchor tag directly. https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement
&gt; Why do you think that? They share a lot of overlap, but are fundamentally focused on different goals. Front End typically focuses more heavily on implementing ui, responsive layouts, templates. They are more likely to engage heavily in HTML and CSS, and ultimately their job is to deliver the faceplate of websites. Application development typically focuses more on software architecture, and can be a backend service, browser based application, or even a command line utility. It's generally much more javascript intensive. The goal for application developers is to make software, not content. 
changelog: https://github.com/gruntjs/grunt/blob/master/CHANGELOG sadly there doesn't seem to be much other than updating dependency versions and dropping grunt-cli as a dependency.
/u/mc_hammerd yo dude. thank you so much for helping. /u/StoneCypher and you too hahaha :D but I'm still working on simplifying the code. Edit: 45% simplified. IT WORKS NOW [AMEEEEN](https://jsfiddle.net/HeejulLee/7cpnn073/1/). 
is it just me, or is the word "fatigue" is starting to be come incoherent due to repetition.
So the author is the type of guy that walks into a bar, sees 24 beers on tap and freezes up because of all the choices? If Bud Light is what you know, then go ahead and drink it, the other 23 craft microbrewery beers don't matter. If you are a single developer, writing a single app, it doesn't really matter what framework you pick.
You've been making SPAs for *years* and still never used Babel? Sorry but I'm not buying it.
There is a fundamental problem with saying Webpack replaces Gulp/Grunt. It is not a Task Runner, it a Module Bundler. Sure, the common tools used with Task Runners are, in essence, Module Bundling, but that is the limit of scope. I write projects that have test cases, benchmarking, other configuration that needs to be linted; all of which is not bundled. Where does Webpack handle that? It doesn't. And what about the server side aspect? I don't need to bundle anything there... but I sure as hell ain't using Make.
Which to my mind is precisely what a flatMap operation involves, regardless of the internal implementation. Arrays are not the only things for which it makes sense to speak of mapping and flatMapping. flatMap :: Promise a -&gt; (a -&gt; Promise b) -&gt; Promise b map :: Promise a -&gt; (a -&gt; b) -&gt; Promise b I'm just saying that it's not exactly a concept foreign to javascript at this point, and it happens to have a lot of useful higher-order applications that play nicely with other types when it's a single named method rather than two.
Yeah, I think it's mostly annoying an unproductive whining. Any new skills require time investment. I remember when I first started web dev I was like "wtf flask python ruby rails node react angular?????" But slowly I found my way and it's not so confusing anymore. It just takes maturity to navigate 
Also, ===, always ===
It's inclusive to the application development discipline, if I understand you correctly.
Or, you do it the right way: use good architectural structure, have self-discipline to follow it and only add tools or libraries or anything else as you actually need them. Don't just throw a bunch of shit together because "it's what everyone does" because in this field everyone most definitely can and sometimes most definitely are wrong. Self-control, fundamentally sound principles and discipline obviates the need for many things that people think they need these days and the results are far cleaner and critically, maintainable over the long-term. 
I never said I've never used Babel. That doesn't mean I'm rushing it into production. 
Yeah, well, that's just like your opinion, man. I don't mean to pick on you /u/elingeniero, I hope it doesn't come across that way. I believe that comments like "webpack &gt; gulp &gt; grunt" just contribute to the whole JavaScript tooling fatigue that people complain about. While there is plenty of overlap, I don't think it's as simple as one being better than another. WebPack is great but it is built to be a module blunder for the web. If I want to lint/test/whatever my server side only code, I need to use another tool or jump through hoops. I find the configuration style of Grunt to be easier to get up and going, this is very important to me. That said, Grunt tends to be slower and setup is more verbose. I like the flexibility and lightweight aspects of Gulp but have trouble getting it to work just the way I like. By the time I do get it set up how I want it becomes hard to read. I don't think any of the tools are bad. I've used them all and will probably continue to use them all for different use cases. There is nothing wrong with starting a project with Grunt in 2016.
Webpack isn't even in the same category. Grunt and Gulp are task runners, Webpack is a bundler. Gulp provides more over the likes of Make than Grunt does (thanks to streams), so I'm with you on that.
&gt; For me JS fatigue comes from an emotional state of feeling under appreciated and **not very competent.** &gt; I still **don't feel like I am doing a very good job**. &gt; There is no reason I should feel this way since from a more rational perspective **I am probably a far better developer than the average guy** Maybe he just thinks the rest of us are **really, really bad** :)
With jquery, you'd do something like: $('form').on('submit', function() { $('input[type="submit"]').attr('disabled', true); }); This disables the submit button when the form is submitted, preventing it from being clicked again until the page reloads.
yes actually, I tried something like this but it won't work. here's what I did http://dpaste.com/1FGZ0SV 
Yeah, that won't do what you want it to do, since return false on the click event won't cancel submission of the form. You could do it like this I guess, bind to the form submission itself: jQuery('form').on('submit', function(){ if(jQuery("input[name=submit]").hasClass('active')){ return false; } else{ jQuery("input[name=submit]").addClass('active'); } });
Semantic satiation.
nah this isn't working 
Then find another career path. As a developer half your job is maintaining production capacity. The other half actual production. 
He could have just created the "simplest thing that works", with the tools/knowledge he knows and is familiar with. Unless there is a specific requirements that the app/project must use tech X you don't know - don't use it.
Alienating your userbase and employees certainly didn't help. 
I like them. It brings the syntax in line with other languages.
yeah, that's kind of how I do it. I do write some ptor specs for our CI, but almost never run them locally. it's very scary when testing is such a pain point that devs choose not to do it. 
Hey, that was my line! https://www.reddit.com/r/javascript/comments/42hofj/meteor_angular2_and_react_once_the_dust_settles/czavkui
I wish this site would go fuck itself.
eslint actually has a "smart" option for the `eqeqeq` rule which covers comparing to null. &gt;This option enforces the use of === and !== except for these cases: &gt;* Comparing two literal values &gt;* Evaluating the value of typeof &gt;* Comparing against null http://eslint.org/docs/rules/eqeqeq I'm usually a stickler for triple equals, but in some cases such as comparing null it's totally fine. 
I actually have just found a quite neat use case: https://github.com/bucaran/fly const paths = { scripts: ["src/**/*.js", "!src/ignore/**/*.js"] } export default function* () { yield this.watch(paths.scripts, "build") } export function* build () { yield this.clear("dist") yield this .source(paths.scripts) .babel({ stage: 0, sourceMaps: true }) .uglify() .concat("app.js") .target("dist") }
Still, many people have trouble using/defining prototypes *correctly*. I have seen people being confused by static vs instance functions, whereas in Java and C# they wouldn't make this mistake. Same goes for defining fields in a prototype, instead of setting these in the constructor. They know how prototypes work, but at the time of writing weren't thinking consciously about the consequences. Additionally, even for people who are fully aware of all this, they have different ways to define a prototyped function. Some use a createClass function (convenient and easier on the eyes, but every framework comes with its own version), some set prototype properties manually (by repeating Class.prototype.function a bunch of times), some will find a shorthand for the latter. There are multiple ways to define them with almost no added benefit at runtime. Different people in a the same will define things differently. The class syntax sugar would avoid the above problems and also set a standard on how to write a class. In addition it allows for shorter code and is easier on the eyes.
Totally agree with you, but what makes experienced developers write those posts? They should know better? Are Java or Python ecosystems so tidy and simple?
AFAIK it is to provide a cross platform friendly API to the DOM.
But how do I make websites?
https://en.wikipedia.org/wiki/JQuery#History
Back in 2006, it introduced itself as: &gt; jQuery is a new type of Javascript library. It is not a huge, bloated, framework promising the best in AJAX - nor is just a set of needlessly complex enhancements - jQuery is designed to change the way that you write Javascript. &gt; jQuery is a Javascript library that takes this motto to heart: Writing Javascript code should be fun. jQuery acheives this goal by taking common, repetitive, tasks, stripping out all the unnecessary markup, and leaving them short, smart and understandable. Taken from: https://web.archive.org/web/20060203025710/http://jquery.com/
Yeah, that was a fun read. "I'd slap him and say go back to being scrum master and get me some coffee." 
This doesn't quite answer your question, but I think it is the first mention of the jQuery syntax on John Resig's blog http://ejohn.org/blog/selectors-in-javascript
Cheers. And using POST + XMLHttpRequest to simply send the data back to my server is the best solution?
I do not see any code, just computer science buzzwords so I can't comment on it. I think it will suck because you are focused on performance of something as cheap as DOM updates. The list rendering demos are laughable because this will always be solved by infinite scrolling (not rendering below fold) in the real world. In front end javascript, simple code is always better than performant code because developer time is the most expensive commodity.
"shounds"?
hehe...cant believe someone is asking this :p 
Yeah, because you always knew Resig's initial intentions. Right. Even knew that jQuery would become what it is now. Right.
I think there's a subset of people will tend to be contrarians. Somewhere along the line they got the idea that being different is the same as being smart. Whether or not you're on the proverbial band-wagon says little else about you. In other words: having strong opinions about javascript/Angular/(insert framework/pattern here) doesn't make you cool.
- consistant API across browsers - some missing functions in IE (like string.trim(), array.unique, etc) - class query selector was not available in some browsers. maybe all - handy docready handler that was guarenteed to work - most people were using a 3 or 4 line custom `ondomcontentloaded` if firefox || `onload` if ie - handy functions to interact with DOM that actually worked for all elems - even checkboxes, not so before (.value returned nothing) - append/before/after/wrap in 2006 ie had something like `getElementsByTagName` and firefox had `getElementById` or similar. and even to finer differences they used a different api like `elem.children`and `children()`, setting attributes, etc. it was very different. so before youd get a lot of code like var ie = !!window.someieonlypropery // ex: !!string.prototype.trim if (ie) document.body.onload = init else window.onDomContenReady = init and then more for opera and ff :x and this gem too queryByClass = (document.getElementByClassName ? document.getElementByClassName : function(class){...}) var chk = queryByClass('.checkbox') var isChecked = ie ? (chk.outerHTML.indexOf("checked") !== -1) : chk.checked 
Shounds shounds perfectly normal okay.
Thanks! This is kind of what I was looking for, a review of how things used to be back then.
Oh my god. I'm dying from laughter. Quick, somebody flip my nips while I'm working with grunt today.
But why do you care?
I've been working on a massive ember app for over a year now at work, and mostly it's great. Strong conventions are the big selling point when working with a team, but ember data has been a giant pain in the ass. We've had to massively refactor parts of our application as ember data has changed, drastically and for seemingly no reason. Those days might be over now that it's past 1.0, but if I could go back and do it over, I'd roll my own simple data store.
For some reason, I think that people who whine a lot are old programmers who had to put load of efforts to learn programming. And today a kid can open a Developer Mode in browser and start learning programming.... they sort of feel that new generation is bunch of spoiled brats who don't care about craft of programming. 
If I recall correctly, there were six main things it wanted to provide a standard, cross-browser interface for: 1. DOM access and manipulation 2. Event handling 3. AJAX requests 4. Polyfill functions for arrays, strings, and objects 5. Computed properties like width, height, and offset() 6. Animating page elements
Please do
Does it assume `undefined` yield will use a callback?
this isn't actually a thing.... *right?*
[Prepare](https://github.com/prerender/prerender) to [weep](http://lawsonry.com/2014/05/diy-angularjs-seo-with-phantomjs-the-easy-way/) for our [industry](http://www.brombone.com/).
Hi /u/jpflathead, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's been my point, here, for years.
I'm tired of people complaining about the people who complain about fatigue. (seriously, I think this is the second one of these articles I've seen today ... must be the current cool thing to do)
Your rant, itself, is one of a naive and inexperienced programmer. I find it interesting how the comments on /r/javascript are 180 from those on /r/programming about the same subject.
What benefit does this have over co?
This isn't appropriate for this sub, also shouldn't the title have said [Hiring]. https://www.reddit.com/r/javascript/wiki/index#wiki_posting.3A_general
Making things easier for people who can't think through the consequences of their actions won't make them code better. It also won't make them understand the difference between "class object" AKA on function properties and prototype properties and instance properties. Saying they wouldn't make this mistake in Java or C# is irrelevant because in Java and C# classes are sacrosanct to the point where modifying class decs at runtime is considered black magic or arcane knowledge even though it's fully documented, simply because Java and C# aren't intended to be compositional languages. Not working whithin prototyping destroys your ability to keep in mind one of the benefits of javascript which is very fluid near homoiconic composition of data within objects which ES6 even improved. This is the same type of argument people used against explicit async. If you cannot reason through a language from it's basic building blocks then use another language.
Because it could be so much better, so it's frustrating to people who are in multiple development stacks. 
It truly is a first-world problem when the plethora of available options give people fatigue. However, there definitely is a rat-race feel for people vying for the field to be on top of all the emergent tech, like you're somehow less marketable if you only used grunt. Thats probably where all the fatigue comes from.
async/await assumes promises being the lowest denominator of async handling. Except callbacks are still being used everywhere (personally).
I don't see where it's "nothing like" those things: in fact, the people who debated and discussed and built out these things explicitly debated the issue of whether Promises should act like overloaded map/flatMap or not (the overloaders won). Your description of what's happening isn't any different from how flatMap works in any number of other contexts. Maybe.of(2).flatMap(x=&gt;Maybe.of(x+1)).map(x=&gt;x*x); //-&gt; 3 Look, I "reset the state of "the" Maybe" and passed the "internal" state of the internal maybe up inside, it, thus "preserving the references" to it that are chained on afterwards. That's not really my favorite description of what's going on, but it's a way one can I think about it, I suppose. flatMap isn't some random idea for mashing together two operations, it's a really basic concept with solid founding in computer programming and working with higher-order TypeClasses. Its signature is this: flatMap :: m a -&gt; (a -&gt; m b) -&gt; m b If you have a function that's doing that, that has that signature, it's flatMapping (or at least the category theory operation that some people call flatMapping). It doesn't matter how (a -&gt; m b) -&gt; m b is done: in fact, most typeclasses have to implement it quite differently (and in fact, in some ways, the *way* they implement exactly *that* operation is often what DEFINES the particular sort of typeclass we're talking about).
Can't you load third party scripts in using a web worker function? 
[ES6 Compatibility Table](https://kangax.github.io/compat-table/es6/). I'm happy the internal app we are working on at my company REQUIRES its users to use Chrome but the support is still pretty low for Safari, for instance, which is a widely used browser. Add in that a majority of the non-developer population's browsers aren't up to date, I still wouldn't consider it safe to use in a consumer-facing product without Babel. You're right, though. Once it's standard, you just remove the Babel import and everything will be fine, so it's not like Babel is some super complicated dependency.
Readability for one thing. But if it's just syntactic sugar, and the previous syntax is still available, then what's stopping people from using one over the other? This similar (albeit not analogous, I admit) to using either the dot notation or the bracket notation to refer to object attributes. 
https://news.ycombinator.com/item?id=11049067 http://www.businessinsider.com/github-the-full-inside-story-2016-2 http://hintjens.com/blog:111 http://sudophilosophical.com/2016/02/09/get-off-of-github/ https://news.ycombinator.com/item?id=11053064 
Everyone is mad at everyone else because they aren't experts and I'm just sitting here trying to learn.
"If a C# / Python/Java/Ruby developer walked in an complained about having too many robust libraries and frameworks to choose from, I'd slap him and say go back to being scrum master and get me some coffee." Well said... well said...
I would argue that the number of Java developers greatly exceeds the number of JS developers, but I don't know that it matters much. Certainly there is a critical mass of JS developers, and many of them are bad (as is the case with many language but you're arguing the lower barrier of entry means the average JS dev is worse than the average Java dev), but you're arguing that many of them are also bad developers contributing to the litany of poor frameworks? I'm not sure I can agree with that entirely.. reason being, I don't think it's the *bad* developers that are contributing to the frameworks (perhaps to some extent), but rather I think it's the organic way that these frameworks come into being. I just think JS is going through growing pains, and it's ok to admit it is all. Dismissing that the pains exist doesn't really address the issues. Regarding the node.js/javascript history comments, I don't think anything you said disagrees with my statement. I've been around long enough to have embraced Prototype, then left her at the altar for jQuery, living through the period where jQuery and javascript were conflated so frequently I wanted to punch every 22-year-old kid who thought jQuery *was* Javascript, to re-embracing "native Javascript" now that DOM standardization can at least be largely relied upon. The DOM and JS are two very different things. My point was that node.js (which perhaps wasn't written by UI/UX devs but has been adopted and built upon by, primarily, JS devs who have their roots in UI/UX) has divorced Javascript from the browser, which is a big freaking deal, but it's also a huge paradigm shift for the JS dev community. So while javascript and java are roughly the same age, javascript has experienced a MUCH bigger shift due to node.js separating JS from the browser, creating - in essense - an entirely new development landscape for the language. That's a pretty challenging thing for a decentralized development community to make sense of ... leading to a proliferation of solutions (some of which are solutions in search of a problem, or solutions that are just bad) ... leading developers to problems of: paradox of choice, sand shifting beneath their feet, and a larger barrier of entry ... which can lead, understandably, to fatigue - for perfectly legitimate reasons.
interesting yet completely pointless at the same time
That's a really good point - it's not even necessarily even just "bad" developers re-inventing the wheel - it's also very *good* developers who aren't familiar with idiomatic javascript or front-end web development (who, I suppose, you could argue were "bad" JS developers but for entirely different reasons ;-) who are busy trying to import concepts, structures and idioms they're comfortable with from other environments... with varying degrees of success. I suspect this is also behind the eventual (and much-debated) inclusion of syntactic sugar like `class` in newer versions of the JS language spec.
Thanks!
In case someone doesn't recognize the syntax on the blog, it's razor. Looks like ASP.NET MVC. The `@{}` denotes block of C# code. `@section` just tells the template to use this when it requests a specific section. By convention, ASP.NET MVC applications have a 'scripts' section at the bottom.
&gt; I tend to think we largely agree Absolutely, yeah - FWIW your comments have been valuable additions, and I've largely agreed with everything you've written in the thread. ;-) &gt; I think really where we differ is that you seem somewhat dismissive (maybe not the right word?) where I see it as a problem that the community does need to figure out. Yeah - that's the nature of a caffeine-fuelled friday afternoon rant. I did warn readers going in. ;-p Really it was just a stream-of-consciousness rant on the topic that the linked article prompted, with little editing or structuring. &gt; Part of growing pains, I just hope the JS community gets mature soon.. that's all. Absolutely, agreed. Of course the additional issue is that people tend to conflate "javascript development" with "web development", and (similar to what you pointed out in your other excellent comment), those are two very different things. So we have things like Angular (which is a fantastic MVC framework for developing rich, responsive UIs for a lot of purposes) being used to build content-heavy, largely static traditional websites (where it's a terrible choice, and traditional Progressive Enhancement would be a far superior solution), or - back a few years - people going nuts and building entire SPAs by piling up ad-hoc chunks of JQuery (which is famously Not a Framework) into a spaghetti-mess of random event handlers and callbacks, instead of picking (or building) a well-designed front-end *framework* to organise the code and data sensibly. There's this misperception that "javascript is javascript is javascript", and what works brilliantly for defining a mobile UI in Cordova necessarily also works well for a static website UI in a browser (and vice-versa, etc, etc), but it's nonsense. I think we need to separate out the ideas of best-practices for "javascript the language (wherever it's used)", "locally-executing javascript application UIs and frameworks" and "content-heavy, SEO-friendly, accessible/discoverable web-based UIs".
[This recent thread](https://www.reddit.com/r/programming/comments/458udn/im_a_web_developer_and_ive_been_stuck_with_the/) has opposite comments as [I note here](https://www.reddit.com/r/programming/comments/458udn/im_a_web_developer_and_ive_been_stuck_with_the/czwhbgt). It's not related to your post, or this article, but something I've recently noticed on reddit.
I thought Jake was fine and so was grunt.
"*traditional* progressive enhancement" ... man, time flies.
Yep. This was written as a fatigue about commenting on fatigue fatigue response. https://www.reddit.com/r/javascript/comments/44syvj/angular_react_and_javascript_framework_fatigue/czswviy
Linting and testing can actually be done very easily with Webpack. For most use cases you won't need an additional build tool.
Because ES6 allows importing only parts of a module (e.g. single functions) whereas Common JS always export a single object.
I wonder if anyone has done a good, solid comparison in using reactive native vs. xamarin.
No one could ever REALLY be an expert. You can be great, have innate skills, you can understand higher level math... but nothing outweighs patience and determination. Even the experts.... I've been coding for 11 years in various languages, have to constantly learn new things and always have imposter syndrome. Even I have to brush up on the spec before taking a job interview because nobody codes in the spec... We solve problems.
There's a bias for sure. This post has 86 upvotes. in the same time, in /r/programming it has one upvote and one comment. https://www.reddit.com/r/programming/comments/45dqpv/byte_me_javascript_fatigue_fatigue_fatigue/
But sometimes people feel flummoxed and decide to write about it. Fuck those guys.
Ah... yeah. That kind of demonstrates my point, doesn't it? Outside of the javascript community, much of the greater programming community looks at the proliferation of JS frameworks and shakes its head in mystified confusion and disapproval. Inside the javascript community people largely tend to just tolerate (or even *celebrate*) it, leaping on every bandwagon that passes, ignoring (or never learning) industry best practices and generally acting like ADHD-afflicted meth freaks. (Of course, there's also a lot of silly, wrong-headed or simply ignorant commentary about JS from non-JS developers as well, some of which is evident in that same thread, but that's by the by.) My original comment (that you seemed to take against) was *very carefully* not advocating or criticising this tendency (so as not to get drawn into another boring holy war about What I Said About Framework X or Crusty Old Devs Need To Just Get With It, Grandad vs. Naive ADHD Children Need To Stop Mainlining Sugar And Learn Solid Engineering Practices, etc, etc, etc ad nauseum). Rather, it was just trying to explain *why* this situation existed in the JS world (and why it was so much more extreme here than other communities ) without stirring up an argument over whether it was good or not.
Oh, boy. I remember when jQuery was first introduced. I spent *years* without it. I spent those years trying to balance out javascript to IE5, IE5.5, IE6, Firefox (if it did exist back then), Netscape... There were standards, nobody listened to them. jQuery filled in the gaps. If you wanted an element to be selected so you could do things with it, jQuery was your answer. The alternative was a shitload of browser checks. And I remember browser checks breaking at some point. jQuery intended to make life easier. It still does.
Thanks for sharing! For how have you been on the market?
wow! Great resource! Thanks pal! ;)
Cool, it's been long time. I like to hear such stories. On which technologies are you currently working? What kind of projects and tasks?
Or "I want a job and a surprisingly lot of employers just start listing different frameworks that you should know even though you probably don't for whatever job it is". I swear if another recruiter approaches me because I'm listed as a javascript developer and they have a great Java job lined up for me, I'm going to scream.
bias in what way? it's not surprising to me that a post about javascript fatigue [fatigue] has more traction in /r/javascript than /r/programming... 
Thanks anonymous for the gold!
"You shouldn't whine: work is hard" is a ridiculous argument. What an immature and childish viewpoint on a complex subject. We're to the point of complaining about everything that's available simply because we're always trying to make development easier and now there's such a huge influx of tools that ***people aren't quite sure what to use or why to use it***. It's especially hard for new people and for people who don't have the luxury of keeping up with the framework-of-the-day. Don't blame them, blame the companies that are hiring for that framework-of-the-day instead of just hiring a developer. &gt; If a C# / Python/Java/Ruby developer walked in an complained about having too many robust libraries and frameworks to choose from Did you actually stop and think that the people complaining might actually come from those languages? Probably not, because I assume you didn't think much of that article through. 
&gt; it is truly impressive how hostile the javascript community is to new users. That's not the community dude, the community wants sensible default. You have a few elites that think they know best for everyone, that's the problem. &gt; regularly have to configure my compiler Javascript does not have a compiler. Literally nothing is compiled in this language.
Yeah...because no Ruby dev has ever complained about Javascript. Oh wait, that's literally what all Ruby devs do.
What frameworks are you referencing when you say they are built by inexperienced developers? 
Developer fatigue is a good thing IMO, makes finding a better job easier when a certain % of candidates can't keep up with current technologies without bitching about it. 
Just a bit of advice, Webpack doesn't do exactly what Gulp does. The power for webpack is IMO require.ensure(). I use Webpack and Gulp in tandem because I like some of the SCSS stuff available to Gulp more than the Webpack. 
super post. spot on i, with all gratitude and appreciation, fall into the experience range of remembering a time when NONE of these frameworks and tools exisited. Not a single one. All vanilla, all the time. Adding that to an educational background in C/C++... im starting to feel better and better about being the grumpy old guy who's sites just work. All the time. Want to know what the next big thing every junior dev needs to start studying.... the business. where ever you are - learn WHY business works the way it does. Ive gone much further being able to come away from project kick-off understanding the whys... how comes easy. Learn Why. Not just how. 
seriously, what is up with lodash warnings in every build?
It's currently a thing at the place where I just started working. They use PhantomJS so show static pages to search engines because the offshore team was too stupid to understand what should and should not be a SPA. So the old CTO got fired, my former coworker became the new CTO, and then hired a bunch of his former coworkers and friends (including me) to replace the offshore team. We're currently in the process of planning a complete rebuild of [EVERYTHING](http://i.imgur.com/i7YLqkI.gif) over the next two years with a sane in-house dev team.
I got quoted in a blog post. Look mom, I'm famous! 
The quote is implying that a Ruby dev was complaining about Ruby having too many mature libraries, in which case he would slap him and tell him to go get coffee. 
I was one of them. 
In an earlier comment, I assumed you were knocking on PE as yet another flashy trend, but now I know you aren't.
I hear so many complaints about JS framework fatigue, but holy hell I've experienced this overwhelming decision paralysis in **every language** that I've used to build out an idea in since I started programming. My path was Java-&gt;C-&gt;lisp-&gt;Python-&gt;More Java-&gt;Ruby-&gt;More Java-&gt;JavaScript and probably omitting quite a few, and let me tell you folks, I will gladly take choosing between NPM, Grunt, Gulp, and Webpack over figuring out Maven and Gradle any fucking day of the week. With java and C++, 40% of the docs you encounter are from pre-2004 and every sourceforge link you hit makes you wonder what planet this community is inhabiting. You think there's any less choice of crap in rails and rubygems? Should you use Puma or Unicorn or Passenger or Thin? In Python, you don't even get to picking out build systems before you're faced with community bickering about whether you should use Python 3 or 2.7. In my 2nd year of college this was an argument and that was seven years ago! SEVEN YEARS and new packages are still being developed for 2.7. Look, I get it, JS is baby's first language for a huge amount of developers, but you learn about what tools and approaches work and which ones don't not by reading blogs by even-less-experienced-but-more-vocal authors, but by rolling up your sleeves, getting your hands dirty, and coming to terms with the fact that you won't have the best answer on your first try, but you might get close enough. Learn from that. If you want to accelerate the process, **get a job** in a **modern** JS team with _experienced_ tech leads, and learn from them! All of my pressing questions and choice paralysis with Ruby&amp;Rails, Java Builds, and navigating the JS dependency matrix came to a close once I was working in companies that had experienced people who were building on (and learning) from past mistakes. After your first 10k lines of JS things will start to make sense. After your first 50k you'll understand how to make smart choices and helping others decide. By the first 100k you'll hopefully know how to architect something much better than the 100k lines you've written so far.
It didn't polyfill anything, it implemented methods before they were introduced to the language. Polyfill would imply they augmented the natives with spec'd methods that didn't exist in the browser. One of the major issues I have with jQuery's methods is that the iterator callback signature flips the key/value order compared to the standard which is confusing.
I am not distracted by that stuff. If a new technology is beneficial for a project AND it increases my hireability then that's awesome. Otherwise it's not difficult to continue using dependable tooling so I don't see a difference in deciding between Flask or Django vs two choices in the JS world.
I've never heard of Nodal but it looks pretty dope.
Ah you're right, that's what it was, thanks!
It's far from just you still using it.
Get a list off the file names and sort it, the last value should be the most recent file.
You are my fucking hero!
because the is the spec and the implementation. Writing a spec is hard, making the implementation fast is even harder.
&gt; Due to the sheer size of ES6, plus a number of unfortunate design choices, it will likely take years until implementations catch up with ES5 optimisations, and the hundreds of man years that went into those. [edit] AKA it took several years to get ES5 to where it is today, optimization-wise. ES6 has been out &lt;1 year.
Are you serious? That seems pretty "easy" (once I figure out how to get the file names). I've been coming up with these insane, complex methods. I've never thought to just do that. I'm going to give this a shot, thank you so much for the response.
My answer somewhat assumes directory listing is enabled... Otherwise, what I would do is try to get the script for the current date, if that fails, get the script for the previous day. Then repeat this process until I find one that actually works.
What stack problems?
I was hoping to see a flood of questions about why `if (a &amp;&amp; a.b &amp;&amp; a.b.c)` occasionally threw errors.
Node.js for the back-end, and looking into learning Python. But I'm a front-end dev mostly. I'm working on Ember.js for work, and React + Redux for fun. Web components and Polymer overlap both work and personal explorations. And WebGL is fun to look at. Last but not least, I'm having fun debugging server-side apps with dTrace and such.
it hijacks the `catch` call making them unusable. It's really an ugly hack rather than a solution. Promise.reject(new Error('rejected promise')) .catch(function(err) { return "Handled error gracefully" }).then(function (response) { console.log('response:', response) }) Normally that code will log `response: Handled error gracefully`, but if I add OP's code I get `response: undefined` The problem OP is attempting to solve is that Promises silently eat errors by default. Promise.reject(new Error('rejected')) OP's code doesn't solve this problem either, because it only sets the timeout if I call `.catch()` on the promise. If I have to call `.catch()` to make this code work, what's the point? I'm still opting *in* to catching errors. I don't know about other browsers, but Chrome will actually log these in the console. Without the code above I get Promise.reject(new Error('Errors log in Chrome')) // Promise {&lt;snip&gt;} // Uncaught (in promise) Error: Errors log in Chrome(…) 
How do you get newSeries from, when it isn't hardcoded?
I really like lexically bound function calls by default. I want that!
I don't know what it so shocking about generating your frontend in a completely different language under a virtual machine. Running a 'headless browser' is no more heavyweight than running the entire Java stack to generate an HTML page. The idea of having backend and frontend teams separated from one another is not a new concept; and it's been fairly common to have them use completely different tools---like for example your frontend people all write in Python and your backend is entirely in Java. Now if you use React, you don't even need to have a headless browser (which honestly was only bringing along the DOM layer anyways). ReactDOMServer.renderToString() on any component will generate the HTML for that component. Serve it, and frontend React will wire up the Javascript events without needing to render any changes. 
&gt; (I suspect node is going to be huge here, as it permits Isomorphic Javascript that combines the benefits of SPAs with the benefits of server-side-rendered PE), That's what I'm doing now. Prerenders for anyone who isn't logged in. Anyone who is logged in gets React components, except mobile users who get pre-renders because we don't trust their phones to be fast enough to do anything.
Promises in Node.js swallow uncaught exceptions, so I think the intention here is to try to make them throw. The problem is that this gist accomplishes that by monkeypatching `.catch`, so if you don't call it, it still swallows the exception. Worse still, if you do call it, it ignores your callback, and instead throws asynchronously. And if that wasn't enough, because the monkeypatch calls Promise.prototype.catch instead of the instance's catch, calling `.then` after a `.catch` gets its callbacks ignored. In other words, it's completely broken. Just use this instead: function report(e) {console.log(e.stack)} somePromise.catch(report) Or if you're in Chrome or Firefox, don't even bother, since they do propagate uncaught exceptions to console.
It's likely that not all of your data objects in collection1 have a "news" property, even though all the examples above do. This will cause an error in the 'article.news.match' part because 'article.news' may be undefined. You can fix this by doing "return article.news &amp;&amp; article.news.match(/Facebook/i);" inside the filter function, which will "short circuit" and return false if article.news doesn't exist.
If you're opinionated you can cut out a lot of things at a glance. I did take a deep look at Flux/Redux but even after spinning off a few prototypes, I couldn't get over my initial reaction of: "I love mutable state, why are you taking mutable state away from me?" Honestly I'm from the Smalltalk world, I like having strong tools to manage the reality of mutable state, not to pretend that immutable and that any given machine environment should be described by as the standing wave created by the interaction of multiple functors.
Lot's of people build a SPA because the initial project scope is *infinite*. You know the type of project where everyone sits down and says that they'll see exponential growth forever and in 5 years they'll be bigger than Facebook and the cable companies combined, so your *potential* feature list is deep into the thousands of points. Looking at that list, it looks like a SPA would be a good fit and it is only after reality hits that Blogger team realizes it is not going to be the de facto meeting ground for all discourse on the internet, that building a SPA for what's essentially a blog seems kind of dumb. ------ On the other hand, you can build a product with progressive enchantment in mind only to find out that the 20% of people who are uber users are really your core market, and so you pile on PE with Jquery and others without any framework in mind.
It's parsed from user inputted data. All of the parsing is done before any of the highchart is called so the object is exactly the same for both parsed and hard coded. I looked into the timeline in the dev tools and it looks like for the parsed newSeries there is a "restyle" calculation after every data point where the hard coded version doesn't do this. Here's another kicker. In safari it works wonderfully with the parsed data and hardcoded. 
&gt; Really? So why are companies hiring for very specific frameworks? Because hiring is usually delegated to halfwit HR types paired with blue-eyed grasshopper devs still oozing dreams of "the brave new world of [whatever new flavor is]" from his pores. Hiring has traditionally been the thing companies are consistently horrible at, which is the defining part of the reason why working in a company of any size above 100 employees is usually a soul-shattering experience. Hiring is useless as an argument in any debate. That said I disagree language is all that important too. What separates boys from the men is the ability to solve problems and learn. learn, learn new shit all the time. I've gone from BASIC and 6502 assembly, over to Pascal, to C, to C++, to Java and then over to PHP, Ruby, Python and finally JS. Same shit different flavor (well writing apps of any complexity above rudimentary in assembly sucks ass, and Python is fuzzy as a teddy bear -- but that's about it).
+1 Funny
Then again, way too much of that shit is people who think that world started when Java, .Net or XML were invented so it's not like their opinion is any more valid.
exactly. That's why I'm taking the active instead of the passive voice: fuck all you whiners and get back to work. the shit you're saying is true of any language, any ecosystem and, frankly any technology. It's like a junior plumber trying to complain about having to know too much mechanical engineering and weight/flow/density ratios to become a journeyman plumber. and that's just technology for shit pipes! I should be going back to work now, but hey, it's my most popular blogpost yet, so i'm going to bask in it =) 
Not commenting on the lib itself but an aside: Why do people write libraries where the functions start with a capital letter? The best practice used to be if a function started with a capital, always call it with `new`. I've seen a couple libs doing this now, this one, Cerebral, and a few other I forget the names of. I get people don't want to use the class-based approach that was done in this past but it seems like such a bad call to just ignore that.
I have rants about rants about fatigue fatigue...
Can you emulate a prototype inheritance pattern in a class-based OOP language like C#? I'm genuinely curious and I think it would help make transition to prototyping less confusing. A lot of people see it as confusing as when they first made the jump to OOP code from purely procedural code.
Thank you so much for this detailed answer!
I suppose there is a type of Darwinism at work in the Javascript world. Those who can't cope with constant change move on to things at which they will be more successful and more happy. Those of us that are left will continue to get the Javascript jobs. Eventually, we will see things settle down. Patience, perseverance and critical evaluation before using new libraries are the keys to a less stressful Javascript environment.
Angular totally fits that description. Easy, but not simple.
It should include: "Comparing against undefined" too. :P
I think HR can sometimes pre-emptively throw away resumes if certain skill words aren't included. As you have mentioned, the 'first line' of people sometimes don't play by smart rules- they are just drone gatekeepers to the company. Also this is just anecdotal but even at interviews, I rarely get asked about my programming fundamentals- it's almost always tests or questions about more tangible practical skills in specific languages. There are likely companies that really want to see your ability to understand algorithms, traverse trees, etc but I have not come across that many in my experience. How much is allowed as ramp up-time can be subjective and you'd have to gauge each company individually. Sure some will give you a chance if you don't know something well and bend their rules a little. But just as often I find places that say "Oh you know Angular but not Ember? That's a shame, we work with Ember :(" and don't want to put two and two together, or perhaps they don't want to because "time is of the essence" and they need an expert in a specific topic immediately. Well-rounded developers with no extreme strengths or deficiencies in anything particular will be at a disadvantage applying to companies that think that way. I can understand his reasoning of not wanting to just bend over to what is currently because in a fast moving industry, a lot of companies are just looking for one-hit wonders that hit the right notes right at this moment, instead of skills that are more timeless and adaptable to different situations.
You can *say* it all you like, but until you can *support* it with detailed technical arguments about: * Future-proofing * Device-agnosticism * Draconian vs. forgiving failure modes * Network topology and information architecture * The accessibility and ease of consumption of "static declarative data" vs "imperative code that executes in unknown time and as a side-effect *may* output one or more instances of mutable declarative data" * Etc, etc, etc ... well, until then you're just regurgitating thoughtless peanut-gallery cliches about what's currently trendy, rather than making a solid engineering rationale. *Can* you make those arguments?
I don't include any mentions of frameworks on my resumes and I actively proclaim my dislike of jQuery during job interviews (often to astonishment) and it has only stopped me from getting a job once. That particular team were Java devs forced to write a web-compatible mobile app and absolutely did not want to learn JavaScript. I can honestly say I am glad I didn't take that job. Honestly, if knowledge of frameworks is your primary selling point you are a weak candidate. It is merely one of several skills, and often not as desired as most people think. If you can demonstrate a strong passion for the work and that you can do the work of three people using just vanilla JS without breaking a sweat you are completely solid. For example, when I interviewed with Intuit a few years back I had no experience with Angular. They told me to study it and practice it before the interview. Angular's API is massive, so cramming is completely ineffective. You actually have to be using it in a real project to get comfortable with it. Needless to say I failed that part of the interview, but I still got the job. They interviewed 28 people before they picked me.
TLDR every ecosystem has too many tools to pick from, all developers have to deal with it no matter the language, it just happens that js is super popular and deals with problems other systems did no have to deal with-- and therefore takes a lot of the flak. 
as OP I would say, also as a former .NET developer, that the amount of complexity of choices is not more or less. I think JS gets flack because people think it should be easy. it is. until you try to do complex projects from scratch. How often does one do that in .NET? It's usually adding to an existing, enterprise app, or just making the REST api, or a queue or something... Also rarely does a .NET dev do the whole stack. Often, a js developer is expected to be really full stack and start and architect projects from scratch. I recall from .NET all the idiosyncrasies of machine configs, web configs, the complexity of deploying them, entity framework vs X framework, code or DB first, webMVC, webAPI or X, Y, Z. your json library selection, security, claims, Lambda functions. A simple console app in C# is no harder than a simple console app in node.js I would argue that the full-stack ecosystem for .NET is just as complex, but perhaps moves at a slower pace in terms of change and "brand new tools" which, if you're smart, don't always use in production anyway. 
I guess what I'm getting at, is instead of the "picking a side to gripe at" my thesis is neither too much x, or too little x. It's that all the theses are wrong, anything after this is obviously as much of a waste of time as this whole post. 
At 2 am walking home from a Party it find this hilarious and the sheer amount of text people choose to write about it worrying.
Lots of stuff on npm. Eg. https://www.npmjs.com/package/gl-vec2 https://www.npmjs.com/package/line-circle-collision https://www.npmjs.com/package/ray-aabb-intersection 
To be honest, the best developing experience I ever had was the golden ages of Ruby on Rails, outsiders complained about the community being snobby or something, but the community was awesome, and everything just worked with strong conventions, and a shitton of plug-and-play gems, you could just focus on business logic. I tear up a little remembering, every time I have to configure Webpack for a new project. I mean, JS is hard compared to that, that's out of the question.
&gt; And then someone says, of course vanilla JS developers get no love, who really is asking for JS developers without expecting them to know a framework or two? I would hate it if that's the reality. I could care less about a developer knowing the frameworks we use. But a developer who doesn't know **any** frameworks raises some serious red flags, because, well... ...why not? There aren't a lot of good reasons why someone wouldn't know a single framework. &gt; nor do we use any of the popular front end ones like Ember or Angular. The company rolled almost everything on their own Great, so you know your companies own internal framework? No problem, but be expected to be asked a couple questions about how it compares to some of the popular frameworks like Ember or Angular. And I would absolutely expect you to have enough experience with one of those to answer that question intelligently (but come on, that's going to take maybe one weekend playing around with it, tops). When I got hired for my most recent job, I had a lot of experience with Knockout, and the company had a lot of Backbone and jQuery soup, and the position was to start development on some new React code. Nobody at the table actually knew React, but we talked a lot about issues I'd had with Knockout, and some of the issues they'd had with Backbone, and we excitedly talked about some of the benefits we expected with the new React code. The fact that I had zero React experience, and almost zero Backbone experience meant nothing, because I had a lot of JS experience, and enough knowledge of React and Backbone to hold an intelligent conversation. &gt; Well, almost other companies seem to say, tough nails, you either know a framework well or we don't want you. No, it's more like "you need to be a skilled JS coder and *capable* of learning whatever frameworks we use internally". Saying "yeah, I have 3 years experience writing Ember apps" is one way of showing that you can learn whatever stack the new company might use, but it's not the only way. On the other hand saying "no, I don't believe in frameworks; jQuery soup is all you need!" is a great way to not get any callbacks, ever. But there's a big difference between the two.
But this is not unique to js. In fact, this is not even unique to high tech. I worked as a plumber and apprentices would study for the codes and standards test only to have things change the next year. Granted it's not as fast paced and maintenance cycles are glacial in comparison: what I'm saying is that these are micro decisions on a per project basis. Saying there's too much choice and unpredictability is just the lot drawn by new technology. Before js it was Java and Ruby and Python. Before mongodb, dynamo DB, redis, it was which flavor of SQL. Before c++ it was assembly, before that it was punch cards. Sure, the cycles have tightened, but so have user expectations. Now we want all the functionality of Facebook built in to every app we touch... Looking at the macro scale none of this fretting about technology lock is new, and rather talk about that as a high level philosophical challenge that get caught in this particular js fatigue dribble.
Like I said in the OP, it wasn't on my choice to have the codebase be custom-built. The project was well into an advanced stage when I was hired so it would have a ghost of a chance re-factoring it all for a third party framework. It was jQuery soup at some ports, but I got used to how everything works and made it work. Some people might see that as encouraging bad practices, but I am learning more frameworks on my own time. It looks to be more of a case that finding a *very good* vanilla JS developer is hard, so companies look to risk less by doing things with a tried-and-true framework. The place I worked at is a startup with only 10 people so that may be why they took a less conventional route. &gt;No, it's more like "you need to be a skilled JS coder and capable of learning whatever frameworks we use internally". Stating I am eager and capable of learning whatever frameworks hasn't gotten me hired in any place that needed them, unfortunately. Because of that, I concluded that few companies care about potential. They have a position open because they have a specific need to be filled *now*, and saying "I can learn it" translates to "I'll will be skilled at it *sometime after* now" in business-speak. A lot of companies get scared of the idea of training people, and unless they're half as rich as Google they won't spend a lot of time training their employees because time is money. I am using React for a personal project, though. What I don't know is how much long should I be using it before it's good enough to add to your resume.
But complaining is fun. I'm gonna write one about how we should all complain more.
How hypocritical you find it bares no relation to how true it is.
I'd disagree with that. `null` is something I'll set if I want something to have explicitly no value -- `undefined` never had a value to begin with. They each have their place in the language and I see them both quite often. Coming from C#, `== null` is something you see quite a lot -- (there is no === there, and checking for null is quite common) it's completely natural on the eyes to me.
The latest major version of lodash renames a bunch of functions to match their ES6 names, which is something they had to do eventually. For example, `_.contains` is now `_.includes` to match [Array#includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes). That said, it would've been nice if their docs had annotations like "previously named `contains`" to give us some ctrl-f support.
so choice A is 3+1 and B is 4 correct?
Yeah. And it would work with essentially any mathematical equation you wanted. So eval('2*3') === eval('5+2-1') And eval('99') === eval('11*9') Etc etc. 
Think like a programmer. This problem is you want a new job and most employers want a person with some experience with a framework. Pretty easy problem to solve. Choose a small project and use a framework for it. Put that project up on github. During the interview say you know a framework and also have deep understanding of the language that framework was written in. Win Win!
Grab-bag utility libraries are a poor substitute for a library that focuses on a specific algorithm. It's also much harder to find an algorithm in a grab-bag library than with a package that is dedicated to a single algorithm and includes that algorithm in its name.
* I know Java &amp; C and check for `null` all the time. * I've also read about why JS got both `undefined` &amp; `null`. * But as I had called attention to before, almost no 1 explicitly assigns anything to `null` even when it's the most correct action to do. * That is, in order to show that something was already declared, but presently isn't pointing to anything. * For JS programmers, only `undefined` is "natural" and widespread. * Even being rare, it's still worth checking out for `null` at the same time as `undefined`, b/c both of those values crash programs if we try to access their non-existing properties: --- var obj = null; obj !== undefined &amp;&amp; obj.length // Crashes! obj !== undefined &amp;&amp; obj['length'] // Crashes too! --- var obj = null; obj != undefined &amp;&amp; obj.length // No crashes! obj != undefined &amp;&amp; obj['length'] // No crashes either! --- My only point is why lints got option to turn off the "unnatural" `== null`, but somehow still considers `== undefined` wrong?
I started using React on a PHP project and honestly I'm thinking about rewriting all the PHP parts in JS just to have this- and universal code too.!
If you're a vanilla.js developer, you know that truly robust XMLHttpRequest calls are chatty. So if you're a vanilla.js developer, you inevitably develop quite a bit of code to make your XMLHttpRequest calls handle the various ready states and other edge cases in a consistent manner. If you *don't* do this, and just call XMLHttpRequst and only check for state 4, you're not a particularly *good* vanilla.js developer. I don't fault people for being young and green, though, so if I'm looking to hire a green developer and mentor them, I wouldn't ding them for this. But if they argued with me that it was unnecessary to write some good library to wrap XMLHttpRequest and still claimed to be a senior developer, I'd send them on their way. If you're a *good* vanilla.js developer, you know what a better API for REST calls buys you. And if you've done more than one project as a good vanilla.js developer, you know that you're not going to be keeping that great REST wrapper framework you wrote in some magic tool chest that you bring with you to every project, because clients tend to hate stuff like that. And that's just one example; there are many others, because, frankly, the web platform is one of the worst/best out there. The point is: if you're a *good* vanilla.js developer... you actually *want* to use libraries. Because you know why they're useful. Now, maybe you have a strong opinion about why JQuery sucks or rocks, or why Angular is better than React or vice versa, but no matter what your opinion is on those frameworks, it's good that you have one (provided you've done more than a cursory glance at each), because that means you're investigating pros and cons -- because if you're a *good* vanilla.js developer, you already know that libraries and frameworks make your life easier by reducing the amount of code that you have to write and/or forcing you down a path toward a more extensible and maintainable application. 
At work, we use Django within python as the backend but converted all the templates to React which are compiled via Node. In practice, there has been no performance issues within our app cluster. That said, we do plan to permanently split frontend &amp; backend teams so the frontend will run an Express server on Node just to service clients that use React and call into the backend API for data.
Heh, funny you'd mention twitter. I also hold them as the canonical example of a company having a very simple application that they decided to complicate with SPA because they believed their own hype about becoming one day all things to all people. Maybe Twitter is important. Maybe it has a high market cap. Yet at the core, Twitter is not a very complicated product, with a small set of allowable UI interactions so the need to split to frontend/backend like they do is kind of unnecessary. On the other end of the market, there are guys who make Bloombergeqsque applications for BI who *need* to have a SPA and clear definition between front and backend. The issues of round-trip latency are all there, but they're inescapable because (a) the application requires you keep context in mind and (b) you cannot load the entire data set ever. For B2C though, often times, SPAs don't make any sense. Granted at my company, we are B2C. We have this issue of having a multifaceted publishing flow for contributors (e.g. the people who actually pay us) and have a SPA for that, but the editors are integrated into every single end-user page so people can keep in mind the context in which they'll be displayed. So while we could have created a totally separate system with duplicate templates just for end-users, instead we just plan to pre-render the largely static site that's served to end-users. &gt; because any site design should involve iterated rollout, and should leave the system open to later extensions and additions That iterated roll out is difficult because stakeholders never want to go back and reimplement things that 'just work', even if it no longer makes sense in context so the pressure is on to choose the right architecture from day 1, and only change it once every 3 to 4 years at best. --- I am curious since you have dealt with this before (and I'm only now about to trod this ground)... what are the issues with running PhatomJS in production to generate the static site? On the face of it seems great---you gain an isomorphic environment for the small performance blip of passing frontend data through a separate VM, but if you maintained separate frontend/backend servers already this is a penalty you were already paying.
If you're compiling C11 code, you still have to specify `-std=c11`.
surely there exists a bash to JS transpiler
As a developer regularly writing nodeJS tools, I can't thank you enough for these links!
There's some nice stuff in there but the argument handling is a bit janky... I would recommend argollector if you want your arguments in a nicely arranged JSON hash.
I believe almost every JS framework exists because people want to make JavaScript look/work more like language x. For example I just read the other day that Facebook developers made JSX because they wanted JS to be more like PHP. I don't know Ruby, but I think express.js is based on Sinatra, which is related to Ruby somehow. For Java people there's Scala.js. I'm sure there's a lot of other examples as well. So when a company is choosing which framework to use (or whether not to use), it depends on the developers' backgrounds. For example I have a strong Flash background, so I love writing as plain EcmaScript as possible. PHP backgrounded people might choose React instead, etc etc..
Hey, it's even easier. swa:/tmp/make-is-nice$ echo 'int main() { return 5; }' &gt; foo.c swa:/tmp/make-is-nice$ make foo cc foo.c -o foo swa:/tmp/make-is-nice$ ./foo ; echo $? 5
yea its just the fn call overhead: [jsperf](http://jsperf.com/push-vs-lennnnn/2) however i had a thought about the object wrapping. chrome notoriously wraps arrays as objects, for some fn's like filter, the first time they are used: `if (!isObject(arr)) arr= wrapObject(arr)` so the first time you do `.method()` is slower than the rest for some fns... so try doing `.push('foo')` once in the setup for all tests the results came out equal when i did that, not as equal without (13% faster) [jsperf, push 1 first](http://jsperf.com/push-vs-lennnnn/2) vs. [jsperf no setup](http://jsperf.com/push-vs-lennnnn/3) so maybe just the first call to push() is slow the rest are equal roughly to doing `mypush(arr,val) =&gt; arr[arr.length] = val`
I usually handle my forms with a configurable stateful component `Form` exposing the following API: - the standard `value`, `onChange` props (making `Form` a controlled component) - plus an imperative `getValue()` method that performs the validations and, in case of success, pulls out the new value (called for example when the user clicks the save button) Generally I'm not interested in the intermediate invalid values entered by the user, what I want is just the whole final validated value, so I think it's ok in this specific use case having a stateful component. Moreover if you really need to store those intermediate values, nothing prevents you from leveraging the `onChange` handler. 
Usually, the script you have your client include sends an XMLHttpRequest (known as AJAX) to your server. Which means it is a request, and it has an IP tag. As to how to get the IP out of a request in node, here is how: http://stackoverflow.com/questions/8107856/how-to-determine-a-users-ip-address-in-node
is TypeScript not strong enough? what else am i missing here?
Oh, right, sorry I think we're mixed up on terminology there. What you were talking about is browser _support_, while I was talking about a _standardized_ specification. I agree with you 100%. We have to support back to IE9 in our consumer facing site (until recently, it was also IE8!), so we have a bunch of tricks to do so (pollyfilling a lot of ES5, auto prefixing our CSS, etc). Fun times!
[Trux](https://github.com/rohan-deshpande/trux) is a simple data framework for React. `API ⇆ Trux ➝ Components` Trux is super easy to drop into your React app and get your back and front talking to one another in a Flux-like fashion, especially if you have an existing API. If you've already got an app going using Flux or Redux and you're happy with how it works, Trux may not be for you, but if you're looking for a simple way to get unidirectional data flows persisting throughout your app, Trux might be just what you need. 
From what I have read, React is easier for non-web developers. I think Vue makes a lot more sense if you already know html and css, because there isn't as much abstraction than there is in React. About the tutorials, the documentation is really good: http://vuejs.org/guide/ and there is a free tutorial video series about Vue: http://vuecasts.com
If framework experience was the only thing that counted, I would never have picked up my current job (frontend developer using a mixture of Backbone and React with a whole panoply of other technologies in between). I came in with none of that framework experience (I did know Angular, which is all but blacklisted at my current workplace). What I did come in with, however, was competent knowledge of vanilla JS and programming in general, as well as foundational knowledge of HTML/CSS and strong devops capabilities. Thankfully, this is a company that sees opportunity as worth more than compartmentalized knowledge. Woe be to the company who passes on a talented developer for a long-term position simply because they want short-term gains. Unfortunately, it does seem like you have to be a seasoned Framework X developer these days to impress the hiring folks. The worst part is, these frameworks come and go, and you're left holding a dead or dying technology in your resume a few years later that won't help you land the next such job.
If it's not FOSS, then it's about earning money. Frameworks saves time (developing, documentation, testing, etc.), and time is money. Developers that don't to use a framework should be able to justify their choice. 
Shout out to [yargs](https://www.npmjs.com/package/yargs) for processing command-line options. I've tried a lot of opts parsers in a lot of languages, and it's far and away the least painful parser I've used.
i saw [this thing](https://twitter.com/sstur_/status/567937326669651969) and thought i could do better. since a legend is still missing: ○ unmounted state ● mounted state | actions performed by the user ¦ react’s flow (this happens automatically)
www.npmjs.com is the best place to find that stuff
JavaScript running on node is not a good choice for ML or heavy computation given that you will end up blocking the event loop which is why there are very few to no library available for ML. You are better of having a separate stack handling ML. I would suggest checking out PredictionIo as they come with a rest server with which you can easily connect from a client or server
This is exactly what I am doing now for a coding test. Have to learn webpack and redux. Loving the redux part a ton. Fuck webpack without boilerplate.
It's times like these I feel so fortunate to be with the company I'm with. I've been able to avoid having to worry about IE compatibility since our sales team is told they can ONLY run it on Chrome. I'm hoping by the time my contract ends, IE polyfills will be not-so-ancient history.
no. 
Just getting into Vue.js myself, and so far I really like the "Angular Lite-ness" of how the framework functions. Or at least that's how it feels at this point. Simple to work with, does't feel too monolithic. If anyone's looking for a nice quick-start intro to Vue.js, Laracasts has a nice video series that helped me jump right in: https://laracasts.com/series/learning-vue-step-by-step
I could have stood to be clearer in my request. We are about to perform a major update of a Rails application (literally Rails 2 to Rails 4, I shit you not), and one of my duties involves the views, which are almost an entire application by themselves. Some of our tests will be automated, and some are outsourced to a roomful of people clicking on widgets and using the new site, but as a developer involved I want to feel capable of drilling into JS issues as they are presented (even with access to the source code). I'm no stranger to Chrome and Firefox's dev tools, but I've never been able to get much useful information out them about JavaScript and the DOM. 
Noooooo!!! I mean, I guess its a matter of taste. However, as a former BB programmer (and the author of a book on BB), I'm now at a new job with a legacy codebase that uses Knockout. I wouldn't wish it on my worst enemy. I'm not a big fan of databinding myself; in my experience it offers solutions to easy problems, in exchange for newer, harder problems. For instance, Knockout's observables and computeds makes it easier to do things like toggle a DOM element ... but using them results in code that's way harder to debug than the equivalent BB View with an events property. If you really want databinding, I recommend Angular, if for no other reason than its mindshare. Millions of devs are using, writing about, and creating libraries for Angular. In contrast, Knockout development is all but dead, and its usage is declining. P.S. Or, as Tebriel wrote, there are numerous databinding libraries for BB you could use, and I'm sure some are better than Knockout. But if you really like that paradigm, using a framework like Angular, or even Ember, where the databinding is "baked in", will give you a more value than shoe-horning some databinding functionality in to a library like BB which wasn't specifically designed for it.
are you available to check our code and see why it isnt working?:)
When I needed to debug some weird stuff that involved DOM mutations, I came up with this little trick: http://engineering.silk.co/post/76945930473/using-dom-mutation-events-for-node-stack-traces Basically, the DOM Mutation Events API can let you access the stack trace when the DOM is mutated by JavaScript... which is useful if you really have no idea what code is responsible.
Can you repost as a link, with your text as a comment? Thanks.
Two general thoughts: 1) Try not to define variadic functions - this should make it simpler to test and use your API. Split a function that takes optional args into two functions - one that doesn't take that option, and one that always does (and likely, the smaller arity function will just be a call to the larger arity fn . For example: // original function w/ optional args function get(url, maybeOpts) {...} // new functions with a fixed arity function get(url) { getWithOpts(url, {}) } function getWithOpts(url, opts) {...} 2) I normally try to only test the public API of a module, unless there is a strong reason to do otherwise. The assumption is that the public API is how the module is going to be used anyways, so any code paths should be able to be excised from there. It also gives you coverage for questions like "did a function call its helper functions with the correct args?".
It seems weird that there's no mention of Intern: https://theintern.github.io/
I hear ya. I started js back in 1996 and coded in RAINMAN at AOL. Webstorm pretty much makes js development as smooth as c# dev. I bet a lot of these js newbies want to use their old tools that aren't suited for js. Hell webstorm gives you code completion inside strings of HTML, in your js! Not that I do that very often, but it's useful if you're writing jsx in react. And just like VS, WS has typescript integration. Comparing vs and webstorm for doing client side (and server side) js, I would def pick webstorm. Anyway full stack JavaScript is incredibly fast to get projects going. 
https://justpaste.it/rcxj , i want it to match even if the display is different say one is 2*4 and one is 8. I still want those two to match. So basically change the value but still have the display different if you know what i mean. Currently it matches everything that has the same display value (hence why its 2 of every letter in the array)
There are specifically two assertions there I take issue with: - almost no 1 explicitly assigns anything to null even when it's the most correct action to do. - only undefined is "natural" and widespread. These assertions I find are not accurate, at least from what I've seen in the 15 odd years I've been writing and reading JS. To me, null means nothing and undefined means "forgot to declare/pass that". null means I have every intention for that property to not be there and undefined was probably a mistake. Any js dev worth their weight in salt would set a variable to null if it should not be there. Do you see people setting things to undefined?? The fact these linters say that `== null` is ok but `== undefined` is not should give you some kind of indication that there are a large number of people out there that think this is OK -- I know I am amung them! I think really I'm having a hard time understanding why null is "unnatural" in your words but undefined is OK. I view it the opposite -- how is undefined not unnnatural?
getDefaultProps is called when the class is created[0] not on the first render. Also, setProps is deprecated[1] so it probably shouldn't be included. [0] https://facebook.github.io/react/docs/component-specs.html#getdefaultprops [1] https://facebook.github.io/react/docs/component-api.html#setprops
So what are the main use cases for CodePath and CodePathSegment objects? Going through the code path analysis doc now but don't really understand from a high level how you would use them.
thanks! i know about the latter, but i didn’t know how to say in the diagram that an upstream component being rendered/updated triggers that
Overly verbose, takes the metaphor WAY to far, and the headline/title has nothing to do with the content. Should be entitled, "pseudo intellectual long winded sailing metaphor for devs"
This is doable. The issue will be the web scraping logic. You might be better served to use a third party website such as auto trader where the markup for each vehicle will be the same. As it is, you'll probably have to configure your web scraper/robot to be website specific. 
I'm glad we have eslint going strong. I still remember when I used jslint and constantly complained about styling things... Being able to have any combination of rules is the right way for a linter.
It's going that way, thankfully. IE9 usage dropped below 2% for us recently (but that's still a very large number in absolute terms), and IE9/10 support is officially dropped by Windows. So in the coming year(s), we should hopefully be able to rely on evergreen browsers being always up to date. The next "oldIE" will be mobile browsers. But they've got a much better starting point :)
Hi /u/skyybreh, please just post once per topic.
Correct, i didn't know how to do it im afraid. I'm sorry if i'm being stupid but it's my first course with javascript so i'm still a bit unsure in some cases, so if you're wondering how the memory was made it was made by me and 2 friends and both friends are better than me at javascript but the problem is that they aren't home :/
Whatever their "target market" can be, they better make it nonempty. The web is not exactly full of people writing how awesome they did since moved to Angular 2 ;)
Eh? I don't think he's questioning how true it is, but how appropriate it is. Only short-sighted companies would be hypocritical enough to demand specific experience but also refuse to provide it.
I am mostly interested in finding these so called companies that are more agnostic with the technology one has experience with. And not just the huge ones like Mozilla or Google. I tend to get hired by smaller, startup-y places but I always find that they want you to hit the ground running, no training needed. But from my perspective, it's been hard for me to find those companies that are lenient with what you know. I've been sending my resumes left and right, probably hundreds over the past year, and I've gotten to interviews with about 15 different companies and 8 on-site ones. A lot of those interviews go great, or so, the look great on the surface because nobody looked very annoyed at me at the interview. But I am not exactly the best at reading people at the job interview. Ironically, I get along well with my peers at work, but interviews are a different story. It feels like I am a strange case. Looks like my problem really is about not being able to demonstrate my potential given what I know. I've also practiced using React and Riot for about three months now. Is it too soon to add it to my resume?
&gt; if you're a good vanilla.js developer... you actually want to use libraries. I agree with that. But I lacked the push and infuence at the company to integrate a framework into the code base. Most of the work was done by a foreign developer who is not easy to get a hold of. Actually, come to think of it, we didn't really use a lot of XHR calls. We did have jQuery but its Ajax functions were rarely used. Data manipulation was mostly done at the front end, basically it sat on top of a PHP framework (which *was* a common third party one) that fetches MongoDB data on the backend and then the UI is where the JavaScript takes priority, juggling the data back and forth among different UIs, as JSON.
this is my first javascript project. js keyboard https://github.com/zombieleet/js-keyboard
what about web-workers?
Also, don't redefine the screen object.
Well.. screen doesn't have a `value` prop, but generally good advice not to play around with native objects in case you overwrite something useful.
If you were going to interview somewhere you should be made aware ahead of time which frameworks they use which would give you enough time to pad your knowledge before hand. Nothing pisses me off more than a candidate who turns up, knowing full well my team works with technology X and Y without any experience of it at all. It doesn't show willing does it?? (If you're wondering how they get to the interview, people lie a lot on their CV). There are benefits to at least experimenting with a new framework or library that seems to have traction. Ask yourself what problem they are trying to solve and why this library solves it better than its billion peers. The reality is actually much more relaxed than you fear. Companies that are interviewing can afford to be specific in there requirements ("Must know Angular") when that requirement is well established in the industry. If they're using something bleeding edge with no market share then they're probably solving a problem that is new and exciting or they're a bit mad. Either way they'll be looking for bright and keen rather than keywords. So on that note, you could spend tomorrow looking at Angular, Node and React (Not necessarily all together!) and that would probably account for 50pc of the popular stuff. I mean it will expand into gulp and grunt and grindr and poozleboff and other tangental shit, but you just want enough hands on to give you flavour.
True, probably not likely to cause an actual error, but confusing for anyone else reading your code--also, it's not semantic, as the screen object contains the sort of information you'd actually semantically want to store in a screen object, as opposed to an input field.
You should check out Erik Rasmussen's [redux-form](https://github.com/erikras/redux-form). It works like react-redux's @connect decorator, allowing you to link forms to redux state in a declarative manner. Not sure if it fits your exact use case, but definitely worth taking a look.
Cool stack, lots of fun I presume.
my reddit client http://reditr.com
does this not work for fat arrow? For example const makeArray = () =&gt; [...arguments]; console.log(makeArray('one', 'two', 3));
arrow functions don't have their own arguments object. Any arguments object they reference would be from the function scope in which they were created (lexical) - just like their `this`.
I've barely used them but they seem very awkward compared to other languages multi threading solutions.
http://2015.jsconf.eu/news/2016/01/13/concerning-jsconf-beirut/
Title is a bit misleading. It's a tutorial on writing a userscript.
My non-committal Object.prototype.toArray method works just fine. Honestly, this is a simple process by just looping through the object to push values into an array... people talk about reinventing the wheel.. this seems like reinventing the metal. 
Yep. Check out https://github.com/gcanti/tcomb-form, it's an implementation of that pattern. In the first example just replace `console.log` with `dispatch` I guess
 var x = document.querySelectorAll("textarea") for(var i=0;i&lt;x.length;i++){ if(x[i].selected){ //your code here } } Should do the trick
Quite a bit of other resources have been linked, here's one for some machine learning stuff http://cs.stanford.edu/people/karpathy/convnetjs/ I haven't got around to try it out yet but it looks pretty useful. 
Depends a bit on what you enjoy. If you like learning new ways to do things, learn something new, I'm like that but I realize not everyone is. Regarding the libraries and frameworks: I'm wary of recommending two-way binding approaches because I have worked with them for a few years now and there are a lot of things that will eventually lead you to a tangly mess. Main culprits being 1) data flows in many directions and often forms a net instead of a tree 2) not easily controllable cascading updates 3) multiple sources of data ("truth") 4) synchronous and asynchronous updates are hard to control. So I'd rather recommend approaches which try to contain and control that complexity, something along the lines of react(+redux), bacon.js, cycle.js etc.
Here's a really simple but powerful view library, which can handle mutable and immutable data: http://frzr.js.org You don't even need any models / collections! Check out this blog post for a little introduction: http://freezer.js.org/minimum-viable-view-library
Has anyone tried this with AirBnb's style guide?
And if it's an iterable, you can already iterate over it with for-of. E.g.: for(let c of 'abc') { console.log(c); } Or: for(let el of document.querySelectorAll('.foo')) { console.log(el); }
..and those winnings aren't from a single win. You slowly build up your net from repeated wins of small amounts Edit: additionally, I find it best to remove outliers that have no chance, and then also remove the favourite, as the favourite is typically the mathematical centerpiece for undermining the bet-on-everything strategy. If your really hedging on the favourite, then just bet on it outight.
Nice plugin. Added to my ever-growing config. https://github.com/gajus/eslint-config-canonical/commit/2bf16c6068d0911b66962e3b672b0c4b8362393c
&gt; That iterated roll out is difficult because stakeholders never want to go back and reimplement things that 'just work', even if it no longer makes sense in context I agree with a lot of what you said, but I think you've misunderstood my point here - the point is that your design should leave open the ability to add *new* features, and/or to replace/re-implement existing features *if necessary*. In general, if you build a system which makes it difficult, costly or impossible to add or swap in certain common/likely features to the system (like SEO, or statically delivering content) then it's a crappy design. Likewise, however, if you build a system that works perfectly well at a basic level (say, using HTTP round-trips) and then you can't get stakeholder approval to invest the time to replace it or overlay it with a flashier front-end (say, an SPA or lots of progressively-enhanced client-side JS), then that's not a *mistake*. That's your PM failing to make the case that the additional work is *actually worth the effort*, right? ;-) &gt; so the pressure is on to choose the right architecture from day 1, and only change it once every 3 to 4 years at best. Bingo, exactly, yes. Which is why it's so important to choose a stable, solid architecture that maximises the possibilities and flexibility of the system, instead of merely jumping on the first currently-trendy platform or tool and deciding to use that. For some projects that doesn't matter so much (eg, company-internal admin tools where the devices accessing it are tightly controlled) or it's simply not practical (as you said, highly responsive BI analysis UIs and things of that ilk are a great example that simply aren't really practical to be implemented using server round-trips), so you can sack off that general principle because it genuinely doesn't serve your particular use-case, but as a general principle it's very, very important absent some really strong rationale for disregarding it. &gt; I am curious since you have dealt with this before (and I'm only now about to trod this ground)... what are the issues with running PhatomJS in production to generate the static site? One quick, general answer here is that it's a fundamentally gross way of architecting any system - if your system needs to support delivering content statically then it should do that natively, rather than trying to identify an arbitrary (and incomplete) subset of clients that need static data, running its own client on the server, capturing the output of the server's client and sending that data back to the *actual* client. There are numerous problems with this scenario, including: * More complexity/fragility (you have all the potential problems inherent in your own code and logic, *plus* all the problems inherent in maintaining and interfacing with a separate PhantomJS instance, *plus* either the risk of bottlenecks in PhantomJS or the additional complexity of a caching system). * More maintenance issues (no longer are you just maintaining your own tightly-controlled code and web server - now you also have a dependency on an entire browser and optional caching system, with their own updates, regressions and bugs). * More runtime complexity - when you're trying to run automated tests or diagnose a problem you have to track and test *both* paths - where your code is running normally in a user's browser on their OS and being interacted with by a human *and* where it's running headlessly inside a browser on your server. * Required support for PhantomJS - PhantomJS has a lot of quirks and oddities, and debugging it is often orders of magnitude harder then simply spinning up a browser in a VM and using its built-in dev tools to work out what's going on. If you fall back to plain HTML functionality then you know in the limit case your site will always work in *any* browser, but JS APIs are where things get badly screwy between browsers (especially PhantomJS, in my experience). In an ideal world your JS should run in any browser, but in practice every browser introduces workarounds or quirks - mandating PhantomJS support therefore inevitably adds additional overhead that wouldn't otherwise be necessary. And obviously if you're writing an SPA, *all* your business logic lives in JS (instead of in server-side code running on a stable, controlled, well-understood system) so the risk of complications and the overhead of fixing them is multiplied. * Inefficiency - Running code in V8 in node.js or on a warm JVM is almost certainly going to be faster than executing it in a browser (even a headless browser) running JavascriptCore on the server. * Relies upon `userAgent` sniffing, which is [inherently unreliable](http://webaim.org/blog/user-agent-string-history/) and has been universally recognised as shitty web design for over a decade now. You simply *can't* reliably recognise a given browser at the best of times, and Google even runs a subset of spiders that explicitly *don't* identify themselves as Googlebot so as to spot (and, if you aren't careful, potentially penalise) cloaking. Obviously not *all* of those considerations are relevant to every use-case, though many of them are for most/all situations. Now, all that said in your *particular* case it's a bit harder, as the use-case you sketched out above (let's say a highly dynamic UI for querying vast amounts of data and displaying lots of small views/extracts to the user) is one where an SPA genuinely is often the best solution, because you need to operate on huge datasets without re-downloading them every time you want to alter your query slightly. That said, PhantomJS is *a* possible solution to making that data available statically from the server, though it does suffer from all the potential issues above, because (when all's said and done) it's a pretty half-assed way to do isomorphic javascript. Another approach that might be worth investigating to try *actual, proper* isomorphic javascript - investigate some of the frameworks that use node.js on the server-side, and try building systems that encapsulate business logic and template-rendering into re-usable modules, combined with a couple of thin server-side and client-side layers that wrap those modules for use on the server and the client. That way you can build a system that uses the same logic to render on the client or on the server, and do it cleanly and "natively" in both places. Then when you get a request you can render any particular page on the server, deliver the whole thing as HTML, then load the client-side JS over the top, and then run the rest of the site as an SPA over the top from there. I suspect this approach is the technically superior approach as it combines the benefits of both server-side rendering *and* SPAs without many of the drawbacks of either, though admittedly the approach and frameworks aren't as well-known or mature as traditional server-side systems or exclusively client-side ones quite yet. In your use-case it's definitely something I'd seriously explore though, as it seems like the most solid approach with the most flexibility and the fewest possible downsides.
What does it mean to say that you remove the outliers? What happens if an outlier wins? Your code seems dubious. 
No bot yet. Looking into scraping some of the more popular services, but I also have a life - so time permitting. That being said I'd happily welcome pull requests
Dubious as in you wont actually win every time??? Darn I was so sure it would
Ok, so horse no. 2 has odds of 1.0, horse no. 4 has odds of 2.0 and horse no. 5 has odds of 50.0. Horse no. 5 is an outlier as its odds are relatively (and extremely) not in its favour (according to the party offering the odds, and thus your payout). Typically there will be around 2-3 runners that I would consider outliers in a horse race event (at least in Australia). Yes if an outlier wins and you didn't bet on them then you have lost, but the idea is to have to the most statistically reliable outcome for a win given a dataset of odds, without loosing any money.
Fun idea, but what does the Less Bet in your output mean?
What is the bet that is made on each horse? Just to win? This doesn't take into account to place, to show, exacta, or trifecta. Wonder how this works for US horse racing. 
So, just bet on the favourites and let your small winnings accumulate?
Do you always place bets that are obviously strategic? I.e. being $2.52 will draw attention to you. And how do you place your bets? Do you do each way bets?
&gt; I.e. being $2.52 will draw attention to you. No gambling experience here - just curious why this is a problem. Is it against the rules to use a strategy or formula? Will they ban you?
(Continued from parent, above) &gt; I don't entirely discount PE, it has it's place, but the PE fanatics seem to believe that every site should be expected to run on every device, with any internet connection, which is BS. This might surprise you after my diatribe above, but I absolutely agree, 100%. It's possible to take any philosophy or priority too far, and there are a literally hundreds of scenarios where it's not necessarily worth the hassle, or an SPA or other non-PE solution might be better. However, *generally*, when you're talking about a site or system on the public, open web, whose primary responsibility is to *contain information* (rather than to "provide a user-interface"), PE should be the *starting* point for the architecture, and a principle that that you don't then deviate from without both a solid rationale and a *complete* understanding of the problem-space instead of a myopic fixation on a single or couple of aspects of it. Also, I suspect in the future that isomorphic javascript will hopefully make this debate increasingly moot, as we can build hybrid front-end-back-end architectures (eg, based on node.js) that share modules between server and client, allowing servers to statically render and serve the markup for initial requests to any given URL, along with *optional* client-side JS (largely composed of the same data and templates) that (if executed) spins up, calls APIs and modifies the DOM created by the static markup to hijack UI functionality like clicks, scrolling and `history.pushState()` to provide a rich (but *still* PE/RESTful!) SPA-style experience for the user from there on out.
What? &lt;button type="button"&gt;Submit&lt;/button&gt; This is what the 'type' property is for. &gt; Did you know that when a form that contains buttons is submitted with the enter key (for example), the form is not directly submitted, but the browser dies a click on the first clickable element No, it does a click on the first "submit" element, which a button is by default. Edit: After thinking about this for a minute, if the author wanted to submit the form on Enter key in all other cases, this wouldn't be as simple. 
How about the following + preventDefault on forms onSubmit ? handleEnterKey(e) { if (e.key === 'Enter') { if (this.state.focused) e.preventDefault(); } } &lt;input type="text" onKeyDown={this.handleEnterKey.bind(this)}/&gt;
right but it gets more fubar because (in my own app) componentdidmount is never called for apps that reuse dom elements.. and who knows what else? (if you know tell me)
FlowType?
Use Async! - https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html
Cant you just outsource it to a webworker/service worker and have it post back once it is done? I am sure you could. 
Thanks. You've given me quite a lot to think about, especially on the point of "how can I avoid PhantomJS?". I think luckily if we use ReactJS or, at least, a similar technique for the views, and keep that as pure as possible of any state then we can use Node to do server side render. But then I'm not sure as it is my first foraray into the wild world of isomorphic web-applications. I think maybe in a few months, I'll do a retrospective so at the very least people can learn from my mistakes. Speaking of which, you may want to write about this yourself. PhantomJS has been seen as the canonical way to do server side render for Angular and others, so it is hardly ever questioned. Yet, people should question it and have some reference to the downsides. Anecdotal but, server-side rendering should be 'simple' in comparison to writing a SPA, yet even people with the technical know how to write SPAs still rely on a service like prerender.io for their PhantomJS support. That alone should make people wonder how complicated this whole setup is, and what kind of gotchas exist that no one is talking about.
Why not generators as well? :) Or even streams, we can do a lot today with streams!
what do you mean with “reuse”?
 var links = ['a', 'b', 'c']; window.location = links[links.length * Math.random() | 0];
As the other comment above this said, you can simply do this: const makeArray = (...args) =&gt; args; console.log(makeArray('one', 'two', 3));
FYI This page isn't loading for me. I'm getting a few errors (I'm not sure if this is related). [Please see screenshot.](http://i.imgur.com/iU8Vkew.png)
There OP is talking about the horses with the least chances of success, I am talking about the horse with the biggest chances of winning. In demo.js these horses are taken out.
It's like the world of fractions, the numbers are normalised to the lowest common denominator, so in the case of 5:2 this is 2.5:1. This means for every 2 you bet, you'll get 5 in return in the event of a win. You also get your bet back, so if you bet 2 on a 5:2 and they win, you will receive 7 because it is the 5 + your initial bet of 2.
ITT people who don't understand how [parimutuel betting](https://en.wikipedia.org/wiki/Parimutuel_betting) works. You might smooth out your variance using a tool like this, but you are still gambling. You'll never get banned because the house takes their cut from the overall pool before the payouts are calculated. They don't care how many tiny bets you make.
casual != compatible
You are the best, this is cool
You added a bit more to your post so I will respond to that bit. At the very basic level it works like this. The house collects all the bets for a particular race, takes their percentage cut from the entire pool, and then calculates the odds based on the amount bet for each horse. The house always gets their money. They do not care what betting strategy you use.
There are apparently some fixed-odds bookmakers for horse racing but it is definitely not the norm. You are probably gambling giving them any money at all to bet with. You might have some difficulty when it comes time to cash out and you'll have zero recourse if that happens.
Ah I know the issue, will fix. EDIT: fixed.
 var links = [ 'https://www.microsoft.com', 'https://www.google.com', 'https://www.mozilla.org' ]; var a = document.querySelector('a#random'); a.href = links[Math.floor(Math.random() * links.length)];
Four equals sign on isNaN for starters. 
^^ This right here OP is concise and well written code. For example: if(isNaN(number)) return "Not a number!"; instead of using if(isNaN(number)====false) IsNan already returns a boolean response no need for further comparison. Also avoid nested if's. Linear code is so much easier to read and debug. 
'Yielding' callbacks are not possible in co.
There's a pretty huge overlap between typescript and ES6. What about the syntax is throwing you off?
It's not about Typescript itself. I'm trying to learn Angular 2 and how to write it 'properly'. For the following code, I'm getting all sort of syntax errors around things like `import {...}`, `@Component1`, etc: import {Component} from 'angular2/core'; @Component({ selector : 'chat-app', template : '&lt;h1&gt;Success!&lt;/h1&gt;' }) export class ChatAppComponent { }
So many basic-level things wrong with the OPs code. Thanks for tackling the first few. It might help to specifically tell OP to work on both spacing and comments to improve readability and debugging. Also, you might move your 1) 2) 3) formatting into bullet points to make it easier to read your comment. It can be difficult to separate the numbers and parentheses that are part of commment formatting from those which are part of function math.
&gt; Decorators and modules are not natively supported in any environment yet. Oh? This is definitely news to me. Since I had only seen it in .ts files I had assumed it was a TypeScript construct. Thanks for the info!
5-2 (or 5:2) can be read as saying that out of 7 runs, you expect the horse to lose 5 times and win twice. Odds of 5-2 would be translated into a chance of winning of 28.6%. Other example odds you might see: 1-1 (50% chance of winning), 3-2 (40% chance of winning), 9-1 (10% chance of winning). Remember, they're ratios (specifically, the ratio of expected losses to expected wins), not fractions. To convert to a fraction, add both sides to get the denominator (which would be total runs), then you can use the first number for the chance of losing, or the second number for chance of winning. Odds of 6-1 = 1/7 chance of winning = 14.3%. And in terms of payouts for fixed odds gambling (which is **NOT** how horse race betting usually works; OP is talking about paramutual betting which doesn't have odds at all), you can read the odds af saying "If I bet &lt;second number&gt; and win, I'll receive &lt;first number&gt; plus my stake." A $100 bet at 1-1 odds returns $200, a $100 bet at 3-2 odds returns $250, a $100 bet at 2-5 odds returns $140. Paramutual betting has been explained elsewhere in this thread, but it doesn't have odds; the winners just share the pool of bets. You *can* tabulate the bets as they're placed to show what the wisdom of the crowd currently believes the odds to be though, but they don't determine the resulting payout as with fixed odds betting, they are calculated from the payout.
I was giving a look on how to convert TS to ES2015 and I just ran into this problem: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import Right now I believe is not worth the extra-effort to avoid TypeScript. If I didn't pass through anything the ony differences between TypeScript and ES2015, at least concerning the features used in the tutorial, are the visibility modifier (private/public) and the mandatory type to all variables. If you make the TypeScript version today and sometime in the future you want to change it to ES2015 it shouldn't be too much work to be make it happen. I'd recommend you to give it a try.
[isNaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN) isn't what you want to use here. It's for checking if something is the value `NaN`, and it will coerce stuff in some weird ways. `Number.isNaN` is better for that, but `if (typeof number !== 'number')` would be the right logic here. For instance, your code returns `true` if I pass in an empty array.
Getting a strong "learn you a haskell" vibe from the artwork. Also, just FYI, it probably isn't wise to embed [OS-specific screenshots](http://www.happylearnjavascripttutorial.com/1/display_message.html) (second image) unless you're writing something specifically targeted at that audience. e: corrected link
Yeah, they're cartoons. LYAH also has cartoons. I can see how you'd correlate them. My original inspiration was a series of books from the 80's called Usborne Computer Books: http://asciimation.co.nz/gallery2/main.php?g2_itemId=5450 Our drawings don't have that bled-out colouring over the lines feel that LYAH does. To a certain degree, all cartoons are going to look similar, I suppose. As to screenshots, there are only two. Chrome looks pretty similar platform to platform. We don't think it'll be a big issue. Thanks for looking and commenting, though! :)
What you want is the second parameter in the examples. It looks like it takes an object with an "onSuccess" key that is a function. The function will be called if the read is successful.
All my money on "no-legs lame-turds" please!
This reflects my concern about Angular 2's decision to primarily support TS :/ It's always best to learn a framework/library's best practices, but in the case of Angular 2, the documentation for those best practices isn't stand-alone. You can't come in as someone who writes predominantly functional JS and translate that to best practice Angular. You need to learn what is effectively a different language and use some transpiling tools to actually learn and write best practice Angular :/ Of course, half of the problem is the ridiculous fragmentation and tool thrashing of the Javascript ecosystem. On one site you'll get a Webpack + Grunt + Foo tutorial, and another you'll get a Browserify + Gulp + Bar tutorial :/ The lack of accepted standardization makes learning UI tools such a pain in the ass, but Angular 2 is particular bad in this respect as the documentation teaches pure JS as a second class citizen right now (especially functional JS).
Namespace importing and namespace usage are separate things in all languages. "Telling it to use the thing you just imported" is needed because the import merely makes the code available in that file. Declaring the dependency in the constructor is merely one of the myriad ways you could use the imported code, so naturally it's up to you to tell the script how you want to use that imported code. The import thing is going to drastically improve and standardize the modularity of code in Javascript. Its how everything from Angular to React to Vue will be written in the future.
I have no idea if windows users will be able to find it - they've moved the location of the dev tools in the menu at least two or three times now. I always summon it with f12 or ctrl+shift+j --- I think this shortcut is pretty similar across platforms. And I want to be clear, I wasn't accusing you of ripping them off. It was more complimentary than anything - I really enjoyed LYAH, and totally agree that more dev material should be in a similar style.
Thank you very much for your clear and thoughtful reply. I'm sorry, I didn't really mean for you to go to the trouble of writing up an explanation for me. I was certain that OP's claim that "you can win no matter what" was full of shit but I wanted him to explain the mathematics. 
Wrong. Browsers provide FileReader Api. https://developer.mozilla.org/en/docs/Web/API/FileReader
http://codepen.io/Reeywhaar/pen/KVEdEN?editors=0010
undefined is an identifier, not a type. The fact that it's an identifier means the VM needs to walk the scope to find out if it's been defined anywhere. While you can't redefine global undefined anymore, but you can still do something like this: (function(){ var undefined = 'foo'; console.log(undefined, typeof undefined); })(); // foo string That is from the MDN page for undefined, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
You could always do the honorable thing, and redirect IE users to the Chrome download page...
Nice work, but the name of the repo is confusing. I thought this was something like Grand Central Dispatch when I started reading. Why not something like "promise-queue"? That's the async equivalent, and people will find it more easily that way.
You can use CSS [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries) to customize layout behavior according to screen size.
already done that part, but it left me thinking is there some issue in my code or is rendering engine of computers IE just shitty. (If it works in mobile IE, but not in PC IE o_O)
yeah it's enabled.
yes i thought of that too but media query alone won't be able to turn the carousel into grid layout, does it? 
The link "OS-specific screenshots" does not work. ... &lt;Code&gt;AccessDenied&lt;/Code&gt; &lt;Message&gt;Request has expired&lt;/Message&gt; ...
https://jsfiddle.net/ht84cvv9/2/ I tried to make fiddle, but it seems to work just fine in ie, but it might have something to do with the fact that my script with issues has more stuff happening in tick function? E: no wait, the fiddle has some weird stuttering few times in IE11
You can have the media query just change the displayed element.
Good thinking! But "promise-queue" is catchy enough to be already taken: https://github.com/azproduction/promise-queue.
You can still use ES5/ES6 to write your components.
i tried this and different values, but the image still flashes weirdly.
Actually i think i found an way how to fix this.. i added this: var img = new Image(); img.src = 'https://i.imgur.com/ejHGuTO.png' i added this variable and then tried to draw it, then it worked.. https://jsfiddle.net/ht84cvv9/6/ Is there other way to do this? In my main script i load different kind of images links from array and then draw them. Or should i make own variable for every image i make and put that images variable in the array? Is there an way to make new global variable in for loop? I mean it's pretty stupid to load every image if i am only using few images at time in draw. 
Thanks! I will be reading the book then!
IE is probably busy sending data back to MS servers
He linked to a URL which is redirected from our AWS site (which expires). He meant the screencaps on this page: http://www.happylearnjavascripttutorial.com/1/display_message.html
Why can't you determine the quality? There are sample chapters avaliable (as free download on the leanpub site)... Also, you can go to http://happylearnjavascripttutorial.com and take a look at the online version of the 2 sample chapters. But the reason to support it would be if you think it looks nice, reads well, and appreciate the new approach to teaching. :) 
If you click that link, the random site will be opened in a new tab and the current tab will still navigate to the URL pointed by the link. I think you forgot something.
like if you have 3 listitems `&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;` and delete the first one, react uses the HTML element and just renders the text from the second to the first or for me i was doing `&lt;page data={{pages[this.props.pageNo]}} /&gt;` and it reused the Div but just updated txt. so no `componentdidmount` which sucked cuz i was gonna animate the transition
Thank you for your suggestions :)
Minor remark: if you're planning to use this IRL then **throw an error when `isNaN(number)` instead**. Returning a string here will likely result in the value being interpreted as `true` instead. E.g.: if (isEven("This really isn't a number")) { console.log("The number is even"); } This will log "The number is even".
I started reading it a few weeks back. My verdict: It's amazing if you have tons of time and patience to read through it. Probably the only other text that goes deeper into JS would be ECMA-262. That sais, a good 10-20% of the earlier chapters in the book consists of: "Don't do this, it's not supported in IE", and documenting other bugs that are so far removed from modern JS. E.g. back then `undefined` was simply a global variable that could be redefined, or the fact that early IE implemented some browser features as binary COM objects that use reference counting garbage collection instead of mark sweep like other browsers which meant that circular references = memory leak. It's an amazing history lesson into web dev if you're into that kind of thing
The name is indeed misleading. Furthermore, `promise-queue` (a more appropriate name) appears to do the same already. There is also https://www.npmjs.com/package/promiseq (That also does the same).
just use https://github.com/zaach/jsonlint What is the reason for another implementation?
Thanks, fixed the link. AWS no-likely hot linking.
It'll be the same on windows as mac or linux. The only difference is if you're using something like visual studio, which has compile-on-save support for typescript. But windows isn't a synonym for visual studio, so. :)
Neat
Yeah it seems that edge/ie does that for a while, it takes time before the blinking/stuttering stops. You van see from network tän that it requests the same picture many times before it stops. On other browsers it requests it once. Weird.
Yea, I'm figuring I'll have to switch up the script for each site. Fortunately, most dealerships seem to use a few dealership-focused CRMs, so the URL structure is (almost) constant. 
Thanks. For some reason I was thinking you couldn't do a product listing ad for a car. It's looking like I'm going to need to create a GAS script regardless of ad type. 
This is not physics at all. Back in the day it would be called a "sine table generator", or something like that. All it does is generate a curve, it has nothing to do with physics. Seems like it was developed by a 20-something not familiar with actual physics programming. 
What about The Definitive Guide? Wait, that was last released in 2011, but a 7th edition is in the works.
You can use `bind` to *partially apply* a function. var test = function(value) { console.log(value); }; var testWithFoo = test.bind(null, 'foo'); //now if you call testWithFoo, it outputs "foo" testWithFoo(); //-&gt; foo You can read more on bind here: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind
Some interesting ideas there. I particularly like the better diffs - they are definitely an issue with some of the other tools. However the whole "you don't have to install X and Y" is kind of questionable :) Is it really *that* hard to type `npm install mocha chai sinon` vs. `npm install painless`?
The simplest way to do that is to use an IIFE to capture the value as it exists at that point in time: var value = Math.random(); var test = (function(value) { return function() { console.log(value); } })(value); value = 0; test(); 
Oh, thats nice too. Didnt think of that. Thanks.
This looks like the article misses the automatic promise wrapping which really helps simplify Promise logic. `Promise.all()` and `Promise.race()` treat non-promise values as resolved promises and `.then()` will always return a promise. The multi-value accumulator need not check for promises. None of the values *need* to be a promise, and we don't need `Promise.resolve()` to return a promise. function addThreeNumbers (x, y, z) { return Promise.all([x, y, z]).then(function (numbers) { return numbers[0] + numbers[1] + numbers[2]; }) } addThreeNumbers(1,2,3).then(function(result){ console.log(result); } // immediately returns 6 No matter if the inputs are synchronous or async, I know the behavior will be the same.
In order for this request to work the server has to support CORS. This is a built-in browser security mechanism.
Thanks, I am moving away from OpenWeather because the data is often wrong, very wrong.
Yeah. Removing the callback and changing the datatype does not affect the issue.
In chrome precomputing is much faster. In firefox calling the function and looking up in a precomputed table are equally fast, and significantly faster than chrome. Is it worth it?
This thinking is 5 years out of date
Spin up small server. Your code AJAXs your server, your server CURLs forecast.io. CORS blocks are done by the browser. If you use anything else to make that request it'll work just fine.
I made a little chrome plugin for lazy developers. When you click the button it will add a random dev excuse on your current input/textarea. https://github.com/luruke/dev-excuses-chrome
I remember not getting hired at Booking for not knowing how to make a private variable in javascript. Kinda happy about it now. I was just baffled why would someone ask such a stupid question. Javascript explicitly has everything public and while you can hack around it, you are doing just that - hacking. You can either trust your colleagues to not touch your _privateVar or they should not be your colleagues.
JSONLint parses text and validates that it is well-formed JSON. It doesn't care about the content of that JSON document beyond that. On the other hand, json-struct assumes you have valid JSON but want to enforce rules about the data itself according to an application-specific schema i.e. number fields should be numbers between N and M, email fields should look like email addresses, etc.
Some people prefer the else for style and consistency. I don't, but some do.
First, that test is far too limiting to be practical. Only you can answer that question: - What's the target browser market look like? - How many times/sec are you calling the trig function? - How much do the extra bytes matter? - How much does the precision matter? - How much will the maintenance matter? - Does this affect readability of the code? Honestly, I can't see that it could possibly matter enough. Even the worst case Chrome was running at 20 _million_ operations per second. Unless you are running this lookup hundreds of thousands of times/section, you will most likely see better performance improvement elsewhere. This is far too much of a micro-optimization for me to believe that it would make a measurable difference.
You should probably be a little more specific as to what you're doing, and what you need. Then at least someone could be kind enough to oblige.
Not to downplay this, but Keybase's pgp library has had ECC for a while: https://github.com/keybase/kbpgp
Vue.js in my opinion is much easier to learn because the documentation is so well done.
I used [Zuul](https://www.npmjs.com/package/zuul) in a new project recently, and it was very easy to get it to do basically all the things Intern seems to do. Am I missing out on anything?
Why do you add spaces before your question marks ?
I haven't used Zuul, but looking through the docs it looks like it's focused on browsers and a few particular frameworks. Intern is more framework agnostic and is meant to be server-side as well as client-side. Intern also provides code coverage information, and I didn't see anything in the Zuul docs covering that. Again, this is based on a scan through the documentation, so I could be wrong.
Yup that's exactly why. I always thought it was a matter of readability but I've never noticed that anglophone people didn't add a space before. 
Speaking language independent here, productivity tools will generally tell you that the else statements are redundant when returning a value at the end of a method, but to me I view it a bit like a switch statement. Sometimes you'll have a set amount of possibilities in which using an else statement makes that clear when all scenarios are handled-- a proper code compiler should tell you that your block of code returning a value within an else statement is not sufficient if not all scenarios are handled and a return statement might not be met. In other cases, returning without an else statement is much like the default keyword, for when you don't need to handle every scenario.
Hmm: https://github.com/theintern/intern/issues/579
https://github.com/airbnb/javascript/issues/736 It's being worked on
This is why I subscribe to reacts stateless component model. Practically all of my front end is in pure jsx with very little react boilerplate, which means I can jump ship from react to literally anything else that supports jsx pretty easily and I'm pretty convinced jsx is here to stay for awhile. Replacing redux is the bigger concern for us but we are all incredibly happy with redux and redux saga. It's scaling quite well too. JS has churn. Instead of fighting it, accept it and keep that in mind when choosing frameworks or libraries. Pick something easily replaceable and you will be much happier. 
It seems that you believe this is a problem. What should be different?
The difference is that OpenPGP.js was security reviewed twice (https://github.com/openpgpjs/openpgpjs) and this revision was also security reviewed (even if this is not included in the readme).
You can use closures to return an object that has method that can access variables still in its environment that can't be accessed outside of that function. 
For clarity's sake, make it a require.
Read through all four parts. I've been using Ramda.js for a while now so it served more as a refresher but the exposition of partial application and currying techniques is useful. Worth a read.
1. Split your javascript out into a separate file and don't use an inline script. It will make things easier to read and understand versus everything in one file. The more you separate your concerns the less overwhelming it will be. 2. I see where you are setting content type but where are you defining the "Content-Length: number_of_bytes_in_file" header? Look at their sample call example for reference. 3. You do want to consider using the [resumable API](https://developers.google.com/drive/v3/web/manage-uploads#resumable) instead of a normal request. 10GB+ is a huge amount of data to be transferring up what happens if they lose connection part way through.. without the resumable method setup they would have to start all over again from the very start.. That will start pissing people off pretty quick. Hope that helps.
Lol true. Btw, I just remembered, YDKJS is probably the best comprehensive read on JS atm. Have you checked it out? The manuscripts are available for free on GitHub, which is pretty great.
Have a look into the API wrappers. Depends on what you're building the webpage backend since this is in /r/javascript I'm assuming you've used NodeJS before? If so, there's a wrapper here: https://www.npmjs.com/package/find-my-iphone Or PHP if you prefer https://github.com/tylerhall/sosumi
Thanks, that's what I needed to know.
I assume you're using the theoretical `Eventual` mentioned in the article? I'm not sure if you were making the claim that this is unclear to reason about with async/await, but here it is written out below: (async function () { console.log(await getFoo(), counter++); console.log(counter); console.log(await getBar(), counter++); console.log(counter); })(); Here's what I assume would be happen assuming that `Eventuals` in this case are actually `Promises`: create getFoo promise yield counter++ (from getFoo Promise) yield resolve getFoo promise with 'foo' (from getFoo -&gt; setTimeout) counter++ (from setTimeout) yield counter++ (from console.log) log: foo 2 (counter is now 3) log: 3 create getBar Promise yield counter++ (from getBar, counter = 4) resolve getBar promise with 'bar' (from getBar, counter = 4) counter++ (from getBar, counter = 5) yield counter++ (from console.log) log: bar 5 (counter is now 6, but returned 5) log: 6 I'm not 100% sure about that, but this is what should happen according to the Promise/A+ spec, which is very clear about the order of things. However, just because the spec is *clear*, does not mean it is *intuitive*. This is especially so when the await syntax is removed. That said, if there were an `Eventual` intrinsic, it would look like this, not like what you have up there (line-by-line translation, note there is no way to represent the ambiguity you pointed out): function getFoo() { counter++; delay(0); // some kind of timeout/delay/sleep function return 'foo'; // &lt;-- Note this is a return, putting code after it will intuitively not run counter++; // This will not run } function getBar() { counter++; return 'bar'; // &lt;-- Note this is a return, putting code after it will intuitively not run counter++; // This will not run } This is a line-by-line translation, but it illuminates a few things: * There is no callback/asynchronous looking code when you have a lazy/eventual intrinsic language. Everything is just written as if it were synchronous even though it isn't. * You can't do anything after the logical equivalent of `resolve`, because it's just a synchronous return statement. * It's (comparatively) really really easy to reason about this. Much easier and more intuitive than with Promises. console.log(getFoo(), counter++); console.log(counter); console.log(getBar(), counter++); console.log(counter); Expected output: foo 1 2 bar 3 4 The major downside is reasoning about when things are running -- when it is doing something else? How do you do multiple things at the same time? How do you deal with side effects (what if these functions were using the value of counter?). This is where crazy magic is happening. If none of your functions have any side effects -- it doesn't matter!! They can all run whenever they want, it's only bounded by data dependencies. If there are side effects, then those need to be tracked as dependencies, and orchestrated to run in a sequential manner. This is some black magic vodoo right here and is nearly impossible to reason about if something goes awry. It absolutely has to work perfectly, it can't be a leaky abstraction. I am not aware of such an implementation that exists.
You are correct on both counts!
Both are true. [proof of 1.]( https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactCompositeComponent.js#L704-L707) I think both your question are explained here https://facebook.github.io/react/docs/advanced-performance.html
Framework are not designed for people to learn javascript, they are designed to help build shit really fast. "loosing control" is the whole point of using frameworks, having smarter people build a rock solid fondation for you to write your app on top of it by following some guidelines. So yes, I won't recommend learning frameworks if your still learning the basics.
Map, filter, concatAll, zip, reduce... learn these 5 functions and... ...wait a minute. All of those functions can be actually expressed by just one of them: reduce. So, learn reduce. And then maybe later learn how to transduce (which makes it easy to get reduce to do just about anything in any order in a highly efficient fashion).
scope, context, hoisting, closures &amp; event loop are some of the interesting parts of javascript imo. If you want to become better than mediocre this is what you need to learn, not React or the Math functions.
I'm not sure if you caught it, but when you set `obj` to `undefined` you are setting it to what you set above, `'foo'` function undef() { var undefined = 'foo'; console.log(undefined, typeof undefined); var obj = undefined; // still 'foo' console.log(obj === 'foo'); // true console.log(obj === undefined); // true - obj is still set to the identifier, so yes they are equal console.log(obj == undefined); // true - even if you use two equals signs, yep still the same console.log(obj == null); // false - 'foo' is not null console.log(obj == void 0); // false - 'foo' is not undefined var notDefined; console.log(notDefined === undefined); // nope console.log(notDefined == undefined); // nope console.log(notDefined == null); // huzzah! } undef(); It's not just to get around a hackish case - it does - but it's a performance improvement. Albeit probably slight, but IMO preference &lt; performance even if it is minor. By far the easiest solution is to just `== null` because it works for both and doesn't do the scope lookup. What's your argument against doing that? 
Sure, basically you're just downloading page content. Personally, I would probably make a simple console app for scraping the site and saving your output to a text file. 
If you don't care about IE8 and IE9 than yes. You also probably want to have a public token of some sort in the script url to auth a client.
If the token is in the URL, can't anyone easily fake it?
eslint does have a `no-undefined` rule: http://eslint.org/docs/rules/no-undefined This will warn you if you ever use undefined -- either as the initial value of a variable, when comparing to it, or setting it -- However it is not in the `eslint:recommended` set, so you need to know about it and turn it on. Actually, one of the beautiful things about eslint is that by default it doesn't do anything and you only get warnings for things you turn on explicitly.... so the linter only prohibits it if you let it (or extend eslint:recommended which has sane defaults)
I wonder and curious about why B3 IR doesn't need "Int8". Isn't it necessary for Javascript to deal with some sort of strings, such as ASCII or UTF-8?
From MDN: https://developer.mozilla.org/en/docs/Web/HTML/Element/script &gt; Scripts without async or defer attributes, as well as inline scripts, are fetched and executed immediately, before the browser continues to parse the page. By this definition, it would fetch the script tag and execute it before the next tag was even parsed... it doesn't even know what comes next, no src to download. That assuming no async/defer. That said, major browsers probably do pre-fetching on all script tags to optimize page loading -- but if the execution order is off -- well, that breaks internet.
I think he was just confusing in his wording. &lt;script src="1.js"&gt;&lt;/script&gt; &lt;script src="2.js"&gt;&lt;/script&gt; This will download them asynchronously, but execute them in order. This is what he was saying a *lot* of web depends on. However, at 1:12 when he says "the normal way, just creating script elements", he means dynamically creating the script elements and appending them. ['1.js','2.js'].forEach(function(src) { var script = document.createElement('script'); script.src = src; document.head.appendChild(script); }); This will download them asynchronously, and execute them whenever it's finished downloading. That's what he said was his fault and the dirty secret. For reference, the *not* normal way is to set `script.async = false;` This is equivalent to the above html. Essentially `async` is `false` by default in html (the opposite being: `&lt;script src="1.js" async&gt;&lt;/script&gt;`), and `true` by default when you dynamically create the element edit: sp
Reduce, the NAND gate of functional programming
The media query? in the link tags &lt;link href='main.css' type='text/css' media='all' /&gt; &lt;link href='print.css' type='text/css' media='print' /&gt; &lt;link href='tablet.css' type='text/css' media='(max-width: 1440px)' /&gt; &lt;link href='mobile.css' type='text/css' media='(max-width: 960px)' /&gt; in mobile.css you can see the following near the top .full-wrapper .mobile { display: block } .full-wrapper .desktop { display: none; }
Almond is CommonJS compatible. Using React, Angular, or other very specific libraries or frameworks would require us to rewrite our entire codebase, which is not feasible, among other problems that must be considered. Context specificity doesn't mean code rewrite, it means components won't clash because they share the same identifiers, or are looking for things outside of themselves. Imagine adding a select in the page and finding it getting its content emptied all of a sudden, because you named it a certain way. You are probably missing the point here, our challenge is to keep a sane codebase, a reasonable amount of developer freedom, and scale that. Others might choose to enforce and maintain strict guidelines, or develop their own complex frameworks.
Why not use Yeoman? What's the point of yet another tool?
Hey, thanks for that. It didn't work properly though - tried clicking everywhere on body and wouldn't get redirected.
Sounds like you didn't understand closures at the time
Just check if(i === 4) (for the 5th element) and then append your extra HTML, looks like you've cracked the rest... If I understood you right
Is [THIS](http://stackoverflow.com/questions/31950470/what-is-the-upgrade-insecure-requests-http-header) what you are referring to? it sounds like you have issues with your headers.. search stackoverflow when you get a problem like this for other people having the same issue and how they fixed it.
You should be able to attach things to the global object: https://github.com/substack/browserify-handbook#global ``` global.React = require('react'); ```
Really? http://codepen.io/anon/pen/jWJeXd
This uses decorators, which is not in ES6.
See this article: http://www.greywyvern.com/?post=337
Seems like a perfect usecase for [JSPM](https://github.com/jspm/jspm-cli)/SystemJS. It allows you to do the same thing as browserify-bundle you app, but it allows on demand loading of dependencies via System.import() any time as well. Supports CommonJS, AMD and ES6 modules out of the box. We're using it on a big react app and couldn't be happier. 
Would like to see one on generators and iterators.
do you mean JSX? because it does support JSX out of the box when you choose babel as your compiler. See https://github.com/capaj/jspm-react for example of boilerplate. 
Stack Overflow would honestly be a more suitable place to ask for help with your code. I can give you a few pointers though. When you say you think js is better for this I assume you mean in the browser as opposed to Node.js. The browser does not have access to the servers file system for obvious reasons so the only way this can be solved using js only will be if the .txt files are publicly available AND you can somehow calculate the name of the latest file client-side. An XHR-request to the file would determine if the file exists or not. Since the filename contains an IP-adress this does not seem feasible. The simplest solution would probably be to create a new .php file on the server (let's call it new-files-in-folder.php), that when called in the browser gets a list of files in the folder, and if the count &gt; 0, echo's something like '{ "num_files": ' . $file_count . ' }'. In the browser, create a script that calls a function at a set interval (look up setInterval). This function should make an XHR-request to new-files-in-folder.php and parse it as JSON. If the num_files property is &gt; 0, well then you know that new files were added and you can do whatever to indicate this. Instead of constantly polling the server you could use something like web sockets, but (no offense) judging by your post I think you are not quite ready for that yet.
Thanks for sharing. Yes that page does provide the detail I was interested in. But either because of how it was written or my lack of confidence on the subject matter, I just wasn't totally sure. (I think probably because I read a lot about mixins in classes and pure render mixin, I might have gotten confused) I really appreciate you and everyone else in /r/javascript that politely and concisely provides responses to questions that might even be dumb or appear to fall under the "Let me Google that for you" category.
I know it supports JSX. But I was getting errors when it had to do both es6 and jsx. It seemingly couldn't do both at the same time which is a non starter for me unfortunately. Though I wouldn't be surprised if I was doing it wrong.
Hi, kapouer! We do run `npm prune` when generating our tarball containing the release. The problem was that this "pruned" version was dropped on top of old releases. Hence the stale directories and the whole problem. :)
You were probably trying to do it with jsx plugin. Don't use that, that one is shitty. Babel has jsx built in so there is no need to utilize plugins.
Added fix due to comments)
Why not Ghost.js?
Meteor sort of does this. It basically exposes a query API on the client. The only downside is you have to use the full framework.
This seems a bit easier to configure than yeoman IMO 
Seriously, monospace is supposed to make things easy to read but this artsy blurry font requires more focusing than reading the other text. Just a suggestion, love the content and will be reading all 4 parts.
Welcome to Web Development :D!
OpenWeather requires you to get a free key. Did you do that? *Okay, looks like you did do that. I tried it in vanilla and got a response, ~~but the response code was a 401 error (invalid api key)~~. var request = new XMLHttpRequest(); request.open("GET", "http://api.openweathermap.org/data/2.5/forecast/city?id=524901&amp;APPID=523e2a873e1f816a5013e8fe4b965455", false); request.send(); request = JSON.parse(request.response); console.log(request); //Good to go!
Have you tried adding **http://** to the API URL, e.g. **http://api.openweathermap...** instead of just **api.openweathermap...**? [edit] Even better, use **//** instead and it'll automagically use whichever protocol (http or https) you're on.
I just realised why it's not working... I've looped the id variables.... I'm such a dumb ass. If anyone has a suggestion on how to do it though would be great!
The most known "databinding only" libraries would probably be [knockout](http://knockoutjs.com/) (22kb) or [rivets](http://rivetsjs.com/) (6kb). If you want to extend that to your entire view instead of just databinding, you've got [vue](http://vuejs.org/) and [react](https://facebook.github.io/react/). Personally, I hadn't heard of jQuery my, and I wouldn't be looking for a jQuery plugin if I wanted databinding, especially if I was going to do a rewrite for more structure.
I think you're using a different API call in your example; http://api.openweathermap.org/data/2.5/forecast/city?id=524901&amp;APPID=523e2a873e1f816a5013e8fe4b965455 works fine.
Firebase. They also have libs for some major frameworks.
&gt; It uses setTimeout to provide a separate context, which then isolates failures and prevents the blockage of the main thread. Can you elaborate on this? It sounds... weird.
I've actually worked this out by doing this... &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;testdoc&lt;/title&gt; &lt;script&gt; function showText(id,delay){ var elem=document.getElementById(id); setTimeout(function(){elem.style.visibility='visible';},delay*1000) } window.onload=function(){ showText('delayedText0',0); showText('delayedText1',1); showText('delayedText2',2); showText('delayedText3',3); } var scripts = new Array(); scripts[0] = "Line0"; scripts[1] = "Line1"; scripts[2] = "Line2"; scripts[3] = "Line3"; for (i=0;i&lt;1000;i++) { document.write("&lt;div id='delayedText" + [i] + "' style='visibility:hidden'&gt;" + scripts[i] + "&lt;/div&gt;" + "&lt;br &gt;"); if(i == 3){ document.getElementById("delayedText0").value = ""; } } &lt;/script&gt; &lt;/head&gt; &lt;/html&gt; However, I can't get it to delete the text that is there and start the loop again. 
don't worry about it... I got it! &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;testdoc&lt;/title&gt; &lt;script&gt; function showText(id,delay){ var elem=document.getElementById(id); setTimeout(function(){elem.style.visibility='visible';},delay*1000) } window.onload=function(){ showText('delayedText0',0); showText('delayedText1',1); showText('delayedText2',2); showText('delayedText3',3); } var scripts = new Array(); scripts[0] = "Line0"; scripts[1] = "Line1"; scripts[2] = "Line2"; scripts[3] = "Line3"; for (i=0;i&lt;1000;i++) { document.write("&lt;div id='delayedText" + [i] + "' style='visibility:hidden'&gt;" + scripts[i] + "&lt;/div&gt;" + "&lt;br &gt;"); if(i == 3){ setTimeout(function(){ window.location.reload(1); }, 5000); } } &lt;/script&gt; &lt;/head&gt; &lt;/html&gt; 
Yep, it does! Updated. Thanks!!
do you really want to reload the page once it's done? I gave it a try here: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;testdoc&lt;/title&gt; &lt;script&gt; function showText(id,delay) { var elem = document.getElementById(id); setTimeout(function () { elem.style.visibility='visible'; }, delay * 1000); } function hideText(delay) { var elems = document.querySelectorAll('[id^=delayedText]'); var total = elems.length; setTimeout(function () { while(total--) { elems[total].style.visibility='hidden'; } start(); }, delay * 1000); } function start() { showText('delayedText1',1); showText('delayedText2',2); showText('delayedText3',3); hideText(4); } window.onload = function () { start(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="delayedText1" style="visibility:hidden"&gt;this is 1 second&lt;/div&gt; &lt;div id="delayedText2" style="visibility:hidden"&gt;this is 2 second&lt;/div&gt; &lt;div id="delayedText3" style="visibility:hidden"&gt;this is 3 second&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; You can see it working here: http://codepen.io/anon/pen/zrbQYe
https://h3manth.com/new/blog/2014/prime-number-generation-with-es6-generators/
Thanks
If you're not support IE6 or Firefox 6(?) I don't see a problem... Considering this is from 5 years ago, I'd like to see a more recent reason not to use it.
yes I do want it to refresh... This is the true file... import subprocess, cgi, cgitb routerR = subprocess.call(['ping', '-c', '3', '192.168.0.1']) if routerR == 0: router = "UP" elif routerR == 2: router = "DOWN" else: router = "Unknown Error" rasp_PiR = subprocess.call(['ping', '-c', '3', '192.168.0.36']) if rasp_PiR == 0: rasp_Pi = "UP" elif rasp_PiR == 2: rasp_Pi = "DOWN" else: rasp_Pi = "Unknown Error" lights_SwitchR = subprocess.call(['ping', '-c', '3', '192.168.0.40']) if lights_SwitchR == 0: lights_Switch = "UP" elif lights_SwitchR == 2: lights_Switch = "DOWN" else: lights_Switch = "Unknown Error" marco_CompR = subprocess.call(['ping', '-c', '3', '192.168.0.17']) if marco_CompR == 0: marco_Comp = "UP" elif marco_CompR == 2: marco_Comp = "DOWN" else: marco_Comp = "Unknown Error" dyllan_CompR = subprocess.call(['ping', '-c', '3', '192.168.0.18']) if dyllan_CompR == 0: dyllan_Comp = "UP" elif dyllan_CompR == 2: dyllan_Comp = "DOWN" else: dyllan_Comp = "Unknown Error" print "Content-type:text/html\r\n\r\n" //html...GO! print """ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Header Info&lt;/title&gt; &lt;script&gt; function showText(id,delay){ var elem=document.getElementById(id); setTimeout(function(){elem.style.visibility='visible';},delay*1000) } window.onload=function(){ showText('delayedText0',0); showText('delayedText1',1); showText('delayedText2',2); showText('delayedText3',3); showText('delayedText3',4); } var scripts = new Array(); scripts[0] = "Router: {}"; scripts[1] = "Rasp Pi: {}"; scripts[2] = "Lights Switch: {}"; scripts[3] = "Marcos Computer: {}"; scripts[34] = "Dyllans Computer: {}"; for (i=0;i&lt;1000;i++) { document.write("&lt;div id='delayedText" + [i] + "' style='visibility:hidden'&gt;&lt;font color='#ffffff'&gt;&lt;b&gt;" + scripts[i] + "&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;"); if(i == 4){ setTimeout(function(){ window.location.reload(1); }, 5000); } } &lt;/script&gt; &lt;/head&gt; &lt;body bgcolor="#000" color="#fff"&gt; &lt;/body&gt; &lt;/html&gt; """.format(router,rasp_Pi,lights_Switch,marco_Comp,dyllan_Comp)
I recommend you https://www.ng-book.com/2/ is update in every beta and have the code resource is awesome. 
It's "&lt;input ...&gt;" or "&lt;input .../&gt;", not "&lt;input ...&gt;...&lt;/input&gt;". It's "&lt;br&gt;" or "&lt;br/&gt;", not "&lt;/br&gt;". Both are void tags. They cannot contain anything.
Nothing jumps to mind why you would get that specific error, assuming you didn't typo anything. You could try moving the expression into a new variable: var fileName = this.documentFileName; var firstPart = fileName.substring(0, 1); var secondPart = fileName.substring(3, 4); var toLaunch = "//pathforthisexample/" + firstPart + secondPart + ".pdf"; app.launchURL(toLaunch, true); `var` in javascript makes variable accessible to *the entire function* that the variable is enclosed in, it should be accessible anywhere in there. 
Thank you will try it.
:) The goal was to make something that you could have in action within a few minutes after looking at an example.
Feedback is always welcome!!
I think it's just to help move your app to using Redux, not actually use both together as a real solution. That way, instead of breaking everything instantly, you break little by little.
This help? http://codepen.io/anon/pen/BjbXBB
Good god.
[Deepstream.io](https://www.deepstream.io/)
The vanilla version needs a "msMatchesSelector" fallback for IE/Edge. :/
why would anyone learn Angular2 when there are so many better options available in 2016?
It's a tool to help you move from Backbone/Marionette to Redux/React incrementally. All your migration code lives in Backbone so when you're done you can just drop it cleanly. It's on you if you actually try to combine them.
Genuine Question... What do you consider to be "Better Options" and why?