If default exports work for some teams.. not sure why we should all do the same. but thanks for sharing...
Not entirely sure. but I bet it would render rather slowly to post effect on changing frames. What you could leverage though is webGL, that would perform. There are util library already: http://htmlgl.com/
cos they are useless for this app
Just to add JS is prototypical (first I would say), functional and pseudo object oriented (recent ecma).
FP allows you to write easily composable and testable transformations over data. Since pretty much everything done on the web handles data, it's a good fit.
I would recommend reading some explanations already available out there. Probably, the most classic reference on "Why FP?" is probably [Why FP Matters](http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf). There are also [many other blogposts](https://blog.blueberry.io/why-fp-matters-even-for-oop-developer-7cb05b4a9856) and even [presentations](https://es.slideshare.net/antpl3/why-fp) about it with very similar titles. Most of them will provide the same arguments, many of which have already been mentioned here. Simplicity, better state management... In general people will say it leads to cleaner code and less bugs, but that's a bold claim. IMHO I think one of the best explanations you can read is [FP is not the answer](http://degoes.net/articles/fp-is-not-the-answer) which comes, despite what some could gather from the title, from a very hardcore FP proponent. He _does_ indeed explain the general benefits of Functional Programming -and even fanboyishly raves _a bit_ on the elegance of a Quicksort function in Haskell-, but he also makes it very clear that FP (or OOP, for that matter) is not the answer. It is not the goal. **The goal is good code**. FP, OOP, whatever, they are just tools.
Isn't that colt Steele web developers boot camp one looked highly upon?
Someone should add this to http://nodeframework.com/. I'm riddled with JS framework fatigue just like the next web dev, but even I found [Feathers](https://feathersjs.com/) on it last week and built a small UI with it, lured by the prospect of quickly scaffolding endpoints with websocket support.
Do programming Challenges. I used https://projecteuler.net to learn Haskell. The nice thing about programming challenges is that it will teach you how to think in a logical way.
My experience with C++ was more shitty than anything, in school we weren't even told what pointer is nor what `-&gt;` actually means, which are like, trivial concepts that everyone using it should understand, sigh. And well, I edited my post for a reason...
&gt; I found out that for DOM-manipulation 70% to 90% are using Jquery That was the case many years ago. Manipulating the dom, with jquery or without, often makes for terrible applications, similar to this tweet: https://twitter.com/AdamRackis/status/844289020372901888 Pick any framework you like. They're smaller than jquery, faster, easier to use, produce code that is actually manageable and clean.
You can pass the function itself, not just its name. As in... function doSomething(a, b) { console.log(a, b); } function callAFunction(f) { // blah blah f("hi", "there"); } // now we... callAFunction(doSomething); Also, for this type of question r/LearnJavascript is a more appropriate place to ask :)
Ah gotcha, good answer. There are some quick wins when you adopt some of the practices. You have to be careful of defining Functional, which is why I (and most others) will say "Functional like" instead. You'll see advantages in creating lots of smaller functions none of which have side effects (i.e. any set of parameters will give the same result for those parameters). This is true of any paradigm though, methods that rely on external state should have an absolute case to do so. Immutability everywhere is another popular concept. Your method that takes a list and returns the list with all the values doubled will actually return a new list, not the original list. It sounds a bit wasteful, this is the cost, the benefit is you can unroll operations that fail because, when "doubler" fails it won't have dicked around with the input data. Again, it's consider a "functional thing" but it applies just as well to other paradigms. There are some advantages to concurrent code if you make everything immutable. Some of them are over stated, but it's one way around synchronising variable access. Treating methods like a pipeline is great too (in the right place). You get the right pipe parts, chuck in a value at one end and it will be processed through the pipeline giving you a result. Because you can test each pure function in isolation and because the input is immutable, writing tests for blocks is easy. That doesn't mean testing is easy, just proving those parts work in isolation. There are more esoteric applications like partial functions/currying. This is a great area to start an internet war, so I'll bow out and just say (wiggles pin free) the legitimate uses of currying in Javascript must number in the low single digits. So you should have a forum internally to investigate this and share thoughts. It's not the sort of thing you plan a massive retrofit of, but it's easy enough to start including functional language features as you go forward. Key though is understanding them (functional features) in the context of the wider application and language. a) Just because a language supports x does not mean you need to use x. 
&gt; Vanilla Javascript That term is thrown around, it doesn't have any meaning whatsoever. Jquery is a bunch of functions to help you out. So are frameworks. If vanilla means you go about dropping state into the dom, reading and writing to it indiscriminately thereby thrashing the layout engine, throwing wires throughout the app to inform places of updates ... that would be a mistake. Take care of it, now you have written a framework.
You're right, I don't, nor I have any idea how much I can trust wikipedia on this. Though I realized that it was procedural indeed, we'd just write entire program in main() calling functions when needed and etc. So yeah, I know OOP the best. Bonus points: &gt;In computer science, functional programming is a programming paradigm‚Äîa style of building the structure and elements of computer programs‚Äîthat treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. So basically everything is clear, there's no "hidden variables" or state, therefore no side-effects like most people seem to enjoy doing it nowadays and pretty much everything is immutable?
That isnt what im asking for. The question is specific 
The vast majority of these posts are the same introduction to the same few things such as map reduce and filter and keeping functions pure and data immutable if possible. Many people are already doing that and it's sort of a no brainer. Almost no one tries to shoehorn Javascript into Haskell because that often makes very little sense. You'd need utility libraries to get access to all the functions you'd need to get anything done. You'd need flow or typescript to add meaningful type signatures to functions where the arguments they take are obscured by just returning a composed/piped function. Your co-workers would likely be confused. So in my impression that whole functional JS stuff is mostly just blog posts of people trying to improve their online persona. Look at open source code of popular libraries both new and old and you'll see that JS is and probably will be, for the foreseeable future, a mix between a bit of OOP, a bit of FP, without leaning too heavily in one or the other direction. 
So the gist of it is that you want to call a function, that you know by it's name. You can use `eval(functionName)` to try to get the function if it's in the same scope as your code. Or you can be a bit smarter, and try to put the functions like 'writePassage' on an object and you object-index into that object with your function name, like ``` var myFunctions = {writePassage: ()=&gt;{}} if (available == true) { myFunctions[functionName]() } ```
You‚Äôre aware that JavaScript and Java are different right? With that out of the way, I‚Äôm a JavaScript developer but I learned Java first and I turned out fine I guess. If I had to do it again I‚Äôd probably go straight to JavaScript. Universities teach Java because it‚Äôs a good middle ground between very low level languages like C and very high level languages like JavaScript and the way it does objects is easy to grasp and explain. It‚Äôs not a bad language to start with, but it can be frustrating and hard to read as a beginner because it‚Äôs so verbose. This Saturday I‚Äôm going to make a simple message board web app and live stream it‚Äôs creation from start to finish. You should drop by. I‚Äôm not going to be covering the absolute basics of programming, but if you run through a bit of codecademy JavaScript course you should be alright. I do have a lesson on JavaScript for absolute beginners but I didn‚Äôt do a great job explaining things and I‚Äôm planning to try it again. https://twitch.tv/chuckletmilk 
Congrats for the project in general, it looks nice! But looking through the code on github, it is *hugely, gut-twistingly* complex! Pretty sure you could rip out 80% of the code in there using the things mentioned in the header. Some of which you have essentially re-written btw, in a more crude and verbose fashion. The app is almost screaming for a sane approach to handling UI and state. 
I thoroughly recommend the book on sale at https://www.railstutorial.org/. It guides you through building a web app using Ruby on Rails which is a great language to get started in (it's easy to learn but also well structured). I would absolutely implore you not to learn Java as your first language, it will be a far harder path to get started and is of questionable value vs more modern alternatives. I say this as a professional web developer of 12 years, 5 of which were using Java.
Checkput teamtreehouse.com or codecademy.com - both focus on visual learning processes within html, CSS and Javascript. Start learning the basics of the three before you endulge in various frameworks within the technology. Once that is a few days in, come up with a simple idea that involves all three and the basic stuff you now know. And start building from there.
Idea
It contradicts HTML, you couldn't wrap table or list elements into divs. const Headers = () =&gt; ( &lt;&gt; &lt;th&gt;A&lt;/th&gt; &lt;th&gt;B&lt;/th&gt; &lt;th&gt;C&lt;/th&gt; &lt;/&gt; ) const Table = () =&gt; ( &lt;table&gt;&lt;Headers /&gt;&lt;/table&gt; )
Its like learning to play music. First you go to codeacademy or freecodecamp and learn some basic chords. Then you learn some other people's songs by re-implementing something you've seen which you like. Then you learn how to write and play your own songs.
Great tip! Thanks! I'll check that out!
It's made by MAIL CHIMP!?! Where do you see that? That IS surprising!:) Data Strategist and Artist here - currently trying to leverage my competence in both fields by understanding the forefront of webdev - hence looking into all the relevant libraries. Some of it is a bit too much math for me - but I'm hoping to be able to do basic stuff and get to know the tools.
Hey, good to hear! You should also check out our platform, JavaScript Works! You will be able to view jobs on our transparent job platform, and read up on a ton of blog content which may help you out :) https://javascript.works-hub.com/?utm_source=Reddit&amp;utm_medium=Post&amp;utm_campaign=Rob&amp;utm_content=JSworks - enjoy! 
Get off reddit 
I believe you about environment. Community is everything. Like, how would you make a radio without the community of all the dead people that invented and explored stuff in the past!:) HARD! I'd love tips on entrance level approaches to learning the libraries used above, so if you have any - bring em'!
I learned with https://openclassrooms.com/ Some are free, some are not (today at least) but it's pretty complete and there are various courses. If you never programmed and want to do JS (for some reasons) I recommend you to start by HTML/CSS to understand "the web" then JS. The best choice for me is to start learning the "C". It's harder and more obscure than JS but when you understand how memory and allocations works, it's pretty good to understand a lot of patterns after (and everything with callback/context will be easy to understand when you know "pointers", this is brain-killing btw). But you can master JS with training without passing by C (better for your mental-safety). And of course, good luck. You need it.
Be aware javascript and java aren't then same thing. Other than 4 letters in the name the similarities are close to nil. If you have any html/css experience javascript is the best place to start since it will tie into your existing skill set. If not, i would recomend php, its easy to pick up, learn some basics, and see results without things getting too heady. After you are confident use your new found understandings to make an educated decision on where/how to progress. Core programming skills are pretty transferable, no different to what you describe with finding new art/design applications easy to migrate between. No fear. No regrets. Welcome to programming :)
That looks like a very nice site! Thanks, will check it out :)
React app with Django backend?
complex app requires complex code, don't you? Pretty sure you could NOT rip out (read: remove completely) even 10% of the code 8) 
on a side note, if you do however decide to go with a "real" programming language then you should definetely choose C# over Java. There are too many reasons for me to list them here so you will just have to trust me on this one.. :)
Best course is to start with anything, which allows you to play with it. In the sense "i change this here, and wow, it changed color". From my experience with myself and others, this immediate feedback is the most important thing at the start of programming. So from your background in design, i would probably start with some JS, html, css to create some moving pages/animations etc. Probably best to pick some framework/library (react, vue. Might be even angular too, but i am a bit opinionated against.)
2drcmda --- Congrats for the project in general, it looks nice! But looking through the code on github, my goodness, it is hugely, gut-twisting complex! Pretty sure you could rip out (read: remove completely) 80% of the code in there using the things mentioned in the header as well as remove all the implicit complexity from the views. The app is almost screaming in sheer terror for a sane approach to handling UI (-components!) and (reactive-) state. --- complex app requires complex code, don't you? Pretty sure you could NOT rip out (read: remove completely) even 10% of the code 8) 
that's the most important advice: always start with a project in mind, it makes all the difference when learning something new.
Yes if this is possible why not.
To get into writing code the best thing you can do is stop reading, open a text editor and start doing it. You can read into problems as you run into them and you will learn way better how to solve them as time goes on. Choose a platform you want to develop for (ios, android, windows, web etc...) If you are a designer web would be a nice transition imo. Pick the best language for that platform Find the tools you will need Do it! üòÅ
While I could debate all day the very grey area that byte-code compiled languages fit into the script vs compiled debate, and that they are all programming languages. I do 100% agree that C# is a better learning language in this day and age when compared to Java for core software architecture reasons. Main thing to know is; if you learn how/where/why to write a for-loop it will stand in any programming language that has for-loops (pro-tip: they pretty much all do).
Like this: (function(){ var privateLocalStorage = window.localStorage; delete window.localStorage; console.log(privateLocalStorage); }()); console.log(window.localStorage); They create a closure where all of their local storage operations are and copy localStorage to a variable and then delete the object from the window.
What does 'useless' even mean in this context? ES6 has a huge amount of general language enhancements that benefit basically anything you could write in JavaScript. There's no shame in not using or knowing new tech, but that doesn't mean you should be proud of it. 
Seriously, this is easily most insane example of this particular brand of NIH syndrome I've seen on this subreddit lately. I get that we've had sort of a reactionary trend towards plain JS as of late because of "framework fatigue", but for the love of God, this is exactly the problem those frameworks exist to solve. Writing miles of spaghetti code just to avoid using React or something at all costs doesn't grant you some sort of moral victory over people who do use frameworks. If anything, it tells me you're exactly the sort of developer I hope I never have to work with.
the simplest answer to your question is "Internet", besides online courses, there are many many websites and blogs that post programming tutorials using clear explanations and sometimes using small projects so you can understand, and it depends of course on the programming language you want to learn. for example: if you're interested in web developement (html,css,javascript...) w3schools is the best website and the one that I use the most. You have also tutorialspoint. Another way you can use to learn while having fun, is through game programming tutorials, I personally have a youtube channel in which I upload javascript games tutorials. I learned a lot tbh while making those tutorials.
FreeCodeCamp! Great content and community!
I thought that being single threaded was a good thing, preventing race conditions and stuff?
meh, just realizing how bad their select is, why don't they fix what they already have?
2OmegaVesko --- Seriously, this is easily most insane example of this particular brand of NIH syndrome I've seen on this subreddit lately. I get that we've had sort of a reactionary trend towards plain JS as of late because of "framework fatigue", but for the love of God, this is exactly the problem those frameworks exist to solve. Writing miles of spaghetti code just to avoid using React or something at all costs doesn't grant you some sort of moral victory over people who do use frameworks. If anything, it tells me you're exactly the sort of developer I hope I never have to work with. --- me too React doesn't help you avoid spaghetti code. React doesn't help you in audio apps. React doesn't help you in non-DOM rendering. This app doesn't require nor React nor Reac-based developers 
What's the reason for doing this since it's still accessible from devtools?
Why not use default exports then and do `export default (state, action) =&gt; stuff` in the reducers?
make a game
This guy codes
The first section- front end development- is a really good intro to JS. It would pair really well with design experience. Try to get familiar with the Chrome developer tools (or the equivalent in your browser of choice), and ask if you can fix a front end bug or pair with a front end dev.
https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API youmightnotneedjquery.com https://devhints.io/es6
If jQuery does the job you want, use it. If you want to learn something new, React with something like [create-react-app](https://github.com/facebookincubator/create-react-app) + any AJAX library might be a good start. I have been using [axios](https://github.com/axios/axios) with no problems.
I agree with this all, but would add another loop after 3-4: * Read others code * Repeat until you understand or can reflow
freecodecamp.org
We use axios in our app at work, but we started down that path before there was wide adoption of `fetch`. These days I'd say go with that, since it's built into most modern browsers and has both an isomorphic and polyfill shim for different environments :)
If you are looking to get into front end web development, I would learn these things, in the following order. I don't know about your area, but in Seattle, as of now, this bucket of skills has consistently yielded work for me: 1. html 2. css 3. javascript 4. the dom 5. ajax requests and callbacks 6. node, npm, git 7. es6 8. react 9. webpack 10. redux 11. react router dom 12. responsive scss 13. UI frameworks should take about 6 months to get the hang of react from no experience whatsoever and another 6 months to feel like a wizard. 
I was never a good learner by conventional means and have been starting to make YouTube videos about programming to improve my teaching skills. Currently we are working on remaking Super Mario Bros 1 in modern, pure JavaScript with no special tools around. https://www.youtube.com/watch?v=g-FpDQ8Eqw8&amp;list=PLS8HfBXv9ZWWe8zXrViYbIM2Hhylx8DZx It's not absolute newbie but lots of my viewers seem to learn a lot, or so they are telling me. :) We are touching on most concepts like drawing things, Maps, Sets, Arrays, Loops, Asynchronous programming, but not so much the document object model. Hope it can be worthwhile if you decide to check it out.
I used to be frequent in HTML and CSS so maybe I‚Äôll brush up and move onto the way of JavaScript.
Why not ask here or on Stack Overflow?
You missed a step ?. Your architect says "hell no" 
Is there any new DOM manip or is it still `getElementsByTagName`/`getElementById`?
Honestly, you will probably find that plain old vanilla JS has everything you need for the basic stuff these days. Query selector is as good as jQuery for grabbing elements, native array methods are pretty great, and the fetch API for async requests is as simple as $.ajax
If you haven't already, I highly recommend joining the [Reactiflux](https://www.reactiflux.com/) discord community. There are channels for almost every modern JavaScript topic imaginable and some of the maintainers of these projects you mentioned frequent this server.
Tons of great resources out there. I thought freeCodeCamp's js curriculum was solid. Really good community as well. Otherwise, these are the basic concepts that I'd learn and try to fully understand, before moving onto 'the dom'. 1. primitive types 2. variables 3. strings 4. arrays 5. loops and conditionals 6. functions and scope 7. objects 8. methods
If you're interested in the web world, [FreeCodeCamp.org](https://FreeCodeCamp.org) is an awesome place to get started. You get the HTML, CSS, and Javascript to become productive enough to get a junior dev job, or the confidence to seek out new ideas and technologies.
Have a look at https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector and https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
Stack overflow spammed me with downvotes when i tried. I guess im indirectly asking here but i've been burned with "its easy study it on your own" or "you cant ask this here" in SO where the general environment can get very toxic sometimes.
I havent but i ll go ahead and do that. The main reason im looking for someone for a one on one basis is because i ve got a significant list of questions about architecture, design and why things are the way they are in the js mindset. For this reason, typing them + making revisions to the phrasing would probably take long. But its definitely a start as trying to do everything on my own has proven to be sub par to the expectations.
The dom?
"Nobody on this field seems to be interested in a paid mentorship where i can ask the things that concern me..." Have you tried https://www.codementor.io? I'm looking for someone to mentor me, too. But I can't afford to pay anything. It's unbelievably hard for me to find anyone who will review my code or share any advice. I've asked a lot of people and few of them replied, but their time is limited and discussions are not very deep. I've dreamed about this silly idea - js mafia community, where developers can post the code for review and more experienced developers will review it, in exchange less experienced developers will review some "novice" code of other even less experienced developers. But it's 2017, if this was a good idea, something like that would exist until now. :)
I certainly will!
At work we write an app that i'd say is far, far more complex (a full blown cad system). The size of that is still just a fraction of the size of your code, which in my opinion is unmaintainable. You seem to be unaware of just how much a difference a good state model can make, or a sane components-oriented approach. Not that i would like to try, but from merely looking at what it does, i am fairly certain i could write your app using 80% less code.
No idea why this guy linked you to Java tutorials but Java isn‚Äôt the same JavaScript in case you‚Äôre not aware. If you want to learn JavaScript, learn JavaScript.
Don't worry about it yet. It's basically the environment that your html and JavaScript are inside of and you utilize it to make the two interact.
If your willing to pay, Eric Elliot is one of the top people in the field and he offers some sort of mentorship product. I have no experience with it, and it is a product, not a one-on-one relationship. I think you get like a weekly skype call with him or something
Do you ever use JavaScript? I‚Äôm not actually talking about Java. Excuse me for the confusion.
Lmao I‚Äôm aware!
If you are only looking at ajax functionality, I would second using of axios library. You could see at http://www.purfectstack.com/packages (scroll to HTTP Clients) that it's one of the most popular one. You can also check other HTTP client libraries if you find a need.
I would guess that they are hoping to prevent users from directly manipulating localStorage values
Injected JavaScript code can't read the localStorage.
data science guys are more into Python, afaik
You are wrong. This is very small and clean code for such complex app. 
&gt; This is basically an after the fact notification That explains, I was sure I'd [read it before](https://hacks.mozilla.org/2014/12/mozilla-and-web-components/): &gt; Mozilla will ship an implementation of custom elements. 
I wrote a mandelbrot set renderer in React. [Here is the code](https://github.com/sahaRatul/test-fractal). https://github.com/sahaRatul/test-fractal [Demo](mandelbrot.netlify.com)
No. Most data scientists use Python and R.
Almost : Data Science =&gt; Python, R Data Viz =&gt; JS (D3 &lt;3)
This is looks like ember model/data lite
While I typically back anything the Firefox team does (and love MDN resources)... this is one where I'm missing the real benefits here. The API in general and the hoops to extend an existing element type seem rather overly complicated: https://html.spec.whatwg.org/multipage/custom-elements.html
if you are using Chrome, open the dev tools. Click the Application tab, and look under "Storage". You'll see Local Storage, Session Storage, etc. If the game state is being saved locally it will be there. I do not know if you can actually move the data though, and its possible they the game is just saving a session id and using that to access the game state on a remote server. 
I'll do it for free - I've worked with Ember/React/Angular on production code. I'd say I've got an advanced knowledge in JS itself. Why free? I'm self-taught and pretty much owe my knowledge to the reddit community.
Have you considered asking publicly, e.g. posting here, maybe one question evwry few days? I suggest this because it might be that if you approach someone, one person, saying you have ‚Äúa long list of questions‚Äù, deep, architectural questions, even if you offer to pay, they may see it as overwhelming and refuse the offer. But if you ask publicly and one question at a time, you may not always get answers, but your chances that _someone_ can help increase a lot.
noice!
lmao? The above comment made you laugh?
No, just thinking about Java vs JavaScript. Didn‚Äôt think anybody still used Java for anything.
Wave through the feeling of "i am smartest man **on earth**" to "how could anyone pay me to do this" at least thrice a day
I would assume they had a problem with a shitty web ad that hosed their localStorage and completely filled it and they wanted to prevent that from happening again, so they did this.
Thanks a lot for sharing!! really interesting indeed :)
Customized built-in element's (the ability to extend a native element) is quite contentious, neither Chrome or Safari have implemented this part of the spec.
very good job!!
[MIT used to](https://mitpress.mit.edu/sicp/), not sure if they still do. Scheme is a [surprisingly good choice](https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992) for CS101 precisely because it doesn't distract with lots of syntax or details of internal workings of the computer.
&gt;Didn‚Äôt think anybody still used Java for anything. ---- &gt;As of 2016, Java is one of the most popular programming languages in use, particularly for client-server web applications, with a reported 9 million developers. ---- Nah... It's literally one of the most used languages.
I continue to hear from everybody I ask that Java is going out of style. Why is that? 9 million is like...all of them.
There are two models of multi-threading: competitive and cooperative. Nexus is of the cooperative variety. It uses a thread pool scheduler in place of the event loop. :) I chose this design because things like promises should never compete for access. The promise acts on a single value and returns a single result, it should never compete for resources. The keyword is *should* though. As a programmer, the decision of how your program works should ultimately fall to you. 
I like it as a light weight replacement for ember data which IMO is the weakest point of ember
&gt;Why is that? I don't know how to answer that question. I'll provide you with a chart that shows the popularity of programming languages. **Java is more popular than Javascript.** https://www.tiobe.com/tiobe-index/ 
Do you personally use Java?
SO is really not for general open ended questions or long format discussions. People *do* get extremely toxic about it which is annoying. I think if you ask some questions here, people would be receptive to it. Hell, you can probably post your list of questions and some people might try and answer some of them.
Also...more people use Java than any C language?! Where have I been?
Hey, I added a big edit, give this a read: Here's the thing, programming languages are like tools, you don't always use the same tool for every job. Javascript is good for client side web scripting and now thanks to node.js it's good for server side scripting as well. Java is better for desktop applications, and thanks to Android, it's also used for native mobile development. (You can use javascript for desktop applications with Electron, but most people consider Electron to be too bloated and a memory hog) When you learn to program, keep in mind you will need to learn many languages to be able to do most things. ---- But yes, I do use Java at work for ETL applications using a tool called Talend. I use javascript for websites (using node.js and react) And even though some people don't like electron, I used electron to build a dashboarding desktop application for our data processors. I also use BASH on linux machines for automating things and C#/.NET for a different Desktop application we maintain. I use PHP for my personal projects. Programmers usually learn a variety of languages, scripts, and tools. 
This is exactly the problem I was trying to solve with https://menternship.org , a website where professional developers create internships out of their side projects for beginner programmers. For paid mentors, codementor looks alright, except it feels more like a consulting service than a mentoring service. Eric Elliot runs devanywhere.io which is a paid mentoring service. Reactiflux is an awesome community for really anything javascript. I wish there was a strong node discord/slack/gitter community, but nothing ever caught on, although the reddit communities (learnjavascript, webdev, javascript) are really strong.
Aye! I have read that! Is that a beginning portion a quote from Javascript‚Äôs site?
Nah, I'm shooting from the hip.
Ahhh! I‚Äôve also heard very similar info about JavaScript from server side from a good friend that is making me learn code.
Go slow and try not to get discouraged. It took 4 years of college and 4 years of working for me to learn all that stuff. I think regular old javascript is perfect for a beginner because all you need to run your code is a web browser. 
Awesome! I think it will be my first proper language 
That's the same reason I recommended axios. If you don't have to support IE, `fetch` is more than adequate.
So... Are Javascript mentors elusive, or are React + Redux mentors nonexistent? Because that's two different things.
How are promises competing for resources? Just curious. I thought they were delegated to web workers outside of the JavaScript engine.
You know it. Yesterday I was curled up in the fetal position on my couch all night having Pepsi for dinner. The day before I was a god.
fetch()
Modern devtools works with your browser's internals instead of the public DOM accessible stuff.
Amaaaaaaaazing!! can't believe you did it just with javascript o-o
Thank you for being reasonable.
Hi. I'm a Redux maintainer, and a mod in Reactiflux. I _definitely_ encourage you (and anyone else) to come hang out in Reactiflux! We've got a bunch of people there who are always happy to answer questions, and I don't think you'll find a better collective amount of React+Redux+JS experience pretty much anywhere :) Also, I'll toss in my standard advice for learning React (and Redux): The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://reactjs.org/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. For an even simpler setup, CodeSandbox ( https://codesandbox.io ) is an online editor that lets you build entire React projects right away. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, Redux, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux.
The content strong you pass to the info window has to be html so you need to add an img tag with src="theurltoyourimage". You can use a data URI in place of the url but you'll have to create it from the uploaded image data. You can do that with a hidden canvas but it's not super fast, better to do that as part of the upload handler on the server side. 
You should ask on /r/java too -- `javascript` and `java` are totally different. 
Here's a sneak peek of /r/java using the [top posts](https://np.reddit.com/r/java/top/?sort=top&amp;t=year) of the year! \#1: [Finally: Effective Java, 3rd Edition](https://np.reddit.com/r/java/comments/74x9gv/finally_effective_java_3rd_edition/) \#2: [Why reverse loops are not faster](https://arnaudroger.github.io/blog/2017/06/15/forward-vs-backward-loop.html) | [67 comments](https://np.reddit.com/r/java/comments/6hg530/why_reverse_loops_are_not_faster/) \#3: [Java 9 Released](http://mail.openjdk.java.net/pipermail/announce/2017-September/000230.html) | [77 comments](https://np.reddit.com/r/java/comments/71lse7/java_9_released/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
is it like XSLT just js instead of xml?
&gt; Eric Elliot is one of the top people in the field Eric, is that you? Please tell me how you started programming when you were 12 and why everything is bad. 
For sure and I recognize that - My concern is just as a developer; modern modularized front end build tooling solves what custom-elements code potentially offer in a simpler manner than their proposed API, so overall I'm just confused at exactly what this spec/proposal is solving.
Let me clarify my statement: Promises never compete for access, which makes them ideal for a multi-threaded environment. (and I'm not speaking of web workers, I mean bare-metal multi-threading like I'm doing) 
I'm just not sure why you would want to. Webcomponents and jsx do much the same thing so I'm just not seeing the goodness of it.
lol, is he not? I read one of his books and see his articles around a lot, dont know much else about him. I did have to stop following him on twitter because of spam
I have not, did inspire me to make a linked list implementation. 
The spec and effort behind it is a kind of retort to these "modern ... front end build tooling" practices. To steal a line from the guys at Polymer, the goal is to "use the platform." The spec lets us write component based applications in javascript that we can just give to the browser without sending it through webpack just to get it to work. 
I thought that's what I did in the code in my edit. 
Yea, those are definitely all good goals - the more we can simply do in the browser natively, the better - I can get behind that idea. I just can't quite picture a scenario where I'd even bother to use custom-elements yet though. Any good examples come to mind?
Custom elements will allow you to write a framework agnostic component that can be used inside any framework of your choosing. Instead of having to find an angular date picker and then a month later on a new project a react date picker you can reuse the exact same date picker across apps.
They easily enable the prpl pattern: https://developers.google.com/web/fundamentals/performance/prpl-pattern/. One way of going about single page application design is to have a top level custom element with a router that lazily imports your views which in turn are custom elements. Your application then turns into a tree of ever increasingly specific elements. The real magic comes from the reusability of the more specific elements you end up writing. For example, I'm working on a site for a radio station. We have a custom element that just displays the details for one song, so it has the album art, song name, etc. I use that element in the real time player and in the song history widget. 
... so? Motif widgets were there since the what, late 80s?
Custom elements are part of web components, together with shadow root and HTML templates.
It could be my ignorance, but is there a way to do this natively on the web before the custom element spec was introduced?
I have not 'seen the light' on custom elements but I would assume it is akin to `fetch` vs `axios`: Yes, `axios` is 'easier to use' but `fetch` is low-level enough to allow you to build an `axios` clone on top of it. Basically, Custom Elements are not supposed to replace `React` or `Angular` but instead be the primitive that those tools use.
Yeah it‚Äôs Mail Chimp, crazy I know. I had to open the link in my browser on mobile, but while it‚Äôs loading, you can see the Mail Chimp logo. And once your phone is sideways and the video is playing, turn your phone back to right-side-up and a little tab will pop up at the bottom that says ‚Äúwe‚Äôre Mail Chimp... learn more‚Äù
No, but that speaks more on the state of the web as a platform. I fully expect something like a COM registry within the next 5 years.
From I understood from the chrome dev summit: - Google pushed the WebComponents (WC) in 2011. No traction from devs. Implementation in Chrome. - Meanwhile, FB solved similar problems without touching the browser with React in 2013 - Google saw the lack of traction of WS due to the lack of tooling and compatibility - mostly ignored React as a serious contender - started working on Polymer. - FB continued pushing React with great adoption and without having to align browsers and libs. - React eventually went above and beyond WS scope, with awesome dev experience and references of popular apps using it in prod. - Google tried to bring back the feature in the browser, as it is their expertise area and competitive advantage. Praised interop between frameworks in all conferences. - When Angular + Polymer sits around 6M download versus 60M+ for React this year, React sees no value in spending effort in trying to make it work with Google's technology for helping Google's libs adoption, when their effort wants to spent elsewhere. This is where I start to speculate: - Google asks Mozilla to implement custom elements, which is an evolution of WC. The idea is to seek developer's support and to show consensus/momentum. 
`blink`
How does this hold up to deeplearn.js from google?
sry for being lazy and not reading threw the whole topic, if i get the title right, how will SEO work with custom elements?
This needs to be directly compared to json schema. There needs to be one huge reason why one should consider this over what is currently most used
The spec/proposal would allow a formalized way for components from different frameworks to work together. EG: Angular Elements will be using custom elements with the goal of being able to use Angular compiled components in React/etc apps.
What worked for me was to start making stuff. Pick what you want to do, read the documentation, set a goal (I will build a todo app that I could realistically use), then set out on achieving that goal. Now, that may not work for you but I would give it a shot. I have learned more making things than anything else. Keep the goal in mind and enjoy yourself!
If you put a console.log() call just before you construct the content string you'll see that it's executing before your rdr.onload() function finishes. You can't construct the content string until you have the data url. You can construct the content string inside the rdr.onload() or use a callback (or a promise, or a ...) to construct the string and create the info window. 
I'm kind of confused as to why you would want to route like this. Anyone give me some use cases as to why this would be better than just a simple router?
[removed]
The origin behind custom elements is [the extensible web manifesto](https://github.com/extensibleweb/manifesto). When HTML 5 arrived, it was only after years of developers wanting things like the date/time inputs (which [Firefox only implemented recently](https://blog.nightly.mozilla.org/2017/06/12/datetime-inputs-enabled-on-nightly/)), and buildings things like date/time input plug-ins for JQuery, MooTools, Ext.js, Angular, and what-have-you. The idea behind custom elements is to prevent this from happening in the future. Whenever a new interface concept gets popular (rounded corners, anyone?), web developers would not have to wait for years for all browsers to support it. Instead, they could use tried-and-tested web components that work regardless of the tech your website is using. And then, of course, there's Polymer, which thinks it's a good way to design your entire application. I haven't figured out why that would be a good idea yet.
Copying [my other comment](https://www.reddit.com/r/javascript/comments/7gliby/mozilla_intent_to_implement_custom_elements/dqkh3p3/): &gt; The origin behind custom elements is [the extensible web manifesto](https://github.com/extensibleweb/manifesto). When HTML 5 arrived, it was only after years of developers wanting things like the date/time inputs (which [Firefox only implemented recently](https://blog.nightly.mozilla.org/2017/06/12/datetime-inputs-enabled-on-nightly/)), and buildings things like date/time input plug-ins for JQuery, MooTools, Ext.js, Angular, and what-have-you. &gt; &gt; The idea behind custom elements is to prevent this from happening in the future. Whenever a new interface concept gets popular (rounded corners, anyone?), web developers would not have to wait for years for all browsers to support it. Instead, they could use tried-and-tested web components that work regardless of the tech your website is using. &gt; &gt; And then, of course, there's Polymer, which thinks it's a good way to design your entire application. I haven't figured out why that would be a good idea yet. So no, JSX don't do the same thing: it doesn't solve the problem of sharing components which can maintain internal state over the different tech stacks people are using. It's not the revolutionary technology some are making it out to be, but it can certainly be useful.
What's your take on ember data?
Assuming javascript isn't an issue, it's no different than standard HTML.
the most of people treat frameworks as miracle. But you can't create unordinary app with ordinary tools. Does GMail use any framework? No. Facebook? No. Twitter? No. MS Office 360? No. All of them created own frameworks to solve own specific tasks. This app needs to show hundreds objects on a screen, see [example song](https://surikov.github.io/RiffShareAndroid/app/src/main/assets/load.html?riff=78-40000660-4060a093-0d0d080c0e0c080f060e-00ad01ad02ad03ad04ad05ad06ad07ad08ad09ad0aad0bad0cad0dad0ead0fad10ad11ad12ad13ad14ad15ad16ad17ad18ad19ad1aad1bad1cad1dad1ead1fad40104110421043104410451046104710481049104a104b104c104d104e104f1050105110521053105410551056105710581059105a105b105c105d105e105f1080548155825583558455855586558755885589558a558b558c548d558e558f5590549155925593559454955596549755985499559a559c549d559e559f55a001ac01b001b401b601b801bc01e001ec01f001f401f601f801fc01-0000206400050206400200106400250206400300106400400112400500206400550206400660225400700106400750104400860325400800206400850206400a00106400a50206400b60123400b00106400c60223400c00112400d00206400d50206400e60221400f00106400f50104401060425401000206401050206401200106401250206401300106401400112401500206401550206401700106401750104401800206401850206401a00106401a50206401b00106401c00112401d00206401d50206401e6021e401f00106401f50104402060425402000206402050206402200106402250206402300106402460225402400112402500206402550206402660623402700106402750104402800206402850206402a00106402a50206402b00106402c60321402c00112402d00206402d50206402f60325402f00106402f50104403000206403050206403200106403250206403300106403400112403500206403550206403700106403750104403800206403850206403a00106403a50206403b00106403c00112403d00206403d50206403e6021e403f00106403f5010440406042540400020640405020640420010640425020640430010640446022540440010d404500206404550206404660623404700106404750104404800206404850206404a00106404a50206404b00106404c0010d404d00206404d50206404e6021e404f00106404f5010440506022540500020640505020640526042540520010640525020640530010640540010d405500206405550206405660623405700106405750104405800206405850206405a00104405a50109405b00104405b50109405c0021c405c00215405c00210405c00209405c50109405d50209405e00104405f00104405f50104406001823406001817406001810406001804406050204406160223406250104406360423406350204406550204406760125406750104406860823406850204406a50104406b50204406d50204406f5010440706042040705020440725010440735010440746142040745010440755020440775010440780031740780031040780030b407800304407850204407a50104407b00117407b00110407b0010b407b00104407b50104407c00419407c00415407c00410407c00409407c50109407d50209407f50106408000206408050206408200106408250206408300106408400112408500206408550206408700106408750104408800206408850206408a00106408a50206408b00106408c00112408d00206408d50206408f00106408f5010440906101e409000206409050206409200106409250206409300106409400112409500206409550206409700106409750104409800206409850206409a00106409a50206409b00106409c00112409d00206409d50206409f00106409f5010440a00011c40a00011940a00011540a00011040a00010940a05010940a10011c40a10011940a10011540a10011040a10010940a15010940a20011c40a20011940a20011540a20011040a20010940a25010140a30011c40a30011940a30011540a30011040a30010940a35010240a46022d40a40011c40a40011940a40011540a40011040a40010940a45010440a50011c40a50011940a50011540a50011040a50010940a55010640a66022d40a60021c40a60021940a60021540a60021040a60020940a65010740a75010940a86042d40a80011c40a80011940a80011540a80011040a80010940a85010940a90011c40a90011940a90011540a90011040a90010940a95010b40aa0011c40aa0011940aa0011540aa0011040aa0010940aa5010140ab0011c40ab0011940ab0011540ab0011040ab0010940ab5010240ac0011c40ac0011940ac0011540ac0011040ac0010940ac5010440ad0011c40ad0011940ad0011540ad0011040ad0010940ad5010640ae0011c40ae0011940ae0011540ae0011040ae0010940ae5010740af0011c40af0011940af0011540af0011040af0010940af5010940b00011e40b00011b40b00011740b00011240b00010b40b05010b40b10011e40b10011b40b10011740b10011240b10010b40b15010140b26022340b20011e40b20011b40b20011740b20011240b20010b40b25010340b30011e40b30011b40b30011740b30011240b30010b40b35010440b46022f40b40011e40b40011b40b40011740b40011240b40010b40b45010640b50011e40b50011b40b50011740b50011240b50010b40b55010840b66022f40b60021e40b60021b40b60021740b60021240b60020b40b65010940b75010b40b86042f40b80021e40b80021b40b80021740b80021240b80020b40b85010b40b95010140ba0021e40ba0021b40ba0021740ba0021240ba0020b40ba5010340bb5010440bc0011e40bc0011b40bc0011740bc0011240bc0010b40bc5010640bd0011e40bd0011b40bd0011740bd0011240bd0010b40bd5010840be0011e40be0011b40be0011740be0011240be0010b40be5010940bf0011e40bf0011b40bf0011740bf0011240bf0010b40bf5010b40c00011f40c00011c40c00011840c00011340c00010c40c05010040c10011f40c10011c40c10011840c10011340c10010c40c15010240c26023040c20011f40c20011c40c20011840c20011340c20010c40c25010440c30011f40c30011c40c30011840c30011340c30010c40c35010540c46023040c40011f40c40011c40c40011840c40011340c40010c40c45010740c50011f40c50011c40c50011840c50011340c50010c40c55010940c66013040c60021f40c60021c40c60021840c60021340c60020c40c65010a40c76033040c75010c40c80021f40c80021c40c80021840c80021340c80020c40c85010040c95010240ca6023040ca0021f40ca0021c40ca0021840ca0021340ca0020c40ca5010440cb5010540cc6023040cc0011f40cc0011c40cc0011840cc0011340cc0010c40cc5010740cd0011f40cd0011c40cd0011840cd0011340cd0010c40cd5010940ce6023040ce0011f40ce0011c40ce0011840ce0011340ce0010c40ce5010a40cf0011f40cf0011c40cf0011840cf0011340cf0010c40cf5010c40d06033440d00011f40d00011c40d00011840d00011340d00010c40d05010040d10011f40d10011c40d10011840d10011340d10010c40d15010240d20011f40d20011c40d20011840d20011340d20010c40d25010440d36033240d30011f40d30011c40d30011840d30011340d30010c40d35010540d40011f40d40011c40d40011840d40011340d40010c40d45010740d50011f40d50011c40d50011840d50011340d50010c40d55010940d66063040d60011f40d60011c40d60011840d60011340d60010c40d65010a40d70011f40d70011c40d70011840d70011340d70010c40d75010b40d80041f40d80041c40d80041840d80041340d80040c40d85020c40de0020740df5010640e00020640e05020640e20010640e25010640e30010640e35010640e40011240e50020640e55020640e70010640e80020640e85020640ea0010640ea5020640eb0010640ec0011240ed0020640ed5020640ef0010640ef5010440f00020640f05020640f20010640f25020640f30010640f40011240f50020640f55020640f70010640f75010440f80020640f85020640fa0010640fa5020640fb0010640fc0011240fd0020640fd5020640ff0010640ff5010440) . It is too heavy for DOM. But the most of modern frameworks uses DOM. Due of this I created my own fast and powerful SVG engine. I will publish it later. This app requires real music instruments. There aren't any library to play real guitar, piano etc. I created my own library for audio, see https://github.com/surikov/webaudiofont WebAudioFont includes about 1000 real instruments and sounds good. Use React or Angular for simple UI. Use only appropriate tool for complex app. Use WebAudioFont for musical apps 8) 
It depends which feature you're talking about. The ORM-like routes honestly saves a bit of time when spinning up apps that generally use the same routes. The custom routes feature is something we actually use at my work (chess.com). Our backend spits out out a list of routes to a .yml file and we generate them in js based off the route name. But - with anything, it's not for everyone. 
&gt; So no, JSX don't do the same thing: it doesn't solve the problem of sharing components You can share it easily. In many libraries sharing is as simple as using a component or aliasing the framework. The last resort would be a mounting node, which is the lowest possible primitive and guaranteed to work, even in old browsers: [From Gutenbergs interview](https://wpcouple.com/interview-react-team-facebook-wordpress-gutenberg/), Dan Abramov: &gt; Web Components are often hailed as the solution to interop, but in practice, we‚Äôve had an interop solution for all these years: it is called plain JavaScript. On top of that, you can always add something else, including Web Components. Since you can create DOM elements from plain JavaScript, I would consider it to be lower level, and thus more powerful.
I don't think anyone is saying you should change anything. They are all correct, however, that using a view library and a state management system would have resulted in writing less, and cleaner code 
&gt; Does anyone know something like that, that is really not mentioned anywhere? I am really intersted in JS secrets. Maybe skim [the language spec](https://www.ecma-international.org/ecma-262/6.0/)? It defines the language so everything is in there.
MOBIRISE is nice for a quickie. https://mobirise.com
RemindMe! 1 day
I will be messaging you on [**2017-12-01 18:56:43 UTC**](http://www.wolframalpha.com/input/?i=2017-12-01 18:56:43 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/7gnp5y/build_a_regex_engine_in_less_than_40_lines_of_code/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/7gnp5y/build_a_regex_engine_in_less_than_40_lines_of_code/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; [Framework.]createElement is the closest thing to shared, universal packages and codebases that we've had, in the web and otherwise. I agree, but only because we don't have web components yet. Also, it should be noted that (the idea of) web components predates JSX, so it might as well have become superfluous. Then again, I think not having to include a library specifically for a certain component (e.g. react-blessed doesn't work with React 0.13, according to its README) really is a boon. And I know, because I've worked with Polymer in a single project with a lot of components from different contributors, and having to manage the library versions for all of them, even though it was just Polymer and it was all in the same company, was (and still is, I hear) a giant pain in the ass that I'm not sorry to be rid of.
Could you point me to a single component in the eco system that needs a webpack transform, other than for module or resource support, like everything else does atm? Polymer itself will be reliant on webpack btw. since HTML imports are dead. 
Custom elements and js modules are supported in the most current version of chrome
Wow, looks cool
Maybe a noob question but how to deploy it? Just use the cli from hosting like aws or need some previous step? 
How would web components help that console renderer, that has nothing to do with the web and renders natively on another platform, to animate for instance? &gt; Then again, I think not having to include a library specifically for a certain component But this is exactly what web components do. If you load 10 components, in the worst case scenario you'll load 10 frameworks. The spec is just a sealed blackbox, inside it relies on a framework, which kind of makes the idea even sillier.
My friends and me just released an interactive GraphQl schema visualization tool. It would be helpful for those who just started using GraphQl. We are going to add more features on it in the future. Please try it let me know what you think!
hahah "Reddit please implement this feature for me. Thanks!"
No? I have code to show what I worked on and I just wanted some guidance..I wasn't asking for anyone to do it for me. I thought this is how you ask a question, you should what you know and what youve done and i thought i did that. Im sorry if it seems that way
The code that you posted is/nearly is equivalent to beforeEach(function(){ fixture = ... component = ... fixture...() }) Does your posted code us `arrow functions`? Yes. Does it represent an `arrow function implementation`? Yeah but that is a really weird way to ask if it uses `arrow functions`. What does it do? It sets the value of an out-of-scope variable called `fixture` to the result of `TestBed.createComponent(Comp)`. It also sets an out-of-scope variable called `component` to be the value of `fixture.componentInstance`. Finally, it calls the method `detectChanges` on the `fixture` object set above.
You should look into redux-saga
OK, I have the following: var rdr = new FileReader(); var span = document.createElement('span'); let contentString; rdr.onload = (function(theFile){ return function(e){ span.innerHTML = ['&lt;img src="',e.target.result,'" /&gt;'] contentString = '&lt;div id="content"&gt;'+ '&lt;div id="siteNotice"&gt;'+ '&lt;/div&gt;'+ '&lt;div id="bodyContent"&gt;'+ span.innerHTML+ '&lt;/div&gt;&lt;/div&gt;' } })(file); rdr.readAsDataURL(file); I get no errors, the picture does not show, but the element is being placed and showing the following in inspector: &lt;img src=",data:image/jpeg;base64,/9j/4VCRRXhpZgAASUkqAAgAAAANAAABBAABAAAAAAoAAAEBBAABAAAAoAUAAA8BAgAIAAAA...,"&gt;
no. Read my comment about fast rendering and audio.
There are better ways of handling this specific case; it's only an example. OP wasn't being serious anyway.
Maybe your'e right and Reddit would love to answer. Although, this is how I read your "question". Good luck.
Everything I do can be easily, and cleanly accomplished in middleware. I've fiddle with saga before, but I don't feel the need for it in *most of my work*. In my opinion, redux middleware is already a pretty good design for the bulk of things a developer needs to do.
You're seriously trying to play the underdog _and_ somehow use an argumentum ad populum at the same time? Just to be clear, you're wrong about this: &gt;Does GMail use any framework? No. Facebook? No. Twitter? No. MS Office 360? No. Facebook and Twitter both use React heavily. So do Netflix, Airbnb, and plenty of other companies with products larger than anything you've ever built. And, just so I'm not talking about React all the time, the new YouTube is built on [Polymer](https://www.polymer-project.org/), and LinkedIn uses [Ember](https://www.emberjs.com/). Yes, of course there are plenty of web apps not built on any of these large frameworks, though often enough this is because they predate the modern concept of front-end frameworks and view libraries. Either way, building a large app without any sort of framework requires a huge amount of skill for the result to be remotely performant and maintainable. &gt;Use React or Angular for simple UI. Use only appropriate tool for complex app. This is so misguided, I don't even know where to begin.
It is a question? I thought when you ask you say this is what did, what i know and i need help or guidance. I did not ask for direct answers or do it for me. This really hurts as someone who is starting JS it discourages me and makes me wonder why bother. I thought I was trying. 
this is what they do on stackoverflow all the time and I figured it would be the same. 
We've been replacing AngularJS on our site with custom elements (not full web components), and recently released our search page that is a combination of various elements: https://developers.redhat.com/search/?t=no+cost+developer+subscription
You are trying and you're doing well. And i'm far from the authority on how people interact with others etc. But in my experience the people that really do well would work through this type of thing. Notice your title "need help implementing &lt;feature&gt; with &lt;technology&gt;". It's not really a question. It's a request. I encourage you to keep working at it and hack together a solution. If it feels tough and you have no clue what you're doing, then you're doing it right and welcome to programming! 
Yes, by definition async functions can't return anything useful themselves, which is why classical js uses callbacks and modern js uses promises and observables.
WHY? JavaScript already runs in XML in the browser: * https://stackoverflow.com/questions/384639/how-to-include-javascript-in-xml-document * https://stackoverflow.com/questions/4121594/getting-javascript-to-execute-for-xml-file What benefits does this offer that already available in XML, XML Schema, and the DOM?
Anything is possible
What /u/cirsca said. It's basically just another way to write a standard function; the "arrow" method would actually make a difference if the `this` variable was used, as that would have an effect based on which context the function was called in. One notable observation is that because the function body is wrapped in `{}` braces, an explicit `return` is needed to return a value, otherwise the "concise body" approach would take the body, evaluate it, and return that. (more info [here on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body); but note that a concise body is executed as a single line of Javascript, so variable declarations and code line delimiters (`;`) would break the function)
Mozilla tends to do the opposite of what Google asks - I believe it was Mozilla that killed Google's cherished HTML imports. Also, the key to adoption for web components was Apple adding support to Safari since Safari on iOS is the only browser/webview that there is no alternative for or way around. Once that happened, I figure Mozilla was do it too once they got Quantum done.
Does this include a native Shadow DOM implementation?
Thanks for sharing üëçüëç
JavaScript's objects are already hash tables. let hashTable = {}; hashTable['key'] = value;
 foo = (id) =&gt; { return this.getData(id).then(res =&gt; res.data); } foo = async (id) =&gt; { const data = await this.getData(id).data; } foo = (id) =&gt; { this.getData(id).then(res =&gt; this.eventEmitter.emit('data-received', res.data); // where you've already done this.eventEmitter.addListener('data-received', this.onDataReceived); elsewhere in your code like in the componentWillMount() }
Just wanted to share this as I have been working on it over the past couple of years and feel its now in a good place for wider use rather than just bespoke clients projects. It is written to make use of the new features while being compatible in an ES5 world, such as async/await/decorators and can be used anywhere, be it a front end framework, vanilla js/ts or nodejs. It currently has out the box plugins for vue, aurelia (due to be updated), knockout and if it gets traction would love to have out the box plugins for other view frameworks.
Just wanted to share this as I have been working on it over the past couple of years and feel its now in a good place for wider use rather than just bespoke clients projects. It is written to make use of the new features while being compatible in an ES5 world, such as async/await/decorators and can be used anywhere, be it a front end framework, vanilla js/ts or nodejs. It currently has out the box plugins for vue, aurelia (due to be updated), knockout and if it gets traction would love to have out the box plugins for other view frameworks.
Thank you!
thanks!!
We just released a new version of [smartbanner.js](https://github.com/ain/smartbanner.js) this week. Take a look in case you'd like to promote your app on a website of yours :)
It's not a valid data URL with the leading and trailing commas in there. Try this... span.innerHTML = '&lt;img src="'+e.target.result+'" /&gt;'; 
nice article!
*bangs head on wall* OK, thanks for all your help. The image is appearing now, albeit upside-down and all pins show the same image (first image user selected). This is turning to a different problem that I'll try to solve for a while before posting again.
It depends on how getData is implemented. XMLHttpRequest _does_ support synchronous requests, though it shouldn't be used - and in using it, the function no longer becomes async. By definition, if the function is async, then you can't get a synchronous response (immediate return). So instead a callback is needed to encapsulate code that does get called when the response is available. Direct callbacks and callbacks through promises do this explicitly while the use of async/await is a syntax that abstracts this with synchronous looking code, hiding what ultimately is a promise resolution in the background. Though it looks synchronous, it remains asynchronous and time (frames) will pass between blocks of code separated by await expressions.
The way you're doing it, you need to have one dynamically created span element for each image you add to the content string (each reader.onload handler needs an independent span element to work with) -OR- You could skip creating the span element and just insert an img element with the data URI right into the HTML string. That's the key benefit of using the data URL, you don't need to manipulate DOM elements to work with images.
Looks like a great tool! Looking forward to checking this out on my next React app.
Like this... contentString = '&lt;div id="content"&gt;'+ '&lt;div id="siteNotice"&gt;'+ '&lt;/div&gt;'+ '&lt;div id="bodyContent"&gt;'+ '&lt;img src="'+e.target.result+'" /&gt;'+ '&lt;/div&gt;&lt;/div&gt;';
&gt; Can't you just set "color:orange" in well class or right-well ID? Try it and see what happens. That's.. programming! :)
It would probably be useful to introduce a small delay before the fetch. Rapid clicks on the filters on this page cause many unnecessary requests.
What's the name of the last app that he recommends? Couldn't hear it clearly from the video.
It can be circumstantial. Often, applying a style to the parent will mean that children of that parent will also inherit that style. The color style, is usually an example of this, but it doesn't work with all elements. &lt;button&gt; children, for example, will not inherit parent color styles, so in this case, the children() is necessary to target those buttons individually. Without children(), the style is only applied to the parent div which gets ignored when the browser goes to draw the button child elements. There are a number of quirky exceptions like this and it will take time and experimentation to get to know what they are.
It depends on how the developer of the game set up the game. If it's localStorage you should be able to export the localStorage to a text file (it's just Text data after all), and then re-import it into the browser on the other computer. That's not advanced level stuff, but it's also not trivial either. 
Remindme! 2 days
Your question stood in my head since you asked it. Didn't had time to test it, but is it possible to solve this problem with a visitor pattern? But I agree that's a problem ^^
Hi /u/ArchAesthetics2046, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I guess the example isn't just popping out at me. Also the "ORM" makes me cringe.
Ok, I can kinda get that idea - but the proposed spec isn't introducing something like a proposed vDOM + life cycle implementation (which is the main advantage of something like react, vue, inferno, etc and something that would need to be baked into any kind of shareable component =&gt; e.g. writing a react component that simply returns raw html with event handlers is already in itself something that can be shared/re-used [its the custom hook up to props, life cycle events, vdom, etc that offer the main benefit]). Extending a &lt;button&gt; tag to take advantage of some inherent properties and behavior tied to it is something we already leverage in many frameworks. Either way, not like it hurts to implement this concept, I wish I could just grasp exactly where and how it is enhancing both a developer and user's experience. Maybe I just need to read up on this more.
Alright, so here's the whole relevant function. I dropped the span element completely and inserted the image element directly into the content string. It behaves exactly the same way as before (all markers show the same image...upside-down): function fillMap(){ var input = document.getElementById('img1'); var files = input.files; for(var i = 0; i &lt; files.length; i++) { var file = files[i]; var reader = new FileReader; reader.onloadend = function () { var exif = EXIF.readFromBinaryFile(this.result); console.log(exif); var lat = exif.GPSLatitude; var lon = exif.GPSLongitude; var latRef = exif.GPSLatitudeRef || "N"; var lonRef = exif.GPSLongitudeRef || "W"; lat = (lat[0] + lat[1]/60 + lat[2]/3600) * (latRef == "N" ? 1 : -1); lon = (lon[0] + lon[1]/60 + lon[2]/3600) * (lonRef == "W" ? -1 : 1); var coords = new google.maps.LatLng(lat,lon); var title = exif.DateTime; var marker = new google.maps.Marker({position:coords,title: title}); marker.setMap(map); var rdr = new FileReader(); let contentString; rdr.onload = (function(theFile){ return function(e){ contentString = '&lt;div id="content"&gt;'+ '&lt;div id="siteNotice"&gt;'+ '&lt;/div&gt;'+ '&lt;div id="bodyContent"&gt;'+ '&lt;img src="'+e.target.result+'" /&gt;'+ '&lt;/div&gt;&lt;/div&gt;' } })(file); rdr.readAsDataURL(file); markers.push(marker); marker.addListener('click', function(){ if(infowindow){ infowindow.close(); } infowindow = new google.maps.InfoWindow({ content: contentString }); infowindow.open(map,marker); }); if (i==0){ map.setCenter(new google.maps.LatLng(lat,lon)); } } reader.readAsArrayBuffer(file); } }
[removed]
Yeah, like I said, not for everyone :)
I got 2 years of experience with react redux ,etc and 6 years of JS experience, feel free to ask any questions my way. I love mentoring and I am a mentor during my free time in https://www.thinkful.com/ so I have some experience :)
It's called boostnote 
Apologies, I'll make sure to read it thoroughly. 
I agree, this looks to me like reinventing the wheel. The points the author mentions to me seem implementation specific and are not a justified reason to reinvent json schema. I'm also at a loss how this got 300+ stars in what looks a very short period of time. Please if I'm missing something point it out. 
Without alternation and grouping this does not implement anything close to RegExp.
Well first I think the benefits of the vdom are vastly overrated. Angular stays performant without one just fine. The vdom is certainly a valid approach but it's not the only one. Second is the component can take care of itself independently of react doing Dom updates based on diffs. The two are orthogonal. Or at least they can be. I don't know enough about reacts internals to say whether it would work right at this very moment.
Thanks for the thanks!
Custom elements, on polymer, will run through webpack before you publish. The end user never needed webpack, not for polymer, vue, or react. The only difference is that the latter run natively in all browsers, not just chrome.
&gt; Angular stays performant without one just fine. With track-by maybe, but if you don't/can't/forget using it... whoa man!
If you added a .bind(this) to the function it would be the same...
Don‚Äôt you post this every day
How's this different to Joi?
I just started exploring graphql and this is pretty great :) bookmarked! 
Are you talking a out angular or angularjs? It certainly helps for angular but isn't really needed until you're iterating over large (for the front end) data sets.
Completely agree. Do you or does anyone else think adding them would make a good followup to this post?
How petulent and elitest of you. What is the purpose of even making this comment? To belittle the author? The article clearly exists to demonstrate how a regex engine might be developed, and how it works. It's purpose is not to implement POSIX EREs, PCRE, egrep's regex, etc. You are mistaken, either way. From [wiki](https://en.wikipedia.org/wiki/Regular_expression), "A regular expression, regex or regexp[1] (sometimes called a rational expression)[2][3] is, in theoretical computer science and formal language theory, **a sequence of characters that define a _search pattern_**." Pretty simple definition. Then, there are the regular expressions of yore, and their development. [POSIX BREs](https://www.regular-expressions.info/posix.html) is a formal specification that supports grouping, but grouping did not always exist in regular expressions, even in the well-known UNIX tool `grep`. "The other **BRE metacharacters require a backslash to give them their special meaning**. The reason is that **the oldest versions of UNIX grep did not support these.** ... Tokens can be grouped with \( and \). ..."
I‚Äôve been seeing more and more posts about Vue everywhere it seems. Guess I should check it out!
STICKERS. 
I bet people don‚Äôt know about json schema
Very good idea. Super appreciate it.
async/await
Is that really the source code on GitHub? It seems like this is the compiled code Babel would give you. https://github.com/reactopt/reactopt/blob/master/src/normalizeOptions.js#L25 I don't know who would write their variables like this.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [reactopt/reactopt/.../**normalizeOptions.js#L25** (master ‚Üí e6add02)](https://github.com/reactopt/reactopt/blob/e6add029531a091666ed882746d92f09260b5c60/src/normalizeOptions.js#L25) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dql8677.)^.
Yes, it looks transpiled.
the source code in the repo is not transpiled... though the dist is.
In my experience prototype is array like and has to stay that way. I remember having to push values to a prototype instead of hard coding a value to affect its length 
deeplearn.js is about deeplearning, mlhelper is about machine learning.
Are you talking about polyfilling methods or something? Like coding up an `Array.keys()` method and then you had to push it to the prototype instead of just assigning it like a normal method (of `Array.prototype.keys = function() {...}`
As far as I understand "exotic" just means "the implementation is provided by the JavaScript engine" which are often written in C/C++ these days, as supposed to "ordinary" which are full native JS implementation. 
Don't rely on random recruiters that have added you on linkedin. In fact avoid linkedin in general, in my experience it's a thing you should have because people want to see you have one but pretty useless for actually finding a job. Use stackoverflow job board - if you have a good score on SO and a developer profile you will get a trickle of legit job opportunities. Applying via their job board will get you decent results - there should be plenty of opportunities in the greater NYC area. Try AngeList if you are more into startups. Also Indeed has a decent selection. I'm sure there's other options, so cast a wide net and you will find something in no time. Best of luck! Side note - know your worth. Don't let recruiters dick you around. If something smells fishy, cancel it.
Considering google refers to deeplearn.js as building blocks of machine learning I wouldn‚Äôt venture to make that distinction. 
I believe it's false because instanceof checks the prototype chain and it probably isn't in its own chain. However it IS an array, and you can check in a few ways (including `isArray()`). Also I'm using the terms "exotic" and "ordinary" as the ECMAScript specification does, namely that exotic objects have some sort of deviation in their behavior (for arrays that is how properties are handled as they are special in using indexes).
 function search(pattern, text) { if (pattern[0] === "^") { return match(pattern.slice(1), text) } else { return match(".*" + pattern, text) } } Isn't it that ".*" here will be greedy and thus swallow everything by default? 1. It's quite a bit inefficient, it will always recurse through the whole string, going at the end, and backtracking it's way back. 2. If group matching is implemented, it will skew results. For example, `search("(a*)", "aaa")` will return empty string, because in `".*(a*)"`, the `.*` will have eaten all the a's already. I didn't try it, but I believe the non-greedy star matching can be implemented this way: function search(pattern, text) { if (pattern[0] === "^") { return match(pattern.slice(1), text) } else { return match(".*?" + pattern, text) } } function match(pattern, text) { if (pattern === "") { return true } else if (pattern === "$" &amp;&amp; text === "") { return true } else if (pattern[1] === "?") { return matchQuestion(pattern, text) } else if (pattern[1] === "*") { return pattern[2] === "?" ? matchStarNonGreedy(pattern, text) : matchStarGreedy(pattern, text); } else { return matchOne(pattern[0], text[0]) &amp;&amp; match(pattern.slice(1), text.slice(1)) } } function matchStarGreedy(pattern, text) { return (matchOne(pattern[0], text[0]) &amp;&amp; match(pattern, text.slice(1))) || match(pattern.slice(2), text); } function matchStarNonGreedy(pattern, text) { return match(pattern.slice(3), text) || (matchOne(pattern[0], text[0]) &amp;&amp; match(pattern, text.slice(1))); } 
I've been learning development for roughly two and a half years now. Here's how I get trough. **How I study** This tip may sound a bit unrelated but I think it's crucial imo. Learn how to google for stuff. When there's something you don't understand or there's a principle you are curious about, you need to know the right words to type into the search box in order to get the answer you need. If there is a term or an error in your way that's stopping you, look it up and only continue once you've written a full page on that term or error (a small page from a notebook is fine, no need for an essay). I recommend you look up what duckduckgo is and use that whenever there's a developing related thing you need answers to. Furthermore, look up tutorials on YouTube. Stay away from the Indian guys who go over the simple stuff in circles to stretch time and find the good stuff where the code, logic and principles are explained clearly. Don't be afraid to type code directly from what you see on the screen. But after you've done so and got it to work, go trough every line and write down on paper what the purpose of that line is. Programming is just one string in the wide web that is IT. You don't necessarily have to understand networking or hardware but understanding at least little bit about (non GUI)Linux, shell commands and how to navigate and use text-based operating systems can do a lot of good to understanding the logical mindset behind development. A lot of this may not make sense yet. But keep it in mind. Learning to code can leave you very clueless very easily. As long as you study hard and set realistic goals for yourself the dots should start to connect slowly but surely. You just need to keep yourself curious to do more research on programming. Document your work. As I've said twice before, have a notebook and pen beneath your keyboard. Write down notes and make technical sketches of what you're trying to do. There are certain standards in documentation of software but don't worry about it too much yet. Just make sure the sketches make sense to you. **Links to stuff you should check out** As for what the actual first step is, I guess html. That's where I started. [This is where I learned it.](https://www.html-5-tutorial.com) [There's also this half hour long video](https://youtu.be/fS7w-TXinPE) which I personally haven't watched, but I know the guy explains things excellently. Though I do recommend you take breaks if you're gonna watch the entire video (Which I you should definitely do if you wanna understand the basic backbone of web-development) And you should look at some more stuff of Eli the Computer Guy in general. Her explains a lot of very useful stuff in a clear way. tldr: Learn how search for good source material and examples. Write down everything you understand, don't understand or are looking into understanding until you don't need to go trough your old notes for a specific thing anymore. 
Try codementor.io
facebook is developer of React 
Huh that's an interesting find and I wasn't aware that was the case for Array.prototype. Searching around it looks like [many prototype objects for the built in constructor functions are instances of their type](https://stackoverflow.com/a/32929083/338923). I'm not totally surprised because before we had Object.create to create objects on the prototype chain of other objects: `Child.prototype = Object.create(Parent.prototype);` it wasn't uncommon to create an instance of an object to have an object that is on the prototype chain: `Child.prototype = new Parent();` You could also create a dummy constructor function setting it's prototype to the parent object and make a new instance of that, but just making an instance of the parent was a common pattern too. I still can't think of any significant reasons to preserve that characteristic other than not arbitrarily breaking someones workflow: https://xkcd.com/1172/
Your code is not waiting for onload() to finish, so the infoWindow happily uses whatever might be in contentString when it gets to that code. You need to make sure all the code after rdr.readAsDataURL() happens in the context of the onload() handler. You can do this with a callback or by moving all that code into the handler. For the flipped image, it's a good thing you're already reading the EXIF data. There's something in there called orientation that tells you how the software/camera thinks the image was oriented. Up to you might be upside down to the camer that took the picture. You need to read the orientation and apply it to the image data. This will mean rotating the image by 0, 90, 180 or 270 degrees. You can draw the image into a dynamically created hidden canvas element, rotate it and convert it back to a data url. Just be aware that if the image isn't square, rotating will require a bigger canvas so you don't accidentally crop the image. 
Thank you for that answer! I'll have to dig some more then. It appeared to me that most were not instances of their "parent" constructor and array was an exception. Perhaps that changed for some but not all between 5.1 and 6. Either way I really appreciate it!
For sure and thanks for the head scratcher of a question, always something new to learn about JS. I bet /u/rauschma would know if there was specific reasons why Array maintained that behavior for prototype into ES6 :)
If that's who I think it is I bet so! Love his books. If I sort it out I'll send you a pm too. I'm super excited to keep exploring haha, and it's always cool to see someone else who enjoys learning new things
Going to your website that is linked at the bottom, redirects me to [http://www.bridscloset.com/comptia/](http://www.bridscloset.com/comptia/) Dude, I say this with love. That website is hell. It looks like a Flash website circa 2003. If you're pushing yourself as an Angular/Gulp/Node/Bable/ES6 developer, have a personal website that uses said things. Your example work is a blob of jQuery and some XML documents that are tied to click events. The old school "mouse pointer on hover" animations don't do you any favors either. Current UI philosophy is focused on matte colors and simple, responsive geometry. [Example: bulma's website](https://bulma.io/). &gt; I feel that I'm a competent worker and I think I'm doing the right thing learning React and researching Vue So me a website you've built with React or Vue. At a glance, you seem like a Flash developer who's playing catch-up way too late. My words might very well be harsh, but I want to be constructive, if not very blunt. 
Thanks
Other then server hardening and a bit of net sec that's about it, also you're not required to learn mongo, you can use any server storage solution. You might also wanna take a look at nginx because (AFAIK) it's still better at serving static assets. If it were me i wouldn't bother about angular, it was the result of the MVC pattern being implemented front-end but 2 way data binding has been simplified somewhat with react and vueJS.
Seriously, custom elements aren't worth much without shadow dom slots
https://github.com/ecma-zz/GiphyR The design was built for Pearson I have no control over the design. I did all code from 2012-2013 This is more because most code I have after that time is code built for larger products. For example I can't link you to the HR control panel I worked on for ADP. I couldn't log into if I wanted to
Synchronous XHR has been deprecated for some time now. Don't depend on it to keep working. https://developers.google.com/web/updates/2012/01/Getting-Rid-of-Synchronous-XHRs
Or implement null propagation... This maybe stuff looks weird...
You should probably stop spamming this. We've seen it already.
You'd still return a promise if you use async/await. This kind of function should return a promise anyways. 
The file linked is definitely transpiled and located in src. It could be the only one, maybe it originates in a different project.
I think this file is a forked version of this one: https://github.com/maicki/why-did-you-update/blob/master/src/normalizeOptions.js But they copy and pasted over the transpiled version.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [maicki/why-did-you-update/.../**normalizeOptions.js** (master ‚Üí 312e466)](https://github.com/maicki/why-did-you-update/blob/312e4663d3930e45765430744edc3257eaa9e159/src/normalizeOptions.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqlkn0z.)^.
Regardless of committing the transpiled version, I'm wondering how Codesmith students come up with their ideas for projects? I think its super cool that new programmers are building useful dev tools. I am pretty shocked that people that are so new, already know what's useful to the ecosytem.
Your personal website should not be a client project. Are you linking directly to their site? If so, that's not great because a) you can't control the content and b) who's to say that site is still representative of what you worked on? If you're personally hosting the code you wrote for them, there may be legal implications as you typically don't own code you write on the job. Instead create a simple, reactive website (hosted wherever you choose) using some current design elements. Keep it basic - a blurb about yourself, some contact info, visual descriptions of past projects you want to showcase - and clean. Then, if you want to, build some sample projects and add links to them as well. This isn't to say that that will get you a job, but that's a good foundation for a personal brand website that can show off your skills even as you learn new tech by building small sample projects. Good luck!
But can they skip a build step? JSX and Vue templates will always need to be transformed.
React 16 is now more performant that Vue http://www.stefankrause.net/wp/?p=454 Personally I found React API much smaller and predictable than Vue‚Äôs. 
Yes I do! The regular formalism is all about the composition of sub-expressions. A third post on adding captures would also be nice.
[removed]
[removed]
this is not a portfolio site i just put it up there because i'm between hosts and i'm redoing my old one to be more professional. 
/u/JDeltaN is formally correct, Regular Expressions are supposed to represent regular grammars (see the second paragraph in the Wiki article), and the operators in regular grammars (like the `*` and `?` suffixes) can be applied to arbitrary sub-expressions. What is implemented here is closer to Lua patterns. Some RegExp engines go beyond the regular formalism and are able to match languages that are not regular. So while /u/zoner's project is interesting it doesn't implement (yet) a regular expressions matcher.
oh. Then python it is
D3 ftw &lt;3
Cool. Thanks for the info
https://www.reddit.com/r/javascript/comments/7gtlbc/mozilla_intent_to_ship_shadow_dom_v1/ :)
https://plopjs.com/ Plop is an awesome code generation tool and it has a nice name too :D
The link seems to be broken.
Just double checked, it's working for me - still having problems?
Only Vues single file components rely on webpack, templates can be processed runtime. [JSX is optional](https://reactjs.org/docs/react-without-jsx.html) but also can be [parsed runtime](https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html). Either way, Polymer is in the same boat. 
Indeed, vanilla components are a bit of a pain but can be quite powerful. I saw a interesting talk the other night about [GluonJs](https://github.com/ruphin/gluonjs) which does seem to make it easier to create components and be able to do proper constructors and injection.
Mostly, I guess, is for code trying to _sub-class_ or _extend_ `Array` in some form. You may be interested in [reading this](http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/), from kangax, which is strictly _pre-ES6_. So... what people arrived to, was that this... function List() { var p = new Array(); p.__proto__ = List.prototype; return p; } List.prototype = Object.create(Array.prototype); // Or before simply [] List.prototype.last = function() { return this[this.length-1]; }; ...generally works for extending `Array`. It adds `.last()` and still keeps all the index and `length` particularities working. But it does because you do set up `List.prototype` as an array `[]` (before `Object.create` was available) or, better, `Object.create(Array.prototype)`, and then create a _real_ `Array` and explicitly modify it's prototype chain through `__proto__`. (Some of the other solutions, such as Dean Edward's idea of getting a clean separate copy of `Array` from a different sandbox, may have also gained _some_ popularity at some point in time.) IIRC it's precisely this behavior the one that breaks if `Array.prototype` is _not_ an `Array` or `Array`-like object.
Wow this is incredible and exactly what I was looking for! I can't believe I didn't see it before either. It makes so much sense especially when you think of not having all of the ways to set up prototype chains we do today. Very very much appreciated!
&gt; modern modularized front end build tooling solves what custom-elements could potentially offer in a simpler manner than their proposed API Web Components aim to solve the framework interop problem. Things like React and Vue work perfectly fine on a page as long as they don't have to share the page with other alien components, frame works and libraries. When you have to mix and match different things from different frameworks and libraries then it all quickly goes to hell. For example, you are trying to integrate new React based functionality into an existing page which was originally done with JQuery and hand written CSS. There is a good chance that the existing CSS will stomp your new work or vise versa. Or even worse, event handling on the window object will interfere etc etc. Web Components give the tools to framework and library makers to make things which interop on the DOM/browser level because everyone has to speak and support DOM. The Web Components spec isn't for application developers to read and use. It is for framework and library devs to use. All those creature comforts which you see in React and Angular need to be added by framework and library devs later. 
Things like vDOM can be combined with Web Components and made easy to use by framework and library devs. As an application developer you are not expected to program on the raw Web Components API without some kind of help. 
I can't say that I understand the confusion about typescript. It is largely just a 'executable, self documenting contract' for your primitives and interfaces. It's pretty strait forward IMO if you have any concept of types. Also, I can understand the the trepidation about licensing for React, but JSX is notably confusing? It is mostly just html with self closing tags, some unique ids tags, and some common sense attribute renaming. I would think that refs, passing around handlers, and keeping the life cycle methods strait to be far more confusing. I'm sure Vue is great and all. And I don't want to imply that it isn't. I just don't buy those reasons to avoid react or angular. I know this sounds a bit dismissive, but I seriously don't understand why those are notable points of confusion, but learning Vue's convention based approach is not more so of a stumbling block.
JSON is basically just JS objects seriaslised to strings (with a few important differences of course). It's very important, but there is little to learn there, you can learn it all from a cheatsheet in an afternoon
Thank you so much. I wasnt aware of the community, i've already joined and everyone is very friendly and helpful.
Maybe i was looking at the wrong platform for this kind of querying. Thank you.
&gt; Should I send the whole JSON data every x secs/x mins? Isn't this very inefficient? Yes but it might be the best way to go if this is early development, following the traditional priority order: make it work, make it *right*, then make fast. &gt; Should I send the whole JSON data every x secs/x mins? There are a couple of obvious optimisations there: * If nothing has changed, send nothing apart form maybe a "nothnig has changed" message so the other end knows the client hasn't just turned off * If something has changed, try to just send that something. You could store a list of changes, send that, and have the server end replay those changes, but that could be more complex and in some cases (such as if the user has made many additions and then deleted them) could mean transferring more data instead of less (the might be desirable if you need to audit user actions or want to provide inter-session undo, but otherwise not). A simpler option would be to keep a copy of the previous JSON string, send a diff of that and the new string and the server then patches the two together. You have to be careful here to deal with errors that mean the server and client become out of sync (i.e. if a network glitch stops an update going through future patches will be invalid so the server should report back an OK status and the client not reset its reference copy if that response is not received). * May send nothing at all until a change is made. Though don't send an update on every user interaction as that woudl be inefficient too. One approach is a to send an update if there has been a change since the last update, unless there has been a change in the last X seconds (i.e. the user is still interacting), unless the oldest chgange not sent if over Y minutes old (so you do save user actions in progress if they are actively working working for a long time). &gt; to the server for storage If it is just for storage and simple reteival then the above is all find. If the data is less simpe and is going to be updated by several users potentially at the same time then you have a far more complicated situation as you need to deal with conflicts (what happens if two users save the same object at the same time?) and/or locking, and keeping clients in sync (if user A updates the object while user B has it loaded, do you update B automatically or wait for manual refresh?).
I actually just implemented a hangman game in Slack today! Here is my take on it: const showCurrentWord = (word, characters) =&gt; { const letters = word.split(''); const replacedLetters = letters.map(char =&gt; (char === ' ' || characters.includes(char.toLowerCase())) ? char : '_'); const lettersWithSpaces = replacedLetters.join(' '); return lettersWithSpaces.substring(0, lettersWithSpaces.length - 1); }; If you pass in `("Dubai", ["a", "i"])` it will return `_ _ _ a i`. It will respect spaces.
Build a regex engine ... using a regex engine? It went ... okay.
Do you know good vuejs template with typescript support?
&gt; But how would web components help that console renderer to animate for instance? Oh sorry, I didn't pay enough attention - console rendering is not a problem that web components solve. Nor is e.g. native rendering a la React Native. All that web components were intended to solve was being able to use a full-featured (i.e. also caring about accessibility and the likes) date picker regardless of the other tools you are using, just like you can use a `&lt;select&gt;`. &gt; But this is exactly what web components don't solve. Loading 10 components, in the worst case, will fetch 10 frameworks. The spec is a sealed blackbox, internals rely on a framework, like Polymer - which is and was the worst offender actually when it comes to api stability and breaking changes. Yes! That is why I don't like Polymer for anything other than being able to test the ideas behind web components before they are fully implemented. The idea is that you're not going to include Angular, React or whatever with your component, because it's that small and it should not be needed. Releasing a web component should be like distributing a library, where you pay attention to its size as well. So a date picker might choose to use moment.js, but as its size would then skyrocket it would probably help adoption if it only used those parts that it needed. I'm not quite sure what you mean by a sealed blackbox? You can implement web components without Polymer (although this will only be an attractive proposition once browser support is widespread). And sure, you could argue that the API is over-engineered or overly complex, and I might agree with you on that, but the problem it solves isn't solved yet, and JSX solves a lot of other problems (and does so right now) that web components do not solve.
It‚Äôs a stupid example, really. jQuery sucks. A CSS equivalent might be: #right-well &gt; * { color: orange } That is assuming jQuery‚Äôs children method only selects immediate children of an element.
Some people, when confronted with a problem, think ‚ÄúI know, I'll use regular expressions.‚Äù Now they have two problems.
I love to use middleware for analytics - something the application shouldn‚Äôt know about elsewhere but needs to know about every action. This article summed it up well. I like to think of middleware as a plug-in-system for my app.
In my opinion the biggest advantage of React over Angular is JSX. Logic in templates is not the best thing because you don't get any JS or TypeScript validation at compile time or autocomplete in the editor. Plus you have to learn the "let i in items" (or was it "of items"?) DSL which feels like a trick and it's not necessary once you write everything in javascript. The other advantage of JSX over templates is that it's easier to compose components (for example, to make a component customizable). In Angular, you have ng-container and ng-content and named slots (the old "transclusion"). But these are solutions to the problem of working with templates. If you use JSX, you don't have that problem in the first place. You can simply pass a rendering function to the child component. So based on the child component's model, you pass it one function or another and bam, you have a customizable component. So React is easier in designing the view thanks to JSX. Angular is easier than React in most other things, but primarily the choice of stack and the cli. The cli in particular is a selling point for me, I really appreciate the time it saves me.
That‚Äôs a great use-case! Have you ever checked out logRocket? It would be awesome to correlate some of that data you gather to what‚Äôs actually happening in the browser
[removed]
&gt;Yes but it might be the best way to go if this is early development, following the traditional priority order: make it work, make it right, then make fast. My app works. I am probably in the "make it right" phase. Right now, I am sending the full JSON every 2 mins automatically and have an option where the user can manually save also. &gt;One approach is a to send an update if there has been a change since the last update, unless there has been a change in the last X seconds (i.e. the user is still interacting), unless the oldest chgange not sent if over Y minutes old (so you do save user actions in progress if they are actively working working for a long time). This would probably be a better approach than just sending full JSON every x mins. So, for this I would need to have something like a global var which is set to true on any possible user interation and reset it when saving? ofcourse, waiting/adding an intreval would be the next step. My worries are since I am still a noob in JS and basically everything in web dev, after reading threads like [this](https://www.reddit.com/r/programming/comments/55okik/how_it_feels_to_learn_javascript_in_2016_xpost/), I am wondering if there a framework that does what I am trying to do, and if there is, I really don't want to reinvent the wheel and waste time. &gt;data is less simpe and is going to be updated by several users potentially at the same time This would be in the near future after I have 100% working functions like proper autosave and undo/redo. I would probably need to look at tools like Firebase (real time db?) for real time collaboration, right? 
Interesting 
&gt; The Web Components spec isn't for application developers to read and use Sure it is. I work full time developing web apps in Polymer. It's components all the way down. I know other devs who develop apps using vanilla web components with no framework. NO FRAMEWORK.
nobody outside google liked html imports personally I'm gonna miss them
Why would anyone want to do this? I'm sure I'd be able to break this because manually emulating regex is just retarded.
Interesting stuff!
shady dom works remarkably well. 
nothing like that It's creating custom HTML elements, eg. `&lt;my-element&gt;Hello, world&lt;/my-element&gt;`
Depends how you use them Custom elements alone don't really affect SEO A single page app built with Shadow DOM could present some challanges; google crawler should read it OK though
Thanks! I‚Äôve written about this phenomenon (e.g., `Function.prototype()` is a function and can be called): http://2ality.com/2013/01/categorizing-values.html But I don‚Äôt know why it was done this way. Possibly (and not entirely correctly) inspired by the Self language. I‚Äôve asked on Twitter and will report back.
Yeah this was actually fairly thorough and well written.
Maybe I was being too blunt and imprecise here. As an application developer you will be able to use the Web Component stuff and understanding how it works is useful, but the expectation is that you will use indirectly via a much more friendly framework or library in between. Polymer does exactly this. It provides convenient ways of doing WC stuff. Yes you can directly code on those APIs, I have done that too and only in the last two weeks in my app I've been removing the boilerplate code and introducing TypeScript decorators to make it easier and cleaner to use. 
Wow. It opened my eyes!
I'm not at all convinced about the performance bit. The article says, hardware is getting better. We have more memory. Sure but Electron keeps the CPU busy too. That means more heat, more fan noise, and less battery life. I have a budget gaming laptop and even I use sublime on the laptop rather than VSCode because the hdd is 5400rpm and it takes an eternity to launch. If my options are buying an SSD so I can run a text editor smoothly or choosing more efficient software, the choice is clear. The big advantage of PWA over native is no installation. That's not the case for desktop apps, in fact it's the other way around. I'd rather see PWAs on desktop rather than Electron-type bundles. Overall it just sounds like we're telling people, please install this software which is slower, takes longer to launch, consumes more resources, and drains your battery faster, because it's more comfortable for **us**.
You *need* the stack that does the job for you. So, just *wanting* to switch stacks without a valid reason is not ok. What is it that you think nodejs can solve that you can't do using php? Then learn that. Why switch everything? Why not start using angular front-end and php backend? You will get some experience using JavaScript that you will need before you dive into Node. Does Mongo solve a problem that you can't solve with the database you currently solve? In that case use mongo with PHP. Dont switch anything just because... 
sounds pretty good, thanks for the info
Oh c'mon, you have to mention Angular if you're going to mention React.
As a React Dev that's been learning Vue for the past few weeks.. Only thing I've enjoyed about Vue are that the built-in helpers: computed methods/watchers are awesome... The templating system is alright, but I feel that JSX/ES6 is way more intuitive and cleaner. On the other hand, I do like how optimized Vue is out of the box compared to React (don't have to baby sit dirty marked components and such). I can see how this would be a great framework to migrate or learn as a new beginner. I don't regret my decision on learning it, but will probably be using JSX with it on my future projects. In the end, I feel like I do develop faster with Vue.. but not by much. IMO-the explicitness required by React makes me write much clearer code. 
&gt; Overall it just sounds like we're telling people, please install this software which is slower, takes longer to launch, consumes more resources, and drains your battery faster, because it's better for us. But people are using these apps because there are no alternative that companies can justify the cost of, there would simply be less apps meaning teams wouldn't have incentive to innovate and race to implement new features/experiences. This is simply the "free market" adjusting itself, not enough regular people, if any, are complaining about this, *so its good* **enough**. If we try to write all software to some heaven like standard we'd all be writing assembly and users would have a choice of 1 browser, 1 editor, 1 music play..etc.
I also ran into issues with matchStar being overly greedy with my original implementation. I added a test specifically to help me to figure it out. I took a peek at your new matchStarNonGreedy and was intrigued, ran it against my test suite, and started playing around with new tests. `search("^this* i*s t", "thissss s")` this passes `search("^this* i*s t", "thissss s t")`I can't get this one here to pass `search("^this* i*s ", "thissss s ")` and this one passes even more bizarrely. My initial guess is it would fail seeing as the previous one failed 
You seem like you know and understand this a lot more than I do, but isn't quite a large advantage (and selling point) of Electron-type applications the fact it can interact directly with the file system?
From my understanding, `IIFEs` are resolved at run-time. The compiler will make sure that you don't have any syntax errors but it won't resolve it into a value until the worker gets to that point in the code ( at `run time` )
That's an absolutely fantastic article (and also has some unrelated stuff I would have loved to have read when I was just starting out too, like prototype vs [[prototype]] since I feel strongly that many beginner resources don't address this properly). Another poster found [this article](http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/) and had a neat comment about it as an example of pre-ES5 code that might need Array.prototype to be an array in order to subclass it effectively, so seeing that I can see how if an inheritance pattern required it it is good to keep that one for backwards compatibility. Still no clue about function though, and super excited to see what you might dig up.
I have tried to use this one https://github.com/Microsoft/TypeScript-Vue-Starter But I didn't like `Typescript` very much.
Im soon finished with my masters in CS, but I honestly learned the most from solving challenges at codewars.com. You have to complete a problem before viewing others solutions, which means you are forced to understand a problem and solve it. Then you can compare your solution with the most upvoted ones and see what you can improve on. They also seperate between clever and best practice solutions. Only problem is that I'm now tempted to codegolf everyything..
What's the purpose you say? Elitist? Anyone who criticises shitty work is elitist nowadays?? Dude, did you even fucking read? That "regex" engine uses regex, not like I fucking expected a real thing in 40 lines of code, but if we are talking about "BUILD" something, then I expect to fucking BUILD it from *SCRATCH*, not just use another engine, because that's just literally a fucking wrapper and has nothing to do with regex engine itself.
So how does it actually connected to any scope other than the global? what happens in the run time when it gets to an IIFE? 
&gt; what happens in the run time when it gets to an IIFE From my understanding, the same thing that happens when the worker sees `if(x &gt; 5)`. It _resolves_ the value `(x &gt; 5)` into a single value. Does `x` have to be in the `global` scope? No. It just has to be in the scope of the block it is currently running in. When we write the following const x = (() =&gt; return 5)() we are telling our worker that we want to set the value of this box called `x` to be the result of calling some value, defined inside of the first `(...)`. Let's do this another way const return5 = () =&gt; 5 const x = return5() The worker has this function that is `() =&gt; 5` and it calls that and sets the returned value to be called `x`. When we run an `IIFE`, it is doing the same thing ( calling some function ) except the function is defined right when it is called, instead of above it.
It's more than likely that the front end timer is reflected by another on the back end so that people can't do exactly what you're trying to do.
I am also unable to open the link. I‚Äôm on mobile (Apollo app) if that makes a difference
We use Redux for overall app state, and Mobx on individual features / components where it makes sense. Don't discount a combo of the two. Works awesome.
So basically learn how to use regex and not how it works, nice.
So with IIFE it does the same thing except the need to declare a variable that points to that function? the compiler doesn't play any role here? So how do variables inside an IIFE are declared?
&gt; I know there's a good chance that there's a server side timeout as well, and that this isn't a perfect solution, but I'd still like to try it. 
You should search the js for a redirect
What does it do?
Combination of class based programing, modular pattern and some functional programming FOR ME was the way to go. 
Let's take a step away from `IIFEs` and understand what `(x &gt; 5)` means to the worker. When we write `(x &gt; 5)` in the console, our worker goes 'Okay, they want me to make everything between `(` and `)` into a _single value_'. The worker knows that we want it to _resolve_ `(x &gt; 5)` into a value. In order to do its job, the worker has to do whatever work is described between the parentheses. So in our example: const x = 6 const isGreaterThan5 = (x &gt; 5) console.log(isGreaterThan5) will print `true` because the worker _resolved_ `(x &gt; 5)` into the value `true`. So now that we know that the worker turns things inside of `()` into a value, let's look at how functions work: const x = 5 const fn = () =&gt; { const x = 4 console.log(x) // 4 } fn() console.log(x) // 5 Our worker can keep track of scope/variables inside and outside of a function. It also knows that a function, called _fn_ above, is _a value_. We know that it is a value because we _assign_ the box `fn` the value `() =&gt; {...}`. So. Taking those two things, let's go back to `IIFEs`. We know that when the worker sees `(....)` wrapping _something_ that it needs to resolve that _something_ into a single value. Knowing that, what is the _value_ of the below? (() =&gt; console.log('hello!')) What _value_ does the worker _resolve_ the above into?
A function. But what it does in case you have variables declaration inside?
The same thing that happens in the `fn` example above. Since it is a function, all the same rules appy.
But it's the compiler role to declare variables and functions. when the worker gets to (function(){var a = 2}) it wants to evaluate the value of a at some point, but "a" was not declared in the compilation phase.
This seems to be a misunderstanding on how functions work instead of how `IIFEs` work. Look into functional/block scoping to understand why `a` is not evaluated until you run the function.
One react tip every day until december 24.
My biggest eye opener was redux. Before redux state in my mind was some minor factor that crops up here and there, that's being driven by some controller types. But state is what makes applications a mess. With redux state becomes the single most important aspect of the application, everything else turns into simple pure functions and reactions. That forces you to think about the structure first, then fill it with life. Once the state model is laid out, advancing forward with views, UI's, etc., is very easy, because it doesn't contain much complexity any longer.
Really great article.
If you can do this, it's time to buy new software.
I know how functions work, you probably didn't understand me or don't know what you're talking about. Function local variables are declared in the compilation phase. When the function I mentioned above is invoked, the engine search for the variable "a" to assign or retrieve its value, but the compiler didn't declare it, because we said IIFEs are resolved at the run-time.
From my understanding of the [spec](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-function-definitions), it seems you are mistaken about how functions work.
Polymer won't be reliant on WebPack any specific bundler at all. Polymer 3.0 is distributed as standard JS modules which don't have to be bundled to work natively, and since they're just standard modules, they can be bundled with any bundler that supports them - which should be all of them.
JS modules should definitely not be bundled before distribution. Modules should be published to npm as plain ES2017 and only bundled and compiled at the application level. Polymer's tools will not encourage bundling elements before distribution.
What do you see there that I don't?. I didn't learn es6/2017, I know only es5.
Non-standard transformations should happen at compile time of the component, before distributing the component as standard ES2017. Then downstream users of your component don't need to use the components choice of tooling.
You got me asking myself the question, "how can I break this". So I set out the verify the correctness of my program. I wrote a fuzzer which essentially generates random regular expressions that conform to my engine's grammar. I then asserted that the RegExp implementation returns the same result as my implementation. After running a couple million patterns against a section of Gulliver's Travels, I learned two things: - My implementation fails extraordinarily with longer texts. I knew recursion would be a problem for any practical implementation (at least without tail calls) and would cause stack overflows, but I didn't expect it to fail with texts that were only a couple thousand words. - My implementation treats the '.' character differently. In the RegExp implementation, '.' will not match various line terminators (\n, \r, \u2028 or \u2029). My implementation does.
Polymer does provide some conveniences, like templating and two-way data-binding, but it's still just web components. The lifecycle, underlying API, use of shadow DOM, etc are all standard. Polymer is quite literally just a subclass of HTMLElement that you extend, so you can both directly code to the Web Components APIs _and_ use Polymer conveniences at the same time.
&gt; custom elements, which is an evolution of WC Custom Elements are a part of the Web Components standards, along with Shadow DOM, `&lt;template&gt;` and the now defunct HTML Imports, which may rise again as HTML Modules.
Yeah, if you want to build someone else's idea that's fine, but let that wait until you're employed. For now, you'll get much more out of the experience if you come up with the idea.
I wish I had found this sooner! I saw the medium post https://medium.com/@samdbeckham/i-have-no-idea-what-im-doing-fbe0ba9362ca that brought me here.. (the slack invite is expired...) are you guys going to do this again (or similar?)
I luckily have ran headless servers and messed around with Linux. That‚Äôs for the tips!
I'm not sure what you understand by "run-time" and "compilation-time", but leaving that aside... Imagine you have this code... // some unimportant code here... 3 + 4 &lt; 5; // more unimportant code here... When the JS interpreter reads that it has to "resolve the expression", that is, execute it and produce a value. In this case, it is very simple. It reads `3 + 4 &lt; 5`, parses it, evaluates the parts applies the operators in the correct order and finally produces `false`. As that value is not _used_, well, it's discarded. But the important thing is that "the expression has been evaluated". Now, an expression can take several forms (or, it you prefer, there are several things that are expressions). A function call, for example, is an expression. So... if the interpreter sees... f(); ...then it knows that expression needs to be solved and the way to solve it is to call `f`. Actually, in general, expressions are made up from sub-expressions, and you could see that `f()` as an expression that is composed by: - sub-expression `f`, supposed to be a function (or a "callable object" to be more precise) - the execution operator `()`. Again, JS applies the rules for solving expressions and says "ok, I have the reference to `f` and now I call the execution operator on it". Another step. Now say we have... 3 &amp;&amp; (f() &lt; 5); I'm not going to explain this in detail, as I'm sure you get it. JS decomposes into subexpressions, one of which means executing `f`, applies the rules, etc, produces a value. Very similar would be this one: 3 &amp;&amp; (5, f(), 4); But let's go one step beyond: 3 &amp;&amp; (a = function() { return 4; }, a() &lt; 5); What is happening here is that in one sub-expression we create a function, and in another we call it. Nothing really too strange, isn't it? What are the scoping rules that apply to that function? Well, they are the same rules that apply to creating any function... var x = 1; 3 &amp;&amp; (a = function() { console.log(x); // yes, 1, sure. var y = 1; return 4; }, a() &lt; 5); console.log(y); // nope, y is only in that function's scope. You know, nothing special. It gets its own scope, it can access enclosing scopes, enclosing scopes cannot access down into its scope. as with any function. Now, an IIFE is mostly the same ( function() { return 4; } )(); It's an expression with 2 sub-expressions, the first one is an expression that evaluates to a function, a callable object, the second expression is just applying the execution operator to that. So, again, there are no special rules on scoping: var x = 1; (function() { console.log(x); // yes, 1, sure. var y = 1; return 4; })(); console.log(y); // nope, y is only in that function's scope. It gets its own scope, it can access enclosing scopes, enclosing scopes cannot access down into its scope. as with any function. ---- Regarding _local variables_. Forget about IIFEs for a moment. function f() { var a = 3; console.log(a); return 4; } Right now, if you execute that code, what happens is `f`, the function, gets created. Nothing more. `a` does **not** exist yet at all. Then you do... f(); Now, **while `f` is executing** a certain `a` will be created in the scope of `f`. As soon as `f`'s execution ends (and leaving aside any "closure related questions", that execution scope will be discarded. Is you... f(); ...call `f` again, **during this new execution** a new _different_ scope will be created, a new _different_ `a` will be created in that scope. The execution will end and the scope will be discarded. This happens on each call. ---- I don't mean this in a bad way, but this type of question is probably more appropriate in r/LearnJavascript :)
Webpack is optional for 2.0, and I believe even 3.0 webpack will be optional. Also, Webpack is optional for custom elements in general - only a framework can require it.
&gt; You can implement web components without Polymer (although this will only be an attractive proposition once browser support is widespread). I don't follow this - you can add a web components polyfill without Polymer.
In JavaScript, there isn't a way to make an object a function. You either have an object, or you have a function that is also an object. Functions are special objects that are marked internally as being "callable", as in they have some additional behavior that is invoked when called with `(...)` following the function's identifier. This callable property is not a property you can set, rather something defined in the deeper, hidden internals of the JavaScript runtime that happens when you create a function using whatever syntax you choose to do so (... which includes more than what you've listed, particularly moving into ES6+). Using `Object.create(Function.prototype)`, for example, creates a normal, non-callable object that happens to grab some inherited Function object behaviors. However it is not able to be called like a function so most of what is inherited ends up not being able to work. The term "hidden property" means basically what it sounds like - some property on an object that is hidden and usually inaccessible from JavaScript. These are also known as "internal slots". They are used internally by JavaScript to make things work correctly, but are not important to users of JavaScript so much so they're not exposed to every day users like you and me. Some of them can be seen in the debugger panel where you can inspect them and see their values, but in code, they're not available for you to either see nor manipulate. For example running this in Chrome: console.dir(function(){}.bind(this)) You'll see internal slot values like `[[BoundThis]]` which represents the function's explicitly bound context. The `[[]]` syntax is used to represent internal slots that exist but you're not able to access. You normally don't have to worry about them being there, but they can be useful in debugging.
Polymer 2 is dead, once again. Polymer 3 will rely on Webpack due it switching to es-modules. There is about no difference, no framework needs or demands webpack. They all are better off for the same reasons: es-next, modules and bundling in general. 
When you use Polymer, you will obviously use a bundler. Or not. Same as with any other framework. 
I use it in at work in a Vue app, for animations that are too complex for Vue transitions 
This is getting crazy now. Webpack, browserify, brunch, what do i care. You need it or else you're building for chrome only. The only reason i posted at all was because the guy said Polymer, somehow, makes feeding stuff to the browser easier, no bundling, etc. That just isn't the case.
Leaving this here for reference. Interesting article doesn't mention interpreter once. https://www.sitepoint.com/javascript-performance-optimization-tips-an-overview/
And maybe check out Apollo.js as a modern way of handling data with graphql 
&gt; Right now, if you execute that code, what happens is f, the function, gets created. Nothing more. a does not exist yet at all. This is not what Simpson claims in his book. JS is a compiled language. as such, when you execute the code it is compiled before it runs. So all the declarations are handled by a compiler, assignments and such happen on execution by the engine. When the engine executes your invoked function, "a" is already declared. In an IIFE case, the compiler pass over the IIFE because it is an expression so it won't declare any of its variables. 
Wow I don't know what's worse: the factual errors or the writing style. 2 way binding? It's not even really in Angular. There's pseudo 2 way but no one is really suggesting you use it. 1 way binding is the default. And sure you want to be mad that Google reused the angular name? Go ahead. It was a poor marketing decision. But a complaint about v4 coming out? The library is on semver. It's just a number. React 16 just came out! Omgwtf! Immutable state? Feel free to use it in angular. Redux? Ng-redux and ngrx have you covered. Html in Javascript? React doesn't have that either but you can declare the Html inside the same file as the component if you want. Use template instead of templateUrl. Jsx is nice though. That's about the only valid argument in this article against angular. But this is still a low quality article. Angular isn't perfect by any means. But it would be nice to see an article that actually wants to discuss actual issues and pain points with it rather than this sort of tripe.
I'm wondering if anyone has any suggested books for design patterns in light of ES6.
Yes, you can also build applications that use native browser features, like notifications, menus and toolbars. You also have access to the entire Node ecosystem through NPM.
Wow, I don't know what's worth: that you couldn't tell that the OP article was tongue-in--cheek, or that you're as invested in your software framework as most people are in your religion, and thus instantly had to jump in and defend it against such vicious attacks as: &gt;After all we‚Äôve been through? Wasn‚Äôt changing everything about our life together in version 2 enough for you? You‚Äôre the reason I have trust issues. Now we‚Äôre not even allowed to talk about Angular version 1. I have to call it AngularJS. You just have to control everything don‚Äôt you! Fine, you win. You can have your whitewashed history.After all we‚Äôve been through? Wasn‚Äôt changing everything about our life together in version 2 enough for you? You‚Äôre the reason I have trust issues. Now we‚Äôre not even allowed to talk about Angular version 1. I have to call it AngularJS. You just have to control everything don‚Äôt you! Fine, you win. You can have your whitewashed history.
 function fib(n){ if(n &lt;= 0){ return 1; } else{ return n * fib(n-1); } } try this
I'm glad you grasped the tongue-in-cheek, just an opinion on a framework which is being untilized less and less - everyone's entilted. It won't be long until people are speaking similarly of React!
I'm just sitting here with C# and ASP and wondering why no one uses it. Oh right, Microsoft. But it's got the horsepower. 
It's a classic exercise for practicing recursion, but a regular loop would be a much better way to do this. The secret ingredient for doing it in a loop is the `*=` operator: &gt; var x = 2 undefined &gt; x *= 7 // same as x = x * 7 14 &gt; x 14 Try doing it yourself. Try using this skeleton: function factorial(n) { // magic here } console.assert(factorial(0) === 1, '0! should be 1'); console.assert(factorial(1) === 1, '1! should be 1'); console.assert(factorial(5) === 120, '5! should be 120'); Once all assertions are true, you won't get any "assertion failed" messages in the console. Using assertions is the most basic way to do something which resembles test-driven development. By the way, it's always a good idea to show us the code. Secondly, /r/learnjavascript would be more suitable for this topic.
Hi /u/reeferd, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Criticism doesn't make someone elitiest, attitude does. Come back in a few weeks when you're emotionally removed from this and re-read your response to mine. You're offering nothing but vitriole, using phrases like "shitty work," "garbage," "pathetic," and calling the author pathetic because you disagree with the scope of what the article covers.
Seriously? The article attempts to raise issues with angular and it's not factually accurate. End of discussion. I explicitly said angular isn't perfect and would even like to discuss it's flaws. I've used plenty of different frameworks and they all have strengths and weaknesses. This article is just another pointless angular bash that's not rooted in reality. You want me to bash angular? Change detection is stupid and they should have forced developers to actually directly use rxjs by forcing the use of the async pipe, or something similar, which is roughly analogous to setState in react. The init life cycle methods after ngOnInit are poorly thought out since you can't actually change state during them but the view and content aren't ready for reading yet during ngOnInit. It's workable once you figure it out but it's poorly communicated by the angular team on how to change stuff during init without ugly hacks like using set timeout. Rxjs is amazing but the angular developers go to great lengths to hide it from angular devs so they aren't forced to use it. This probably means more developers can use the happy path in angular but it causes a lot of problems when stuff *should* just be done with rxjs but instead angular has to supply some sort of bandaid. Pipes are a good example of this. 0 real reason to exist when observables literally do the same thing. Forms are... not great. I do think angulars forms are usable and overall about as good as any other forms implementation I've seen but they are still not a good experience. Regular forms are fine for really basic use cases but as soon as forms start to grow in complexity they become pretty unmanageable. Reactive forms work better but a lot of the syntax is awkward and while you can make it work they don't play very nicely with state management libraries like ngrx even though they internally use observables. Those are the kinds of issues angular actually has and would be worth discussion. Not the junk in this article. It's not a matter of being personally invested. It's a matter of knowing *something* about what you're writing. Otherwise you get to read about stuff like "lol can you believe Javascript? 0.1 + 0.2 = 0.300000004! Lol Javascript can't even math". Dressing up problems with a language or framework or whatever in a funny breakup letter doesn't make the points raised more valid.
He's partially correct, but only correct in regards to specific specifications of regexs. I will grant that, for all intents and purposes, the article does not match a modern regex language; however, it does match the very basic definition of implementing a search pattern, and is about the same as the original grep tool, when regex's were becoming more widely used.
My problem turned out to be that I was returning the wrong value!
&gt; only the one who actually read YDKJS will be qualified to answer this question. Get over yourself.
&gt; only the one who actually read YDKJS will be qualified to answer this question. Well, if that's how you think, you could probably write directly to Kyle Simpson and ask Him. He's on Twitter, both as [@getify](https://twitter.com/getify) and as [@ydkjs](https://twitter.com/ydkjs), He's also on Medium as [@getify](https://medium.com/@getify), you can, maybe, open an issue asking for clarification at His Github [YDKJS repo](https://github.com/getify/You-Dont-Know-JS) and His email address is getify@gmail.com, as per His Github profile. :)
I have a custom altcoin GUI trading bot needs testing. I created it because I wanted more options for buying and selling than what Bittrex currently offers. I wanted to be able to set both stop loss and take profit conditional orders at the same time. As of now you can only set one or the other. My bot will buy at desired price and set a stop loss and a take profit trigger at specified targets. Plus it has a trailing stop to get more profits when coins keep pumping. If anybody is interested in giving feedback and getting a copy message me.
It covers nothing "X in less than y lines of code" can never cover anything simply because it focuses on minimising already existing thing (and the result isn't even usable in real world, just another brainless garbage) for no reason without explaining much. Yes, I am sorry of disagreeing with **nonexistent** scopes.
I would use this plugin to control which file(s) are loaded https://www.npmjs.com/package/module-mapping-webpack-plugin
Oh! Sorry.
According to Kyle Simpson: "The first thing Compiler will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree. But when Compiler gets to code-generation, it will treat this program somewhat differently than perhaps assumed. A reasonable assumption would be that Compiler will produce code that could be summed up by this pseudo-code: "Allocate memory for a variable, label it a, then stick the value 2 into that variable." Unfortunately, that's not quite accurate. Compiler will instead proceed as: Encountering var a, Compiler asks Scope to see if a variable a already exists for that particular scope collection. If so, Compiler ignores this declaration and moves on. Otherwise, Compiler asks Scope to declare a new variable called a for that scope collection. Compiler then produces code for Engine to later execute, to handle the a = 2 assignment. The code Engine runs will first ask Scope if there is a variable called a accessible in the current scope collection. If so, Engine uses that variable. If not, Engine looks elsewhere (see nested Scope section below). If Engine eventually finds a variable, it assigns the value 2 to it. If not, Engine will raise its hand and yell out an error! To summarize: two distinct actions are taken for a variable assignment: First, Compiler declares a variable (if not previously declared in the current scope), and second, when executing, Engine looks up the variable in Scope and assigns to it, if found." Now I will clarify my question: what happens when the compiler gets to an IIFE? As you can read, Kyle claims that the compiler responsible for declarations, and IIFE is an expression.
I assume you have the functions as anonymous and inline. I would pull them out. Then you can call either whenever you want -- just watch out for `this`. function changeInnerHtml() { /* stuff */ } function changeNumberInput() { /* stuff */ } function both(){ changeNumberInput() changeInnerHtml() } numberInput.addEventListener('change', changeInnerHtml) dropDown.addEventListener('change', both)
I like https://www.amazon.ca/Node-Js-Design-Patterns-Mario-Casciaro/dp/1785885588
... that's a factorial function
The link works fine for me in Chrome on desktop, maybe try this which is the direct link to the post: https://groups.google.com/d/msg/mozilla.dev.platform/aJvUlADn-Hk/BYB52MgDBQAJ
The link works fine for me in Chrome on desktop, maybe try this which is the direct link to the post: https://groups.google.com/d/msg/mozilla.dev.platform/aJvUlADn-Hk/BYB52MgDBQAJ
Thank you, sir! That's what I was looking for! You seem to know a thing or two about JS :p hope I get there as well :)
Right? It takes some serious getting used to. I had an opportunity with Swift to learn about it. It‚Äôs called options in that language. But the idea is the same. Instead of null, you‚Äôd have a Maybe that might have a value or be nothing. Forcing you to make those safety checks. Once it clicks, it‚Äôs hard to go back to a language that does not implement it. 
Thanks, it is working! Simple solution, I guess I was just hoping it would be more intelligent.
&gt; just an opinion on a framework which is being untilized less and less ?
Hi /u/chaseg22, you might want to check out /r/LearnJavascript too. In regards to what you're seeing in the bottom, nothing is "not working". You are still in your editor.
hello, thank you i will post there. i run my editor (brackets) but alert wont pop up on my site when i run it.
Have you referenced the JavaScript file in your HTML? Are they located the same place? There could potentially be many things wrong just by the defaults of this.
You need to replace /path/to/script with the actual path to your script. I can't see for sure but it looks like ./script.js
Is this ceremony really needed just to set the focus? Shouldn't a simple [html5 `autofocus`](https://www.w3schools.com/tags/att_input_autofocus.asp) be enough? &lt;form action="/names"&gt; Name: &lt;input type="text" name="fname" autofocus&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/form&gt; 
tl;dr .map() and .reduce()
yes my javascript file is in my HTML body 
Pass a function as an argument to the function or call the function using brackets ExampleFunctionObject[name](); If I am understanding you correctly
Sorry! I didn't yet get to use a web framework such as angular, react or even bootstrap, I've always coded using plain languages (html,css,javascript,php...) even though I hear about them a loooooooot, this is why I want to ask you some questions: When it is necessary to use such frameworks?? How easy it is to work with them? and which dbms can you pair with any of them? Thanks in advance.
&gt; The big advantage of PWA over native is no installation. That's not the case for desktop apps, in fact it's the other way around. Unless performance improves to get at least somewhat close to native, I'd rather just see PWAs on desktop rather than Electron-type bundles. mak One of the main usecases of electron isn't to make a highly performant application. It's simply to have a single code base which runs everywhere and feels native to the users. I can write a PWA and then with minimal effort create desktop applications which use the same code but allow me to do things like notifications, file accociations, and interface with systems that the web can't.
I use React for JavaScript that's too complex for Vue /troll
`/path/to/script` is a placeholder likely from a tutorial... you need to put a real value here.
great!! you made it really easy to understand üëçüëç
Very nice
http://www.davidarchymensunderwear.com/ 
woops, wrong link! https://join.slack.com/t/eloquentjs/shared_invite/enQtMjgwNTE0ODEwMzA3LTc4ZDljNjFkMTE3YjgzYjdhOTFjNzgyNmRhZWUyYjk1NzI5MmE1NDlhOTdmZmJjMTMyNGI2MjcwMmQzYzc1ODc 
interesting......
Thanks! =)
correct i did grab it from a tutorial but i erased /path/to/script and just put &lt;script src="script.js"&gt;&lt;/script&gt; and it still wont work. i know its probably something so simple but i cant figure it out haha.
Old topic, but for what it's worth, Google intends to go down on malicious advertising and dark patterns. Early next year, Chrome will start shipping with an ad blocker that will target ads that break [the Coalition For Better Ads' standards](https://www.betterads.org/standards/).
what else did he ask for 
üôÑ
You can distribute desktop applications as binaries with no installation required ...
Wow you missed the whole point of the article. Autofocus attribute only works on page load.
Looks good.
I see your files have the unsaved circles next to them.. Sounds silly but make sure the files are all saved before running.. Assuming you changed you src path to src="script.js"
it works !!! wow just as simple as saving. Thank you and everyone for your time . again sorry for the newbie question. cheers!
How would you implement `.map()` using FP?
you named it `fib` (fibonacci) instead of `fac` or `factorial`
And to add to what charlesc321 said you can freely add the autofocus attribute to the html and it will work as expected. This directive goes beyond that.
-1 *coerces* to true in a boolean context (i.e. it's truthy), but that doesn't mean that it *equals* true. The same applies to numerous other values, like an empty array.
because it's broken. make sure you code defensively, as in, explicitly enter boolean statement within the brackets. 
oh yeah i guess sorry i have brain damage
Hey, I think we've all been there before. That's happened to me many times. Saving your files after every single change will be second nature to you pretty soon haha
Would you say that the patterns in this book would apply to front end work as well? I mean I know front end frameworks force certain patterns on you but it seems like there'd still be room for leveraging some design patterns. I mean, I guess as someone who is fairly new to design patterns, the Head First book would be as applicable as anything.
haha np. Now you just have to adjust the name inside the function. It still says `fib` :P
Because once upon a time, C defined the number 0 as being "false-ish", and everything else as "true-ish", and far too many programming language designers felt that was a good idea.
&gt; If my options are buying an SSD or installing more efficient software That's crazy. I would never go back to HDD. If you actually care about power consumption don't use an HDD.
&gt; Would you say that the patterns in this book would apply to front end work as well? Yes, I'm using the command pattern as outlined in this book, and a "service locator" type construct to avoid a massive `if-else` chain. It's honestly one of the better books I've read. I highly recommend it and would pick this up over the Head First book any day of the week. 
&gt; explicitly enter boolean statement within the brackets. It is a boolean. 
Have you considered making a browser plugin that runs on that site that just auto clicks something every few minutes for you? 
The technical answer is because calling `A == B` where A and B are different types causes JavaScript to type coerce the values until they match. In this case, where A is a number and B is boolean, the boolean is coerced to a number. So -1 == true becomes -1 == Number(true) which obviously is then -1 == 1 and we can clearly see that this will fail. On the other hand in the first case the condition is, in my understanding, equivalent to writing Boolean(-1) and the only number that coerces to the boolean value false is 0.
MDN has some information about equality here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness You may also see charts like this floating around for equality (==) comparisons: https://i.stack.imgur.com/35MpY.png For non-equality truthy/falsy evaluation (e.g. `if(-1)`), most things are truthy, except for a few falsy values which are outlined here on MDN: https://developer.mozilla.org/en-US/docs/Glossary/Falsy Ultimately, `if (value)` is not the same as `if (value == true)`
All this talk about unicorn devs not existing, I just found one that evolved from an svg. üßê
I wasn't there at the time, but I'd be very surprised if the original grep didn't support groups (and consequently operators on groups). They are an essential part of the regular formalism and `re` in grep means "regular expression", not "pattern matching". I do think that /u/JDeltaN may have been nicer in pointing out the problem. I had the exact same thought but refrained from commenting given the intent of the article.
Na√Øve, only simplest-case, not well thought out, using recursion: const map = (f) =&gt; { const r = ([x, ...xs]) =&gt; { return xs.length ? [f(x), ...r(xs)] : [f(x)]; } return r; } // e.g.: const double = map(x =&gt; 2*x); double([1,2,3]); 
Ah yes, and without a polyfill. Obviously you don't want to go about including tens of date pickers and the likes and as many polyfills.
Early versions of C didn't have a boolean type. All you had were types of integers and floating point values. 
I'm aware. :P
-1 is _truthy_ (in that it's not false or falsey). Comparing true to -1 is the same as saying -1 == Number(true) Before the code runs, Javascript tries to make everything the same type before comparing it. Equality checking in Javascript is one of those things that gets a lot of hatred, this is why. If in doubt, use `===`
This is the most descriptive entry I was able to find regarding the history of the syntax of regular expressions. https://www.regular-expressions.info/posix.html From this, it is quite clear the first languages did not support grouping, nor was grouping a part of regexp's regular grammar. Anyway, this is now pedantic and not the original point I intended to make. I believe the article should be taken for what it's worth: a demonstration of a naive and simplistic regex engine.
This is interestingly quite readable even though IMO just looks horrible. Though today I learned about array spread syntax so that works for me. Thanks.
Do other languages do it in this same way? As in, they try to typecast whatever is on the right into the type that is on the very left Cause I knew languages changed int‚Äôs into doubles if there is one double present, but didn‚Äôt know that same thing happened with Boolean values. But that might just be javascript 
I must confess I needed two tries to get the spreads correctly xD
 Boolean(-1) == true // true -1 == Number(true) // false When comparing JS coerces to the same primitive. In this case it coerces true to a number - which is +1, obviously different from -1. If instead it coerced -1 t o a boolean, then it would be true, because -1 is truthy (as you have noticed in `if (-1)`)
You need to include only one polyfill.
&gt; which may rise again as HTML Modules. Perhaps you mean 'es6 modules'?
The 'more intelligent' method is to use a data store like Redux or MobX, and separate your logic concerns from your UI concerns. The event listeners dispatch actions to the store, the store does the calculations, and asks affected components to update. For simple applications, this is obviously overkill.
The ideal name for a variable is data. Perfect.
What /u/slmyers writes works fine, but it has bit of a drawback when you'd want to use the event object within the event handlers. Personally, I prefer to keep this type of custom event handling as close to reality as possible. Instead of introducing a third function to compose the other two handlers, you can let one handler call the other. Not directly though, but by faking an event to let the browser handle that event normally. If you happen to use a library like jQuery, this is easy: `$input.trigger('change');` would be all you needed to add to your select's event handler, provided that `$input` is a reference to the jQuery object for the number input. If I recall correctly, jQuery in particular actually puts in some work to attempt to make the event look more realistic, mostly by including a pretty decent custom event object. Other libraries may provide similar tools to do this type of stuff. If you're rolling with VanillaJS though, don't worry as there is an event API for you to use here. [See MDN for more details](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events), in particular the section about 'Triggering built-in events'. As the MDN docs will show, doing this in VanillaJS is slightly more complicated than using something like jQuery's `.trigger()`. Still, I'd argue that this approach wins out versus the introduction of a third function that calls the other two. Even with VanillaJS, this approach will be simpler once you abstract away the creation of custom events into a separate function. You also get a result that more closely resembles reality, allowing you to think of that custom event trigger as being no different than actual user-triggered events - which in turn lets you use the event object properly.
There‚Äôs a lot of brainstorming. Groups usually come up with several ideas. Anything that sounds easy/boring is rejected by the staff. Also, many Codesmith students have technical backgrounds, or a couple years of professional development experience (with some having 10+ years). The admissions process is tougher than some actual technical interviews I‚Äôve had with startups.
Once the month rolls over you‚Äôre setting the date relative to that rolled over month.
This was downvoted when I came to this thread and I have no idea why. It's a really important question to ask. I like this answer: https://www.quora.com/Why-should-I-learn-a-front-end-JS-framework-Angular-React-etc-and-what-are-their-benefits-over-a-more-traditionally-built-site
In a functional language it reads quite simply: map :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = f x : map f xs
https://dorey.github.io/JavaScript-Equality-Table/
This is insanely cool. So interesting.
switch to vuejs
Have personally scaled this same structure in a few applications, I agree it works nicely. Usually our components just have "enhancers" (often the use recompose) though instead of us splitting between containers and components. We had found that loading state in a parent and passing it down was unnecessary, instead we just connect to state at that lower level (hence components having enhancers, which can connect to state).
Lol. Try a basic course to get started.
Care to elaborate? This particular article is about maintaining a large React project. How would Vue.js handle this problem? I'm genuinely curious why you would suggest this over React as I don't know much about Vue.
Vue's philosophy leans heavily on the side of simplicity and self contained components. Both in terms of style and code. A single vue component is organized cleanly separating html from css from js but still keeping them in the same file. https://vuejs.org/v2/guide/single-file-components.html Data communication from something like an input field is much more simplistic as well making it easier to organize and write code for you to better understand later on.
&gt; This is simply the "free market" adjusting itself, That‚Äôs your problem right there. 
Interesting, that does sound like a clean way to handle components. I might check out Vue.js and see how it compares to React with a new project I'm going to be starting soon.
[Are you running on `file://` or through a web server?](https://stackoverflow.com/questions/12587731/same-origin-policy-google-chrome-canvas-and-file-scheme)
No, HTML Modules, a potential replacement for HTML Imports: https://github.com/w3c/webcomponents/issues/645
You don't have to use a bundler at all. You can just use HTML imports, natively on Chrome and with the polyfill on other browsers. Likewise with JS modules you don't have to use a bundler. Not sure what you're saying about a distinction between Polymer and other frameworks, neither HTML Imports or JS modules are Polymer specific.
file://
Then get a web server.
This is why it's best practice to only use the strict equality comparison and convert types manually as needed. -1 === true // this is false
...I see
[removed]
Thanks checked it out. You were right. What an under-rated gem. Read the chapter on Modules. Fan-freaking-tastic.
It‚Äôs far less about the language and more about engineering. Knowing when and how to scope down work, knowing when you can push work onto others and when you should accept work from them, knowing when things are good enough that it doesn‚Äôt make sense to make it better, etc.
If you have written moderately complex JavaScript and later realized "I should have done this instead..." then you are ready for this book. It will help you think about future complexity issues early in development.
[Addy Osmani's blog](https://addyosmani.com) is a consistent source of very useful information. I just wish he posted more frequently. 
I'm not a fan of booleans being automatically converted from integers. Why not force an explicit conversion by the programmer for the rare case you are using ints.
[removed]
&gt; BTW read this for more information http://voidcanvas.com/is-javascript-really-interpreted-or-compiled-language/ I don't think you read it very carefully. &gt; Conclusion Thus, even though JavaScript execution looks complicated and kind of hybrid, but I am still in the side of calling it an interpreted language rather than a compiled one or even a hybrid one which many people are calling these days.
Front end happy hour. 
Huh? The free market is a beautiful thing. What are you talking about?
Hi /u/pls_help343, For javascript help, please visit /r/LearnJavascript. Thank you!
&gt; Function local variables are declared in the compilation phase. What makes you think that? You seem to be assuming a lot of things that just aren't so. &gt; When the function I mentioned above is invoked, the engine search for the variable "a" to assign or retrieve its value... No, that's not what happens. [FunctionDeclarationInstantiation](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-functiondeclarationinstantiation) is the relevant part of the spec -- "when an execution context is established for evaluating an ECMAScript function". When a function is invoked, the language creates a new lexical environment and environment record (steps 2 and 3). These are the data structures that hold the local variables. Then in steps 11-14, the spec simply mentions and uses var, lexical, and function names. Now, this is where a language spec differs from a language implementation. The spec doesn't say how an implementation is supposed to find those names. Maybe they walk the AST a second time, or maybe they keep a cached list when creating the AST, or maybe something else entirely. And the exact mechanism will differ between Chrome's and Firefox's and IE's implementations. All we can say for sure based on the spec is that one of the first steps when invoking a function is to create a data structure to hold the local variables and to create entries in that data structure for each local name used in the function.
https://github.com/slavazhil/tanks2
C++ has many implicit type coersions as well. Some of them can be fairly technical but have similar implications for the topic here, e.g. what happens with if(blah) where blah can even be a weird object (safe bool idiom) http://en.cppreference.com/w/cpp/language/implicit_conversion
Looks really cool! Also kind of relevant Dr. Axel Rauschmayer put out three articles on ReasonML a few days ago which look great also, so hopefully ok timing to add them: http://2ality.com/
The Sessionstack blog has an awesome series on how JavaScript works: https://blog.sessionstack.com/tagged/tutorial The third article in the series talks specifically about how JavaScript handles memory allocation, garbage collection, and memory leaks and what causes them: https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec And here‚Äôs a Google article about how to use Chrome Dev tools to identify and fix memory leaks: https://developers.google.com/web/tools/chrome-devtools/memory-problems/ 
No, it's not that i just want to switch stacks. It's, i now actually want to learn a stack and stick with it. Why i want to switch? I probably will like it more, especially as a student, to write my full stack app, in 1 language, instead of 2 or 3. 
The V8 blog has some good articles. For example: https://v8project.blogspot.de/2017/11/orinoco-parallel-scavenger.html I also recently saw: http://www.katiefenn.co.uk/memory-dont-forget-to-take-out-the-garbage/
Still sounds like "just wanting" to switch. If you don't really know JavaScript yet, I think you will hate it more. Really stick with something you know and evolve. Make progress towards your favorite stack... A beginner with experience in php AND Python and several frameworks sounds like you have already given up on something a few times... Switching stacks doesn't make it easier, only more confusing.
Hello, really really thanks, But i don't know, but its not working for me ... I will send you here full js .. function play(){ document.getElementById('entryPage').style.display = "none"; document.getElementById('singlePage').style.display = "block"; } function easy(){ document.getElementById('entryPage').style.display = "none"; document.getElementById('singlePage').style.display = "none"; document.getElementById('catPage').style.display = "block"; } function hard(){ document.getElementById('entryPage').style.display = "none"; document.getElementById('singlePage').style.display = "none"; document.getElementById('catPage').style.display = "block"; } function time () { document.getElementById('entryPage').style.display = "block"; document.getElementById('singlePage').style.display = "none"; document.getElementById('catPage').style.display = "none"; //nezobrazuje sa "single page" } function animals(){ var random=0; var word=""; var animals=["cat","mouse","horse","dog","lion"]; random = Math.floor(Math.random()*animals.length); word = animals[random]; console.log(word); } function cities(){ var random=0; var word=""; var cities=["Bratislava","Paris","Dubai","Prague"]; random = Math.floor(Math.random()*cities.length); word = cities[random]; var letter; console.log(word); } and the output is 'gWord'... 
this is the index.html till now: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link type="text/css" href="hangman.css" rel="stylesheet"&gt; &lt;script src="hangman.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;body onload="time()"&gt; &lt;!-- vymazanie single page na zaciatku --&gt; &lt;div id="entryPage"&gt; &lt;button id="play" onclick="play()"&gt;PLAY!&lt;/button&gt; &lt;/div&gt; &lt;div id="singlePage"&gt; &lt;div&gt;Pick a difficult:&lt;/div&gt; &lt;button id="easy" onclick="easy()"&gt;Easy&lt;/button&gt; &lt;button id="hard" onclick="hard()"&gt;Hard&lt;/button&gt; &lt;/div&gt; &lt;div id="catPage"&gt; &lt;div&gt;Choose category:&lt;/div&gt; &lt;button id="animals" onclick="animals()"&gt;Animals&lt;/button&gt; &lt;button id="cities" onclick="cities()"&gt;Cities&lt;/button&gt; &lt;/div&gt; &lt;div id="gWord"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
i was trying to do it like that: function cities(){ var random=0; var word=""; var cities=["Bratislava","Paris","Dubai","Prague"]; random = Math.floor(Math.random()*cities.length); word = cities[random]; var letter; console.log(word); var x="_"; for (var i =0; i &lt; word.length; i++) { while(x==i) { document.getElementById('gWord').innerHTML=x; } console.log(x); } } but it only show me how many '_' are instead word ...
"Simply". I know this would probably be "simple and obvious", but I have no clue about haskell's syntax so it isn't really. Also I didn't think it could look more horrible than previous example. Where's that FP's readability everyone is talking about?
Thank you for the link. Microsoft is really trying to enter every area on the web. I love typescript but couldn't make it work with vue. I suggest you to use typescript. It is a bit hard to setup and get used to but gives you great intellisense and typechecking. Vscode typescript support is pretty good. Also you can use it with webpack.
* Don‚Äôt use for-in, use for-of. Then it‚Äôs a decent solution. * Alternative: [`Array.prototype.find()`](http://exploringjs.com/es6/ch_arrays.html#sec_new-array-prototype-methods)
Learning about composition and currying has been a tremendous help for me. Also: ditching jquery and building ui elements from scratch using es6. Its suprisingly easy and usually does not involve alot of code. On the serverside of things, I've spent alot of time deep diving into different frameworks to truly understand what they do and how they work. I even made my own mini-framework. The knowledge I got from doing that has also been a great asset. Knowing your tools and your stack helps you make better engineering choices.
Interesting... reading into those now!
`for-of` loop: for (const material of userInput) { ... }
The only number that is falsy is 0... most defined things in js are truthy, including -1... so the first statement returns true. [falsy values are false, null, undefined, nan, blank string and 0.... oh, and `document.all` for trick questions in interviews] When you bring `==` into the equation - this will do type coercion... the right-and side is coerced to the left-hand side. So it's like saying `-1 == Number(true)` which is `-1 == 1` which is false. Same thing happens with a lot of things - where they might be considered truthy (or not) while equating to true (or false) doesn't go through. The one that always gets me is using truthy in an if statement to check if something exists. In most cases, it'll work - except for the number 0. So if you take input from a user, `parseInt` on it and check if it exists - it'll work for everything except 0... i.e.: const input = parseInt(req.body.input, 10) if (input) { /* all numbers except 0*/ )
Yes and no. In C, TRUE is equal to the integer value 0, and the null pointer is coerced into the integer value 0 too in tests. Conditional statements (if(*), while(*), for(;*;)...) resolve as "pass" if the value is non-zero. In effect, this works kind of like JavaScript, but is much easier and simpler to figure out. C++ and later JavaScript had to extend these type coercions much further as more implicit types and operators where added to the language, forcing to add an === operator and making the resolution of corner cases far more obscure. If that helps, Lisp, as well as most dynamically typed languages also have these bizarre ambiguity resolutions, but JavaScript takes them to the extreme, whereas many sane languages will just return errors.
The second example uses a boolean expression (as seen in C#, Java, Dart, etc). The first one doesn't. That expression yields a number, not a boolean.
Just don't write na√Øve code. If your function expects a specific type, validate its input before using it and handle errors appropriately.
You can use `!!` to turn something truthy/falsy (booleany?) into an actual boolean: &gt; !!'' false &gt; !!'x' true &gt; !!-1 true
You can easily keep a component in a single file with react. That's not what this article is about. 
"how can I hammer a nail without using a hammer?" If you want strongly typed use typescript. 
Yes, of course. Just curious of the best possible way to make strong typed, since there is no operator overloading in JS.
I won't recommend you learning it, of course. But, just in case you have some curiosity, I will try to explain just that snippet and how to understand it. It's just three lines, luckily :) (And it is _very close to the JS I posted, actually, which may help) In fact, it's three lines and the first isn't even needed... map :: (a -&gt; b) -&gt; [a] -&gt; [b] You may see this type of line in many Haskell snippets. What it does is _express_ the _type_ of `map`. There's type inference in Haskell so a lot of the time you _don't need_ this line. A lot of people will still put it, specially when explaining code. I won't get into detail on this, basically it means: map is a function that takes a function from a to b, and an array of a's and gives you back an array of b's. Note that there's also automatic currying in Haskell. So we have this: map _ [] = [] map f (x:xs) = f x : map f xs This is a way to declare a function based on _cases_. You can see this as multi-dispatch i.e. declaring a bunch of functions with the same name but taking different arguments and the system will call the appropriate one depending on the arguments passed in each call. Things that come into play: pattern matching, de-structuring. There are 2 cases defined: map _ [] = [] First one is just saying: "This will handle the case where the second argument is an empty array, and I don't care about the first argument. In this case, the return value is an empty array". Haskell is a bit terse in _separators_, so there are no parenthesis around arguments or brackets around the body of the function. map f (x:xs) = f x : map f xs Second case is: "This handles when the second argument is an array with at least an element." This says so in the `(x:xs)`. An array is constructed with the `:` operator that concatenates an element (`x`) and _the rest_ (`xs`). `xs` may or may not be empty, but you _know_ that `x` is not because if the whole thing (`x:xs`) was empty, then it would have run through the first case, not through this one. It also says: "The first argument, we'll call it `f`". And then there's the body of this _sub-function_, which simply returns an array: using the same `:` operator it builds an array where the first element is `f x` (in JS we would write `f(x)`, it's just calling `f` on `x`), and the _rest_ of the array is... calling recursively `map` with the same function `f` and _the rest_ of the array `xs`. The nice thing about having the system take care of multidispatch and pattern matching and all that is that doing it by hand is _pretty horrendous_. I can remember at least a couple of JS libraries that attempt to provide some sort of multidispatch with various forms of pattern matching, but none have really caught on. So, imagine for a moment a language close to JS but with multi-dispatch and pattern matching. We could write something that might look like this: function map( _, []) { return []; } function map( f, [x, ...xs]) { return [ f(x), ...map(f, xs) ]; } I've used the spread operator because we talked about it above, so I assume it's now "clear enough" :) I could've written what I had above very close to this (barring multidispatch, of course), if I had not gone for a manually curried function... const map = (f, [x, ...xs]) =&gt; xs.length ? [f(x), ...map(f, xs)] : [f(x)]; So... Uhmm... I'm not sure what I'm trying to tell you other than sharing, in case you wanted it, a minimal explanation on how to read that Haskell snippet. Other than that... It makes me wonder... would I write JS in that manner? Is it really _horrible_? And well, I guess it depends. I _can_ understand your feeling about it. It does take some effort to read it. I could say that the effort comes mostly from not being accustomed, but that's probably not a really relevant distinction. So, I do get your perspective. On the other hand, I must say I generally do like it and I'm getting quite comfortable with such a syntax as I'm using it for some inconsequential experiments and personal projects. But I must also say that no, I definitely wouldn't use this sort of syntax in the professional environments I've been lately. Most people are _not_ accustomed to it and that _is_ the important point in those environments. Maybe, with some other team, when some time has passed and it's a more prevalent style in JS, I might consider it. But right now I understand why many people might find this alien or even _horrendous_.
Unless one is written for spec V0, another for V1, etc.
I don't think so. That's just JavaScript, although I'm sure some others exist as well. Most languages have an actual type system, but JavaScript thumbs its nose to such a feature. An array, for example, is an object and for a long time it was hard to distinguish one from the other. Now we have `Array.isArray` function that can be used as a pseudo type check for arrays. Another example is the type of null. Null value is one of JavaScripts primitive data types, yet using the `typeof` operator on null returns `"object"`, the same that it returns for objects (including of course arrays, as they are objects). The reason for this is an ancient bug that has since been added to the specification to avoid ambiguity over the `typeof` operator.
Now it's a bit more clear, also yeah, I had problems with multidispatching in JS too (I still prefer to call it function overloading as in C#, Java and even C++ it's a thing and was pretty straightforward to use), although hacky, it's possible to "overload" by simply checking amount of parameters being passed, although that also doesn't look that nice either.
Ah, yes, overloading is _close_ to multidispatch. Not exactly the same, though. Overloading is resolved statically, while multiple dispatch is done at run-time -and so can go a step further, e.g. depending on dynamic properties, even the _value_ of an argument, rather than only the type and/or number of arguments. In the Haskell above, you'll notice it dispatches on the _value_ of the array :) As for how _nice_ it is or isn't... I guess it depends. In Haskell it's just extremely common. I don't have much of an opinion on it.
Also see LiveScript http://livescript.net/
mobx-state-tree not even mentioned? It's the best of both worlds, from the creator of MobX. Pure pleasure to use.
Or flow
What is the best source to master these topics?
I doubt it
People hire front end developers, not javascript developers
If you have some projects you can showcase that somewhat fit their requirements, then you have a chance. It largely depends on the market, some locations really struggle to find talent so you don't need much experience at all to land yourself a job.
This video is very helpful: [**2016/2017 MUST-KNOW WEB DEVELOPMENT TECH - Watch this if you want to be a web developer**](https://www.youtube.com/watch?v=sBzRwzY7G-k)
I would check out upwork.com
&gt;Would you transpile from another language, and if so, what? Typescript &gt;How would you structure your code? Some sort of formalized state management. It wouldn't absolutely have to be redux style but I have yet to see a better alternative in front end. &gt;What capabilities / browsers would you support? Evergreen but mobile is *way* to important to ignore. IE 11 and less though forget about it. &gt;Would you request JSON or HTML from the server, or both? In an ideal world where anything is possible both would be nice. But there are performance considerations when the front end isn't completely in control of the view, whether virtual dom or something else. &gt;Would you test your code and with what? Of course tests are required. The what isn't very important to me as long as it works. &gt;What build tools would you use? Other than typescript as already mentioned I don't actually care if it specifically used webpack or not. Or any other particular build tool. Just make it work, document it, and provide a cli to get started. A more extensible cli than the major frameworks generally offer would definitely be interesting but I'm not 100% sure of all the ramifications there. &gt;How would you import and use external libraries and utilities? Npm? Is there really any other good choice? &gt;How would you avoid namespace collisions? For the library itself? Angular did it right by prefixing all their modules with @angular. &gt;Would you make your app an SPA? This depends on what the app is. But if we are talking js front end frameworks then yes generally if I'm using one it's for an spa. &gt;What are the main challenges / problems you would face? Performance, state management, the usual really. One thing I'd want to do is really use rxjs or at least a similar observable library. Like really make it a part of the framework that is fully exposed and that devs are absolutely forced to use. This might hurt adoption rates but I think it opens a lot of possibilities. I've wondered just how far you could take rxjs as the pipeline for basically the entire application and maybe throw react in for the view. But really make the framework based around reactive observables.
Heres mine: * Would you transpile from another language, and if so, what? No - I would write all code in ES5. * How would you structure your code? 1 file per component, arranged in folders by page. Probably a single "main.js" bundle + page specific bundles. * What capabilities / browsers would you support? FF latest, Chrome latest, IE9+, all iOS, and 90% of mobile Android users. * Would you request JSON or HTML from the server, or both? JSON for ajax requests, HTML for pages. * Would you test your code and with what? Yes, with Selenium. * What build tools would you use? Webpack. * How would you import and use external libraries and utilities? I would use Webpack to assign each library to its own global namespace and load them in each page with require(). * How would you avoid namespace collisions? Require() + global namespace using Webpack if needed. * Would you make your app an SPA? No. * What are the main challenges / problems you would face? Main challenge would be complex DOM manipulation in vanillaJS. I would resist pulling in React or jQuery at first, but it would probably find its way in.
Did you just recreate angularjs with modern tooling? ;)
When I say component, I mean just a chunk of JS code that manipulates the DOM and calls AJAX. Not a component in the Angular sense. No rendering of templates.
Interesting, Ill have to check out RxJS
Basho: Lazy, Functional Style pipelines using JS for shell scripts/automation. I just rewrote most of it today, and it's a better tool now. https://github.com/jeswin/basho
Install flow-bin and flow-remove-types and start hacking flow annotated code for node. I switch to babel + preset-env + preset-flow very quickly though because using require and import type together seems ugly to me... 
Plenty of jobs exist that don't require you to write (much) in languages outside of JS (Node shops come to mind). However, you'd still likely need skills like database fundamentals, software design fundamentals, etc., which you don't get when doing basic language tutorials. Trying to find a coding job with the mindset of only wanting to learn the bare minimum isn't a very solid approach IMO because you will always be learning new technology and skills on the job.
The way I'd do it is decompose it into 2 problems. The first one is: Given **one** _recipe_ and given an _inventory_, does the inventory contain all materials in the quantities needed? The second one is: Given a collection of recipes, find one that matches a certain criteria. First good news: The second problem is already solved! So, with a bit of wishful thinking I could write... function chooseRecipe( book, inventory ) { return book.find( canBeMade(inventory) ); } And that's the second part already solved by simply using `find`. Note that this will only give me the **first** _valid recipe_, but if I wanted to obtain **all** _valid recipes_ the change would be as simple as using `filter` instead of `find`. function getAllDoableRecipes( book, inventory ) { return book.filter( canBeMade(inventory) ); } So, anyway, the first part of the problem... I, thinking wishfully, imagined I already have a `canBeMade` function, so that's exactly what I need to write: function canBeMade(inventory) { return function(recipe) { // ... now we have 1 recipe and the whole inventory ... what do we do? }; } This looks easy. You just need to check that for each material in the recipe, that same material is also present in the inventory in the same or a larger amount. The only thing bothering me is that in the way the inventory is structured right now, it is a bit tedious and annoying searching through it. I'd much rather write the inventory in this way: { ironPlate: 1, copperPlate: 1 } ...because it's much more simpler to use. But (!) of course, the inventory may be being used in other parts of the application an you may not want to change everything. So we'll just transform it _locally_ first: function canBeMade(inventory) { let simplerInventory = inventory.reduce(function(inv, item) { inv[item.name] = item.amount; return inv; }, {}); return function(recipe) { // Still pending... }; } But.. why this, you might ask? It makes it really simple to search the inventory now. Is there at least 1 `'ironPlate'` in the inventory? Well, `simplerInventory['ironPlate'] &amp;&amp; simplerInventory['ironPlate'] &gt;= 1`. So... cool. I just use that for every material in the _recipe_. function canBeMade(inventory) { let simplerInventory = inventory.reduce(function(inv, item) { inv[item.name] = item.amount; return inv; }, {}); return function(recipe) { return recipe.requirements.every(function(requirement) { return simplerInventory[requirement.item] &amp;&amp; simplerInventory[requirement.item] &gt;= requirement.amount; }); }; } (`Array.prototype.every` returns `true` if all elements check according to the function passed. `false` otherwise.) Putting it all together, you might have something like this: function getAllDoableRecipes( book, inventory ) { return book.filter( canBeMade(inventory) ); } function canBeMade(inventory) { let simplerInventory = inventory.reduce(function(inv, item) { inv[item.name] = item.amount; return inv; }, {}); return function(recipe) { return recipe.requirements.every(function(requirement) { return simplerInventory[requirement.item] &amp;&amp; simplerInventory[requirement.item] &gt;= requirement.amount; }); }; } Which you could use, with your existing `recipes` and `userInput` arrays like this: getAllDoableRecipes( recipes, userInput ); // Result is: [ { name: 'Red Science', requirements: ... } ] // Similarly with the single result function chooseRecipe 
I have worked as pure frontend developer for 2 years, used only react and sometimes doing markup.
Any of those should work on that array, so the problem is probable somewhere else. Please consult questions 4 and 5 in the [sub's FAQ](https://www.reddit.com/r/javascript/wiki/faq) for how and where to ask questions :)
I got my first developer job 5 months ago only knowing javascript (es6, react, and a very vague knowledge of redux), node/express back end (barely,) and SQL (barely). I had a loooot of on the job training to do, like googling how to do basic things with react I didn't understand, figuring out bootstrap styling framework, and learning C#/asp.net framework which is used by our massive back end. I probably do more coding in c# now than javascript (and tbh I probably enjoy it as much if not more) and I've had to touch a lot of things I was completely unfamiliar with along the way (like actually learning SQL, figuring out older JS frameworks like Knockout, becoming more familiar with git, learning the company's general development and deployment process which at first seemed incredibly complicated to me, etc). Basically, yes, if you know JS and whatever framework the company you're applying to uses, you can get a job, but if it's your first job they might expect to give you a decent amount of hands-on training for the first 3-6 months or so. And you might have to apply to a lot of places and you might have to take something you don't love doing and get paid less than what you'd expect (I was making $20 an hour for my first 3 months before getting salaried and a raise). Especially if you don't have a college education it's gonna feel like work getting your first job (I dropped out of college and took a 4 month coding course after which I sent out probably 30-40 applications before I got an interview, and another 30-40 before I got an offer), but don't give up, it's definitely possible. Just expect to learn a ton more than you already know once you get the job, and probably not ever really stop having to continue learning. 
anyone got a tutorial for this ?
For of to iterate over array not for in, that‚Äôs for iterating over props in an object 
anyone got a tutorial for this ?
This isn't specific to react, but organize by feature, not by type. See: Ember's module unification. Glimmer's default app layout. Drawers gem for rails apps. 
Have a look for some of his talks about this stuff as according to some of the reviews it's just a rehash of those talks and articles. If you like what you see then go for it. I find Unc' Bob a bit caustic but I do respect his knowledge. Scanning through the contents there's nothing in there you wouldn't be able to understand. It's not targetting advanced coders. It won't all fit into place in your head immediately but it will probably help you reason about certain problems later on. Watch one of these, They're almost identical, and see how you feel. [One video](https://www.youtube.com/watch?v=Nsjsiz2A9mg) [Two video](https://www.youtube.com/watch?v=o_TH-Y78tt4) 
Why would you need a javascript libary for that? All the functions from video.js are relatively easy to use in normal JavaScript/html without a library... A view weeks ago i did need to make one for a school project and it worked out prefect. If you make a custom react component for the player you can make something much better.
Nah, i think you have the wrong view on me. I go to school to learn app development, so they learn us more then just 1 language and framework. Anyways, i have no questions anymore. Thanks for your time. Have a good day.
My guess is that this has something to do with the fact that you're making an async request. That can be tricky. Here is a JSFiddle that uses fetch to make the request and then runs a function on the result that iterates through each country. Happy to answer any questions about how it works: https://jsfiddle.net/yzevfger/
So, things like database fundamentals, software design fundamentals, etc etc are and have been huge concerns of mine while learning. I recognize the connection between not just doing these things, but know why and how it all functions. and the gap in my knowledge created by a lack of knowledge on things such as software design fundamentals is really worrying to me and holding me back. do you have any suggestions, resources, books or anything of the like that you suggest to broaden my knowledge beyond the syntax of a language? Thank you in advance. &amp; as much as I would love to attend college rn, not necessarily an option.
Good point. A portfolio is a great option.
Plenty of six-figure JavaScript jobs out there.
any comment about livescript ? 
I think asking what the bare minimum to get a coding job might be, is actually a pretty solid question for someone who's established in another career. Maybe not for a student though. To me, the bare minimum is the point at which you can bring enough value to an employer as you continue to learn to justify a paycheck, rather than learning as a hobby in your own time.
this works perfectly and ye could you explain how this works please?
Video.js is primarily used for styling your video player. I don't think it adds much beyond that. If you're doing _real_ adaptive bitrate video streaming and especially if DRM is involved, it's a whole different game and for that you'd need [dash.js](https://github.com/Dash-Industry-Forum/dash.js), [hls.js](https://github.com/video-dev/hls.js/), [shaka player](https://github.com/google/shaka-player) or [rx-player](https://github.com/canalplus/rx-player), depending on what kind streaming setup you have and what code style you prefer.
Maybe 5 years ago. JavaScript engineers are increasingly a thing.
I learned that stuff by doing it wrong the first time, then making it better the second time and trying different approaches until something worked. It takes a long time (I have been programming for nearly 30 years now), but in the end you‚Äôre much better at this than anybody who has learned this from books, tutorials or YouTube videos. These days I just have to look at the source code of a project and can tell you what will be a problem later on and what approaches will work fine. I didn‚Äôt have to learn any software design patterns for this, these concepts come naturally after a while. tl;dr: don‚Äôt bother with reading about programming once you have the basics, just write hobby projects where failing is not a problem.
Building a small-to-medium sized app in vanilla js with RxJS is a great way to solve the complexity with the least amount of abstraction!
Meh, learning enough html 5 and css 3 to be able to implement mockups from designers shouldn't take long at all. 
You‚Äôre missing an opening curly brace after the if. 
If you run it synchronously it will return nothing since it's executed immediately. A response will arrive fast, but never instantly. With . then, it awaits something and doesn't get executed until that something is there.
True enough
It uses the `fetch` api that returns a `promise`. If you don't know what those two words mean, don't worry it's more or less what their names imply. When you request data from a server, it's not like referencing a value that you already have in local memory. You have to wait and halt execution until the server has responded before you can continue. `fetch` is wonderfully easy to use because it returns the aforementioned `promise`, so you can declaratively write what you want to do with the data when it comes back - this happens in the `then`-block. Line-by-line it goes like this: Get the data from here ``` fetch("https://restcountries.eu/rest/v2/name/ireland?fields=name") ``` then, when we get a response, continue by evaluating it as JSON ``` .then(response=&gt;response.json()) ``` then, when you're done with that task, iterate over the data, which is now a javascript array of objects ``` .then(countryArray=&gt;iterateOver(countryArray)) ``` bonus: Because we know the we'll get an array back and the function `iterateOver` takes an array as parameter, we can use it as a first class function like so: ``` .then(iterateOver) ```
Yes thanks I enjoy learning thats why I started
Thanks
You asked for advice on where to start, my advice is: start with JavaScript on the front-end.
No, you have to know how to wash your clothes, dress yourself and brush your teeth too.
Knowing only Javascript in isolation is like understanding the body by only examining the skeleton. You probably know more than you think anyway, as at the very least you need to know how to consume and present information in order to do anything at all with JavaScript. It's mostly a matter of degree. Your specialism may well be JavaScript, but the things that surround it need to be taken into consideration and these make up your personal stack. If you haven't already given yourself a pet project, if you're learning with a view to becoming a professional, then you are doing it wrong. The creation of your pet project will unlock your potential and expose you to all the things you need in order to progress. It won't happen overnight though. Patience and perseverance are your greatest friends.
I grouped the statements after the (if) and the (else) with curly braces but it didn't do any change.
Completely false. We hire JS devs all the time for node, iot, and games. 
https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia Navigator.getUserMedia is deprecated. Use MediaDevices.getUserMedia instead.
That's a good and true observation in my opinion. But few employers like to see themselves as paying for somebody else to learn. Sometimes you have to engineer those opportunities so that the logic of employing you is inescapable.
As a full stack developer -- Javascript jobs are still very difficult to find. Java still has a death grip on the job market, unfortunately. When I put my resume out last year I had over 100 calls and emails from recruiters over a couple month period, and none of them were using JavaScript on the back end. Some of the job offers did ask for Angular or React knowledge. They all wanted something else on the back end though.
&gt; validate its input before using it This adds lots of boilerplate code, increases the file size, and also negatively impacts performance. Using TypeScript is a much better idea. You get better tooling and the types also serve as documentation.
I'll try thank u
I wrote my first program 30 years ago. If you want to keep on working, you never stop learning. Love of learning is what turns this from a job into a vocation.
LiveScript is freaking great. &gt; LiveScript is a language which compiles to JavaScript. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, it also has many improvements for object oriented and imperative programming.
Nothing has the id of attendance. Why don‚Äôt you try passing true/false into the function. Then you don‚Äôt have to check if anything is checked or not. 
If you learn framework such as Angular with Typescript or reactJS, then there are high chances of you getting a good job. Knowledge of only JavaScript will not help. These framework are some or the other eay based on JavaScript so it will be easy for ypu to learn.
Without the curly braces it‚Äôs only evaluating the first statement after the if. I would advise you to always use curly braces in an if statement. Even if you only mean for the first line to run still use them. 
Thanks
Damn I'll reconsider
My solution looks like this: function checkInventory({item, amount}) { let slot = inventory.find(slot =&gt; slot.name === item); return !!slot &amp;&amp; slot.amount &gt;= amount; } let available = recipes.filter(recipe =&gt; recipe.requirements.every(ingredient =&gt; checkInventory(ingredient))); https://jsfiddle.net/n4d0dwz1/ (I renamed "userInput" to "inventory".)
This is nice, thank you for posting 
I added id="attendance" to the first radio button attributes and it did the trick :) thanks!
Thanks for the link! I got [an answer](https://twitter.com/awbjs/status/936993492206628865) from Allen Wirfs-Brock: &gt; Goes back to JS1.1/ES1. Based on idea that a prototype is in fact the prototypal instance of a class of object (see self language). &gt; &gt; Later found to be problematic. ES6 made new built-in protos just holders of methods. Couldn't change existing protos b/c backwards compatibility.
Yes
What was on the backend usually?
Short answer is yes, absolutely. Longer answer is not likely, as vanilla JavaScript rarely works on its own. If you want to do frontend or web work, you are going to need experience with a SPA framework like angular or ember, or perhaps react/redux. These are indeed all JavaScript but with sprinkles of HTML and CSS mixed in. If you really only want to write JavaScript then nodeJS is your route. You'll need to learn how nodes APIs in addition to some routing frameworks like hapi, express or my favorite, koa. GraphQL is a great thing to get into right now, but generally you'll need to know some sort of SQL or nosql database querying. There's also mobile frameworks like react native, but inevitably you'll need to dabble in Android and iOS APIs and Java/Objective-C. This all being said, my job is 99%+ JavaScript, but a peripheral understanding of other technologies is important.
I think it really depends on where you are. The enterprise SaaS world is moving toward doing more and more on the client side and just consuming REST APIs, and as a result there are some big, big JS codebases out there. At my company, for example, we have a dozen dedicated front-end engineers. We dabble in the backend codebases, of course, when we need to make small changes, but we don't really have any true "full-stack" developers because all of the codebases are just huge. I also think it varies a lot from city to city.
Yes - I wasn't talking about the bare minimum to be able to say "I know JavaScript." I was talking about the bare minimum to be able to say "the value I bring to an employer immediately outweighs the cost of having a junior developer learning on their dime."
Like 90%+ of the positions wanted Java devs. :\
Came back to answer the question, but it looks like you did already :)
Yeah, i want to start with Angular.js. And if i made a basic front end app, i want to start with Node.js.
Personally I love Typescript. I started using it for a 100K LOC project and I think it's the only way to keep your sanity intact when dealing with Javascript. As an added bonus, you can use modern stuff like destructuring and string templates and they get transpiled to ES3/ES5. Kinda like Babel.
‚Äúengineers‚Äù
I really hope ReasonML keeps gaining momentum. I really miss algebraic data types and pattern matching while writing JavaScript.
You need to learn a specific front end framework, example Angular.js or a specific back end framework, example Node.js. And you need to know OOP, and MVC. And you need to have made like 5-10 projects on your own in a mvc framework in oo code. That's when i would feel confident in starting to search for a job. I did 2 internships without knowing the basics of OOP and MVC and i did have a really hard time.
I get why this is getting downvoted, it sounds cunty...but I agree. There are principles of software development that are necessary to write good, maintainable code that a person, more than likely, won‚Äôt pick up. It‚Äôs either that or people will be complaining in 5 years about only being able to find 30k a year jobs. 
I know you're joking but an "engineer" is someone who can imagine various solutions, decide on the right solution for the job, and implement it. It could be a new process or implementation, or a rehash of something someone else did. Being an engineer is more than being a codemonkey. Engineers are capable of thinking of abstract and complex solutions, and then implementing those. As for Op's question, I hire people who are fullstack engineers. Since our stack is Javascript, they only *need* to know Javascript, but the more backend and general purpose languages they know the better. The difference is whether we hire them as an "Eng 1" or a "Senior Eng 2".
IoT now runs on JS? It gets scarrier and scarrier. 
I couldn‚Äôt disagree more. I learn heavily from books then take that and apply it. OP, everyone has learning styles that work best for them, learn how you do best, then take the time to code and apply your knowledge.
It‚Äôs not scary at all. Building things for Alexa, Home electronics, and other devices works perfectly fine in JavaScript. JS is the new PHP when it comes to people bashing the language for the sake of Internet points. Is it better in C, python, or GO? Maybe, but most clients care less about what hip language you are using Vs when you can deliver a working product. Truthfully, there‚Äôs nothing scary about it. 
&gt; Are they decent JavaScript front end and back end stacks that are being used by companies? Yep. IMHO, they are the future for most web development, along with some React which is a sort of competitor to Angular. &gt; is it a wise choice to learn them and search for a junior position in a company that uses that stack? I'd say yes. They have a solid future.
PHP was a language deserving bashing. Not anymore. Javascript was and is deserving it still. 
Myself and others I work with all started out as C#. When we moved away from WPF and developed the front end in Angular 2+, we all became Javascript-oriented engineers. We sometimes do stuff on the back, but its so rare. When I changed jobs, they were more interested in my Javascript skills, Angular 2+ and Typescript than anything else. But its like any other language. There's nothing wrong with specialising exclusively in Javascript as long as you know how to design an application well (i.e. know whats in the stack, even a pure JS stack, how to properly implement design patterns, reusable code, separation of concerns, etc)
In vocational programs, often students are taught a wider net of technologies. If you know javascript, you are closer to working in the frontend than the backend (despite the growing prevalence of node.js and backend js, I assume most jobs involving strong js skills assume front-end stack skills.) With this in mind, I would highly advise you learn web technology: In rank priority, this is what I would focus on: - [Javascript](http://jstherightway.org/) (especially interacting with the DOM) - [CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS) (and maybe something like LESS or Sass in addition) - [HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML) (it's *the* templating language, especially for the web) - PHP (or some other backend language used for building HTML, this depends on the market you are targeting - you may want to focus on a .NET stack depending on what jobs are around) - SQL (relates to PHP and the backend - understanding a web application or website means understanding how the data gets to the model and thus to the browser) Note that as you move down that list, the less change is involved. SQL and back-end languages don't change much, whereas javascript has changed a lot and web frameworks have become a volatile and huge area to keep up with. If you are interested in learning frameworks, some common ones you may want to try learning are: - [Angular](https://angular.io/tutorial) (maintained by Google, huge and popular framework; it is probably too bulky for personal projects, but may be relevant to a job) - [React](https://github.com/facebook/react) (developed by Facebook, not generally as bulky as Angular and other frameworks) - [Vue](https://vuejs.org/) (great documentation, focused mostly on user-interfaces, light and easy to integrate rather than big and prescriptive.) I know little about frameworks, so others may be able to help you more. I hope this helps get you started. I would likely focus on web dev jobs; doing some work on Github and building a portfolio would help immensely, especially without prior job experience. 
Android apps are generally written in **Java** not **Javascript**. The two are completely different things, and all they have in common other than the name is that they are both computer languages. If you actually mean javascript, then you need to write your code in something like [nativescript](https://www.nativescript.org/) which is a javascript (technically typescript) framework for Angular, itself a front-end application framework in typescript.
Check out [cycle.js](https://cycle.js.org) . Andre Staltz has a great [egghead course](https://egghead.io/courses/cycle-js-fundamentals) that walks through his motivation of the library and shows you how to build with it. It leveraged streams (not rxjs) heavily. 
React native maybe?
I've heard nothing but great things about cycles! When I tried to look at it I was lost in 'shiny new toy' land and never gave it a fair trial. I'll have to check both of those out! 
I think it's because JavaScript wasn't really am option for back end until the V8 engine was created. People are slowly moving towards JavaScript. Being able to use JSON format everywhere is bloody amazing. You never need a library to convert the format into the format which the new language understands, and most importantly, you can use patterns like the Broker Pattern on the client and server side by using the same interface
Manager: Now, you know it's up to you whether or not you want to just do the bare minimum. Or... well, like Brian, for example, knows thirty seven runtimes, okay. And he has a terrific smile.
The best way to debug this would be to console.log `nextDay` every time after you change it. You'll see that `setDate` doesn't do what you're expecting it to (hint: it doesn't just change the day of the month and it will keep those changes each time you go through the loop)
Mainly, I don't see how someone can write JavaScript without understanding the DOM and how HTML and CSS work. They all go hand in hand.
It depends on the gig you land and how you apply yourself. I got a job knowing bare minimum Java Script and found a company willing to have me do small projects while also teaching me along the way. Not s bad day to start
If you just want to understand language behavior, then the spec is the ultimate authority. But if you want to understand a specific language implementation, such as v8, then you should go directly to the folks who work on that implementation. They [talk at conferences](https://www.youtube.com/user/ChromeDevelopers/search?query=v8) and [explain how v8 works](https://www.youtube.com/watch?v=EdFDJANJJLs).
Lot of mixed answers in here, nothing really definitive for you, so I'll try to help. I interview and make hiring decisions at large corporation. The three major role areas that I hire for are front-end developers(react/js), back-end developers(java/REST), and full-stack developers who are comfortable with both these stacks (but I don't view this as a significant positive attribute, just a developer preference--if someone wants to do both front and back end development, I expect them to be just as good as a typical developer who specializes in each of those). When making hiring decisions for front-end developers, the primary *technical* skill I look for is JavaScript. We describe all our technologies on our job requirements, we see experience with our particular frameworks as a strong plus, with other similar frameworks as a plus, but neither of these are hard requirements. JS frameworks come and go, if you learn JS and you're good with it, that's the core. Similarly, knowledge in HTML/CSS are helpful, but not required. With react and a decent UI toolkit, the amount of expertise required on html/css by most developers on your team can be greatly reduced, and that's kind of where we are. The TL;DR for you is, yes, if you're passionate, up for a challenge, know your JS, and are up for some amount of learning, a fair number of places will hire you. In fact, the best places for you to work will be the ones that don't get all hung up on having X years of experience with the specific stack they're using--that mentality is usually a bad sign. You'll learn more from people who don't view it that way.
Yeah, but node has been around since 2011 so that's not really an excuse. The real issue is that it's 1000x easier to fuck up a javascript codebase than it is a Java codebase. Java has a ton of things in place to prevent you from screwing up too horribly. Javascript is like the wild west, and I agree that it's awesome. I use node on every one of my personal projects. But at the same time the front-end angular codebase I have to deal with at work is a nightmare, because it was mostly written by novice devs with no real guidance from people with experience. If you are building a team of senior cutting edge code ninjas, 100% go with node. If you are building a team of recent college graduates with very little experience... I'd stick with java for the near future.
Possibly for a junior level position...just expect to learn a bunch more in a hurry. SQL, HTML, and css are all must haves. Then a backend language like Java, C#, PHP, Python, Ruby, etc (not all of them, but at least one).
I wouldn't see why not. Javascript is an enormously powerful language. If you know it well, you've got plenty of background to learn any other programming language, quickly enough. The only thing you might need extra, is SQL. 
 Node and front end frameworks are going nowhere. React, Angular and Vue are very popular at the minute so its worth picking one up. Will they be in top in a few years? Who knows but all of the frameworks work in a similar way and when you comfortable with the concept and the core functionality switching between them isn't too painful. The Flux Architecture that most of them push also has good momentum and will continue to grow. As this is an architectural pattern, it is framework/ library agnostic and completely transferable.
But, I mean, you had to have had your resources, no? So from the sound of it, messing with raspberry pi projects is actually a great place to start?
Yeah, i switched from basic Python Django programming to basic PHP Symfony programming for school purposes. And it was like 80% ish the same. But yeah, i don't want to choose a language and framework that are dieing of course. I want to choose something that is still "middle-aged". Anyways, you made a good point.
Kinda, but for JavaScript, it's better to just use whatever computer you have and develop on that one. You only need a text editor and a web browser to program in JavaScript. The Raspberry Pi can do that, but it's pretty slow.
Lol must feel good bashing js in a js sub
Vue and React are still growing (an understatement), Angular is definitely still healthy. Node is too ubiquitous to die anytime soon: js across the stack and a ridiculously popular package manager. They're solid tools and will be current for quite some time yet.
My concern with swagger is that you have to know your requirements up front. What if your requirements are constantly changing?
I think the idea is pretty damn WRYYYYYYYYYYY
Thanks! Yes I've found the second one, about halfway through. No idea how it relates to actually learning how to make build some architecture, but I presume it's become more evident with time as you said. At minimum, he's got a good sense of humor. 
Solid argument bruh. How's league of legends treating you
I assume you mean Angular 2+ when you say Angular. I'm currently working with Angular 4 and forcing Typescript makes the IDE at lot more friendly when you write the type of everything. The thing with Typescript is that it is Java 99% of the time, then 1% of the time it's functions as parameters which is were most people fuck up
Glad I don't have to use Angular anymore. 
Yes, but honestly learn any of the big 3 Angular, React, or Vue, then also learn the other 9nve you have a grasp of the first. Once you learn one of them the other 2 will come easy. Additionally it makes you more sellable to employers. Not to mention yeah Angular may be the most common job wise but if you also know the other 2 then you'll be worth more to others especially a company not looking for angular because I bet everyone else will just be learning angular.
Then you change your swagger... it‚Äôs just like Tdd or bdd, there is some additional cost but the benefits outweigh said costs.
Have you used it in production?
Please don‚Äôt listen to OP, he has no idea what he is talking about. There is absolutely nothing about Vue that solves the problems in this article. React is also a component based library and components are almost always put in a single file. Just like vue. What the article is talking about is what happens when you have 100 component files, plus 100 files for all the other things an app needs beyond components like state management, routing, api calls, etc. how do you organize all those files? Vue has all those same concerns outside of single file components: https://v1.vuejs.org/guide/application.html React is single file components and Vue is single file components. Nothing about them being single file components helps in anyway with the problem of organizing large projects. 
At Newscorp a few years ago you actually had to deny the existence of back-end technology and pledge allegiance to almighty Javascript before they would even make (fleeting) eye contact with you. Then they all discovered Nodejs...
&gt; ubiquitous What do you mean with ubiquitous? Its a new word for me haha. Yeah, at my Python internship JavaScript was both used for React and it's package manager.
You don't have to. There's libraries out there for doing 'Code-first' APIs with Swagger schemas, where the schema is generated for you based on your code, so it's always in-sync. Just make sure you don't keep changing your spec post-release (without versioning it), or people won't like you. [For sails](https://github.com/trailsjs/sails-swagger) [For hapi](https://github.com/z0mt3c/hapi-swaggered) [For koa](https://github.com/zaaack/koa-joi-swagger) [From JSDoc defs](https://github.com/Surnet/swagger-jsdoc)
lol yeah right 
React native or even use https://github.com/infinitered/ignite Ignite which will throw together a react native app for you pretty quickly and you can quickly set your colors and logos and have a few basic pages and an app together. 
probably java, like 90% of the business logic of the world is written in java
lol yes
It isn't even possible to dev in javascript with just knowledge of javascript. Employers like to know you can do other things that go along with having to write javascript like repos, showering, being on time. Take all the shots. Let them figure out if they can get along without you knowing something else. 
You know anywhere I could look at some simple projects to get me started?
Just go for it! If you‚Äôre fairly intelligent and willing to do the hours you‚Äôll do fine :)
Exactly, it's a lot to take in and it isn't immediately apparent initially. If I said "Wax on, wax off" would that be a movie reference to distance to relate? Most of what's in the book, in fact a lot of what's important when it comes to coding is to be able to make changes, sometimes enormous and fundamental changes, and have some degree of certainty that you can do it a) relatively quickly and b) relatively safely. You don't have to learn it all in one go though, so just enjoy the ride :)
Yeah my team changes our production spec constantly. Not by a lot, just a small change here and there. But over the course of a year theres so much wrong with our API docs that our customer service team is forwarding bad request issues to dev on a weekly basis. Im making a slight push to use versioning in our API but Im unsure on how to pull it off without multiple servers or versioned handlers in our repo.
PHP still has mysql_real_escape_string.
Yes, your best bet for a pure JavaScript role will be learning react. Angular is mostly tied to a full stack role, and other libraries like vue and elm have a smaller adoption rate. I'm not saying that these libraries are bad, it's just a numbers game.
This is like asking if you can get a job as a carpenter if you owned a hammer. The question is do you have the knowledge to use it? In the metaphor, where to drive the nail, and how to swing the hammer. JS is just a tool. It is one part of a large aspect of software development 
Ubiquitous just means commonplace, found everywhere. :D
I'm probably the wrong person to ask, because when I was at that stage of learning, the Web didn't even exist, but I've heard some good things about Code Academy. This is their JavaScript/web app development course: https://www.codecademy.com/pro/intensive/build-frontend-web-apps-from-scratch
I was just working at a place (I left due to distance from home), and they are a leading IoT company in a specific area. Everything runs on Node. They initially had a C app but found that Node actually works better and is faster. Node is surprisingly powerful and fast, and much easier to spool up then Java or PHP in my opinion. Every environment I‚Äôve worked in that used Java took days - if not weeks - to get the local build up and running. Node was just ‚Äúnpm i‚Äù into ‚Äúnode app.‚Äù Pretty damn nice.
&gt; /r/learnjavascript &gt; Python video course
Learn some basic HTML and CSS and you are set 
Javascript still has no integers, so? At least you do not need that function in PHP. Both languages have legacy issues, but while PHP improved a lot, the same cannot be said about JS. 
Are you running your website in a local server or simply open it from the disk? Chrome does block some APIs if the website is not running HTTPS or running from localhost.
It works, thank you! 
I don't see that much activity about the CC, but I do see a **lot** of style recalculation and repainting and layout... with the page _at idle_, i.e. no scrolling, not even moving the mouse or anything. Looking at the source code it looks like they are they are doing some not-too-good things. One I don't really get, because it's not actually doing anything. It looks like they're trying to do some sort of animation on the title that reads "We build products.". And so every couple of seconds, through a `setTimeout` they try to do this thing but there's nothing to do. Mildly silly but I don't think that's the culprit. They also use an animation library called WOW, who knows why. And this library has an interval set every 50 milliseconds or so to check the scroll and, if needed, fire its animations. Again, not too nice, but maybe understandable and also quite probably not _too much_ of a problem. Finally, they also seem to have some subtle animation around that title area in which they move some &lt;div&gt;s containing images with some shapes. They do this with CSS which could be good, but then, what the animation does is animate the `left` and `top` properties of the &lt;div&gt;s. This is quite probably the one causing all those re-stylings and re-paintings. :( About the Cycle Collection, again, I'm not seeing that problem. I mean, I do see occasional Garbage and Cycle collection related events, but it doesn't look out of the ordinary at all. For comparison, it's _much less_ than what I see here in reddit.
Thanks. This really helped me a lot.
When they said node is going nowhere, they meant it's not going away anytime soon. They didn't mean its dying. 
Would you then recommend learning JS heavily? If you could go back, would you broaden yourself heavily or would you specialize in C#/something else instead? I'm starting this no degree, self-learning process to get a job path, as well. Everyone recommends JS/Node.
For ASP.NET swashbuckle
It does require more up front thinking, but hopefully you have a good idea what the API will look like before it's put in production. You can still change the documentation after it's in production. But just like everything, be sure that the changes do not break backwords compatibility.
Lots of companies use it in production. I have even worked with government clients who I've implimented it.
&gt; Will they be in top in a few years? IMHO react will be. Not sure about Angular, but react is has the same API for couple of years now and it is still going strong. Whereas Angular keeps changing the API, keeps introducing breaking versions and the community is not growing. At the rate react is going Angular will be left in the dust. &gt; The Flux Architecture that most of them push No, just a few devs from Facebook pushed it, but I think all of them would agree now that redux/mobx is far better aproach to state management. I haven't heard about a single project utilising flux in commercial nor OSS space. 
Out of curiosity which area do you live in? I know in Toronto Java and C# are popular. It wouldn't surprise me id location plays a big role on what language is popular.
I tried this. I made a fully functioning plain js app that was a data @&amp;&amp;grid with full edit/copy/add/delete functionality in-line. It worked good. Later I upgraded it to be component based. Meaning I would take an element on the page and initialize it with my constructor. This added click listeners and things like that to make the app automatically do cool stuff. All of the data was contained inside the html itself. The element git filled with more html using a template function I wrote. The next step was to do the inserting/deleting of elements less manually, so i started looking into how virtual dom works. Then said fuck it, why am I re-writing vue or react? And just seitched to vue, because it was already everything I was trying to make. 
Thanks for replying, I dont mean to come off as arrogant, I think it my comment could be interpreted tbst way. Anyway, Im genuinely interested...my workplace could use some better documentation practices. What issues have you run into using swagger? Are there any resources for best practices or for gotchas that happen to newbies? Whats your opinion on using it in a team of 5-20 people? 
&lt;header&gt; must be inside &lt;body&gt;
Angular doesn't use a virtual dom. It does use change detection though which only rerenders the view when bindings change. Which is very loosely the same idea. But it's explicitly not a virtual dom.
Isn't redux an implementation of flux?
I get your point. But either way, these functions are very complicated. I was writing a separate function for each ‚Äúthing‚Äù to out it in the right place...not very efficient. 
Great answer. Whatever opens the door 
Oh I didn't mean to sound like I didn't agree with you about deciding not to reimplement react. Just you said you don't see how you can get away with not using a virtual dom.
How does angular do it? It sounds like to a oid the virtual dom they just re-render the whole page...that can‚Äôt be it
I'd probably end up writing a poor copy of my favourite framework that covered my use cases then carry on as usual.
No they only rerender a component who's been flagged as changed by change detection. Instead of explicitly calling setState Angular checks the state constantly and when it finds changes it triggers a rerender. I'm glossing over a lot of details here but that's the basic idea.
Yeah for sure. I'm currently in the Research Triangle, so east coast US. I'm not sure how the job market here compares to SF, Seattle, or any other tech hubs. I was in Seattle before moving to the east coast and did Java development there, but that the last time I was job hunting there was like 7 years ago before Node was even released.
You should at least know html and css.
Thank you for pointing me to sub-reddits I had absolutely no idea of, wow, mind blown, smart ass. conducive &gt; you
you should make an effort to learning and understanding general computer science principals. The bootcamp generation has become so bad that i refuse to hire anyone that can't speak to any non mean stack technologies. 
yeah, and increasingly a thing where that javascript usually impacts other systems, such as a browser which renders using html. 
the only people near me that get 6 figure jobs are tech leads and senior devs that know much more than javascript. this just isn't true. experience pays. not hype.
Your loop will increment `i` for you. If you increment it yourself in the loop you‚Äôll skip indices.
Its the same architecture, yes. 
Redux is a flux implementation. There are also others, which is why I referenced the architecture rather than a specific library.
Yeah. This. Sorry for the confusion.
https://www.w3schools.com/jsref/jsref_max.asp
Fantastic presentation! Loved seeing Netscape being loaded inside Firefox :D
try to translate your requirements into code. In your title, it says "bigger than", in your code, you use &gt;= you'll also need to return true somewhere...
Your logic is quite broken here. Also, it seems to me that ES2015‚Äôs (I think it is new to 6/2015) map or reduce function could be of use here, depending on how terse you want your code. 
Yes.
OverTime - 1 command to see when it is wherever your team mates are. Working on remote teams can be difficult across time barriers, so I built this tiny little CLI tool to make it a little easier. https://github.com/diit/overtime-cli 
You don't want map or reduce... [Array#some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) is what you want. In any case, this function won't help a beginner to understand javascript basics like array looping.
It is a matter of keeping track where everything is, and defining what is supposed to happen under a given set of circumstances. If you are a beginner, use Jquery. If you have experience and are up to the challenge, you could do it.What happens when an item is selected, what happens when an item is dragged up, what happens when an item is dragged down? Once you are able to break it down into discrete steps, it isn't actually that difficult. I'd still use JQuery anyway because it will likely be smoother and more stable than what you can do.
Normally I would make use of jQuery, but in this instance it's an Angular component and we're trying to keep jQuery out of the codebase.
Fair enough. 
 [3, 8, 6, 4].every(num =&gt; num &lt; 7);
There is a third, less popular (but much older) option than using TypeScript or Flow, which meets your requirement of JS strong types. Use JSDoc comments: /* * @param {Number} x * @param {Number} y * @return {Number} */ function add(x, y) { return x + y; } Then feed your code into Closure Compiler and it will use the type annotations in the comments: https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler
[Collisions](https://github.com/Sinova/Collisions) - A 2D collision detection library
in JS an array is an object so it actually doesn't matter - you can use `for in` to iterate over an array. It is better however to use `for of` since you'll have to do a `hasOwnProperty` check if you use `for in`
Incorrect try it and see
Incorrect an array is not an object they‚Äôre two completely different types [] !== {} True
a solid understanding of the concepts will put you a leg up from the competition. There are a myriad of JS frameworks, as long as you are willing to learn and adapt, apply you core concepts, sky is the limit.
My functional solution: ``` const inventory = new Map(userInput.map(Object.values)) const isSetAvailable = (requirements, inventory) =&gt; requirements.every(({ item, amount }) =&gt; inventory.has(item) &amp;&amp; inventory.get(item) &gt;= amount); const getAvailableSets = (recipes, inventory) =&gt; recipes.reduce((cumulus, { name, requirements }) =&gt; { return isSetAvailable(requirements, inventory) ? cumulus.concat(name) : cumulus }, []); ``` As you can see, the first thing I do is create a Map instead of iterating through the array. This has a performance benefit, because you don't have to traverse the entire list anymore. `Map` has also `has` and `get` methods that communicate your intention more clearly. Then it boils down to reducing the list of all possible sets to the list of the ones that can be afforded.
It's been quite a week, but I've got something up. https://github.com/dtfinch/hero-starter
Google analytics.
Been working on this for a while - an IDE to provide a modern modal editing experience, based on Neovim: https://github.com/onivim/oni Some nice progress this week though - significant responsiveness improvements using [redux-batched-subscribe](https://github.com/tappleby/redux-batched-subscribe), and refactored some of our RxJS layer so that it is [unit testable](https://github.com/onivim/oni/pull/1049).
First, dear god, let's add some white space and remove that random comment: function determine(number, chain) { for (var i = 0; i &lt; chain.length; i++) { if (number &gt;= chain[i]) { chain[i++] } else { return false } } } console.log(determine(7, [3, 8, 6, 4])) So, let's talk about `chain[i++]`. What is it you expect this will do? In the first loop of your example code, first it will call get `chain[0]`, which evaluates to `3`. Nothing is done with this value. Then the `++` kicks in, which sets `i = 1`. So now `i` is `1`, and then you get to the end of the for-loop, and `i++` gets called _again_. So now `i = 2`, and you _never checked `chain[1]`_. Remember that a for-loop can be rewritten as a while loop: var i = 0 while (i &lt; chain.length) { . . . i = i + 1 } So you don't want to `i++` somewhere in your for loop, because you'll just end up skipping indexes. What I'm _guessing_ you meant to write was `continue`, which will jump to the next for loop. You'll also want to return `true` if you make it to the end of the loop, otherwise you're returning `undefined`: function determine(number, chain) { for (var i = 0; i &lt; chain.length; i++) { if (number &gt;= chain[i]) { continue } else { return false } } return true } Of course, you could drop the `continue` by checking just for the false condition instead of the true one: function determine(number, chain) { for (var i = 0; i &lt; chain.length; i++) { if (number &lt; chain[i]) { return false } } return true }
I would assume `some` is more efficient as it probably short circuits. !arr.some(num =&gt; num &gt;= 7);
I would do it on the backend, and only to authenticated users. If your using express for example, you could use Middleware to read the the user and store the results in a database. I'm sure just about any framework will have a way to execute some code on every request.
I‚Äôll take protobuf over swagger any day. While swagger does documentation ‚Äúok‚Äù enough, APIs need to be precise and well defined. This IMHO is where swagger falls short. It allows you to define the equivalent of ‚Äúobject‚Äù or ‚Äúdynamic‚Äù which is just an abomination in an API. The other annoying part is just dealing with the document structure. It painful and overly complicated whereas the protobuf language is clean and precise even across languages and architectures. 
You're right, but having to invert the comparison makes it a little less obvious what is being tested, and for small data structures like a small array of numbers it's better to always favor readability over performance. 
I'd say it's important to look at the job market in your area (or the area you're looking for work) and see what kind tech the companies are using. If I could go back and wanted to find work in my area (New orleans) I would say I'd still focus on Javascript heavily but also learn a strongly typed/class based language because it's structured a lot differently from javascript. Java is still a very very popular language and I believe fits those requirements, as does c#. Tldr: solid knowledge of javascript + front end framework (react + redux is probably the most in demand from what I've seen) + basic styling (CSS (plus framework like twitter bootstrap) and HTML) will get you a job. Knowing another language and how to put together a back end/API/basic database will make you find a job quicker and probably start with a higher pay. It'll also make you feel more confident in job interviews which is a nice plus Sorry the tldr is longer than the op
What is it that he wants that isn't allowed? Does he want to store personally identifiable information?
I wasn't saying JavaScript is good, just that PHP isn't either. PHP improved a lot, but imo to late. It was awful for at least ten years, so the last five years of improvement are progress, but I still don't hold it in high esteem. In a few releases, they've reached the dizzying heights of sort of nearly as good as Java, which isn't a good compliment.
JS can certainly be your focus, but you'll want to understand how it connects to databases and APIs and front end stuff like HTML and CSS. You should look at those job listings as suggestions for what to study. Ask yourself why they'd want those things. How do they connect to JS? Can I do a small project that incorporates one of the other line items, like sql instead of mongo? Do I want to be able to maintain older code like PHP? To some extent, most jobs will require that you know how to learn beyond your core competency. The work will usually involve different systems communicating, which means you'll be better if you have a working knowledge of the basics of a variety of tech.
There's a method, `Math.max` that returns the greatest number of an array. Once you have the biggest number, compare it with provided number: `number &gt; Math.max(...chain)` That's strictly a JS answer... if you wanted to do it with a for loop, iterate over the entry and any one of the array entries is &gt; the number, return false so you exit out early... after the loop, return true. There's another js method, `Array.prototype.every` that does basically that. This function runs on an array and if the callback returns false for any iteration, the function will return false. `chain.every(item =&gt; item &gt; number)`
every will also short circuit. If you pass it an array with a million entries and the first iteration returns false, the function immediately returns false.
I don‚Äôt think this really matters. If your requirements are constantly changing you still benefit from having a documented api spec. Clients can now diff the spec and see where they are broken, or even better, if they use a generated SDK and a type safe language like typescript, swift/objc or java the compiler can automatically tell them. You need to know your requirements upfront for any api development. If you don‚Äôt know your requirements you don‚Äôt know what to build. You may not know some specifics such as some entity fields or endpoints/operations but api docs are a living document, they change with the code. Developers can easily build out endpoints and then document them after the fact when they are ready to be used. The OpenAPI spec is quite easy to hand write but some frameworks can automate it for you. I‚Äôve done this with springfox, a Spring plug-in but I know it‚Äôs possible in other frameworks. Most of my work is with Django working at a consultancy/agency. We hand write our specs currently as Django lacks a solid automatic integration (although it‚Äôs on the way!) and we find it dramatically increases our velocity even in the face of insane requirements changes (small business clients often pivot) due to the aforementioned SDK generation. We also find that on boarding (new) devs to a project is much easier as they are able to understand client/server interfaces much better (swagger ui and sdk rather than a sprinkling of random xhr/fetch code). 
I thought things settled with Angular 4 and 5? 
Have you heard of ES6? What are your exact complaints?
based on how you're phrased this question, I am going to say most definitely not.
so... currently c, c++, rust can compile to webassembly. and because i dont like c or c++, i want to learn rust!
And with quite a few employers I think it would be fair to say that it is a perceived cost. In my experience I have profited greatly by giving opportunities to hungry, eager and committed individuals who want to learn and improve. Mentoring is a benefit that can work both ways.
(The following doesn't really bear much relation to JS) While the author has previous books widely regarded as essential -The Clean Coder and Clean Code-, I've been seeing much less praise and [a lot more criticism for Clean Architecture](https://dzone.com/articles/book-review-clean-architecture-by-robert-c-martin). One particular claim that can't be argued much is that the book presents nothing new. It is, mostly, a re-hash of older articles and talks from Robert C. Martin. Not only, but being so, the book falls into the same problem many of his latest articles and talks fell into: it seems to be very general and abstract but disconnected from _how_ to actually solve the concerns of development. The advice he gives is "not bad", but the feeling is that it really doesn't help. This ultimately gives way to the feeling that... &gt; The term architecture as used by software architects like "Uncle Bob" is hand wavy bullshit. ...(cite from a comment in r/programming a year ago). To be fair, again, he sometimes gives some good advice. The problem is that usually it's generally obvious advice or, in most cases, it's just too generic, avoiding giving any real insights into the detail of _how_ to actually implement that advice. I haven't personally gone through the whole book. I picked it and read some bits. But I must say it really feels that way. In particular, this is the same sensation I've had about Robert C. Martin writings and talks for some time now: He doesn't really say much of actual use beyond the obviousness. People I know who have read the book more in depth, confirm this feeling.
If you want to do this imperatively, use for-of to simplify the code a bit. For-of can be used if you only want to look at the items itself and don't care about their index. function largerThanAll(value, numbers) { for (let number of numbers) { if (number &gt;= value) { return false; } } return true; }
I'm guessing you meant Google Analytics, if he is wary of their ToS and want something "free" you can suggest something like https://piwik.org/ since it's open source and self-hosted.
in 5 years webassembly will kill javascript completely, probably starting with some huge sites implementing it right now (all major browsers have native webassembly support since last month)
that was amazing
To get help you need to link to the code, or preferably a controlled, minimum replicable JSFiddle/Codepen. $("navPanel").hideOnClick() - won't work because you're trying to select dom elements &lt;navPanel&gt; which don't exist. Without knowing the API or what .panel() does, what plugins you're using, it's all too hard to guess.
My personal guiding rules: * Eliminate all build tasks to run the application. * Preserve state at all times. * Never send code to a server. * Avoid and reduce reliance upon dependencies. I have slid on the *no build tasks* rule a bit since moving to TypeScript, because you have to compile between writing code and running it. So now I have a minimal build task in place to compile TypeScript, perform ESLint validation, load libraries to create an experience that runs with Node. The final step is to take the Node app and convert it into something that can run in the browser. That is really as simple as put all the code into a single file and change reference from *global* to *window*. I reconcile that I must have a build process now I have a node process that executes *fs.watch* and automatically runs the build when there is a change to certain files and then uses web sockets to refresh a status or test page in the browser, and automatically run the code in the browser upon web socket refresh. It is automated enough that it is kind of like not have a build task, except for the 1.5-2 second delay. That said I need a universal way to organize my code. I absolutely refuse to jump through a bunch of bullshit hoops to perform environmental specific builds and unload massive dependencies on my users. What I do is create a project specific object and attach it to Node's *global* reference. All my code for an application goes into my big object. So at the global, library (file) sharing level, the application is organized as a multi-tiered object. That is the first time and last time I will use objects to organize any code. It is extremely efficient and eliminates all manners of ritual and ignores Node's differences to ES6 modules. The way this works is that for Node only I will have a build file that requests, using Node's *require*, to load the necessary files and those files assign their code to the proper place in the application's object on global. The application object will contain all the working code and so it can be used directly, with some minor changes, to write the browser application. Internally to the app the code knows where all the pieces are using the organization described above. For example if I needed to access another library from a given library it would be something like `global.myApplication.beautifyUtility.script` or an extreme shorthand of that. Internally to the libraries everything is organized as nested functions. This makes for, again less code rituals and other bullshit. I never use `this`, `new`, any other OOP madness in my code unless a third-party dependency makes me. Coding like that, can execute much faster, but faster execution through OOP in JavaScript isn't common. You really have to know what you are doing. My code is internally organized as nested functions or ES6 blocks for scope. This is faster in most cases because it is the most direct means of resolving shared references (scope chain and reference resolution) and you don't have to dick around with prototype chains. It also makes the code easy to read, as it is well structured. The most important aspect of this is that structured well planned code takes longer to write, but is superior for maintenance. The code executes (almost) exactly how it is read. I used to worry about supporting all browsers and environments. About 6 months ago I decided to move from JavaScript to TypeScript and abandon `var` for `let` and `const`. If your browser still forces `var` then my code won't run there. This helps me eliminate most, not all, of my IIFEs in my code. It also lets me see when I am attempting to reassign to a constant. Points I haven't addressed: * I never send things back to the server and less there is a business requirement that forces such or unless I need to do something that cannot (or should not) be done in a browser. I have for a long time used a CURL on a server to bypass CORS in the browser. * When I have to send things across the wire I prefer JSON 99% of the time, because it is small. XML is a far more intelligent format which is helpful in those rare cases where you need more intelligent things. * The only opportunity for a namespace collision external to my app is the name of the application on *global* and *window*. I lower this risk with a specific name of moderate length, like *parseFramework*. * SPA is really a browser only consideration. Whether I prefer a SPA or not depends upon the requirements of the app. A SPA can be really convenient for the user, but with large apps this can quickly get out of control and turn into a ball of crap. Not matter what I will save state of all user interactions and store this state data in localStorage. I really believe most large Frameworks make this far more complicated than it should be.
https://www.youtube.com/watch?v=Io6JjgckHbg alt: https://viperhtml.js.org/
Wow this is great! I wish I had this tutorial for a school project I did last year man..
The Advent of code has started! http://adventofcode.com To celebrate that, I started writing Advent of Code tasks using my own compiler called "Ranger", which compiles the tasks to JavaScript, Go, Swift, PHP, Scala, C#, Java and C++ https://github.com/terotests/Ranger/tree/master/adventofcode If compilation succeeds, the results will be in the bin/ -directory. This is a good test because these kind of tasks use operators a bit differently. And because this is a new compiler in test phase, you will find bugs a lot. If you want to try the tests, the compiler can be installed with "npm install -g ranger-compiler" - has zero dependencies, just one JS file which is compiled from the source code, written with the Ranger language itself. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [terotests/Ranger/.../**adventofcode** (master ‚Üí 5a6d9b1)](https://github.com/terotests/Ranger/tree/5a6d9b1a954e9beb0f3e993631c41c8e09fb266b/adventofcode) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
If you like a mix of Perl+Python, weird syntax without any cool features of es2015+ like async/await, you will like LiveScript.
thank you I didn't know about piwik üëç
if you save the positions of each item in the list (I mean the ordinate) that would be really easy, I mean something like: "if(draggedItem.y&lt;otherItem.y+otherItem.length) slide(otherItem,up); else if(draggedItem.y+draggedIem.length&gt;otherItem.y) slide(otherItem,down)" Of course this code is called when drag event is detected (mousedown) 
Check out heap analytics. Tracks events and actions at the user level. Or mixpanel. Lots of others out there. Heap is good if you have under 50k visits per month because you can stay on the free plan. Insanely expensive after 50k
I like the way you explain things very good job üëçüëç
so did it work??
Bane of evil. Sadly nobody will likely want to help you burden the souls of your users with annoying ad nonsense. Fun stuff like this makes me wish browsers had an instant switch to block loading of all scripts not originating from the same domain at the page.
I'll do it for a Bitcoin.
Pshh... I'll do it for a Bitcoin. 
I can pay in bitcoin.
https://github.com/Selection-Translator/translation.js No English doc, but if you need, I can ask the author for you.
Very useful, thanks! I completely agree that it has very nice UI, it should'nt be that bad in usage. Anyway, wanted to share a [post](https://mobilunity.com/blog/sapui5-vs-openui5-developer/) with SAPUI5 vs OPENUI5 comparsion. These two aren't very different, are they?
Ok, thanks for that warning shot. I will bear it in mind. I'm really still a noob, just at the stage where I'm just beginning to think about architecture - so perhaps the non-specific "good advice" will be helpful for me in a way it wouldn't for a more seasoned programmer. I'm definitely up for specific suggestions. I just made this post, perhaps you would comment there? https://www.reddit.com/r/softwarearchitecture/comments/7h7v90/architecture_for_a_music_apps/?st=jaqyhhdt&amp;sh=d9bc9cc7
Another tip, use css transform for the animation because that is much smoother than css relative position.
I saw this talk at MiswestJS in August. Absolutely blew me away. Feels like the beginning of the (slow) end of JavaScript. Time to learn Rust!
Wow, looks very promising, thanks! The Chinese docs are fine. I'll give it a try.
No dev in their right mind would willfully contribute to an asshole design feature like a pop under ad. Sorry. You should look into a different revenue model if you're looking for help placing ads.
HyperHTML did it first and better.
[Spion.io](http://spion.io/) is a free, open source library that I think is exactly what you want. It'll even capture a recording of the page for you. 
It's super slow and often buggy in my experience.
I'm sure it's very location-dependent. 
I am a big fun of eslint too! It is way more than just some rules. It creates consistency and helps you became a better development. The hardest part is to have other people follow it!
I really appreciate how much effort was put into this readme. It is well written, addresses many potential questions, teaches the reader about the domain at the conceptual and implementation levels and makes the project seem very much more polished. Well done! 
&gt;It creates consistency and helps you became a better development. Shame we don't have linting for English...
Well, an array is an object but an object isn't necessarily an array. And `[] !== [] //true`
I'd love to see Typescript becoming a webassembly compiler. Otherwise, I'll have to learn Rust, I guess.
Am I the only one who just doesn't care to stand on a soap box pounding my chest about linting?
Thank you!
Personal experience here ... About a year ago I went in looking to learn Python which turned to JS then Express then mongoDB then SQL etc etc... once you have a core set of fundamentals in a language you‚Äôll seek other technologies almost naturally it seems. My first ‚Äújob‚Äù which was just recently is helping my uncle with SEO which is the last thing I would have expected to be doing
A rerender of what though? Like say i wanted to add a record to a list of records...is it re-rendering the entire list?
Not that hard, there's a tool called husky which forces you to fix your linting issues before you're allowed to commit / push your changes. Works great on projects with a lot of developers.
How many languages do you know fluently?
No problem! This is solid advice. Thank you.
Yes
It tries to figure it out.
Just sort the array and test with the first or last entry according to your sort order. You ask larger than all of the entries, not a filter. 
Your code had a number of issues. here's working [codepen](https://codepen.io/alex-wilmer/pen/rYPgeB?editors=1010) the basic thing which was wrong is that your checkbox handlers were trying to access a variable that wasn't defined in the same scope. a super quick fix was moving the var statement out of the `createWorld` function var light1, light2 function createWorld() {...}
Agree. 100%
I've noticed Many of these programming posts are "style" related. Makes sense because the majority of programmers interested in writing any kind article are often going to write about the combination of those two interests. I've trained my brain to read code like a compiler/interpreter. This fluff gets compiled away in my mind. And this verbosity can often hide the worse kind of bugs. I personally don't need it. If anyone wants to refactor a bunch of function and variable names for the sake of readability, more power to you. Write some tests instead.
Any CI can have configuration set to force eslint any commit 
No harm in both
You can't, that's why you're asking here. (Couldn't resist, sorry)
I suggest you to put your code somewhere like jsfiddle, so that would be easy to work with. 
Disclaimer: this is just for fun and evaluating your javascript knowledge, so pleease don't take it too seriousely.
Hi /u/Mr_Fischer, while we think that games written in JavaScript are cool, we'd much rather see the source code than a link to your app store :) On top of this, you're relatively easy to doxx based on your link. Just a heads up. I'm removing this for being self-promotion, as it falls in that category when there is no source.
 var formular = $('#form'); formular.on('click', function getTarget(e) { ... }); I think it's related to your use of `formular` and `form#on`.
Not sure how to say this polutely, but I feel like this post counts as "memes or low-effort content" in the subreddit guidelines. The sound effects and loud techno music are an earsore as well.
you said it politely don't worry :), sorry for the music. but low effort and meme, not really I took a lot of javascript tests myself and I thought why not try to make a catchy video about it, make people evalute their knowledge in the language and at the same time have fun:)
The content is useful content, however this may not be the best presentation of that content.
Thanks :), any advices ???
I don't think Js will die any time soon. But webassembly could be the beginning of a bright future for the web
Quizlet
Hard to say. There will probably always be _some_ JS. But all of the efforts make JS more performant now seem pretty pointless. And that is the sort of application I find more interesting.
I'll look at it. Thx for sharing 
????
Where can i find more tests like this? 
https://www.javatpoint.com/javascript-quiz, work hard :)
I could be wrong, but declaring the function name in the callback you pass through the event listener could be causing an issue. For example: form.on('click', function(e) { }); There is no need to name the function. Doing as shown above will accomplish what you want. But the big thing that is definitely causing an error is your use of "val." This is not an attribute like the vanilla JS "value." It's a function, so you need parentheses following it. var jsTextInput = $('title').val();
Media encoders and physics engines maybe, but JS is plenty fast for most use cases.
What makes hyper better?
Created another video about using RESTful API in Qooxdoo ( phew took me all Saturday ). https://www.youtube.com/watch?v=CoBKTiBkc9Y You can even play with the code in my WebOS https://www.AstraNOS.org/MiyamotoMusashi/BattleGround.php?course=3 
Looks interesting. Thanks for sharing.
Why not just /node_modules?
Has anybody used lint-staging as mentioned in the article? I think its great except when I went to commit a file chunk instead of the entire file.
We use a build.jar. If you break the CI build, you put a donation in the jar &lt; $1. We then use the money in the jar to help pay for the kegs in our kegerator. It's entirely voluntary, but it does average about ~$15/week, but those who do participate get to pick the one of the kegs.
IMO prettier + eslint basics are plenty. Hyper customization is :(
Do you have a link to this husky tool? Google results are bringing up husky tools from Home Depot or a defunct github org: https://github.com/huskylang
I think this is what I'll end up with
Exactly what do you need help with?
you're unable to use third party lib... why
Can you define third party library? How are Express and any of the no sql db libraries not considered third party?
https://www.npmjs.com/package/ssh2
It doesn't hurt to name your callbacks. It actually helps in debugging because the name will show up in the stack trace! 
google tip: search for `npm ${thingy}` https://www.npmjs.com/package/husky
https://gist.github.com/WebReflection/fadcc419f5ccaae92bc167d8ff5c611b
 class SimpleStorage { constructor() { this.data = {}; } setValue(key, value) { this.data[key] = value; return value; } getValue(key) { return this.data[key]; } } module.exports = SimpleStorage; Something like this should work, just add an internal function to save the data property to a file on each call.
Hmm, shouldn't the file still lint? I can be kind of annoying. I had it set up on one thing keep you from _merging_ if it didn't lint and pass the tests. 
REST Express Example const express = require('express'); const SimpleStorage = require('./simple-storage.js'); let appStorage = new SimpleStorage(); let app = new express(); let handleGetValue = function(req, res) { res.end(appStorage.getValue(req.params.key)); }; let handleSetValue = function(req, res) { let postData = ''; req.on('data', (chunk) =&gt; { postData += chunk; }); req.on('end', () =&gt; { res.end(appStorage.setValue(req.params.key, postData)); }); }; app.get('/:key', handleGetValue); app.post('/:key', handleSetValue); app.listen(8080, () =&gt; { console.log('Example app listening on port 8080!') });
Or purescript... which compiles to c/c++ :)
Sounds like you've got a pretty good idea of what you need to do. Is there anything specific you need help with?
Thanks, I'll give both a look.
I'm pretty sure it's because promises are standardised and CSP is not built into the language. Clojure has promise, CSP-style, and agent based async, and pretty much everyone uses the CSP-style over promises.
Tough crowd... I swear it wasn't me who downvoted you. I'll give nativescript a try, thanks for the pointer. I did server-side programming in Java for a couple years, but didn't like the Android IDE (or the weird way they have to put together an application) one bit. And agreed that the Java/Javascript naming was unfortunate. Some kind of marketing gimmick by Netscape and/or Sun (RIP both of them).
Sorry I should mentioned, New libs which are already not available internally in the organisation 
Mock rest API for crud operations which saves to a file 
I know that, when I wrote "force", I meant people following the standards by their own will because they understand the needs for it. Also the main problem for CI force implementation is legacy code.. And we have plenty. :)
No one will ever need more than 512KB of JavaScript!
Didn‚Äôt know about ssh2 so that‚Äôll most def come in handy. From here it‚Äôll just be mashing everything together after digging into that framework (library?) and getting it to play nice with vue and electron. It‚Äôll take a lot of time as I am still learning the fundamentals of JS, which I‚Äôve been learning alongside everything else. 
Firebase has a noSQL REST API you can hit with requests. 
Those two parts of your statement: &gt; I saw this talk &gt; the beginning of the (slow) end of JavaScript Are a contradiction. Unless you watched without any comprehension.
Don't have deep knowledge about both. I just scratched the surface. Thanks for this! 
On `dragenter` you need to physically swap the nodes, but use 3d transforms to move the nodes back to their starting position so it looks like nothing was swapped. Then trigger a reflow (it's needed) and then reset the 3d transforms while adding a transition to smoothly move the nodes to thir new position. I did something similar if you want to check the code out for some pointers: https://codepen.io/Mobius1/pen/VKByKd
So if I understand correctly, async here means that the handling of the emit call(s) happen on the next iteration of the event loop?
There is an [open issue to support partial staging](https://github.com/okonet/lint-staged/issues/62). This is the only reason I‚Äôm not using lint-staged yet. As I recall, even if you partially stage a file, the entire file gets committed.
We don‚Äôt write code only for ourselves, that‚Äôs why I find great value in tools like ESLint (and Flow). When we can read our own code, it‚Äôs easy to think that it is well-written. However, I measure code quality a lot by how quickly another person can pick it up. If you have no trouble with continuing another person‚Äôs work, then the quality sounds good enough. :)
Your error is not in this section of code. Is there more?
That is the issue! there is no more code! it's this and the rest is HTML in a seperate file.
That doesn't make any sense. You declare three variables upfront and then never use them?
Weird i know, but that is what our professor showed us... i'm very new to Javascript &amp; JSON and i'm learning day by day? so the first 3 variables are basically useless you say?
We have no idea without context. You said the rest is HTML, but that would be very strange given what you have showed us. I suggest sharing everything.
updated my post.
You're missing what I'm saying. The parsing error *does not exist* in what you've shared. So which is more likely: that the error is wrong or that you are neglecting something. We cannot help you without full context. Drag the folder to your Dropbox, then right-click and copy the share link and post it here.
I literally have nothing else beside some images and a single css file. But sure i'll upload the whole ting to weshare. give me a moment i'll PM you the link.
You can review SheetJS on github
Delete statements one at a time until the error goes away... when it does, it‚Äôs likely the last line you deleted. Brute force, for sure, but...
A numeric keyboard works in mobile browsers. It contains a pluggable keyboard component and a input box in replace of native input element. The numeric keyboard have several versions: plain javascript class, React component and Vue component.
weirdly enough i made it work somehow.
Not sure if he can introduce Firebase if he is not even allowed to add new libraries to the project.
demo https://fast.wistia.net/embed/iframe/f40gilnlxp
its a scripting language.
Our teacher does not understand this:(
Hi, At my company i'm the git guy and every times we successfully push code to production i add a git annotated tag on our repository at the latest pushed to prod commit. Every time written the same way. Thoses tags allow us to know what was inside this release for history So was on holliday and despite the fact i formed every body with git cli workflow guess what... no body created a new tag So here is a the github of this tool's which work on every git project and help you build a new tag based on previous one and provide you with a boilerplate. Only tested it on linux ubuntu distribution :https://github.com/benjaminW78/pimp-git-tags 
Is there a reason you need a GUI? Seems something that could be accomplished with a pretty simple python script. Also, is there something keeping you from dropping a script on the connected device? Assuming linux... something like a cron job then rsync to a base machine?
Don't try to argue with him. Learn what you could from his teaching. Filter it and used what is usefull to you for futur job. His considering of Js is just outdated and based on the fact it's not what he know. 
Android Studio is much better these days, give it another look, or a first look if Eclipse was the official way to write apps last time you messed with it.
It is bad that he tries to impose it on other students.But you are right.Thank you.
So...the whole project? You haven‚Äôt attempted any of it?
Define the difference between a "scripting language" and "programming language". 
It always makes me laugh when I hear students complaining about the incompetence of their teacher. Did you ask him what motivated his judgement instead of judging him? You would have learned something (at the very least, you would have learned more about your teacher). It is possible your teacher considers Javascript is lacking some essential features "real programming languages" should have, and he wouldn't be alone to think that. Or he might consider Javascript as a "mere scripting language" because of its usage in web pages. And JS started as a mere scripting language, with no doubt, so it doesn't come from nowhere. A scripting language is a language which is made available to users so they can add functionalities to a software. A scripting language can totally be a "full-fledged" programming language. It is not necessarily (although it often is) a difference in nature, but a difference in function. Javascript is provided to developers within the browser to enhance web pages, so it makes complete sense to call it a scripting language, except that when Javascript becomes the main interest of the "web page", when you make a "web app", which you can even compile to release a desktop or mobile app... does it still make sense to call Javascript a scripting language? The boundary is blurry. Maybe it does, because the DOM is not part of Javascript, it is not a library either... I don't think it this easy to deliberate. Historically, interpreted languages were assumed scripting languages contrary to other languages which require compilation (and would make terrible scripting languages because it is not at all convenient to recompile a software in order to extend it). That's another way to interpret your teacher's reaction. Don't get outraged so easily. Ask questions, it could give birth to an interesting conversation.
Of course Javascript is a programming language. The whole categorization of languages into scripting vs compiled language is pretty outdated if you consider that C# is compiled to an intermediate languagewhich is then JIT compiled to bytecode at runtime and that JS is actually JIT compiled as well by modern JS engines/runtimes. So the restult is that pretty much all modern high level languages can be considered hybrid languages.
If you still care, I have fixed the bug. It got delayed due to my exams.
really nice article, I tried them all and it work, except for hack n#2, I think I didn't understand how it works, could you please elaborate more on that??
Hey! thank you very much for posting this... I just wanted to ask if you know about other React courses I could take.. there are SEVERAL online, but I'd love any recommendations, and I'd really love to end December by knowing how to build cool stuff on React. Thank you very much! 
Good work!
It sounds like you're recreating [Ansible](https://www.ansible.com/get-started).
Promise.all returns a promise which will resolve to an array holding the resolution of each promise passed as arguments. await will delay execution until the promise resolves. Destructuring will assign each resolved value in the array to a variable.
Hi there! I agree that there are tons of React tutorials out there - this Christmas calendar is going to give you tons of tips, but if you're out to learn a bit more basic stuff, have a look at the official docs, as well as Egghead tutorials and even survivejs.com :) Best of luck with your learning!
It sounds like your next step is learning how to use a modern view library (i.e. React, Vue), and a transpilation tool like webpack. It's not so much about a specific concept like object literals, which are fine in terms of declaring an object, but not great as a means of structuring an entire application. I think your concerns will be addressed if you learn (any of the) modern methods of structuring a front end application.
I always struggled to understand the difference between an interpreted (scripting) language and a compiled one. I found this one answer in the stackOverflow forum: https://stackoverflow.com/questions/2657268/whats-the-difference-between-compiled-and-interpreted-language. I understand now what a compiled language is, but still have a hard time with the interpreted one, here's the answer: In an interpreted implementation, the original program is translated into something else. Another program, called "the interpreter", then examines "something else" and performs whatever actions are called for. Depending on the language and its implementation, there are a variety of forms of "something else". From more popular to less popular, "something else" might be ==&gt;Binary instructions for a virtual machine, often called bytecode, as is done in Lua, Python, Ruby, Smalltalk, and many other systems (the approach was popularized in the 1970s by the UCSD P-system and UCSD Pascal) ==&gt;A tree-like representation of the original program, such as an abstract-syntax tree, as is done for many prototype or educational interpreters ==&gt;A tokenized representation of the source program, similar to Tcl The characters of the source program, as was done in MINT and TRAC. At the end of the day, both categories of languages are used to make tasks automatic, and that's programming.
Eggheads [react-fundamentals](https://egghead.io/courses/react-fundamentals) was fantastic. Goes through a minimal build setup to building components, composition, lifecycles, etc. Takes an hour and you know react. [Getting started wit redux](https://egghead.io/courses/getting-started-with-redux) is also pretty much, but that's for later.
Thank you. I am casting about for what is next on the learning list. I have added the subreddits for vue, reactjs, and angular to my list. It is good to know that I am on a solid track. As the sole developer I have a great deal of power to structure as I like, but I lack peers to just sit down and talk shop. The last developer I had working with me was just a punch-in/punch-out. I had to pick up his code afterwards and it was a glorified mess of special branching, magic numbers, duplicated code everywhere. A real head-scratcher while I unwound it. I am determined to not leave my code in that shape when I move on to my next job.
[removed]
[removed]
In assuming many of the devices are network devices, so all the scripting has to be done from a host, not the far end.
The company list reads like an obituaries section.
I've developed a couple of apps that support both shadow dom and shady dom. Here's what I've found. I have only found one for-reals bug in shady DOM, in shady CSS specifically, WRT to parsing quoted strings containing the `-` char in attribute selectors. I was able to work around it by using a unicode escape sequence. Other than that the only bugs have been in my code, usually when I forget to use the shady dom api, or ignore the fact that shady dom manipulations happen asynchronously a microtask later than bound data updates, or some other shadow/shady compatibility detail like that. I am not trying to support any particularly old browsers though. In my experience shady dom is not inherently slow. It's just a thin wrapper around the platform css/dom API. There's no reason to think it's any slower than react at, say, `appendChild()`. A lot of the slowness comes from slow browsers. Firefox was a dog until 57; now it feels a little faster than chrome, even when FF is running my app in shady dom and chrome is using native shadow. The difference disappeared. Also people just write shitty apps. Unlike, say, react vdom, web components have no system to enforce efficient dom manipulation. You can do whatever dumb slow synchronous thing you want. Efficient web components are written to make large expensive DOM updates asynchronously to maintain interactivity. The reality is that, in the right hands, web component based apps, even in shady dom mode, can deliver an **interactive** user experience, not just a pre-rendered page, in &lt; 2s.
billmalarky here, for some reason automod keeps deleting my comments saying I'm using a "url shortener" even though my comment doesn't even have a link... I've messaged the mods and hopefully I can actually answer questions when they resolve this! 
That's great, sounds like you have good standards for code quality already. I'd recommend looking at looks of example projects, since there are many different ways to structure your application, even within the same stack. Next.js and Nuxt.js might be an interesting thing to look at.
at the very least, he connects to a machine on the network that then allows him to run commands to the managed machines. A script dropped on that master machine could run the script and probably email him the results. It sounds like his current process is to ssh into the master machine, run something in the CLI for each of the machines he needs a backup from, and then FTPs onto those other machines to retrieve it. If he's using SFTP, he may be able to SSH to those machines themselves. Obviously, it'd be safer to toss something on the master machine and not risk fubaring the other remote machines. My point is only that using JavaScript to create a complex GUI may be more work than is necessary. He could create a simple node.js program to run the commands every 24 hours, or an even simpler python script.
Sorry it may sound like I try to appropriate work of others but I did not write that article, I just read it and liked it so I shared with you :) About the question someone already explained how it works :)
[removed]
Drop him an email asking him if he could elaborate on his point, before calling him out as incompetent.
&gt; ‚ÄúAT&amp;T‚Äôs support for JavaScript is more than support for cool technology ‚Äî it is support for an open standards process. Open standards are and will be as important to the success of the Internet as open connectivity.‚Äù üòê 
Aw bummer. yeah that's pretty much a dealbraker but it looks like they're making some headway and comments on it just three days ago. I'll have to keep an eye on it
It might lint and commit the entire file but the point is I"d like to be able to partially commit a file. As OP pointed out though, looks like its an open isssue
 Ôº≠ÔºµÔº¨Ôº¥Ôº©Ôº≠Ôº•Ôº§Ôº©Ôº°
Kinda like reinventing the wheel? 
I genuinely laughed when I read that part of the article.
You should not understand interpreted languages as scripting languages. HTML is interpreted as a DOM tree but it is not a scripting or even a programming language. A less trivial example would be the library mathJS, which is able to parse mathematical strings: the kind of code you would write in MATHLAB, only that the mathJS interpreter doesn't allow you to use control structures or create your own functions inside the strings you parse (you can make custom functions available to the interpreter, but you would have to write them in Javascript). This is too limiting to call it a scripting language, and yet it is interpreted (with a tree-like representation). When I say it would be too limiting, I mean that if you were to allow users to write code interpretable by mathJS, they wouldn't be able to do anything more than calculations. Many parsers like syntax highlighting parsers rely on tree-like representations. You can definitely call these "interpretors", but they don't execute the code, so you can't call the parsed code a "scripting language" in this scenario.
&gt; Time and time again JavaScript is crowned the most popular programming language in the World. Oh holy crap the level of crying in r/programming about JavaScript. Those guys are really expecting WASM to replace JavaScript with something else and without any expectation they will have to write asynchronous code, callbacks (promises or whatever), presentation, network requests, or anything else. Sooo much crying over there.
None of the examples and demo work on Firefox
Yup... üòë
thanks :)
Well, i will choose webassembly then. But i havent heard much about it so..
Ignore him, arguing about languages is pointless.
I hate to say it, but "adolf hitler" is right 
14'000% growth for Vue, astounding. Is it reasonable to expect a lot more Vue positions to be created in the near future?
None of those comments are about the language itself. They are all PR fluff pieces centered around those companies. The GIFs add nothing except page weight. &gt;The creation of a general, standard scripting language for Java development [...] Ugh.
% growth is meaningless when starting from such low numbers. If you have 1 download and then next month 2000 downloads that's 2000%! But it's still a relatively small number. I'm not saying vue isn't growing or whatever. Just you shouldn't base much on % growth when the starting point is so low. If you were to look at % growth of angular from February to April it has like a million % growth. Actual numbers show vue is still pretty solidly in 3rd place of the big 3 according to npm statistics. That's far more important as much as any of these npm download numbers are significant.
He could do that, but like other people have mentioned he would basically have recreated Ansible, except with way less features. It seems to me that the GUI could be a unique wrinkle on the idea that might make his project catch on, if that's what he wants.
&gt; I always struggled to understand the difference between an interpreted (scripting) language and a compiled one. That's an implementation detail. There are interpreters for C. V8 (Chrome's JS engine) didn't have an interpreter until recently. It generated native code right away. Dart is also what most people would consider to be a scripting language, but you can AOT-compile it.
If programming had hillbillies they would be found there. 
yep, I understand that now, this confusion is part of my overall struggle especially that I had to study it in english which is not my native language. thanks for adding more examples.
I mean, it‚Äôs JavaScript... the most popular programming language no one bothers to learn.
I am pretty new to Git, having mostly lived in the MS and Embedded worlds. That is a good idea to just pull down a bunch project files.
I think I'm more fascinated by the Douglas Crockford article sourced by the Twitter post near the top of the page: http://crockford.com/javascript/little.html That Y-combinator specifically wows me. With arrow functions, that could be written on one line as: ``` const Y = le =&gt; (f =&gt; f(f))(f =&gt; le(x =&gt; f(f)(x))) const factorial = Y(fac =&gt; n =&gt; n &lt;= 2 ? n : n * fac(n - 1)) ```
My favorite quote: "Javascript was created to make the monkey dance"
&gt; ‚ÄúThe creation of a general, standard scripting language for Java development will accelerate adoption of this new, exciting technology for delivering dynamic, live content to the consumer. Metrowerks will support JavaScript as part of our effort to deliver tools for Java as the programming platform of choice for new Internet development.‚Äù Wow, the Metrowerks guy really got the wrong end of the stick there.
Learning it doesn't make it any less shit, though.
There's nothing particularly unpleasant about writing asynchronous code given the right primitives.
Minimal example with dummy async operation: function delayed(value, ms) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(value)) ); } (async function main() { let [a, b] = await Promise.all([ delayed('A', 50), delayed('B', 100) ]); console.log(a, b); // A B (logged after ~100 ms) })();
Your computer is built entirely from reinvented wheels.
&gt; function delayed(value, ms) { &gt; return new Promise(resolve =&gt; &gt; setTimeout(() =&gt; resolve(value)) &gt; ); &gt; } &gt; (async function main() { &gt; let [a, b] = await Promise.all([ &gt; delayed('A', 50), &gt; delayed('B', 100) &gt; ]); &gt; console.log(a, b); // A B (logged after ~100 ms) &gt; })(); oh niiiice thank you so much!! this is much better :)
Yeah learn git, use github extensively, and npm/yarn for packages!
Forgot to actually pass "ms" to "setTimeout". So, it actually defaulted to 0. Heh. I fixed it in the snippet above.
Not really, the announcement itself says "JavaScript as a compliment to Java"
&gt; Whilst BrendanEich was hard at work creating the now much loved language some twenty-one years ago much loved? that's highly debatable...
Yeah, in the guy's defence this was pretty common thinking at the time.
Is it vote ring? it's not even javascript :/
it doesn't sound like he needs a lot of features though, or a GUI. This is a problem that could be solved with less, and give him a little experience with languages other than JavaScript.
ok :) thanks!
Never heard of Ansible, looks cool. I‚Äôll have to check it out! To elaborate a little more on my situation, I‚Äôm a cinema technician. (Username checks out) Most every device I work with has either it‚Äôs own set of CLI commands available through something like putty or telnet. In the example I mentioned, that would be a cinema server (or player). ‚ÄòBackup‚Äô is just an example, but there are tons more. Retrieving logs, running an upgrade (after putting it on the server via ftp), rebooting, etc. Another device, for example, would be a digital cinema projector. Most of these come packed with their own API, and that‚Äôs where the real magic would be. Most devices have vnc as well, but in regards to my job, I would love to be able to deploy a batch of commands, like ‚Äòbackup‚Äô or ‚Äòupgrade‚Äô to all like devices in a theatre. It would take a lot of work no doubt, I‚Äôm just driven by the fact that there is nothing like it for what I do, it would save time, and I enjoy programming. A GUI makes sense to me because I would want it to be a dead simple procedure, and all in one (one click, file upload-download prompts, etc.) The projectors are cool because you can control the lamp, channels, douser, and so much more. Key features of the project, that my be useful to the community, would be the GUI sitting on top of a boiler plate. Type IP / hostname here, type username-password here, port number, baud rate, etc. the guts of it all would be specific to what you were wanting to control or communicate to obviously. Buttons that perform predefined serial commands. Maybe even an editor that allows you to edit the string commands and test them out without having to hard Code them?! Basically a starting point for anything that you can putty or telnet into.
Yeah, holy shit. JavaScript is far from a perfect language, but all the folks declaring that JavaScript is now dead thanks to WASM are seriously deluding themselves. People forget the "script" in JavaScript - it was invented to be an easy scripting language for web pages. What takes a single line of JS code to accomplish would easily take dozens if not hundreds of lines of WASM - and that's if it's even possible at all right now (there's no direct DOM access in WASM right now, which already makes it pretty much useless for simple things like setting event handlers on HTML tags). WASM will have its place for performance critical code, but it would be a major pain in the ass to actually perform normal web development with WASM or WASM target languages like Rust. Plus, using non-JS languages to write scripts for websites is nothing new. There's a plethora of "compile-to-JS" languages out there, most of which even provide access to the browser APIs that you need to do anything remotely useful in a web page. 
Thanks. I want to reply to so many interview questions with the Harrison Ford "who gives a shit?" gif. When they give you a piece of code where a closure loops through inherited properties and patches the prototype of a different class inside a setInterval, and what's the value of `this.prototype.x` seven seconds from now?
Agreed. More fun is the calls from the people to replace the DOM with a widget, menu, or tool completely ignoring the DOM is an architecture.
.‚Äã
This is an old article from 2012. JS does have actual maps now. There is also Object.create(null) for creating an object which doesn't have any keys. So, that's something you can use if you want to, say, count how often each word occurs in a text. &gt; 'toString' in {} true &gt; 'toString' in Object.create(null) false
Many people agree with this, some have even ditched ESLint completely in favor of Prettier, even though they don‚Äôt serve the same purpose, they just have overlapping capabilities. I tried Prettier and didn‚Äôt enjoy it that much (another blog post coming). Partially because lint-staged can‚Äôt do partial staging yet (I know lint-staged isn‚Äôt related to Prettier, but IMO it‚Äôs the best way to enforce it). But also because people shoule still have the freedom to format some aspects of the code as they like, instead of leaving subjective visual decisions up to a tool. I‚Äôll give Prettier another go later, though.
We had to broadcast the output of a 360 camera that used RTMP. We used ffmpeg server side to turn that into HLS on the fly. HLS is much more front end friendly. Over in the front end, we used [three.js](https://threejs.org/examples/?q=video#webgl_video_panorama_equirectangular) to do the 360 illusion - if it's a normal video, just the canvas' context.drawImage function would be enough.
[removed]
[removed]
[removed]
Yo, been stuck on this for about a week now... please tell me where to put launchRocket(321)... Thanks
That's a completely different AT&amp;T than the one that exists today. Todays' AT&amp;T is a conglomeration of 3 different parts that were broken off the original "Phone Company". They went thru a transformation from local phone carrier to international telecom, and then sucked down remaining vestiges of the failed, shrunken and enfeebled original "Phone Company". The Phone Company's "Bell Labs" is responsible for a non-trivial amount of telecom tech today. Whether they were the original patent holder or merely refined the shit out of it, that company was the mindset behind the statement in the article. A completely different company *in all* ways.
[removed]
Where would I have to put this? I have been stuck on this for about a week now and havn't had luck. Thanks
YOUR OPINION IS WRONG. (/s, do i have to put /s?) I see this opinion all the time. And then when the person goes and backs it up with reasons why they say that, they're usually responded to with points that show that the original opinion is based on a thin understanding of JS. I'm not deriding you in any way, I'm making my own observation. JS is not without it's warts, but I quite like it. Also, and probably the bigger point, ANY lang is shit if it's the wrong tool for the job. Why would anyone use JS for an embedded system?
What the downvoters probably don't get was that this was #***THE*** mass-market computing buzzword of the 90s.
Yes, it was common thinking *amongst people who had got the wrong end of the stick* (i.e. non-developers).
While in the other corner we have : [Just say no to more end to end tests!](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)
&gt; I quite like it Why, what makes it preferable to any other language? I can't think of one single thing it does better. It's about as good as you'd expect for a language thrown together in a few days. &gt; ANY lang is shit if it's the wrong tool for the job That's a pretty weak defense. Misapplication of something doesn't make that thing bad. &gt; Why would anyone use JS for an embedded system? I ask myself the same question, but still we have Tessel and Espruino. 
Ah mate, maybe you're overthinking it? If when you inspect the page, you click on the tab console- it's like a games console, right? So like entering in a cheat code, try and enter in the launch code.
Thanks for the input, would you know how to use html and javascript to use the phone's camera?
Unfortunately `switch` and `switchMap` will already switch to the second observable once it arrives - no matter which result actually comes first. This may not always be intended ... It would be nice if there was a `switch` that would switch when a later observable produces its first element and not instantly when that observable arrives...
&gt; Why, what makes it preferable to any other language? `shrugs` It's preferable because I like it. I didn't say it was better, I just said I like it. &gt; Misapplication of something doesn't make that thing bad. Nope, but it makes it shit for whatever you're doing. It seems you're trying to prove something. I got nothing to prove. I like js (and python too, for that matter), it works for me, and it works for a lot of people for the things they want to do. Just because you don't like it, for whatever reason doesn't, make it shit. May as well be arguing about your favorite color.
I'd like to see an equivalent article for Flash, Active X, and Shockwave.
Javascript is not going to be obsolete any time soon, no. It is being used more and more every day, not just in browsers, but for webserver backends (node.js) and fully native mobile apps as well (react native, nativescript). Your friend is completely 100% wrong. If I had to place money on which would die off first between javascript, c#, and python, I'd honestly have a hard time before finally settling on c#, and it will be many many years before that happens either.
It was common practice. JavaScript interacted with Java applets. So a big sale was Java applet devs could integrate better with the website as a result. For example, an applet with some ugly animated flaming text could have the text and colors modified without recompiling the applet. This was a really popular use of it unfortunately.
Javascript is definitely not dying... 
lol got to the second section, then it started to become a math test...
&gt; There are even some efforts to just use a canvas, and say screw browser/os meddling. And accessibility,
Will do, thanks ... I stumbled upon it but the [demo](http://sheetjs.com/demos/table.html) didn't include styling so I moved on. Thanks again, will try it as of tonight
Even though it's ECMAScript, the name JavaScript coming in later. 
Modern JS written in TypeScript is really fun. I cannot write vanilla JS anymore, it feels too unsafe. I know i will mess up at some point. Tests would catch some/most of the issues but not all of them. I really like the fact its just a superset with types. Nothing more, nothing less..
http://lmgtfy.com/?q=js+use+iphone+camera
Not so fast! I have seen it used in the early to mid 2000s. Long live legacy!
This is not good, really. The design of the starting page is just annoying. You get a big centered button urging you to _Start_, but right below it a smaller text telling you you shouldn't really start, you should read the instructions. If you do scroll down to read the instructions, then you'll have to scroll back up because there's no button at the bottom. But that's just annoying, nothing more. What makes this not good is the test itself and the total lack of validity of the results and the conclusions one could naively take from it. First there's no information **at all** about where this comes from. Who did this? Is it just a guy, bored at on a Thursday evening? Is this done by a recognized and well established education organization? Is it backed by anyone at all? Not only there's no explanation, no about us section, but there isn't even a small footer with a copyright notice or a link to further information about this. Incidentally, the page is actually illegal in the EU. Not that I care, but it is. I should also mention that calling this an "exam" rather than a "test" or "quiz", makes it appear that indeed there's some sort of organization behind it, some kind of _validity_ to it. But no, there also no assurance on the origin, quality and method of the test. The final paragraph _claims_: &gt; Designed as a tool to assess a JavaScript developer's aptitude, The JavaScript Exam comprehensively evaluates knowledge across a wide range of understanding, differentiating certain levels of knowledge and skill with precision. It assesses both general knowledge about JavaScript and a developer's ability to work with it in order to solve problems, and attempts to offer a thorough (lengthy 100-point) examination of skill level. So, it _claims_ comprehension and precision in determining a developer's _ability_ and _skill level_. The only reason for such claims is covering "a wide range" of understanding and being thorough because it's _lengthy_ "100-point". But this means nothing, really. Have these questions actually been contrasted with knowledgeable people? Who knows. Do this questions really represent such a "wide range"? I, personally, don't think so. It's just my opinion, but then again I can assign anything better to the test than "some person"'s opinion either. Does being _lengthy_ give any guarantee at all of being better? No, clearly not. Then there's the test itself. The first part consists of a number of questions that go from the somewhat reasonable to the stupidly useless. Some of these are the typical questions that when being asked in an interview I **have** to answer with: "Is this the type of code you write? Because it is I don't want to work here". They are not the worst offenders out there, luckily, but they _are still offenders_ in this camp. A clear example is the one on `n++ - --n`. Others are at least debatably imprecise. The wording, either on the enunciate or on some of the answers is _a tiny bit off_. Maybe not much but enough to generate doubts. And not doubts about the examinee's knowledge, but doubts about the examinee's understanding of such wording. The second part is not multiple choice but requires you to write code to solve some problems. There are some _annoyances_ here. Most relevant is the fact that you don't know exactly how the code will be evaluated. You can write some code to test the code you wrote ("but remember to remove it later!!"), but no information is given as to how the final code will be run and judged. Will a real person read it and go through it and then give it points on various merits such as legibility or cleanliness? Will it just run through a battery of tests? If so, _which tests exactly_? Because some question do have some sample cases but others do not. LEt's take the one about prime numbers. Is the examinee required to give a solution that works for incredibly large numbers? Or just up to, say, one million? Maybe up to one hundred? Also, how is each question's worth determined. Why is question #14 worth 2 points and questions #8 and #2 only worth one, when the approximate complexity is mostly similar? ---- I'm sure a lot of people will take this _"exam"_. They may even find it _fun_ to do it. I don't mind that. But I find it quite disingenuous and misleading to attach to it any claims of fitness for any purpose other than _fun_.
&gt; many developers just want to be able to interact with the users in a standard way and not have it look weird, which is still a pain point in the web That's true, but only because it's a fundamental misunderstanding of the nature of the web, and precisely *why* it's now defeated all direct competitors, and is possibly in the process of gradually eating the entire software UI industry. Everyone wants to be able to quickly hack up a UI for their desktop website. And everyone can think of an easier way to define a UI that works on mobile. And some people want to be able to easily define UIs for larger screens like wall projectors or shop displays. And loads of people want to be able to define a UI that's discoverable and accessible to disabled users. And some people even want to be able to be able to output their UI in the form of a Braille keyboard, or a text-to-speech vocal output. But if you want to have a unified UI that handles desktop *and* mobile (and everything in-between) *and* wall-projectors *and* is discoverable/accessible for disabled users (including "disabled" users like search-engine spiders and automatic translation tools) *and* can be transformed into Braille or spoken-word *and* can be easily styled to produce program UIs *and* documents *and* free-form graphic design problems like marketing websites... well, then it's tough to define a system that's as flexible, usable, adaptable *and substantially easier to use* system than the DOM. Don't get me wrong - the DOM **API** is dogshit, and should have been phased out years ago - the length of time it took to even get something like XPath or querySelectorinto browsers was abysmal all on its own. Nevertheless, the DOM itself (and its various layout systems) and the separation of HTML, CSS and JS are the way they are because they're solving problems that 95% of the people criticising them **aren't even aware are problems**. Most people are basically taking an omni-medium boat-car-plane-rocket-timemachine that can take them to nywhere in the known universe and criticing it because *they* only want to take it down to the shops, and a go-kart would have been be easier to drive for their specific, tiny, trivial use-case. &gt; There are even some efforts to just use a canvas, and say screw browser/os meddling. Yep, exactly. If you don't understand why (specific use-cases like games aside) defining UIs entirely in the canvas is practically the biggest, most appalling misapplication of web technologies you could possibly conceive of, then sure - it probably looks like a great idea. In the same way that if you know nothing about cars, it probably seens like it makes sense to rip out the gearbox and drive everywhere forwards at 5mph because that whole shifter and gearbox thing looked far too confusing and inconsistent between car models to be worth understanding or bothering with.
Much loved, but *also* widely hated. Or to put it another way, "divisive". ;-)
We get it, it's just that it adds absolutely nothing whatsoever to the conversation.
Reading the comments here, I fully expected all this sarcasm. Were you even alive back then?
I am in no way trying to warn you off of Angular. On the contrary I think they made a lot of really great design decisions when creating it. But I will warn you that Angular is *heavily* focused on the spa use case. That explicitly means *do not render views on the server*. You will struggle endlessly trying to get Angular to play nice with html you serve into it. The spa design means that your server should *only* be sending some sort of data format, usually json, to the front end and then the Angular app uses that data to create the views itself. So if you already have a server that is rendering html and then serving it to the client Angular is probably not a good fit for updating your front end. React and Vue both currently fit that use case much better. But like I said, I do think Angular has a lot going for it. So if you want to mess around with it feel free. Start with the cli and go nuts. But don't expect a good experience getting Angular to play nice with server rendered html.
I'm only replying as the submitter rather than one of the sarcastic commenters, but I still remember downloading Netscape 2.0 and hanging out in comp.lang.javascript in 1996 :-D On the flip side, I imagine I'm on the older side in this group..
&gt; This is an old article from 2012. JS does have actual maps now. [And here's an article from the same author/blog about the new Map function](http://2ality.com/2015/01/es6-maps-sets.html) 
thank you!!!
thank you!! :D
If you know JavaScript very well, you'll know that some of the questions, when thought of in an abstract sense can be answered correctly with multiple answers, which is when this test becomes nice but pointless. That's the beauty of JavaScript I guess.
That means that Angular is not going to play well for all of the existing code base that I inherited. The vast majority of it is ASP.net/C# code - Master Pages, User Controls. I wrote most of the SOAP and Rest calls that push up data, but there is some pretty heavy server-side manipulation. I could use Angular to deploy some new stuff, but I would hate to put too many different irons into the fire. On a previous job I had to corral a code base that was bent around F77, C, Lisp, ASP, and Java. Each programmer over the years wrote in their comfort zone which meant it increasingly became a mess. I was popping Tums by the bottle, but when I left it was down to only Java and ASP - far easier to replace me when I left. Thanks for the heads up. The funny part is that probably a good 60% of the applications would be considered pretty much SPAs as they are small tools used by various internal business entities. Custom time tracking, job costing, estimating, accounting, inventory, etc.
[removed]
It's not stagnating. It's JUST been supported by all browsers and if you care about IE like most do it's still not an option.
This exam would be useful if it scored each answer right away. But for the length, I don't trust the scoring. Also, being able to use JS to work the the DOM is not the same thing as knowing JS.
Yeah I don't think Angular is a good fit for retrofitting old apps. It's really for new app development. At the very least even if an old app was a json api separate from everything else you're still basically talking about completely rewriting the front end.
Fair point, but people build houses with shit just fine when they understand the properties of shit.
While I agree with parts of your comment, I think you are being a bit harsh here. Of course these types of tests are primarily designed for fun, I think you are just taking it way too seriously and are getting caught up in semantics (is this a quiz or an exam?) while missing the bigger picture. It has a dual purpose, first and foremost it's for recreation (did the layout, the ebullient designs, UI of the site, and just the overall "cute" vibe not give you that impression?), and secondly and perhaps even in a lesser way it helps the user see how well they fare relative to others who have studied JavaScript. I am not particularly interested in knowing how 'standardized' the questions are, it's not like I'm taking an entrance exam to be admitted to some prestigious institution, nothing about the site gives me the impression that I am either. I agree that some of the disclaimer (the text right under "Purpose") can come off as too "authoritative" in some regard, but doesn't the user not want to go into this test with some intentness as well? Because you seem to suggest that this test should not be taken any more seriously than those PURELY-for-recreation-value "Take this test to see what your favorite colors, foods, etc say about your personality!" quizzes that litter the landscape, and I think that's a very unfair characterization. I should also note that I scored low on this test (but relative to others, quite well... no one got Gold yet?), but rather than going on a tirade I took it as meaning that I still have long ways to go. 
Having used some of these resources very recently (specifically that JS Dude, the site is pretty good despite being incomplete). I can safely say they are definitely for up to mid (and they must be good since I got multiple offers using these guides) I would also throw in Javascript: The Good Parts in there. I would also recommend including sites with challenges like Hacker Rank; the beginning stuff is fairly easy, but the mid-tier stuff has come up on interviews; plus, its good practice for problem solving skills. 
As is the SCSS and grid system I use. ;) 
All hail the fiber gods
So is my DNA. ( Õ°¬∞ Õú ñ Õ°¬∞)
To be honest, I think Javascript: The Good Parts is a bit dated now. I debated putting it on but feel like it's past its prime.
This article isn‚Äôt wrong, but most CRUD apps shouldn‚Äôt be concerned about things like transpiled code not performing. If you have unperformant code, it‚Äôs likely bad code and not bad tooling or Babel being bad.
Well, compared to C# or Java, it has proper first class functions, not just class methods or lambdas. Not everything has to be inside a class. Module imports instead of everything being a global. Not sure how much longer something like this would take to write in Java or C#: `const foo = {a: 1, b: 'xyz', c: x =&gt; x * 2, d: {}}`. Being able to write arbitrary structures is quite powerful. Then if you want types add Typescript or Flow for a better type system than C# or Java. Granted there are plenty of other languages out there, but those are the other big two that are often considered superior, yet have significant productivity issues compared to JS.
[removed]
Well, TypeScript is a bit more than types: it's also a compiler, and adds a few more things besides just type definitions, like `@decorators`, class modifiers (ie private protected etc), namespaces, mixins, and a few others. It definitely is a superset of JS, but it's quite misleading to say that it's nothing more than just types. In my opinion, [Flow](https://flow.org) is the definition of "a superset with types. Nothing more". Flow doesn't ship with a compiler, it relies on babel to strip the type defs. It doesn't include any other non-standard features, if you want decorators or namespaces, you'll have to get that from babel. 
Part of me thinks it would be funny if someone just started saying they would support it but had no idea what it was.