Same way I and most of the other agencies and companies I know test any front end knowledge. A simple design to code test using only html, css and js (with jQuery). No frameworks, no CMSs.
&gt; For the sake of simplicity, we assume we adopt mustache syntax in our standardized template language. If we're going to standardize templating features in HTML, you'd think introducing actual new HTML elements would be the way to go. Something more [like this](https://github.com/rooseveltframework/teddy/) than mustache would make far more sense than a completely new language embedded into HTML.
My point is that "I wouldn't bother with Promises" is nonsensical when the feature you're suggesting as an alternative literally requires Promises.
&gt; Your React app isn‚Äôt finished yet: get it working first! On no planet is this good advice. Do it from the start, otherwise you‚Äôll make a ton of assumptions in your code that you can‚Äôt make when your SSR. 
This is a proposal for an entirely new feature that has yet to be implemented. Chrome doesn't and by definition can't have it.
Looks like they only have Mac/Linux/Windows App. I was hoping something i can just deploy on Heroku or host it on any server.
2 things: 1) Are you saying it didn't take years for those things to be implemented? 2) Say it with me "I fear new things". Once you say it out loud, you'll understand why 'people' shit on the parade.
Not sure I like that link you posted. I do think there is a time &amp; place for this, I just don't think apple is the right group to propose this change / update. Also I think there needs to be more browser-templatability. Such that what are defined as templates are dependent on what say a user sends to the browser. Let users configure the browser via headers sent to the client. Then it bootstraps right away, without having to wait, and then we can select a few template rendering modes. This is a w3c spec type conversation atm.. It will need atleast 6months to 1yr if not more to come to a community agreement on what the best approach will be. 1 thing for sure is that microsoft should have no part in this conversation since they invented IE5-edge, and edge still has major issues. They're not fit to be making any kind of decisions.
Looks like CFML! 
Please explain me, why does one need this feature if it already is a lot more convenient to write an app using ond of frameworks, that provide a lot broader api and set of features? I mean, it might be better in terms of performance, and also frameworks can gain additional performance by generating the template html, but I still don't see the reason people are so obsessed with these template html and web components. Seems to like its a step back if you use it directly.
The advantage of doing something seemingly silly looking like that or like return await promise; is that it adds to the stack trace in case of an error. Without `await` that won't happen.
If I'm hiring a Junior Developer, I'm not hiring a skillset. To me, I care more about that persons personality and willingness to learn. Proof that they push themselves to learn is what I really look for. Ultimately all skills / frameworks can be taught by any of our intermediate or senior devs. I think most companies make the mistake of asking for "Junior developers" when really they want Intermediate Devs who can just pick up a project and start working no problem. My advice, prove you push yourself to learn, and accept the fact you know nothing. You will learn faster on the job than any school ever prepared you for. However if you must have a list of skills, here you go: * Javascript - basic programming fundamentals * HTML * CSS - You don't need to know everything, or every browser bug. * SASS/Stylus/LESS etc is a plus, but not a requirement, it's hardly different to CSS. Stylus is my personal recommendation. * React/Vue/Angular etc is a plus, but again not a requirement, knowing core Javascript fundamentals is far more important. * jQuery - we don't actually use jQuery every in production anymore, but it's still something you learnt, so I respect it. * Clean code - super important to me personally, I always look for this. * Problem solving ability - Being a junior develop, hell any developer, is becoming a wizard with Google. Things I would never expect from a Junior: * Unit Tests * git (most juniors never had to use it, if they do know it, they don't use it correctly) * Async / Promise knowledge * Working with APIs * Working with deeper browser apis (geolocation, video, audio, webrtc, etc) * Observables / RX * Webpack * Redux / Vuex / etc. * MVC / MVVM / Flux * SQL / NoSQL databases * PHP * Server config * Tooling config
[Strapi](https://strapi.io)
i read up on this tonight and would love to see a native hello world with esm importing something like react if possible! if you have a repo i could peruse i'd greatly appreciate it, as i think the closer we get to universal modules across server/client the more fluid js dev will be!
&gt; Are you saying it didn't take years for those things to be implemented? Most browsers that people use are evergreen it's entirely possible now to have something out and useable in a time frame measured in months rather than years because you don't have to wait for end users to buy a new PC to get the latest version of Windows and therefore IE. 
As a lead developer i dont even look at knowledge on a junior position other then html and css, tooling and techniques differ from company to company so what i look for in a junior is mostly the correct attitude and mindset in order for them to succeed. Then its up to me to mentor them and give them a path to obtaining the knowledge required for them to grow to mediors and seniors, witch is done in years not weeks or a couple of months like bootcamps like to suggest. I think the requirements nowadays are insane for people entering the wonderful world of programming and are quick to lose their enthusiasm cause the toolsets are so complex these days, most of them just wanted to be a developer to create awesome stuff and build actual working software but are demotivated by all the libs, transpilers, frameworks, preprocessors and techniques they have to learn before they *feel like* they can start developing their idea, most of them dont make it to that stage, they will just throw their hand up in the air and say "fuck it" and i think thats sad.
Wouldn‚Äôt call Node a framework. Anyway I use Node at work and we usually end up picking Hapi - like Express but far less stuff included, a lot less bloat, nice syntax and Walmart have done a great job of creating supporting packages.
that's really incredible what he did with unpkg and module loading from url... but even with him implementing http/2 for these files, it's still taking ~ 5 seconds for that d3 demo to load on every request =/ this is definitely a step in the right direction for sure
&gt; 1) Are you saying it didn't take years for those things to be implemented? Huge difference between era of IE and the near future when everybody will support only evergreen browsers.
Both HTML in Javascript &amp; template slots are specifications in progress. They even said that hopefully lit-html will be entirely replaced by the browser in the future.
But it's a step forward if those libraries implement it, because it will reduce their size and they will be using native browser feature that will be heavily very optimized.
Very enlightening! Nice read. I was surprised to see TypeScript not mentioned alongside Babel, to be honest (as although it does indeed add type-checking, that's effectively opt-in; it's just as prominent as Babel for giving people access to future JS features). Maybe I'm just being petty, though. Was expecting to see a page on Webpack! It's currently just a side note alongside React.
Es6 was finalized in 2015 and ie11 is still missing support for most of the features.
People just use babel or whatever, no on is going to drop 15% of their users just cause
ie11 isn't evergreen and has a global usage of ~3%
You can't poly-fill most of the things.
Ie 10+ automatically updates, so yes it is evergreen.
I wouldn't call them a convention. They're primarily just a noisy habit. In JavaScript, I prefer to omit them. In other languages, like Java or C#, they're sometimes required (e.g. when working with an ORM framework).
Modern v-dom isn't much more than 1-3kb. The simplest polyfill you have to ship to support older browsers will be larger.
Nope nothing special about properties named `get`/`set`, it's a valid identifier/property/method like most other things. However `get`/`set` do have special meaning similar (but more specialized) to `async` if they're immediately before a concise method definition e.g.: const o = { firstName: 'Bob', lastName: 'Dylan', get fullName() { return `${ this.firstName } ${ this.lastName }` }, set fullName(name) { const [firstName, lastName] = name.split(' ') this.firstName = firstName this.lastName = lastName } } console.log(o.fullName) // "Bob Dylan" This doesn't make them unusable as regular properties though e.g. all of these are still valid: const o = { get: 10, get fullName() {} } const o2 = { get(someValue) { return someOtherValue }, get foo() {} } // yes a method named get can even be a getter const o3 = { get get() { return 12 }, set set() { this._set = 12 } } // They're also a regular old variable names const get = 12 const set = 13 const o4 = { get, set } // { get: 12, set: 13 } 
&gt; current methods are faster (and always will be) I have heard these types of narratives about web standards so many times over the past decade, and they have always been proven wrong.
seems like a human :)
The "overhead" is next to nothing. A V-dom node is a linked list, a couple of internals, maybe prototypes and class references. Nothing that would ever cause trouble. In the other thread and in others i see people make lots of claims. Yet never actually proven. If you say that a template will be as fast as a modern v-dom, say Fiber in async, then prove it. 
You made the original claim, you haven't proven anything. I even gave you a link that says that component scheduling has nothing to do with templates vs V-dom comparison (lit-html doesn't even have components). Why do you have problems distinguishing the underlying technology from the overall stack?
The fact that both ie10 and ie11 exist would suggest otherwise. IE 11 also has an end of life date in line with the end of Windows 10 support lifecycle. Automatic updates of security patches and bug fixes doesn't imply evergreen status just that it's still supported. 
Evergreen isn‚Äôt browsers that update themselves. It‚Äôs the browser that are always supported as a sliding window (3 last major versions). With Microsoft dropping IE11 from its evergreen browser list, Edge is now the only Microsoft evergreen browser. 
Prefixed as in: getSomeVal () {} Or: get someVal () {} The first is just convention, and sticking to a getter/setter patter is good practise as it encourages you to set up some protection when you‚Äôre mutating values. Using the get/set keywords is basically a formal way of implementing getters and setters, but it will obfuscate some functionality too, which isn‚Äôt always a bad thing. Using get/set to access properties enforces good convention, so you‚Äôd have a setup like the following: class MyClass { _someProp = 0 set someProp (value) { if (value &gt; 0 &amp;&amp; value &lt; 100) this._someProp = value } else console.log(‚ÄòValue must be greater than 0 and less than 100‚Äô) } get someProp () { return this._someProp } } This way, when you assign a value to _someProp you will set it as if it is a normal property and the fact you‚Äôre actually proxying the value through a function is hidden: MyClass.someProp = 50 Same when retrieving a the value with the getter: const propValue = MyClass.someProp get/set keywords can be used on objects as well as classes.
I didn't bother to reply in the other thread. You seem to have missed the point. Your link absolutely does nothing, it neither explains nor proves. The proof itself was in the Sierpinski demo. It proves how fast Fiber really is and can be. They have taken the demo and manipulated it, so that it renders a few bubbles. If they manage to render it as fast as Fiber does, no matter how they're doing it, then we're talking. Until then web-components are as slow or fast as any generic web app. Fiber on the other hand competes against native apps, not web apps. It was literally written to open up that space. 
It's not really a new language. It's pretty much a very limited subset of JavaScript, surrounded by two curly braces, and one or two new keywords. Quite intuitive, given that most people writing templates will know JavaScript, especially a really simple subset of it. Indeed, [the standard template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) use a very similar syntax, although involving only two braces and a dollar sign. Mustache syntax also has the advantage that it's clearly identifiable as being 'more than just HTML' in a HTML structure. I understand where you're coming from. In the past I've also wondered whether template syntax should be HTML style rather than mustache. And some engines like Vue and Aurelia have pursued that thought. But I think mustache still has a lot going for it. In the end of the day, though, without customisable syntax as this proposal noted, I imagine there will always be a few communities of devs maintaining their own transpile language.
Does anyone understand what they said about bidirectional binding? It's one of those features of template and data binding engines which can be super useful.
&gt; It‚Äôs the browser that are always supported as a sliding window (3 last major versions). that's a silly definition unless you think ie10 9 should still be supported
ie10 is EOL no one should be using it. Not that anyone should be using IE11 either but at least it's still supported.
I may be missing something, but I've connected my Spotify account, selected some options and then nothing happens. I can't see anything to "generate playlist" or similar
if you write something to innerHTML, all tags are closed automatically once you insert an opening tag. Write your output to an array, push the list items to it and then join the array and write the result to innerHTML.
&gt; Looks like CFML! *Shudder*
Thank you!
Edge has had 3 major versions already. Edge is the evergreen plan for Microsoft. 
I thought the windows 10 support life cycle was going to continue indefinitely
IE is discontinued. It only gets security updates. Edge is evergreen. 
Any chance you could list the starter kits and boilerplates that you have found the most useful?
I don‚Äôt fear new things I‚Äôm simply being realistic. In fact, I would love to see a standard templating system in place, I‚Äôve done this long enough to know how progress works, my statement will reflect the actual timeline. If my comment had a tinge of reluctance it‚Äôs because I work for a big N tech company tech leading fullstack Node/React projects which need to support IE11. I understand the pain of supporting older browsers while using bleeding edge tech. 
Don't pretend like you don't like your indexes starting at 1.
No CS degree and no bootcamp here and I agree. The contracts and now full-time job I got over the past year have been because someone liked one of my projects.
Looks similar to what [Ractive](https://ractive.js.org/tutorials/hello-world/) has been doing for years.
Bonus: it works in two dimensions! https://codepen.io/a8t/pen/QOjzpL (I haven't fixed the focus when you hit the right side of the window or the bottom of the page yet, but that's one line each :) )
I think grades are even more meaningless than degrees tbh, especially for universities that grades based on student rankings on a bell curve.
The main issue with your code is that the addToDo function is trying to set 2 properties of an object without an actual object. So you need to do something like this: addTodos: function(yes){ return{ text: yes, completed: true } }
You have to seed an artist, track or genre to branch off of. Try choosing a genre from the seed button at the top, then generate the playlist at the bottom. Don't worry, it took me a bit to figure it out too.
That's a different browser... 
Doesn't apprear to work on mobile.
The sites that were around in 2010 are also very different from what is possible today. What has shifted is the definition of what front-end is supposed to mean. Today it means you can pretty much realize everything, from simple sites, static blogs to complex applications. And with that the complexity of tooling also increases, just like you can't create a complex application with little knowledge on the desktop or in native toolkits - you need a lot of expertise. From all the years i've been doing front-end on the desktop and in the web, i would say that developing with the tools we have in the web is "easier." But at the same time it has a lot of surface area to cover from build tools to pre-processors to frameworks.
My observations in lit-html is that templates can get very framework opinionated fast. Thus the extensibility.
Set the values gave it a seed, first track out was beyond hype!
Author here - most of this stuff was encountered during a big refactor of the CertSimple codebase earlier this year. I turned my own notes into the article - if there's anything you think is missing, just give me a shout and I'll add it.
Never mind this apple, where‚Äôs your implementation of HTML imports (includes)?
Why are you here
I'm not sure I understand what you say about "new symbols not showing", but there are a number of problems in the code. - The code in the repo and the code in the live version **are not the same**. So the link to the repository is useless. It does contain some errors, but I will ignore them as it is _not_ the code you're actually running. I'll only say this about the code in the repo: That `wait` function is a _terrible_, _terrible_ idea. - In lines 13-17 of `script.js`: if ((ai)&amp;&amp;(occupied&lt;9)) { AI() }; update(); winCheck(); That is, you let the _"ai"_ player make its move _before checking if the human player has won_. This is noticed because when I won, an additional move from the _"ai"_ player appears on the board. (Notice that in the repo this has changed and you only let the player play if no player has won yet) - There's a problem in the `ai` function in the loop in line 66. The problem is in line 67, to be precise: `aiChoice=Math.floor(Math.random() * 6) + 1 ;`. If the `ai` function has to resort to this loop to pick up a random empty cell, but you have the _"bad luck"_ that cell `1` to `6` have all been played, the loop will be stuck there forever and the page will freeze. Did you notice it? You're generating random numbers only from 1 to 6, instead of from 1 to 9.
Put a `setTimeout(function(){ /*...*/ }, 300)` around your `alert`s. Would be better if you build a GUI element to indicate wins.
Yes the site has an older version of the code. The wait function is a way I tryed to fix the problem i wrote about and forgot to take out. I havent notixed the random numbur problem, so thank you for pointing that out. 
Thnks , i'll go and try that
Thanks for the heads up. Works on Android Chrome (galaxy s8). What's your phone? I'll figure out how to make it work.
Thanks for the response. I have added the Typescript as part of the "Types" section. I'll make Webpack more prominent.
When you want people to spend time helping you, you should at least take the time to use a markdown code block for your code.
It worked !!
No, it totally takes years, but 1) Years pass by faster than you think 2) It doesn't mean it's any less awesome. Standardization takes time.
Chrome on iOS, iPad
Hi /u/mdmccarley89, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/hevestuffman, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `certsimple.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [certsimple.com](/search?q=%28and+site%3A%27certsimple.com%27+author%3A%27hevestuffman%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|15|75%
I see. So it falls back to a jump scroll, right? Just noticed it does on my Mac's Safari as well... Guess the .scrollBy() method (which doesnt have the best documentation) isn't as well-supported as I thought!
Any connector for a swagger spec?
Hi /u/khazha88, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/matthewfelgate, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/TimeLordofWInterfell, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/funky_bbq, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/DenuvoHater332, For javascript help, please visit /r/LearnJavascript. Thank you!
I wish they'd finally realize the solution isn't too add more to the kitchen sink, but to decouple the layout and rendering model from the document parts. They keep putting applications inside documents instead of the other way around.
Ack will do. üëç
Because nothing can ever be deprecated, or upgraded in a modular way. Every single mistake is backwards compatible forever. This in itself should be a giant red flag. The web wasn't great when we had plugins and applets, but at least you could extend functionality organically and in a contained fashion. Now we have to rely on the generosity of a handful of enormous vendors to evolve this medium, which is slowly but surely becoming the world's most complex, overengineered app sandbox ever devised. Worst of all, it's build out of second rate knock off APIs for everything. You don't have real networking, only what websockets and webrtc allow. You don't have real media, only WebAudio and MediaStream, with audio and video tags. For graphics you only have 2D canvas or 3D webgl which is 10 years out of date. WebAssembly changes nothing here, it's still just tethered to all the same "not invented here" APIs. Templating does not belong in HTML, because HTML is just a display format. It should go in the layer that drives the HTML, but which is currently not open for reprogramming and extension. That's why there's all these JavaScript frameworks in the first place.
Is there some reason --that I'm not seeing-- that the interpolation escape sequence for HTML templates can't be the same as ES6 template strings? I mean, wouldn't &lt;template id="foo"&gt;&lt;p&gt;${bar}&lt;/p&gt;&lt;/template&gt; naturally complement var bar = "Hello, World!"; var foo = `&lt;p&gt;${bar}&lt;/p&gt;`;
Node.js with Express usually does the trick for me
No. We have enough problems with adjusting to es6. 
What is example of good one?
They suck because they want to skate in with their paper degree and very little skill. With programming, you have to treat it like a way of life, a diet, a workout. It‚Äôs fitness.
&gt; This new subclass has update method, which can re-substitute mustache syntaxes (we can pick some other syntax if anyone strongly feels about) in the cloned template instance. The syntax is still open for debate. Your question is also being discussed [here](https://github.com/w3c/webcomponents/issues/688)
is it really that bad? I haven't used it in a real project yet but my contractor uses really awful CSS classnames that bother me, and I can see a benefit to a sort of standard in naming conventions. What's the cons?
&gt; It proves how fast Fiber really is and can be Ok, good for you all and all of us. I also prefer apples over oranges. Stop commenting unrelated stuff on HTML template interpolations threads. V-dom is also a related tech but component scheduling is not.
https://caniuse.com
Usage of this might be related to the following: https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior 
Because I found window.scrollBy support unsatisfactory, I used the 1st order [smoothstep](https://en.wikipedia.org/wiki/Smoothstep) algorithm and [element.scrollTop](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop) instead. [Code](https://github.com/FoothillCSClub/CSModules/blob/3902121b90626fa555123790c9a69ee4ae901cbb/index.js#L190) [Website](https://foothillcsclub.github.io/CSModules/) (I used it for the course selection buttons on the left edge of the menu.)
Good feedback. My UX design is pretty bad I'll admit. It's not entirely intuitive how to use it. I didn't think anyone else would really use it but if others start using it more, I'll redo the UX and do it right.
It's not on there. Actually, .scrollBy is supported by all browsers https://www.w3schools.com/jsref/met_win_scrollby.asp but I dug into the documentation and there's no mention of the support for .scrollBy accepting an object argument including the behaviour attribute.
I don't think it's related!
Well said! As a new Front-end developer I‚Äôve used firebase to showcase my skill set without having to worry about anything on the backend. Now I am slowly peeling off the layers of backend to have more control. Just got my first web developer position and the majority of the projects I presented were built with a firebase backend!
So it's a similar process except it works by imperatively scrolling a certain amount per unit time, where the scroll amount per time interval changes. Right? That's clever!
Why the fuck would you run your API backend in a fridge?
If you're asking /r/javascript, expect most of the answers to tell you to go with Node.js. If you choose to go that way, I think the most modern framework right now is Koa. But there's also a lot of good framework for other languages, like Spring for Java and Sinatra for Ruby.
Congratulations. Well done on the job.
Which itself is, if not derivative at least postdates https://viperhtml.js.org 
Except that you can run promises concurrantly. Await/async really make promises nicer, but not totally replace them. const results = await Promise.all([ promise1call(); promise2call()] ]).then(res1, res2) { // Do stuff. } 
ELI3
Reusable HTML. &lt;h1&gt;{{name}}&lt;/h1&gt; You can make copies of that using JavaScript, but in the copies, `{{name}}` can be replaced with whatever you want.
Damn. Bots these days.
You should probably go to r/LearnJavascript for this type of question.
We do?
I am sure you will find plenty of devs which like BEM. To me however it looks extremely ugly, but I was always a fan of using as few classnames/ids as possible. Try and decide for yourself whether you like it or not :)
The truth has been spoken. Front-end development is tilted for those reasons and the latest frameworks only add more tilt - at least that's my opinion.
Tell me, how many clients' browsers already implement it natively and how easy is it without preprocessors?
This looks very much like [Admin-on-Rest](https://marmelab.com/admin-on-rest/index.html).
You should probably go to r/LearnJavascript for this type of question
No idea, most "big" things are using preprocessors right now; for smaller one-off solutions you can just stick to ES5 just fine.
It's totally possible to concurrently await promises without Promise.all: const task1 = performAsync1(); const task2 = performAsync2(); const res1 = await task1; const res2 = await task2; 
Come on Apple let's get the basic working first. Such as service worker etc... 
so let x = `&lt;h1&gt;${name}&lt;/h1&gt;`; But they want it in the html and not js right?
The point is we shouldn't need that many layers of abstraction. Not other language had tools just to install other tools to be able to transpile the choice to a workable form. I mean, I love what es6 brings and write almost exclusively in .Vue files, so maybe it's my JavaScript fatigue speaking... But the ecosystem is way, way too convoluted and intertwined.
That's not the language problem in itself, that's the problem of slow adaptation. WE don't have problems adjusting to ES6, our end users have. WE don't have exactly because of the transpilers. It's the same in other areas - while Android 8.x is out, there's A LOT of devices still stuck with Android 4.x so if you want to target most of the market you need to cater to those as well.
HTML imports are dead. If a browser doesnt support it yet, it wont. And those that do are dropping support. Thats why Polymer 3 is moving to es6 modules, and lit-html.
Just use plain objects. Example (typed on phone): const Constants = {} Constants.Database = {} Constants.Database.LOCATION_USERS = "users" export default Constants
Do you need all that stuff? Probably not, but when your productivity increases four fold building ambitious web apps, you tend not to care as much.
It's all (ok, like 75-95% of it) build tooling, not the framework itself; you're not shipping the 13k files with your app. You're shipping like 13 (or whatever). Disk space is cheap these days; think of it like installing a compiler to build your web app.
&gt; Am I alone in thinking this is kind of insane? no. &gt; I'm interested in others opinions. it depends on your team size and how "enterprisey" you want/need your processes to be. here's my personal opinion: https://github.com/leeoniya/domvm there are plenty much smaller, dependency-free libs [1] that offer the benefits of virtual dom, declarative construction, SSR, single-script tag &amp; no tooling. [1] https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
are you asking how to import and export modules?
You are definitly not alone with your thoughts ^^. Hell there even are library creators trying to implement good and scalable helpers and libraries in the 1-2 KB size. But minimalism comes with a price too, one of such often is weaker tooling. But does it matter if frameworks like Angular5 exist? You dont need to use them! I always try to think like this: "Do I know how a train works? Nope, but i use it daily anyway, because its so much better then walking."
HTML [already has](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) a specification for template elements -- however these aren't parametric and can only encode a dom structure, all your code can do is load the element, clone it, modify the clone via regular dom calls, and append the clone to another element. This proposal extends the above functionality to have a parametric mode, where you can define those templates with handlebarse-like syntax, and render them with a simple JSON object like so: `newElem = tplElem.createInstance({name:"billy"})`, then later: `newElem.update({name:"bobby"})`.
FAAAAAAAAAAANTASTIC TALK! I'm more and more inlove with the functional side.
Which is tragic, `&lt;html-include src="adjacent/source/file.html" /&gt;` should have been in from day 1.
There is a great [smooth scroll polyfill](http://iamdustan.com/smoothscroll/) for this.
I tried to understand hyperhtml, something about it just felt overly complex for just generating templates. I like the simplicity of lit-html in that its trying to do a very few things well, and has a pretty obvious path to extensability
If using ES6 modules, exporting individual variables like this works as well. export const DATABASE_LOCATION_USERS = "users" export const STORAGE_BUCKET = "us_central" A few advantages to this approach: - Module systems, bundlers, and type systems will warn you when you try to use a key from the module that doesn't exist, helpful if you happen to rename the variable, or if you make a typo. - Bundlers can tree-shake away the unused constants, but this is a small upside if there aren't very many of them. - Variable declarations are friendlier to minification than object keys. Given this is node, all the bundler-related upsides might be moot, but good to keep in mind anyway. ¬Ø\\\_(„ÉÑ)\_/¬Ø
I recommend that you take that application created by create-react-app and running a production build with it (npm run build). It will create a single .js file for you that is a couple hundred KB big, similar to the angularJS library. As far as production code goes, it is not dissimilar to an angularJS application. As far as development and build tools, it is very different though yes. Is this insane? Do I know exactly how what it is doing and how it works? Do I even know JavaScript? You are going to have to define those a little better. I guarantee you do not know everything going on with the internals of that 100KB+ angularJS library. It is just the bundled &amp; minified version of what create-react-app spits out. As far as what production code gets made, it is very similar. Also, for reference, [here](https://github.com/angular/angular.js/blob/bf758d0bef449e07ce57d9c53dcb2a9191c1dc3d/package.json) is a list of all the dependencies the angularJS library uses for its own development. Are you required to know what all those node modules (and each of their dependencies) are doing to use angularJS?
&gt; I feel like these frameworks are breeding a generation of developers that don't even know javascript, and that's a huge problem. Because tooling and frameworks have lots of dependencies? You sift through the `node_modules`. I'll be writing code. I also feel pretty strongly about which one of us has a "huge problem".
All that stuff is typically only used for *developing* and *testing* the app, though. For Angular 4, my actual finished dist files are smaller (and usually perform better) than the same app under Angular 1.5 would have been. 
Not exactly sure what you're trying to say here. I'm learning a new framework and took a look at what it installed along with it. Seems like something any responsible developer would do. The part of my post you quoted is referring to some new developers who don't know how to code *oustside* of react/angular w/e. Unfortunately that's becoming more and more common, and yeah that IS a huge problem.
haha, Internet of Shit.
&gt; I'm learning a new framework and took a look at what it installed along with it. Seems like something any responsible developer would do. If you were to learn C, would you first look into what's included in `stdio.h` before you started writing your hello world?
Yup, you're feeding into the smoothstep function a number ranging from 0 to 1, and it converts a linear time progression into a smooth sine-like progression.
In every language/framework, there is what is called "boilerplate", which are code that's required but has little to no application logic. Every language has it. In the case of your Java code, the only non-boilerplate code is just `final String LOCATION_USERS = "users"`. So just port those to JavaScript, and add whatever JavaScript boilerplate. In JS w/ES6 module system just do export const LOCATION_USERS = "users"; If you want deeply nested namespace: const LOCATION_USERS = "users"; export const Constants = { Database: { LOCATION_USERS } };
&gt; The part of my post you quoted is referring to some new developers who don't know how to code oustside of react/angular w/e. Unfortunately that's becoming more and more common, and yeah that IS a huge problem. people proclaim this about every abstraction layer to anything ever learn what you need to be productive
a better analogy is buying a new car to replace the old car. and yes, of course i will check how big the trunk is, how fast it accelerates and handles, how much it weighs and its mpg relative to the shit i've been driving for the past 10 years.
If I successfully wrote C applications for years without it and all of a sudden I was forced to have a strange header file that I never needed before... yes, yes I would look to see what's included in stdio.h
JS development is becoming more mature, and with that comes dependencies. You need build tools, frameworks, test frameworks, and any other libraries you want to bring along. You should treat your node_modules directory the same way you'd treat a lib/ directory in any other language. That's just where your dependencies are stored when you install them. You don't include your node_modules directory in your repo, it's basically just a build artifact. You shouldn't need to look too deep in there unless you're debugging something specific or you're just curious. You don't *need* to know exactly how all of your tools work in order to be able to use them. That's what documentation is for. And as tools become more advanced, their code becomes more complex and they get bigger. I tried reading through the source code of React one day and I got hopelessly lost. These tools have large teams working on them. It's not just one dev anymore. If performance is your concern, run the app, take a look at the bundle size. Are all of those hundreds of modules included in the bundle? Does it take a long time to load? The answer to both is going to be no. Those modules are present in your dev environment, but tools like webpack and rollup intelligently determine what code is needed and strip away everything else. If you're not used to it, it's going to be daunting. But you can either be stuck in the past or open your mind and realize that things are this way for several good reasons. We haven't all just lost our minds. I will agree that certain things have gotten out of hand, however. Modern JS takes advantage of several powerful tools, each one with it's own complexities and sets of docs, and each one has ten competitors. We need some standards and some cohesion to offset the growing forest of technologies that populate the web dev world today.
Can I call you daddy?
Ok, fine. Well I'll try to be helpful and recommend you look at [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements) and [stencil.js](https://stenciljs.com/). They have far lower "baggage". Oh and [choo.js](https://github.com/choojs/choo). I really feel though, if you want to take a look at angular/react that you should ignore the dependencies and just write some code. I mean you're more-or-less doing this to maintain employability right? It's not going to help if you go to an interview and they ask "Do you know any React?" and you say "have you even *looked* at the dependencies!?".
&gt; ...yes, of course i will check how big the trunk is, how fast it accelerates and handles, how much it weighs and its mpg relative to the shit i've been driving for the past 10 years. OP hasn't even gotten past how big the trunk is.
&gt; Because nothing can ever be deprecated, or upgraded in a modular way. Sure it can. Create a completely new API, and then deprecate the old one when it's usage drops (see for example AppCache vs Service Worker Cache). The point is to not break any existing webpages, that is not a "red flag", that's what made web the most popular platform.
https://github.com/tanrax/simplescrollup
I recommend using Robert Penner's easing equations for realistic animations like this. You can combine with animationframe for a buttery smooth result. You can find the equations here - just copy and paste the equations and don't use jQuery (the repo is quite old). https://github.com/danro/jquery-easing/blob/master/jquery.easing.js
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [danro/jquery-easing/.../**jquery.easing.js** (master ‚Üí a6f21ff)](https://github.com/danro/jquery-easing/blob/a6f21ff77c84cee11562d36c51fb5b9c95f2eec0/jquery.easing.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
&gt; All this for an app that displays 'hello angular' in a browser window. Thinking this way is a bit of a trap. If the goal really was just to display "hello angular", then you wouldn't need angular to do that, or even JavaScript for that matter, you could just write it in HTML. The reason we don't do that is because simply displaying "hello angular" ***isn't*** the goal. The goal is to give you the infrastructure to build a large, complex, and scalable application. "Hello World" is simply a token demo. &gt; I use angularJS at work, and enjoy it. It's relatively small (just include one script file) ... My previously empty directory was now 121 MB project containing 13 thousand files and over 300 node modules. Most likely the older angular source also had many many files, and as part of their build process, they concatenated them all together to give you a single script file. Nowadays, that process of concatenating has been pushed further down the line. Now they give you all their little files, and they probably expect you to use a tool such as Webpack to do the concatenating yourself. You're still getting the same thing, except now you're seeing the sausage getting made. ;-)
 I'm going to repeat /u/gaearon 's standard reply: The set of dependencies that CRA uses includes: - A compiler - A bundler/linker - An optimizing minifier - A linter - A development server with live reloading - A test runner All of those are isolated and scoped to that one project, and they are all _build-time dependencies only_. It's also important to understand that Javascript packages are effectively distributed as source, which affects the number of files on disk. (Granted, many NPM packages do include unnecessary files in the published artifacts, but Javascript itself is a major factor there.) Meanwhile, XCode is supposedly something like 8GB installed, Visual Studio is multiple gigs, and if you were to look at the actual file size on disk of any C++ compiler toolchain, that would be a minimum of several dozen megs - those are just usually preinstalled on Linux or Mac systems. So, context is pretty important here. 70MB for a complete JS build toolchain is perfectly fine :)
despite what Sir Mix-A-Lot preaches, not everyone likes a big trunk.
jumping onto my top-level comment: /u/AsIAm mentions a [polyfill](http://iamdustan.com/smoothscroll/) for window.scrollBy() that makes this work. Someone over on /r/webdev mentioned that I could have used .scrollIntoView() and they're right. It's cleaner to just find the target and instead of calculating the distance to scroll, say this: targetAnchor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: "nearest" }) That, combined with the polyfill, sounds like a pretty good solution overall.
[removed]
It uses Admin On Rest. It's a layer on top of it that parses a Hydra documentation and generates automatically a working admin. It includes a Hydra doc parser, an AOR configuration generator (dynamic), and a JSON-LD/Hydra client.
I understand this, and as I continue working in the framework I'm noticing this stuff is easier to forget about. Mentioning VS and XCode are perfect examples of what learning this framework is like. It feels like I'm going from writing javascript with a few libs to make my life easier to writing Angular. It doesn't feel like JS any more, maybe that's OK.
I don't think this is a new thing. When I first started learning JS at least 10 years ago JQuery was the one hot library; if JQuery couldn't do it most devs would say it was impossible. Irked me because I wanted to learn the actual language at the time I think it's a matter of demographics: web devs tend to be less interested in the tech and more interested in completing a project.
I am continuing to learn the framework. I don't need this for my current job, I'm more or less learning Angular out of curiosity, but you're absolutely correct. Not learning new things because I don't agree with design choices is kind of a dumb stance to take. As I continue I'm finding it easier to just forget about the "baggage". I'm also noticing, though, that this isn't really JavaScript anymore. It's Angular and maybe that's alright. I think people need to approach it that way. Angular/React isn't a library you include to make your life easier, it's a language in and of itself and a development environment (that may make your life easier).
 function EnableTextbox(checkbox, textarea) { if(document.getElementById(checkbox).checked) document.getElementById(textarea).disabled = true; else document.getElementById(textarea).disabled = false; }
It doesn't seem to work for me?
It still doesn't work. :/
Hi /u/junyoung95, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/crapspank, For javascript help, please visit /r/LearnJavascript. Thank you!
this works for me: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="task2.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Is this a gift? &lt;input type="checkbox" id="checkbox" button onclick="EnableTextbox('checkbox','textarea');"&gt; Write your gift message here: &lt;br&gt; &lt;textarea disabled rows="5" cols="50" id="textarea"&gt;Type your message here. &lt;/textarea&gt; &lt;/body&gt; &lt;/html&gt; function EnableTextbox(checkbox,textarea) { if (document.getElementById(checkbox).checked) document.getElementById(textarea).disabled = false; else document.getElementById(textarea).disabled = true; }
Hi /u/arup_r, For javascript help, please visit /r/LearnJavascript. Thank you!
Of the things you listed, the only one I believe is insane is how many modules are required. NPM is the only package management system where the community gets off on "tiny modules," and this is the result. I also believe it's insane that certain things, like, Gulp, aren't installed globally. As others have mentioned, the dependencies are all build tools. In other languages and systems, say .NET, the implementation is much more sane: * You install your compiler and build system. The Visual Studio installer will install, say, csc and MSBuild. These are global. * You can include custom build steps in your projects, if needed. * You will have .NET installed globally. This is a very large library with a ton of functionality. * If you need external dependencies, you use NuGet (.NET equivalent of NPM). These are installed locally, along with their own dependencies. The major difference is no one in .NET land gets a boner for releasing a NuGet package with a single function, so you have perhaps 2 or 3 additional dependencies installed; often times none. * .NET land has a concept of "binding redirects" that allow you to point any version of any dependency to another version, which further lessens the need for additional dependencies. Ultimately, I agree it's "out of hand," but it's been this way for several years now. Very few people in JavaScript land buy into how other systems have done things for decades ... it's really strange to observe.
Yes but you also need [eslint-plugin-flowtype-errors](https://www.npmjs.com/package/eslint-plugin-flowtype-errors). .eslintrc: "plugins": ["flowtype", "flowtype-errors"], "extends": ["plugin:flowtype/recommended"], Then in your webpack config for the eslint loader, you can specify the "failOnError" option to be true if you want the build to actually fail for linter errors. Personally I recommend having it fail for production builds but not dev builds, that way it's not painful in day-to-day development but you're still enforcing your linter rules prior to code making it into production. Webpack config: module: { loaders: [ { loader: 'eslint-loader', include: src, test: /\.jsx?$/, options: { failOnError: true, }, } ] }
it was this part of my code that didn't cause to work. EnableTextbox('checkbox','textarea') Thanks a lot!
@kenman thanks. What this reddit form is for then?
well javascript is turing complete, so any other turing complete language could implement any algorithm javascript could. As for speed, there maybe certain things that are optimized at a very low level in js, but i doubt it
Do you know any of this things that might run better?
I mean JS is really good at events, since that's what it was roughly designed for (not to block the browser). There is no reason any other language couldn't be good at this too (and many are)
many things in javascript may run faster than the equivalent code in python, but probably not anything written in C or Java
It's an interpreted/script language. And compiled languages like C outperform interpreted ones because they are compiled into machine code before they are executed. But on the other hand JavaScript it's one of the fastest interpreted languages because Google, Microsoft and Mozilla have put so much effort into writing efficient runtimes for it.
Yes I understand this, that is why I had such low hopes to begin with.
It's actually JIT compiled and not fully interpretted.
About four letters.
The package they are talking about actually runs Flow from and through eslint, and the Flow errors are then reported as eslint errors.
i hurd the browsers nowadays JIT-compile those sections of javascript that appear to be used the most.. which means that javascript actually is not always interpreted, but sometimes exist as compiled machine code. although, my point is somewhat moot. It still runs slower than regular pre-compiled languages.
css in js is the worst trend in web development I have experienced. If you want modular CSS, use css modules. If you want CSS in the same file as your components, use something like vue.js's single file component structure. Implementing some frankenstein css solution using js template strings that throws away editor syntax highlighting and autocompletion all in the name of keeping everything pure js is lunacy. Seeing that there are so many competing solutions to something that isn't a problem in the first place is even worse. I will put down money that this is something we look back on in a few years time and regret implementing and having to support.
Yeah unless it's actionable e.g. some kind of animate or click event (because you must) my CSS is always in its own self-contained loosely-coupled file for all styles. JS does its thing, CSS does its thing. They come together only and exclusively when needed.
If anyone is to blame, it's npm (and don't get me wrong, I loooove npm). By using a centralized repository of open source packages, we've bought into and invested in a system that encourages reuse of other packages over writing code ourselves. Personally this doesn't bother me that much because I think it's worth the overhead, but it is the reason why our devDependencies are growing. The initial shock of a large node_modules folder will eventually be outweighed by the relief of a much nicer development experience, if you stick with it a bit longer. Webpack ftw!
I always hated the try/catch notation, so when I was reading this on my phone before it got me all fired up. Naturally, I went back in and dropped everything I was doing at work to try this out - couldn't get this to work though. At least not with just Node and the command line... Any way to get a clean notation like this to run in "just Node"?
JSYK all browsers on iOS use the same rendering engine that Safari uses.
Very false. A good employer would hire a junior developer based on: willingness to learn, cultural fit, and foundational knowledge of HTML, CSS and JavaScript. I don‚Äôt understand why an employer would want *primarily* knowledge of ‚Äòjquery‚Äô (why even use that anymore...), ‚Äòa framework‚Äô (learning vanilla JS &gt; frameworks) and a CSS preprocessor (instead of learning css first)
I‚Äôve found most people want interns that are finishing up a 4 year degree. 
Because js itself has evolved. We don‚Äôt use it just to animate something or create menus anymore. We build entire applications on the back of it and thats more than OK.
I made an open source library which solves the uses cases described in the proposals and more [dom99](https://github.com/GrosSacASac/DOM99)
it's the old vendor lock-in routine. You are correct to be concerned.
You don't paste a binary between the script tags so it's an interpreted language but alas with some very clever runtime engines that are capable of compiling and optimizinng during execution.
&gt; I also believe it's insane that certain things, like, Gulp, aren't installed globally. Consider the alternative: you start a project using gulp 3.9.1 and it works fine. Then later, you have to work on another project which is using new breaking features in gulp 4.2.5. If gulp is installed globally, then one of your projects will be broken until you get around to upgrading it. &gt; The major difference is no one in .NET land gets a boner for releasing a NuGet package with a single function, so you have perhaps 2 or 3 additional dependencies installed; often times none. Small packages aren't the problem, it's often packages that are far too big for their own good (and not split apart enough). When you depend on a big featureful project, the bloat grows really fast. &gt; Very few people in JavaScript land buy into how other systems have done things for decades ... it's really strange to observe. If you haven't had to die on the battlefield of dependency hell, manually resolving sometimes impossible to satisfy dependency graphs in other languages and with other packages, the way commonjs modules and npm work is fantastic. If you don't like bloat, you can use other frameworks that are [more minimal](https://choo.io/) while still breaking things down into modules where appropriate.
Yeah I honestly don't understand the appeal. My current solution is much more pleasant to work with in my opinion. I use a combination of a few webpack loaders and plugins to allow me to write LESS files such as: :host { color: red; } The ':host' selector is converted into a unique classname which I can then import and use in a JSX/TSX file: import className from './whatever.less'; export function Whatever() { return &lt;div className={className}&gt;Hello world&lt;/div&gt;; } When compiled, :host and the imported className will be replaced by a unique classname, compiled to CSS, and concatenated into a single CSS file which is then automatically added to the page with a &lt;link&gt; tag. I can't really imagine feeling the need to switch to CSS in JS.
Hey folks, developer of CertStream here. You can read more about the motivations and implementation behind this project by visiting the announcement page (https://medium.com/cali-dog-security/introducing-certstream-3fc13bb98067) on my company's blog. I'm also happy to field any questions anyone may have! 
&gt;Not other language had tools just to install other tools to be able to transpile the choice to a workable form. What other language has to deal with the insanely varied execution environments that browser-facing JavaScript does? You don't have to transpile your ES6 code if you can get away with only targeting the latest versions of modern evergreen browsers, but we rarely have that luxury. 
News and discussion of JS, or interesting/challenging problems.
I'd agree with you, but there are a couple of valid/interesting points to be made on the other side, too. I recommend this: https://medium.com/@didoo/let-there-be-peace-on-css-8b26829f1be0 It's a bit wordy, so if you want the takeaway watch the two YouTube videos at the end.
&gt; behavior: 'smooth' Here you are: https://drafts.csswg.org/cssom-view/#smooth-scrolling https://drafts.csswg.org/cssom-view/#enumdef-scrollbehavior It is the same property accessed through CSSOM (parsed from within stylesheet or exposed by js API) In chrome it was introduced in ver 61
Which version of Node.js do you use? `async-await` is supported by 8.x and above. http://node.green/#ES2017-features-async-functions-await With Node6, babel and its plugins make it work.
Why would I want a dependency with 1000 functions if I only need one of those functions? Tree shaking will eventually help but to this day many packages won't tree shake properly. For example you pretty much have to use `lodash-es` instead of `lodash` if you don't want to bundle a shitload of functions that your app doesn't use. .NET is a standard library in the C# world because it has the backing of Microsoft. Many functions have been added to the ES standard, but other than them, who are we going to trust to release the de-facto, gigantic, monolithic, everything plus the kitchen sink library for JS? Modularity and choice are not a bad thing, imo.
Omg, stop bringing OOP bullshit into JavaScript. Learn functional programming.
Well, its okey to be able to do that, but thats not the performant way
jQuery bred hundreds of thousands of developers who didn't know JavaScript. Hell, the awful way `this` is used in jQuery ensured that for years, most front end devs had no clue how prototypical inheritance in JS works. Why are people just now starting to complain?
In exploring Spotify's public API, it looks like there is a fairly easy way that I could build an "artist explorer". To explain, I want to add a feature that could give a user access to tabular data on all of an artist's tracks. The tracks would be sortable by the song characteristics (acousticness, liveness, danceability, loudness, energy, etc.). Then, the user could select tracks in the table and export to a playlist. That way, you could easily create a "Ryan Adams Acoustic Playlist" that had the top 20 most acoustic Ryan Adams songs. Is that something anyone would be interested in using or just me?
The JVM doesn't run binaries either. Like I said, it's not a fully interpretted language. The reason asm.js rivals traditionally compiled languages in terms of speed is because it's maximizing the amount of it that can be JIT compiled.
I'm kinda new so i probably don't know what I'm talking about, but from my understanding javascript handles certain corner cases of math a little weirdly, so an algorithm based on that or any of javascripts other unique quirks could produce an algorithm unique to the language . 
... don't set display to none? Seriously though, that has to be the worst piece of code I've seen in a while, you're reading bad tutorials.
I think the meme that node_modules is some huge uncontrollable mess has spread a bit too far from the people who browse r/programming. Yes, node_modules can get large but little of that is going into your production app. I wouldn‚Äôt pay it much attention, just be sure *your app* is where you want to be size wise. 
I don‚Äôt want to be that guy, but those people have always been there. Now, it‚Äôs people who only know one specific framework, back in the day it was people who learned HTML, CSS and did a bit of photoshop and called themselves developers. Unless something drastic changes on the front end, this is how it will be for a long time.
You can have both ya know. Feel like some of the best frameworks use functional and oop together.
Off the top of my head, no. If you want hyperperformance then JS is not for you. Not that it can‚Äôt be performant, but you simply don‚Äôt have that level or control over memory that you get in a lot of other languages. But, and it‚Äôs a big but, there are so many cases in the real world where JavaScript will do the job better than the competition. Whether that‚Äôs for business or compatibility reasons, it doesn‚Äôt matter much at the end of the day.
Here's [something to that effect](https://github.com/rooseveltframework/teddy#includes).
Is duck typing just a comparison of interfaces instead of types?
Please update your code. There is an issue: p.log(); // I am Oliver p._firstname = "Nana"; // &lt;===== p.log()// I am Oliver
What do you mean when you say it isn't JavaScript anymore? If you used the client then it should be TypeScript, not JavaScript.
Can I &lt;include&gt; an angular, an ember, a react, and a vue app into the same DOM (no iframes) and everything works as it should do?
Honest question: why? It's not perfect, but you could: 1. Display modal. 2. Drop a cookie indicating the user's response. 3. Read the cookie on subsequent page loads. 2. If the user accepted, load GA. 3. If the user declined, don't load GA.
if you are going to keep checking out angular, i strongly recommend the angular cli. https://github.com/angular/angular-cli It (from my understanding) is similar to create-react-app -- it is mostly for the build tools. `ng new yourProject` to generate the boilerplate, `ng serve` for development, `ng build --prod` for deployment.
This is called easing. Smoothstep is some weird name someone apparently gave to one easing function
&gt; you'd think introducing actual new HTML elements would be the way to go. This is about &lt;template&gt;.
That might be something to look out for, thank you.
Just use the first and second variable &amp; property assignments.
Yes, the internal mechanism of try..catch block creates and destroys context information. Even though it may not be noticeable, the result may be noticeable if it's executed within a loop.
Well it is if you value developer time, since it's fairly performant in that regard
I'm aware of that. I'm talking about the templating system that goes inside the `&lt;template&gt;` elements. I don't think it should be mustache, or handlebars, or dust.js, or jade, or any of the popular ones. Something made from new HTML elements that are only valid within `&lt;template&gt;` elements I think is a better way to go.
Teddy doesn't use iframes, so yeah it's the same DOM. I'm not sure if it's possible to load angular, ember, react, and vue into the same DOM in general though. It seems likely they'd overlap in some fashion. Even if it worked, it would be horrible for performance.
That‚Äôs why we want this in the html spec.
Haha, looking at your code I got super excited at the idea of a reverse arrow function.
Oh I agree, Apple's proposal is totally worth supporting. I don't follow your logic as to how any of that is a reason to want it though. Support for templates natively in the browser isn't going to suddenly make loading angular, ember, react, and vue into the same DOM at the same time a good idea.
Well, there is also &lt;slot&gt;. This one also came from Apple, if I remember correctly. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot
I don't use it in loops but my script is dynamic so there will be chance I will do 100x try catch. Will it cause an unresponsive browser? This is my main problem. Anyways the User will be notified if the code execution will take too long if they add too many inputs.
I've found `styled-components` to be a really nice balance. You still get [syntax highlighting/autocompletion](https://i.imgur.com/XNIVOQx.png), and it's really nice to have your components truly be self-contained ‚Äì that's the one thing I liked about Vue, and it's great to be able to do so in React. It's also dope to be able to use JS for your styles which makes dynamic stuff pretty easy.
If you want to emulate privacy, use the WeakMap workaround. https://jsfiddle.net/rzgumjL4/ But since that's super annoying, I recommend to use leading underscores for wannabe privacy and then switch to actual privacy when the language supports it. TypeScript is also an option.
No. &gt; is there any algorithm that performs better in JS? V8's regex implementation is one of the best. If regex is the bottleneck, JS can be at the very top.
Being interpreted or not is an implementation detail. There are interpreters for C, for example. JavaScript is typically JIT-compiled. V8 just got an interpreter. Until recently, it started with crude machine code right off the bat.
As a person that pays for IT spanning multiple years ahead, I want to think I have a methodical way forwards in the DOM as a organize the building of a large application. Here you go - [this blog entry](https://paulhammant.com/blog/angular-declarative-ui.html) marks me as lucky that I bet on Angular1 in 2009 (same day as Misko did to a non-alpha user group). And it left me thankful that I disliked Backbone from the first second I was able to compare source to Angular1 (Angular was actually before Backbone). I'm not oracle though, I know Vue is taking the some of Angular1 community, and Angular 2 and React are taking some of the rest, and I know (because I was Director of Engineering over some (prior) significant investments in Ember that I do not like that at all. But despite all that like and dislike staff that I want to compose rectangles from all sorts of web technologies browser side going forwards and not have them entangled/interfering in the DOM. In particular, I don't want to have to rely on iFrames to stitch them together. All of these are economics factors given we're 100x more expensive to make web applications today than we were in the mid 90's and I fully concede that the experience bar has risen since then.
To me, your complains are the equivalent of an Amish person entering out into the world and complaining about all of the new things.
Hey! So thanks for the opinions/comments, I'd like to address a few of them. Totally understand where you're coming from and the resistance to these solutions. &gt; If you want modular CSS, use css modules. Typically css modules are implemented using CSS in JS solutions. The fact it's a separate file doesn't detract from the fact that it's still inherently CSS in JS. [I recently gave a talk on this](https://medium.com/object-partners/css-in-js-benefits-drawback-and-tooling-80286b03f9aa), and one of the slides deliberately calls out that if you don't find these solutions appealing, CSS modules are a _great_ alternative that has some of the same benefits as these libraries. &gt; If you want CSS in the same file as your components, use something like vue.js's single file component structure. Agreed! Vue does that really cleanly. I call it out specifically in that post above as a good solution. &gt; Implementing some frankenstein css solution using js template strings It's not just JS template strings &gt; throws away editor syntax highlighting and autocompletion Fair point! Editor tooling is certainly a weakness. &gt; Seeing that there are so many competing solutions to something that isn't a problem in the first place is even worse. To me, competition is an inherently good thing. We also see a lot of JS framework competition, does that in any way diminish the concept? &gt; I will put down money that this is something we look back on in a few years time and regret implementing and having to support. I hope so too! I'm of the opinion that these are a temporary measure to something that I gets fixed, i.e. in something like web components w/ shadow dom! Interesting points, thanks for the feedback! 
Do you know what editor and theme that is?
agreed! I also like this solution, and it lets you use whatever CSS preprocessor (e.g. SASS can be used, as well) you like This is CSS modules, correct? Or at least seems like an implementation of it
My only negativity is that safari is already becoming the new IE. Can they try to catch up on standards before proposing new ones?
I'm aware.
Js is probably the fastest at algorithms to modify the html on the page. Any other language would have to be proxied by, or bypassed via, JS anyway, while js can operate directly.
The editor is Atom, the theme is a custom one, but you can install `bliss-ui` and `bliss-syntax` through `apm`.
Maybe that's all it is, honestly I'm learning a lot today. That put a hilarious image in my head btw, thank you for that
Thanks for the tip! I'll check it out
/u/DSchau, I have to admit that I have some reservations about the CSS-in-JS trend in general, but wow! This site is incredible, and immediately helped me to understand some of the fundamental differences between competing libraries in this space. Well done, this is an incredibly useful tool.
The question I asked here was not interesting? Was that simple like a factorial problem?
hey, really glad to hear that! That was definitely the goal, so glad to hear that it was at least mostly realized. Thanks again!
check out [this post](https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660) as well. Also note, it's from the creator or CSS Modules!
I think part of my problem is that I approached angular the way I approached libs of the past. Take angularJS for example. You include it in your page with a script tag then just start writing normal js with it. While more expansive, it can be approached like any other js library (jquery, lodash, etc.) but even with angularJS it's still just JavaScript. Angular,on the other hand, is not really a JavaScript library. It's a development environment and almost feels like it's own language. It's easy to see how someone could learn angular and not really learn vanilla js all that much. I think that might be where people's problems with these frameworks come from. They sit down, start a project and expect to be learning a js lib. That expectation vs the reality of coding an angular app is what creates the knee jerk repulsion some people feel. It's not that that's a bad thing. It's like if you expect a bowl of ice cream and get pizza instead. Both are good, just not what your expecting.
Which plugins/loaders are you using?
Even when I was using angular 1.x I was using gulp and grunt with a bunch of node modules for the build. Angular 2+ feels the same to me but with TypeScript instead of vanilla js. Is that not the case for you? One thing I would suggest, try implementing a few decorators of your own. It's not terribly difficult. It will give you a lot of insight into how angular does a lot of it's magic and decorators are on track to become part of vanilla js. Angular introduces a lot of new concepts but very few of the concepts are far from the standards track. It may feel so new but keep in mind that in a few years these concepts literally will BE JavaScript. As you become more comfortable with the concepts, start digging into @angular/core. There's a lot of interesting stuff there. I find the angular 2+ source a lot easier to read than angularJS.
&gt; That link proves that developer that created lit-html thinks that demo comparison is pointless and unrelated (exactly what I am saying to you). He doesn't understand this problem space, it is impossible to **correctly** implement scheduling on top of lit-html, scheduler should be aware of all pending DOM mutations and should be able to discard them or apply them atomically, otherwise it will be like any other broken "async rendering" that many other FW authors(like myself) implemented many years ago, React is the first UI library that tries to solve this problem correctly.
I did a google search and found multiple hits for both PDF and Word.
I do use grunt with angularJS, but honestly I generally avoid using libs when I don't have to. Maybe it's because I come from the C/C++ world, but I'm most comfortable being close to the metal (and not relying on other people's code). For js that means using vanilla js. For that reason I rarely used any libraries. I've worked on fairly large/complex applications and, for the most part, plain angular and vanilla js is all I needed. I was never interested in typescript (learned it but never used it) because I didn't run into type issues. Again, this may be my C/C++ background, but I'm just used to being careful and paying attention to things like types. Most js libraries seemed like a way for people who don't know js to avoid learning it (which is the same reason I hated when they added the 'class' keyword). *Tl;Dr;* yes I've used grunt and other build tools/transpilers, but only very sparingly and never to the extent that angular does.
It's neat that you've done this, and I have no problem whatsoever with people experimenting with this stuff just to learn and try new things. However, if anyone actually runs this on a production site, or does any other hijacking of fundamental browser control, I will open their webserver and take a shit right on top of the motherboard. This is behavior nobody should ever actually modify. And it feels insane that I actually have to say this, *because people do.*
Thanks for the feedback. I am new to JS, and when I saw this post I thought it was intersting. So, I shared it. I'm not the author.
All I knew a year ago was bower. It has really faded. Nice to have a quick guide for migrating. I would need one if I were to migrate today.
I think a lack of platform maturity makes some of the short comings more apparent. You're complaining about build tools. Do you read through gcc or clang source code before starting projects in C? I sure as hell don't. I copy and paste make files until my code compiles and then I write my code. I do understand the sentiment. I felt the same way until I was given a deadline. After that I was just glad the code worked.
More often than not it takes resources/time that aren't just available. Maintaining is when it gets hard, but 'code usage coverage' is a good start!
what if you want add "onblur" and "onkeydown" to a field? of use getElementById or getElementsByClassName?
[removed]
Honestly I keep hearing this "deadline" argument. Does anyone in the js community code because they enjoy it or is everyone just chasing check? Yes I've looked at what's in gcc because I'm fascinated by the tech itself and want to know how things work. I *enjoy* doing things like writing compilers. I keep hearing this "productivity" argument and it seems to entirely miss the point. Yes, at work I'm sometimes in "just get shit done" mode. But I'm learning angular because I like to code, it has nothing to do with work. I didn't learn assembler because it would let me get my job done faster. I figured all devs would feel the same draw to investigate this stuff. Maybe the js community is different than others
Thanks! Hope it helps when you migrate!
&gt; Consider the alternative This is why multiple versions would install. Consider the multiple versions of msbuild you have if you install multiple versions of VS. &gt; Small packages aren't the problem OP asked about 13,000 files, which is definitely a problem unique to NPM. &gt; If you haven't had to die on the battlefield of dependency hell All dependency systems have this problem to some degree. NPM's dependency graph was a huge issue until ~2 years ago. It is one reason Yarn exists. Modules are a separate topic; we would be comparing commonjs to loading assemblies in .NET rather than dependency management systems.
I made no argument about deadlines. Just a fact of life. I love coding, that's why I sought a career in the field. After looking at gcc did you conclude that c/c++ development has gotten out of control because of the complexity? Or did you simply think that it's a neat tool and get shit done? I also made no argument about productivity. Maybe you responded to the wrong comment? I learned angular for the same reason and then got an angular job. After that I read through the angular source. The difference is that I didn't hop on Reddit and complain that JavaScript has gotten out of control and is no longer JavaScript, unlike c or c++ which is completely under control with it's simple tools and build systems like gcc, cmake, etc. JavaScript is maturing. Along with that comes more complex tools. If you're under the impression that c and c++ tools are far more simple, think again. Although im really just preaching to the choir since you've "looked at what's in gcc"
üßü‚Äç‚ôÇÔ∏è
Why not directly convert with a [Video Converter](http://www.pavtube.com/video-converter/), it saves time.
Literally the first line of code is display: none; /* Hidden by default */
 What the hell?
You said you "felt the same way until I was given a deadline" I've seen that same argument from several people in this thread. That's what I was responding to. Yes gcc is complex, cmake is complex. It isn't comprised of 300 different libraries controlled by different organizations without an explanation of what they're for. If one of these libs releases a breaking change who's in charge of making sure my next npm install doesn't install the incompatible version? The angular team? Npm? Me? My initial reaction was knee jerk, I admitted that. But I'm surprised more people don't question the "crowd sourced" nature of some of these js frameworks. That's all this post was, "hey this is crazy right?" And the general response was "it's a lot of stuff, but they're build tools and it's worth it" and after working with the framework some more I agree. And it isn't js, it's a custom framework that dictates how you write your code, on top of typescript, on top of js. But, like I said, there's nothing wrong with that. Just like c++ isn't c. It's based on c, a lot of the build tools were built in c (at least originally) but it isn't c. That's not a criticism, it's just the truth.
I'm fine with modularity. I'm not okay with single-function modules and an unnecessary number of dependencies. &gt; Why would I want a dependency with 1000 functions ... Tree shaking will eventually help You answered your own question; dead code elimination negates this concern. There are other reasons as well, such as wildly varying quality between libraries, fun issues like an 11-line module being pulled from NPM (I know this was resolved), the complexity of managing so many dependencies, and more. JavaScript has a unique problem, being that it has to send these libraries to the browser. For Node.js, this isn't a problem. I think the JavaScript community has kind of painted itself into a corner by adopting what I'd consider to be a bad practice. But, it is what it is. .NET doesn't have to be monolithic, by the way, especially with the advent of .Net Core. ;)
bruh why are you shamelessly plugging your video converter 
That you didn't say when you were deleting this post. Google search gave me the same search results to me also. But they are not the better approach. Also most of them are how to preview it, I asked for thumbnail creation. Don't ever delete someone else post which you think not interesting to you. If the post gets lot of downvote, means it is not a good question, only then you can remove. 
You're right, I did say that. I just didn't realize we were arguing. I don't know all of gcc's dependencies, but any libc implementation is going to be pretty substantial. You install that at a system global level so it's out of sight out of mind but it's not much different. In your package.json you can specify different version tolerance, so the answer to that would be... You. Of course if you prefer a more C like, lower level approach you could always manually resolve your own dependencies. I think after the left-pad incident, people realize that accepting the crowd-sourced dependency management is problematic. It's just really convenient and easy. It is just js, just as much as QT is just c++ or gtk is just C. JavaScript is in flux at the moment but that's just growing pains.
MDN is such a great resource and thanks for that. But please, dear Mozilla, can you get rid of the new white-font-on-black-backgrond style in your subtitles. It's fine for your logo and maybe the status bar, but not for subheaders within articles. That is very distracting for the eyes and I'm sure a professional typographer will confirm that.
I didn't use the word "argument" to insinuate that we were arguing. Honestly I think we Agree on more than we don't. And yes, I understand how to use package.json to manage library versions, I was simply pointing out my reason for skepticism. It doesn't seem reasonable to ask every angular developer to stay on top of 300+ libraries. On the other hand I also have realized that this is *probably* stuff that I won't have to worry about. You're 100% correct in saying this will be a non-issue and exists because JavaScript as a language is going through some serious changes (most of which are for the better). This all stems from, what is arguably, a healthy skepticism. Do I generally take gcc/g++ for granted? Yes, of course I do. But the c/c++ standards have been in place for decades. A year ago Angular4 was Angular2 and was in beta. I think if anything people should ask more questions of how their tools work. Maybe a better post would be "how do I know this tangle of dependencies is stable?"
[removed]
Semantics in my view. JIT is a interpretation. It's a way to explain that the interpreter is sofisticated to enough to see bottle necks in the code and reuse already compiled blocks. All code has to be compiled some time. With C and Java it's done during development and with JS and other interpreted languages it's done during execution or "JIT". Allthough Java for example does not compile down to pure machine code.
&gt; it is impossible to correctly implement scheduling on top of lit-html, scheduler should be aware of all pending DOM mutations DOM batch update control API is exactly what they are working on https://github.com/whatwg/dom/issues/270. For example you can implement any logic, including the scheduler, using this. Stop saying everything in absolutes because you don't know what are you talking about.
The more the better
&gt; For example you can implement any logic, including the scheduler, using this. You can't implement anything because it doesn't exist.
You could use some regular expression. Something simple, such as `var classes = styles.match(/\.[a-z0-9\-_]*/gi);` may do the trick. But if you want to be more strict and only support _valid_ identifiers, you could use a better expression, such as... `/\.-?[_a-z]+[_a-z0-9-]*/gi`. You may have to do some additional testing with different inputs to check it finds all the results you want.
That just an API for declarative batch updates. You can abuse DOM's internal batching logic without virtual DOM diffing (e.g. Glimmer VM https://github.com/whatwg/dom/issues/270#issuecomment-227617545). But even if that is not as performant or as extensive as with VDOM, my only point was (which I mentioned in this thread and the other one) is that templates are the future and there is nothing theoretical preventing them from replacing VDOM diffing which has an inherit overhead. This is the the path that current web standards &amp; proposals are taking.
Cool to hear, i am indeed from Switzerland hit me up :).
&gt; JIT is interpretation. AOT, JIT, and interpreting are 3 different things. &gt; With C and Java it's done during development [...] Java for example does not compile down to pure machine code. Java is (typically) compiled to byte code, not machine code. That byte code is then (typically) JIT-compiled at runtime. It's also possible to AOT-compile Java or to interpret the byte code. Dart, for example, doesn't have an interpreter anymore. There only was an experimental one for small embedded systems. Dart can be compiled to JS, it can be JIT-compiled by the Dart VM, and you can AOT-compile it for iOS and Android. The Dart VM can also run so-called snapshots, which contain serialized token streams. This skips the parsing stage. Since a couple of months, it's also possible to add AOT-compiled code to these snapshots. This skips the warmup phase as well. However, JIT stuff is still done if the VM determines something should be changed. See also: https://en.wikipedia.org/wiki/Interpreter_(computing)
Awesome, thanks for clarifying. Now that I see it, I don't know how I missed it the first time through. I'm using AOR at work right now so I'll probably end up giving this a try to see if I can take advantage of some of the extra features. Sounds pretty sweet.
Try it out! Most solutions pass all props down, as is, to the underlying element. One caveat is ‚ÄúinnerRef‚Äù vs. ‚Äúref‚Äù, which is required for certain fields if you want to access the innerRef
&gt; VDOM diffing which has an inherit overhead. Have you tried to implement a non-vdom algorithm to update scene graph that at least can handle 80% of use cases of vdom libraries and will be able to compete with fastest vdom algorithms? The problem with non-vdom approach for updating stateful scene graph is that it requires too much complexity to deal with edge cases (especially when this edge cases require predictable behavior for something like rearranging DOM nodes), and because of this complexity this algorithms lose raw throughput, and in the end they are usually slower(in synthetic benchmarks) than fastest vdom algorithms. I came from a different background, and to me it is obvious that trying to "draw" as little as possible is not the best approach, sometimes it is faster to "overdraw" because throughput of the algorithm will be significantly higher. But it seems that to many web developers it is counter-intuitive.
The first line seems completely redundant... you seem to be iterating your `pagecount` variable until it reaches `this.numPages - 1` (because you're using `&lt;` rather than `&lt;=`). I.e. `this.numPages` is already your `pagecount` variable. A lot of your example code isn't valid JavaScript. [Anyway I'm reading that you can't call "action items" directly from JavaScript.](https://forums.adobe.com/thread/2066232) What you could try is setting the `viewState` like [this post](https://acrobatusers.com/forum/javascript/change-documents-properties-intial-view-js/) describes but I don't know if this works. I don't have Adobe Acrobat to test. ``` if (this.numPages &gt; 5) this.viewState = { overViewMode: 3 }; ``` or maybe ``` if (this.numPages &gt; 5) { this.viewState = { overViewMode: 3, pageViewLayoutMode: 1 }; } ``` Good luck
&gt; something that isn't a problem in the first place In what world is CSS not a problem. You use vendor prefixes and css hacks to support older browsers, degradation fallbacks even if you have to. You use bem in order not to bleed. CSS modules are complex, and you'll have to create several loader configs once you pull 3rd party css-reliant libs. CSS is utterly stupid in the sense that it knows nothing, and is almost 100% separated from your environment. You pump "CSS variables" into its bubble in order to cure some of it, but it's still cumbersome and isn't supported everywhere. The whole idea that CSS *must* be a separate container with a strange language that acts as a blackhole, overriding whatever props come before it depending on what loads first --- i am honestly asking, do you really think there's nothing wrong here? Javascript and JSON are the most obvious and logical candidates to receive styles. Most if not all issues would be cleared once the various approaches find common ground.
Thanks a lot /u/JesusVKilmer. I'll try this method as soon as I can. And sorry for my bad skills in javascript. I am trying to get better and be less stupid. :)
Not just Microsoft. Google, w3c and samsung it says in the article. 
They already do it. The news is that Microsoft has joined. IMHO that's a big deal because it shows the war is over.
&gt; I'm continuing to learn angular and the initial shock of what the fuck is all this is being replaced with the understanding that Angular/React/&lt;insert large framework here&gt; aren't really js libraries. They're development environments and languages all their own. You aren't writing JS, you're writing Angular, and that's OK. Only their CLI's are. And that's due to the circumstances. I'd start every project these days using node build tools, wether it be a static page or a complex application. These build tools bundle, make it possible to use modules, handle resources, etc. The framework itself is but a javascript-lib, what else would it be.
Any loop block will always make the web page (not the browser) unresponsive, because JavaScript is single threaded - unless the loop is executed in a worker (i.e. not in the main thread).
Microsoft is late to the party, as always, and **joins** everybody else who already was involved: Google, Opera, etc. 
[removed]
I'm not familiar with this Spreadsheet api or async.series. Can you walk me through what order you expect everything to happen?
I'm actually talking about all of angulars dependencies, which I've come to learn are 99% build tools (transpilers, linters, etc.) Those things aren't the angular cli, it's a dev environment.
[removed]
https://codereview.stackexchange.com
Exactly four letters.
Now I can‚Äôt unsee this
People probably wouldn‚Äôt have to come up with all these different solutions if CSS wasn‚Äôt inherently broken.
I tried to distill your code down into the most basic representation of the problem: https://runkit.com/embed/cte9b335ur8r It appears that the for loop with `getRows` call runs all the way through, so your `step()` gets called way early. This is a classic race condition. You might need to use another `async.series` inside `appendSheets` or something other construct. Actually, even though everyone hates promise chains I think using one inside of `appendSheets could make things a lot more clear.
dae H8 le M$?!
Haven't tried the playground yet, as I'm on mobile. But just a quick question for you CSS in js'ers out there. The last time I tried a css in Js it was using the glamourous library. Now when I was working locally (in dev and prod mode) everything worked great. But when I pushed it to a temporary host (surge.sh). I noticed that the render was a bit slow. And I'd see the unstyled components first, then glamorous would kick in and style it. Because I didn't have a whole lot of time to figure it out. I just made the content hidden, then faded it in with glamorous. Is there another solution to this? Or was I doing something wrong?
What you're describing is probably against their terms of service. Meaning even if you got the code out, if they ever found out they would sue the crap out of you.
Angular may be a special case since it'd pretty fat with AOT and hundreds of other moving parts. Normally the framework is self sufficient. That is the case with almost all of them. Their cli's then help you to set up an environment.
Agreed angular may be a special case. Haven't tried cli yet, but I've heard good things. Does it still use webpack? I thought they moved away from that particular lib, but that's hearsay
If you're writing an application for the client, you would 3nd up writing your own framework anyways. Unless you're saying you'd write a complex, fast changing application using only basic dom apis with no abstraction layer or anything. Good luck with the spaghetti you produce with that. Not to mention that your entire codebase will essentially be untestable.
You are talking when you have hard due dates. And you dont have time to think about anything. We, as developers should be able to do the same in semi native frameworks
What kind of a sicko loves npm?
"Semi native frameworks". What does that even mean? You do realize that frameworks like react and angular are native code. They are just an abstraction layer over the dom api because writing a complex app which needs to re-render based on retrieving of data, user input, etc, would be a nightmare to maintain and test. Most companies don't want to invest in writing their own internal framework because high quality open source ones are freely available.
When i say semi native, im saying: UI elements are plataform dependent, most code is cross plataform and not using a browser.
Thanks for answering! I am trying to use https://cookieconsent.insites.com/ with the compliance type "opt-in" since the Swedish laws are a bit all foggy I want to make sure I do all of it correctly. Unfortunately, I am not too experienced in javascript using "callback hooks".
It works on mobile! But that‚Äôs interesting! Have any links you could send my way (feel free to message) If anything, render/mount should be *faster* with a production build because of minification and other performance optimizations
I see a lot of comments saying, CSS-in-JS IS TERRIBLE! I personally love css-modules and think it‚Äôs the appropriate solution for my own projects, but I find myself using the right tool for the job. What I use entirely depends on the scope of the work and the tools I‚Äôm given. I have some projects that are so deeply entrenched in gulp or grunt from 3 years ago that use a global sass stylesheet, that not even css-modules are a good possibility. Why even? I can write CSS wherever, it doesn‚Äôt matter to me. But when it comes to spinning up a new project, I‚Äôll give this trend a shot to see what it‚Äôs all about. I have some concerns since css-modules are so badass imho, but I believe there‚Äôs probably a good use case for this stuff. I can think of some scenarios where an external lib might set (and overwrite) styles on a component dynamically where CSS-in-JS combined with ReactDOM could be a really sweet way to overwrite those styles with classes. It would be more cumbersome with normal css-modules. Just saying, don‚Äôt knock it until you try it... or you start working somewhere that uses CSS-in-JS. Sometimes the choice is not your own.
It uses Webpack. I think it moved away from System.js.
So basically, I want to loop through each sheet and while loop through each sheet, loop through each row of each sheet. Inside each row for each sheet, there are a couple async functions that HAVE TO COMPLETE otherwise if the loops moves on it's SOL (hence the await.
Curious about this as well.
I'm not even sure how I would use a promise chain in a for loop right now
The saying on every IT coffee mug.
Yes
Welcome to over-engineered Javascript induced fatigue. IÔ∏è say that with a love/hate relationship for it 
Where are you from mate? 
If you don't have a ROM file on hand (Attention, large GIFs): [Preview 1](https://i.imgur.com/pYI9ipl.gif) [Preview 2](https://i.imgur.com/isgIRLD.gif) [Preview 3](https://i.imgur.com/GMqDYKr.gif) [Preview 4](https://i.imgur.com/HmvBTAV.png)
an agnostic model is one that doesn't care to work with anything... What premature optimization is creating middleware for problems you don't have until you have 10 coders working on the same product and you need to make sure they're not stuck in the same box, because it's expensive to put 10 people into the same box. If you're not doing anything special then agnostic-anything will add another set of layers to your stack and you'll be stuck developing on three ends instead of 2.
I guess I misunderstood. Sorry about that. All valid points for sure.
Since the question was crossposted to /r/reactjs , people reading this thread [may want to check out the discussion there too](https://www.reddit.com/r/reactjs/comments/7ardj7/is_it_possible_to_have_libraryagnostic_models/).
Nothing much, just spent a bit of time [experimenting with declarative DOM specification via function composition](https://twitter.com/jamesseanwright/status/926850372697772035)
My experience is with AngularJS and C# WPF so hopefully some of the terminology translates over. Also, hopefully my understanding of the two is accurate haha! As far as I know, in MVVM architecture, the view model is a thin layer intended for linking your models to your views. C# WPF uses an observer model that you're talking about and AngularJS just reloads the bound portions of the UI on a cycle-basis that is triggered when you interact with the UI. In WPF, you had to use the WPF provided decorator (PropertyChanged event I think - it's been awhile) to indicate that a property is something that the UI should track changes for. If you built your own implementation, then you had to pipe it through to PropertyChanged somehow with an adapter class. In summary, if React+Redux operates solely on an observer pattern similar to WPF, then, as far as I know, you'll have to create a class that adapts your observer pattern to fit the interface provided by React+Redux.
Thanks, it's always good to hear about practical experience. I tend to agree that VM should be a relatively thin layer. The problem is, the two most popular libraries for React (Redux and MobX) both rely on certain behavior of your state/model classes. &gt; if React+Redux operates solely on an observer pattern similar to WPF I'm afraid this is not the case. Basically, Redux replaces your whole state tree on any action and compares object references to detect changes (if you want to change an object, you make a new one, functional-style). The actual state is immutable and any interactions with it can only be done with Redux actions (a form of Command pattern). So, yes, it's quite different.
I feel like having my models framework-agnostic can bring more benefits. I usually don't prototype UIs from the beginning. I start with plain classes, methods and other things natural for a given language and subject area. Then I test them via console or by other means. Only when I have a fully working model, I add UI to it. But when I discover when the whole model needs to be reworked to fit a particular library, problems arise. Having my model (a purely conceptual thing) tied to a particular UI library feels wrong to me.
cool
We develop an application that has something like plugins, the models behind that are based on redux because it is library-agnostic by design. It has bindings for everything and even if something doesn't have them, it's only a couple of lines to create them. Since the models are driven by actions internally they can be reflected by any framework or ui toolkit or even plain javascript. You simply define how a button looks, an input, send the events down by action, and the rest is done by the plugin. The downside is of course that you have to write the reducers and actions. 
lol, looks to me like this sub is filled with microsofties. The truth gets downvoted once again.
I think my issue is a bit different. I want the model to be agnostic of **state management library**, while I'm not so concerned about the **view** library (model shouldn't be tied to view in any case, so I struggle to see how this can be a problem). 
You're right, but then what you're proposing is always a middleware between whatever UI you want. And then if the UI is tightly coupled with some state management, like react/redux, you're stuck tighly coupling the middleware to that. I'd use Vuejs though, as it's pretty decoupled from a backend. 
A full-stack JavaScript app built in React / Redux / Node https://gitconnected.com - The community for developers and software engineers
I'm a huge fan of [Semantic UI React](https://react.semantic-ui.com/introduction). The components are very sensible and provide a lot of functionality by default. My only issue is that the CSS requires either a lot of specificity or a !important to override. It's been my favorite by far to work with though. https://gitconnected.com is built using Semantic UI React as the main UI library
I totally agree. Tests that *sometimes* fail are horrible. Writing tests that are designed to be different each time is just asking for tests that *sometimes* fail.
Using the CSS and letting the new framework's vdom do the job that jQuery originally did.
Not sure if that's even possible. Javascript is not reactive, and proxies aren't widespread enough. If you ship a simple class, nothing will be able to reflect it, unless you provide some surface for it, be it events, redux or otherwise. The thing with redux is, it's just 1-2kb gzipped, and it provides a surface everything can work with. But if you do find something i'd be glad to hear about it.
Why are the doors so glitchy? Otherwise, this is really neat!
These framework still have HTML markup and you just need to inject these css framework into the page. there are plugins which code these UI framework in a React or Angular way. Multiple ways to go at it
I mean its kind of a good problem to have... You as a developer have a lot of choices to swap out libraries of your choosing... Yes, difficult for beginners but the flexibility is great. 
I was reading a post the other day that explains a potential alternative to classical MVC called MOVE. Instead of Model, View, Controller, as in MVC, the "MOVE" acronyms out to "Model", "Operation", "View", "Event". In MOVE, a Model is not aware of how it is persisted. It is simply a dumb information object. You can ask a User Model if a given password is valid, but you cannot save it to a database. That is the job of an Operation. An Operation is where business logic lives. You can have Operations for saving, creating, editing models or calling external APIs and so on. Operations are triggered by Events, and Events are called by Models and Views. For example, a user logging in via a UI - when the View's Login button is clicked, an Event is dispatched to the BeginLogin Operation. The BeginLogin Operation calls the User Model's password compare method, which dispatches a PasswordValid Event to the Login Operation. I think this is a decent way of decoupling model logic away from frameworks and instead putting them in the Operation layer. This way you can simply dispatch Events off of your Models and Views inside library code (express route handlers, react render methods, etc), and the library code simply acts as glue. I've never tried this MOVE thing myself, because it seems similar in concept to what Redux and the Elm architecture is at their core - just with a little more separation of concerns, but it seems to be in spirit of what you're asking for. You can read more about it here: http://cirw.in/blog/time-to-move-on
I've been working on [the jsgui framework](https://github.com/metabench/jsgui3) for absolutely ages. I built the Controls on top of Data_Object, but as JavaScript functionality has improved, including Getters, Setters and Proxies, I've had to make use of Data_Object less. The plain object would be fairly easy to generate by using a toObject function on the model objects if there were one. You could write one if it didn't exist. Since moving jsgui over to ES6, with version 3, I've got an empty implementation of toObject in Data_Object, but that would be the way to go. Jsgui has got some nice features and strengths, and I'm interested in integrating it with React and Redux where appropriate and useful. What functionality are you looking for that is lacking in React+Redux?
https://github.com/ng-bootstrap/ng-bootstrap
extract-text-webpack-plugin, css-loader, less-loader, string-replace-loader. Here's an excerpt from my webpack config: const extractLess = new ExtractTextPlugin({ filename: '[name].css' }); // then in the webpack config rules: { test: /\.less$/, use: extractLess.extract({ use: [ { loader: 'css-loader', options: { modules: false } }, { loader: 'less-loader', options: { plugins: [ new CleanCssPlugin() ] }}, { loader: 'string-replace-loader', query: { search: ':host', replace: ':local(.default)' } } ], fallback: 'style-loader' })} The string find and replace is a little hacky, I just think it's nicer to work with.
How is framework size even remotely related to vendor lock-in? React has a pretty big node_modules, yet drop in replacements like preact are available.
A highly scalable is a burned expression, hehe Why would people pick this over next.js or Create-react-app ?
All of them except IE?
We recently released [vue-mc](http://vuemc.io) which was written with Vue in mind but actually has very little dependence on Vue. Would be quite easy to adapt it into something framework agnostic, as the only thing you'd need to change is calls to Vue.set and Vue.delete (observer pattern). 
Love it too! It allows me to do pretty prototype ! I used to have theses shitty looking prototype and some people can't see through shitty buttons.. Since then! My work life is so much easier ! Semantic-ui itself is written in a magnificient way! Worth looking at the code for its architecture. very... semantiquy hehe.. The react one not as much
I understand your sentiment, but it‚Äôs really unavoidable to some extent. For example, end-to-end tests may fail sometimes if there are timing issues because it somehow matters which of a bunch of parallel-executing requests finishes first. And I do think that‚Äôs actually a *good* thing because nobody is going to write explicit tests that cover all such timing combinations, yet you do want them covered. I do think however that test that fail sometimes are also a test of discipline. If you see the test failing and ‚Äúsolve‚Äù the issue by rerunning the suite to get it to be green again and leave it at that, you end up with an unstable suite. But if you treat a test that sometimes fails as one that you should fix and stabilie asap
No, as the article says, you don't write a random test. You use a fuzzer. Use the right tool for the job.
You could use Jquery in both Angular and React and create a basic wrapper. Or drop it, by taking over the css and do the dynamics in your target framework, there's not much to it. The problem with things like bootstrap and semantic remains that they're css based. On the outside it looks like components, but internally they have to adhere to selctors and css rules, which throws off most ports i've seen. I'd look for a real components-based solution like ant-design for React or element for Vue and Angular, i don't know any but i'm sure they exist.
&gt; Maybe it's because I come from the C/C++ world, but I'm most comfortable being close to the metal (and not relying on other people's code). To be honest, even in the C++ community, not relying on other people's code is still a bad thing. It's called the Not Invented Here syndrome.
/r/programmingcirclejerk
[removed]
Hi /u/rdv100, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Was too lazy too animate them (:
Love ts-ignore comment. It's nice temporar hack. Actually after I saw post I thought how nice it would be to have this - and boom - it's there.
What‚Äôs are the arguments against it?
Use Bulma
Fair enough!
[removed]
&gt; Let's say you write a test that creates two different users, and for whatever reason, the test fails if the users have the same name (due to a database constraint failure, write to same map key, array having 1 value instead of 2, &amp;c). Faker has about three thousand different possible values for a first name. This means that every 3000th run on average, the randomly chosen names will collide, and your test will fail. That'd be 3000\^3000, though right? Which is a very, very low risk.
Percentage of the installed ones?
You do know that CSS modules are CSS-in-JS right? And that OP is on of the creators?
If you use random, use a PRNG with fixed seed. You get n random results, but they're always the same.
http://www.instantrimshot.com
&gt; my Application is built around eval() WTF?
Very significant. Most used browser is by far chrome which auto-updates.
Eh, you can crank out features in Rails or Django at 2-5x the rate of js development. But then you won't get a fancy SPA.
If the tests only failed when the first name was "Abigail" then you would be correct. But usually the first random value can be any of the 3000 first names and the second just has to match it, so 1 out of 3000. 
Mobile at work :p not enough time to play around. Will definitely when I get home. As for an example I used [this](https://github.com/nozzle/react-static/blob/master/README.md). Using the CLI I chose the glamorous option. When using the development version, and the production build *locally* it worked. But when deployed to surge.sh it caused the problem. Again I'm no expert and am new to CSS in Js libraries. And didn't have a lot of time to tinker. My current personal project uses CSS modules. But I am looking for the perfect CSS in Js solution for me
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nozzle/react-static/.../**README.md** (master ‚Üí 28caa52)](https://github.com/nozzle/react-static/blob/28caa526ef539438c7738c5174eeb0eea822a3f5/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Got an error: ReferenceError: FFT is not defined at timestepT (eval at runCode (http://www.articlesbyaphysicist.com/q4p/q4p.js?asdf=6:30:19), :41:13) at Object.timestep (eval at runCode (http://www.articlesbyaphysicist.com/q4p/q4p.js?asdf=6:30:19), :15:19) at step (http://www.articlesbyaphysicist.com/q4p/q4p.js?asdf=6:56:55)
Ah, stupid capitalization problem. I develop on windows, and the server is linux. It should be fixed now.
I‚Äôve been making a portfolio that on mobile is a single page app. Uses js for the page changes and the buttons. Looking to start working with Vue.js [portfolio project is here](https://ssmale.github.io/Folio/) would love constructive criticism on how it works or the code 
Pretty sure this math is wrong, collisions would happen far more frequently than 1/3000... This is the same math as the birthday problem, where you'd have a birthday collision for every 50 people -- not 364
Microsoft sucks hard, they have this dumbass complex of making everything difficult for web developers especially email developers. 
Try this https://github.com/golang/go/wiki/Learn üòÇ
try disabling all browser plugins and see if it's there
Lesson 1: java and javascript are different languages. Head over to /r/javahelp
IIRC it's injected by some Google "bandwidth saver" extension or something similar. It's not on your site, but in your browser.
As long as IE9 is allowed to exist, the war is not over.
Yes, that's it. Thanks.
Thanks. Weird. Did not think about a plugin injecting code into my page.
Updated two of my libraries https://github.com/fcostarodrigo/rfc-open-path https://github.com/fcostarodrigo/rfc-walk Replaced mocha with jest. Started using prettier now. I am still missing the badges, need to look up Travis CI for that I think.
The first random value has to be the same as the second random value, so it's not 1 in 3000, it's one in 3000\^3000. 1 in 3000 would be if the tests fail if the name is "Abigail". 1 in 3000\^3000 is when the tests fail if the first one is "Abigail" and the second one is also "Abigail".
The birthday problem does not apply for 2 variables, only for more than 2 since it is exponential.
You're misusing Vue, this is a problem that you simply shouldn't have.
You pick a name. You can pick any of the 3,000 names, it doesn‚Äôt matter. You pick a second name. The only requirement is that this one must match the first. The odds of this occurring are 1 in 3000.
You just need to attach @click event to all your divs with card class rather than using jQuery to find the divs and attach a click event. vuejs is meant to replace the need of jQuery. 
I'm afraid the article lacks in some global aspects. In particular I'd say it needs a more defined structure. It needs to better define its goals and then more clearly follow the path to those goals. Instead, it wanders and loses itself too much in details. I mean, your goal as stated here is "to explain some of the fundamental concepts of frameworks". In the article it's stated in a similar -though not exactly equivalent- way: "The goal of this blog-series is to explain what frameworks do, why they‚Äôre used, and demonstrate with examples across many different frameworks." Now, that looks like a very clear goal and that's good. But then you jump from those very general goals, to one _very specific and concrete_ code example. And I don't mean that following the TodoMVC example is necessarily a bad idea, but that you jump into it and go into a level of detail where we mostly loose sight of those general concepts. In fact, you do **not** explain those general concepts. Take _delegation_. You stated back there that you were going to explain or discuss _"Delegating"_. But now the time comes and the only explanation given is this: &gt; ‚ÄúDelegation‚Äù is a technique that improves app performance by using event bubbling. This post is an excellent description of how it‚Äôs used in the Aurelia framework. (We‚Äôll discuss Aurelia in-depth in a future post.) &gt; javascript - Aurelia delegate vs trigger: how do you know when to use delegate or trigger? - Stack Overflow So, first you don't really explain what it is or how it works, much less why it would be a "fundamental concept" in relation to a framework. You just mention that it is a technique to improve application performance and that it does so by "using event bubbling". And then, offer an additional link that still doesn't explain what it is, how it works or why it is used, but instead is about the specifics of some DOM events not bubbling, the Aurelia guidelines to that effect and that's it. There isn't much explanation either about "imports and exports". Yes, you do mention something to the effect that they "glue everything up together". But... What's the relevance? Why is that "concept" relevant for usage of a framework? That's what you promised to explain! And the same thing happens to _Binding_. "We see all of the ‚Äúbind‚Äù functions here and the use of .bind to to set the this value on the associated methods. Read more about bind methods here." and that's it. A link to some explanation of `Function.prototype.bind` but again no explanation of why that "concept" would be relevant, even a _fundamental concept_, for a framework. And so far, neither of those "fundamental concepts" (binding, delegating, imports and exports) seem to be specially _relevant_ or specific to the context of "using a framework". Binding is a completely general concept. Imports and exports, you're going to be using them too if you're not using a framework (as is seen even in the chosen example). There is _a bit_ more explanation in the case of _Routing_. At least you do give some sort of indication of what it is for. But again, the explanation is so brief you could almost miss it. And in the meantime, while these explanations almost pass us by without noticing, you add a _lot_ of detail that is _very_ specific to the particular code example you chose. Like the fact that "`editItemSave` updates an item after its edited." or that "`setCompleteAllCheckbox` ensures that `$toggleAll` is set to the desired state by forcing it from its opposite to the desired state with `!!checked.`". Well, this may be relevant if we were analysing this code _to understand this particular piece of code_ in its full detail. But that was not the goal. The goal was to merely use it to extract this other more general concepts we wanted to understand. It all pretty much falls apart when we reach the conclusion. We learned "that creating a simple todo list SPA requires some heavy-lifting to be done correctly." Well, maybe, but was that what we were here for? Because I thought we were here to learn fundamental concepts that a framework uses. Please, don't take me wrong. I appreciate the effort you've made. Also, I fully understand that this is supposed to be the first in a series. And it's also a broad subject and My words above may be too harsh. I know, but it's not my intention to make you feel bad, nor is it to make it personal in any way. My intention is to make you notice how the article sets up some expectations and then follows a completely different path, focusing both too much on the code example chosen and too little in the goal of explaining fundamental concepts. I know you picked up as the first code example for a series on frameworks, one that _doesn't use a framework_. I understand that. But what a reader should receive is a much higher perspective analysis of the _general concepts_ that building an application involves, not the specifics of using `bind` or event delegation. Things like "separation of concerns". Your brief definition of "framework" (only) mentioned that is _adds structure to your code_. So it would make sense to focus much more on the general structure of the code. All you mention about structure, about Views and Controllers and anything is that _we already know about it_.
 jQuery('#container-of-dynamic-dom').on('click','.card', function(){ $(this).toggleClass("flipped"); });
why not bind it to the document? $(document).on('click','card',function() { 
This is called event delegation and is one of the most important fundamentals to understand. As in this example, jQuery makes it easy. If you are using vue, it surely has it's own form of eventing built in, so like everyone has said use that. _BUT_ I am of the firm belief that everyone should take the time to understand what is going on, so here is a write-up about it using vanilla JS: https://davidwalsh.name/event-delegate
[Interactive Fluid Simulation](https://wyattflanders.com/Fluid/ )
I made an anti-procrastination tool. Using nwjs,react,ps-node. I am really proud. Because after I made it I made my code more readable. Probably the code is still ugly. But in comparison to what it was, it's a masterpiece. https://github.com/RandomGenerator42/Anti-Procrastionation Also, I have been programming a little over six months.
&gt; 1 in 3000*3000 is when the tests fail if the first one is "Abigail" and the second one is also "Abigail". Your numerator is wrong. It's not just "Abigail", but also "Bob", "Chris", etc. So 3000/(3000*3000), which is 1/3000.
Can you call it in an async function? 
you mean like fs has. FileRead() and FilerReadSynch(). I haven't seen something like that in the documentation. 
It's a new feature in ES2017, so you'll have to use a transpiler. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
Thanks I am going to let you know how it will go.
&gt; Let's say you write a test that creates two different users, and for whatever reason, the test fails if the users have the same name ...and that's the _ONLY_ argument put forward to say faker is bad. What a load of rubbish. If I know that two users cannot have the same name, I write the test along the lines of let name1 = faker.random.firstName(); let name2 = ((otherName) =&gt; { let name; do { name = faker.random.firstName(); } while (name === otherName); return name; })(name1); And if I don't know that two users cannot have the same name, then after 3000 runs I can find out by looking at the error logs. This is a non issue.
You still have to ensure that the two names are not the same. If you do it with a fuzzer you can do it with faker too.
That HTML link is annoying unreadable on a mobile device. 
Real Estate Cashflow Calculator: [gocashflowapp.com](https://gocashflowapp.com) Built with 100% Angular 4. Hosted on S3/CloudFront for like $0.08/month.
Is using a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) an option? I've only ever read some of the docs. So I can't provide any insight on actually using them.
Can‚Äôt even tell if this is a troll or not
[This lib](https://github.com/ignoreintuition/jSchema) was just posted to hacker news the other day.
 const validClassRegex = /\.[A-Za-z0-9\-\_]*/g; Array.from(document.getElementsByTagName('style')) .map((styleTag) =&gt; styleTag.innerHTML.match(validClassRegex)) .reduce((cur, prev) =&gt; cur.concat(prev)) 
I'm not sure if this is relevant, but I find that once I take soft-deletes and JOINs usually needed for viewing records into consideration, that I always always tend to use SQL views (with separate models) for the "R" in C**R**UD, and the 1:1 models &lt;&gt; table models for C~~R~~UD. So I usually end up with different models for editing tables vs viewing data on the frontend anyway.
Do you mind reposting when this is readable on mobile? I'm sure it's a great article but it's all screwed up in anything thinner than a desktop monitor.
This basically kills any enthusiasm I have for learning react / JSX. Now it seems if you want to change the H1 size from 18 to 22pt in a module you need a dev and a build / deploy process before you even know how it's going to look. It seems counter-productive to me to tie up devs endlessly making minor style changes to CSS in JS ( without the all the benefits of SASS ) when they could be improving functionality or working on new features. It almost seems like a move to cut UX types ( non-devs who are good at massaging CSS and making stuff look awesome ) out of the loop. It's essential for me to learn this stuff career-wise, but honestly... the the thought of it is sending me into eye-roll overdrive. I too wonder at what point we'll look back and go "what the hell were we thinking?". 
I find this question interesting because Redux isn't necessary to use React and the purpose of Redux is similar to what you're already doing with your model, state management. Redux simply changes state by issuing predefined "patterns" that you define that alter the underlying state, and when that change is made, an event is triggered in the store, which triggers an update in React. You don't need Redux to use React. React itself is simply a unidirectional rendering engine. You just have to tell it to re-render when the underlying props change. That's what the `connect` function does. You're correct in your assessment that you need an observer pattern, though. Any underlying change to the data, or "state", needs to generate an event that can pass the altered state on to other functions. The trick, however, is to do this efficiently and with the capability to debug it. Redux solves the debugging part because each change to the state is documented by "action", and you can time travel by replaying all the actions. Libraries like `reselect` help with the efficiency because they help optimize the retrieval of certain sections of the "state". You could, however, have a library agnostic model for any number of tasks. You'd have to write adapters for the various frameworks, but you could underpin all of your state management with a single library, ASSUMING you can observe changes in the data. The benefit of using something like Redux is that it's well tested and there's a wealth of information from other people about how to use it, debug it, and optimize it. If you're using a model that you created yourself, you're left to your own devices if you run in to problems. I hope that helps answer your question. 
Nice! That's a whole lot further than I got. I started heading down the road of some loop that calculates the end (y) point of the terrain and draws horizontal lines with the colour extrapolated from some interpolated gradient value. Sounded awful and I backed out there and then. LOL
How dare you ...
Hi, why do you put node_modules/todomvc-common/base.js into a separate script instead of putting it together in the bundle.js. The $delegate function could be rewritten as to loop once at the beginning only instead of on each event, with a map for example. &gt; The series is aimed at those familiar with JavaScript syntax, accessing the DOM, functions, and classes and is also aimed at people who do not yet know what a framework does. I think the target audience population is slim. What do you think about [dom99](https://github.com/GrosSacASac/DOM99) ?
Wait until the DOM finishes.
dom99 looks interesting. I think it's similar to this thing called the DOM and the associated API calls by some group called the W3C.
Eyes! https://codepen.io/SarahC/pen/OxRyKK How it works (visual mapping shown by lines): https://codepen.io/SarahC/pen/QqqZgz Lots of Iris's: https://codepen.io/SarahC/pen/WZZaOY Big iris: https://codepen.io/SarahC/pen/eGeyRM Finally, iPhone, Android, and Windows Chrome version without any text around it, and full screen: http://untamed.co.uk/halloweeneyes/
can you tell how, please?
Smooth and cool.... it's great!
Make it agnostic, and then add converters for each type of expected modelling data?
Where?
Works with "Chromium Smooth Wheel Scroller" installed too, cool! Often programs like this usually break if a smooth scrolling plugin is installed.
It‚Äôs fantastic that you‚Äôve found a solution that works, however, I‚Äôve worked at three different companies that have had significant problems along the lines described in the post, so I‚Äôd hesitate to call it a ‚Äúnon issue.‚Äù At one, Faker related issues led engineers to become conditioned to just hit the ‚Äúrerun tests‚Äù button, which obscured actual issues with the tests. Ive never seen anyone go to the do..while lengths you describe in a production test.
It‚Äôs fine :D Thanks for giving it a shot. I appreciate it :)
I think it‚Äôs the ad that‚Äôs screwing it up. 
https://serverjs.io/ server.js for Node const server = require('server'); const { get } = server.router; server({ port: 8080 }, [ get('/', ctx =&gt; 'Hello world') ]);
I meant until the function finishes. Sorry. 
You must have the patience of a saint
With Windows subsystem for Linux it's not bad at all
Can you add https://github.com/zeit/styled-jsx ?
if you are using vue, you almost never need to use jQuery. you can use `data` to have each card's state(flipped or not) in an array, or make those `.card`s stateful components. i created a simple [demo](https://jsfiddle.net/karamarimo/aetr05ev/) that uses the former way.
Just add the style to your div from the start. Beware though that users can still inspect the page to read the answer.
It can be a bit frustrating, but I don't super like the meme. I prefer 'Chrome is the new IE'. But I'm comparing it to IE for a different reason. They're rapidly becoming the only main browser which is what originally caused the lack of innovation after IE6. Diversity is super important for standards. I'm not a big Safari user, but they're doing some stuff really right. Power consumption and privacy come to mind. Chrome is not gonna be a market leader in protecting your information.
Yes. I used this module now it works. https://www.npmjs.com/package/webworker-threads
thanks, thanks. i try
ah, sorry. I'll test it out and see if I can make it work there too.
sorry sorry sorry
... id="myDiv" style="display: none"
thank you so much
this should be called HSON
&gt;There‚Äôs another class of errors where you let Faker choose a number between, say, -100 and 100, and it fails on 0 or at the ends, and **you didn‚Äôt validate it properly as the test writer.** Thus isn't an issue with Faker vs other libraries.
cool
AS A HUMAN I APPRECIATE THIS. But seriously, *why*? JSON is not meant to be written by hand. If you need "JSON for humans" just use YAML which is actually designed for that. You'll need an extra converter or parser either way.
how does this make anyone‚Äôs life easier? it doesn‚Äôt 
if JSON were extended to allow comments, that would make plenty of people's lives easier.
Humanscript object notation?
any change to the current, pretty much perfect standard would break it, resulting in lots of implementation pain and hours of extra work on all sides. yaml and others already have tried to fix this but JSON is a format targeted at machines, is widely adopted and works just fine. why ruin it with the next hot thing?
This would completely break interop with a third-party system since they would need to implement JSON5 parsing as well. Widely adopted standards take time to evolve for a reason. 
For the same reason we spend time updating old standards all the time: it's an improvement.
You can bet there's someone in there who worked on the XML specifications, or at least has the same brain parasite. 
Why would you comment a JSON file?
I'd personally find comments useful for local configuration files, like package.json or for webpack. I'd rather not learn yet another markup language; JSON seems like a more natural config language to use JS projects. I agree with your point for Machine-to-Machine JSON, like API responses, I'd take nice, formatted documentation over comments anyday. 
Config
The site explicitly states that this is not an extension to JSON but a new separate data type independent of JSON with it's own file extension and (soon) mime type. Clearly they've anticipated your objection and responded to it in the proposal. It makes perfect sense to provide this as an alternative to be used for new code in situations where the current JSON constraints are restrictive and burdensome.
You can do most of this in YAML, which is a superset of JSON.
When you use it for configs instead of YAML. TOML etc.
If you want syntactic sugar for JSON, why not just go all the way and use YAML?
Floating point calculations not being used?
If it were support trailing commas, it would be even better.
&gt;the current, pretty much perfect standard would break it, lol! JSON is nowhere near perfect. It lacks support for comments, trailing commas and versioning. &gt;yaml and others already have tried to fix this but JSON is a format targeted at machines, is widely adopted and works just fine. why ruin it with the next hot thing? Good point. The heart of this issue is that **people are using json for file which are meant to be edited by humans eg: package.json, composer.json etc** So, technically, you are right, issue is coming because people are abusing json (kinda like they abuse html/css/javascript) However, we can't fix people, but we can fix json. 
No thanks
In that case wouldn't it be better to provide a README with actual instructions and comments? Much clearer and easier to read then a JSON file with comments in it
Why not?
Just the ability to break text over multiple lines would help me no end when setting up test data for example.
How about nope? Most of these are trivial changes, for handwritten JSON you could just preprocess this away and keep compatibility with regular JSON. If the argument is "human written configuration", go with YAML or something like that and convert it to JSON at build time.
I had the same reaction. Because JSON isn‚Äôt for humans. It‚Äôs a format for data exchange between computers and has just enough features to be simplistic and to the point. This HSON isn‚Äôt bad looking, just not comparable to json since it serves a different purpose. Just name it something independent of JSON rather than introducing a new data exchange format and trying to piggyback of another formats success.
Say I've got an API that returns JSON. I want some test data for it, and that test data includes some big chunks of text. Having the ability to split that text over multiple lines rather than having one massively long line would make my life easier.
YAML is absolute garbage. It takes a simple format (JSON) and completely ruins it by adding multiple different ways of representing the same data, and adds *meaning* to white space. Utter junk. 
JSON is the standard, and it doesn't just apply to javascript, so why it's been updated with ECMAScript in mind is beyond me. Not only that but it requires both the sender and the receiver to learn it, and adopt it, you can't just do it on one side. In which case, standard json will do just fine. I'm not that familiar with JS, but have been learning React and JSON is automatically parsed anyway when receiving it. So I don't have to worry about it. Haven't been in a situation where I've had to build and send JSON in JS but I have in other languages and its not difficult because I already know how to format JSON.
The thing is that sometimes a human needs to amend JSON. 
`{ ‚Äú__comment‚Äù: ‚ÄúJSON is fine‚Äù, ‚Äúdsn‚Äù: ‚Äúmysql:host=localhost‚Äù }`
I've done this a couple of times in config files. Not perfect but at least a legal comment. ` { ‚Äú//": "my comment" } `
Not sure what you're doing here. Are you providing a button to allow each browser to convert the current page to PDF, or are you just distributing a single PDF to be viewed in-browser by the viewers of each browser?
PDF viewers may be considered similar to web browsers: They render output from a script. But that's a very superficial similarity, since HTML and PostScript are nothing alike. You could render them server-side using a PostScript template or generate them client-side, e.g. using [PDF.js](https://github.com/mozilla/pdf.js).
Then it‚Äôs not JSON anymore since there are a bunch of breaking changes. This is more of an breaking alternate syntax to YAML, and drawing comparison directly to JSON is begging for Internet nerd complaints(me right now). Again, it looks neat, but that ain‚Äôt JSON by any means.
I like this idea a lot. I‚Äôm stealing.
Standards can change over time, it's a thing.
For a small donation to a medical or wildlife charity of your choosing it is yours for a lifetime. 
It doesnt matter who generate the PDF. The same instructions will generate the same result. Not like HTML and CSS.
That looks quite impressive. I think my math skills have become a bit too rusty to understands this tho.
I've mentioned in other places a fairly common example that I've had - test data for a JSON interface. Some of the new features here, such as splitting text over mutiple lines, would be quite handy, as would being able to add comments to that test data. I'm not going to rewrite the entire thing in yaml to get those features, but I'd happily use this. 
You're not improving a standard by releasing a library on GH.
You know how cool sorting visualisations look like? https://www.youtube.com/user/AlgoRythmics
While there are some thing, I'd like to see in JSON (comments, trailing commas), some of the extension proposed here are problematic. * Unquoted keys serve no real purpose, but make the syntax more ambiguous and harder to parse. * Same for single quoting of keys and strings. * Adding Infinity, -Infinity, NaN, and -NaN to numbers poses problems for non-JavaScript languages that can not represent those with their number type. The other changes are so minuscle that changing them would not be worth the compatibility hassle with existing parsers. Generally, I get the feeling that people try to apply JSON to everything, even to areas where more suitable formats exist. A bit like the XML fiasco from last decade.
I hate this idea a lot.
Thanks for explaining, I didn‚Äôt see your other comment. So here you argue simplicity benefits of testing, but you‚Äôd have to rewrite the entire receiving end to interpret a new format. It sounds more like you‚Äôre in need proper client side testing tools. In this case, something that converts this new format into real JSON before sending, rather than having to rearchitect the client and server to get around an edge case.
Nice article!
It's a proposed extension to JSON. If it were adopted, then there would presumably be no need to rewrite anything - you could just start passing JSON in using these new features.
The JSON standard can't be changed, it was released without versioning. You'd break everything.
why are people so quick to take out strict typing? is it really that much of a hassle to type quotes and keep your commas in check? 
If you were going to rewrite JSON, instead of pointless things like trailing commas, why not implement things you literally cannot represent in JSON -like recursive data structures
Or you can do all of it by renaming the file to .js and slapping an "export" in front of the first bracket.
This is my main beef with this. It might have some valid improvements but run through IETF and validate the improvements by committee. https://tools.ietf.org/html/rfc7159
Accepting a new standard doesn‚Äôt cause it‚Äôs automatic implementation. Sending this new format to any json accepting service would cause it to explode. 
It's nice to have both for different reasons. I mightn't want to document the purpose of the config element, more why it's configured that way.
Also, this would make JSON parsing/encoding a lot more complicated and probably slower
Doesn't work with some JSON interpreters as you can't use the same key multiple times in one object.
True, but it's the first step towards adoption. We shouldn't resist standard changes purely on the grounds that they might cause issues with backward compatibility issues, particularly if it's a case of things only breaking old systems when the new features are used.
It's almost like it's jumping up and down and screaming at you and you don't see it? You know, there's a thing one should be using every damn time they write any HTML markup to check for such things and, only on reddit and other amateur forums, do I find people who don't know what it is or that it exists (much less use it at all).
What‚Äôs your argument against?
Publishers could optionally provide multiple JSON versions and consumers could decide which versions they are capable of reading.
I think you missed the point. They didn't rewrite JSON, they made a syntax that's easier for humans to type.
&gt;JSON isn‚Äôt the friendliest to write. Keys need to be quoted, objects and arrays can‚Äôt have trailing commas, and comments aren‚Äôt allowed A new standard all for these little non-issues? F*cking deal with lack of trailing commas.
Get creative ‚Äú//c1‚Äù: ‚Äúcomment‚Äù, ‚Äú//c2‚Äù: ‚Äúanother comment‚Äù
if you read it; against taking out strict typing
How is documentation in an external file better than in-context comments?
Error Invalid JSON: unknown key "__comment" found. Please 
As far as I know, it's using double precision more-or-less throughout. The variables might get accidentally initialised to integers in places, but they'll quickly drop back to floating point -- javascript does that quite automatically.
Try add 0.2 and 0.1 (think that is it) in javascript
No, thank you. 
It requires a different parser, stringifier, standard, file ending and mime type. I don't want to anal about terms here, but it looks very much like a rewrite to me. If you want to make JSON easier to write, use tools. Like a decent editor, linter, or a script etc. Things that are all completely compatible with the current JSON standard. If you want to document JSON, use a schema. It provides much more functionality than comments. Or just add comments and use a preprocessor to remove them. My point is, if you're going to go through all the effort of trying to create a successor to JSON. Then why not address some of the actual problems that are impossible with the current standard. I don't see why anyone would take the hit on interoperability and performance for such trivial benefits.
If you already have a working model, you don't have to use redux. just use react, call your model methods, and re-render the UI with `forceUpdate`. It's not nice, but it's an easy solution for a simple prototype app.
yeah, double precision is default, and so 0.2 + 0.1 = 0.300000004 or something. The main error comes from the grid that the simulation is on, and the timestep being not as accurate as it can be, rather than from the limited precision. It is possible to get to machine accuracy with chebyshev integration and a very fine grid, and in some cases, the machine precision is important, but for these simulations, it's less important.
&gt; Numbers can include Infinity, -Infinity,NaN, and -NaN. Oh good. The lack of -NaN was the one thing holding back adoption of JSON at my company. We didn't have a reliable way to propagate undetected arithmetic errors across machines in our cluster, and persisting them to the database was a real chore.
At least use true multiline strings, like what they have in python or JavaScript template literals. Escaping every newline cuts directly against their claim that this is somehow motivated by some faint shred of humanity.
In my opinion markdown or regular text file would be much more readable then a combination of configuration and documentation that were put together in a single file. E.g - { // The API host bla bla // bla bla bla "hostID": 213123 } Or - conf.json { "hostID": 213123 } README.md **hostID** * represents the ID of the AWS' EC2 instance which connects to our bla bla bla bla * hostID should be numeric * more info * yada yada Much more readable and maintainable in my opinion
yep, or HorrificSarcarsm object notation :p
I don't understand this argument. Can it something else and let people use it if they want to. It doesn't mean it will be *forced* on anybody.
`Uncaught SyntaxError: Unexpected token ‚Äú in JSON at position 2`
Json doesn‚Äôt have versioning built in. Any change breaks the 1.0 spec. There are millions of independent json parsers out there. Every one of them would need to be updated for this to work. 
Exactly. The use case where this is useful and yaml is infeasible is so small that the whole inconvenience of dealing with two types of json makes it seem ridiculous to me. I don‚Äôt want things to be optional when it comes to streams. It‚Äôs important that they are consistent so that they are easy to parse. I like being able to easily apply regex to validate json files. 
That's what these alternative formats are trying to avoid. I agree with GP: inline comments would be much more intuitive and easier to use. I don't see how separate files are more readable or maintainable, since you now have two files that need to be in sync.
Exactly. Take a JSON file, add comments, skip quoting keys, skip quoting values, rename to `.yaml` and you have a working config files with all of the JSON benefits, none of the YAML ambiguities and most of the JSON5 additions.
 "//c1.5": "Almost forgot to mention...", "//c1.625": "Third thing I should mention...", "//c1.75": "Second thing I forgot to mention..." 
Ah, the XML hate game. JSON offers 2 data dimensions (keys and content), XML offers 3 (tags, attributes and content). JSON lets you put data in a tree and add one custom label per node. XML lets you add an entire dictionary per node. JSON can't do what XML can without becoming as verbose as XML, and XML is too verbose if you don't require the third dimension.
Sorry, not now
&gt; asolute garbage &gt; Utter junk. That's a bit harsh. Yes, YAML is a much more complex and ambiguous format, but it adds a lot of useful functionality. If you don't like it, that's fine, but it most certainly is not "absolute garbage". Ease up on the hyperbole.
We absolutely should. Any break, big or small, is completely unacceptable in a versionless standard like JSON. This kind of stuff belongs in a preprocessor, anyway. Comments, broken strings, single quotes, dangling commas, etc. are all completely useless to machines. If you want them, write your data in JSON5 and compile down to JSON. Personally, I think the features gained aren't worth the added hassle, though.
I wonder when we'll finally stop getting "check out how to do X in ES6!" articles
We *can* fix people by *not* "fixing" JSON. Eventually, they'll learn that JSON doesn't make for a good human-editable file format, and choose something more appropriate.
But it isn‚Äôt invalid. I‚Äôve actually used this in practise. 
Phones aren‚Äôt too good for coding, but you get the point. 
I say, Hey, way to go and make a project and get better at coding! With that helping-people attitude, you'll go far. In reality, I think this may be a little unnecessary. It adds additional processes, and after a year of working with it, I thought JSON was perfectly readable. I'm a stickler though and align my colons and single quote everything - but in the end, it's beautiful and easy to read.
How do you see unquoted keys making the syntax more ambiguous? I don't have issues with unquoted keys in JS object literals. I'm not sure that other languages not supporting Infinity etc really matters. You can already put a null in there, which isn't applicable in a lot of languages, and either way a program has to be able to throw an error if it doesn't like the data it's been given. This is actually the only new ability to encapsulate data that the spec is putting forward. That said I think your final point is the killer one. It's likely none of this is worth creating the versioning headache of having older parsers not be able to parse newer JSON. Even though proper comments would be great. 
I don‚Äôt think it‚Äôs overly harsh. Many times people I work with have been tripped up by some stupid ambiguity using YAML, and it‚Äôs way harder to learn given its mish-mash of different ways to do the same thing. I really don‚Äôt see any point to it. 
Using a JSON schema for your config gives you documentation, versioning and validation. Comments just give you (probably out of date) comments. 
No they could work as normal and new endpoints serving JSON 2.0 could provide to newer parsers. JSON doesn‚Äôt need to have built-in versioning for this to work, and besides versioning could be added to the 2.0 spec.
"New" "jQuery based". Why?
So which parsers support which spec? I'm sending you a json file, which do you require? What happens if I send the wrong one?'' 
It's nice to have both for different reasons. I mightn't want to document the purpose of the config option, more why it's configured a particular way.
Prior to sending the JSON I request some metadata asking if you support 2.0.
Sincere question: why not? What are jqueries' faults? Is the alternative just the new vanilla js and if so what makes it better? 
But I don't. It's all parser dependant. 
Is your argument that we haven‚Äôt yet figured out the full upgrade path? If so then we‚Äôre in agreement; it‚Äôll take some organization and planning. But if your argument is that it‚Äôs not possible then that‚Äôs where we would be in disagreement. I know it is possible.
 { "// this is my comment" : "" }
If you're working on any substantial UI, jQuery leads to poorly structured spaghetti code that is tightly coupled to the DOM and has no sense of separation of concerns. The solution is modern view libraries and/or frameworks. They encourage good, de-coupled design patterns. And if you're not working on a substantial UI and are just adding a couple dropdowns to your page, why would you pull in a big monolithic library?
[Hjson](https://hjson.org/) is a thing and it is just as pointless.
They've already introduced breaking changes - allowing a JSON file to be just a string, number or boolean. That would break any parser expecting it to be nothing but an object or an array.
These proposed additions seem to be sugar for JSON. Why bother writing a new standard and then convincing people to adopt it, when you could transpile JSON5 into normal JSON? Say, for instance, comments; just strip them out of your JSON5 and you've valid JSON. Why not instead write in JSON5, use transpiled JSON in your applications? 
Exactly. Developers should stop using JSON as a configuration format if they want comments so bad. [TOML](https://github.com/toml-lang/toml) is a configuration format.
JSON is like a human-data interface. So I think the only thing really missing from it is comments.
That is the developer's fault for choosing the wrong tool for the job. YAML and TOML are config formats.
Wait...someone undersrands how a framework using 296372919267229137112337 dependencies works under the hood? Crazy people...
Why are you commenting your JSON so heavily? JSON5 is not the answer, YAML and TOML are.
Try [TOML](https://github.com/toml-lang/toml) then.
Can `null` not do the job?
True, but OP isn't crying about anything just asking for some guidance.
Personally I love this. Quoting keys always made it harder for me to differentiate between data and keys, and comments are a godsend.
Did you mention comments too? Xml seems to do what this wants to do. Just use xml. 
So you don't like it because it's not what you're used to?
You could also run your join though a minifier before parsing.
``` { "version": "0.0.2", "//": "dickbutt" } ```
Unfortunately only one per level
Would have to be a very long line
Yes. But it could also be a configuration that is read dynamically at run time and that is configurable per deployment and could do with some helpful comments for techs. 
Lol. Must be nice living in your made up world. 
Same. That's literally the only thing I care about of the proposed features.
Avoiding ambiguity? 
It's just an example. For readable multi line you could have an array with strings for value. For multiple separate comments in one objects your can use the key for a title or something. If it is a config file, all your implementation has to do is ignore unknown keys. The double slash for key is just there as a visual cue because we are used to read them as comments. It could just as well be markdown syntax, like "## input path": "must be absolute from system root". 
I replied about that [here](https://www.reddit.com/r/javascript/comments/7awlrg/json5_json_for_humans/dpdnqsi/). tl;dr use whatever you want for key. "//" is just there as a visual cue. Go with "// Input files", "// WARNING" or whatever is relevant for that comment. Hell, you could even put the entire comment as key if you want. Then it should very well be unique. 
YUCK! I like adding comments, but JSON is great please let it alone. If you want to create your own goof ball thing go ahead, but don't call is JSON... Maybe call this thing XSON
I threw a penny at a bird once, does that count?
http://yaml.org
Exactly. Although I could go for trailing commas too.
&gt;Eventually, they'll learn that JSON doesn't make for a good human-editable file format, and choose something more appropriate. Like maybe JSON5?
https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr
Quotes aren't too bad, but training commas are useful since you can add/remove lines at the end of a structure without touching any other line, and diff-tools tend to be line-based. 
I think the person you replied to was being sarcastic
Kind of a dumb argument IMO. Gasp! Sacrilege! Yeah, yeah. But just because some people abuse a feature doesn't mean it should be stripped out entirely. I mean, JS is *FULL* of features people abuse. We'd have to throw the entire specification out if we got rid of things Crockford saw people doing wrong.
I think our robot overlords in the future would be very displeased if we left dangling commas. There'd be whole robotological debates on why such a useless appendage was _added_ to a specification.
just as bad as java projects always using xml for config...
I am by no means an expert in data formats, but what "real" difference is there in XML's attributes vs tags, beyond a purely syntactic one? For instance, the following attribute : &gt; &lt;human nationality="Indian"&gt;&lt;/human&gt; Could also be easily expressed as : &gt; &lt;human&gt; &lt;nationality&gt;Indian&lt;/nationality&gt; &lt;/human&gt; Which, in JSON, would just be expressed as: &gt; { nationality : "Indian" } // you'd presumably assign this to a "human" variable somewhere, or save it to a "human.json".
Using jQuery with a VDOM library is exactly what I did when I was first learning React.
At least xml allows comments. 
The fact that it doesn't change means it has an implicit version already, and it's called `application/json`. The next version can be called `application/json2` or some other name if it's not backwards compatible.
Oh my god, do you even HTTP? *Resource* and *representation* are orthogonal. You don't add new "endpoints" just to serve a different format. That is literally what `Accept` is for.
Try/catch limits optimizations in some JS engines but the latest versions of chrome should be fine. `eval` itself is generally slower since it has to invoke the JS interpreter but I'm not sure how much this will affect performance. Can you explain why you're using `eval`? It's off topic but I'm curious.
Hi /u/ianlumm, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/eligloys, For javascript help, please visit /r/LearnJavascript. Thank you!
I'll refer you to [the man himself](https://plus.google.com/u/0/+DouglasCrockfordEsq/posts/TN4Y2xy64Yq).
That's what is what I'm referring to as a new endpoint but I think you took what I'm saying as necessarily meaning a new *route*.
Like HCON.
Change `rgba` to `rgb` or add a 4 parameter like `rgba('+rand_rgb1+','+rand_rgb2+','+rand_rgb3+',1)`
Of course it is. With Faker you get a false guarantee of ‚Äúmore coverage‚Äù versus hard coding the number ‚Äú7‚Äù and making the test pass every time.
Not really, no. JSON5 is equally inappropriate for the task. Adding comments and dangling commas isn't going to fix what ails it.
xml also allows so much you have to use a special library to make sure people don't cause the parser to crash your system. 
You lost the human part in your JSON. You also changed the semantics of the XML so that the text content of the human element went from "Sanjeev" to "Indian Sanjeev". Looks like you're not understanding the *markup* part of XML.
At least Hitler liked puppies. 
It would be better to use a different format. HCON is great for configuration files. YAML, even, is better than JSON.
Well, that‚Äôs the thing about XML - it‚Äôs a text markup language, so applying it to structured data (or at least, data MORE structured than a table) is non-obvious. If you imagine tags as table column headings, then your second XML formulation is more obviously correct. But this falls apart for any kind of relational or tree-structured data, because that‚Äôs not the use case XML was designed for. 
&gt;adds *meaning* to white space. It's called semantic whitespace, and it's a thing. See: Python, Haskell, Occam, SASS. Your JSON must look terrible if you're not already indenting it.
They are the same resource serving two different representations, like I said. We don't describe the Web using whatever terms WordPress chooses to use, since they don't have formal definitions outside of it.
awesome! thanks! was it more-so the lack of the 4th paramter in `rgba` or the addition of the color variable that helped?
What you *said* is: &gt; Oh my god, do you even HTTP? Resource and representation are orthogonal. You don't add new "endpoints" just to serve a different format.
Completely agree. I don't hate XML, I do hate the complexity of working with schemas and namespaces and all the other crap that is only appropriate in 1% of projects but turns up in 90% of them. I used to work on a product where some smart bean said "We'll put everything in XML and then the users can just write some XSLT to customise it". The users didn't learn XSLT and it didn't end well for anyone involved. What's particularly annoying about it is that the suite of XML technologies are actually really clever and can solve some quite hairy problems. So I'll take back my attack on the people who designed the technologies, they may have cake, but I'm launching a new attack on every person who ever massively over complicated a project with them :)
So a user has a personalized certificate, so if they want to download it I have my express template 'render' in memory with their personal options, then I'm passing that output into the html-pdf library. That is all working fine, but I have to use some different css when I'm rendering to the browser vs when rendering into html-pdf. So my question was really 'how many pdf viewers do I have to check my pdf in before I'm confident that everything is good'.
Thanks
Or just import a regular .js if it's a config file.
 I am aware of the semantic changes. But from my point of view, all these documents store the same "degree" of data. I could deserialize any of these documents and receive the same information. As I said in my last paragraph, the "type" information can be easily be stored as a "type" key-value pair. Or you could omit it entirely, since standards like JSON Schema exist precisely to validate the "type" of a JSON document. I don't need a "type" field or a "human" tag to know if a document is describing a human. Instead, a "human" document is any document that has a "name" and "nationality" field. In a simple scenario like the one I just gave, XML provides little-to-no benefit over JSON as a data storage format. But perhaps you have a better real world example that would show how XML could store data more efficiently than JSON?
This is the correct answer and should be higher. I'd be trivial to write that transpiler and reap the benefits of new features. Zero reason to change how the actual data is sent on the wire.
your jsfiddle is not working... all i see is a black screen. i replaced "rgba" with "rgb" and it started showing circles. also, you are only assigning a value to `radius` later in the block. this will cause bugs so put that statement before the for loop. for (var i = 0; i &lt; 26; i++) { var x = Math.random() * (innerWidth - radius * 2) + radius; var y = Math.random() * (innerHeight - radius * 2) + radius; var dx = getRandomInt(-5, 5); var dy = getRandomInt(-5, 5); var radius = 50; circleArray.push(new Circle(x, y, dx, dy, radius)); }; actually, the color only changes when a circle hits the border. set the number of circles to like 3 and you'll see it.
Ya know, you're right. For storing repetitive data, XML offers no real benefits compared to JSON. But for storing documents like HTML pages, XML is super useful because it clearly separates "containers" from "content", and makes documents easy for humans to understand and modify. While I could put "&lt;nationality&gt;" as a sub tag of "&lt;human&gt;", it would be pretty awkward to see "&lt;style&gt;" as a sub tag of "&lt;div&gt;". All of which are easier to read and modify than '{ "tag": "div", "style": "color:red" }' when it's down several layers of nesting.
Your problem was just the lack of the 4th parameter in the RGBA.
PDF viewers are all trying to implement the same ~2000-page specification. As with all large specifications, some aspects will inevitably be interpreted differently (or downright incorrectly) by different implementors, but core stuff like text placement rules should hopefully be pretty watertight. I'd test your PDF display on: * Firefox, which uses PDF.js; * Safari, which may use Apple's own PDFKit(?); * Chrome, which uses "Chrome PDF Viewer" * Anything you have access to that explicitly uses an Adobe Acrobat plugin I'm sure there's others too, but this should be a decent testing palette.
Fair enough, but every standard needs to be able to change.
You'd just be creating a new data format, naming it json2 would have no practical meaning. You can't just decide to use MIME types for versioning. Anywhere a piece of JSON was disassociated with it's MIME type (like everywhere), you'd have no way of knowing what version it is (all broken). If you decide to stick the versioning in the file (where it should be), you need to make it so that is incompatible with the current standard. Since JSON has no reserved words, every possible valid piece of JSON could be being used for something i.e. pick `{ "version" : "x.y.z" }` and you've just broken every package.json file ever. But if you make incompatible, then no current parser has ability to tell you whether you've got valid piece of JSON, but in a different version, or just some invalid or corrupted piece of garbage. So they're broken. Sure, you can make new parsers that can tell the difference, but they'd just be parsers that understood both, and they'd be restricted to treating versionless JSON2 as JSON. i.e. they couldn't tell the difference between corrupted or invalid JSON2 and JSON. Broken. There is no existing mechanism or support within JSON for updating it. So for all intents and purposes you might as well be creating a brand new format. If you wanted to do that, I don't see why you would tie yourself to being like JSON before you even started. Might as well go for greenfield. 
[Learning javascript 2017](https://www.ivanjurina.com/learning-javascript-2017) I recently started learning JS. Made some notes from some courses and tutorials, maybe someone will find it useful.
Dates?!?!? Still no fucking dates?
Actually, one of the goals of JSON is [specifically **not** to change](https://youtu.be/-C-JoyNuQJs?t=18m5s). This goal is even alluded to in the intro of the ECMA-404 standard: &gt; Because it is so simple, it is not expected that the JSON grammar will ever change. This gives JSON, as a foundational notation, tremendous stability.
That's not really how this works. If you're choosing to be dependent on a 3rd party lib you need to be able to answer "why?", not force others to talk you out of it. The problem that jquery solves is largely a non-issue with modern browsers. The days of ubiquitous jquery are behind us, and you need to provide some justification for using it.
Video linked by /u/captain_covfefe: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Douglas Crockford: The JSON Saga](https://youtu.be/-C-JoyNuQJs?t=18m5s)|YUI Library|2011-08-28|0:49:26|354+ (97%)|45,677 $quote Yahoo! JavaScript architect Douglas Crockford tells the... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/captain_covfefe ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt; Adding Infinity, -Infinity, NaN, and -NaN to numbers poses problems for non-JavaScript languages that can not represent those with their number type. On one hand, most languages are already incapable of representing every valid JSON number (of which there are infinitely many, because the spec does not limit the range of valid numeric values). On the other hand, what JSON parsers do in practice is utilize the floating point types from their corresponding languages. Those types are (almost?) all following the IEEE spec that already supports infinities and NaNs. All in all, this particular point shouldn't really be a problem in isolation, though it does complicate parsing if added alongside the other features (hex, explicit plus, leading dot).
Were map, filter, forEach, and reduce not available before ecma2015?
You don't even need a transpiler. The spec is a subset of valid JavaScript objects. You can just add a `module.exports =` or `window.whatever =` at the front of the file and you know have your data.
To be completely pedantic, JSON stands for JavaScript Object Notation. It was meant to be a subset of JavaScript/ECMAScript. The fact that it has parsers in pretty much every other language is just a consequence of its readability and ease of use.
Yeah you're right, they were. But now you can use arrow functions with them, so I thought thats worth a mention.
I like the library, but I'm in the minority because now everybody seems to think: 1 html-components is the way to go (see angular, react, vue) 2 jquery is a mortal sin (see messages here) 3 every widget should be big and flat (see material design, uikit) 1 is unsolvable 2 could be mitigated if you change the dependency from jquery to zepto or any other more lightweight selector lib ([ki](https://github.com/dciccale/ki.js) maybe? or even nothing) 3 is less important if you target corporate environments, where your excellent grid could be a big plus Anyway, good luck! an excellent UI, I really hope it takes over 
üëç
I disagree. I've started using yaml because I find it much easier to read and write and it has unquoted keys. Single quotes aren't any harder to read than double since I'm looking at javascript all day anyway. In fact, when not using yaml we've started simply exporting a json object and requiring that instead of using a json file where appropriate. Comments are the primary motivation there, and they're worthwhile.
That's great thing, but for node.js scripts I prefer just to export JS object, e.g. `config.js`: module.exports = {/*do what you want to do in JS syntax, not JSON*/}; // in some file: const config = require('config.js'); 
Fair enough, cool thing to know
Seems a bit dumb to me - no-one is smart enough to think of all future eventualities for a standard's use. But I guess he knows what he's doing. It seems a bit of overkill to create an entirely new standard for the stuff being proposed here, and the use cases that I'd find them useful for aren't ones that immediately lend themselves to converting over to something like yaml, so it seems a shame that we may never see small but useful enhancements simply because someone decided it should never happen.
{"comment":"This is my comment"}
&gt;readability and ease of use Which is the crux of the issue. If it ain't broke, don't fix it. If only because "fixing" stuff in this industry tends to break it anyways.
Hmm at this point why wouldn't you just use a standard js file and js object?
Strict typing is a good thing 
Well, the reason I ask is that when I started with js some time ago, jq absolutely made my life easier and I fell in love with it then. I haven't followed the state of js lately which is why I ask, what makes "not jquery" better? I get your point but lately I've just seen a lot of "jquery, omg why?!" and I don't get it. But then, I'm not a front end dev.
&gt;Again, it looks neat, but that ain‚Äôt JSON by any means. And ES6 isn't JavaScript. 
If you are using JSON for a config file and your key naming is so obscure that you need comments to figure them out, then maybe it's not the fault of JSON.
This is what I do for node apps. My config files are just a big module.exports = {...} with the object literal filled with my data.
That's not the point. For a data exchange format, directives would completely destroy the ability of the format to be reliably interpreted. The fact that it is limited is actually a feature.
But YAML and TOML aren't JSON, and context switching sucks.
But wouldn't it be easy for developers to write their own mustache-esque syntax using the `HTML template` specification? Basically, wouldn't it be 'walk this small template DOM and replace `{{ KEY }}` with the value at `obj.KEY`? To me, it makes much more sense to build our own abstractions on top of the `template` specification instead of having an angular/handlebars/etc like syntax built into the browsers. However, I haven't used this syntax in a long time so I might be talking out my ass here.
&gt; "jquery, omg why?!" The answer, succinctly, is that it's largely unnecessary given the state of modern browser apis and UI frameworks. the problem it solved isn't really a problem anymore.
YAML is a superset of json, so it is json. Just with bells and whistles added
No, YAML is not JSON.
Build a schema that validates this. Basically impossible.
JSON is a data interchange format meant for machines that is conveniently human-readable. That's it. The fact that people keep trying to misuse it as an editable file format is not something to be admired or encouraged, let alone something we should be breaking the standard to facilitate. There are far more appropriate formats in existence for that purpose, virtually all of which solve the problems people keep trying to "fix" JSON to solve. So, why don't people use those instead? It's the age-old developer plague of using what's convenient and familiar to you instead of the best tool for the job.
Looks and feels great. It might be a good idea to put a link to the source code if you don't mind.
So which is the better format for me to create test data for a JSON service that's got large amounts of text in it?
Presumably, your the service is meant to communicate with client software and not humans, so JSON makes perfect sense (ignoring the obvious point that JSON is likely the *only* format understandable by a "JSON service", making it the best format by default).
And in that test data, I'd like to be able to split my text over multiple lines and add comments in there. So which format should I be doing that in?
There would be no practical reason for you to do that. Test payloads are not something you would be reading enough for such a thing to be beneficial to you. And if they are, then 1) your tests are far too fragile, and that's the real problem, not JSON; and 2) you should be using software with a friendlier user interface to generate the payloads, rather than editing them by hand.
Why should I be putting in a whole bunch of extra tools to do something that my standard editor can do perfectly well (except for the lack of splitting lines and adding comments)? And why do you think that test data isn't something that people (either myself in a couple of months' time, or someone else in the team who's not seen this area before) might want to be able to understand? What's "fragile" about people understanding what a particular bit of test data is meant to represent?
The quoting requirement is kind of a pain in the ass too. I always create a .js file and export a js object as its easier.
&gt; Why should I be putting in a whole bunch of extra tools to do something that my standard editor can do perfectly well (except for the lack of splitting lines and adding comments)? You shouldn't. Note that I only suggested that you do such a thing if your tests are fragile (meaning, you've already screwed up), and you're bound and determined to hand-edit payloads often enough that such features would actually benefit you. This is not the common case, nor is it in any way desirable. Your payloads should basically be write-once and read-never. The more you break that rule of thumb, the worse your tests are (or, by proxy, the more unstable your application is). &gt; And why do you think that test data isn't something that people (either myself in a couple of months' time, or someone else in the team who's not seen this area before) might want to be able to understand? Because the payloads are the wrong place to explain your testing methodologies. You should be doing that in your tests. If it helps you understand why, consider that JSON being human-readable is merely a convenience. An implementation detail. You certainly wouldn't be trying to explain yourself with comments embedded inside a PNG or JPEG payload, would you? No. You would explain yourself in the appropriate tests. The payloads are the wrong place for such things.
https://xkcd.com/927/
I don't like the idea of random data in test cases as testing should be asserting an expected result. At work we run tests on an empty database which is cleared after before each test case runs. We then would write unit tests which test for a certain known outcome such as: * Given create user, when email is valid, then user is successfully created. * Given create user, when email is invalid, then invalid email exception is thrown. * Given create user, when email already exists, then email already exists exception is thrown. * and so on... 
&gt;This is not the common case, nor is it in any way desirable. Your payloads should basically be write-once and read-never. Really? You don't think any other devs in your team should be able to read your test data? Glad I don't work in your team. &gt;Because the payloads are the wrong place to explain your testing methodologies. You should be doing that in your tests. Some tests are visual tests. Stub data to allow people to see what the site looks like in various scenarios. &gt;You certainly wouldn't be trying to explain yourself with comments embedded inside a PNG or JPEG payload, would you? I don't tend to have PNGs with nested data that has meaning, or write code that parses the internals of those PNGs. But tbh, I think this conversation has run its course. You've clearly decided, without bothering to really understand someone else's use case, that this use case is wrong. And I can't be bothered to debate with people like that. 
It makes maintenance easier because every line has the same format so you can rearrange and remove lines with saner diffs and fewer mistakes. I used to wonder why but have come around to them and wouldn‚Äôt go back.
Neat but why not just use TOML or YAML or any number of other config formats if you‚Äôre going to introduce a new implementation? It‚Äôs clinging to the JSON part without reason. JSON is for machines, like XML. That‚Äôs ok.
And JSON5 is not JSON either. 
How are you supposed to tell the difference between NaN and -NaN with null? Besides what if the value is actually just null?
Infinity can be very useful for denoting infinite upper and lower bounds, instead of having to use exceptionally large numbers.
Love it , I‚Äôm learning js and this is helpful 
You're right.. and, I'll be sticking with JSON. I've worked at so many places where someone initially chose YAML and then they went back to JSON because it's more standard. Eventually as systems scale, config files move to a DB or other systems that don't work with YAML. 
thank you, it¬¥s all about sharing knowledge!:)
I tried it in this very high resolution and there's this peculiar thing going on on the right side of the canvas: https://i.imgur.com/ezZyg8x.png Doesn't seem intentional.
learn the basics of HTTP, HTML and CSS. instead of learning the DOM's API, start with jQuery and learn how JS interacts with the DOM. learn how to use Chrome's or Firefox's devtools. Learn how to set breakpoints in those devtools and step through code as it's executing. once you have a hang of it, start looking into JS frameworks, nodejs and other server-side stuff like SQL and databases.
I find that I only learn by doing. Start with some interactive coding tutorials, like Codecademy.
Thanks. Ive realized that im not really retaining any of this by just watching videos.
&gt; Unquoted keys serve no real purpose, but make the syntax more ambiguous and harder to parse. JavaScript and many non-JavaScript languages allow identifier object keys. It doesn't add any notable amount of parsing complexity and it is a convenience for the programmer. Besides if we start shooting things down because the stuff going on behind the scenes is complicated in an effort to make the programmer's job easier then we'd all go back to writing C. &gt; Same for single quoting of keys and strings. I'll give you this one. It doesn't raise parsing complexity but having both single and double quoted strings in dynamic language has always been a sticking point for me. &gt; Adding Infinity, -Infinity, NaN, and -NaN to numbers poses problems for non-JavaScript languages that can not represent those with their number type. IEEE 754 floating point is not exclusive to JavaScript, nor does JS have arbitrary precision floats and will still be restricted to single or double precision. Not only do most languages support IEEE 754, it's supported in hardware too. Chances are high you have ¬±INF and ¬±NaN for free regardless of hardware, OS, or language combination.
I don't like the quoteless keys. Too much trouble for a data spec. I don't really care about NaN and Infinity. I just want comments.. fucking Crockford...
[Github](https://github.com/maierfelix/wasm-particles)
What's the advantage of being a JS subset if we aren't supposed to actually eval it? Why not just use YAML?
Oop and inheritance was supported long before es6. Classes are just syntactic sugar added in es6, but prototypal inheritance is still used in the background.
I make a lot of utility apps for board games I like, and I use a lot of hand-written JSON to populate data. The lack of comments, having to quote keys, and omission of trailing commas are all common frustrations that aggravate me on a regular basis.
[Github](https://github.com/maierfelix/wasm-particles)
Personally I love TOML since I also liked ini files. It is so simple. 
&gt; Start with jQuery and learn how JS interacts with the DOM Those are two opposing things.
Another *curated* *awesome* *special* link list? Awesome! My 7 y/o retarded sister can put links together as well
Mate honestly, just script it. "I use a lot of hand-written JSON" is the problem there, not JSON.
Haha, you're kind of an ass.
Sure, you're just looking to straight char replacement with an undefined length string (not that length really matters) Your pseudocode is exactly how you would do it too Take string split Encode char Recombine Of course lots of room for improvement, but at its core that's it
Thanks, this is is super useful! 
Noob here . I was wondering if you could explain me like 5 ,what's the purpose of webpack ? I couldn't understand it 
For random length, instead of making them all different variables, instead use an array. Look into String.prototype.split and iteration over arrays (you'd either use a for/(in/of) loop or a .map method). Example code: var text = /* however you get the string */ let textArray = text.split("") let newTextArray = textArray.map( function(character) { /* If logic here. `return` any values. */ }) let newText = newTextArray.join("")
Wanna watch me code an app
Just polilty asking, why are you using var instead of let or const ? These are also part of ES6 . Thanks 
What about dates and sets?
You'd use arrays for this. Overly simplified example: &gt; [...'foobar'].map(c =&gt; String.fromCharCode(c.charCodeAt(0) + 1)).join('') "gppcbs"
Pretty comprehensive list, thanks for sharing
Absolutely this. I really don't get why things like babel and flow use json instead of exports for their configuration :/
Training commas shouldn't be in the specification, but the specification should allow empty items to be ignored. This covers trailing list commas, empty list items (e.g., [1,,,,2,3]), and empty object elements.
Ok, so I am able to break up the array but how do I put each letter into its own variable. I am just testing this out as I go but this is what I have so far, 'var string = "123456789" document.write(string+"&lt;br&gt;"); test = string.split(""); document.write(test); document.write(test.length + "&lt;br&gt;"); l=test.length; document.write(l); var i = 0; while (i&lt;l) { document.write("The number is " +i); document.write("&lt;br&gt;"); i++; }'
If you routinely have to caveman JSON, I suggest using an online tool like jsonlint to validate it. 
WebPack is a module bundler. It's primary purpose is to make Dev life less shitty. It allows developers to split their projects into multiple files based on whatever organizational structure makes sense for their project, instead of having one giant JavaScript file. When you're done with your project, or want to check your progress, or whatever, you run it through webpack, via node and NPM/yarn, and it poops out a singular javascript file which is a combined version of all the files in your project. Typically, it will also do other things like run your code through babel, which is a transpiler that changes code from one state to another, allowing devs to do things like use ES6 standards in their code and transform them into ES5, or even ES3 compatible code without having to actually write in those standards, which are shitty. It can be configured to lint your code (check for style errors, among other things) and fail if your code is shitty. It can be configured to minify and obfuscate your code, which means it changes things like 'var tacos' to 'var t' which results in smaller file sizes and thus faster download times for your clients. Note that webpack is not the first tool in this space - it started with browserify, and then grunt came along, followed by gulp, and then webpack. all of those other tools are still in use, but webpack became very popular recently, in part because it's the de facto standard for react projects (although you can use the others with react too). Browserify is pretty much dead though, and the creators have endorsed webpack as a replacement. 
You‚Äôre gettjng there! Now that you have `i`, you can use it to get the character at that position in `test`: `test[i]`. 
Stop watching videos and start making things! The best way to learn is to put it into practice. Think of a simple idea for a web app and then start building it. You'll learn a lot a long the way and you'll remember a lot more too :) 
I always recommend freeCodeCamp, which is the resource that‚Äôs allowed me to take a deep dive into coding. I‚Äôve had an interest in web development for about two years now, but FCC is the first one to make me feel like I‚Äôm really learning. I also supplement it with TeamTreehouse, which is a paid resource full of video courses. I know you said you‚Äôve tried video courses and didn‚Äôt get much out of them (I‚Äôve felt the same way before), but these are different IMO. They‚Äôve got a 7 day free trial if you‚Äôre interested. Best of luck with your coding!
Yeah, that‚Äôs super important. Follow along with the videos, type everything out yourself (don‚Äôt copy-paste), make mistakes, experiment, change things. 
Webpack is like a factory, in the sense that you enter some raw materials and it returns a product ready to use. For example let's say you are building a site and you want to use new [features](https://babeljs.io/learn-es2015/) of JavaScript and [SASS](http://sass-lang.com/) for your styling. Some browsers are already capable of understanding ES6 JavaScript features, but not all of them, and no browser (that I know of) can directly use SASS. So the solution is to compile your files into new ones, ES6 is going to be transformed into ES5 JS (which almost all browser are capable of understanding) and the SASS is going to be transformed to CSS. The purpose of webpack is precisely that, it acts like a factory with a control room where you can configure what types of files you want to transform, where do they live and where do you want them "outputted". PS: I wrote this a few minutes ago, but my internet stopped working, I'll just reply to you with my point of view, I also liked your explanation haha.
I'll add a little tidbit that may help you out. search "Junior" level web / software jobs around your area. Look at what they are looking for. Then focus on that... Another thing is get good at testing and figuring out bugs. Majority of what you'll do at first job is fixing bugs and assisting other engineers - Obviously this depends on company. 1. Go through Michael Hartl's ROR tutorial - This is not necessarily to learn rails but to learn general web concepts (MVC, rest api, ajax, cookies, sessions and authentication) 2. Beef up on your JS via http://eloquentjavascript.net/ 3. Get really good at responsive UI development 4. Volunteer and/or freelance to create UI 5. Keep learning and repeat I suggest responsive UI development is because many software engineers do not like this part. Even though they are really strong software-wise but suck when it comes to design. 
I know how to simulate quantum tunnelling with my dodgy game loop
I think I have it now, while i&gt; length of user input if userinput[i] == e then finaloutput[i]=q This is where I have a If statement for each letter in alphabet. end if end while write finaloutput
I‚Äôd say we tag teamed it pretty well
&gt; You can't just decide to use MIME types for versioning. It's not a *version* of JSON, it's a different format that happens to be a superset of JSON. In that regard, it's just like YAML, which also has its own media type. The information about whether a file is JSON, YAML or, in this case, JSON5 does not belong in the file. It's metadata, not data.
Ah, but NaN? Or -NaN, which isn't even a "feature" in the JS program you would be presumably parsing JSON5 into? I would be incredibly surprised if there's any situation where NaN is the best value to use in a human-readable configuration file.
Does JavaScript even define a distinct -NaN value? I can't find anything documented, and `console.log(-NaN)` prints `NaN`.
A lot of apps will think it's invalid.
Well, it works in browsers and Node, so that‚Äôs good enough for me. Know anything that would reject it as a concrete example?
A vanilla version of this would be nice to see.
I don't mean platforms. Let's say you have an app which takes a JSON file as configuration. App assumes that all the keys are configuration values. It will take that "__comment" key and validate it and complain that it's unknown config value and shuts down.
You can actually use a standard string method called "replace" to do this. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace For a simple swap from e to q it will look like: "ea".replace("e", "q") But you can also add more advanced functions or switch statements. Im not sure it this is faster than array operations, but it's a standard function so it's probably pretty quick
It's been a minute so I don't know if it's still around, but The Odin Project at theodinproject.com really helped me start to get to where I felt mildly competent at programming. If you're looking for a career, it teaches Ruby, which I think is suboptimal, but the design of the program is fantastic, it's free, and it gets you hands on with HTML, CSS, Javascript, and jQuery. It kind of amalgamates various resources like Codecademy into one linear "zero to junior professional" track. I highly recommend it. 
Classes in js are just a complete lie and I hate them (I don't but they don't bring much to the table currently). I actually didn't mind working with prototypes. Precious few people understood prototypes/inheritance before es6 but I guess TC39 wanted to get that number down to zero.
So it seems I am stuck at the last part of the code and I am at a total loss as to what to do. &amp;nbsp; var i = 0; var temp; var final; &amp;nbsp; while (i&lt;l) { temp = test[i]; if ( temp = "a" ) { final[i] = "q"; } } &amp;nbsp; document.write(final); &amp;nbsp; So everything is working up until I am making the final string. It seems that final[i] is wrong but I am not sure what to do
Depends how you parse the statement, but yeah. I think for a beginner it can be a nice bridge from code to things like changing classes and whatnot, which arguably is interacting with the DOM and it's made very clear by the jQuery syntax. If you're familiar with jQuery and then look into how to replace it with vanilla js you'll have a good sense of what it is you're trying to do. 
Isn't that just agreeing with everything I've said, and contradicting what you originally said? By all means, create a new data format. Good luck with that.
&gt;kind of
When I want humans to write configuration files, I give them YAML. 
PDF were designed to be have full-fidelity in typesetting and layout when printed by different viewers on different platforms. This should hold true if you only use basic features of PDF. More advanced features like 3D, form-filling, signature capture, encryption etc are probably not implemented consistently across viewers. 
The thing about JavaScript is, you never know.
Yeah let‚Äôs conflate more things with the actual definition of null and move towards making it entirely meaningless.
How familiar are you with general programming concepts? If you don't know any programming, leave Javascript for now and learn programming first: * [what is an algorithm](https://www.slideshare.net/hermiraguilar/algorithm-and-pseudo-codes) * [statements](https://www.teamten.com/lawrence/programming/intro/intro2.html) * [what is a variable?](https://www.teamten.com/lawrence/programming/intro/intro4.html) * [conditional structures](https://www.teamten.com/lawrence/programming/intro/intro6.html) * [loops](https://www.teamten.com/lawrence/programming/intro/intro8.html) * [what is a function?](https://www.teamten.com/lawrence/programming/intro/intro10.html) * [learn some basic algorithms](http://ressources.unisciel.fr/algoprog/s00aaroot/aa00module1/res/%5BCormen-AL2011%5DIntroduction_To_Algorithms-A3.pdf) and try to solve [some problems on your own](https://adriann.github.io/programming_problems.html). * Then learn the [basics of OOP](http://ee402.eeng.dcu.ie/introduction/chapter-1---introduction-to-object-oriented-programming) --- After you get that out of the way, you can get into web stuff. Learn how a webpage is served, the basics of HTTP, how Javascript is executed, how it interacts with the DOM. Then find some exercises and tutorials for building simple apps (forms, blogs, news sites, etc.)
I used the term too loosely, since it has multiple meanings. Increment vs variant, let's say.
Couple general comments: * The blog doesn't really follow a logical/cohesive approach (feels all over the place in terms of concepts/explanation). * This is supposed to be an introduction blog for newcomers and it seems like many key important concepts are glossed over. * I'm missing where an actual understanding of frameworks under the hood is needed here for review. * Add some visuals, way too much text and reading for a beginner to even try to understand. Some specific comments: &gt;Many of them follow the Model‚Äìview‚Äìcontroller / MVC paradigm (while others may only do M, V, or C). Most modern frameworks actually just supply the view (React, Vue, Inferno, Preact, etc). Only some frameworks these days have opinions built in on these other aspects (Angular, Ember, etc). &gt;Why Use a Framework? There are many reasons to use a framework. There are a number of problems with ‚Äústate‚Äù that occur in any given web-app. We‚Äôre going to discuss some of the essential concepts that frameworks address in this post. This just seems confusing; Why Use a Framework? =&gt; Benefits include common coding practices and patterns (which is useful for teams) and features like virtual DOM, type-checking, etc. Just some of my constructive criticisms; in general I wouldn't really think this blog as is, is very accurate or helpful for your intended audience. Good luck!
I think you're thinking of negative vs positive infinity - no such thing as negative NaN.
In that situation it's recommended you use the string "NaN".
Okay so first thing, I would define _final_ as an array, so use _var final = [];_ Secondly, you need to increment _i_ with every iteration, so put _i++_ after your if-loop (but still inside the the while-block) Lastly, final is an array, so turn it into a string again before outputting it by using _final.join("");_ Now it should work, eventhough there definitely more efficient and elegant works of doing this, as other commenters have pointed out. :)
Clever wordplay, obtuse metaphor. 7/10, we appreciate your contribution.
If you dont know about lisk, check them out Www.lisk.io
But you know, just _in case_...
Kind of disappointing it's just a curated list based on github stars... popularity doesn't necessarily mean the source code is a great example/model to follow and pull from. Also kind of strange that all data is painted immediately on page load (doesn't seem to be any kind of fetching/refresh of data going on as a new panel is brought up, etc).
I could fix it in about a second or two. but erm. whats in it for me?
hey thanks for responding. I appreciate your input, especially on things not specifically related to my question. the previous commenter had edited the JSFiddle so I'm not exactly sure where it stands now, but I took a copy of the script when they has it working so I think I know what I need to correct. 
So you're a QA tester. Get a tool which allows you to do exactly what you want and export proper JSON. Problem solved, and you're now compliant with 100% of the industry use of JSON. [In fact, here is a tool I made in 10 seconds](https://repl.it/Nmt7)
I'll also reply to you here, put your data into a javascript and JSON.stringify it. Simple, done. Hell you can even program in it so you don't have to generate 50 iterations of data!
Like Require.js?
&gt;I don't tend to have PNGs with nested data that has meaning, or write code that parses the internals of those PNGs. You are too dense to see the analogy he's trying to make. The same reason you dismiss the usage of comments in PNGs is the same reason why he's saying you shouldn't be putting comments in JSON.
It's based on https://github.com/sorrycc/awesome-javascript. No need for complex design when strange design works just fine!
Because people don't understand JSON isn't a language for people. It's an object notation for machine communication not what you'd hand type an email with.
I know there is easier but I am enjoying trying to figure this out on my own. So I am getting a result, that is wrong and I'm not sure how &amp;nbsp; var string = "abc"; strsplit = string.split(""); l = strsplit.length; var i = 0; var final - []; &amp;nbsp; while (i&lt;l) { if ( strsplit[i] = "a" ) { final[i]="q"; } if ( strsplit[i] = "b" ) { final[i]="w"; } if ( strsplit[i] = "c" ) { final[i]="e"; } i++; } document.write("And the end result " + final); &amp;nbsp; The result is &lt; And the end result e,e,e So I'm not sure why the result would just be e
Thank god the JSON format isn't mandated by Reddit.
Usually it accepts both but looks for one before the other.
The only use for such "better" JSONs is easier human editing. And we already have many solutions for that ‚Äî eg. YAML, TOML, JavaScript files and probably much more. 
Well, selectors are doable in vanilla JS, so you don't even need a library to help you do that. 
if you want it you gotta WANT it... you cant half ass it. 
Strict typing? Do you mean strict syntax? 
Apparently in JSON5 there is.
https://github.com/johnsylvain/pagine This is a project I‚Äôve been working on that generates websites from markdown files (inspired by jekyll) without running a server or the need to compile it into static files. Everything just happens in the browser. There are limitations such as SEO, but this was just a project for me to hack on. I'm just curious to hear what y'all think about it. 
Basically Fun story, I couldn't get requirejs to work consistently, so I've wrote this up. It is very lightweight and tries it's best to be fast :)
Yep, that's because you use _if (strsplit[i] = "a") {}_. A single _=_ is used to assign a value, like you do in the following lines. To check for a value, use _==_ or _===_. So change your if statements to if(strsplit[i] === "a") { strsplit[i] = "q" } and so on and it should run.
&gt; console.log('hello world!'); 
I'm pretty sure the comment is correct. From the [wikipedia article on YAML](https://en.wikipedia.org/wiki/YAML): &gt; YAML 1.2 is a superset of JSON, another minimalist data serialization format where braces and brackets are used instead of indentation.[2] It's cheating a bit because I'm not sure if that's true for every whitespace variant of JSON but at least `JSON.stringify(data)` and `JSON.stringify(data, null, 2)` are both valid YAML.
That's technically correct (the best kind) but in practice rarely helpful. If your automated tool or API wants or produces JSON, it will not look good in a file where you'd expect YAML. And none of the JSON tools or APIs will accept a typical YAML file. Definitely a fun factoid that can be helpful from time to time but not *that* valuable in general.
I got it to work using this, &amp;nbsp; if ( strsplit[i] == "a" ) { final=final+"q"; } &amp;nbsp; and it works perfectly! :)
Having comments in `package.json` *sounds* super useful and great to have. Until you try to have things like `npm install --save` and a bunch of other automated tools that want to maintain the file and suddenly have to worry about keeping ASTs with comment nodes around. No comments means you give up a little bit of human convenience but get a whole lot of automation that's easy to implement.
More than that. Even if you do care. As an engineer you have to make tradeoffs. If the numbers come out favorable for accepting complexity for the sake of ease. You do it
It's unfortunate but a fair bit of the artistry and creativity dies in an industry once it matures. I think JS is begining to get there. Many of the big problems have been solved. It's playing with legos rather that building building blocks much of the time these days. 
Exactly. You can watch someone ride a bike all day long and know exactly what you need to do but you won't be able to ride one until you practice.
Whatever you know best unless you have a compeing reason to do something else
No way, it's just running `0 - NaN`, which is still `NaN`.
JSON == YAML but YAML !== JSON, so no they are not the same and the difference is *important*.
Not for anything resembling type safety. No
https://www.typescriptlang.org/ You tell me
It's growing in the market i work in
State management library (disclaim I wrote one) based on single responsibility principle; is only care about how UI look like: render(view, state) =&gt; UI. It seems to me that you try to use your domain/business objects as state. I understand that when start a simple application; it is so irritated to copy between business model and state for every simple tasks. But when the application grow big, it is comfortable to have UI/state and business logic separate, you could focus one thing without fear break another. So it is important that how you feel comfortable to code your application. If you feel it is complicate for state management; it is a sign that your application don't need it. 
Hell yeah moire lines! 
I admit to using JSON for everything and I'm curious under what circumstances I'd be better off using a different format.
I wish I had the article I read when I was first learning programming. Basically, the biggest problem is when starting out you don't even know what to ask. Begin with the end in mind. What do you want to do? Front end developer, back end developer, web designer, app developer, video game developer? All of these require a different set of skills. The good news is the logic is the same, and once you learn a language, it is easy to pick up others. 
Webpack is js anyway, right?
-embarrssed- I didn't open it. =/ I was hoping you'd mention it was something like the body being interleaved with the header tags or something.
just being a good guy really.
Interesting. That usually crops up on strange usages of `define`, usually coming from a modules that don't use the umd boilerplate or do some weird stuff to pull out `define` and call it. It seems you likely have a dependency somewhere that is old and causing this issue.... a quick search reveals there's a few of these in the wild, but most have been fixed, this one specifically: https://github.com/kriszyp/json-schema/issues/59 (a workaround is posted in this issue, if you are hitting this and performing an upgrade to dependencies is not an option) Where it is is the real question and you're going to need to dig into your code bundle to figure out what it is. Either way, `dataTable` isn't making it's way on to jQuery -- you might try reading the README if you haven't already: https://www.npmjs.com/package/datatables.net-dt var $ = require( 'jquery' ); require( 'datatables.net-dt' )( window, $ ); // $ now has .dataTable 
Is jQuery included in your bundle?
Started freecodecamp and im liking it alot
&gt; also, fwiw - reworking an existing project to use webpack is often a thankless task - works best if you use a bundler from the get-go as opposed to refactor an existing legacy site to use it. I'm starting to realise this more and more :) Is there an alternate path you'd advise in taking 20 Javascript and CSS files sourced separately via &lt;script&gt;and &lt;link&gt; tags, and having just 1-2 files downloaded from the server? I guess could just 'cat *.js &gt; bundle.js; cat *.css &gt; bundle.css', but I was hoping to at least try and incorporate some modern tools (as much for self-learning as for speeding things up). 
Hi again /u/JesusVKilmer. I have tried the method you suggested. It sets the Bookmark panel to visible in the open and active PDF document. However once you close the document it resets back to its original state (i.e Bookmark panel : hidden). Btw the [link](https://acrobatusers.com/forum/javascript/change-documents-properties-intial-view-js/) you have given describes the exact issue I am facing and apparently it can't be acheived by using javascript. But Thanks a lot for all the help :) I am sure I can use your ideas elsewhere.
Honestly, whatever works - I'd maybe throw uglifyjs in there so `cat *.js | uglifyjs &gt; bundle.js` to ensure things get minified. There's probably a CLI css minifier out there too but it's been a while since I've had need for one - a lot of the preprocessors come with a minify option. Maybe you could start out with grunt or gulp? Those are less of a paradigm shift and can get you into using build tools to automate scripting out things like concatenation &amp; minification, and will potentially let you get into other tooling like less or scss. If you want to learn webpack - I'd definitely recommend a fresh project. Mind you, figuring out how to repurpose an existing site to use webpack would be a great learning experience - if not exceedingly frustrating.... it'll give you lots to google that's for sure.
Under the reduce example you could include the output of ‚Äòsum‚Äô for as you did with the other array method examples. Otherwise great job, this is awesome!
yup, look at cdata directives in xml. total clusterfuck. if you want comments, pipe thru json5 and be done with it.
or use json5 and stop bitching
webpack sucks
I mean, I don't disagree entirely but this doesn't help me lol.
It's like the devs changing the mechanics of a video game because they don't like what people do when playing. Back in the q3test days, id software changed the game so that there was a minimum 1/4 sec delay between jumps. You can't put padding on a knife to keep people from stabbing each other. Just build the tool and let it go. . . you'll be SURPRISED at what people will do will flexibility. Some of the coolest shit in dev has come from the lack of chains.
&gt; Classes in js are just a complete lie and I hate them To be fair, JavaScript's arrays, functions, objects, and even local variables are just as much of a lie as its classes. ;-) https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#javascriptc-rosetta-stone
Only if you threw a [stone at a robin.](https://www.youtube.com/watch?v=LklFP1IG9KY)
Video linked by /u/monsto: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Rockin' Robin-Bobby Day-original song-1957](https://youtube.com/watch?v=LklFP1IG9KY)|AK47bandit|2008-03-20|0:02:41|21,352+ (96%)|3,608,905 $quote original song, oldie. --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/monsto ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
All the little snippy arguments and pontificating righteousness reminds me of the "mechanics" thread in /r/AskReddit a few days ago. And nobody has changed anything.
Pretty funny that React isn't in the list, like, at all.
Was super impressed by the demo, excellent work! I checked out the code as well and the compiler is awesome! https://github.com/maierfelix/wasm-particles/blob/master/rollup/compile.wasm.js#L15-L18 Interesting how it basically converts the WASM into an ES module. You could theoretically load this dynamically in the upcoming version of Chrome using `import()`.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [maierfelix/wasm-particles/.../**compile.wasm.js#L15-L18** (master ‚Üí 45769eb)](https://github.com/maierfelix/wasm-particles/blob/45769ebe192fabfe5c0db09cb2d4165cf1f9680a/rollup/compile.wasm.js#L15-L18) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I thought JSON was already pretty readable....
Also not sure why ? In boxes are showing up in my post. 
Great effort and you're getting the gist of a lot of concepts, but there are a few issues. &gt; Node.js is an open source server framework. Node.js is a runtime, not a framework. &gt; Classes JS doesn't have actual classes. It's just sugar for prototypal inheritance. &gt; Helper Methods These are Array prototype methods. The term "helper methods" is a bit confusing. These also don't really belong in a post titled *Learning Javascript in 2017*. These were added back in 2005 and have been in standard use pretty much every since via polyfill. &gt; The map helper method in es6 allows us to create arrays by calling a function on each element of an initial array. This doesn't actually explain what map does. Try instead: *The map method creates a new array with the results of calling a provided function on every element in the calling array.* (From MDN) &gt; The filter helper method in es6 creates new arrays with all the same elements of an initial array depending on a test that we give it. Again, confusing language. Try instead: *The filter method creates a new array with all elements that pass the test implemented by the provided function.* Your sources include w3schools, which is notorious for providing bad info. Please remove. Also, for a post like this I'd stray away from citing medium articles, and lean more toward resources like MDN or devdocs.io I get that you're learning, but a good deal of the information is either incorrect, or lacks proper context. I'd suggest fact checking a bit before posting this kind of thing. I'd hate to see newer devs picking up bad info. 
For articles I tend to have a daily squizz at Webdesigner News, dev.to, Hackernoon, Medium and save whatever looks good in Pocket to read when I get a chance.
Classes are syntactic sugar..blah blah blah di blah.. can people get over prototypes already, classes are invented way long back, these prototypes are inspired from classes and javascript introduced classes again, its all a hogwash, just learn something and get job done, nobody cares of people opinions
the fact that classes cannot have default fields except those initialized in the constructor makes them worse than prototypes. https://github.com/tc39/proposal-class-fields is already in Stage 3, but that private field syntax makes me shudder.
Well, no. I‚Äôm a dev but thanks for assuming that you understand the problem domain before jumping in with a solution. And yes I know there‚Äôs ways round the restrictions. But creating a js file, which you‚Äôve got to execute to generate the file actually want is a clunky workaround for a problem that could be solved by having the file just support the things I want in the first place. 
No. The analogy is just not very good. Json files contain structured data that my code cares about Pngs don‚Äôt. And if no-one was meant to be caring about seeing the internal structure and content of this data, then there are better ways to be passing the data around than a text-based format like json. 
Crappy code
Nope. You‚Äôre still just misunderstanding the problem and trying to answer a different one. It‚Äôs a fairly common problem though, so don‚Äôt feel too bad about it. 
I think he is asking if you meant require.js instead of commonjs 
Nothing will stick until you start doing. Start small. Make a "Hello World" page then build up from there. Make a page that just shows you the current time. Now make a page that shows the current time on a wall clock using hour, minute, and second hands. Now make a page that shows you the current time for 20+ different world cities. It doesn't have to be unique or earth shattering, you need to start with an end goal in mind. For more projects, try recreating sites using static/mock data. Recreate an Instagram feed or Facebook page using static/mock data.
Cool, could you maybe give a slight overview of what all those tools can do? :)
There does seem to be one in the [README, for tools](https://github.com/gikmx/tools/blob/master/README.md) and [README, for npm scripts](https://github.com/gikmx/npm/blob/master/README.md)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gikmx/npm/.../**README.md** (master ‚Üí 61fbd9a)](https://github.com/gikmx/npm/blob/61fbd9a23069c35461a4ea11bdf8e986605fb15d/README.md) * [gikmx/tools/.../**README.md** (master ‚Üí 124ed6b)](https://github.com/gikmx/tools/blob/124ed6b65c455912b5ea1209ef704c58b4142aa3/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpf0xmw.)^.
&gt; reminds me of the "mechanics" thread in /r/AskReddit a few days ago Link?
Can you not make this _a_ thing? This is just as much of a plague to JSON as 'standard style' is to the javascript formats. Be a bit stoic and pragmatic of how you write JSON - accept that it's a damn standard and not a playground or something that you should be writing manually by the megabytes. If you still want to go with your silly standards, write your jsons as .js files and prepend with JSON.stringify(...) and you can write all your object notation.
You should consider yaml - it is much more friendly to write by hand than json, plus it has comments, anchors etc. plus as a bonus it is a superset of json so migrating should be easy
Try clicking the link and reading the extensive documentation they provide
These look really useful! Observables for clients are great and . I couldn't tell, but have you provided each of them as a npm package? The fs and spawn observables would each be fairly popular probably as individual components
As of today this is a hard question to answer. JavaScript‚Äôs popularity has coincided with a lot of methods to teach each, targeted at eventual development environment. If it‚Äôs web development you want to use JavaScript for I suggest you follow the guides of one of the popular frameworks (say [Ember.js](https://guides.emberjs.com)) and fill holes in your JavaScript knowledge along the way. 
That said, here‚Äôs a couple of resources you could use. Problem is that they teach the internals and quirks of the language, making them more suitable to latter stage JavaScript developers trying to satisfy their curiosity. JavaScript Allong√© Effective JavaScript Eloquent JavaScript
Duck Typing is not about types or interfaces, but behaviours. Is commonly used in dynamic typed langs. If you created a function expecting an object parameter which haves a "sleep()" method, it can be a "Person" or a "Laptop" instance (they don't share any inheritance/interface, but this single method), your function still working, because it doesn't care about types, just care about that single behaviour.
Damn that's ugly
Thanks :D! Tools are separated by topic, [these are all the tools available](https://github.com/search?q=tools+user%3Agikmx), and [here are all the corresponding npm packages](https://www.npmjs.com/org/gik). `tools-streamer` is the one with all the FS-specific observable operators. I think splitting it into each operator wouldn't be much hassle, but I don't know, maintenance is way easier if they're bundled. After all, the operators are fairly simple. But I leave it up to you guys, if you think it's worth it, I can take some time this week to split them up.
Having massive amounts of data and comments in test data, that need read and understood is a clunky workaround. Sure, everyone else here could be wrong and your problem domain is so unique and special that it requires this. But in all likelihood, the code smell is a code smell and you just need to engineer the solution properly. 
Basically there are 3 categories: - *presets*: `eslint-config-*` and `webpack-config-*` - *tools*: These are bundled into [one big package](http://github.com/gikmx/tools) (we don't usually use it) or splitted [by type](https://github.com/search?q=tools+user%3Agikmx) so you can use them individually according to your needs. - *npm*: This is like an automator for the usual tasks on package.json, we found ourselves writing over and over again these scripts and decided to mimic the script style that `create-react-app`uses, so we can maintain them in a single place. We're planning to split this up too, but right now is a single repo. We tried not to make them specific to our needs so we could eventually publish them, but some scripts are kind of specific to our needs, the idea is to make them more general, but first we wanted to know if the repo would gain traction. 
Did you end up fixing it or do you still need help? 
I didn't see this until now. I just threw up in my mouth, a little bit.
I've made a Bootstrap4 version, please check it out here - https://github.com/keaukraine/bootstrap4-fs-modal
Bootstrap4 is a separate project (serves the same purpose but is implemented purely in CSS, w/o JS) - https://github.com/keaukraine/bootstrap4-fs-modal
Yes. I‚Äôm sure the three random people in here who have no knowledge of the particular project, and made no attempt to understand it (something I‚Äôm sure you‚Äôll agree is a fine trait of talented software engineers...) have a better idea on how to solve the specific challenge than the separate teams across my organisation who have independently tackled similar challenges in very similar ways. . A good example of the clear understanding of the problem domain is the phrase ‚Äúhuge amounts‚Äú. I‚Äôm not aware that I made any reference to huge amounts of data. What we‚Äôve actually got Us a few very specific edge cases where some of the features in this proposal would be quite handy. But clearly, as one example, rather than simply taking the json responses from our backend services, saving them straight out as json files, and just editing them to add a few more example scenarios to show clients what the site might look like before all of the services area ready (a job that usually takes a few mins, but that would be easier for other teams to understand what they are showing if I could sometimes add a comment or two and break text over multiple lines), I should clearly rip all of that up, and create js files to recreate the json stub files I‚Äôve already got because 3 people on the internet thing that‚Äôs smart. None of the problems I have with our current way of working are anywhere near big enough to add more complexity in to the process. And the proposals wouldn‚Äôt revolutionise my day to day work. But they would sometimes help a little but. And it‚Äôs hardly lime we‚Äôre alone in finding it sometimes handy to have human-editable json. There‚Äôs a whole host of 3rd party applications and libraries that choose to use json for config files for example. Clearly the 3 people on this thread all know better than every single one of them about the correct solution to their problem. 
Not really - it's pretty logical. When you want to remove a line, you just remove that line. Currently, you have to remove that line AND worry about whether it's the last in a list, and if it is then edit the line above it too. That's illogical. 
Or how about Hocon github.com/lightbend/config/blob/master/HOCON.md
The sync fs calls inside a Promise executor made me a little bit sad.
This reminds me of the [Brainfuck visualizer](https://github.com/fatiherikli/brainfuck-visualizer)
Do you build a library for script-tag/umd consumption? Because normally you don't bundle, you run babel over it and that's that. Or if it has to be a bundle i'd always use Rollup on the publishing side. Using rollup on the receiving/front-end side on the other hand is crazy. It's only asking for trouble and there are a thousand things that can and will go wrong. I've fought against it days and weeks. Webpack, otherwise it's on the user. As for the main entry, i use this: "main": "dist/index.js", "jsnext:main": "index.js", "module": "index.js",
Obsolete. Chome 61 supports imports.
Guess at TLDR: * Angular is good at enterprise. * React is popular and facebook made it so you should use it too * Everybody Talks about Vue so it must be good but we haven't tried it 
Yeah, that's probably the most logical explanation for why don't have these "features" in JSON: that these smart folks just don't understand your (unfortunately) very common use case. It's just a matter of you explaining it accurately enough, and then they'll finally see the light after all these years.
Routes doesn't work. I don't know if i'm using it well. https://pastebin.com/M2T8m49U
Because why use CSS directly if you can wrap it with a js library?
You have it set up correctly, routes are currently setup as hash routes (`#/` and `#/nyan`). I'll make that more clear in the documentation.
The beautiful thing about JSON is, it can be ingested as well as outputted. So you need only load in your existing saved JSON, map it to something new and save it again. Something that would take minutes to script...[here's a handy table on how long you might want to spend on this](https://xkcd.com/1205/). Now obviously you aren't going to be happy with since you've already decided that scripting is too complex. But I've done it, it's simple, highly extensible and an all round better solution to hand-writing JSON. The human-editable version of JSON is JavaScript (or any other of the multitude of languages that support JSON). The reason I feel pretty confident in saying you're thinking about this the wrong way, is that you are proposing changing your data exchange format, from JSON (something that is readily supported everywhere), to this (something that is supported nowhere). For the purposes of making testing and demos a little easier. Which is such a bonkers proposition that the answer can only be, you need to find a different solution. The complexities of writing a script pale into insignificance when compared to introducing this to your project. 
Please add some filters ! Well maybe just a checkbox that goes, filter out jquery libraries. 
Thanks.. not a lot of new stuff here.... 
Nice, thanks !
I'm getting 8 FPS :-/
Next step: look into using MongoDB instead of reading and writing JSON files directly.
But this is meant to function as a desktop application if I was going to use the data for a rest api I would have used Mongo. 
For vanilla JS I'd advise a series of books called 'You Don't Know JS' by Kyle Simpson. They really do peel away the hood and talk about the mechanics of the language. https://github.com/getify/You-Dont-Know-JS I've heard plenty of things about how good Eloquent Javascript is as well, though I haven't read the book myself.
&gt; a slight overview 
I don't understand the argument for comments in JSON. How often are you actually reading JSON files? What is the use-case where you have massive JSON files that actually _need_ comments?
Build your own project with React and Redux if you want to learn them.
Would this work with no server at all, as in loading from the filesystem on a local intranet?
Your article is nice but it could use a better formatting to help differenciate text from code.
I‚Äôm not proposing anything. I‚Äôm saying that I would find some of the features he‚Äôs proposing quite useful. And for some reason, some people are desperate to convince me that I wouldn‚Äôt find them useful and that instead I‚Äôve misunderstood my problem and that they already understand it far better. I‚Äôve done the scripting thing as well, many many times when it‚Äôs appropriate. It might shock you to learn though that it‚Äôs not always appropriate or as simple as just editing a json file. 
I love webpack, but I did find have a hard time using it to build npm packages. I ended up switching to rollup for that specific purpose, and my webpack project can consume the builds created by rollup without issue.
I love Vue but I wouldn't say it's any more coupled to a back end than React 
Take it up with github.com/sorrycc/awesome-javascript
That's a good idea
Now I have to find a reason to use this at work. Great job If you're the author.
Great article, I definitely use some of these daily (esp. defaulting with '||'). Does any one find that, when working on teams some of these can end up being more confusing that they're worth. Using the '+' operator instead or .toString() for instance. I like that the shorthand will save some keystrokes, but I'm afraid too many people will come along and not understand it. Interested in others opinions.
I might be in favor if it supported `undefined` values. That's my one gripe with JSON as a data format. It wouldn't be a problem though if JS had only had one empty value type to begin with, but there's no way to fix that now *sigh*.
To myGreat question. To my understanding, initializing variables with `var` is still an acceptable practice in Javascript. They merely have different scoping properties. We have three ways we can initialize variables in Javascript: - var (Binds definition to the encapsulating function), - let (Binds definition to the encapsulating code block) - const (Binds definition to the code block and is immutable) Here is is a jsFiddle demonstrating the three types of scoping properties. https://jsfiddle.net/xp8mre5g/1/ The reason why I used var is that of convenience. Once in a while an ECMA 5 habit slips out I suppose. Let and const would work fine in the demonstration. Call me old school I guess. 
I refuse to tell you anything!
That one liner is amazing. Thousands of lines will be saved in the next few years. 
https://thenewstack.io/typescript-getting-popular/
I can second that. Kyle Simpson‚Äôs writing style makes it really accessible, while still not holding back any of the grimy details. My one reservation about ‚ÄòYou Don‚Äôt Know JS‚Äô is that is does get bogged down in opinion in places. As long as you take it with a grain of salt, you should be fine. 
Thanks for the reply! My question probably seems pretty simple to most on this sub, probably why it was down voted. I could care less about that, I got a good answer to my question which is what I came here for.
That is not something I have tested directly, but if your system is able to serve static files it should work
Allong√© is really tough for a beginner. Eloquent ramps up really quickly with a new version coming out soon. All great resources for folks with experience though. 
This is awesome. Would love to have a James Harden beard in here too.
Yes, but your comment was responding to someone saying "YAML is a superset of json, so [it's JSON + added stuff]". Paraphrasing the second half. And that statement is generally correct. YAML is a superset of JSON. `YAML !== JSON` is true as well. That's not a contradiction. You could argue that it should say "YAML is a strict superset of JSON" to rule out the equality case but I wasn't aware we were talking about details of set theory here. ;)
I see your point. I, personally, don't think JSON needs a rewrite. The simplicity is what makes is valuable. That said, the purpose of the "rewrite" the author was pointing out was so that you could instrument the JSON "code" a bit more, using things like comments. I know that when I have JSON in config files and such, I usually wish the JSON was really the JavaScript object syntax so that I could put the other information in place that I need and so it was easier to maintain for humans. That was the author's goal. Someone else on here already pointed out the solution that I always end up using in these situations: I just make the JSON into real JavaScript and the problem is solved. 
trollol
TBF to everyone you did say &gt; I'm not going to rewrite the entire thing in yaml to get those features, but I'd happily use this. and &gt; It's a proposed extension to JSON. If it were adopted, then there would presumably be no need to rewrite anything - you could just start passing JSON in using these new features. So I think what you've experienced is you misunderstanding this, and everyone else understanding it far better. It might shock you to learn, there is time for updating (or this case, replacing) interoperability standards, but some weird edge case where you need to comment a JSON file, is not one of them. Either your use case is complex enough to warrant tooling or scripting built to facilitate it (which is really easy given JSON's stability and support), it's an anti-pattern and you shouldn't be doing it in the first place, or it's such a small convenience that it really there's need to consider it.
I think you may be referring to [react-css-modules](https://github.com/gajus/react-css-modules) which is specific to react. [css-modules](https://github.com/css-modules/css-modules) is a concept, not an implementation. It can be used in many different ways including through [css-loader](https://www.npmjs.com/package/css-loader) in webpack or postcss. I would definitely not call this css-in-js.
This looks promising, thanks!
YAML can fuck off. Long Live JSON.
Won't disagree with you on that.
It‚Äôs far from complex and given how often I‚Äôve seen different teams do similar, I very much doubt that it‚Äôs ‚Äúweird‚Äù. I‚Äôm not demanding a change to the spec to support it. I‚Äôm simply saying that there are places where the proposed changes would be useful. You can argue about whether the level of usefulness outweighs the cost of extending the spec - that‚Äôs a sensible discussion. What‚Äôs been happening instead is people coming up with a whole bunch of convoluted solutions to problems they clearly can‚Äôt be bothered to even properly understand. 
I've considered it in the past, but the workflow around JSON is just so easy. It's the lingua Franca of the web. Also, I dislike syntaxes which are based on indentation.
That's very honorable and supportive to offer. I don't think it's necessary. I mean it's not like we're talking abou 7mb of logic scanning keystroke events here. IMO it'll be fine leaving it together. If you were concerned about it, you might include some documentation on how an individual can separate out, if they were so inclined.
I‚Äôm not sure your minor chords make sense? 5th string, 6th fret is not F, it‚Äôs Eb
&gt; IMO it'll be fine leaving it together. Agreed! :) &gt; Unlike a lot of packages with 18kg of cruft, your tools here have actual use That's the best compliment a library maintainer can receive, thanks!
But you can't change the spec, that's the point. You could extend it, but that would mean you'd be using a different data format and lose interoperability. As far as I can see there is no sensible discussion can be had around a spec change for such conveniences, since the cost is so high. Therefore, if it is a common problem, or one that really needs a solution, the easiest and best solution is providing something built on top on the spec to solve it. People are coming up with convoluted solutions, because they understand *that's* the only sensible discussion that can be had. Unless you have data you need to transmit, that literally cannot be expressed in JSON, building on top of it is always going to be easier than replacing it. 
Using logical operators for defaulting (i.e. "localVar = inputParam || defaultValue;") is nice (IMO, some disagree) as it reads logically enough (set *it* to *this*, or if not possible *that*), but I don't like short-circuited condisiontals using &amp;&amp;. I understand exactly what is going on as do many others (most with a reasonable amount of experience) but it will confuse some developers making your code harder to read and it doesn't scan readily into natural language, at least not in my head. If you want to make conditionals more concise I suggest using the built-in conditional operator that is designed for that: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator - so for the example given: "connected?login():0" (unfortunately you can't skip the false part, using 0 as here is the shortest option, some suggest false, as you aren't assigning it anywhere it doesn't matter what literal you use). On another pnoit: caching "array.length" is advice that can be much further generalised to "cache all inveriant values used in a loop". For instance if then end condition is determined by an element in an arry or any property of an object (not just array.length) then cache that in a simple variable too. Especially if reading the value could be expensive such as pulling it from a DOM node's attribute. A good optimising compiler will do this for you in most cases though I still prefer the habit of doing it manually despite this being less concise because it can be more *clear* despite being less concise and because there are some things that block almost all JiT optimisations (see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers for a list specifically relevant to V8, as used by Chrom{e|ium}/node.js/Electron).
Yes. That sounds about right, and is pretty much what we do. Pull requests will typically involve multiple repos, though, with is a bit annoying. We are considering using Yarn's workspaces feature to get all our projects back under one Git repo (https://yarnpkg.com/en/docs/workspaces), but we haven't had time to work on this yet.
So... interesting! Sounds like that might be a caching or other issue with surge.sh. Have you checked out Netlify? I've found it to be _great_ for static site hosting
I would love to! Looking into it
Unfortunately, it requires babel as far as I can tell. I am using buble as the transpiler, which ships a reduced payload and tends to be overall a bit smaller. I'll make a note of it though, because I'd definitely like to add as many libraries as possible!
I'd start with some tutorials to get your skills up, then you'll be more marketable when you're looking for new opportunities: https://www.turbo360.co/tutorials
The [Rauschmayer books](http://exploringjs.com/) [MDN Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) 
Why? While I've been working on [https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS](https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS) I spent enormous amount of time on creating schemes, and then I decided to automate this. Imagine the library which allows you to pass a code string as input and receive a complete SVG string as output. There are also some cool features like style themes, scheme transformation etc. I was hoping the community can test it out and give some feedback. Thank you in advance. 
Hey.. you give me an idea to use `code testing coverage` to detect dead code, but it requires full unit-tests coverage. :(
Many other browsers do not
+ Ember for some reason
After using grunt, gulp, and ultimately resorting to NPM for building my projects I spent a bit of time creating the task runner I've wanted. It has the same idea of a task name with a command as an npm script, but you can build out task dependencies, check inputs for skipping up to date tasks, and easily parallelize execution. Any feedback would be welcome!
I am studying node js and this compilation help-me very much.
Transfer your knowledge of Meteor into knowledge about the core technologies making up the framework. Read up on websockets and associated libraries (socket.io), familiarize yourself with Node.js for your backend, and learn a view library such as React or Vue. Meteor used to be pretty cool and interesting tech for getting something up and running in a short period of time. From my point of view, it kinda died when they couldn't agree on an opinionated tech stack, but allowed so many different overlapping libraries to be used, e.g. React and Angular over Blaze. That, and the Mongo dependency scared folks away. These were some general advice. Improving on React and Redux is simple: just make something with them. 
being a professional beginner is a thing
Yay! Just what we need, another module loader...
practice. it's like learning all there is to building a house, but never actually picking up a hammer. of course the first time you pick up the hammer you're going to be lost even if you know a ton about building a house. i found programming to be the same. start building stuff and only then is it going to become second nature to you. like, oh, this was a problem I've encountered before, so I know how to solve up. just like if a professional contractor runs into a problem building a house, he immediately knows the solution because he's built 1000s of houses before.
It became second nature after about a decade of programming and learning.
Really cool! You should cross post this to r/nba if you haven't already.
Pick something to make that you really, really want to exist. That really excites you to work on. Then start with [create-react-native-app](https://github.com/react-community/create-react-native-app) and build it. When you don't understand something, google, click the stack overflow link, and you learn. Easy.
There's a wide range in quality of the learning resources out there, a lot of what I see recommended to beginners is either a course that only teaches you to copy variable names from an example or a book that goes into execution without any kind of practical examples . All too often important things like debugging, testing and learning to read code are entirely skipped, while at the same time learning frameworks is pushed harder than first learning fundamentals . Getting good requires having good learning resources, not skipping steps and practicing .
Thanks for sharing!
Building projects without relying on anyone. 
That was the most descriptive title you could think of?
Pretty good punch list. Worth looking over. Thanks :)
was it hard to convince your company to open source? I'm currently trying to convince the company I work for to start open sourcing code and I'm wondering about the most effective approach.
Ahh, I didn't realize that.
That font is even ballin', I love it.
I don't understand why. This way there is no nested promises/callbacks. Seems cleaner.
Yeah I've heard this from other people but far out I am just so over putting time into learning another tool like this. Sigh.
Honestly it's really not that bad... took me an hour to duplicate what I thought was a fairly complex webpack setup with rollup
Well for this particular one, I don't have any dependencies, so that might be fine. But what if you have dependencies? You need to bundle right? In terms of your main entry, can you show me an example of a package you've done where this is working? I just want to see the project structure and webpack conf in full so I can see what's going on. 
Is there some boilerplate I can use where I don't have to care? That would be ideal... I'll go looking. 
We're a small company, so it wasn't really difficult, the hard part was actually to separate the modules in a way that made sense to someone else. But if you're planning to pitch the idea of open-sourcing I'd recommend looking into how companies like Facebook, Netflix or even Microsoft have benefited when open sourcing their tools, I mean, they're actually saving a lot of money when the community is helping them keeping their technology up to date and stable, so they can concentrate on innovation. wouldn't you agree? 
No, JS operations have fundamentally more overhead than the equivalent operations in a low-level, statically typed language like C. Even if JS is compiled to machine code ahead of time it will still take longer to execute. For example, [these are the semantics of the add (`+`) operator](https://www.ecma-international.org/ecma-262/6.0/#sec-addition-operator-plus). The actual adding of the two numbers is the final step (step 16). It has to do a variety of conversions and type checks before it can actually do the addition because JS is dynamically typed.
Why did you call npm npm.... surely thats confusing
haha couldn't think of a better name at the moment, we use it on for npm scripts (we don't use yarn) so we named it npm. Got any suggestion? 
Uhh no idea, npm-scripts? I'm terrible at naming things 
apparently, you and me both my friend. LoL
it‚Äôs actually called @gik/npm, so it should be fine‚Ä¶ although a NPM fork could also live under that name, maybe you‚Äôre right.
Very cool man. Good work.
yup, that's the plan. Any particular reason you went with an MIT license?
the article says it‚Äôs obsolete because [ava-ts](https://github.com/andywer/ava-ts) exists. welp.
No, just the most accurate one. Also I‚Äôm still new to reddit, I‚Äôve been trying to expand my known list of communities for software development
I can sort of understand it as a pre-processor, so you can just write your JSON in an easier manner, then convert it before use. Though to go to the trouble of organising that as part of the build pipeline, you might as just use JS like you said. It'd be just as easy and provide far, far more power and flexibility. I'm not entirely sure whether that's what the author is aiming for with this library. Though in the inclusion of a new MIME type, and number values that don't convert to JSON, suggests to me, they want people to actually start supporting it and using it as an exchange format. Which I just don't see happening...who knows though. 
&gt; No, just the most accurate one. It isn't accurate either. It's just a self-fulfilling prophecy. I downvoted it because the title is complete garbage. You have to put some effort into it. It's disrespectful if you don't. Also, people who find it via search won't click it either. It's like preemptively flushing it down the toilet.
im a good guy, but you really didnt describe the error you're having , so you arent making it easy for us to HELP you fix it... so if i cant HELP you, i have to DO it... and if i have to do it, I do that for money. :/ Did you google the error? What software is giving you the error? 
technically that's impossible because of the `@gik`scope, isn't it? 
Not really. Your users bundle them. Babel lets them stand as require or import calls and you publish like that. Users will consume them via Webpack/Rollup/Browserify. The only exception would be if you provide a browser bundle for script tag consumption. You can do this additionally, and i would suggest you use Rollup for that as it creates smaller bundles. I only do this if i absolutely must, script tags are dead.
No, I mean judging from the name.
&gt; Fair point! Editor tooling is certainly a weakness. I bet there's a way using ASTs to parse the css-in-js blocks and show CSS highlighting. I mean, they added HTML-esque highlighting for JSX, so why not CSS?
You can use a set to get the unique values of the letters in the word. If there is not the same number of items in the set as in the word, then not all letters were unique. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set function isogram (word) { const letters = new Set(word); return letters.size === word.length; } console.log(isogram("abcde")); console.log(isogram("aa")); console.log(isogram("yiss"));
Clickbaity stuff you see around all the time from an obviously fake account (Jessica my foot - you mean Igor or Rajiv...) Not even particularly good. &gt; 1. Converting to boolean using !! operator It's not better than simply casting to Boolean, and less readable `Boolean(castMe)`. I mean it's not 1999 anymore when you need to minimise by hand... Same for the number one &gt; 3) Short-circuits conditionals Not very readable, there is a reason why most JS style guides say not to use it. &gt; 4) Default values using || operator You learn this in day two of JS school &gt; 5) Caching the array.length in the loop Micro optimisation with little impact, and none at all on some browsers &gt; 6) Detecting properties in an object O_o is that a "tip"? &gt; 7) Getting the last item in the array Good, but it's just a normal language feature &gt; 9) Replace all /facepalm &gt; 10) If you need to merge two arrays you can use the Array.concat() function: No shit. Next you are going to tell us that if you need to remove the first item in an array you can use Array.shift()
Yes! It makes it a lot easier to do some quick basic prototyping of user interactions :)... I study HCI and am currently looking into React for rapid prototyping.
definitely exists! I didn't want to get into too much detail, but editor tooling _can_ be a weakness, but in general, it is both: 1. Getting better 1. Many editors (e.g. VSCode, Sublime, etc.) have plugins that allow for CSS in JS tooling So it's definitely not non-existent, just maybe not quite as strong and robust as the equivalent CSS editor tooling.
could even just do "npms" instead of npm-scripts
No, designers don't need to know how to code. Knowing how to code informs a person about what's easy to implement and to make consistent, but that doesn't necessarily translate to what looks good, what is intuitive to users, or what makes sense from a branding or strategic perspective. You can easily invert the question on its head to see why that makes sense: do developers need to know about kerning, color theory, negative space, stock photo licensing, etc? No, not really, that's the designer's job.
Did you ever use Axure? Because i am in doubt if frameworks are needed because Axure has a lot of functionality. Also, are you in large teams? What developers see benefit from you prototyping in React? Why not Vue? They say it is much easyer Vue framework. Also, what courses did you do, do you know JS very well?
This is just a couple of reworded paragraphs from Wikipedia
By looking him, it is vice versa, he is stating that yes, they should: https://www.youtube.com/watch?v=Flze-rwT7lM But i want to see what developers think on this, if there are any benefits for you, that designer knows code (framework?)
I agree with your points! I'm going to rethink the content / audience and make the scope more specific. Thanks for taking the time to read and review the post.
I'd probably use Prettier over ESLint these days. Zero configuration, zero bikeshedding.
Thanks for taking the time to read and review the post. I didn't write todoMVC, but I'm guessing that non-bundled script is common to all the implementations of todoMVC. Nice catch on $delegate! I'll definitely check out dom99 - it looks pretty cool :)
I don't get why developers call their own stuff beautiful, it is like when someone laughs at their own jokes or something. but thanks for sharing though!
If you're interested in benefits, sure, keep an open mind and learn about as many things as possible in as much depth as possible. There are two main reasons for why a designer *shouldn't* learn coding. One is conditioning. For example, learning database normalization might help you inform about a better way to display certain information, but a common thing newbie programmers do is implement single-entity update interfaces (i.e. edit pages) because that is the easy to do with SQL/CRUD/REST/etc. The problem is that batch updates frequently offer better UX but, due to conditioning, would not be the UX of choice to many programmers given that it is less straightforward to implement. The other reason is opportunity cost. The time you spend learning something is time you don't spend mastering something else. This may seem obvious, but realistically, not everyone is a disciplined self-motivated self-learner. There are many things that a good designer needs to master before coding, and there are plenty of things they can pursue for career growth that don't involve coding. So, should you learn to code if you're a designer? No. Will you benefit if you do? Yes, but only if you are disciplined about taking the right lessons from it.
In this [image](https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart/raw/master/docs/examples/default/flowchart-image.png), it looks like the flowchart is implying that it only loops in the last if statement. This [image](https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart/raw/master/docs/examples/defined-color-theme/flowchart-image.png) doesn't really convey the fallthrough in the switch statement. Also, your parser doesn't seem to handle for..of loops. It looks really nice though!
 faker.seed(value); Problem solved.
[removed]
This is so damn cool. Good job!
Ain't nowt quite as satisfying as taking an idea to its n^th degree, except maybe pushing the software that implements the idea solidly past mvp. This definitely has promise for a great learning tool. Nice :-)
Sorry node. Serverless has arrived.
&gt; Name Your Functions That's usually not necessary with new ES2015 automated function naming rules.
Formatting != Linting Use eslint to enforce style and to catch errors, prettier to format. 
It seems like just about every web developer could find a use for a library that adds a css selector when an element is in the viewport. That is essentially what this does. I would think this with be helpful to just about everyone that wants to add some basic css transitions to add some visual candy.
Really needs something about bundling (webpack) and typing (TypeScript)
http://deanhume.com/home/blogpost/cpu-throttling-using-chrome-developer-tools/10144 This is an old article, so this feature should be available in regular Chrome by now. 
I'd love to see this as an outline addon in vs code Reminds me of water bear but without most of the functionality. Great job op.
I didn't know you could pass a string to the Set constructor. But make sure to toLowerCase or toUpperCase the word before evaluating otherwise `"Test"` will return `true`
And I gather that they just run on static files?
I disagree with the component-focused architecture. This pattern does't scale well and makes it a pain to find things when you start abstracting models out to a separate npm repo and are left with a random collection of subfolders - many engineers working on the same project don't usually maintain discipline about it. Also one of their code examples had a redundant middleware curry(?) app.get('/', (req, res) =&gt; { myController(req res) })
Care to elaborate? I'm genuinely curious how serverless deprecates node
Speaking of "enforcing stateless behavior", I think Heroku is good "stateless" training wheels. For example, you can't even have a dependency on the filesystem which is always tempting/easy when starting off a new project. If your application works on Heroku, it's probably architected to work anywhere with any number of app servers, so I think it's good for beginners or people that aren't sure what statelessness would entail.
Doesn't make sense. You still need to bring your own runtime... You sure you know what those words mean?
This is incredible. Amazing job with this.
Awesome! Now make one for football 
Why are you calling it a MEAN stack app? You're only using the A in the acronym.
AWS accounts for more than 6 times the server capacity of all the competing services combined. FaaS architectures will result in less physical servers being provisioned. I assure you these Lambda type services from AWS aren't running node.
We're using Node and Express as server-side. It didn't seem necessary to post on the question. 
&gt; That's half of truth - Node is pretty good on CPU intensive tasks, but it's awfully bad at doing CPU intensive tasks in the same process with request handling. Depends on what you quickly you need that task done. It's not a secret that you can get way better performance using Java, C# or C++.
What do you mean "forced you"? That &amp;&amp; probably isn't doing what you think it's doing. Programming doesn't work like natural language, you have to be more explicit. You can't say "if x is equal to y or z", you have to say "if x is equal to y or x is equal to z". 
Good ideas mostly, but the concept of a best practice list is too prescriptive, and some of these are wrong or outdated. People are going to waste time and lose focus on actual requirements. See 'cargo cult programming'. First of all, Express is just plain outdated. The idea that you can't use custom Error classes is also outdated with the last few versions. Not every project needs a bunch of subfolders or secondary repos. You absolutely don't have to use Swagger to document your API. Unhandled promises are supposed to crash in 9 right? If you don't have massive amounts of traffic then you can usually run the front end as a separate Node process. Doesn't always have to be nginx or something. The lock dependencies thing is outdated. 
Thanks for the pic it‚Äôs what I was looking for 
Is there a similar list for React?
L
I wrote this library about a year ago to make it easy to make high -level, behavioral assertions on async code without firing up heavyweight tools like nightwatch.js, selenium, etc. In my projects, these tests tend to execute in ~50-100ms: literally 100-1000x faster than something like nightwatch.js. There are two caveats: 1- It assumes you're working with some sort of API mock which can respond immediately. 2- Since it never uses a real browser, defects in your CSS cannot be detected.
&gt; ES2015 automated function naming wait, what?
// a bit more Unicode-proof function isIsogram(str) { str = str.normalize().toLowerCase(); return new Set(str).size === [...str].length; } 
NBA CLI - Watch NBA in your terminal. https://github.com/xxhomey19/nba-go
What are you talking about? Node is a lambda runtime. I get the feeling you‚Äôre using these terms but have no idea what they mean.
you can use this function: function isIsogram (str) { return !/(\w).*\1/i.test(str); } https://stackoverflow.com/questions/35469019/how-to-check-regex-true-on-no-repeating-letters
same. wtf????