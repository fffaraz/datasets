I agree with your decision. It is never a good idea to leave unfinished products gathering dust. ^^
Glad you do buddy. Well, that is one of my problem, I have many and constantly excited with new, while the old getting dusty. But honestly, I hoping to release them all one day. Slowly and steady.
I love to hear how people say that you don't need semicolons because the code works without them most of the time. Hey, the weak comparison operator (==) also works well most of the time, why don't you use that instead of ===? It saves one character too!
Slow and steady wins the race! And excitement is good, it keeps you going. Balance is key, as with everything. ;)
Because you’re whining that reddit isn’t rallying behind you? You were being a dick in the comments, is that really so hard for you to grasp? Sometimes being factually correct doesn’t mean you’re morally in the right. But you seem pretty convinced it’s everyone else with the problem, and I don’t really feel like arguing with you anymore.
You need help by the looks of it
I've got an extension that fixes number 1
That is actually pretty sick project. Thank you very much for making this open source !
Interesting game! Does it have players and does it work on Linux?
I finally fixed it!! Edit: Also tested the breakpoint thing and it worked fine. Good thing to know for debugging. THANKS DUDE. It was indeed that it wanted to highlight cells offgrid. 
I don’t get the joke.
Computerphile on Youtube. The channel I've been watching more and more.
It's a special case of the logging functions, not of the date object. It's meant for debugging, so it tries to print the most useful representation of an object. In your example, it's telling you the object's type and a list of its properties, which is far more useful than a custom defined `toString()` method. If you're doing this in a browser, the output is even interactive, so you can click on it to edit properties and such. This wouldn't really be possible if it just converted the object to a string. Note also that this is all implementation-dependent. If I run your example (in Firefox) I do not get the output you get. I get the Date object's type and a human readable representation of its contents, in UTC form, not the result of `toString()`. But whatever implementation you're using decided that seeing a date object printed in the local time zone was their idea of the most useful form for debugging. Again, there are no standards, it's all up to the `console` implementation. 
&gt; JavaScript is compiled language; Sure, why not? https://github.com/nexe/nexe All languages can be interpreted and compiled as far as I know. Even C. http://www.drdobbs.com/cpp/ch-a-cc-interpreter-for-script-computing/184402054 However, I usually talk about the present norm and for Javascript, it's compiled and has been for almost a decade.
Oh ok, I think I get it: So this is just engine-specific log functionality, and has nothing to do with the internals of Date. The implementation of the log is just to represent the Date object as some type of time string instead of it's Object representation. Is this correct? Seems a bit strange to switch it up for the Date Object only.
Yes. What's the problem exactly?
Well obviously, by definition every language can be interpreted and compiled, as language itself doesn't define whether it's compiled or interpreted or both, it's what we have and what use it's made for... Such as compilers and interpreters and probably transpilers.
When did I say that the Rasp Pi was software? I just pointed out that the Rasp Pi has a tangential relationship to FLOSS. It's clear that you have no argument and have resorted to name calling and deflection.
Deflection? I just asked you to learn about [FLOSS](https://www.gnu.org/philosophy/floss-and-foss.en.html) before you try to argue with me about it not being total garbage. It's not about software being free or not, it's about nutjobs thinking that it's *injustice* if it's not free or not open sourced. Get over your ego already. FLOSS is shit, deal with it.
Big fan of [Full Stack Radio](http://www.fullstackradio.com) and [syntax](HTTPS://syntax.fm). Great podcasts with some really tasty treats!
I know what FLOSS is. I'm aware that it has to do with software. I'm not arguing the merits of it. I'm just pointing out the strange circumstance you're in: using a Rasp Pi, which runs off FLOSS and then calling FLOSS garbage. EDIT: Not once did I say that FLOSS was superior. What ego do I have to get over, as you claim? Again, you are making assumptions. EDIT 2: Also, you're trying to move the conversation away from my main point. Instead of addressing something I pointed out, you go on a tangent and totally miss the point. You assume that I'm some sort of FLOSS zealot. You call me a "FLOSS skiddie" and a "dipshit." You insult other members of the subreddit. You insult /r/javascript. What credibility do you have after doing these things?
It's the other way around: The Date object is being handled fairly normally here, as in it's simply calling `.toString()` on the Date object, and showing the result. The regular object is the one whose visual representation is altered by the logging system, which is showing a bit more useful representation of the object. It's also adding the ability to inspect the object properties, as that's something you'll often want to do when logging an object to the console. A regular JS object tends to not have a custom implementation of `.toString()`, and as a result simply calling that would *always* result in something like `[object Object]` - not even showing the name. I'd say this is mostly done to make things a little bit easier for users, and not force them to always add `name` properties to every one of their objects just to make things more readable in the console. You might think, "well Date objects are objects too, why don't we get a nice little arrow infront of it, letting us inspect its properties just like we can do with a regular object?". This is probably not done for the simple reason that, when logging Date objects, you're generally interested in what date/time they represent - nothing more, so just a `.toString()` often suffices. Btw, you can manually enforce this ability to *any* variable, by using `console.dir()` instead. As a comparison, you can try using `document.write()` instead of `console.log()`. This essentially shows the default behavior: `.toString()` is called, the result is displayed, and nothing fancy happens. The browser console is just adding tons of stuff to help us developers out! :)
I'm not quite sure that the layer of abstraction is a noticeable difference, in most situations. Especially when the layer is nothing more than a direct call to Vanilla JS and no different than creating a method that does the same within your app (which most people do).
If you can't admit that FLOSS is garbage then you think it's okay, there's no inbetween with "paid software is injustice" and "paid software is fine", other than "I am fucking stupid and have no idea what FLOSS is but I will tell you that I know what it is". That's the ego you have to get over. Did you even click the fucking link or bothered to read at all? Because it looks like you didn't. Just because we all run some form of free software doesn't mean that FLOSS is fine.
I really appreciate that people complained about the phrase tasty treats so often that they just use it even more now. 
I'm not here to argue the merits of FLOSS. Is it a philosophy I agree with? No. Proprietary software is fine. It's not evil. Open Source stuff is cool too. I did read the link you sent me. I'm aware of what FLOSS is. I know who RMS is. I know what GNU is about. Refer to my second edit on my previous comment as well. EDIT: It's clear that I'm throwing things into a bottomless pit. Have a good rest of your day. I'm sorry if I offended you in any way. It seems like I must have if you started calling me names.
&gt; learning react is a much steeper learning curve than vanilla JS Disagree.
Use Firefox?
There's a difference between insulting merely a place such as /r/javascript and people who spout nonsense in it. But since that got over your head so easily I don't think it's worth discussing anything. Well if you don't agree with FLOSS, how about don't get triggered when I say that it's garbage? There's nothing wrong about free software, does that mean that I'm all for free software only if I run it? Keep the answer to yourself, thank you.
He does do this because that's the point of the series. It's about figuring out what's actually going on with the language and why.
I actually think I found the specific definition in v8: [v8-console-message.cc](https://github.com/v8/v8/blob/48c1cb9746ee5506a693c92544f6a89c79fcd286/src/inspector/v8-console-message.cc) //... if (value-&gt;IsObject() &amp;&amp; !value-&gt;IsDate() &amp;&amp; !value-&gt;IsFunction() &amp;&amp; !value-&gt;IsNativeError() &amp;&amp; !value-&gt;IsRegExp()) { v8::Local&lt;v8::Object&gt; object = v8::Local&lt;v8::Object&gt;::Cast(value); v8::Local&lt;v8::String&gt; stringValue; if (object-&gt;ObjectProtoToString(m_isolate-&gt;GetCurrentContext()) .ToLocal(&amp;stringValue)) return append(stringValue); } v8::Local&lt;v8::String&gt; stringValue; if (!value-&gt;ToString(m_isolate-&gt;GetCurrentContext()).ToLocal(&amp;stringValue)) return false; return append(stringValue); So if it's an object; but not a date, function, error or regex: return some objectprototostring magic, otherwise return the toString result
Yes and yes
I think this is valuable for people writing interpreters, or very advanced users that, for whatever reason, really need to push the language to its limits. For most developers, and especially people trying to learn to program for the first time, he doesn't provide enough context or explanation for why you would use the (many, many) features he covers.
Downvoting you because it's not a trend at all, it's just a fad by a small minority. Mostly misguided hipsters.
&gt; I think ~~people on this subreddit~~ **most developers** just really dislike this trend FTFY
Firefox is shit. 
It can definitely be improved, but if you're not going to use the components in other places, don't put them in another file. One thing that would help is getting rid of the switch statements. `renderLoggedInContent()` should really be in the main render function as: { auth ? &lt;AddComment /&gt; : &lt;a href="/auth/google"&gt;Log in to comment!&lt;/a&gt;} This is much easier to read - everything is in one place, and it's a simple "if else" logic. Also, if something should be abstracted, I think it's preferable to do it in it's own component rather than in a render function. For `renderAdminContent()`, I'd put in the main render function: render() { ... { auth &amp;&amp; auth.isAdmin &amp;&amp; &lt;EditButtons onDelete=this.onDeleteClick.bind(this) /&gt;} ... } // above the main class const EditButtons = (props) =&gt; { ... } If you plan on making the `EditButtons` more complex, it will be much easier to abstract it out into it's own file later if you do it this way now. Hope that helps! 
Professional (hopefully soon). Definitely have some ideas for my own apps and games too. My goal (which could change but I'd prefer not to) is to become a Front End Dev
Curious what you mean by 'Apple like bug'.
I am a new developer and I just started learning React last week. Upon finishing the React tic-tac-toe tutorial, I've decided to create my own tetris react game. Its super cool as you can also rewind the game at any point and pass through the walls. here's a demo for it: tetriact.herokuapp.com 
k
Wow. What a way to blatantly take my writing out of context. My goal is to learn more about front end development, specifically JS, even more specifically, about the JS tooling that's used by front end devs. Are you happy? Does this fulfill your intellectual requirements?
thanks mate
Your readme should start with a concise summary of what your project does and why it might be useful to people.
You are creating a simple version of flappy bird. Without physics for the jump ( or a fake sensation of physics)
I think that's sort of the point though. It's not called "you don't know how to use JS", it's called "you don't know JS". Additionally the Introduction specifically says it's not for learning how to program.
Congrats on the release!
You should probably turn to r/crypto or https://crypto.stackexchange.com
I think I might need to use Canvas?
How about trying your hand at https://open.kattis.com
Thanks George. Any support is welcome ^^ .
 var $ = function(x) { return x.charAt(0) === '.' ? document.getElementsByClassName(x.substring(1)) : x.charAt(0) === '#' ? document.getElementsByTagName(x.substring(1)) : document.getElementById(x) }; Good suggestion. Made that a bit prettier for you.
We have added documentation about scaling acrose machines at the end of readme, but our next target is to rewrite all documentations in github wiki and give more examples of usage. With better logo)
I like the Wireflow, and I am python guy, but might jump and help you guys with something.
You probably know about it, but: Linters, man.
Just keep the good work!
All solved now, but thanks man (:
LMAO. It is so funny. But don't cringe -- I mean, he is a legendary professor at NYU. This is just him not taking himself too seriously and being deliberately ridiculous.
This does help a lot! Thank you!
This is great for simple cases where you're not using CSS combinators... for anything more complex I'd suggest using querySelectorAll and a polyfill (if necessary).
Because your initial assumption is wrong. Browsers only support JavaScript. This may change in the near future with the standardization of WebAssembly.
On a server you can run whatever programs you want. You are limited to what a browser can do on the client, which is JavaScript.
angular and react are garbage.
Not to mention Rust.
Yea I never actually looked at their site, it uses WebGL(on canvas) after looking into it, which is completely different, it would take me hours to debug exactly what they are doing in that instance, and WebGL support is a bit remedial at the moment. You could probably achieve a similar affect doing the method I said, though I don't know how you could do the trail off the top of my head, but you could do the feathering with a css dropshadown inset, or a css gradient, or an image overlay.
If you want to run language x on the server side of you website then you just have to get your server to support that language. If you want to run language x on the client sure of your website then you have to convince every major browser to adopt language x. The only language the browser support directly right now is JavaScript. You can compile/transpile other languages to JavaScript, but you can't run and others directly.
We use gulp at work for zipping up compiled "modules" at work. It's pretty handy for that, especially since it's easier to make the compilation cross-platform
You play in a browser 
If you are noticing performance problems using any widely used library, it’s probably you and not the library 
If I remember correctly Firefox had supported Python for a brief amount of time in order to offer alternatives. It never caught on with other browsers. In the past such a thing was difficult because there were more engines than we have today, the majority of those engines weren’t evergreen, and browsers were far less cooperative with each other. The world is far different today but at the same time there’s less of a need to support a different language. JavaScript itself has made massive improvements and using JavaScript (or some specific version of) as a compilation target is common.
Like I said...the tutorials look legit. I'll definitely use his channel as a resource. He's just a bit silly lmao
I've been planning on reading them for awhile now. Could you give me a list of topics you thought you were important/a summary of what you learned so I can have an outline while reading it?
Here is a lesson in creative writing. First rule: Do not use semicolons. They are transvestite hermaphrodites representing absolutely nothing. All they do is show you've been to college.
Didn't Exploder have Actionscript?
Hey guys. I'm a little late but I'd love the feedback. http://github.com/jstillerman/logs
Not even remotely the same thing.
From most to least important (for me) Prototypal Delegation (NOT inheritance) Type Coercion Functional Programming &gt; OOP (in JS at least) 'this' Operator Precedence Hoisting To elaborate on each point: Book 3: There's no inheritance mechanism in JS, at all. Period. End of story. It may look like there is but there isn't and once you embrace that, objects and prototypes make a lot more sense. Book 4: Type Coercion was big. There are so many "gotchas" in coercion and it drives a lot of devs understandably mad. The functional &gt; OOP is all throughout book 3. 'this' is pretty self explanatory and also in the title for book 3. Operator precedence is book 4 and clears up a lot of other "gotchas" you don't see coming in JS. Hoisting is book 2 and not as big of an "a-ha" but definitely cleared up a lot for me even though I already knew it relatively well.
They had an infamous goto fail statement repeated in their SSL handshake which didn't produce warnings in the compiler, and at least at the time, xcode didn't have unreachable code warnings turned on. I do not know if they have it enabled by default now. This could be attributed to their style which dropped braces whenever possible, but without the backup of Pythonesque indentation rules. This meant that it broke out of the if statement because without braces only the first line is attributed to the clause. The argument goes that if you always include braces then you can always tell intent, the Apple bug is tough, because it could be a merge issue, or it could be someone trying to do a final fail if nothing matches but putting it in the wrong location. As I can see that I've been downvotes, some people want to remove visual indication whenever possible so that they can have "clean code". I'm not against that, but it would be good if your scripting language treated it in a first class way rather than "but I can". https://www.imperialviolet.org/2014/02/22/applebug.html
In the early days of web browsers we actually had this. We had flash, and some other stuff I don’t recall off the top of my head. MS with IE had activeX controls which actually much like web assembly allowed native code to be executed within the browser. And you know what? It sucked horribly. You had to have the right plugin in order for the page to work, or your a version off sorry you can’t see the content. Oh you want to ha e privacy and security, good luck. Oh you want this to be performant, suck it. Yeah it was horrible.
Being an "optional" step, they are not the same thing as having my interpreter shake its head and throw some of that junk back at the author. I quote optional, because it is mandatory to run it through in our process, but that doesn't mean that every code checkin has had it happen.
I think you meant ? document.getElementById(x) : document.getElementsByTagName(x.substring(1)) instead of ? document.getElementsByTagName(x.substring(1)) : document.getElementById(x) 
v8 will both interpret and compile. https://youtu.be/N1swY14jiKc?t=13m51s 
If you want Or make your own client
2k+ active players, on sale at the moment too
Programming Throwdown. 
Does screens have a client or can you play online? Is it hard to get a footing as a new player?
I'd like to do this but a bit confused. Can you give an example on how to make the first length spec pass?
You define "this.size = 0" field. Then increase that size by one in "push" method. Finally, length returns "this.size". As you pass more tests, you'll need to eventually "talk" to elements plain array, as well. 
Why create a function for this when querySelector() or querySelectorAll() does it better and is built in?
http://store.steampowered.com/app/464350/Screeps/
Came here to suggest Softskills Engineering. I absolutely love listening to it. Been following since you released your first episode. 
Browser only supports javascript Server is a place where you generally connect to a database, run some functions and etc. Think of a computer running a program. Later you send you can send whatever you want via the HTTP protocol, which can be read by browsers **through javascript**, but a server itself has no real connection with a browser.
I honestly like yours better.
Because they prefer other languages that do not use semicolons. It's the same sort of thing as past trends that saw programmers bending over backwards to implement classical OOP in js, instead of using the language as designed.
The most important reason, in my opinion, is that one should not rely on a weirdly implemented error mitigation systems to allow for a specific formatting. That's like intentionally inserting a bug into code in C++ specifically to trigger a specific optimization on some compilers, instead of just writing optimized code in the first place.
Yours are more interesting.
I wasn't looking for confirmation of my question, but an answer to it.
Seems odd as a tagged template... You can't interpolate dynamic values right? Why not just a normal function that you can pass a template literal to?
I am just starting out with JavaScript, having done a little C# a while back. I'm trying to relearn everything I knew back then. Being very interested in testing, TDD and BDD this seems right up my alley, although I've mainly been looking at Mocha/Chai so far, it should be pretty similar. I'm going to give this a go later today. Thanks for the challenge. :)
Hi. I think the reason you are getting downvoted so heavily is that you don't back up your statement with any facts or even an argument. :)
There's a ton of layers :(. I was thinking of automatically renaming the layers as they're pasted into PS, too.
Yea wtf
Sorry, what? That's _specifically_ something tons of people use a linter to enforce. You can use a pre-commit hook to prevent them from commiting any code unless it passes the linter. 
&gt; Edit: Haha ok, this goes way over my head. It seems difficult at first, but I suggest you keep at it! There's little truly challenging about it and it's a great exercise. It just seems daunting at first. Where are you having trouble?
const $ = document.querySelectorAll.bind(document)
const $ = document.querySelectorAll.bind(document)
You still need to understand how ASI works even if you use semicolons... Consider this: function example() { return "something"; } becomes: function example() { return; "something"; }
I understand what you're talking about, but I have no idea on how to script it, can you help me out with that? I fully understand the html part that's not hard.
That’s an excellent suggestion. Thank you!
I can't answer all of your questions, as I too am looking into how to go about getting myself into the industry. But, I can tell you that knowing how to write vanilla JS is extremely important in understanding what these frameworks are doing; less reliance on the framework itself. Angular and React are the most popular frontend frameworks. Honestly, it is all personal preference; Angular5 has TS, which is a superset of JS that lets you give your variables types, and React has really awesome state management as well as JSX and even React Native for mobile apps. I honestly believe that JS is the best language to have for web apps, and it is not going anywhere anytime soon.
[Here are some prerolled examples](http://youmightnotneedjquery.com/) 
I guess because it's looks fancier? I'm not sold on it either. Also, how does this play with transpilers? Babel/TypeScript would desugar the tagged template into a regular function call, so this transform needs to run first to avoid that. But then this transform would need to parse TypeScript code as well...
When you say 'vanilla js' do you mean in the not-jQuery sense? There are a bunch of things that I do using a library which I would rather not ever try to do in vanilla. (Lodash, React, D3, threejs, etc) It's important to understand the facets of the language. Understand patterns in your code. Know when certain features are advantageous etc. But you don't need to know everything about it. Like you don't need bitwise operators to make a basic webapp. For this, I'd say just make sure you analyze things you don't understand and ask questions on those. Make sure you understand 'functional programming' patterns. I'd recommend forcing yourself to write in ES6+ at every opportunity. AJAX is fundamental in web. Definitely learn what HTTP methods are and how to handle errors there. REST apis then GraphQL is what I'd recommend. If you want to do front-end, learning React well is a great idea. Even if you don't use it in the work place, understanding these patterns will make learning Angular, Vue etc much easier. If you are interested in React, [check this out](https://tylermcginnis.com/courses/). It's been extremely worth it for me and my career. If you want to learn backend, React Universal is awesome for server side rendering of UI components but you'd probably want to start on something else like express, mongoDB, ember etc. You will learn by doing. If that means side projects in you free time, then that's how you'll learn. If it means doing free lance projects, that's your venue. But beware that a successful reputation as a developer is not founded in over promising and skimping on deliverables. Only commit to projects which you can deliver on. I cannot stress this enough. Freelancing in my experience has also been another ballgame which had its own set of social rules which I didn't know before I myself started doing it. For me though, it was always a better value in working with and learning from those more experienced than myself. I found mentors extremely helpful when I was green enough that I didn't even know how to ask the questions I needed to ask google. Even after coding professionally for 5+ years, I need to bounce ideas off people and ask them for a second set of eyes or criticism on my code. Keep in mind that whatever you learn today, you will likely need to revisit that skill in a few years and update your tools. But for now, find a specific part of development or intersection of parts and learn a shit load about THAT then build from there. 
yeah, OP has this in all his work for years but it doesn't work for IDs or plain elements? what's up with that? 
Bitwise operators can be very helpful, it’s like a Boolean with superpowers as it can have r/theydidthemath amount of states that can be combined, hence the or/and operators. Very nice. 
It took me about 10 minutes to truly get my head around what was happening; I didn't find the explanations I found that useful. Hopefully this was is a bit better. But yes they are very helpful and great for performance.
There's still array underneath. That's not too fun. Building one without any stdlib is way more inspiring. All you need is a closure :)
This only covers bit masking, there is much more to bitwise operators. And even bit masking, I have never found it to be so useful in practice. It's never something that solves a performance bottleneck, it's a micro-optimisation at best (assuming _it is_ more efficient than whatever alternative you may come up with) File under r/mildlyinteresting
It does, but the whole point of the article is to give a starters insight into what they are. Can't deny that you are right though
Great idea. When someone who doesn't know your code finds: $("#example").classList.add("test"); and needs to change the ID to a class, then they just need to change it to $(".example").classList.add("test"); That really makes everything easier. ^^This post contains sarcasm.
I always use it to write logic in a readable way: var logic = cond1 || cond2 || cond3 || cond4 || cond5 || cond6; Versus: var logic = false; logic |= cond1; //logic = logic | cond1 logic |= cond2; logic |= cond3; logic |= cond4; logic |= cond5; logic |= cond6;
You have only linked to the codepen. There is no "Example 2: Loud Playback" there
Feel free to fork and create a second level of the challenge. I would gladly take it on! Or just add "second level" section in the readme and send a PR! I created this one so that my mentee can understand arrays better. It will be too challenging to do it without fixed-sized array for them at this point. 
&gt; Is it still important to know how to write applications in vanilla JS? I never understood the big controversy about that, you still write applications in javascript, no matter which library or framework you use. There are things that libraries can help you with for certain, which would be hard to inefficient to set up yourself. Imagine if you had to orchestrate your read/writes to the dom in order to not thrash it. Or pool and re-use events from a single event source. Create a mechanism that only re-renders the parts that actually changed. Scheduling updates, manage state, etc. There is nothing in the javascript language or the dom api that would make that easier in the slightest. 
 ASI is a bad idea, but unfortunately it's there and cannot be turned off. You don't turn off the ASI by adding semicolons everywhere. :( Your argument would be great if adding semicolons everywhere made it possible to disregard ASI, but unfortunately it doesn't. Adding semicolons on every line in your code base only saves you from ONE case (have not looked into the template literals one yet) which is if you begin a line with a ( or [. To me, that seems like a bad tradeoff, and for me it makes sense to keep my enemies (ASI) close and be aware of it instead. 
&gt;I know this probably isn't a popular thought **on reddit**, but I hate JavaScript libraries. I especially hate seeing people load an 82KB file for something that could easily be done in vanilla JS. ftfy
Bang on. One fallacy I often hear repeated is that adding semicolons everywhere allows you to forget about ASI, which is wrong and and harmful advice. 
As a recruiter in the JavaScript space, I would say that building something as you learn to code is hugely important. Put it up on Github for the world to see, and when the time comes for interviewing for that first job, you'll have something concrete to show and you can explain how you built it and what frameworks you used. Regarding technology, learning to code JS from scratch i.e without the need for JQuery is also pretty important. The current market is very favourable for those who know ES5/6/7 and React, etc. Hope this helps! :)
This would be a solid advice if ASI could be turned off with a setting, but unfortunately, that is not possible. Even if you use semis on every line, the ASI will still be active, causing errors if you're not aware of it. 
It's not javascript, it's an homemade script language and a battle API but the game LeekWars is reaaaally cool ! https://leekwars.com
Sorry, I've edited the above.
Ok, so whats not working? You want to set the volume? Nowhere in your codepen do you actually call `setVolume` on your `player`
I've tried adding it but it won't work. I've been testing it via [TryIt](https://www.w3schools.com/html/tryit.asp?filename=tryhtml_intro) adding the code from [here](https://developers.google.com/youtube/iframe_api_reference) but I can't seem to get it to work.
Ok, I had a play around. I have to say that 'but it wont work' does not describe what you want to do, what the intention of the code is, what you want to achieve, and so on. I'm willing to help you, but you really arent communicating the issue(s) that you are having with the code. I am presuming that you want to set the volume to 100, as you have referenced this specific section (and that seems like the only unique bit of code there) - despite me asking for clarification. ---- anyway, I added the `player.setVolume(100)` in the `onPlayerReady` callback, after the playlist has been loaded. This seems to set the volume to 100 fine. I then added `player.playVideo()` after setting the volume, and it looks like chrome has blocked it for me. It might have been a setting I tweaked, because I was fed up of auto-playing videos (seriously, they are the devil) I received the warning in the console: base.js:6342 Failed to execute 'play' on 'HTMLMediaElement': API can only be initiated by a user gesture. So this means the user has to interact with something to be able to initiate the play. Similar to opening a popup window. The user has to click/tap on something to be able to initiate the action.
what's wrong with var logic = cond1 || cond2 || cond3 || etc..
No, you don't need a Macbook. Linux and even Windows are suitable for JS development. 
You absolutely do not need a Mac. JavaScript is pretty damn portable. It's got slightly different implementations per browser but that is not OS dependent. Nodejs on the server is identical on all platforms. The easiest/cheapest path for you would probably be Windows on the Thinkpad.
This looks fun! Is there a deadline?
Thanks for your swift and in depth response. I would like the volume to be 100 when the video autoplays. I am still learning the gist of it and working out what does what. I tried messing around with the location of player.setVolume(100) but couldn't get it to work and reset the volume to 100 when changed.
For Windows I recommend installing - Git for Windows - which also provides a bash shell - [ConEmu](https://conemu.github.io/) terminal emulator As a former Linux person (since 1994, for kernels 2.2 and 2.4 I even did network code development) I'm not missing anything. If I had any Linux servers to take care of that might be different, it's nice to have a similar environment in that case, but right now I don't care about server platforms. 
I think you are a bit salty here.
It's pretty trivial "obfuscation". In fact, you have it right there: function BNAxbV(value) { GXaXcBMU += String.fromCharCode(parseInt(value) - 87849839); } Let's make it a bit less ugly: function decrypt(value) { return String.fromCharCode(parseInt(value) - 87849839); } And there it is. You get say... `87849899` and pass it to the function: decrypt(87849899); // &lt; decrypt(87849872); // ! decrypt(87849939); // d decrypt(87849950); // o decrypt(87849938); // c decrypt(87849955); // t decrypt(87849960); // y decrypt(87849951); // p You put it all together and you get `"&lt;!doctype html&gt; ..... "`.
It will only initially set the volume to 100. You need to find if the YouTube API exposes an event for when the user changes the volume. And if it will then let you re-set that to 100. This seems like something that could be exploited to the detriment of user experience, and I don't think YouTube will let you do this. From my quick research, it doesnt look like there is an exposed `volumeChanged` event (or similar). If you must do this, you could maybe set an interval, and set the volume to max again. However, without knowing why you are doing this, I'd recommend not doing this. This is very much something that (unless it is expected behaviour from the users point of view: that they cannot change reduce the volume of a video that autoplays) will massively piss off a user. It is boiling my blood just thinking about encountering that in the wild!
Also take a look at es2015 uptades. It will give you a good background for futur interview on js 
Not necessarily but if you want to write mobile apps you’ll need a mac. Android can be done on any OS, but Apple are more restrictive so you’ll need it if you want to write anything for iOS.
Just as a side note. React Native is not considered to be a "hybrid" framework.
Can I make private repo so my hero.js code is not visible to all players??
Sorry if I wasn't clear again. The user won't see the video playing on the website as it will be out of view. It was only if they changed it on Youtube then refreshed the page, it would stay 100 instead of what they set it to. To put help ease your blood back to normal, the website is a music streaming one which is used to calm people. Do you have an example of the code including it setting the default volume to 100?
No.
dude give it a rest. most first or second year cs students do something like this in c or c++ or java
That's not entirely true. I can write mobile apps using a cross platform library in any os. The only thing you can't do is license, sign, and deploy the package to the Apple app store
Fair enough. From the codepen you provided in OP: //Find this function function onPlayerReady(event) { player.loadPlaylist({ 'listType': 'playlist', 'list': playlistId }); // Add the following 2 lines. player.setVolume(100); player.unMute(); } 
Linux's your friend, with good GUI &amp; keyboard shortcuts. Have a mac only if you plan to develop for Safari / iOS in an exclusive way since there are no other way to debug your work except having a mac for those. Otherwise avoid the whole Mac ecosystem all together, IMO it's a loss of money.
As someone learning the same (and using Ubuntu) trust me that the tools are just plain hard at first, and Ubuntu is just fine. In fact I used to use windows and it was a nightmare but everything just works on Linux. The real problem is when you try a React tutorial and it's using router and redux and eslint and prettier and babel and webpack and sass and axios and on and on and on. For a beginner (especially one solid with programming basics) hats the real challenge with JS I think. But I definitely love Ubuntu and it gets my vote every day of the week. Mac would be fine too but in terms of simplicity not more or less. Windows is actually much harder in my opinion but that's a different story. 
No. Node works well on Windows. However, I also suggest being familiar with how it runs on Linux, as that is where it's most likely to be deployed.
Why not windows
yep. That's why it's better to omit them and have the pitfalls checked by a linter. Standard.js/Prettier FTW!
apples and oranges
&gt; AI driven what? Prettier is not AI driven. Please show me an AI driven tool for JS formatting.
On Windows 10, instead of using mingw (what Git for Windows provides), you can use the Windows Subsystem for Linux. It's pretty great. A few things I will say about Mac hardware: There is definitely a markup there, but a lot of times you can't directly compare the "typical" specs and say that the hardware is equal. I haven't really researched your linked laptop, but a lot of times even if a PC has the same CPU, graphics, etc as a Macbook, it will come up short in many other ways. Slower storage, crappy trackpad, poor battery life, etc. Obviously you got what you want out of a laptop, but it's not always easy to make a direct comparison
You don't need to have macbook. I used to be windows user, and then had so much struggle to work in peace with some stuff like, react-native or meteor.js and then I switched to Linux. There everything worked from first try, and I am never going back. :) I haven't tried mac though, but Linux works great for me, I had none issues so far. I work with MERN stack btw
When you use something like Cordova or Ionic you’re essentially building a web app so I wouldn’t count those as true mobile apps - more like a web app contained in a mobile app. With React Native or Flutter you can’t even test your app without having a mac. Also what’s the point of writing an app for mobile if you’re unable to build it or even reliably test it. At some point a mac needs to be involved.
I personally use a Macbook because the workflow suits me well (and I also occasionally need to do some iOS development). However, I also have a Surface Pro and a Windows desktop that I occasionally use for web development, and they both usually do OK (every now and then there's some node module that requires some sort of compile chain that's a PITA to set up on Windows). 
&gt; To me the Windows desktop is much closer to what I expect. Windows can't even get the slashes going in the right direction so I don't understand that comment at all.
Noted, we'll get it on the board in the near future! :) Maybe we should call it [WTF Wednesday](http://commadot.com/wtf-per-minute/)? Eh, probably better in the weekends.
Windows is not native to the web. The WWW was created on Unix for Unix and uses Unix standards. 
I didn't want to complicate things.
Windows will happily work the the slashes going in either direction. :) Now, that alone isn't a good reason to use Windows. But if the horror of using backslashes is the only thing keeping someone from using Windows, they can rest easy knowing that even crappy old cmd lets you uses forward slashes. 
I am not aware that javascript people use Macs so much. There is nothing wrong with that since OSX is Unix and so is the web so using a Mac is just as good, or better, than using Linux or BSD. 
Nah. Is there a particular thing you are having difficulty with? 
If you like ConEmu, have you tried (Cmder)[http://cmder.net/]? It wraps ConEmu and adds some nice extras. I know some people who have tried Cmder and gone back to ConEmu, so it's not for everyone. But it's worth a shot if you haven't tried it. There's a portable version so you can use it without needing to install anything. 
I'm pointing out that the native use of Windows is not natural on the web and for you to use slashes the right way something manually or programmatically has to happen for that to work right. That such a simple thing isn't done correctly should be a warning to anyone trying to use Windows for web development.
How do you test your mobile app with ios without a mac?
omfg that name lol
People in this subreddit can think? What a relief.
What do you think of the mainframe space? Companies like IBM are still making gobs of money there (shrinking market, but still very profitable), but their engineers are older and starting to retire. Seems like it might be a good career move as scarcity of talent drives up salaries. 
Good question! Nobody has tried that as far as I'm aware. You might have to grant JSJitsu read permissions. We can work together to ensure that works for you if you'd like.
I already tried adding JSJitsu as collaborator for private repo but it's not working because I get error: JSJitsu isn't a GitHub member.
Here is my no [] approach https://medv.io/immutable-list-implementation/ 
[removed]
People don’t know vanilla js 
Awesome job OP! Along with screeps, there's also [Hack Mud](http://store.steampowered.com/app/469920/hackmud/) that was JS scripting based. I haven't played it in awhile, but it was much more human interaction focused. Once you got going, your scripting skills were used against other human players. It was really interesting. I'm unsure if it still has a player base though. I mainly focused on generating [art and analytics](https://dribbble.com/shots/3054727-Hackmud-Orbital-Inc-Logos) for our corps scripts. I really wish the game took off, but I suppose it's incredibly niche ha. 
Alright, I'll do some research and see what I can find. Surely there's a way to get to private repo code through the GitHub API.
There is no deadline. Do it in your time, comfortably! The whole purpose is for you to benefit from it by the means of challenging practice. If it is not challenging enough for you, come up with some restriction, like maximum function length, or no if statements, etc. 
I can see the problem that this is tackling but in simple cases, wouldn't it be easier to just check whether the promise has already been resolved? const response = await Promise.race([ fetch('https://example.com'), sleep(500).then(() =&gt; { if(!response) console.log('Timeout!'); }) ]); I was just adapting the example here, but most of the time you would probably want to either reject the promise in the timeout case or provide some default/equivalent value.
Great, thanks!
Cheers!
Thank you, DragonCockFondler, and God bless.
I got your ideas. It would be great to check promise state - but synchronous check is [impossible in JS](https://stackoverflow.com/questions/30564053/how-can-i-synchronously-determine-a-javascript-promises-state?noredirect=1&amp;lq=1). I agree that when just providing default value - non-cleared timeout should not be the issue. But if that default value requires some calculation or even database request - it would be redundant work.
I develop exclusively on Windows. 99% of things I do daily work without issue. Visual Studio Code and Node.js at home, and the full Visual Studio/C# experience at work. When i need to SSH into a Linux server or use nifty linux CLI tools, I use the Windows Subsystem for Linux and use bash. It's a really seamless experience: (1) Open CMD.exe (2) Type "bash" (3) viola, you're in an embedded Ubuntu shell.
With CI it isn't optional.
You don't need a MacBook. Based only on my empiric point-of-view, most of the people opt to use Os X because it is a Unix environment with support for popular apps like Photoshop, Illustrator, Brew, Sketch and so on. If you need any help, tell me here or in a direct message, I will be glad to help you.
I know this video and sub is javascript related but I'm trying to get my head around how are you supposed to write tests for asp.net views and database access calls when you don't control the data.
While the Mac seems to be fairly common, there isn’t anything there that can’t be don in Ubuntu. I prefer Ubuntu myself as I like the native Docker support rather than a VM. I’m and old Windows convert, so the keyboard binding is also more comfortable. 
Nope. I work in the field and use Linux. Most everyone around me uses Mac, but I honestly seem to have less issues. Every time a macOS update rolls around their workflow seems to break.
You don't ever need a mac book
It intelligently detects some edge cases or even reformats perfectly normal code if it can make it semantically better. Not that there's a neural network underneath or anything. :-)
I would say Ubuntu is just as convenient as mac (if not more because of the wealth of open source programs)
Hi /u/JohnnyBottlerocket, For javascript help, please visit /r/LearnJavascript. Thank you!
I mean, based on the question, you clearly don't
Thanks, fixed.
How? Did you even read my question? I asked why there are so many server-side frameworks, yet javascript seems to be the only client-side one. At no point did I ask for an explanation as to what javascript was or how it differed from server-side code, or how it worked. Everyone else answered just fine. I'm not sure how your comment is remotely valid.
You can rent time on a shared box for deployment etc
Learning them together is fine. You can't learn angular without learning javascript though -- angular is not a language, it's just a library written in js. Make sure you know if it's actually just Angular (aka Angular2+, Angular4) or AngularJS (which is Angular1). They are **very** different things.
IMO, they ARE solid recommendations for a beginner :) VSCode is really good, feature wise!
I have used Linux, Windows and Mac as a Javascript developer. I would recommend Linux or Mac but not Windows - Not having a built-in bash shell makes things very tricky because almost all documentation online is for the bash shell. I use a Macbook now because the trackpad and retina screen still feel top-in-class.
I guess we don't share the same experience then. It's very slow for me, with a lot of input lag.
Pointless for testing. You can’t test it on a simulator or a device without a mac. 
how is it pointless for testing? are you under the impression that you can't interact with these boxes or something? you totally can. 
You really need to take some time and re-evaluate that statement. Try repeating it to yourself in the mirror and listen if it makes any sense.
Zso.. Couple of recommendations (subjective). * Avoid all the boilerplate by using https://github.com/gajus/postloader. Alternatively, checkout PostGraphQL/ PostGraphile. * Avoid ORMs. Use lean SQL client (e.g. https://github.com/gajus/slonik) to craft queries and leave boilerplate to PostLoader/ other purpose-built data loaders. * If you decide to use an ORM such as Sequelize, you must use it https://github.com/facebook/dataloader to [batch requests](https://medium.com/@gajus/using-dataloader-to-batch-requests-c345f4b23433). * Use a logger that does not require initialization (e.g. https://github.com/gajus/roarr). Use it throughout your stack... you will thank me when your app scales to thousands of requests a second and you need to drift through bazillion logs. For monitoring/ network layer cache-ing checkout https://www.apollographql.com/engine/. Source: Designed one of the biggest public GraphQL APIs (https://go2cinema.com/api/graphiql). Been working with GraphQL everyday +10 months.
Mock it?
Alright thanks! They specified AngularJS so I guess its Angular1, didn't know that. I'll keep on working on my JS then.
Sure, but you don't need to actually check the Promise's state. You can just race them as normal and work out whether or not you already have your result when the timeout occurs. You would only need to provide your default value if the timeout expires and your data wasn't collected in time.
&gt; The real problem is when you try a React tutorial and it's using router and redux and eslint and prettier and babel and webpack and sass and axios and on and on and on. Exactly this point... To install all this additional stuff I always need to add PPAs, edit a lot of config files and most of the time I mess with my system.
I'm not into the Angular ecosystem, so I could be wrong, but almost every job listing I've seen that requires Angular will specifically mention Angular1 if that's what it requires. I would reach out and ask if you're not sure, but I'd bet it's likely new Angular(2 and up)
Awesome! I've played around with NestJS a bit, and while I'm not currently using it in production, I've been impressed at how good the developer experience is when compared to trying to use Express/Koa/Hapi with TypeScript. Looking forward to trying out the OpenAPI features. Great work!
Absolutely not. I've been developing in JS (and other web dev) on windows for 10 years. It's just fine
yes, `const`/`let` has nothing to do with immutability. if you know it, youre gonna be using `const` most of the time.
I live in Brazil, and the mainframe scene depends a lot on financial institutions. We are facing (kindly recovering from ) a huge crises in political and banking areas. So I'm not able to provide a good perspective. Currently I made less than USD 20K/y. 
Well, he's got a point. Not trying to shit on Windows here but having done web dev on it for years, the damned slashes did throw of countless of npm packages and scripts, as well as major tools like webpack in the past. I've had utf8 and bom issues, node-gyp was a hell once, node in general had real fall outs on Windows. It's gotten so much better now, but still there's the occasional bug with this and that tool, on Windows only. 
because on a server you OWN it and you can do whatever you want on it... you clearly do not own everyone's browsers and everyone's computers, so you have a limited choice of what you can run on those platforms
It really depends on the type of test you're doing. I mean, it's not the same situation for a _unit test_ or for an _integration test_. In general, in a unit test you would _mock_ the parts that are external to the _unit_ you're testing. The reason is simple: You only want to test _that specific unit_. It's a _unit_ test. Say you're unit testing a controller. You just want to test that controller, not the whole thing. So, anything that the controller _uses_ or _needs_ to perform its work, you would mock it. You create "fake entities". Your controller receives a request...? You don't create a request from a browser, against the server and let it reach your controller just to test it. What you do is create a "fake request" a _mock request_. In the same way, you may mock database access or any other part. Your controller calls a function to see if the logged user is a normal user or an administrator, which is read from a user directory or wherever? Well, you mock that function to explicitly return either 'normal' or 'admin', depending on what you're testing in each case. Not only that, in unit tests you usually run the tests with _hard-coded_ data. That is, you want to test what happens when some method receives a `false` as a certain argument? You explicitly pass a hard-coded `false`. In larger, integration tests, you don't mock "behavior entities". You don't mock a class, or a function. Precisely because you _do_ want to test all the involved _units_ or systems together. But then again, in integration tests the problem with data is slightly different. As you're testing a large, complete system, you tend to need _largish_, _complete-ish_ sets of data for everything to work. There are two main strategies here: - The best one is having a "test data set". Usually this is taken as a _slice_ of real production data, if it makes sense, or as a laboriously built set that you create specifically for testing. The advantage of this approach is that the data is "real" or as real as it can be. And to a certain point you _do_ control it. If you create the set, you control it completely, if you take a slice of production data, you control it a bit less, but mostly you still control it enough. The disadvantage is that you have to _maintain_ that "test data set" (or the tools to generate it from production data) and that is usually a cost that it's always a loss. - The alternative is to create _sets of integration tests_ which are self-contained in relation to data. This means that if you want to have a test to modify, say, a product's properties, then you would first run a test that _creates_ the product and then the one that modifies it. The advantage here is that you need a much smaller set of initial data, because most of it is generated by the tests themselves. But, of course, the disadvantage is that this couples some of your tests together, making it hard (even impossible sometimes) to run them in parallel. In any case, the main to notice about this is that you use different solutions for different types of tests. Not all tests are equal and so not all tests should use the same solutions.
I've [created an issue](https://github.com/JSJitsu/ai-battle-website/issues/70) to address this. I think it will be straightforward to fix, so I just need to find the time to make and test the changes.
Damn. I'm always surprised at how much less non-American programmers make. I wonder how long we can sustain it before software developer moves to other countries.
Thanks so much!
Is everyone forgetting hackintoshes or virtual machine?? Damn.
I haven't set up a React environment on Linux recently, but I'm not sure what PPAs you'd have to set up, other than possibly one for Node? Pretty much everything else should be available on npm
Why do you think it returns 6J? foo.substr(3,foo.length-6) means give me three characters starting from character 6, so first part is 63n and bar.substr(2) means give me all characters starting from character j =&gt; j94nhj9
I can't live without Cmder =)
I think you're thinking you're using `slice`, but you're using `substr`. The second argument is the length of the string, not the ending index. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr 
I can try tomorrow if you want? I haven't contribute to open source project yet and I will be glad if I could. 
[removed]
I still feel as if you didn't read my question... For the umpteenth time, I understand the difference between client and server. I understand that code from a plethora of languages and frameworks run on your own servers. I was simply asking why there haven't been more alternatives to javascript for the client end. Why are there not more alternatives or standards built into browsers other than javascript. Someone mentioned webassembly, which I didn't know about and I'm happy to see. 
I also prefer Linux. There are a couple of things I do to keep up-to-date with Javascript development: * use [`nvm`](https://github.com/creationix/nvm/blob/master/README.md) to keep up-to-date with current Node releases, or to get the appropriate Node version for a project * follow [Yarn's installation instructions for Linux](https://yarnpkg.com/lang/en/docs/install/) (if you use `yarn`) which will get you set up with a repository to track Yarn releases automatically Beyond those dependencies most tools that I use can be installed with `yarn global add` or `npm --global install`. From time to time I have to translate a `brew install` instruction to an `apt-get` for the corresponding package. I use Debian Testing, which has more up-to-date software than Ubuntu does. But I don't think that makes much of a difference for Javascript development when you have specialized sources for Node and Yarn anyway. Maybe you could tell us more about the particular struggles that you encounter?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [creationix/nvm/.../**README.md** (master → a57fe84)](https://github.com/creationix/nvm/blob/a57fe846e8bb7d6d53ab4bc953025fde30e1770f/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqex0b8.)^.
It depends what kind of development you do. If it's web development, Windows with WSL is perfectly fine and a much cheaper option than macOS. If you want to do cross-platform development however (Electron, React Native, etc.) it's a better to have a Mac as you can target Windows, Linux and macOS from it while from other operating systems you cannot target macOS.
Sounds good! My development environment is messed up so I can't jump into things quickly at the moment. Feel free to ask any questions, and I'll try to remember to add more detail to the issue on GitHub.
Quick question, this is the first time I’ve heard someone recommend against using ORMs, they seem to be (from my relatively uninformed view) well accepted as a preferred method over interacting with the DB directly. What from your experience makes you recommend against using an ORM in this situation?
Postloader looks cool, though it looks like the combination of postloader + slonik saves me some work building up model definitions but costs me work by needing to handcraft all SQL queries and I still need to handcraft the integration layer between that and the GraphQL schema, so it seems like I'm not really saving much work in exchange for finer grained control over the queries that get executed. Sequelize provides a raw SQL execution method, so really I'm only saving a little bit of runtime speed. Would love to hear more about your thoughts as to why you don't prefer ORMs, however. [Graphql-sequelize](https://github.com/mickhansen/graphql-sequelize) depends on [dataloader-sequelize](https://github.com/mickhansen/dataloader-sequelize), so there is a query batching and caching layer in the stack. Thanks for the links to roarr and apollo-engine, those look great and I'll take them out for a spin.
This helps if one of your promises results in a side effect. In my opinion side effects make code more error-prone, and reduce the usefulness of my type checker, which can only check function inputs and outputs. To handle a case like a timeout I would move the failure handling (logging the error, or whatever you want to do) out of the race. Instead I would return a value from the timeout branch of the race that can be identified as a failure, and handle the failure after the race completes. This `timeout` helper function does that, and produces a failed promise in case of a timeout: class TimeoutException extends Error {} async function timeout(promise, ms = 10000) { const failure = {} // Detect failure using by-reference comparison with this value const result = await Promise.race([ promise, sleep(ms).then(() =&gt; failure) ]) if (result === failure) { throw new TimeoutException(`operation timed out after ${ms} milliseconds`) } else { return result } } try { const response = await timeout(fetch('http://example.com'), 500) } catch (err) { if (err instanceof TimeoutException) { console.log('Timeout!') } else { console.log('other error!', err) } } This version of `timeout` is a pure function that is able to signal a timeout condition via a rejected promise. I can handle the timeout in the same `catch` block where I handle any other errors that might have arisen during the course of the program. In this example I use custom error subclasses to distinguish different types of errors.
You only wonder this when you haven't had the displeasure of working with outsourced devs. (No offense to OP)
Depends on if you want to start messing with React Native or NativeScript.
I actually like WTF Wednesday. Got a nice ring to it, and it's a nice humpday activity to review code and if you're working on it through the week you have two days to repair your WTFs.
I think you have the trend backwards. There used to be a lot of alternatives to javascript, things like Flash, Java, Unity Player, and stuff. A lot of the alternatives had sucky performance or security, and the rest mostly died when web apps for mobile became a thing. So we've seen javascript take on competitor languages and emerge at the most dominant. To understand why people aren't making alternatives now, think about what it would take for an alternative to be accepted. You would have to get the majority of browsers to agree on a standard, so Chrome, Safari, FireFox, IE and Edge. They all have their own js engines, so they would probably need their own engine for the new language as well. There's not really a way for the to ever catch on. On the other hand, there are some alternatives to javascript that work a little differently than you might be thinking. Langauges like Typescript and Clojurescript compile into Javascript to run in the browser. There's also web assembly, but it will be years before than can be used in any sort of "production" app because browsers have only just started to support it. There's a big different between a js library like React and a whole new client side langauge.
sweet, roarr looks nice
Installing the tools is only a couple steps (and 90% of the time it's just an npm install which is the same on all OS). I think I've only installed two things from PPAs in my entire time (node itself and git). The hard part is figuring out how to configure your tools and that is there no matter what platform you are on. But your original question was about which OS, which is why either Ubuntu or Mac are fine (and I like Ubuntu way better but that's definitely preference) and why I (and probably not I alone) recommend to avoid windows. I'm not quite sure what you're getting at.
I'm not speaking of outsourcing, I agree that usually ends badly. I'm wondering when foreign and US companies will locate more product teams outside the US. Even UK, German, and French devs have much lower salaries than the US. I recently saw a job post for my same job, same company, different product, and the salary was less than 1/3rd of my salary in Denver metro. Doesn't seem sustainable long term.
Time is random per trigger. Sort of.
It's a fair comment. Actually I had a lot of trouble with both internal and external outsourcing (Java, Mainframe, etc). But I think 80% the time was a faulty management. 
I agree, such approach makes sense. Although with your `timeout()` function you will always need to require `TimeoutException` that can make usage more complex. Anyway, my point is more about clearing promise timeout as well as `clearTimeout()` clears synchronous timer.
I worked the entire day yesterday trying to figure out why I WordPress plugin I wrote was broken on a user's website but worked on my development PC. Took all day and couldn't figure it out. 30 minutes ago, I installed the plugin on a live web server to test it, I immediately saw the PHP error. It had to do with how Windows and Unix handles slashes in file paths. But, then again, it my fault for not booting up one of the many VMs I have to look at the issues. And, I was being overly clever in how I built the file path for the required file include.
COBOL and DB2 I feel bad for you
It is all about using the right tools for the right job. In case of GraphQL, most (90%+) of the queries executed by the application will be PK lookups. ORM provides little to no value here. You can either construct the query yourself or use a scaffolding tool such as PostLoader (that will in addition to creating the queries describe their result types and avoid some normalization steps that otherwise would be done at the runtime). The 10% of the queries will be mutations and complex lookup queries. You could use an ORM for the mutations (insert/ update/ delete). I don't see any value, since again, it will be predominantly PK based queries, i.e. `DELETE FROM foo WHERE ids IN (...)`. To some extent it depends on the underlying database, e.g. traditionally, MySQL based backends contain little to no data validation logic beyond index constraints. In contrast, a well designed Postgres backend will have all of the data validation logic in the database. Therefore, if you are using something like MySQL, you might benefit from defining Model constructors that enforce constraints at the application level. As for complex lookup queries, it almost unimaginable to write any complicated query using ORM. I'd be curious to see the following query written using Sequelize.js: SELECT e1.venue_id, e1.movie_id, e1.id event_id, e1.date event_date, e1.time event_time, a1.seat_count auditorium_seat_count, seat_count.* FROM event_view e1 INNER JOIN auditorium_view a1 ON a1.id = e1.auditorium_id INNER JOIN LATERAL ( SELECT COUNT(es1.id) seat_sold_count, -- sscatte = seat_sold_count_at_time_to_event SUM(CASE WHEN e1.starts_at - es1.created_at &lt;= INTERVAL '10 MINUTE' THEN 1 ELSE 0 END) sscatte_lte_10, SUM(CASE WHEN e1.starts_at - es1.created_at &lt;= INTERVAL '20 MINUTE' THEN 1 ELSE 0 END) sscatte_lte_20, SUM(CASE WHEN e1.starts_at - es1.created_at &lt;= INTERVAL '30 MINUTE' THEN 1 ELSE 0 END) sscatte_lte_30, SUM(CASE WHEN e1.starts_at - es1.created_at &gt; INTERVAL '30 MINUTE' THEN 1 ELSE 0 END) sscatte_gt_30 FROM event_seat es1 WHERE es1.event_id = e1.id ) seat_count ON TRUE WHERE e1.starts_at &lt; NOW() AND e1.auditorium_id IS NOT NULL AND seat_count.seat_sold_count &gt; 0 ORDER BY e1.starts_at DESC LIMIT 10000 I am sure you can write it using ORM, but again – it will add no value. In general, (subjective) ORMs have no use case. The common argument pro-ORMs is that it allows easy migration from one backend to another. This is BS because of at least 2 reasons: 1. A project almost never requires migration from one RDBMS to another. In my decades of experience, I have worked on just 1 project that had this requirement. Which brings us to the second point. 2. For anything but basic ORM constructs, migrating from one RDBMS to another will require changes in code. The other common quoted pro-ORM argument is that it provides an abstraction that is native to the programming environment. This is a double-edge sword. True – query definitions will look and feel more like JavaScript. However, it comes at the cost of abstracting the actual queries. If you have a DBA person on the team, the DBA person will not touch your code. You will now have an overhead of DBA designing the queries/ indexes and programmer adjusting the lookups to match those queries. Needless to say that is inefficient. Meanwhile, writing plain queries will allow you to easily test those queries in your database client without thinking of how to express them in code. Are there valid uses for ORMs? Sure. One such case would be designing software that is intended for distribution and needs to work with different types of backends. In this case, I think it would make more sense to use ORM than writing queries for each database engine. Not too long ago I have written an article [Stop using CSS in JavaScript for web development](https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc). I think it is time to challenge the popular (mis)use of ORMs.
&gt; but costs me work by needing to handcraft all SQL queries You don't write any queries when using PostLoader (for the PK and similar logical lookups that can be inferred from the database schema). You can use whatever else you feel comfortable to write other queries. See this comment for more information https://www.reddit.com/r/javascript/comments/7fvcax/scaffolding_a_nodejs_graphql_api_server/dqf1j6b/.
Thank you! I am using it in +20 projects at the moment and slowly rolling it out into every project that I maintain. Ability to have structurized logs across the entire application stack is proving incredibly useful when analysing logs, designing alerts and monitoring patterns (e.g. query execution time, HTTP request time, etc)
I may suggest going to r/LearnJavascript as it is expressly dedicated to helping people learn.
Answered my own question. For anyone wondering, it's fuzzy search. https://bevacqua.github.io/horsey/
May sound stupid but I'm using let over const because const is more verbose and more importantly, because it promises something that it is not. It just seems a bit awkward to call something const that can be freely modified. 
And now you bring up two of the many reasons why Windows is a problem.
No I don't and yes it does.
Agreed - I wonder if you are accidentally making it more difficult than it needs to be? The next time you have a problem, can you post here or post your steps you took to resolve it? Maybe someone can point out an easier way.
so you can only play previews? I've made a Spotify app myself, but I made it a remote control for the desktop app to be able to play whole songs
Testing through TestFlight is totally different to testing having built via Xcode. TestFlight apps mean you lose all access to debugging, one of the biggest advantages of writing native apps through a JSContext (ie RN or Flutter). If you used your method you would be coding blind until you rent a Mac. There’s simply no practical way to view your app as you’re developing it - to say that testing via TestFlight only is prohibitive is a big understatement. TestFlight is what you want when you’re nearing completion and you want to distribute the app among stakeholders for user acceptance testing before release. Your method might work for Ionic, Cordova, and co but for native apps or native apps controlled via JS (RN, Flutter) it’s simply not feasible to develop apps without using a Mac. Even if you bodged a simulator onto a Windows machine it’s not enough. Simulators alone, on Mac or hacked onto Windows, aren’t sufficient to test your app if you’re looking to put your app into production. If your company has told you it’s fine to write iOS apps without a Mac then they must simply be unaware of how much less productive their devs will be. Buying a Mac would be far cheaper than paying the dev’s salary for the extra time the project will take.
Hi /u/indra1986, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'.
Doesn't work for me. Those other characters I have on my keyboard.
I wouldn’t recommend it with something like Angular, since if you’re new to the language the lines between the framework and the language could get blurred.
Under no circumstances should anyone ever use jQuery. Seriously though, jQuery is just a pointless abstraction unless you need to support very old browsers. Although it’s also good at determining and setting positions of elements, since it has a few node functions you don’t get with native, but that’s not worth bringing the whole library in for.
I agree. I only use const when it's semantically a const and not just because I happen to only set it once. Using let is clearly a win over var though.
i'm not seeing any performance issues. one thing i would remove is the little hover effect you have when hovering over the rock. 
Hmm... maybe its because im using a mac... Why do you think the hover effect is bad? Thanks!
i'm also on a mac, mid 2012 pro model. i just don't think it's necessary.
I‘m on my iphone7 and also see no perfomance issues. I agree with my previous speaker, the hover effect is unnecessary
All that `const` promises is that the identifier cannot be assigned a new value, and it delivers on that promise. Remember variables pointing to objects in JS are always only holding references to the objects. Those references are truly constant. That does not mean that the object which is referenced is frozen. That's what `Object.freeze` is for. In other words, the point of `const` is that the *identifier* is constant, not that the *value* is constant. This prevents bugs caused by a developer reassigning an identifier to a new value reference. Generally, the vast majority of identifiers in code never have to be reassigned. By defaulting to `const`, you give more meaning to `let` because it then explicitly conveys that "this variable may be reassigned at some point, so you can't rely on it always containing the same reference".
what they all try to say is - Serverside you can even create your own language and use it production wise without any effort, just let it listen on http. Later maybe someone else will try your solution and so on and so on and you gain popularity. On the other hand you have frontend with browsers. Imagine you've created cool frontend language. You've made superb app with it and it works great. What you need now is to convience few large companies to incorporate your language and once it's done you need few more months to make most of users to update to newest browser versions. And now it appears there's new better language or your language has some major flaw. Everyone's pissed. Not to mention that you need good reason why to choose any language and how it will bring any money to browser owners. Javascript have this main reason - it was first and it worked enough at the time it was introduced. And I believe it was good idea to improve it over time instead of introducing new languages.
Hmm.... I dont know if youve ever played this genre of games but they mostly all have some sort of effect on the thing you need to click. Also, i doubt there would be performance issues on a phone as you aren't actively playing the game. From the clicking, passive income from the buildings, as well as a bunch of other things, the game tends to slow down.
- Yes it's important to have at least the basics of JS. Even on Angular / Vue / React you will work with JS synthax and understanding it is mandatory - Angular vs Vue vs React : The three are totally fine. Vue is less used but growing very fast. Angular use Typescript (not mandatory but I would'nt recommend trying without it) so check if you like this language. But remember that all of them are good and that you can pick one depending on your feelings after doing a few tutorials. - I don't know if doing "vanilla Ajax" is very usefull today. I would at least try to do a few example to understand how it works but it's maybe one of the feature where I would very quickly go to libraries like Axios or the new Fetch interface.
as far as I am aware the API only returns preview urls. There are different API methods to control your spotify player which I guess is what you most likely used - https://developer.spotify.com/web-api/console/player/
&gt; It's just not made for that, ~~don't use it that way~~. it is not robust, when used this way. 
Could you send the finished code as i am doing something wrong , maybe a copying error or i might be putting launchRocket(321) in wrong place cheers 
While ago for a job interview i was asked to to a exercice which could be described like cells mitosis I was asked to draw inside a web page a square. When the mouse was overing atop the square it shoud have split it by 4. And when overing was repeated it should have done this again and again. This task was given with no techno limitation. I could have used canvas or what ever i wanted to do this but i chose dom elements with css. I only needed to be done with plain vanilla js and in 2 hours time.
Not gonna send the code my dude, but make sure you've translated the code, and then go in console and try launching it there (:
&gt; Only works in Google Chrome main.js:1063 and main.js:1745 You're using the nonstandard window.event thingy there. https://developer.mozilla.org/en-US/docs/Web/API/Window/event Unfortunately, Firefox still doesn't support image-rendering: pixelated. I'm not sure if there is a good workaround for this.
By the way i learned javascript ( first prog language) by doing javascript micro game like make moving a div with keyboard or touch. Then adding features like collisions and rendering of sprites and animations. Trying to implement simple physics rules like gravity and bouncing of object is quite challenging for beginners and make you do practical things
Just run it. &gt; (function getAttackString() { var foo = "d3263nb34"; bar = "x3j94nhj9"; return "The code is: "+(foo.substr(3,foo.length-6))+(bar.substr(2)); })() "The code is: 63nj94nhj9"
fezza, im so close i just need to get tis last bit right, gonna ask teach tomoz 
I use objection.js as the ORM with my GraphQL implementation. I consider it to be lightweight compared to bookshelf / sequelize. - It uses knex under the hood - It does schema definitions / validation - Reference joining - Best feature: Graph insert / update functions. If you have a nested data structure and defined your relationship modeling properly, you can do a nested insert / update, which is really useful for nested GraphQL mutations; in most cases, you can do a 1:1 mapping between your graphQL mutation input to the objection.js graphInsert/graphUpdate methods.
good luck (:
Yeah I don't like your argument at all...that's the concept of const in most languages, not just javascript. You can't reassign it and that's great.
Use WebGL with pixi.js. If your game logic is seperate from your graphics, I'm 100% certain it will be trivial for you to port. WebGL &gt;&gt; html in terms of speed and cross-compatibility. 
Programming is not hard. Controlling the flow of a user experience is hard.
The only thing I've found I just can't do with Linux is build iOS apps (relevant because cordova), as XCode is MacOS only
&gt; youre gonna be using const most of the time. I generally use let, because the average lifetime of a variable is like 4 lines. The number of errors I could have prevented by always using const where possible is also zero. It really doesn't seem to provide any tangible benefits.
You might find it interesting hear that there are actually LOTS of people arguing against ORMs. I would actually say that this is a super polarizing topic, almost like emacs/vim and there's many in both camps.
I've been working with graphql pretty extensively for the last 9 months. I've been working on migrating a large legacy rest API from PHP into graphql. It's actually been so great for everyone. It's taken a few iterations, but we've designed our codebase such that adding new entities or query arguments takes around 15 minutes - it's more of a config job than a coding job. It makes migrating a legacy code base of 80+ entities over so easy. Here's a few tips: - Serverless architecture is a great and super cheap way to run graphql in the cloud. - GraphQL naturally works serverlessly; each request is unique and unrelated, and the setup time for an entire schema can almost be measured in nanoseconds. - Currently handle ~50k requests per day through serverless graphql on lambda and we barely break double digit $ each month. - If going down the serverless route, it's imperative that you setup an express server (or a local serverless framework) to expedite local development. - Use mapping object to help alias table columns (also helps give strict typings for table columns in TS). - These are great to help reduce raw strings in your code and make migrations easier. - Rather than something like sequelize or hand crafting sql in a resolver, I'd suggest using [join-monster](https://github.com/stems/join-monster). It generates sql for you based on the GQL query + config you add to your object configs. It's great because it means your graphql object tree is your ORM definition (saving double handling!). - It's not *perfect*, but it covers 90% of the use cases pretty well. - For any relationships that are more complex than JM can handle, you can go with a raw SQL `resolve` function instead. - It's fast. It can parse the GQL AST and generate a SQL string in around 3ms. - Split your folder structure so it's easy to reason about where things go. We have the following structure at my company: | +-- lib - misc utilities +-- modules | +-- standard - contains all of the entities that have join-monster generated queries | | +-- resolvers - contains the root-level "query" fields for each entity | | +-- schemas - contains the graphql object definitions for each entity | | +-- Root.ts - the root query schema for the module | +-- variant1 - contains modified resolvers with a certain set of access controls on them | | +-- resolvers | | +-- Root.ts | +-- raw - contains all resolvers that have raw SQL query resolvers | +-- resolvers | +-- Root.ts +-- tables - contains all of the table mapping files - Within our `schemas` folder, we also split apart our pure graphql object config and our join-monster object config into two separate files so it's easier to view, digest and change the two. - LOG LOG LOG. - Log the execution times of every piece of your API. - Make sure all errors are caught and logged in a standard format so you can easily see things that you missed. - We dump our logs out to kibana, so we created a private npm package which helps us log in a standard JSON format which kibana parses and makes easily searchable. - This is also helpful for doing things like creating fine grained performance graphs to see where any bottlenecks are. - Create snippets for your editor. - You'll find so much of creating and exposing an entity in graphql is duplicated work. Unfortunately most of the duplication is in the `GraphQLObjectType` config, so utility functions can only help so much. - Snippets can save you so much time in this regard. You can create a snippet for a creating an empty, Object, and snippets for each type of field you might add! - My team all uses VSCode, and we found this extension particularly helpful: [Project Snippets extension](https://marketplace.visualstudio.com/items?itemName=rebornix.project-snippets). This lets you create snippets in the project folder (under `.vscode/snippets/&lt;language&gt;.json`) and have them available to everyone who opens the project.
&gt; Unfortunately, Firefox still doesn't support image-rendering: pixelated it has `crisp-edges`: https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering#Examples
Great points and some of which I am coming to realise in my own applications. Particularly that migrating to another RDBMS is likely never going to be a concern, and because my app is based entirely on 3rd party data my queries are generally very static and predictable. Having originally built my db schema with sequelize (mainly because it was easy to do), I'm now hitting difficulties when trying to create relations between data that may or may not exist, resulting in some gnarly dependency lookups that could be achieved with some plain old reliable SQL (your example query is getting pretty close to the scenario that I'm banging my head against). Admittedly I'm not a database guy so it's even more of a challenge when I don't know the right terms to Google, but I always try to be thorough with my research when I get that feeling I'm on the right track. I've considered switching to graphql to reduce the number of front-end requests and your tools look like they might give me the right nudge to make it happen. &gt;In case of GraphQL, most (90%+) of the queries executed by the application will be PK lookups In your experience, is this: 1. inherent to GQL or with a little config (as in It Just Happens and I don't really have to worry about it) 2. the natural settling point of my code when developing with GQL 3. a pattern I consciously use to improve my architecture/reduce potential issues For my application the main queries are never PK lookups (but do involve a few FK joins) and so unique indexes have been created on the columns that make up the primary query fields. I assumed this would be perfectly suitable for GQL or do you think I am going to experience any friction with this?
Hi /u/Ekaakshara, this post was removed because it had a content-to-promotion ratio of less than 1, making it effectively spam. We don't directly mind people promoting something as a aside or a closing statement, but /r/JavaScript is not a place to be "selling" your product. Thank you for your understanding, and here's to hoping we won't need to remove any other posts you make :)
I swear if you delete this link one more time...
Yea, that would do the trick.
Think about it like this. When you use `const` by default, then any time someone reading your code sees a `let` declaration, it is telling them "Hey, this variable right here is not always going to contain the same reference. We are going to reassign it at some point." That can help improve readability.
A lot of PK queries are inherent to GraphQL cascading resolution model. Lookups based on unique contraints will work just as well.
I generally have the markup on the page, usually at the footer. Styled to not display by default and has some transition properties. Then I just use my js to toggle a class or something which makes it visible and animates in.
You could get the same with static code analysis. It be actually significantly better since you won't have to do anything extra and those variables themselves would look different (e.g. they could be italic) and not just their declaration (which isn't always visible). Anyhow, if you want to improve readability by documenting your intent etc, you probably should start with types and not something as minor as this.
Mostly for consistency with other transforms (sheetify, glslify) but also for future syntax highlighting. From a technical perspectice it's also easier to differentiate between function calls and tagged template strings when doing AST parsing to get the right one. Probably also worth noting that you can import local files directly too, and in the near future from locally installed crates.
I use TypeScript and `const` together every day....
It looks like it's a banner ad script try tries to get around ad blockers? function AdManager() { function loadScript(_1) { document.write("&lt;scr" + "ipt type=\"text/javascript\" src=\"" + _1 + "\"&gt;&lt;/scr" + "ipt&gt;"); } function getCookie(_2) { var dc = document.cookie; var _4 = _2 + "="; var _5 = dc.indexOf("; " + _4); if (_5 == -1) { _5 = dc.indexOf(_4); if (_5 != 0) { return null; } } else { _5 += 2; } var _6 = document.cookie.indexOf(";", _5); if (_6 == -1) { _6 = dc.length; } return unescape(dc.substring(_5 + _4.length, _6)); } function getQueryVariable(_7) { var qs = window.location.search.substring(1); var _9 = qs.split("&amp;"); for (var i = 0; i &lt; _9.length; i++) { var _b = _9[i].indexOf("="); if (_b == -1) { continue; } var _c = _9[i].substring(0, _b); var _d = _9[i].substring(_b + 1); if (_c == _7) { return decodeURIComponent(_d.replace("+", " ")); } } return null; } this.chooseProductSet = function() {}; this.getSlot = function(_e) { if (this.slots &amp;&amp; this.slots[_e]) { return this.slots[_e]; } else { return null; } }; this.isSlotAvailable = function(_f) { return Boolean(this.getSlot(_f)); }; this.renderSlot = function(_10) { var str = this.getSlot(_10); if (str) { document.write(str); } }; this.renderHeader = function() { this.renderSlot("header"); }; this.renderFooter = function(_12) { this.renderSlot("footer"); }; this.getParam = function(_13) { if (this.params &amp;&amp; this.params[_13]) { return this.params[_13]; } else { return null; } }; this.setParam = function(_14, _15) { this.params[_14] = _15; }; this.setForcedParam = function(_16, _17) { this.setParam(_16, _17); }; this.setHostId = function(_18) { this.host = _18; }; this.setTaxId = function(_19) { this.taxid = _19; }; this.setVid = function(vid) {}; this.supportProductSet = function(set) {}; this.setDebugMode = function(_1c) {}; this.ver = 2; this.params = new Object(); if (window.cm_host) { this.host = window.cm_host; } if (window.cm_taxid) { this.taxid = window.cm_taxid; } if (window.cm_role) { this.role = window.cm_role; } var _1d = getCookie("cm_role"); if (_1d) { this.role = _1d; } var _1e = getQueryVariable("cm_role"); if (_1e) { this.role = _1e; } this.init = function() { if (this.host &amp;&amp; this.taxid) { if (this.role &amp;&amp; (this.role == "local")) { loadScript("catman3/code/" + this.host + this.taxid + ".js"); } else { if (this.role &amp;&amp; ((this.role == "deux") || (this.role == "dev"))) { loadScript((document.location.protocol == "https:" ? "https:" : "http:") + "//scripts.pd.lycos.com/catman3/code/" + this.host + this.taxid + ".js"); } else { if (this.role &amp;&amp; (this.role == "qa")) { loadScript((document.location.protocol == "https:" ? "https:" : "http:") + "//scripts.qa.lycos.com/catman3/code/" + this.host + this.taxid + ".js"); } else { loadScript((document.location.protocol == "https:" ? "https:" : "http:") + "//scripts.lycos.com/catman3/code/" + this.host + this.taxid + ".js"); } } } } }; } new AdManager().init();
I am not sure that throttling function is that useful. The debounce one is great if want to wait for some state to be stable before acting on it, e.g. to validate a form value. On the other if you need to give regular feedback about that value as it evolves, e.g. for autocomplete suggestion, you would want the last event to trigger the listener. With your throttle function, the last event will be ignore if it happens during the delay. I would suggest running the listener at the end of the delay rather than the start.
I created an Enterprise Wiki. I recommend fitting the code to the production instance. For example, is all of the wiki content that you want summarized in a TOC on the same page that you intend to insert the TOC and TOC code? Did the users/content creators create pages for each subject or is it all on the same page? If it is all on the same page then the process to build the TOC is easy. Yes, you may manually have to add the heading levels (H1, H3, H3, etc.) to each topic and sub topics if they are not already added. Inspect each element to see what, if any, class name(s) or IDs are used for each topic and sub topic. If separate pages were created, follow a similar process, but the code will need to loop each page and select the elements on each page, and add the text and link for each element to the TOC page. If the pages were created with the "[[Topic]]" method for wiki pages, then the links are selectable using $('.ms-wikilink') or $('.ms-missinglink'). THe process for separate pages will be more complicated than if the content is on the same page as the TOC. What worked for me on SPO using the 2013 experience, was selecting the Headers with class 'ms-rtestate-field'. Example: $('.ms-rtestate-field h1, .ms-rtestate-field h2').css('color', 'orange'); Plug that into your browser console and see if the content's headings change color to orange [obviously make sure jQuery is loaded on the page first]. If not, then we are not correctly targeting either the content container or not targeting the correct elements (or more likely, the H1, H2, etc. elements do not exist.) I can definitely help more once you identify where the content resides, where the TOC resides, and which classes or ids are used for both the container and the topics and subtopics. My Animals and Plants TOC works on the 'Same Page' but the 'Different Pages' is a bit more complex. Oh, and wth is a "Dumpster Cat"?
Lol at that other comment at -4 so far. Programming will get you abs if you have resistance bands &amp; dumbbells next to you for whenever you want to destroy your laptop but you bought it for your bootcamp you still haven't finished &amp; your still paying it off &amp; won't be able to afford to until you get a job after all that deferred Best Buy interest hits you in the wallet. Run-on sentence satisfies cardio for the day.
Look into object pooling
&gt; why wouldn't you? Because it's not important. There is no need to draw attention to something which is irrelevant. Just because something is const doesn't mean you can ignore it. You still have to read every line. You still have to read every assignment. By the way, you can't mark parameters as const. Is this a big issue for you? Write a proposal.
Right. So, types are more important for you.
thanks
a bit hacky, but yea it'd def work :)
thanks
Sweet that's what I was hoping for wrt the api design. I did the same thing with an HTML parser that was a tagged template. Made sure it worked as a standalone function.
Is there a GitHub for this?
You can learn it, but don't forget there will always be some stupid user or stupid businessman guiding your "engineering" decisions. Your shit will always be buggy and really, always be wrong. Nothing like having users who want a "form" on the screen that has 17 sections, when you really just need a guided process flow to capture information for each section, when it's needed. But, nope. Users are dumb. Need to "see" the form!
I ran into this issue but apparently iOS 10 and above override any custom view port or scrolling. Allowing users to zoom in or zoom out. It sucks. 
One of the comments mention the create-react-app might be an issue. Does anyone know why? 
What are you trying to do? It's easier to help you achieve your goal if you say what it is. --- &lt;in id="i"&gt;ﬧコ┘пߛப厂&lt;/in&gt; What is an `&lt;in&gt;` element? The closest I can find is `&lt;ins&gt;` but I doubt that's what you want. (https://www.w3schools.com/tags/tag_ins.asp) --- var elm2 = document.getElementById("i") What is the point of this? Your code doesn't mention `elm2` ever again. --- var text = elm.textContent.replace(new RegExp(/ﬧ/,), "a") var text1 = elm.textContent.replace(new RegExp(/コ/,), "b") var text2 = elm.textContent.replace(new RegExp(/┘/,), "c") ... I hypothesize this doesn't do what you think it does. What it does is create multiple unrelated variables that are each the original text modified once. What you probably wanted to do is chain them: var text = elm.textContent.replace(/ﬧ/g, "a").replace(/コ/g, "b").replace(/┘/g, "c")... Here, I'm using the `g` (global) flag to make your regex check for all instances of that character, not just the first. --- var face = elm.textContent.replace(new RegExp(/😀/, "ug"), "{replacement}") I don't even know what this is supposed to do. --- elm.textContent = text elm1.textContent = text elm.textContent = face This sets the `.textContent` of your `&lt;in&gt;` element to the very first `text` variable (not `text25` or whatever). Then it probably crashes because `elm1` does not exist. Then it undoes what it just did and sets `elm` to be the content of `face`. I'm guessing you only actually need the first line.
Since Windows is just software, everything in it (and every other operating system) happens programmatically. So since the processing of slashes in paths happens programmatically in Linux and OSX as well (seriously, you can look it up in the Linux and XNU kernel sources), are you said they're not done correctly either? I think there are actually some pretty good reasons to criticize Windows. This just isn't one of them. 
You got things like the Code-A-Piller and Osmo which allow toddlers to program. So I don't think you can just say it is and only is hard. There's a lot to learn, and for the most part programmers do not intentionally make it easy for the next person, because they didn't have it easy. One of the unique and interesting things about JS is that a community seemed to coalesce around the language that has been trying to break this trend but at the same time this definitely can rub people the wrong way. There is definitely a lot of negative perceptions of bootcamps and citizen coders. I personally feel that is a very insecure way to be and it is somewhat evident and confirmed by people downvoting comments in here. 
Puppy placeholders! [www.placepuppy.net](http://www.placepuppy.net)
This is pretty cool. One thing id really like to see here is a bit more responsiveness to the drag of my finger. When I swipe left or right, there is no motion of the post at all until it finally changes. It made me question whether I was swiping for a quick moment. 
And deleted once again...
That is absurd :(
Thanks for the feedback! That was initially my goal, but the complications of adding a library like React-dnd ended up being beyond the scope of the complexity I was picturing. It’s definitely the next feature I plan on addressing when I revisit it. 
Controlling the flow of a user experience is not hard. Gaining such mastery over your body that you learn to grow wings and fly is hard. 
Very cool. Nice find
Gaining such mastery over your body that you learn to grow wings and fly is not hard. Programming is hard. 
This is a weird smattering of comments that are...criticizing things? I love what JS allows people to do. It's relationship with the DOM helps illustrate that even trivial things can quickly become complicated, yet it's not so off-putting to keep people from trying. I'm glad people find it difficult enough to make them think twice but not so difficult that they quit. 
We invented programming, very recently, as a tool to let us operate computers as easily as possible. All of the ways it's hard are things that we got wrong.
Mastery of controlling the flow is making me hard
[removed]
That's a flippant statement that is plain wrong. Programming is complex because our requirements are complex and the world is chaos.
what the fuck are you even trying to say
&gt; There's a lot to learn, and for the most part programmers do not intentionally make it easy for the next person, because they didn't have it easy. This is so wrong it's laughable. Maybe not every single person goes out of their way to make things as easy as possible, but in general people do try to make barriers of entry lower. &gt; but at the same time this definitely can rub people the wrong way. People are not rubbed the wrong way because JS is trying to make things easier. This is completely wrong and misses the entire litany fo reasons why programmers tend to not like JS. It has little to do the language being easier to utilize. &gt; There is definitely a lot of negative perceptions of bootcamps and citizen coders. Not related to JS. But yes, these places often take a lot of money from people, like 12k, and give an education similar to teaching yourself online. All the while promising jobs that aren't always there. It has little to do with barrier of entry or being easier to use. &gt; You got things like the Code-A-Piller and Osmo which allow toddlers to program. So I don't think you can just say it is and only is hard. Okay, wow. When toddlers are solving actual CS problems and building frameworks, tools, etc, or *actually* programming, let's talk again. That's not actually programming.
I can literally see your insecurities.
function decode(elm) { let text = document.getElementById(elm).innerText let dict = {}; dict[/ﬧ/] = 'a'; dict[/コ/] = 'b'; dict[/┘/] = 'c'; dict[/п/] = 'd'; dict[/ߛ/] = 'e'; dict[/ப/] = 'f'; dict[/厂/] = 'g'; let str = ''; for(let i = 0; i &lt; text.length; i++) { if(dict['/' + text[i] + '/']) { str += dict['/' + text[i] + '/'] } else { str += '_' } } document.getElementById(elm).innerText = str }
No offense, but if you just copy &amp; paste your class homework assignment into reddit, I don't really want to help you. What have you tried? Where are you stuck? What part of this don't you understand? Please show your work so far. Ask a specific question, rather than asking us to do your homework for you.
 function
 function decode(elm) { let text = document.getElementById(elm).innerText let dict = {}; dict[/ﬧ/] = 'a'; dict[/コ/] = 'b'; dict[/┘/] = 'c'; dict[/п/] = 'd'; dict[/ߛ/] = 'e'; dict[/ப/] = 'f'; dict[/厂/] = 'g'; let str = ''; for(let i = 0; i &lt; text.length; i++) { if(dict['/' + text[i] + '/']) { str += dict['/' + text[i] + '/'] } else { str += '_' } } document.getElementById(elm).innerText = str }
Wow, you really destroyed him in this debate. 
Failure at controlling the flow quickly makes me soft. 
Js seems so easy for me tho
I am a self taught developer that initially started with HTML/CSS/JS and almost went to one of these bootcamps. What insecurities? You just posted some really incorrect stuff and are blaming any criticism on "insecurities". Seems like you're building a strawman to me.
I also don't see any performance issues, however I do notice that when I'm making lots of actions (ie mining ores) my computer tends to go into rocketship mode. I'm also on a macbook pro, either 2016 or 2017, whichever is real (and newer). Maybe look at how you're handling those events? I also noticed that if I try to set up a loop to click events in the console the app slows to a halt. I'm sure you have some sort of debounce or something, so maybe that's the problem?
A blog post with a load screen. I didn't check, but I'm assuming yet another React app for React's sake, which leaves me to wonder if the author is really qualified to comment on how hard or not hard programming really is.
Honestly, I only came in here because I expected and went looking for a raft of "Programming is easy, I knock out an OS before breakfast!" type comments. I haven't got the energy to troll them for it this morning. I'm with you. Language choices aside (They each have the good and bad), programming scales well. You can almost always make progress and improve and that improvement is bounded only by your own effort as much as your intellect. If someone can reason about why, when you make a cake you put the mixture in the oven after you mix in the eggs, or why breaking each of those eggs is the same process repeated n times then they can grasp programming.
Haven't built anything recently with JS, but looking forward to it. You can have a look at one of my first JS projects. It's just a simple calculator: https://tamalanwar.github.io/bkash-calc/ 
&gt; and for the most part programmers do not intentionally make it easy for the next person I don't agree with this at all, there are tons of free resources online that make it easier for someone to pick up a language. Stackoverflow alone is filled with people helping out people. Honestly, the web dev community is probably one of the most friendly online communities. 
Very general statement. Simple programming is simple, complex programming is complex. So many analogies for this, choose one. Comparing [scratch](https://scratch.mit.edu/) to [brainf*ck](https://esolangs.org/wiki/Brainfuck) ultimately makes the statement redundant anyway.
Huh. This is homework. In fact, I am fairly certain I know the module this comes from. 
Nice find 👍🏻
Uf I see I will have to boot into my linux :D 
Happy birthday OP, what's the world like now that you're 12?
While I can’t speak to this particular case, CRA does set up scripts and configurations up in a very particular way. (I’m learning this myself at the moment.) You can always leave the safety of CRA with an `eject`, but that is a one-way trip. And you’ll have a dumpster’s worth of suddenly-revealed configuration files (e.g. webpack).
Well, OP didn't know how to... so... It's easy, yes, but not everybody would know how to decode it. But more generally people do this because it's annoying, not because it's hard. In fact, they usually do this because it's very easy to make it somewhat annoying, but it is quite hard to make it really hard. And why make it annoying? Because most of the time the people seeing it don't care enough to put up with it. They'll see it and think "Ooofff, whatever, I don't care enough". For those do do care enough, it doesn't really matter if you make it easy or hard.
That's a lot of good recommandations! Perhaphs you should write a blog post? You could update the article in the original posting with your recommendations.
5/7
I liked the apt stock photo of rocks. 
I'm more of an Hentai.js guy
Please, we are in 2017. Don't say ajax anymore.
Don't aggree with: &gt; Even reading a great book is an act of consumption.
Username checks out
Actually... Programming IS easy. You see, there's a simple problem, you have to go through the forest of understanding how electric logic, chips, computers, operating systems, compilers/interpreters and etc works, before you can get to the actual programming and are able to truly say that you are good at it, or that, at least you somewhat understand it. Nowadays programming languages are very high level, and even a complete noob can do amazing stuff which was possible only by most dedicated people just few decades ago. Real programmers made it easy for everyone, and it is easy. As for your example of knocking out an OS, that doesn't make much sense at it requires a lot more knowledge, but I'll let it slide. :)
Any decent JS boi know about anime.js
Pretty interesting, but the lack feedback when there's a syntax error is pretty frustrating. Also, the console can get locked into a loop if you enter a syntax error.
I think it depends on the company culture, but most places generally prefer quality over speed. I guess if you’re coding slower you should have more time to think over everything? And if you’re writing bug-free code after 1 slower pass compared to someone who writes more buggy code but is fast, I think most employers would prefer that. If you’re a good developer people really aren’t going to mind, even more so because a good developer is someone you can discuss ideas with rather than a code monkey that’s going to smash out apps at lightning speed but can’t talk about what he’s doing. And it’ll matter less and less as you progress, since you’ll get more hands-off the more senior you get. Good luck dude!
Just looked through the docs site... what the fuck is it?
Scratch isn't even programming anymore, DnD is cancer. Brainfuck is esoteric programming language. What is there to compare between those and actual programming?
Thanks for your answer =) As it turns out, not all modules were found with npm so I have problem requiring some old modules which are not compatible with webpack / node. Probably I need to go with both, webpack + grunt or webpack + gulp?
&gt; the point of const is that the identifier is constant It's about the binding, not the identifier. Renaming identifiers is something you do with your IDE/editor.
Did you not read my last paragraph? My point was that programming is fundamentally simple and accessible to anyone. I was expecting many comments from people claiming only their immeasurable intellect could comprehend "the code" and that always makes me ratty. 
Wow you see flaws in JS which aren't related to "easy peasy and brings in "n00bs"!", you're so insecure! /s Though, when I say that programming is easy, people tend to get insecure... Especially when they remember that night where they couldn't find a simple typo they made while compiler/interpreter was shouting at them for it, showing even a damn line where they made it and even a character that is wrong in that line. I hate that kind of people. It's really not that damn hard, once you learn how it works and instead of copy pasting code from stack overflow mindlessly, you start understanding it, copy pasting it, making few tweaks to fit what you want to do, and then using it in your project, so when shit breaks, you know why it did and have an idea how to fix it. :)
Maybe this will help you https://youtu.be/PhUb7y9WZGs
They are all programming.
/r/iamverysmart Programming isn't easy. If you're doing very simple crud apps maybe, but overall it's a huge field with a ton of domain knowledge needed. "Typos" and being frustrated with a compiler is *not* why programming is hard, but it is a reason why it can be frustrating. Or better known as being *unforgiving*. Those people and the people who become defensive when you say "programming is easy" are two different people. Good Programming is hard because we deal with solving hard problems. If you're gonna tell me programming solutions to complex problems is "easy" then you're naïve or don't actually work on those kinds of things. And I don't know what world you live in, but JS / Python / Ruby or other high level, abstracted languages are not always an option. Being a *good* C programmer is difficult. Working with embedded hardware or with Verilog for parallel programming isn't easy. You're just plain wrong. Building working programs is different than building *good* programs, which is difficult.
Scratch is DnD (Drag and drop just fyi). Not programming, dragging blocks of "code" which on your end is just a simple square with few links to other parts of code is nowhere close to programming, not to mention that it's limited and will never give as much freedom as programming itself. Brainfuck is esoteric programming language, do you even know what it means?
Ooh that looks interesting, Ill check it out! Appreciate it!
That's valuable insight, thank you.
Really? So you know all of its implicit type cohesion rules? You completely understand “this”? You know exactly how hoisting works? You understand the event loop and how it interacts with your code and the call stack? You know all the DOM API gotchas and inconsistencies across browsers? You know how shadow DOM works? JS is not easy to master, especially in a browser context.
Javascript Animation library
So you were expecting people to claim that programming is hard, as in, agree with this post and not what you just said? This subreddit is pinacle of intelligence. /s
Not just the DOM! Thanks to Node et al. JS now has so many applications (e.g. robotics)
It's the sort of article to which people respond with dick waving. It's the dick waving I dislike. The article isn't about the complexity of programming it's about the benefits of engaging the brain. I think we're a little way off peak intelligence yet. Give it a week or so ;) 
steady on mate, you'll give yourself an aneurysm.
I never said that I am very smart. And I don't know what world YOU live in, but average user really doesn't need to know C and be a good C programmer. Also we are in a goddamn /r/javascript, do you really expect me to talk about actual programming and not this easy-peasy "programming" that front end developers also find hard? Also you can do a lot with it without ever having to get into actual programming when Node, React, Angular and whatever crap is here to do all the job for them. Rhetorical question, you don't need to answer. You really have great points and I never said that what you mentioned is easy and I agree with you completely, it's just not something that should be discussed in subreddit that is too smart to understand it. Especially not Verilog/VHDL or whatever is being used nowadays, when they are "hardware languages" and describe hardware itself and not what software does on it, which is lower level than Assembly, which is lowest "actual programming" language, I myself have merely scratched the surface using very little of VHDL in university, and it's not easy, although I wouldn't call it programming either, designing, for example, a good processor is entirely different problem than it is creating some application for everyone to use.
Yep, immature elistists and circlejerking. I am not surprised at all.
Shouldn't be an issue. What is important is getting the code right and making it readable/easy to work on by others in future. All that might change is your ticket delivery estimates might be a little higher. Just make sure that you take your own laptop with you to interviews so that you have your dictation program to help you as well as make the interviewers aware that you'll need to use it.
How do you disagree with that? It's certainly not creating anything
Only on reddit would this be questioned. Having a need to write and run programs to "fix" which direction the slashes goes means one more piece of software that needs writing and maintaining and installing and running. It's a "cost" any programmer would know and avoid at all costs but you'd never understand that.
And they do so, because often times, the problems people want to sort, are trivial. For example a discord bot (chat bot) that does something simple automatically, I have several friends who managed to create their own bots without even understanding many things properly and aren't ever planning to be programmers or be related to it in any other way than that. And most people make excuses that programming is hard and they don't have all the time in the world to sit down for a bit and think of how would they solve such simple problem. No shit that programmers start "dick waving".
I understand nearly every concept you described and I still consider myself a piece of shit programmer.
I'd say it depends. Generally I agree with the others quality &gt; speed. But lets say you work ond a webapp that has a huge userbase, important things get done and needs to be up 24/7. Then suddenly it goes offline and it needs to be back up within minutes. Then sometimes speed &gt; quality so that the users can use the system again.
Typically, for me, typing speed is not the bottle neck in development. In short, everything else is. The logical steps of breaking down the problem into smaller parts, thinking through what I'm trying to implement and code, testing, etc. These are what takes the majority of the time.
&gt; How much of a problem is this going to be when I start applying for jobs? If you are in the US your disability is protected by law. Just perform well during the interview. Coding fast has little or nothing to do with typing fast. Once you have mastered scope and the dom and some basic idea of architecture you will be 10x the JavaScript compared to somebody who hasn't figured out these concepts. You can afford to type slowly because something that will take the next guy two days might take you only three hours.
Woah that's a great argument to show me that I'm wrong!
Haven't worked in IT before, what are ticket delivery estimates? Good thinking on my own laptop. From what I read it's not uncommon to get asked to do small coding assignments during an interview right? That would be an opportunity to show the interviewer how I work I guess :)
Certainly? Are you sure about that statement? Reading a book doesn't have to be a passive experience. Reading a great one rarely is.
It's not about writing something quickly, it's about dishing out a half assed prototype that "works" as fast as possible and thinking about it's usefulness. Of course typing speed does matter here, but not that much. But that's only one part of development - prototyping. As for working in a company generally, I think that employers prefer someone who is good at it, not someone who is very fast at it. Also intellisense helps a lot too, as it has a number of features such as: "List Members, Parameter Info, Quick Info, and Complete Word.", lattest one being autocomplete (on demand, not completely automatic), that allows to write something even faster.
A lot of coding is thinking about what fairly small boy of code to write, rather than writing lots of code. Maybe 50% of my day is design and planning systems, so the thing you can best work on is potentially your speed of concept generation, rather than typing.
To be fair, you have to have a very high IQ to understand Rick and Morty
Programming can be how ever hard you want it to be, just like anything else.
I recommend using the instructions provided in the readme file for the website repo, and using the vagrant box. It's the easiest way to get started.
Actually shows people how to use JavaScript for trivial things and not how to abuse your `npm`. +1.
I often say that programming is like doing a 5000 piece puzzle of the clear blue sky. It's not impossible, or even that hard really, but It is daunting and, unlike the puzzle analogy, programming is an incredibly broad topic. Most people, in both cases, are not going to know where to start without a little guidance. Most people are not going to seek the guidance because they don't see the value. I'm glad you find it fun. I find it fun. It's like a puzzle you get to invent and then solve and then optimize. There is a ton to keep in mind on even the smallest project, and learning organization techniques is fun for me. I'm thankful that the thing I find fun is also useful and lucrative. That is very lucky for us. But saying programing is "easy" is just inflammatory. Programming is not easy, even on the best days. Programming is a slog. Thankfully some of us enjoy it. Playing basketball is easy, but it comes more naturally to some than others. Most importantly, don't make programmers sound like douchebags. It's not nice to the rest of us. 
Well, since JSON is just a plain JavaScript object, you can use any library that is good for manipulating data in JavaScript. Lodash probably has a lot of the functionality you'd need.
Webpack can shim old modules, inject/expose their namespaces, etc. externals: https://webpack.js.org/configuration/externals/#src/components/Sidebar/Sidebar.jsx shimming: https://webpack.js.org/guides/shimming/#src/components/Sidebar/Sidebar.jsx global injection: https://webpack.js.org/loaders/imports-loader/#src/components/Sidebar/Sidebar.jsx force exports: https://webpack.js.org/loaders/exports-loader/#src/components/Sidebar/Sidebar.jsx
If you work in an agile environment tasks are divided into story tickets. These tickets are usually given points for complexity as well as time estimates when you're planning the tasks. Depending on who/how many/other factors these estimates might increase / decrease. And yeah, a lot of interviews set tasks during. Some might be on a laptop, some may be pen/paper or whiteboard to show understanding. Depends on the company.
Everything is easy if you know how to do it, everything is hard if you don't! In all seriousness, I always take an approach of 'it isn't difficult, I just don't know how to do it yet'. It doesn't change reality but it does change how optimistic I am about tackling that void in knowledge/ experience .
How easy it is depends on the task. Most people want to solve their own problems, which are often times simple, that's what I meant by easy. It's rare for them to try and create something innovative. They want to automate something really boring, make something easier, that kind of stuff. Of course it's not easy to solve a serious problem which will determine your career and future of your project, and all other projects built upon it. Such example would be a programming language itself, as in, development and all those other things such as documentation, maitenance, yada yada. As for people not seeing value, you're right, especially when they think that it's all that boring stuff and can never be fun, even though recently I wrote a simple chatbot that utilizes markov chains and it's responses sometimes are funny even though it was reading what other people talk about only for merely over a week. The markov chain and it's theory is what throws people off I guess, even though they enjoy using the final product of it for some reason. People are weird. Also programmers definitely aren't douchebags. If they were, we couldn't even argue about whether they are or not, not on internet at least.
How easy it is depends on the task after you understand a thousand things about programming in general. Before that it's like asking some rando to frame a house. 
First of all, you can use `JSON.parse()` to turn a JSON string into an object. Then you can use JavaScript itself to manipulate the Object. If you need something more complex (like "get all values who's access path match a specific pattern"), there's a library called JSONPath. It's basically XPath for JSON. GitHub repo: https://github.com/dchester/jsonpath To delete properties you can use the `delete` keyword: `delete foo.bar` There's also the possibility of transforming arrays using the instance methods `.map()` and `.reduce()`, depending on what you are trying to do. 
Well sure, to make something it definitely takes skill and knowledge, I remember even I had a problem of googling "how to do X in Y programming language" instead of actually learning how to program.
&gt; , do you really expect me to talk about actual programming and not this easy-peasy "programming" that front end developers also find hard? Also you can do a lot with it without ever having to get into actual programming when Node, React, Angular and whatever crap is here to do all the job for them. Well I guess we agree on that one. JS does hand hold a lot. But programming general is not easy, even if certain languages are "easy", rather easier than others.
Had a quick look after reading your post. I'm impressed by the motion path feature. As a flash game developer, I used to work with motion paths a lot but didn't find anything equivalent outside of flash for a long time.
who said anything about passive? He said it was an act of consuming.
It depends on your definition of programming. Graphic based programming (instead of text based) is really just a higher abstraction over the text. If you feel like software for creating software must involve text-based code, then yeah of course you will think it's not programming.
if you were asking that, you already knew a lot of base knowledge programming is hard. anyone who says it isn't is lying to themselves or has no memory of what it is like to learn
looks like they used a closure / minifier / obfuscator https://github.com/mishoo/UglifyJS2 https://developers.google.com/closure/compiler/ I used to work in a shop that would run production ready code thru one or two of them at least to make it harder for others to steal. 
Sure looks that way, the `decodeURI` calls look like they're masking some specific data however and that's what makes it interesting. Wonder if it's possible to de-obfuscate those 
I spend a large amount of time [just staring at the screen](https://i.imgur.com/YIoGdRO.jpg)... 
It's fun isn't it :) I watched part of a Microsoft video the other day where they were making [FlappyBird using React](https://mva.microsoft.com/en-us/training-courses/creating-flappy-bird-using-reactjs-18124?l=zyfw7QaXE_7706218965). I like the contrast between the two. 
Graphic based programming isn't the same as programming. You might want to learn more about how it all works... Here's ELI5: * Compiler/interpreter breaks up your code into small bits called tokens which represent operators, variables etc, parses it, which is basically error checking as to whether code is valid, maybe then optimizes your code by replacing some expressions with ones that result in bytecode which executes a lot faster and stripping unnecessary lines of code, then translates parsed structure (often a tree) into valid bytecode (0's and 1's) which your processor can understand. * Graphic based "programming" is just dragging prewritten blocks of code and modifying parts of it through UI, which means that person who developes graphic programming application has to think through a lot more things to make it possible to develop using purely UI without typing much, for example consider FOR loop block in graphic programming: for(int i = start; i &lt; end; i += step) { executeBlock(userSelectedBlock); } In UI user inputs start of range, end of range, the step as how it increments, and also selects what must be executed in said loop, can't you see how many problems arise here? Now user might want to use the end as length of some list, now developer has to add some way of instead of entering an integer into a field, referencing some parameter of another block yada yada, all because user can't even type something out, typing isn't hard, and also it's more intuitive to just type. Graphical programming is like trying to speak visually, would you like to communicate with others using only images on which you must draw and place already existing shapes, or would you just reply in text like you do now? I am not trying to be elitist, it just has way too many drawbacks for no reason.
Cool, I'm gonna read into this! Seems like a nifty tool.
What the hell are you supposed to say without offending your sensibilities?
Thanks for the references :)
Thanks for the recommendation!
It has limitations sure, but that doesn't mean it's a bad thing. It's considered a good teaching tool. If it helps someone create something and get interested in the field, why knock it? :) It's definitely quite different from text based programming, in both capability &amp; complexity. But it is part of the overall field. It's considered to be a visual programming language. A good example of this style in the real world would be with game engines. Unity &amp; Unreal engine offer flows similar to this, to connect bits of logic together, or scripts. I know i've seen something like it with custom shaders in Unity. Blueprints in Unreal is a pretty good example of what can be done with visual based programming as well.
Those look like unicode or ascii %7F is delete i think 
Wrong. NOW I have a lot *more* basic knowledge, and now I rather for example look up canvas documentation in JS, not how to "make platformer in javascript" (which is what I meant by X in Y language). And programming isn't learning. Learning to program is.
why am i even talking to you
"programming is hard" in a javascript sub... whatever you do, don't try to learn c++...
Okay, so I was responding to your comment rather than the article specifically but even in context. &gt; There is nothing wrong with any of these activities, but they are all pure input. Even reading a great book is an act of consumption. This sentence doesn't make a great deal of sense. Input to consumption. But by input, I assume he means he isn't getting anything out of it. You 'get something out' when you put something in: you think around a subject as you're reading, you bring yourself into the conversation so it becomes a dialogue of sorts. That is an inherently creative process: you're asking questions, filling in blanks, bringing your own knowledge and experience into the mix in order to critique what you're reading. Thoughts are things too. &gt; You are not creating anything when you're reading a book. Not anything tangible the way he is referring to it. Code/ software is not tangible. If we're going to put absurd restrictions on what is and isn't an act of creation then we all may as well stop what we're doing now.
&gt; This is so wrong it's laughable. Maybe not every single person goes out of their way to make things as easy as possible, but in general people do try to make barriers of entry lower. These days things are a LOT easier for newcomers, with a vast wealth of book/online resources and better tooling, etc. If this is your position, then I can tell you have not been doing this long. Programmers unintentionally and sometimes intentionally make things more difficult. There have always been books, now there are bootcamps and videos, and they cover the basics quite well but not much beyond that. &gt; People are not rubbed the wrong way because JS is trying to make things easier. This is completely wrong and misses the entire litany of reasons why programmers tend to not like JS. It has little to do the language being easier to utilize. You are misunderstanding, people get annoyed at the audacity that someone could go through a 14 month bootcamp and be at the same level as recent comp sci grad. Nevertheless, veterans definitely try to put a wall up. If you haven't seen it then you aren't looking. &gt; Not related to JS. But yes, these places often take a lot of money from people, like $12k, and give an education comparable to teaching yourself online. All the while promising jobs that aren't always there (iirc a few bootcamps are getting in trouble now due to promising a high job rate). It has little to do with barrier of entry or being easier to use. You are taking this from the POV of someone trying to learn, I am making the point that someone already in the industry would look poorly on someone taking this course. I KNOW the course is something people could teach themselves and I don't really care if they advertise job placement. That is a completely different discussion and if you have evidence of a bootcamp intentionally misleading people you should make a post about it. &gt; Okay, wow. When toddlers are solving actual CS problems and building frameworks, tools, etc, or actually programming, let's talk again. Toddlers aren't developing complex systems, distributing code, building unix systems, etc. Code A Piller is not programming. Again you are putting up a wall. Let's go right to the core of this one, teaching kids and really babies to program, is more about teaching someone to solve problems in a structured way. Just like with any fundamental skill, learning this very young is going to embed it in the way a person thinks. Watching a 4 year old program a robot to avoid an obstacle is amazing. I know your first thought is bullshit, then to diminish it, as you have done, and I know why you would think those things. You are thinking "fuck if they can do that at 4, I am going to be useless one day." Let me assure you, with the current attitude you have, you making that an absolute certainty. **Note: I want to move the conversation forward, so if you just wanna disagree for the sake of disagreeing go to /r/politics. Otherwise I am going to again assume you are disagreeing and don't understand why, which would indicate to me some sort of insecurity of fear.**
Nest is awesome indeed, its the best framework i have not used yet, Strapi's coming on strong thought. Wonder if you can use it with rethinkDb. 
Just created a JavaScript intro to QooxDoo
Why do you use webrtc and what are the benefits ? How do you make sure everything stays in sync ? Tips &gt; ```if (this.x - tank.width/2 + moveX &gt;= 0 &amp;&amp; this.x + tank.width/2 + moveX &lt;= arena.width) {this.x += moveX;}``` you can use a combination of Math.min and Math.max for linear clamping, it will work for both forward and back ward movement and will be more accurate ``` this.x += moveX ; this.x = Math.max( 0 + tank.width/2, Math.min( arena.width - tank.width/2, this.x)); ``` &gt; ```if (this.angleGun &gt; Math.PI) {this.angleGun -= (2 * Math.PI);}``` you can use `%` for rotational clamping, &gt; `time.now = Date.now();` you can use the first argument of frames to get the time (relative), provided by requestAnimationFrame 
&gt;But by input, I assume he means he isn't getting anything out of it. You're assuming wrong. He is saying that by CONSUMING a book, he is not CREATING anything. It's as simple as that. Read the damn article before you comment on what people say, eh? Crazy idea!
Doesn't matter if it is hard or easy. The central theme is very true. You are a good programmer when you realize that you will never know enough to sit back and rest, that learning is a life-long occupation. That learning is something you love. 
You know, those downvotes feel strangely affirming.
If you're coding correctly, you're reading 10x more than writing. Your disability is protected by law. The law will be completed with at any company one would want to work for. You should be fine. If you're looking for a job, pm me. I'll refer you to the company I love working for. Can't promise a job, but can at least get you in the system.
One of my bower packages for example is this: https://github.com/diosney/angular-bootstrap-datetimepicker-directive It doesnt have package.json and doesn't expose any of the functions if I understood properly. So how can I import this kind of library with webpack?
This is beautiful. 
Really cool, although it would be nice if you had better physics for moving up/down, instead of it just immediately popping there.
Js isnt programming. #taunt #huehue #js programmer here
You can set the style manually with [set style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style). Or you can predefine classes with the desired background color and swap the css classes by modifying the [class list](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList). Or if you are only targeting evergreen browsers you can use [css variables](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).
dont worry about it the idea is to write less code
Maybe you'd like DHTML. Just say HTTP, why the fuck do you need a word for everything.
Slow and steady wins the race. At work you will stare at problem to solve for extensive amount of time. Its not typing speed but problem solving that is important about this job. Just do not apply for junior positions in outsourcing software houses since there they might need mules to do extensive amount of relatively easy and repetetive tasks. Always ask if you will work directly for the company that owns the product that you will work at. Also money is better.
I really enjoy that feature as well. I know codrops has done some interesting stuff with it. 
Maybe I am assuming wrong. I would never have the arrogance to state with certainty what the author is thinking. He clearly criticises consumption in so much that it did not generate output, I would consider original thought output, even if it isn't transcribed. I did read the article, and your definitions of 'creation' are vague. My point is simply that the medium is not really the issue, the approach is. You can just as easily 'create' when programming while not actually producing anything of value or at all original, the inverse can also be true of consumption. The distinctions are important but you refuse to recognise them. You also went on to imply that programming results in the creation of something that is tangible which is incorrect (I challenged this but you didn't respond to it). Tangible is something you can touch. Perhaps you prefer the definition of tangible that equates tangibility to something 'real'. I'd argue thoughts are real. So if the argument boils down to something visible or measurable or tangible being the only output of worth then, I reject that premise and am happy to continue to disagree with you.
&gt; Watching a 4 year old program a robot to avoid an obstacle is amazing. . I know your first thought is bullshit, then to diminish it, as you have done, and I know why you would think those things. You are thinking "fuck if they can do that at 4, I am going to be useless one day." I legitimately did not think any of those things. How about you stop projecting? Thanks. It's a very cool thing indeed, but logical/structured thinking != programming as we know it, although programming *involves* logical thinking. It looks like we have quite the different definition of "programming". A toddler is not doing what we are doing. Equating the two is simply absurd. I'm not "putting up a wall" for pointing out an absurd comparison. Also I never said it wasn't amazing, just that it was not programming. Because it is not. Secondly, we always need more good programmers, so good if they acquire logical/structured minds and then continue to programming. &gt; You are misunderstanding, people get annoyed at the audacity that someone could go through a 14 week bootcamp and be at the same level as recent comp sci grad. Nevertheless, veterans definitely try to put a wall up. If you haven't seen it then you aren't looking. This isn't limited to programming. Of course veterans of an industry are not necessarily going to be fond of programs that churn out people. Although to be fair, CS students aren't necessarily going to be good at [practical programming either](https://blog.codinghorror.com/why-cant-programmers-program/). But the bigger backlash is only more recent, years ago it was different. From what I've seen online and in real life, people are generally (not always) but generally working to improve things and make things more accessible / build better tooling. &gt; If this is your position, then I can tell you have not been doing this long. Programmers unintentionally and sometimes intentionally make things more difficult. There have always been books, now there are bootcamps and videos, and they cover the basics quite well but not much beyond that. I've been around to know that people in a variety of fields can unintentionally and sometimes intentionally make things more difficult. Look at librarians as an example. Nowadays things are much better. Which means people *are* working on resources, and have been so for a while. Talk about shifting goalposts, eh? Back in the day, you could find people on IRC, etc. Not as good as today, but the mere fact that it's much better today negates your point. &gt; Note: I want to move the conversation forward, so if you just wanna disagree for the sake of disagreeing go to /r/politics. Otherwise I am going to again assume you are disagreeing and don't understand why, which would indicate to me some sort of insecurity of fear. You're not moving anything forward, you're using straight up thought projection and pseudointellectual arguments to shut down mere criticisms/different opinions. Just because someone disagrees with you doesn't mean they have fear or whatever. Stop blanket assuming, it comes across as quite naive. Actually address what I'm saying rather than projecting what you think into my thoughts. Honestly, you need to work on your debating and conversational skills if you actually want to have a debate, not trying to shut down anything you don't like. 
If you think programming is hard, you have never lived in poverty. Dream of getting a job makes learning to code an easy affair ! 
You're digging pretty deep
Honestly typing fast isn't that much of a problem. Most of your time will be spent thinking of the code to make and finding out where you missed 1 letter (although automatic linting makes this super easy nowadays). What might be an issue is some working environments might be in an open office and it might be hard to dictate because it'll pick up other peoples conversations. But I guess the company will probably work with you to help you with your handicap, so that might be a non-issue.
Just an opinion. Nothing more.
I've been digging [Ramda](http://ramdajs.com/). If you're not use to functional programming concepts, it can take a bit to get used to. However, it's very powerful once you do. [Thinking in Ramda](http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/) was very helpful during the learning process.
Are you actually slower to code or just to type? I can type very fast, but that doesn't actually speed up my development. Since each file, function, line requires thought and often research it's not like I'm typing at full speed. To not sugar coat things, you will get skepticism. Maybe consider going to some coding challenges or other events to test your speed and have proof that this doesn't slow you down.
Great video. Take a look at this for building game timers. https://www.youtube.com/watch?v=JZbSTMNVkjc
I am not trying to shut you down, I am struggling to even understand if we are having the same conversation. Let's go back to the beginning: My position is **programming is not hard**. To this position I offered the fact that anyone can learn to program, even a child. You are saying it's not real programming, I am saying it is. If you offer a definition of what you think programming is, then we can debate that. Otherwise I am going to assume I am correct. If you want to debate a particular scenario then offer that up separately as well. I tried to pre-emptively address this with my second position **some programmers will often over-estimate the complexity of programming**. This could come out in a few ways: * Discouraging others * Failing to acknowledge that pointless barriers are in place (intentionally or unintentionally) * Trying to diminish the achievement of being self-taught or attending a bootcamp There are otherways but these are the most important because they go to my final point **these indicate some feeling of threat or insecurity**. We could spend hours talking about this but why would anyone actively try to dissuade someone from programming? My only explanation for this (and it applies everywhere) is the person feels threatened. You said I am projecting, I am most definitely not. I know I am not the smartest. This doesn't bother me. I know the next generation of programmers will displace me, I am actively trying to make this happen. I know AI will replace a lot of my job, I am actively trying to make this happen as well. None of this bothers me because I acknowledge it and I am planning to adapt.
I don’t wanna be that guy but I did something similar to this when first starting out a few months ago.. its a good exercise and is fairly simple.
I am very much in support of most of the positive comments on the thread, but I do want to mention one negative thing, but to conclude, I don't think it that your disability totally kills all your chance. It really depends on how `slow` is your `little slower`. While it's true that programming is not about typing speed, you can very well get along by typing slow and well thought out, but the cold reality is that your day-to-day work will involve lots of code editing, trying and failing, and that takes a lot of time. You're multiplying that time when you are typing slow, and that could impair your daily productivity. BUT! If you are a genius and you would never refactor, or edit your code, just write everything once and it'll JUST WORK then you'll be awesome, but then you're in the 0.01% of the programmers, and you should use your genius to superior things other than coding. 
If you're coding verbally, I believe that the largest factor will be accommodation space. You won't be able to feasibly have a cubicle, you'll need an office... which could be a big huge giant social headache, depending on the culture there. "That guy gets an office?! just because he can't type?!" etc etc. I wish you luck.
I think you are looking for the best way to manipulate a "data tree", not specifically JSON. Could you explain `appendNodeAfter` Im thinking that a flat tree expressed as an in memory mongodb like say nedb or loki would do the job; or specifically a data tree lib.
LPT: When you make a Reddit article about a programming library, add a link to the library in your post.
I once worked with a blind developer, not a little blind, 100% vision loss. He was one of my he best developers I’ve worked with. Programming manuals had to be scanned in for him and he required text-to-speech to “read” the code. Typing slowly will not hinder you at all. Many of my coworkers still hunt and peck to type. 
One thing that might be an issue to keep in mind is some companies have timed online assessments to get interviews. I flunked my most recent one because I wasn’t fast enough typing. So hopefully the company will be kind to you and accommodate you if they normally do these kinds of tests. 
I'm sad that this has been your experience with other programmers. I know the feeling and it's not a nice one. But I don't think that experience justifies such a large generalization as you were doing up there. I have indeed met people that think that way and intentionally shunt others away from programming, but I have met many others that are clearly determined to help, teach, and encourage others. Very intentionally determined to do so. And precisely _because_ they didn't have it easy. So, in a sense, I also feel you may be projecting your own experiences on to a too general conclusion. I won't claim that my anecdotal experience is more relevant than yours, of course, but that has to mean that your own experience is also anecdotal.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/20150808_205301_hdr.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
So I should test it in a new folder and just install react instead of CRA? 
Most places I've worked ask for estimates on how long it will take each developer to complete tasks. If I estimated two days and take two weeks, there's an issue. I would assume that if you estimate two days and complete the task in two days, there'd be no issue. Be realistic with your estimates and you should do well. :)
In addition to what a lot of others have said about typing speed not usually being the bottle neck, lots of places now practice pair programming. If you find someone with a good pair programming culture you can make use of their hands while you both think about the problem. And now I think about it pairing is proof of the “typing speed is not the bottle neck”. Typing speed is generally at the speed of a single person with most methods of pairing, but you have two brains to try and solve the real bottle neck which is thinking about the problem. 
* Discouraging others * Failing to acknowledge that pointless barriers are in place (intentionally or unintentionally) * Trying to diminish the achievement of being self-taught or attending a bootcamp Okay, show me where all these supposed people are. Show me where people are actively dissuading people from joining programming. Point out to me these "pointless barriers". Not acknowledging them unintentionally is quite a different from intentionally doing so. You cannot fault people for being unwitting about something that they genuinely don't know about. You know what? I think you're just making a strawman. You see a few examples of something, and then somehow extrapolate that to the entire community of programmers somehow. I'm sure there are examples of what you've listed, but I'm also sure that there's **orders of magnitudes** more examples of people being kind, welcoming, and encouraging new programmers. The very state of programming today staunchly proves your point wrong. It has never been as accessible, as easy to get into programming than right now. Go look up the illusion of frequency, also commonly referred to as the Baader-Meinhof effect. You see something, notice it, and then suddenly it seems like its everywhere. No, you're just looking for those moments and ignoring the multitude of times that it's not happening. Another cognitive bias is having negative things stick out much more than positive ones. Don't cherry pick examples to suit your argument. &gt; To this position I offered the fact that anyone can learn to program, even a child. You are saying it's not real programming, I am saying it is. If you offer a definition of what you think programming is, then we can debate that. Otherwise I am going to assume I am correct. Anyone can learn to do extremely basic things in programming. Programming in Scratch or extremely simple learning environments is * the whole point of the **guided** environment, and * nowhere near to actual programming. Programming in scratch is nowhere *near* the same as programming in C or Python to efficiently traverse graph nodes or implement complex algorithms. It is no more programming than a child driving one of those plastic vehicle toys is an actual race driver. This stuff is to teach a *logical* mindset, but it is not actual programming. By your mindset, a child playing with lego toys is basically doing civil engineering.. A child playing with a plastic cooking set is basically a professional chef. Ridiculous. Pointing this out is not mincing words, you're just holding a very wrong opinion of the term programming. &gt; We could spend hours talking about this but why would anyone actively try to dissuade someone from programming? Show me proof. 1 person doing this is not indicative of a community. Unless its something widespread, it's not something worth spending breath on, unless you are wanting to build a strawman for arguments. &gt; You said I am projecting, I am most definitely not. You literally stuffed words into my mouth and told me exactly what I supposedly "thought" about a video or link. *That* is projecting, sherlock. You already have an image in your head of what I think or who I am, so there's no point in even debating you. &gt; I know the next generation of programmers will displace me, There aren't nearly enough jobs to go around. The only person displacing you will be yourself by not learning applicable skillsets. You have a very distorted vision of programming if you think kids will somehow be able to grok the entire field of programming. They'll come up with new things and all that, but right now you're being kinda ageist. The smartest and most knowledgeable people I know are all older dudes, and programming would extremely suffer if we all just imagined new blood to be somehow magically better than years and decades of experience. Get a fucking grip on reality. It is good for teaching logic, but ultimately nothing like actual programming. By any reasonable definition of what programming is. By the same definition of programming used by the programmers to build the software powering your computer. To call that the same as some toddler piddling with curated, extremely limited instruction sets to achieve pre-orchestrated / pre-guided outcomes is so. fucking. ridiculous. I don't know how you can say that with a straight face. 
Done! 👍
Hi, I don't always work with JavaScript and occasionally need a refresher and I almost always turn to Eloquent JavaScript, http://eloquentjavascript.net/ I think Mozilla Developer Network has some great info too, https://developer.mozilla.org/en-US/docs/Web/JavaScript Hope these are of benefit.
A few books I recommend, by level: https://glebbahmutov.com/blog/javascript-books/
Typing speed is among the least important/relevant qualities of a developer. I honestly don't even care how fast someone types. I think it's more relevant how loud you must talk while dictating. Try to be quiet in an open office environment. 
Try Kyle Simpson's courses I have read his book series You Don't Know JS and they are very good even for somebody with quite a bit of js knowledge. He has a free week of courses at Front End Masters (this week only apparently): https://frontendmasters.com/teachers/kyle-simpson/ Just to be clear I am not associated with that site in any way and have not used any of their materials so can not comment on their quality or suitability. All I know is that his books are well worth reading for all skill levels.
Wait what else would I uses besides my own experience to form an opinion? There's not really any data I know of on the subject. Also, I really don't even care about qualifications, this is reddit and you are entitled to your opinion. My experience with programmers has been varied. I never said ALL programmers were a certain way, you drew that conclusion, and I don't think I ever even implied it. If I had to take a guess I think maybe people fall in the middle, some are positive and some are negative. I consider myself one of the positive people who try to encourage and teach and mentor. You are welcome to review my post history to confirm this. I don't really consider it sad or anything that there are negative people, I know they are there, I feel like I understand why they are that way and I just accept it. I do acknowledge that almost universally those negative people will try to over-estimate the complexities of programming.
It's from an online class I'm that that doesn't have the best help available. 
Read this entire article: https://en.wikipedia.org/wiki/ASCII
Never heard of this but will do! Thank you for the tip
Haha maybe i worded the question wrong then because that is what i meant to ask. When people start playing the game, it starts to go crazy. Never heard of debounce before but searching that up now. Thanks!
[removed]
Where da flappy dunk JS doe?
I can see you are getting pretty emotional about this and it is coming out in a very toxic way. I am just gonna say that you are actually agreeing with me in a way. I said programming is easy, you said: &gt; Anyone can learn to do extremely basic things in programming. &gt;It has never been as accessible, as easy to get into programming than right now. I said "some programmers will often over-estimate the complexity of programming.", you said: &gt; you are insulting an entire complex, intricate craft &gt; Go read a history book on computers and the modern history of linux. I am saying you feel threatened, you deny it, but then you respond only emotionally and actually try to attack me and not the points. Finally, you are asking for proof and I am pointing back at you. You are the example of the type of person I am describing. I am not saying you are bad, good, right or wrong, but you do exist, and you are exactly the type of person I had in mind when I made my original post. Not to beat a dead horse, but the positive person you are talking about is me. I try to help people, I mentor, I develop tools to help others, I train others, I write guides and books and blog posts, I encourage those around me and I do not try to inflate my own sense of worth by putting others down.
/u/brett84c seriously look at these courses this is what I was going to recommend. Kyle Simpson is the man. Normally this site is 40/month so I’d take advantage of this free week. I would definitely still buy a monthly membership.
Did they change this so that click events happen instantly on webpages? I feel like click events are instant in mobile Chrome, now. Seems like the old 300 ms delay issue magically disappeared.
You didn't say "some programmers". I also didn't say you did. But you said: &gt; for the most part programmers do not intentionally make it easy for the next person You have also, a number of times, referred to "Programmers" in general, without any qualification. And that is a wide generalization. That's the only thing I'm saying, that you made too wide a generalization. Maybe inadvertently.
I looked through your code and it seems like every time a user clicks, you set a timeout to run 1000/3 milliseconds (kind of arbitrary but i digress). I think this is a majority of where that craziness comes from. In my limited knowledge of how javascript works, I believe every time you do this, it takes a snapshot of the execution context for the closure that runs Game.earnGems(). Not sure how much memory and/or space that uses with regards to your app, nor am I sure how much this actually matters (hopefully someone smarter than me can explain it better) but if I'm correct then you're basically hogging a lot of resources, which causes the fans to go into overdrive. Maybe try not using the timeout and see if that improves things?
I'm sure you're comfortable with the tools you already have and use, but have you seen [this video](https://www.youtube.com/watch?v=8SkdfdXWYaI)?
The beard is too majestic for Javascript. 
it *does* work as /u/Oscar_Mild intended (check out the usage examples), it's just that in addition to reinventing `document.querySelectorAll()` he's used the opposite rules with '#' prefixing tag names instead of ids, which is pretty silly, though a great way to infuriate anyone who has to work with that code.
I did mean some. I think most people acknowledge that these toxic people exist. I wouldn't say that its even a large group, I would say that they do have a big impact though. So while I was not trying to generalize about all programmers, they do cast a long shadow. I think almost everyone has a story about one. I have been in consulting for a while so I encounter these people more often. Anyways, the only reason I even got on to this subject was because whenever there is a discussion about programming being easy/hard, it always attracts them, I don't know if they even realize the negative impact they are having. Or at least I think its negative, but I also think I am on the other side of the spectrum.
WebRTC is UDP/TCP. Websocket is only TCP. What's the best way to check for a collision between a bullet and a tank?
Would you recommend this over Udemy courses?
After doing some minor research, I found this: https://stackoverflow.com/questions/38276583/how-many-concurrent-settimeouts-before-performance-issues One of the comments to the responses suggested instead of running an anonymous function in the setTimeout, create a separate named function and pass that in instead to reduce the amount of memory allocated. However, I still think removing the timeout completely will probably show the best improvement. Is there a specific reason you added the timeout? And just out of curiosity, what was your reasoning behind 1000/3 for the timing?
Got a link for that FlappyBird React video?
`npm install flappyjs`
You're right. My bad.
That will make the tutorial complicated. and longer. but still I will make another tutorial
When JFK said, "We choose to goto the moon and do the other things not because they're easy but because they're hard!" By "other things" he meant programming.
Https://javascript.info
+1. Typing speed is largely irrelevant. The use of efficiency tools like autocorrect and jump-to-keyword probably don't have great accessibility support, so you might lose some efficiency there. Definitely be proactive in explaining your situation, I think many employers would see it as an impressive quality rather than one that would hold you back. "This person overcame a disability that prevents them from typing and became a programmer? Wow I'm sure their other attributes far outweigh losses in typing speed."
I wonder if these might be regulated to require accessibility support. 
&gt; Because it's not important. I disagree. &gt; By the way, you can't mark parameters as const. Is this a big issue for you? No, because I can do: function foo() { const [a, b, c] = arguments; } 
Hoisting. https://www.google.com/search?q=javascript+hoisting&amp;oq=javascript+hoisting&amp;aqs=chrome..69i57.1899j0j7&amp;sourceid=chrome&amp;ie=UTF-8 
I wish it was just a joke... I'm not against using libraries, it would be stupid not to, but things like this just...
I prefer Express for servers.
Good point. Updated.
Funny and very true, but the phrase "How it actually looks like" sends chills down my spine. (Both are pretty bad, actually.)
Check out [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/). First-class functions are one of the greatest features of JavaScript, but most developers haven't tapped into that potential yet. Unlike most literature around FP, the guide is mostly short and practical examples that are easy to follow, with very little theory or jargon. You'll pick up things that help you write far more declarative, testable and reusable code anywhere, without trying to force you into a strict functional paradigm. A lot of it you can do right out of the box without any libraries, but you'll definitely find [Ramda](http://ramdajs.com/docs/) or [Lodash/fp](https://gist.github.com/jfmengels/6b973b69c491375117dc) add convenience.
You have to use this.a in first log to display 'a'. This is called hoisting in javascript. Global scope variables can't be accessed directly in other scopes. Read about scopes and hoisting in js.
It's in my post. Just in case I cocked it up here it is: [Link](https://mva.microsoft.com/en-us/training-courses/creating-flappy-bird-using-reactjs-18124?l=zyfw7QaXE_7706218965)
Yeah open office environments are a hurdle i've been thinking about as well. I don't think they are an option honestly. It's not that I talk loudly but I talk all the time, and use some words very frequently that would probably drive people crazy. For example, everytime I click the mouse, I say "zip", which makes the computer click for me. it has become fully auto for me, but would probably be very annoying to people in the same office.
They most likely try to appeal to people who know jack shit about programming and are literally promoting React.js. Because language itself is "too hard" to use... Such thing is both good and bad, more people can get interested in programming, but... I've seen some shit, and it's safe to assume that some people might start thinking that programming, or well, development, as often times we just tend to call ourselves developers, itself isn't creating anything new, it's just using what's already here. It's okay though, some programmers can show people that it's trivial enough without Reacts and Angulars, and while programming indeed might not be easy, flappy bird is quite trivial and intuitive to make.
The imports-loader would take care of it, just supply the `angular` namespace. You can read out of bower as always, you could even resolve bower - there are plugins for it. Or look for packages that haven't been abandoned. The datepicker saw the last update years ago. There must be a trillion of up to date components for this.
good point about it picking up surrounding sounds. I had only thought about my dictation being a disturbance to others. I'll probably need some sort of space to myself, this will probably a problem for some companies. But I think there must be companies that see possibilities as well. Considering I don't care what the space would be(how small/whatever) as long as it is quiet and I don't disturb others.
Oh brill thanks, I must not have been looking hard enough!
It's the typing only. Good idea about the challenges, might consider that! :)
won't be looking for a job untill 6 months or so. Really appreciate the offer though.
You might end up faster than average, then you can flaunt that in interviews. Good luck!
&gt;I began to learn how to code using JavaScript four months ago So why the fuck are you writing your 2nd article about programming, given that you've barely started? &gt;Sure, I was generating plenty of output in my job as a journalist Oh.
javascript ✔ code bootcamp ✔ medium ✔ Status: Guru
Cool, looking forward to it
Looking to try and mine some bitcoin, huh? Well, I won't help you...
[It's mentioned](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#With_let_and_const). It's just new (-ish). The [Rauschmayer books](http://exploringjs.com/es6.html) are good for discovering other new (-ish) features.
Excellent :D
I can highly recommend immutable js. Especially for the “find and update” case. It might be tricky at the start, but once it sticks you’ll wish it is there every time you have to deal with large or complex json trees. 
If you haven’t already take a gander at the You Don’t Know JS series by Kyle Simpson. I’ll admit I’m not a JavaScript expert by any means, but he makes it a point to peel back the layers to help you understand how and why things work the way they do. https://github.com/getify/You-Dont-Know-JS
I don't trust people who spend more time typing than thinking. I would say being a slow typer is only really a problem if it takes you longer to get down your thoughts somewhere (either in code, text notes, or whiteboard) than it does to forget what you thought of.
Just discovered the site right now. Can't vouch for the course content because I haven't tried them, but they're taught by real aces of JavaScript (Kyle Simpson, Douglas Crockford, etc.) There are some good courses on Udemy, but the average instructors for this look much better I'd say...
They may have, but there’s a way around that by applying `touch-action: manipulation` to the element. 
Typing is not the difficult part. Solving the problem and figuring out _what_ to type is the hard part. If you can do that you should be fine.
Did you know you can also label it? const a = 42; const b = 12; myLabel: { const a = 24; console.log(a); //24 console.log(b); //12 } console.log(a); //42 And then break out of it by name? const a = 42; const b = 12; myLabel: { const a = 24; console.log(a); //24 break myLabel; console.log(b); // NOPE! } console.log(a); //42
Depending on what you are doing you may find normalising the data with something like normalizr makes things much easier to work with. 
Well it's true that you can make it complex by making complex requirements. For instance you could make the requirements that the program has to solve a puzzle, and then the programming is at least as hard as solving the puzzle. But if the puzzle has been solved before and there's just no sensible interface to get the code to solve it again, then we're back in the hell of our own making.
Watch out for "coding tests" that some companies give. That's about the only situation you're against the clock with real code. Any other interview will be verbal. Even whiteboard sessions, all they care about is how you walk through the problem. Personally I think someone like you would be a tremendous benefit. So many people have difficultly verbally explaining code. As others have said, if you're US based your disability is protected by law.
Yeah, the wording was terrible but I didn't feel like digging to find a correct one.
Out of curiosity, what is the type of myLabel defined as? I'm on mobile, or I'd check myself.
The `&lt;canvas&gt;` element, as an HTML element, can be resized with regular CSS. But that will just set the maximum number of actual on-screen pixels your `&lt;canvas&gt;` can take up, width-wise and height-wise. The `&lt;canvas&gt;` *also* has a `width` and `height` property that establish its own coordinate system. Note that these do not have to correspond to real pixels at all - you could have it be 100px by 100px but have its coordinates be 1000 x 1000, or even 100 x 200. (Obviously, you'd get some weird distortions if the ratio isn't right, though!) Finally, the actual content within the `&lt;canvas&gt;` is drawn there, generally, by javascript. So unless you also edit the game's JS, it will continue to draw stuff at the coordinates it thinks are set, even if you've changed them. In other words, if you double the `&lt;canvas&gt;` width, the script may not realize that, and could continue to draw things at the original dimensions... so you might just end up creating empty space.
Can someone give a scenario where this would be the preferred method to solve something?
A label isn't a variable, so no type.
Knowing how things work is inherently the bottleneck. you can shave days off just by knowing a common pitfall. that said, it's possible it'll take you longer to get to common pitfalls. but don't let this deter you.. just read more would be my advice. read all the time. 
Sadly, most of the programmers I know rely heavily on libraries or on frameworks on stuff which I think they can actually do it themselves, and when it's not working the way they want it to be, they move on and find another ... Or approach me and ask for help. I'm in no position that I'm gonna say that I am an "expert" but it's safe for me to say that I had a better understanding of javascript than most of my colleauges. It's just sad watching them jumping right into hypetrains when a new update or new libraries/framework comes out without a better understanding what a simple object can do in js. Thanks for sharing man! Appreciate it!
Because it acts as if the var declaration was at the beginning of the function. Weird behavior. BTW if you've only learned JavaScript you might not know that JS is unusually quirky like that, like it's not just that programming generally is complicated and weird, JS particularly is full of unnecessary quirky useless little complications.
Because of hoisting, your code... var a = "a"; function b(){ console.log(a); var a = "a1"; console.log(a); } b(); ...essentially becomes this: var a = "a"; function b(){ var a console.log(a); a = "a1"; console.log(a); } b(); Within `b()`, you're declaring a new var `a`, which gets hoisted to the top of the scope. So the global `a` never gets a chance - a new variable with the same name is created, but it's not set to anything until after the first `console.log(a)`, which is why that one returns `undefined`. On the other hand, if you did it *without* re-declaring `var a` inside the function, then `a` would refer to the same global variable both times, so you would get what you were probably expecting: var a = "a"; function b(){ console.log(a); a = "a1"; console.log(a); } b(); // a // a1
I did know about the labels, but did not know that you can label it like this. Thanks!
Thanks! I will should definitely check it out!
Thanks, i should definitely check it out, especially "ES6 &amp; Beyond" part. I think there should be some more cool stuff, beyond stuff that is mentioned in cheat sheets.
&gt; I love what JS allows people to do. It's relationship with the DOM helps illustrate that even trivial things can quickly become complicated ... This is really an example of how programming can go wrong. There is so much cruft of yore, and backwards compatibility concerns, that the DOM is horrible to work with. JavaScript is born out of this and has some disgusting warts too. It's no wonder something trivial is complicated in web browers. If you haven't yet, write applications for other platforms (iOS, Android, Windows, QT, etc). Things are much more well organized, usually well defined, and just plain sane.
This was likely written by a non-native speaker, as that construction is common in other languages.
This is one of the main reasons programmers call web developers monkeys and front-end development a monkeywork. As monkeys can be trained to do a specific task, yet change something and they are clueless on what to do. It's quite sad actually how people don't try to understand something but rather learn how to use it for specific cases... Programming languages are more than tool to solve problems. And frameworks are merely boilerplate which everyone gets bored of rewritting all the time, not something which does all the job for you. I don't know if you missclicked or meant to reply specifically, but it's relevant either way. I'm glad that not everyone is clueless on what they are doing and want to actually understand things, not just how to use them, I am not even close to being a person you could actually call a programmer either, but sometimes people around you just make you look better than you actually are...
More than you could know. Udemy is littered with garbage. Whereas front end masters only has very very good content because it cost so much money. I was lucky enough to take classes there because my company paid for it.
ahh.. worth a try ay ;)
magic.
I've done a little canvas work... and I mean very little, like I made a thing that simulated a starfield with individually spawned stars in an array that appeared off one screen side and moved across the canvas to the other, where they despawned, and I also made a map thing for a client that would put pins in a map of Europe representing different filming locations, with links to the videos popping up on mouseover... But that was a long time ago and nothing since, but I suspected something like your answer was going to be THE answer. "The canvas render is actually abstracted from the nuts and bolts html it sits on, so no dice probably." That about right?
Apparently Three and create-js and a bunch of other stuff
For the downvoters, if there is a more appropriate place to post this, please let me know!
UTC was derived from UT1 to match Earth's rotation as far as I know. Meaning that there exist those wierd things like leap seconds. UTC 2016-12-31 23:59:60 existed. Number of miliseconds between 2016-12-31 23:59:59 and 2017-01-01 00:00:00 was 2000 in UTC, JS shows 1000. So the interval does not represent real UTC interval, but more of a real time elapsed. I am confused.
Shader code. Check this: https://www.shadertoy.com/
It be boring watching someone program for several hours?
I know it's been around for a while, but not everyone knows about this awesome thing.
Thank you guys. I'll skip the MacBook for now.
If you need to break out of a nested loop. For example, outside: for (let list of lists) { for (let item of list) { if (item === 3) { continue outside } console.log(item) } } If an item is 3 it won't iterate through any other items in that list. 
It's very uncommon to use a [block statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block) on its own. However, block statements are used extensively with things like loops and conditionals. Consider this: for (const item of items) { const temporaryValue = item.someProperty; doSomethingWith(temporaryValue); } console.log(temporaryValue); // undefined The for loop has its own `temporaryValue` declaration inside of its block scope, which is accessible only from within the block.
So long as you don't use "var", then a simple block could replace an IIFE.
Since you asked no sugar coat. Writing speed (typing or dictating -- does not matter) is important. Long but really good rant by Steve Yegge on why it is important: [http://steve-yegge.blogspot.lt/2008/09/programmings-dirtiest-little-secret.html!](http://steve-yegge.blogspot.lt/2008/09/programmings-dirtiest-little-secret.html) He uses word "typing" a lot. But what he really means is "producing text". Though, by dictating you probably can achieve above average writing speed. I mean way above average. So, for sure start applying for jobs.
Super cool man!! thanks a lot! Makes me think I can build stuff too.
Without looking under the hood, this looks a lot like a webgl fragment shader that's being fed two videos and a mouse position.
can we "goto" it?
nice to hear that.
I have MS and tremors in my hands which can get quite bad. On a good day, I type maybe 10 WPM. If you have good problem solving skills, you should be OK. Many times, hunting down a JS error is 90% of the battle, and coding is 10%. I have been a software engineer for over ten years, and my disability affects the emails I have to send more than my coding. I'm also a bit self conscious when screen sharing because of my tremors.
Thank you for sharing that. To me, you're an inspiration :)
What motive would they have for “promoting” React? Also, even if they were why does that translate into them saying JavaScript is too hard on its own?
[removed]
In general, it's used in calculations with temporary variables involved: { const a = 2 * Math.PI; const b = 3 ** 2 - a; var x = f(a, b * a); } 1. The introduced variables may shadow outer ones, so you don't have to care how to name them. 2. `a` and `b` go out of scope after the calculation (so they really are "temporary") The result is stored in `x`. `x` lives longer than the scope as `var`s are function scoped and not block scoped. Today's style guides discourage the use of `var`s (prefering `let` &amp; `const`). So you are stuck with this: let x; { const a = 2 * Math.PI; const b = 3 ** 2 - a; x = f(a, b * a); } See: Even if you wanted to declare `x` as a `const`, you cant as `const` has to be initialized. If you follow you intuition, you'd just put the curly braces behind the assignment operator, like this: const x = { // ... } Unfortunately, currently there only exists a block **statement** and not a block **expression** and above code assigns an **object value** to `x` as curly braces `{}` in the context of expressions are **object literals**. That's a **design issue** in my opinion. As you can tell from this example, it is a real pain to apply this pattern in JavaScript. There is a [stage 1 proposal](https://github.com/tc39/proposal-do-expressions) for block expressions called "do expressions" which looks like the following: const x = do { const a = 2 * Math.PI; const b = 3 ** 2 - a; f(a, b * a); } Somewhat back to your actual question: This pattern (temporary bindings) is heavily used in functional programming in form of `let in` bindings (Haskell here): let x = let a = 2 * pi in let b = 3 ^ 2 - a in f a (b * a) In rust, the block (expression) statement uses the same syntax as the block expression: let x = { let a = 2.0 * std::f64::consts::PI; let b = 3f64.powi(2) - a; f(a, b * a) }
&gt; Google remove functionality to *improve* Internet. Shit's getting infuriating recently across all Google products. I'm in a fk Google position lately ;/
Yes. But only when you're directly above it.
i always wondered why javascript lacked `break {level}`. there's no technical limitation to adding it that ic an think of, yet it continues to be absent :/
at 23:39 you turned into a chipmunk
Coding Train has their coding challenges, which are more small bits you can use for an app but he talks through the process and how he's approaching the problem. Or Meth Meth Method has been coding a Mario clone in JS from scratch.
named labels don't require cascading edits when other levels are added or removed :/ -&gt; :) Of course, if that's a problem in your code, maybe you have bigger issues to deal with :) -&gt; :(
I don't know if getting hired at Google makes you super opinionated and not care about other people's usage or vice versa, but I'm seeing a lot of that Google,*the people that work at google* doing what it wants and their response to backlash is &gt;"not muh problem bruh" &gt;&gt;Sincerely, the majority market share holder of Internet related Tech
There are streams on Twitch for programming. I've streamed before and has small chats with viewers. Pretty fun experience. 
Thanks for pointing this out. I loved this in C++, though I don't think I could label scopes.
Everyone is different and some of us are wired to get something out of a task that a lot of people would see as being boring.. For example I really do not understand the fascination with e-sports. But watching someone code and do so with a sense of style and clear coding principals is like watching an artist at work for me. 
makes sense, but it's a weak argument for adding a trivial feature that exists in basically all programming languages and the lack of which is quite surprising.
I would consider myself between beginner and intermediate, and his course on Egghead.io for Functional Programming, I have absolutely no idea what is going on! I wish I could though, it looks awesome I will check this out for sure, thanks
You don't know js series is really good at explaining intermediate concepts. There are 6 different books I think so you can choose what you need to learn. 
[That has been gone for years](https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away)
Hello, I don't think you should worry. Like it was said, your disability should be protected under law. I think at one point I saw a stat that said the average developer writes very little code daily. The rest is design and admin stuff. I honestly think as a developer this will be a great strength for you. You'll be forced to be more thoughtful with your code, which I think will ultimately result in higher quality. Another thing that's embraced in many places is the idea of paired programming. I enjoy it in short bursts, and I think you may enjoy mixing it into your work. In terms of your worry about noise, honestly don't. There's a lot of noise in most offices. Unless you're screaming, I think it's on others to out on some headphones. Good luck to you.
Hello, I don't think you should worry. Like it was said, your disability should be protected under law. I think at one point I saw a stat that said the average developer writes very little code daily. The rest is design and admin stuff. I honestly think as a developer this will be a great strength for you. You'll be forced to be more thoughtful with your code, which I think will ultimately result in higher quality. Another thing that's embraced in many places is the idea of paired programming. I enjoy it in short bursts, and I think you may enjoy mixing it into your work. In terms of your worry about noise, honestly don't. There's a lot of noise in most offices. Unless you're screaming, I think it's on others to out on some headphones. Good luck to you.
You’re a troll. Calling programming easy is hands down one of the stupidest things I’ve seen on reddit. 
This is getting posted every week. https://static.ozairpatel.com/hewft.png
Didn't this just get posted last week?
Great video. You do a great job by visualizing exactly what the code is doing line by line. 
It will start sucking once you need to do big refractors which involve mindless button pushing. But IDEs can help with that. 
Its not just me then. Angry at them over their shitty app dev choices (messengers etc), the fact they track every god damn thing, the shittiness of their phone lineup (in the process of rma'ing a nexus 6p). I just have zero confidence in anything they do now. To the point where I groan when I hear they've acquired a product or company I like, because they'll likely just shut it down a year later and absorb the talent. Seeing it quite a bit on twitter, a lot of people moving off of Google platforms in favour of privacy focused, community driven services. 
„It’s easy to add“ is a weak argument for adding a feature. In this case, said feature easily leads to bugs and is easy to replace with something better, so there’s no point in adding it to a new language. Java is the same by the way.
hhhh :D
thanks
https://youtube.com/channel/UC8A0M0eDttdB11MHxX58vXQ
Oh thank you for your quick reply! I came up with an alternate way to do it as well if you'd like to see. only issue is firefox doesn't seem to like my code. https://a.uguu.se/xuTFdGaWzDGk_Elianscriptconverterfinal%21.html
Thank you for your detailed response! I will study this lol 
If you’re new to it, no, I’d keep with create-react-app so that you have something that works out of the box. This will let you focus on your content immediately. Just realize that, later (or much later, depending on what you want), you might want to `eject` and have more fine-grained control over your scripts (meta-tools) that configure and control the React process. 
Not sure what refractors are. But I'm really into automation, I don't "believe" in mindless button pushing. If that's the case then there has to be a way to automate that sh't right? Who knows maybe I can find ways to automate those to a substantial degree. Or maybe not and it will just suck :P
Fun Fun Function, in particular the series on functional programming: https://www.youtube.com/watch?v=BMUiFMZr7vk&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84
This was a really informative post, thanks. Out of interest, I come from a JS/PHP background and am interested in learning Rust, would you recommend any intermediate steps/languages before actually learning Rust itself? I find myself very lost very quickly.
Java, Kotlin, Swift - all support named labels for breaking. As far as I know, Ruby, Python and C variants have neither labeled nor numeric breaks. PHP has numeric, but I hope that's not what you're using to quantify "basically all programming languages" ;)
Thanks! Much appreciated.
It's ok to break user space!
his courses are also on pluralsight which I think is still free for 3 months with a free visual studio essentials signup
I just added velocity and gravity variables. On button press set `velocity = -10`, the set `position.y += velocity`. Each draw() loop `if (velocity &lt; 0) velocity += gravity`. Also set it back to zero when we're done `if (velocity &gt; 0) velocity = 0`. This gives you a nice smooth jumping animation.
It's almost always possible to automate, but a lot of the time doing it the "dumb" way is faster. https://xkcd.com/1319/
I started with it a few weeks ago. Really liking it once I figured out how to use anime.remove() to repeat an animation. Also that it doesn’t work with jQuery objects. I couldn’t see these two things mentioned in the docs or I just missed them. 
Had you used the browser console, you'd have seen error is here: event.preventDefault() `event` is not defined. Chrome emulates Microsoft and gives you an event object. Firefox strictly follows the standard. You'll want to read up event handlers. In particular `addEventHandler` will be your friend, instead of in-lining events.
Not sure if there is a way through the remote generated methods but there is "updateAll" and "destroyAll" in PersistedModel, you can create your own endpoint and use them. https://apidocs.strongloop.com/loopback/#persistedmodel-destroyall
what you want to do is create a &lt;form&gt; element with a text &lt;input&gt; and a &lt;button&gt;. If a button is the last element on a form it will submit the form automatically when clicked. Next create a variable for the form (you’ll probably use an id) When a form is submitted it will cause a page refresh. To avoid this you want to use preventDefault() in event listener function and then append your message to the page. Let me know if you need more help. 
Dope! Solid article. I’m just learning this stuff so the simplicity of this example is much appreciated. Also the first ML application I’ve seen on jsfiddle. 
Yuh-huh, can too ^^^^kinda, ^^^^not ^^^^really. Here's a stupid, useless example: function doAThing(num) { console.log(`Thing number ${num}`); } let num = 0; labeledBlock: do { if (num &gt;= 100) { break labeledBlock } ++num; if (num % 2 === 0) { continue labeledBlock; } doAThing(num); } while(num &lt; 10000); It prints the odd numbers between 0 and 100! Exciting stuff!
Pretty cool, right? You know. You might want to start learning about the HTMLCanvasElement! Check out this codepen which is utilizing the same technology and tinker around all you want. It would be great experience for you to have! https://codepen.io/lukasvait/pen/Evbeo
I am not expert on collision detection but here is a link https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection 
I did see that and I was actually just looking into that as I was waiting for someone to reply (you). What would the event be? thats what im confused about... Would it be whats inside one of the functions?
Can but not necessarily will. When people ask what language to start with I never use JS specifically because of the DOM. Beginners tend to lack the knowledge to make sound design decisions when manipulating the DOM. It's not their fault - there are a million small things to consider.
Not bad but I think you need a step or two between setting your context and your user resolver, showing how to map a resolve function to a query/type. I suspect that most people that are familiar enough with GraphQL to get that jump that just occurred are probably familiar with JWTs and authorizing via context.
Speed is a factor in our interview exams in that people who aren't familiar with the libraries we're looking for experience in (Angular/React) typically don't finish in time. This is because they're hitting avoidable road blocks or having to google what should be simple things. If an interviewee didn't finish in time due to a disability but showed sufficient experience/skill they would not have that held against them.
I've only done a few `&lt;canvas&gt;` projects myself, but that was one of the first things I had to wrap my head around. Luckily, I'd done some `&lt;svg&gt;` stuff before, and that aspect is very similar.
On mobile I have no idea what is going on. The screen seems to randomly change. Between two images. Need to look at it on desktop. 
Event handler functions get passed an event object when they get called, meaning you can do something like this: document.querySelector('form').addEventListener('submit', (event) =&gt; { event.preventDefault(); console.log(event); // A bunch of data about the event }); to access that event data. In your case, you can actually just pass the event in when you call the run function on your form: `&lt;form onsubmit="run(event)"&gt;` and it *will* work, weirdly enough. I'd recommend using an event handler though, like OP was talking about.
I don't know how to make my code say "error" to the wrong input 
These kind of videos are becoming harder and harder to find, but more and more useful. Frameworks aren’t worth jack without a solid fundamental knowledge of the language. 
I replaced the no-longer-working Dropbox back-end from version 1.0 to v 2.0 in my JavaScript, web based desktop on Saturday. http://www.softwaresamurai.org/2017/11/25/cloud-abstraction-layer/ I also created a intro video to Qooxdoo, though that was Sunday ... https://www.youtube.com/watch?v=48qHRcNac3A 
lol on desktop my processor went nuts and it was really laggy. I'm talking like 90% utilization across all 8 threads.
To be frank, if you write code like this, you are very likely to be setting traps for code maintainers later on. While you may completely understand your usage, someone scanning code could easily update the wrong value and create a bug. Just because you can does not mean you should ever do this.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment Specifically the note under the Object Destructuring section: The ( .. ) around the assignment statement is required syntax when using object literal destructuring assignment without a declaration.
The day someone defines best use case for every programming language (including which language is best for learning to programme) will be a wonderful day - I imagine they will also become very rich and not give up that information easily. Anyone that believes programming is as trivial as baking a cake and following instructions is being mislead. 
To be fair, Google started out as a company using tech to solve problems. Google ushered search into a new era. Before I got into programming and reading blogs/forums, it didn't seem like Google was doing anything wrong. It was just data to enhance the user experience. That's what the average user is sold. That's why we gave them the monopoly. Want to get morning traffic updates? Share your home/work address and time you leave. Want curated news feeds? Share your interests. Want relevant recommendations on everything from cooking to music? Share some basic demographic information. These are all things that a smart system would need to be successful, so people go with it. And to be fair, Google does do a great job with what you give it. The problem is that they're propped up by their advertising revenue, and all the free stuff end users get is paid for with personal information. 
i don't understand why you couldn't do this in Java
Screen change was triggered by touch event for me.
Hmm I just tried that too but it doesn't do anything. The image keeps switching from a girl in a bathroom and a dude with a hat. I thought it was loading because there is a bar in the middle that looks like it could be a vertical loading bar, but it never moved. On wifi with 100gb down, so either I am missing something, the page is bugged, or it is taking way to long to load. 
this is why you should use const {a, b} = {a: 5,b: 98};
And, speaking for myself and a lot of people I talk to lately, in a "+1 Microsoft position". The world is truly upside down from 10 years ago. ---- ^(btw, while typing this message, I fatfingered the closing quote to be {"}. Just sayin.)
In case anyone is interested I grabbed the shaders from the page: [Vertex](https://pastebin.com/raw/6ZeXbU4w) [Fragment](https://pastebin.com/raw/qVMCAF1S)
Honestly, probably
that looks like the loading/intro screen. make sure you scroll down to start the video.
This is very cool! If you want to start learning how to code and create something like this, check this out: https://progate.com/
We talking about labels? I agree. Scopes I don't.
TBF this is more useful in a language like C++ with RAII so you can control the lifetime of an object's resources.
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!-- The Elian Script An Alternative Writing System Whose Properties Combine the Linearity of Spelling with the Free-Form Nature of Drawing This writing system was developed by C. C. Elian ====== This app was written by Ben Kraft under the "I kick ass" License. ====== --&gt; &lt;head&gt; &lt;link href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/jwAA/+cAAP/zAAD/+QAA//wAAP/+AAD/5gAA/+YAAP/+AAAB/gAAff4AAH2AAAB9/wAAff8AAH3/AAAB/wAA" rel="icon" type="image/x-icon" /&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Elian Script Converter&lt;/title&gt; &lt;style&gt; h1 { margin-top: 40px; margin-bottom: 70px; padding-top: 15px; padding-right: 30px; padding-left: 80px; text-align: center; text-decoration: underline; text-transform: uppercase; color: darkgrey; text-shadow: 1px 1px 2px white, 0 0 25px blue, 0 0 5px darkblue; } h3 { margin-left: 80px; margin-right: 15px; text-align: right; color: silver; text-shadow: 1px 1px 2px black, 0 0 25px blue; } pre { color: white; margin-left: 55px; text-shadow: 1px 1px 2px white, 0 0 25px blue, 0 0 5px darkblue; max-width: 85%; height: 81px; text-align: center; white-space: pre-wrap; word-spacing: 8px; word-wrap: break-word; border-style: inset; font-size: 40px; background: rgba(0, 0, 0, 0.3); padding-top: 14px; padding-left: 8px; } html { font-family: 'Palatino'; font-size: 22px; background-size: cover; } body { font-family: 'Palatino'; width: 75%; height: 100%; min-width: 900px; max-width: 100%; position: static; margin: 0 auto; background-image: url('https://i.pinimg.com/originals/46/0c/bd/460cbd085e34e1610880f1b34ec8e79e.png'); background-size: cover; } .lastResult { padding: 3px; color: black; } button { border: none; text-align: center; text-decoration: none; display: inline-block; font-size: 25px; font-family: 'Palatino'; margin-bottom: 7px; margin-top: 7px; padding: .25em; color: initial; } input:focus:-webkit-input-placeholder { color: transparent; } input:focus:-moz-placeholder { color: transparent; } input { margin-left: 80px; font-family: 'Palatino'; font-size: 25px; color: white; overflow: auto; max-width: 800px; margin-right: 80px; margin-left: 80px; resize: none; text-align: left; text-indent: 7px; background-color: white; border-style: inset; background: rgb(0, 139, 139); /* Fallback for older browsers without RGBA-support */ background: rgba(0, 139, 139, 0.3); } p { background-color: white; padding-left: 8px; margin-right: 200px; width: 275px; border-style: solid; border-width: 1px; position: center; } #container { display: block; margin: auto; height: 100%; width: 75%; height: 100%; min-width: 900px; max-width: 100%; position: static; margin: 0 auto; border-style: inset; background-image: url('https://i.imgur.com/iipgZmh.gif'); background-size: unset; } .buttonHome { width: 80%; margin: auto; } .toElian { left: 0%; position: relative; } .toEnglish { left: 33%; position: relative; } .clearButton { left: 66%; position: relative; } &lt;/style&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;h1&gt;Elian Script Converter&lt;/h1&gt; &lt;form&gt; &lt;input style="width:80%;height:45px;" id="in" placeholder="Type here:" /&gt; &lt;div class="buttonHome"&gt; &lt;button id="toElian" class="button toElian"&gt;Elian&lt;/button&gt; &lt;button id="toEnglish" class="button toEnglish"&gt;English&lt;/button&gt; &lt;button id="clearbutton" class="button clearButton"&gt;Clear&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;div&gt; &lt;hr style="margin: 40px; "&gt;&lt;/hr&gt; &lt;div id="preview"&gt; &lt;pre id="out"&gt;&lt;/pre&gt; &lt;/div&gt; &lt;h3 href="https://www.reddit.com/user/Mr--Night/.html"&gt; By: Mr--Night &lt;/h3&gt; &lt;/div&gt; &lt;script&gt; var textIn = document.getElementById("in") var textOut = document.getElementById("out") // First, let's go ahead and disable the form submit document.forms[0].addEventListener("submit", function (event) { event.preventDefault(); }); document.getElementById("toElian").addEventListener("click", () =&gt; { out.textContent = alien(textIn.value).join("") }); document.getElementById("toEnglish").addEventListener("click", () =&gt; { var englishText = english(textIn.value) out.textContent = english(textIn.value).join("") }); document.getElementById("clearbutton").addEventListener("click", () =&gt; { clear(); }); var charmap = { a: "ﬧ", b: "コ", c: "┘", d: "п", e: "ߛ", f: "ப", g: "厂", h: "ⵎ", i: "ட", j: "ᒣ", k: "ᓗ", l: "ᒧ", m: "ᒉ", n: "ᑭ", o: "ᘂ", p: "ᒥ", q: "ᓕ", r: "ᒪ", s: "ᒭ", t: "ᓘ", u: "ᒨ", v: "ᒕ", w: "ᑮ", x: "ᒎ", y: "ᓟ", z: "ᓛ", } function reverseCharmap(_charmap) { var keys = Object.keys(_charmap) var newmap = {} for (var key of keys) newmap[_charmap[key]] = key return newmap } function alien(text) { var letters = text.split("") var replacer = (ch) =&gt; { var replacement = charmap[ch.toLowerCase()] return replacement || ch } return letters.map(replacer) } function english(text) { var _charmap = reverseCharmap(charmap) var letters = [...text] var replacer = (ch) =&gt; { var replacement = _charmap[ch.toLowerCase()] return replacement || ch } return letters.map(replacer) } function clear() { document.getElementById('in').value = ""; document.getElementById('out').value = ""; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
Just pushed an update
Wow so many "below threshold" comments.
Same thing on mobile for me and scrolling doesn't work on mobile either. Seems odd to invest all that time and not consider proper mobile support.
It's an art site so I get only supporting desktop for the full experience, but ya they should have a fallback for mobile.
You know today I leared that it wasn't "The Ukraine", but in fact it was just "Ukraine"
Wow... I cannot believe I was so far off lol programming is harrrrd. This right here taught me a lot. Thank you very much :D I can't help but notice you also lined up my buttons. 10000 thank yous :P 
&gt; I don't understand how foo (apparently a variable) and foo() (apparently a function) became related. In the definition of `obj1` you see `foo: foo`. Since the right-hand side isn't in quotes, it's a reference to something that already exists -- and what exists and is named `foo` in that scope is the already defined function `foo` above, so `obj1.foo()` will just call the global `foo` function defined at the top. 
Couldn't get it to work on my phone, but it was a cool experience on desktop.
FYI this is made with WebGL, not the canvas API. They both use canvas elements, but are otherwise completely separate.
That's kinda what I figured, and I understand the mechanics there, but I'm lost on -- well, for lack of a better word -- the pedantics. I thought it would have come back as an undeclared variable error (what is that, some kind of `reference` error, right?) because isn't `foo()` discreet from `foo`? Regarding what happens there... is that some kind of fallback or coercion? I mean what js rule allows it to decide that the *value* in `foo:foo` is intended to be `foo()`?
You caught me on a good night when I had a little time free. I know that I often learn more from looking at good code than I do from studying a whole book. And yea, I figured you'd appreciate the help with the buttons. "Flexbox" or "Grid" based solutions would have also worked, but I can't do flexbox from memory and I was too lazy to look it up. You really weren't far off, but the use of in-line handlers (the javascript-in-HTML) is considered bad form, so I figured I'd give you a point in the right direction. (Your code worked on IE and Chrome because they create a `window.event` object, which is why `event` existed without being passed in. This carries over to how IE handled things in ancient days. Firefox sticks pretty much to the standard. Fortunately, IE10 and 11 also follow the new standard, so you can use `addEventListener` pretty much everywhere and you'll never have to worry about the horror of the old days.
&gt; because isn't foo() discreet from foo? Not in this case. In the definition of `obj1` you see `foo: foo` so, right there, that makes `obj1.foo` a *reference* to the existing `foo` -- which is the foo function defined above, so `obj1.foo` is a sort of "pointer" to that existing function. I'm not sure I can make this any more clear. &gt; What js rule allows it to decide that the value in foo:foo is intended to be foo() The rule is just that functions are first class objects. This means they can be referenced exactly like a variable or object or whatever else. `foo()` is an expression that *calls* the method *named* `foo`, understand? So say the function `foo` exists like in the example. You can then say something like `var a = foo` and `var b = foo()`. This will make `a` a reference to that foo function, while `b` is just the result of calling that function.
It's not really a secret. Const and Let (the new es6 features) create block scope, which is exactly why they were added when we already had var. It's mentioned almost every time the introduce the let identify but I haven't seen it much for the const identifier. Long story short people that were used to block scope wanted it in javascript because functional scope was annoying(?) for people who are only used to block scope. If can defeinitely shorten your code if that is what you are after or you genuinely need block scope.
&gt; This will make 'a' a reference to that foo function, while 'b' is just the result of calling that function. #BAM Got it. Fuck, mang... that's flexible AF. You are the man. Thanks for the explanation. I have no idea how I would use that, but I'm sure I'll find one. It looks really useful... ...actually, it sounds like it's *really* useful in terms of scoping. declaring, say, a `dice_roller()` in the global scope, and then tacking it on to anything that needs dice rolled in a more specific way. Yeah? 
You need to be careful running them through transpilers though, since `var` comes back and is no longer isolated. Usually the transpiler is smart enough to rename variables as necessary, but if it's not aware of all the variables (ex. global imports used elsewhere on the page, but not the current script) you could wind up clobbering something. It's a rare edge case, but something to keep in mind.
In general it's useful when you want to call things later, or be more dynamic. For example you can have a switch statement that is setting `obj1.foo` to any of a number of functions depending on the `case` statement you fall into, then later on calling `obj1.foo()` will call whatever function that was. It allows for much more dynamic programming -- I don't personally think of it in terms of scoping. One place I use it often is for things like onclick handlers, because you can find an element or dynamically create one, then say `elem.onclick = foo;` and that will cause the function `foo` -- conceptually, this would mean that *at that moment of the click*, `foo()` is executed. If you just said `elem.onclick = foo();` then `foo` would be executed right then and the result handed to onclick -- which would probably just cause some error as soon as the element was clicked.
You've ruined the magic for me with your matter-of-factness facts.
Redux reducer's switch statements. :\
this.a wouldn't work that way, no. Hoisting is why the console.log output undefined, but what you described isn't hoisting. Global variables and functions, if they aren't shadowed, can indeed be referenced inside function scopes, otherwise they'd be nearly pointless.
&gt; If you just said elem.onclick = foo(); then foo would be executed right then and the result handed to onclick -- which would probably just cause some error as soon as the element was clicked. Or roll a die (= I get your switch/case example. You want `foo()` to be available when you need it, and you can do that with this and be DRY. Also it's not inheritance. It's not setting properties or prototyping, but it's kinda similar, tho I can see how some could conflate them all.
Whoa that's cool. Probably has a few usability issues though.
I second Ramda. 
It might be, but lots of people wear headphones while they work, so if it's not overly loud it will probably drown out you're talking. I would just focus on being good. If someone is a good devwloper, it would really help to overlook the whole issue. A solid and competent coworker is always valued. 
I was under the impression Java was block scoped? 
Hi /u/Progate-LearnToCode, that's spamming. Please don't do that. Thank you!
Great video!
That looks pretty thorough :)
Essentially, the first time you call console.log(a) the only value you've assigned to a variable entitled "a" was in the global scope; however, it doesn't log that to the console because inside of your function b() there is a different scope in which you have declared another variable by the same name (otherwise known as shadowing). At the time you called console.log(a) there is no value assigned to the local variable a. The javascript engine knows that within your b function there is a variable a but again when you call console.log the first time no value has been set to it. Hoisting is a metaphor for the way the JavaScript engine reads your code. On it's first run through it goes and grabs all of the declarations you've made within the code. Then only afterwards while it is executing your code does it actually assign the values to your variables. TL;DR You haven't assigned a value to "a" at the time you logged it in the current scope and because it is named the same the engine doesn't look in the surrounding scope because it found what it was looking for.
Yep it's awesome! I use it for DOM animations in my Three / React powered game engine, it's sick. 
I was prompted to rotate my device, so they do support mobile browsers, just not yours. 
chill out. I was just replying to people saying it didn't. If it works on mobile devices that's cool. No need to be a dick.
Is this guy British
If you want JS secrets, read or watch anything by Kyle Simpson (author of the You Don't Know JS series). [Right now, you can even watch some of his courses for free.](https://frontendmasters.com/teachers/kyle-simpson/) (But only until Dec. 4th)
[Right now, you can watch some of his courses for free.](https://frontendmasters.com/teachers/kyle-simpson/) (But only until Dec. 4th).
It's supposed to be GPU (since it's webgl) so I think that implies something fucked up either due to your browser or your extensions or something. As a result it defaults to CPU processing which is super slow.
I’m about to graduate with a bachelors degree in computer science, and my friend works HR with this company. She says she can get me a job there. I had no idea they made stuff like this. I was really excited before, but now I’m over the moon!
Sorry, I didn't mean to come off aggressively.
My work laptop isn't exactly powerful. It may as well be a static image.
I just published [Basho](https://medium.com/p/2b1891c16ea9/) - A tool for automating shell commands using JavaScript. If you're shell handicapped like me, take a look.
Thanks for correcting. I got this wrong.
How exactly does that break anything? Give me an example of broken website or component affected by this change. I've recently implemented a feature detection for this scenario right when I saw the warnings in dev console and had no issues. 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Shells
Basho is not a new shell. It simple lets you mix JS expressions in the shell of your choice. 
I think Meteor is a bit of a waste of time for an application that might garner any real use. Their approach to moving data to the client lends itself to creating security and performance issues very early on in the apps lifetime, and scaling out of them can be really very complex. I'd go with the comment from /u/tuesdayrain - start with Express.js, it's tried and tested (and really great to use) and far less (negatively) opinionated about how to structure your application. Furthermore a lot of the SPA frameworks out there can be backed by Express too, so it's definitely a valuable skill to have.
Those people must not have tried to use OneDrive. That shit is infuriating...
The article is about the benefits to you of learning to program, because it's cerebral which is exercise for the brain. Who said anything about "all programming"? The point is that the fundamentals of programming are very simple. Take ingredients, combine (subroutine with 4 calls to CrackEgg() and Mix() between adding other ingrediedients ), set temperature and bake, wait x minutes, poll minutely to see if it's done. Remove when done. Execute all the cleanup code like turn off the cooker, let cake cool, eat cake etc. They are building blocks of reasoning about imperative code; execution order, loops, conditions. If you can't see the underlying cake baking program just by reading it, perhaps you need to revisit some introductions. Once you have the fundamentals, all other problems because different ways to reason about the fundamentals. The code might support imperative, functional and/or OO, on top of that we teach re-useable patterns. It's not easy to write a hospital imaging system, the flight computers on a fighter or a financial trading system from scratch, but with guidance from the team who did, our cake writer could become productive pretty quickly. The first thing they will learn is that all big problems are just lots of little problems glued together. And each of those problems is also just more problems huddled together for warmth. And what does "defining best use case for every programming language" have to do with anything? That is not how language development, i.e. the creation of new languages works. They all include trade offs for a dozen legitimate reasons. They almost always embrace generality otherwise you hamper the ingenuity of programmers trying to use it. 
Yeah nothing shows up for me on my Kindle, would be nice if they made it a bit more accessible
How come you make the draw function and then call it right afterwards?
Please OP do the needful
It's like magic! (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧
Very cool. If, like me, you had trouble getting it to work on a mac without a video card, use Safari. Chrome doesn't fully support WebGL (and the website erroneously says it's because you're out of date), and Firefox's support is buggy.
You already have been answered, but just in case... In the sub's [FAQ](https://www.reddit.com/r/javascript/wiki/faq) there's a link to an [explanation of this here in the subreddit](https://www.reddit.com/r/javascript/comments/j2j8b/the_this_keyword_is_extremely_simple_and_doesnt/) (be sure to read some of the comments for some extra bits).
It would be a nice addition to have a computer player / bot, to play against. You know, for when no one else is connected. That aside, the next game starts way too immediately after you win/lose a game. If I win, well, that's not too bad because I'm playing the winning move and I know I'm winning. But if my opponent wins, I don't even get enough time to see their last move. Bam, start new game. Not even a "You lost" message or anything. You need to either put some delay there or explicitly have the players click something to continue.
Someone sat down in front of a computer and pushed some keys.
I declared the function, and then I call the function once, and then the callback function "requestAnimationFrame(draw)" we do the rest
thanks :)
good point, don't use the frameworks if you don't have knowledge about the language first
That's not a very helpful comment, it isn't making me infuriated at all
Cool, thank you, I appreciate ! This is exactly why I wrote it. There is another JSFiddle that you can also find on the blog : http://jsfiddle.net/franpapers/9hnwLpm5/ This one was attached to a previous article, and it's about linear regression, still with an easy example!
&gt;They most likely try to appeal to people who know jack shit about programming and are literally promoting React.js. Your argument is that _Microsoft_ is shilling React? Seriously, just think about that for a second. &gt;It's okay though, some programmers can show people that it's trivial enough without Reacts and Angulars, and while programming indeed might not be easy, flappy bird is quite trivial and intuitive to make. Dude, you realize the entire point of this course is using a fun example to demonstrate what you can do with React, right? You're not a special snowflake for realizing React would be overkill for this in practice. What you're doing is basically the equivalent of shitting on a tutorial by saying "But I already have a to-do app!", but more condescending.
Some WebGL but the site takes over a minute just to load so .. EH.
Aye, that makes sense I suppose
just a heads up the "◆" char may cause issues for webpack builds
Take a look at TPL Dataflow library, it's in C# but maybe you can draw some inspiration from their block model. I haven't used it much lately, but, 2-3 years ago I used it to build the rendering pipeline of a pdf reader with cancellation, prioritization, pre-rendering.
So basically, shilling React, as in, showing what you can do with React, not with a programming language. Good that we come to agreement.
Looks like I have to start looking into webpack then. The only reason is that there might be multiple old packages and would require many rewrites on the app so we are sticking with the old stuff :/ Thanks though!
That\s not what flashy javascript gimmicks are for. they're designed to look good on the high-powered development machine they were built on and fuck everyone else.
The images change based on phone movement. You have to keep your phone almost completely still for it not to trigger the other image, it is a bit sensitive.
Neat, but very discouraging )= to the aspiring.
"High powered development machine" &gt;runs flawlessly on my 1.6Ghz duo-core Asus laptop with 1GB VRAM with a shitty graphics card from 2000's... We are sorry about your tomogatchi not rendering this properly.
Sorry dude but, a laptop is "high powered" compared to the average android handset on 3G
I tried to run it on IE9 and my PC exploded
Works fine on my phone
Thats amazing! Thank you! Btw. I'm looking for a tool to make a cursor that can "paint" opacity, which then fades out, to a layer - any tips for how to do that?
btw - the overlay, that changes and morphs - where is that from? How did they do it? I'm a bit of a novice, so please go deep if you have the time:)
Haha. But answered my question though :)
Thanks!
Load time is worth it though:)
Congrats on that! :) Who made it? I can't find that info. And what do you plan to work with after your degree? Do you understand webGL?
No.
Thanks for the chip in. I'm looking into that, and WebGL, and also Three.JS, but I'm still novice in all three. Btw. Anyone here know how I could make a cursor that can "paint" opacity to an overlay/overlaying layer? What would be the best tool to use for that? I've seen it done in Hennessys Mastered from chaos campaign!
Yes, please don't. If I wanted to watch commercials I'd buy a tv instead of asking people to share knowledge on Reddit. Thats why I come here - because there is exchange of non-com content and knowledge.
I've finished initial development of a JavaScript client for our open-source server. The server is designed for realtime and social games and apps. A spiritual successor to Parse server with more capabilities. Would appreciate any feedback on the code and suggestions? Thanks :)
Why no devDependencies? Everyting is plain dependency in package.json?
So a laptop from 2010 is high powered compared to phones we have nowadays, pretty weird. Oh and don't worry, I know how it feels, I have windows phone and pretty much nothing loads here, it doesn't even know what javascript is. Instead complaining I just use a real machine though. EDIT: I just tried on my RPi3, ARM 1Ghz processor, 1GB RAM, I can only assume that it doesn't have a GPU or it's definitely not the same as a gaming pc, and that's about the same spec's as phones nowadays, it got stressed out, but I didn't really expect it to work. I mean, do you guys also complain about not being able to run BF4 or whatever game on fully maxed out graphics while using your tomogatchi? There's a reason why minimum requirements are a thing, and it's not like we do it on purpose to spite you and make you spend money on hardware...
This is awesome, I love the syntax they went with for this. Looks real clean. 
It is a bug https://bugzilla.mozilla.org/show_bug.cgi?id=737852 To get around this you need to share code 
Wow, is there a lot of theses types of products in the game land ? I never did a game but i build multi-user virtual classroom and right now i'm wondering if maybe i could of gone with a game server. It appears to offer the advantages i get from horizon.js combined with feather.js. This looks amazing, going to try. A huge wall i'd face presenting this to the support. Last year i convincingly presented horizon.js, now its absolutely dead. My boss already hate new things, they are only trouble to him. We'll see. 
Eh, comments are legal. I once wrote a function to find the lowest common integer in an arbitrary number of sorted arrays and this (labelled blocks) came in quite handy. I commented that it was weird and that it was an extremely specialised tool, so if requirements change it would most likely easier to delete the whole function and write a new one. I think that's pretty maintainable tbh
C. It's a small language that's easy to learn, and it has a lot of the flaws that rust was designed to fix
thank you for your reply. see the code below ctx.font = "60px Arial"; ctx.fillStyle = "white"; ctx.fillText(userName, 400, 1150); 
xzcz
I am not 100% sure, but I think simply changing `var` to `let` or preferably `const` will solve your issue. Take a look at the concepts "hoisting" and "block scope".
Awesome explanation, thanks!
I don't think this will cause a *leak*, but i do see a misuse of [.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) which will result in additional memory being allocated for an array that you never use. `.map`'s purpose is to produce a new array by transforming an old array. The function that you provide to `.map` tells it what transformation to perform, and your function should return the transformed value. But you're not returning anything so `.map` ends up producing an array of `undefined`s. Since you never assign this array to anything, i expect it will be garbage collected and not cause a leak. Your code does end up producing an array, but only because you're doing side-effects inside your map function. Essentially, you're treating `.map` as though it were `.forEach`. This gets to the result you're after, but the effort done by .map to create a new array is wasted. Instead, i'd recommend doing the following: var promises = subset.map((uid) =&gt; { return promiseUserData(uid).then((userData) =&gt; { if (userData) { userDataArray.push(userData); } } }); By the way, there's no guarantee on the order that the promises will resolve, so this will result in userDataArray being constructed in an arbitrary order. Is that what you expected? Or should the results be in the same order as the subset?
&gt;So a laptop from 2010 is high powered compared to phones we have nowadays, pretty weird. Yes. Because laptops have dedicated cooling systems and a mains power supply for when they're not relying on their enourmous battery. A phone is a bunch of ram chips and arm processors all sitting on top of each other, with no cooling system to speak of at all, all wrapped in several layers of plastic, and a 10Wh battery has to run the device for the whole day. That includes the screen, the wireless and cellular modems, etc. You can run your 10 year old laptop at 60W just fine, if you try to run a phone at that rate it would melt or the battery would explode. The global task scheduler in a phone is optimised to save power whenever possible, which means most of the chips are powered down whenever possible. So any specs for processing power you see for a phone are effectively marketting numbers and don't apply under real-world conditions. &gt;I mean, do you guys also complain about not being able to run BF4 or whatever game on fully maxed out graphics while using your tomogatchi? I think its perfectly reasonable to expect a **website** to run well on a device that represents the average web browsing platform. And no, minimum hardware requirements should not be a thing for a website, if you believe this then you shouldn't be a web developer because you're probably the reason that the average page load time on mobile is 19 seconds, and when the page does arrive its full of janky Javascript gimmickry.
"please stop feeding me!"
-teen girl squad
Thanks for the reply. I switch all variables to let, except for subset which I made a const. This ran correctly but did not fix the issue. I will look into "hoisting" and "block scope".
The requestaninationframe queues up a function to be called on next frame. One frame fires each 1/refreshrate of monitor seconds, usually 1/60
Thank you for the response, you are correct so thank you for that. Order does not matter thankfully. That code section now reads: let promises = subset.map((uid) =&gt; { return promiseUserData(uid).then((userData) =&gt; { if (userData) { userDataArray.push(userData); } }); }); 
Define the variables on the same line as the restructuring assignment: let { a, b } = someObject
you ranted in the wrong neighbourhood 
That's great! Did his advanced JavaScript course get renamed to something else?
I'm not really familiar with Horizon although I did like RethinkDB from that team. As far as I'm aware in terms of game servers we're the only open-source option (but definitely let me know any you come across). I'll have a look at FeatherJS and see what I can learn from it. The multi-user virtual classroom. Is it built with a game engine in the browser? How do you represent visuals for each user?
You are pretty much correct, they measure your users' mouse gestures and overlay the statistics on (a render of) your website.
Hey guys! I'm one of the developers for this tool a couple of friends and I have been working on a developer tool for React to help streamline the process of building skeleton prototypes project on component hierarchy. Our app will generate a folder of connected class components files to use for new projects or inject into an existing one. We were hoping the community can test it out and if it’s helpful for your workflow. Recently Added: - Save/Load feature We plan to continue building it out with more features including: - Redux state management - State vs. Stateless base component selection Let us know if there are any issues or any recommendations. We appreciate any feedback from the community! Thanks! 
The dataflow blocks abstraction over tpl is amazing. It's rare I hear anyone even mention tpl though. Such a shame because it's so awesome. I just had to geek out for a moment when I saw someone else actually mention it for once.
Have you looked at rxjs? You could really just implement some custom observable operators to do most of this and get to take advantage of all the already existing ones.
Yeah people thought it meant playing with react or angular.... 
This
I haven't found anything yet - but I can imagine since the onscroll event is delayed - things that are positioned on the screen with JS during scrolling is broken. Perhaps also scrolling interactives that use ScrollMagic which relies on constant scroll events to detect scene state changes.
If your promiseUserData represents a request for user data, then the memory increase could be caused by the data. You can verify this by changing promiseUserData to Promise.resolve and comparing usage. Also look up how to compare heap profiles in Chrome and you can see what is accumulated. 
Just a question. Is promiseUserData(uid) a call to a database by chance? If so, there are better ways of getting lots of data out than going one by one. If it is a db call, let us know, and we can help you there. If not, then sorry, I have no real advice on this one. 
Cool, Kyle is awesome. 
I have never seen it, but from description it sounds very close to what I was try to achieve. Probably it would be my choice if I was in c# stack
Your suspicions were correct. returning Promise.resolve() does not cause memory issues. However the following test promise also causes memory issues: function testPromise() { return new Promise((resolve, reject) =&gt; { setTimeout(resolve, 100, 'foo'); }); } From this I suspect that the Promises are not resolving before Promise.all is completed or these returned promises are not cleared from memory. Any ideas where as to go next?
I am querying a database. I am trying to match authenticated users to their respective associated user data in the DB. There may well be a better way of getting it, if you know how that would be great.
any chance you can post link to the github repo? would be cool to learn from
Positioning things after scroll on mobile devices was always tricky, and against UX in some cases on such small screens. I've just opened scrollMagic (on desktop) for the first time and oh my God. I don't have smooth mouse scrolling and the effect looks hideous D: I never liked websites that hijack my scrolling habits and make it unpleasant experience. If anything, I'd vote for just avoiding this kind of animations on mobiles in favor of performance, readability and maybe some css animations if necessary. 
Apples and Oranges, programming can also be a solution to the later, although it can be a solution for a exactly the reason that is is hard...
Good. You deserved that. :D
I do believe that even your tomogatchi must be able to load a website. A **website**. The problem is that the example provided, isn't a website really. It's a whole application embedded into the browser. Oh I am sorry, you couldn't really see what it is, not like you'd know... Go on any flash game website and complain here about flash games not running correctly on your shitty devices. Same thing really.
A week? I don't think people need "free for one week" when they can Google. Free for a month would be better but anyways it is an nice gesture.
Hey OP, did you have any joy in the end? I think it would be beneficial to put a variety of stuff on Github, or if that's not possible then make a nice website about yourself, including a link to your CV etc. Screenshots of some of your work may also help. Hope this is helpful!
This is most likely due to the dependencies of each of the libraries you used. Grunt-Bower-Concat will walk the dependency tree and add all of the dependencies in each of the bower files. You can try overriding this by manually setting all the dependencies to the same version of angular in your configuration file. I grabbed the below from the docs on dependencies: https://github.com/sapegin/grunt-bower-concat dependencies: { 'angular-library': 'angular', } 
First, are you sure it is a leak? Try run it with small heap size (node --max-old-space-size=&lt;MEMORY&gt;). A memory leak will cause the application to crash with a 'JavaScript heap out of memory' error. If it doesn't crash, it will probably run very slow due to constant full garbage collection sweeps but what this means is that you aren't creating permanent references but instead probably doing something that is causing garbage collection to not run efficiently which can also be solved. Choose a heap size which would allow your code to run a few times before reaching it.
What a great beard
There is a general limit to how many objects can fit in memory for any language. I have moved too much data using node then I should have. As you look at data you can visualize it as a tree. Each piece you work on is a node added to the breadth and the transformations depth. Once transactions are complete the depth of nodes can be simplified to one value and intermediate values can be garbade collected. If you expand the breadth too fast you will run out of memory as you will have an ever increase of total nodes in your tree. To solve this you need to wait for transformation to complete before adding more to the breadth of the tree. Bluebird has the map function with a concurrency value. Instead of using a for loop. Use bluebird.map and set an appropriate concurrency value so you are only working on a limited set up information at any given time.
Don't look a gift horse in the mouth. 
My only critique of him is he goes off the rails a bit sometimes recommending his own stuff rather than sticking to JS ... specifically his async stuff in YDKJS.
in my experience any time I'm writing code that involves a lot of typing it's something my IDE could do better. I use VSCode with a bunch of addons, and I find that any time I need to write boilerplate kind of stuff there will usually be some sort of autocomplete functionality to help me out. For instance, I have a module auto-importer, so I don't need to worry about filling out imports in the top of a file, and I have a snippet that will make a React component for me. I'm not really sure how well IDEs work with dictation software, but since many of them are extensible you could probably work on adding this functionality yourself. It seems to me like you should spend some time trying to find the best editing software for yourself and improving it, and once you do you should be able to to code as fast as anyone.
thanks!
If you can change the API yourself, you should absolutely create an endpoint that can take an array of ids as a param. You're hitting your API N times vs just once. Your API then can return two arrays - one with ids that were successfully authenticated and another with ids that were not. Having just one vague error to account for half a million possible errors won't help you debug should you have problems. What are you doing with your `userData`? So many questions... Look into Bluebird's `Promise.map` as well, which eliminates the need for that awful `Promise.all` and `push` combo.
It's really simple. You're querying for a thousand user ids. This is madness. Is this because you're trying to chunk the half a million user ids? And your choice was a thousand? Have you tried a hundred?
We use webRTC and each user has its own video stream or avatar is camera is closed. Ui is built with React js, state managed by mobx. Horizon brings reactive queries to the frontend with its very fast prototype setup(auto build collections, indexes, etc). and Feathers brings secured services and authentication. WebRtc can be used peer to peer with full mesh up to 4 other users and we can also relay through a server with Mediasoup. Its a pretty nice project. A server like yours or parse could replace the combination be a single point of management. We also look at Strapi the newest version. Its insane the options nowadays. But still great job, this looks very promising. 
&gt;Also I am not a web developer, Good. I'm glad you're not responsible for anything that anyone uses.
It’s a company called Mail Chimp. I️ thought they solely did automated email services before seeing this and then diving more into their “about us” page. I️ have no idea what webGL is, and honestly, I️ hate programming. I️ didn’t realize how much I️ hated it until last semester. But luckily I️ have a concentration in information assurance and security (cyber security) and am hoping to land in an opening they have for penetration testing to get my cyber career started. Are you a CS major as well? Or programmer? 
I made this: https://github.com/rapidjs/rapid.js! Just released the first version finally.
I don't have the cash to pay for a Frontendmasters membership and I only have around 20 hours free, starting tomorrow to watch these videos (That are almost 46 hours everything together). Does anyone know if the content of these videos are included in his books?
Yes, it is slower than doing 1000
Make sure you aren't using `console.log()` to log the promises or the objects. The reference to the object in your console will prevent them from being garbage collected.
Yes, its been renamed to "Deep JavaScript Foundations" - https://frontendmasters.com/courses/javascript-foundations/
I will check, thank you
&gt; Also, why has no one asked this yet in this group? Probably because this is a subreddit specifically dedicated to JavaScript. The debate between Bootstrap and Foundation is probably better suited to /r/webdev, /r/web_design, or /r/Frontend. I write mostly back office applications and had only ever heard of Bootstrap at the time I started so that's what I went with. I'm pretty entrenched in it now so I couldn't be bothered to switch.
I suppose I was focusing on the JavaScript aspects of BvF, and that was sort of a given since I was posting it in here. Granted, their focus is always on helping support the CSS written, but no one ever seems to talk about that aspect of the frameworks. 
Why not `&lt;fragment&gt;&lt;/fragment&gt;`? This looks like a self-closing tag `&lt;/&gt;`
Best tool for the best job. Use both FP and OOP where appropriate.
You really should consider offloading as much work as possible to the backend. There's too much traffic over HTTP and you're relying on memory management of a browser.
what if a and b are global or module wide, and not just local ?
thanks
`&lt;&gt;...&lt;/&gt;` is sugar for `&lt;Fragment&gt;...&lt;/Fragment&gt;`
This is on a nodejs server
I guess there are more questions that need answering. Please answer them all if you want some real help with this. 1. What are you doing with the userData? I can't think of anything that you should be doing with 500,000 userData at a single time. There is probably a better algorithm you can use for what you want to accomplish with half a millions userData objects. 2. Is this run in a browser on a client's machine, or as a script for yourself, or on a backend server with NodeJS or something? 3. Do you have control of the promiseUserData function? If so, we will want to either tweak it, or make a new function to handle an array of uids. It is kind of database 101 level that you can get multiple records with 1 query, instead of making 500,000 queries for 1 row at a time.
the courses offered on frontendmasters are super well put together and way more cohesive than googling.
Functional programming is mainly dealing with state in a non-mutable manner. In some instances it can make code easier to reason about, eg objects are always different so you can use `===` on them to check for equality.
Doesn't work on my iWatch, total bullshit. /s
Bootstrap's JS is just a bunch of jQuery plugins. Folks here tend not to like having jQuery as a dependency since it often doesn't comport with modern web frameworks/technologies. People are more likely to use libraries like ui-bootstrap to get those features in a way that matches their dev environment. I can't really speak to Foundation's javascript features.
Oh don't worry, let's say that I think we should get rid of phones. So if I was reponsible for anything, the first thing I'd do is make sure that every phone that tries to connect to any website melts in your hands.
You can speed the videos up, I usually watch at 1.5x (I can't do 2x yet). I would recommend picking the videos you are the most interested in and watching those. Also, if you haven't checked out Kyle's ["You Don't Know Javascript"](https://github.com/getify/You-Dont-Know-JS) books [(they're available for free on github.com)](https://github.com/getify/You-Dont-Know-JS) I would HIGHLY recommend them. 
yes, Rx is awesome and would be a good choice for some cases. But for things I was trying to solve I felt to constrained by how Rx dictates the flow architecture. All I needed was an Observable's base functionality which you already have in stdlib's EventEmitter
Hmm weird. It ran pretty smoothly on my old 2010 work iMac with a 128mb Radeon graphics, where usually, anything WebGL slows it down a crawl.
If you've dug through an hellish OOP forest of inherited abstract interfaces to find where behavior is actually coming from, then you'll see the appeal of pure functions that operate only on their arguments. I believe most programmers prefer OOP for no reason other than its what they were taught and what they're familiar with. Even if you're self taught, blog posts, online courses, patterns that we'll known libraries use, all come from people who were taught OOP from their introduction to programming. FP isn't the savior to all the problems of OOP, but it's a different approach that hasn't yet been thoroughly explored. I find functional code bases easier to reason about, and with strong type safety (in JS, via Typescript or Flow) it becomes much easier to write code that can be refactored, extended, and otherwise maintained.
Rxjs doesn't really dictate the flow at all. I mean some of the operators it provides explicitly do control the flow in a particular manner because that's what they are designed to do. But you can easily write your own operators to fill in any functionality you think is missing.
Codepen chart is broken, but neat concept.
First off, you could consolidate your code quite a bit into the following: for (var i = 0; i &lt;= numPasses; i++) { const processed = uids.splice(0, 1000).map(uid =&gt; promiseUserData(uid)); const users = await Promise.all(processed) .then(users =&gt; users.filter(exists =&gt; exists)) .catch(err =&gt; console.log('Error in Promises.all: ', err)); } Technically there's a bit of overhead in iterating over the array a second time to filter the empty users, but I doubt that will be a bottleneck and the code is much easier to read. Second, I think your memory consumption has to do with the fact that you're creating 1000 promises all at the same time, querying the database 1000 times (flooding the connection pool and creating connection instances simultaneously), and then filling a subset of those 1000 promises with user data at a fairly substantial pace. You might consider doing one uid at a time, similar to this: for (var i = 0; i &lt;= numPasses; i++) { const subset = uids.splice(0, 1000); const users = []; const l = subset.length; while(l--){ var uid = subset[l]; const user = await promiseUserData(uid); if(user) users.push(user); } // users is all of the matching users } But if you're really into saving memory, I'd look in to using streams and creating a pipeline for processing each user as they come in. Using a stream, you get the first user, process it, then release it to garbage collection while you work on the next user. Much lighter on memory usage. I'd give you an example but I don't know what you're doing with the user data to craft the pipeline.
This will not make a difference.
Why would that matter? Make your APIs performant. That's not a problem unique to certain server technologies.
i just use [chart.js](http://www.chartjs.org/) it works for everything i need to for anyway. 
You're a beginning developer, trapped in JavaScript. If you were a great or even moderately aware developer you wouldn't have to ask if you're supposed to know everything, because you would have a general sense for the vastness of computer science.
Sure. You'll just be a "great" deceiver ;)
**TL;DR** - Immutability - Pure functions - Function composition - map, filter and reduce
&gt; With all that being said, can you still be considered a great developer despite that you're highly proficient in separate other disciplines within the language? I would say absolutely. You could be a highly skilled UI developer, making a performant, user-friendly dashboard for some big app, but still not know much about the Canvas or be adept at complex mathematical equations/operations. Similarly, you could be a fantastic game dev, making beautiful game worlds and intuitive game mechanics, but still not know about best practices for writing a hamburger menu. I follow a lot of developers who work on React a/o Vue UIs, tooling, and utility libraries on twitter, and I would consider them great, even though they may not know anything about game dev. 
Something that would make it a lot easier to read imo would be splitting the code into modules. And the huge if/else statement in the Client.connect method could be abstracted into something cleaner.
I'm answering this on the assumption that you're managing a team in a non-technical capacity. I'm basing that on "Why should my business adopt it...". So if you're actually asking as a developer, my answer would be complimentary but different. It's not going to improve anything unless the developers involved understand the pro's and con's first. Not in isolation, but contextualised against the alternatives. Functional programming isn't new, it dates back almost a hundred years, its roots buried in calculus. FP languages appeared well over 30 years ago, so have considerable history. It's also not new in the context of Javascript, it has always been consider "functional like". Functional isn't even new as applied to OO languages. C# is a great example where its functional aspects have been refined and expanded for over a decade. Functional has helpful concepts. Language designers are clued into that. As several people have said, it's not an either or situation. You adopt the right aspects of each approach and mix them in the right ratios to deliver a working application. A lot of the claims made about functional's advantages over other paradigms usually only apply when you're using those other paradigms incorrectly (defining incorrectly, or correctly is the magic sauce here). Bottom line, it's a question your development team should be able to answer. If that answer involves a lot of wholesale change and near vertical improvements on any scale, their answer is probably wrong.
Looks like a quick way to reduce boiler plate, which is always great. Well done! 👍
The word has taken off a lot more than the practice. Anyone that used jQuery used functional programming, albeit not purely.
HP ProBook 640 G1. "Intel HD Graphics 4600". On my home desktop it works like a dream, but this really doesn't have a graphics card. Or at least the integrated one is garbage (and old). It runs VS Code magnificently however :)
We're looking more for Node.js devs. React &amp; Redux is a huge plus.
Indeed, same here :-( I guess a static fallback would be a good feature :-)
Let's be clear. The question wasn't whether I should know "everything". No need to get personal.
Well, I don't think events bubble up from inside of iframes so I'm not sure there's much you can do about it, aside from preventing scroll on the page all together (which, you can't actually do using `event.preventDefault()` in a `scroll` event listener). It's funky browser behavior that cause the top level window to scroll when the iframe has no more room to scroll. [Best solution I could come up with is setting the body's `overflow` style to hidden when you focus in the iframe](https://codepen.io/Anaphase/pen/LOXZyK), but it only works if you actually click into the iframe to trigger the blur event. ¯\\\_(ツ)_/¯
https://github.com/magicdustin/socket-games here ya go!
Thank you for the feedback! I don't know if I will end up getting around to building a bot by I will definitely try to make the win a bit slower without the instant reset.
Hmm, I like this. As a backend dev, who builds rest apis, I like how the requests are structured. Thanks for sharing.
canvas is Javascript you twat
I don't think he/she's getting personal, you're just taking it personally. The statement they made isn't wrong, you would understand your questions is a little silly and being a "great" is some egotistical dream people have of being the next bill gates or some shit. What does being a "great" even mean? Do what you want, what's useful to you, what you enjoy. That's how people become great. Passion + work.
Funny, that old iMac barely runs VS Code well enough that I accept to deal with the general slowness haha
&gt; what is the business case for functional programming Rapidly changing business requirements do not byte-rot the codebase as quickly. Code is easier to reason about. OOP is really great when you have a thing that does not change, not so great when it has to be maintain and grown over considerable amounts of time. Code becomes easier to reason about and compose in logical chains where links can be removed or added vs stacked bricks.
I won't be much of an help on the subject of grunt-bower-concat but it seems that this project is not maintained anymore. As an alternative I suggest you use https://github.com/yeoman/grunt-usemin It will generate bundles based on index.html import and you'll be able to easily hook uglify and such tools. The downside is to maintain this import list but at least you won't have problems with duplicates.
There are different aspects to programming in the same way there are different aspects to writing engineering or art. No one is expecting you to be a know it all, just keep learning things.
&gt;With all that being said, can you still be considered a great developer despite that you're highly proficient in separate other disciplines within the language? This is a hard question to answer. It may even be the wrong one! If your concerned about your journey as a programmer, I'd highly suggest reading "The Pragmatic Programmer." It's a language agnostic book about becoming a great problem solver. Programmers who are "great" often make something considered great, like Linus Torvalds, or contribute a great deal to their community a la John Resig. You might be considered a great programmer by your team. The right question might be how can I be a Good Programmer or a Good Problem Solver in order that I can contribute something great. Then let your work and your passion speak for themselves.
Blog posts abound on this topic, as well as a lot of personal preference, but here's a few things to think about before even considering using FP (from a top level / management perspective) **1** It requires as much or more discipline to do right compared to OO / imperative code **2** It can be harder to reason about for new / junior devs coming into a code base **3** It won't magically solve all of your problems, and may even cause some (FP devs can easily fall into the trap of being too terse / code golf style and end up writing something completely unreadable) **4** While ES6 and beyond has made a lot of strides toward making JS more palatable as a FP language ... it's definitely not designed to be one, and you will need to write a lot of helper functions or use a library like Ramda / lodash / etc to get to a place where FP languages are natively (and only kind of). For example, currying, partial application, etc are not core features in JS. Anyway, benefits include: * composability * immutability (DIY in JS - there aren't many guards against writing mutable code by accident) * DRY code * Easily testable code * elegance * cut down on variable reassignment which can be hard to track / easy to introduce bugs (oh what I already mentioned immutability) * excellent integration with React which can be written as mostly stateless functional components. Having worked on (professionally) a large and highly imperative / OO Backbone codebase, AND a more FP heavy React codebase, I can easily say the latter is far easier to reason about and make changes to without causing a regression. However, that's not the whole story. Both have benefits, and if you are working on a team it is a discussion you should have with your team. You should do extensive research to make the right choice *for your situation*. If everyone much prefers OO - then OO is probably the best option. 
Whether the question is right or wrong it definitely now comes in handy! For a while I've been wanting to strengthen my overall problem solving skills but couldn't find a good book that didn't pertain to one specific language. Thanks for your advice.
That does sound super helpful, thank you! It has been a little while since then, and sadly I still haven't had the opportunity to get my portfolio into shape... but, some good news at least by way of a recruiting site called [hackajob.co](https://hackajob.co) who are really helping me find a new job. Their site benefits from a "strengths" section, which is basically a series of timed coding challenges that you can work through and add to your profile. I heartily recommend them to anyone in a similar boat, their "talent advocates" really try and help you out - even going as far as calling me up before interviews with tips and advice! Thanks again :)
Thanks for your thoughts. I used to be a technical project manager but have now switched back to development. A lot of developers, both now and when I was a manager, liked to adopt new languages and tools because they were the new "hot thing". Because things like switching costs, amount of support available, etc. could affect our outcomes, I learned to ask what the true value was to our business.
I appreciate your thoughtful reply. Thanks!
well, there is no connection between number of blog posts, and pretty much anything. Folks will say/do anything for attention it seems. There are some nice bits, but it becomes an ideology for some who seek "purity", and write crappy solutions anyway. If I need to extract an array of keys or something from a reasonably small array of objects, I'll slap a map=&gt; together, but it will be the first thing I revisit if performance gets bad too.
You need OOP when you need to have statefull things (objects). For example, functional UI widgets is a truly retarded idea. It works on the web though, because developer doesn't have control over UI specifics like layouting, invalidating, drawing, etc. Most of pure business logic can be defined by pure functions though, because data manipulation is stateless most of the time.
[removed]
You should look up jQuery UI. That's already done, and you can just copy paste the example code and change it to your needs. If your teacher wants a vanilla solution from the ground up, you're in trouble, but you can probably look up other solutions on the web. That said, I strongly advise you to learn JavaScript. It's programming, which means it's hard at first, but makes you accomplish so much in the future that the struggle is totally worth your time and patience.
jQuery is not supposed to replace all of Javascript - according to their own site (https://jquery.com/), jQuery "makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler". So it's really optimized for manipulating DOM elements. Outside of using `.each()` to loop through a `class` or something, I can't imagine using jQuery for "creating a loop", like in your example.
Assume not using jquery or other libraries? 1) You can do a dropdown in CSS, but if it has to be JS I don't think there is a toggle visibility built in, but you can write a small visibility function and nest divs you toggle to show/hide on click to start: https://www.w3schools.com/howto/howto_js_toggle_hide_show.asp 2) use innerHtml on a container in your page. Something like: https://www.w3schools.com/jsref/prop_html_innerhtml.asp
Oh boy! 
Also, check out http://youmightnotneedjquery.com/ - DOM manipulation in vanilla JS isn't all that different, especially with `.querySelectorAll()`.
Thank you. Reading this from a redditor makes me really see the importance about js. I will try to learn as much as possible 
You're going to have to be a lot more specific. 
dude I am beginner, give me some time :)
This is my first personal application made using React. In terms of my implementation I used: * [create-react-app](https://github.com/facebookincubator/create-react-app/) to set up the build configuration process I couldn't figure out how to do myself. * [Tone.js](https://github.com/Tonejs/Tone.js) to produce the sounds and manage the timing between beats. * Socket.io to allow clients to communicate board data with each other. In the development process I found the React Docs and the official React Tutorial to be the most helpful. I would appreciate comments and suggestions as to how to improve this application. I am willing to answer any technical question below in the comments. Thank you
I prefer to use OOP most of the time because bare functions floating around with bare variables which in JS terms are well, global variables... Which I just don't really like, especially because keeping the state in such way isn't that simple, and anything could break. Though in OOP approach, when something breaks, I know exactly which object/class needs to be fixed, but I guess that's just me. Also in school we started with C++ (I guess nowadays they just hate students) and everything was just fully functional, so I wouldn't say that the OOP is the only thing I'm familiar with. Though you have some good points, in functional approach it's very bare and clear what does what, and you don't need to keep track of states in mind either.
Javascript is not a functional language, but you can code in a functional *style*. Suggest watching the following presentation : https://www.youtube.com/watch?v=oF9XTJoScOE
lord jesus it's a fire
No, it means you're pretty much a failure. But at least your perceptive in your own mediocrity, congrats!
You only have bare functions and bare variables if you're not using any of the modern JS build toolchain, typically you'd group them into modules. The only time "when something breaks I know exactly where it broke" is true is in small or particularly well maintained codebases. Bugs presenting themselves far from where they're caused can happen no matter what patterns you follow. I'd bet your experience with C++ was more procedural than functional. Function programming implies some patterns that are relatively difficult to use in C++ (passing functions around, for one).
Thank you! I'll add more detail in the section you mentioned.
Just reading through that code was really cool - I didn't know Proxy was a thing!
[removed]
Just installed, Thanks for this awesome tool!!!!!!!!!!!!!!!
Cool, this looks promising! Having Redux/state/props support in the future will definitely make is pretty awesome. Do you guys have a timeline on when the new features will come out?
Very cool. Just had a nice little session with a random stranger. Fun :)
From a purely practical point of view, the big advantage of FP is that it tends to lead to less complex code bases. It's usually easier to explain what something is, rather that how something works.
Maybe I'm missing something, but what's the advantage of this over just `&lt;div&gt;` tags? It's not like the concept of only returning one element really bothered me, but I guess it's clunky to add unnecessary divs?
Adding an extra wrapper element often times messes up layout-dependent styling. For example, if you had a parent component that was a flex container, and you had a child component with multiple elements, an extra div would require you to apply additional styling to the child's wrapper element to make sure the elements are laid out properly. Without the wrapper, they'll be laid out correctly without any extra effort.
Are you referring to DOM APIs that rely on literally mutating the DOM? Or just the way data changes as the user interacts with the page? Because the former case can be abstracted away quite nicely by modern view libraries like React, and the latter case can be handled well in a functional paradigm by a state manager like Redux.
I have hotjar and fullstory a bit and i think they capture the page html on the first load and then all dom mutations from then on. Check this page, open the console and interact with the buttons and text (is editable). Watch the mutations happening in the console https://codepen.io/johnsardine/full/rYQyGN/
We recently hired someone with angular experience though we're not using angular. In the end, once you get to the people that know what's up, it doesn't matter as long as you know _something_. Know react, vue, or angular? Cool, you're good to work on my react/vue/angular/whatever project. What you don't know you'll pick up and it won't take long if you have the fundamentals down. Don't rely too much on recruiters. It's their job to find people - any and all people, even if its people they're not interested in doing anything with right now. The fact that they're picking up on you at all is a positive thing. Now you just need to put a little effort into getting a foot in the door - a door of your choice, not theirs.
It depends on the streamer, or how interested you are in the related tech, though I imagine a lot of people just pop in and out of streams, or they just leave them open in the background.
What these companies are asking for and what they need, are two separate things. They need someone who is going to get the job done but they have no way of knowing if you will. So people assume years of experience equal the ability to kick ass. I have found, the best bet, is to become active in the community local to you. Join a meet up or find a study group that you can help. This type of networking is valuable to a future employer and will most likely put you in contact with the right people, in the right places. ... but everyone is different.
Happier programmers = money saved. 
Have you written enough (in a) lisp that you've come to realise the beauty of S-expressions? Have you ever written your own monad in Haskell? Do you know the difference between regular languages and context-free languages, and how to minimize epsilon-transition state machines into regular state machines? Have you contributed to the Linux kernel, or some other highly regarded open source code base (with high code quality standard)? Do you know what the relationship between B-trees and 2-3-trees is, and why B-trees are generally unsuitable for in-memory storage? Can you create a thread-safe circular queue using only a mutex? Can you, completely unbiased, name some pro's and con's, and give example of a good area of application, of the following paradigms: imperative, object oriented, functional, declarative, reactive? Do you know what linear types are, and what types of guarantees it brings? Do you know how dynamic programming differs from divide-and-conquer? Can you create a polynomial time reduction from Clique to Independent Set? What is your view of a "great developer"? Personally, I twitch every time I hear a Javascript developer push JSON into another field where it does not belong (parsing JSON is computationally expensive - you would know that if you had some traditional compsci knowledge), and never having heard of Boyce-Codd Normal Form still touts document databases as the end-all solution of all storage problems.
Ah, that's good to know. I don't need any extra demons messing up my layouts.
Wait, of course functional programming can have state... you must not have a good understanding of what it is. I can't understand what you mean about functional UI widgets being bad and developers not having control over UI on the web. Actually almost none of your comment makes any sense...??
[removed]
&gt; EDIT: I'm not saying that it was 100% following functional approach, should have probably said "no OOP" approach. Honesty, it still sounds like you’re conflating proceedural with functional. First class and higher order functions are a staple of functional programming and, from what I recall, non-existent in C++.
Bluebird is the best answer for this task. Although, I would try to improve your query to get user data in batches rather than fanning out like this if it's an issue.
&gt; it's a different approach that hasn't yet been thoroughly explored. I don’t know about that. Lisp has been around for a while...
I don't think you'd try to argue that lisp has similar usage levels to C++, Java, C#, etc, though. The ideas are as old as anything else in computing but I don't know any CS101 courses that teach lisp.
I honestly think Lisp was a 200 level course when I was in school.
Not being excited about learning new stuff might be coming through in your interviews... and they're probably correct to not hire you if they are building greenfield stuff depending on their tech stack. Maybe you can try looking for jobs that need help supporting older codebases? They're definitely out there and when you find one they're generally a lot higher paying and stable. In my experience government contracts might be a good fit, they're usually very slow to adopt new language features due to bureaucracy. And then after doing that for a few years maybe you'll want to learn the cutting edge stuff again :)
By the way, Nexus.js is an attempt at building an entirely new multi-threaded JavaScript runtime, and not a Node.js library. You can read more about it here: https://medium.com/@voodooattack/multi-threaded-javascript-introduction-faba95d3bd06 What I'm looking for in particular is advice on how to structure the API interfaces, so far I've modelled it after boost (the C++ library), since its patterns are already established and quite versatile. I'd like more input from my fellow JavaScript developers on what they'd like to see, however. Any particular pitfalls with Node that I should be careful not to fall into? Do you have any recommendations for certain functionality? Any feature requests? etc.
He's just noting the discrepancy between the ideals of "never mutate state" and interacting with the real world, which is stateful. Crockford mentions the same dichotomy when giving lectures. The goal is to find the correct balance. 
&gt; The rise in which decade!? It's been studied, used, promoted and written about in the '60s, '70s, '80s, '90s '00s, and now this decade. In the late 1980s it actually appeared as if it was poised for mainstream impact. The tools were mature, the techniques were well studied, many optimistic books and courses existed. FP was a particularly active area in the UK, notably Edinburgh. &gt; &gt; John Backus, inventor of Fortran, gave a famous Turing Award lecture in 1978 (a mere 36 years ago) clearly outlining the pitfalls of being locked into imperative thinking. &gt; &gt; Many of the practical issues of functional programming (for example, efficient implementation of lexical closures and gc) were solved before 1990—a mere quarter century ago. &gt; &gt; What went wrong? Fortran, BASIC, C, then the Internet, Java, then everything else. "Popularity" crowded out FP's good ideas for decades. Because alternative ideas had no standing in the popular mind, programming became modelled by the von Neumann machine exposed by C and Fortran (a mindset which had already been critiqued by Backus). Despite years of principled opposition from the likes of Dijkstra, flawed ideas like mutability, null, reflection, and dynamic typing spread like kudzu. [link](https://www.quora.com/What-caused-the-rise-in-popularity-of-functional-programming-What-changed-and-brought-functional-programming-to-the-forefront-of-business-programming)
For me, it comes down to declarative vs implicit. FP is declarative and therefore easier to understand the intended outcome of a given codeblock. 
jQuery is JavaScript - it's just a library. One of its main goals is to make DOM manipulation easier, but also has some things for dealing with ajax requests/etc. Dealing with the DOM is only part of what JavaScript lets you do. Mucking about the the DOM is one of my least favorite aspects - I'd rather let a library/framework deal with that for me so I can focus on other areas of the application. The site [you might not need jQuery](http://youmightnotneedjquery.com/) is handy for seeing how you would use vanilla JS instead of jQuery. For example, $('#someId'); // find something by id which is the same as doing: document.querySelectorAll('#someId') If you were not using jQuery, but liked the shorthand syntax, you could make your own `$` function const $ = (selector) =&gt; document.querySelectorAll(selector); $('#someId'); $('.some-class'); When I was first learning JavaScript (nearly 10 years ago), and dealing with older browsers - IE6 days. There were so many cross-browser quirks / bugs / etc - that jQuery provided a nice way of being able to 'just get stuff done' - and not need to worry about all of the edge cases. It also let me focus on the business logic of my application. I don't think I would of had the patience to take JavaScript seriously if it wasn't for jQuery back then, even though I haven't used it in ages. 
jQuery is JavaScript - it's just a library. One of its main goals is to make DOM manipulation easier, but also has some things for dealing with ajax requests/etc. Dealing with the DOM is only part of what JavaScript lets you do. Mucking about the the DOM is one of my least favorite aspects - I'd rather let a library/framework deal with that for me so I can focus on other areas of the application. The site [you might not need jQuery](http://youmightnotneedjquery.com/) is handy for seeing how you would use vanilla JS instead of jQuery. For example, $('#someId'); // find something by id which is the same as doing: document.querySelectorAll('#someId') If you were not using jQuery, but liked the shorthand syntax, you could make your own `$` function const $ = (selector) =&gt; document.querySelectorAll(selector); $('#someId'); $('.some-class'); When I was first learning JavaScript (nearly 10 years ago), and dealing with older browsers - IE6 days. There were so many cross-browser quirks / bugs / etc - that jQuery provided a nice way of being able to 'just get stuff done' - and not need to worry about all of the edge cases. It also let me focus on the business logic of my application. I don't think I would of had the patience to take JavaScript seriously if it wasn't for jQuery back then, even though I haven't used it in ages. 
At the end of the day the project is likely going to be mediocre unless it solves a problem that you have. It’s tough to get motivated to really push a project over the edge unless you have some skin in the game. Think really hard about a problem you encounter regularly and design to that solution. 
&gt; difficult to use in C++ (passing functions around, for one). I agree with everything else in your reply, but I disagree with just this bit. If we're talking about state**less** functions, then those were always easy. That's just a function pointer. Even C could do that. C's [qsort function](http://en.cppreference.com/w/cpp/algorithm/qsort), for example, was a higher order function long before higher order function became a buzz word. If we're talking about state**ful** functions, then yes, before 6 years ago that was verbose in C++. But since 2011, creating stateful/lambda/closure functions is just as easy in C++ as it is in JavaScript.
But why male models?
&gt; const {a: x, b: y} = {a: 5,b: 98}; &gt; [a, b] = [x, y]; 
I had not used default exports before (as I just inherently knew the benefits of named ones) and stepping into a project that has everything exported default instead of named brought me to the same conclusion - never use default.
hah you made me laugh, but then i got sad...
You're probably a pretty good developer, but you're hurting yourself by complaining and feeling afraid to learn. When you deride the JS ecosystem and lump things like DOJO, React, npm, and JIRA together, I think you're sending a pretty clear signal that you're not familiar with these things. As a practical example, maybe you have a codebase that is mostly React but there's some legacy stuff using Dojo. You use node.js tooling and npm modules. Jira is an issue tracker. Mocha runs your tests. You probably have Git version control. ES6 is the 2015 standard of JS. React is "just a view". I think if you brush up a little and try to cultivate a more optimistic attitude, you will turn your luck around. 
Wow this is pretty slick!
‘Now es6 is better’ makes me think that you don’t really know what you’re talking about
:( it was supposed to be funny
That is, once you understand the building blocks. Once you understand what `map` is for, it's much more concise to scan than an equivalent for loop. When I see `for` in code, I don't really know what it's for; there are so many possible uses and applications. Seeing `map`, I know exactly what will happen.
This is actually really well put
Yep. OP is calling himself a front-end developer but to me it looks like he just spent 10 years learning HTML and CSS. I don't understand why he's confused.
The title seems a little dogmatic, but I definitely agree, especially in relation to tooling with TypeScript. Project-wide renames _sometimes_ work with default exports, but not as consistently as named exports. [Relevant link](https://basarat.gitbooks.io/typescript/docs/tips/defaultIsBad.html)
There’s no guarantee memory will be cleared after the loop ends. Chrome will decide when to garbage collect. All you can do is assure no references are being held longer than the data should live. 
If your file exports one thing, I don’t see why a default export is bad.
Don't be afraid to learn JavaScript frameworks. The more of them you toy with (you don't need to be perfectly competent) the more you'll see similarities and evolutions in the technology. Learning React and Angular aren't necessarily wastes of time. Although learning the new Angulars will involve learning TypeScript. Under the hood these frameworks are all JavaScript. If you're a competent JavaScript developer, and you've experience with a few frameworks you'll be able to pick up any one of them given a shorter ramp-up time. When I'm interviewing candidates, I don't really like to see mastery in the singular when it comes to JavaScript. I like to see a candidate has taken time to at least survey the landscape. If your last role used React and you're now a React grandmaster, that's great! But knowing of other frameworks and having at least toyed with them demonstrates a thirst to learn and a good grasp on the landscape and trends. Knowing a dev has written XHTML, Perl, Classic ASP back in the day is great if they're together on new technologies. Show's me they've seen the evolution and stayed the course with it. Knowing a dev has only written XHTML and Classic ASP because that's all their job required them to do for the past 15 years, that's not so encouraging.
We better get to banning this also. import { rightName as wrongName } from module
+1 to this. Actually take the time to learn SOME of the things that are newer to you (React, unit testing, JIRA, npm) . Take the risk, despite your knowing that these tools won't be around forever.
take some classes on udemy
I don't agree. There are cases where different files may have similarly-named exports being imported into one file. Cases like this are probably what `as newName` is meant for. Example: import { combineReducers } from 'redux' import { reducer as userReducer } from 'modules/user' import { reducer as authReducer } from 'modules/auth' import { reducer as chatReducer } from 'modules/chat' export const rootReducer = combineReducers({ user: userReducer, auth: authReducer, chat: chatReducer, }) A somewhat contrived example, and a little boilerplatey, but you get the idea.
Well I don't agree either, I think the original post is dumb, I was making a point that named exports can be whatever name you want.
There’s online classes but that also doesn’t work for everything. I’m not sure your level of knowledge on design or programming but what I’ve done in the past is come up with a project and draw out the components needed for the project. Once you have that down, start researching how to do those things in the programming language of your choice. Also look up similar examples/projects to yours. 
Check the FAQ at /r/learnprogramming 
I think this would be a great place to start! I’m pretty decent at learning new programs. I just taught myself VRay and Sketchup and realized I needed to stop being lazy and learn code finally. I have only dabbled sadly. I have a decent foundation but no real skills so far.
Ah, my bad then :D
Hey did you get this figured out? I need to do the same thing, wondering if you got it working.
Probably not related, but on big/nested loops like this at least extract anonymous functions where possible, so they're not being created on every loop or sub-loop: - `(userData) =&gt; ...` can be extracted out of the `map` callback scope - The error logging function can be pulled out of the whole `for` loop
I think so to, especially if you’re just beginning. Learning a programming language is one thing but it helps a lot when you can actually see how it works in “real life”. JavaScript is a very good language to learn and also fairly simple compared to some others. It’s also used for a lot of different things today and is super useful. Since you have a design background, you should check out a JavaScript library called p5. Its user friendly and used to visualize data, art, and more. Wish you the best of luck! 
Thanks a ton! I’m mostly a visual learner. 
No problem! If that’s so, JavaScript is a great language to start with. Watch YouTube videos if you don’t understand things. There’s tons of online resources. 
I have been told by a professional I know to learn Java. I was going through their resource page and was taking in most of info.
Sorry. I know es6 and typescript and so on aren't frameworks. React you need to use es6+babel for instance
This. So much this.
I know all of these. Td ameritrade uses dojo for their graphs. React and NPM go together for any kind of builds. It's just every job seems to want an entirely different ecosystem
How so? 
Since you're already using async/await, you can make it even nicer (and avoid one of the anonymous functions that I noted in my other post): let promises = subset.map(async (uid) =&gt; { const userData = await promiseUserData(uid); if (userData) { userDataArray.push(userData); } }); This does the same thing, it does *not* cause the loop to wait for each promise before moving on to the next iteration.
I feel that Java May be a bit too hard for someone’s who starting out. It’s also what we call an object oriented language and those can be tough for a beginner. It’s best to start easy and gradually learn harder languages or concepts. Once you know one programming language well, it’s super easy to learn others. 
I was told Java would be a good starting language. Any suggestions on where to start?
Check out: https://www.codecademy.com/learn/learn-java https://www.udemy.com/java-tutorial/
Thanks!
You’re welcome :)
If you are as good of a developer as you claim to be, learning a new framework to the point of working proficiency shouldn't take you longer than a week or two. They're not different ecosystems, they're different tools. If you want to find jobs easily, you should have a portfolio that demonstrates your ability get shit done outside of any particular toolset. Top developers don't look for work, work comes to them. Build a network, learn to market yourself, continuously educate yourself and have an online presence within the community. Go to conferences, present, write useful articles, contribute to open source. Have GitHub, LinkedIn, StackOverflow, AngelList, etc. accounts. 
Are you using Bluebird by any chance? This might be a stretch but there is a bug I logged recently in Bluebird's repo that was plaguing me with memory leaks for years that might be affecting your code. See here: https://github.com/petkaantonov/bluebird/issues/1478 TL;DR - Just a standard import of bluebird will pull in code that has all of the debug flags turned on unless you explicitly disable them with Promise.config(). This includes the flag **longStackTraces** which basically causes Bluebird to keep stack traces in memory until a certain amount of Promise executions are generated. One way to test if this is your issue is to disable these flags explicitly and see if it reduces memory consumption: Promise.config({ warnings: false, longStackTraces: false, cancellation: false, monitoring: false });
Npm goes together with pretty much any mainstream framework now days...
That article is factually inaccurate, named exports hinder treeshaking, as webpack with specific plugin to handle the case import an entire file, not just the code related to the named export, it treats them the same way as default export. Always nice to see someone post up a blog for doing something drastic, and providing a completely rubbish reason for doing so.
I have a similar background, though I've pursued both tracks and have always known some "ad agency" level coding, i.e. ugly hacking (no offense to any ad agency coders out there!). Best way for me has been to scratch my own itch, even for commercial app ideas. Once you have even a rough idea: 1. Start with pen and paper 2. Type out things one should do with the app (log in, sign up, create a post, read posts, edit posts...) 3. Map out a flow from these things so you end up with a "boxes, labels and arrows" chart 4. Hit up Sketch/Photoshop 5. If you're visually inclined, create UIs to match your vision. If you're not visually inclined, download some UI component package for your software and drag those buttons etc. into place 6. Start developing the UI in your chosen tech (iOS, Android, Web...) 7. Use static values, i.e. don't worry about database or business logic 8. Focus on getting the 80/20 rule right for UX (20% effort gets 80% results) 9. Once happy, look to incorporating a database backend and business logic 10. Use Google, Stack Overflow, tutorials and documentations heavily throughout the project That's my take, anyway. YMMV. Check out "Fake it till you make it" book from Amir Khella. Not for coding insight, you won't find that in there, but more to get the process going.
Yeah it’s kind of apparent you don’t know what you’re talking about 
This is how my brain works! Thank you so much! Also what exactly do you mean by the 80/20 rule?
I think you’re in the wrong subreddit. 
Where are you located?
Near nyc
I assure you that's not the case. I know angular 1.6. I know some react, I've contributed to the jqiery codebase. I've been doing this since ie6 and Firefox 2 didn't mingle. I also have been working with ecma for longer with Adobe technologies
Ah, can't help you then, sorry. Best of luck though, keep trying.
Hah what we're you thinking out of curiosity 
ES6 and TypeScript are two different things. ES6, aka ES2015, are core functionalities on the base language itself. Saying you need to do ES6 is equivalent to saying you need to do regular Javascript. TypeScript is essentially syntax sugar and a coding style that transpiles into regular Javascript. 
He (claims to have) contributed to jquery core. That’s usually not something you can do if you don’t know what you’re talking about. I think he’s probably a good engineer that hasn’t adopted the whole modern JavaScript ecosystem yet. If I did job interviews I’d give him serious consideration. 
I know I just said es6 and typescript aren't frameworks. I can explain but obviously I could Google it if I didn't know that. Dude you're not helping.
PM me your resume and portfolio.
Better, compares two things.... How can I build a better chat bot, if it is my first chat bot?
i have the impression you don't understand what functional programming is
From a hiring perspective I would avoid you. Not because you don't know these things, but because you seem unwilling to try and understand them. When hiring a developer, particularly front end, you need someone who can pick up and learn new technologies quickly and be passionate about doing so. I went from a HTML/CSS/jquery jockey to creating a yeoman generator for our company's front end team, running a knockout template engine using sass and grunt all in my spare time. Why? Because I saw a problem, found technologies to alleviate developer burdens, read up on them, created a proof of concept, presented it to my director, and implemented it. Since then I moved to a full stack position where I have done work in Angular, react, Vue, .net, laravel, swift, Java, react Native, grunt, gulp, webpack, etc. The concepts carry over from one technology to another for the most part, so leaning s new language or framework isn't that hard. And most employers don't care that much about it. 
Freecodecamp.com
&gt; I have a decent foundation but no real skills so far. It’s a funny thing, the context of this sentiment I have a CS degree from university, specializing in computer graphics, I’ve written lighting samples and other OpenGL projects, real time systems, distributed systems, many c programs, assembly, performed algorithm and data structure analysis, written a FAT16 filesystem driver, worked on a satellite, worked for a gaming publisher, written my own games and now build mobile apps in react But I still consider myself as just having a decent foundation but no real skills so far This is said just because you’re going to have moments where you think you can’t do it, but it’s not because you can’t, it’s because every human thinks that lol
Jesus...that made me feel all fuzzy on the inside. Also, fuck you. You worked on a fucking satellite? I hardly know what I want to do with my life. Please tell me you aren’t super young at least.
Yeah man! Just spend a year on unemployment while you learn every esoteric framework that comes along each month. Don't be such a bitch.
Well I’m not, but I’m just out of university The thing is it’s just a matter of interest and time, start with one piece at a time and remember the rule: the first part of learning something new is like a logarithmic curve, it’s really steep at first but eventually it’s a lot easier, until the next challenge 
That is very true! I just need to suck it up and learn a language. What did you learn first? And I legitimately want be your friend! You seem interesting 
Again?
I guess it depends on what aspect of programming you want to learn. It’s a really expansive field and I think each will have its own entry points. I can only speak for web development (trying to be full stack), and if you want to know more I might be able to point you in the right direction. For basic programming you can always start with the command line.
I know, or at least used to know, command line. I would love to be full stack is kinda my goal. Maybe mobile app development later. 
I think it was Visual Basic in high school a couple decades back, although I learned a lot more in LUA making mods for a game I liked Most of the other stuff was accelerated by being in university, the environment is conducive to heavily self-motivated learning and extra curricular projects Maybe start with JavaScript, ruby or python, since you can learn those online in a REPL ( like those online tutorials that let you write the code in the browser ) A lot of primary concepts need to be solidified before you even fully understand how hello world works, but the best thing you can do is start and be willing to ask what might seem like even basic questions, then when we explain things you can pick up even more from explanations we may not realize you needed to know
There really was no better way of phrasing that, was there?
Don't waste time with 3rd party recruiters. I've never had a positive experience with one, in this career nor in my previous sales job. They are value-diminishing middlemen whose commission comes out of the same budget as your salary. On the other hand, online recruiters like Hired earn their value by making the job search a lot more passive. I got my current job through them while working 70 hour weeks at my former employer; not a chance I'd have been able to motivate myself to send out resumes, let alone talk to a third-party recruiter on the phone.
sentences like this are probably the biggest thing costing you these jobs. We would hire someone who doesn't have tons of react experience, but not someone who says they know what it is and then says something showing they have literally not even a vague idea.
Have you ever done any UI work?
It’s handy to have a decent grasp of the command line. You’ll use it a lot as you progress. While HTML isn’t programming or anything, what it helps teach is the relationship of JavaScript to the DOM. In turn, you’ll also learn about fundamental things like objects, arrays, functions, closures and currying as you learn to manipulate the DOM. Since you have something tangible to work with (let’s say you’re building a generic UI component, like a mini dropdown menu) everything kinda slots into place a lot easier (or at least it did for me).
Yeah, mostly UI work, and fairly complex stuff with animations and interactions. It was a mess before functional programming. Widgets that are pure functions of state, with their actions being callbacks/actions (instead of mutating the state directly) are a huge win for keeping things sane in UI development. Can you speak to any clarifications on your points?
Thank you, yes I agree it's kind of overwhelming to deal with JS when it comes to deal with it. But Jquery is a cool tool, and make my work really easier! 
1. Don't be scared of fucking shit up. 2. Fuck shit up. 3. Figure out how to fix shit. 4. Fix it. 5. Repeat until good at code.
yea you don't know these... the way you talk about them makes you sound REALLY inexperienced
You might want to post this on a JAVA subreddit. This is for [Javascript](https://en.wikipedia.org/wiki/JavaScript) which is very different than Java. I'm not 100% sure what your question is asking, but from the looks of it you never set done to true or false anywhere. You need to create a boolean done = false; at the top and inside your if(ans2.contains("Yes")|| ans2.contains("yes")) **ps (ans2.toUpperCase().equals("YES")) will work better** set that flag to false. Also some advice. Make your inputs into a double instead of an int, because [Truncation](https://en.wikipedia.org/wiki/Truncation). And look up code styles. Way too much whitespace.
Not everyone uses the same frontend stack, the same way that not everyone uses the same backend stack (although arguably there's more variation on the backend side).
When you present yourself as someone who's not willing and able to learn and master new stuff, don't expect to get an offer.
Usually, especially if you're more visually oriented, there is this burning desire to see the UX "just right". Unfortunately, things can get really tricky fast after a working level has been established. I have no proof, but I wager the visually oriented need faster feedback loops to stay motovated. I.e. we will lose patience if we are exerting too much coding effort for no visible improvement. This can happen easily with e.g. morphing some graph "just right" or "nailing my idea of screen transition within a tabbed navigation". Grinding to a halt here is bad for motivation. So go for breadth first, release something whole. You will feel great! After a release it is easier to focus on the finer details of the app.
You've definitely got a great setup. Never seen Strapi before. I think you're right in this project Nakama server could replace the combination of Horizon+FeatherJS. If you do get the chance to experiment with it drop into our [community channel](https://gitter.im/heroiclabs/nakama) and let me know. :)
I figured that was a joke...
The best way to learn something, imo, isn't schooling, it's having an interest in the subject and getting your hands dirty. Start building something serious. You have an idea for an app / website? Good! Then go ahead and build it. You probably don't even know how to start. Then do the amount of research you need to get started. Then build what's called a "hello world". Pretty soon you'll probably want to do some more research. R The world of programming is huge. Even compared to Trumps hands. You don't have to learn everything at once, just start small and continue from there. I'm a professional programmer since 17 years, and I still don't know the tip of the iceberg of programming. You'll never know all of it. 
I did wonder about how best to break up the code into pieces but I was under the impression that ES6 modules are much like a package in Go? They represent a collection of structures for a specific purpose. Do you have a guide you can recommend on how to manage ES6 modules in a project?
If you've dug trough an hellish functional application where everything is curried, there is no way of debugging, error handling and everything is broken down into small meaningless functions that you have them so many that everything starts to get duplicated..than you will start to appreciate OOP and the clean structure again :D .saying that functional is nice but it has the same flows as OOP..if you do it properly its nice if you don't it is really bad..I would say a lot worse than a badly written OOP app
&gt; I️ have no idea what webGL is, and honestly, I️ hate programming. I️ didn’t realize how much I️ hated it until last semester. I felt this way until I got a job where I wrote code for a living and found out how completely different (and better) programming is when done in a professional environment. My love for programming grew 10x after I put a few thousand hours in as well. I would also suggest trying out a handful more languages if you haven't. All that said, it sounds like you've already got a pretty great plan for after graduation, may your future be bright.
It works perfectly! Thank you my man.
Aside from Java, you could also start with python, a good introduction: http://openbookproject.net/thinkcs/python/english3e/ Apparently the head first books are not that bad: https://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208 Since at this point I've noticed we're in the javascript sub: https://medium.com/coderbyte/50-resources-to-help-you-start-learning-javascript-in-2017-4c70b222a3b9 https://developer.mozilla.org/en-US/docs/Learn/JavaScript Muchos later, read these: https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882 https://medium.com/startup-grind/a-lifetime-of-learning-to-code-df1a9889c403 https://97-things-every-x-should-know.gitbooks.io/
&gt; no ES6, just plain JavaScript ES6 = just plain JavaScript
Hey come on I have my entities with default export wtf. (judging by the title)
Lol wut. I have 2 imports of useContainer, one for plugin for database another for plugin for controllers, there can be third, plugin for sockets. So whatcha suggesting, use 3 files just for importing lol?
There is high demand for devs be it middle or junior, just keep trying. People are switching careers etc, there is place for everyone. All those js frameworks are huge marketing nonsense, that hr is exploiting. You may need to find a job that pays a bit less but gives you the chance to work with angular or react on daily basis to get more familiar with all this js bs. Try going to like 30 interviews and then re-evaluate what are the best moves you will have to make in order to adapt.
The app doesn't use any features from ES6. ES5 only.
A module is a file usually containing one piece of functionality. You compose your package from many modules. What you have is fine. The only problem is if the library gets too large, reading all the code in one big file is a pain. I don't know of a guide, but you can take a peek at [some modules from PIXI](https://github.com/pixijs/pixi.js/tree/dev/src/core/display) and [localForage](https://github.com/localForage/localForage/tree/master/src) as examples. Pixi has many classes, so puts each class in its own module. localForage however uses more atomic modules each with one little function. Both are good approaches, and not mutually exclusive. Personally I just try to keep each module small and easily digestible, so that it can be understood "at a glance" without necessarily reading everything in it.
Best answer by far. It's free, comprehensive, and the community is awesome. 
Why not?