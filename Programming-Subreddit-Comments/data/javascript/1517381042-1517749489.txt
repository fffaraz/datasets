Good point. Is prefer to follow logical separation to keep the parent cleaner, where it makes sense, but there is certainly overhead involved.
This seems very relevant: https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5
Conditional breakpoints are common to other debuggers, too. You can use them with Visual Studio Code's debugger, Visual Studio's debugger, JetBrains' debuggers, etc.
Should the greet form at the front page actually work? Because it does not seem to. 
If there's no parameter to prevent buffering then you're S.O.L. I'm afraid. Regarding handing whether there are already parameters in the URL or not: exercise left to the reader. ;-) Hint: the easiest way is just to stick another `if`/`else` statement inside your last one, that checks whether `url.includes('?')`, and decides between using '?autoplay=0' and '&amp;autoplay=0' accordingly.
If there's no parameter to prevent buffering then you're S.O.L. I'm afraid. Regarding handing whether there are already parameters in the URL or not: exercise left to the reader. ;-) Hint: the easiest way is just to stick another `if`/`else` statement inside your last one, that checks whether `url.includes('?')`, and decides between using '?autoplay=0' and '&amp;autoplay=0' accordingly.
I cannot tell if you are being sarcastic or not. Why is matching the opposite condition of what you want to action on obvious? 
It's a matter of personal opinion I suppose, but the NPM repository is far too lax with what gets in, package naming and namespacing, etc. Maybe if it were a bit harder to prepare and publish a package we wouldn't constantly have 50 different public packages that do the same fairly trivial thing, more than half of which haven't been maintained at all.
Definitely going to be using this the next time I use Rails for something
I suppose you have a point their.
Where is the interesting insight? I'm not seeing it. All I got from the article is that there are a lot of programming languages, and people use a bunch of them, even some really old ones. Was there more to it than that?
You can download the database. https://cve.mitre.org/data/downloads/index.html You can also check if any of the CNAs have an API. https://cve.mitre.org/cve/request_id.html#cna_participants
What if `string1` has characters in it that have a special meaning in a regular expression?
[C3](http://c3js.org/) uses a factory to generate charts. Usage looks like this: var chart = c3.generate({ bindto: '#chart', data: { columns: [ ['data1', 30, 200, 100, 400, 150, 250], ['data2', 50, 20, 10, 40, 15, 25] ] } }); In fact, the factory is actually just [a courtesy for this](https://github.com/c3js/c3/blob/master/src/core.js#L44): c3.generate = function (config) { return new Chart(config); }; The only problem with the article you linked is that I feel it is mostly focused on _custom_ charts. That is, it outlines an approach one would use to produce custom, one-off charts but still do it in an orderly fashion. And so, it is mostly a _guide_ leaving you to do most of the work. On the other hand a chart library generally includes its own catalogue of charts and aims for easy _small_ extension. That is, it aims for small customization of the existing charts, rather than general creation of new types of chart. Well, they do allow it, but then again you're _mostly_ in the same situation as in the "orderly one-off chart": doing most of the work.
&gt; Good programming isn't about saving characters, it's about communicating to the people who come after you I agree 100% ... but then you didn't mention commenting? Haha, like, code however you like to code, if you're going to use "a" as variable name then give me a comment explaining exactly what "a" is storing/doing. - *I realize that's just a quick example just making a point* 
No but you can setup an authentication/signing scheme so that you at least know which user submitted what. 
I've yet to come across a case when I need to do direct dom manipulation when using React. I imagine there might be edge cases, but for the most port, you don't need it at all.
I agree. In that scenario I'll break it out to a sub component. This is for small switches or logic that isn't being re-used.
Can't you get rid of a lot of unwanted behaviour by using `!!` ? I also often not only check for `!!` but also for a field. So `if (!!a &amp;&amp; !!a.username)` to make sure we're dealing with actual content. It might make code a bit longer, but it saves you lots of issues in the end. 
A hidden input on the form with a preset value you are expecting is a possible solution. But anyone using your API after perusing your apps source code will see that and take it into account.
There's nothing wrong with jQuery if it suits your purposes. My grudge against it is that it's pretty heavy baggage to attach if you only use small bits of it. Like, for instance, I will like jQuery's ajax implementation better than plain vanilla js. But if a tool suits your purpose, dumping it on purely "purist" grounds is not a good argument. 
Nice one!
for the most part, i am able handle a lot of the things with react state change handles. One example is when i need to add/remove a class to an element because a value in a list of objects changed. Unfortunately i am unable to apply the change without a page reload or jQuery
No. As long as it's possible to see the application source code, or debug the application, any other application can mimic what your application does.
you mean true &amp;&amp; reportThisAs("abusive or harmful");
 string2.indexOf(string1) === 0
Very cool. But zoom is limited? It gets low detail and blocky when you keep zooming in.
Couldn't you just store the list of classes applicable to that object in a variable in the state and when the value in a list of objects that you say changes, change the variable in the state and trigger a render Sry, for my English, I'm half asleep but in my head it makes sense
[CxJS](https://fiddle.cxjs.io/?f=l3m4amLH) seems to check this box.
PROGRESS https://codepen.io/pakastin/full/gvppqr/
 import classnames from 'classnames'; &lt;div className={classnames( class1, active: isActive )} &gt; ... &lt;/div&gt;
I’ve switched to object destructuring now because (IMO) it’s clearer what’s going on and makes adding defaults a breeze. Also more concise.
Most jQuery functionaly doesn't fit well with react, because it uses direct dom manipulation and react is based on virtual dom.
React way to this is to hold your list of objects in state or props, so that you can calculate classes in render method based on this list. When the list changes, it will get automatically rerendered.
So there needs to be some sort of escape? Hmmm that's going to be fucked up but anyways, the string1 and string2 in my application would only hold an underscore
or axios which is also a really nice library
Great point, do you see similar code injection techniques working there? I guess it would depend on the language?
I think it is because the floating point math's precision
Just what we need. Another overview of front end frameworks.
Admittedly I only tried it in [the typescript playground](https://www.typescriptlang.org/play/#src=const%20x%20%3D%20%7B%20a%3A%201%20%7D%3B%0D%0Ax.b%20%3D%202%3B) and it wouldn't let me see the generated javascript, so I assumed it didn't compile.
I wouldn’t hire you ...
I use knex + objection + schemats kombo with typescript and I'm quite happy. I tried Bookshelf/Sequelize year ago, but didn't like it and also TS support was weak... TypeORM looks very promising, but at that time was not really prod ready, i was hitting a lot of bugs, probably it's way better now. Today I would try TypeORM first and if it didn't work out, knex + objection is great kombo. Some minor issues: 1. objection has small issues with ts typings 2. doing migrations with knex means, that your model is effectively defined in 2 places 3. i prefer to validate with class-validator instead of json schema.
What's a JSX specific example?
Circumstantial really, the former is very useful for conditionally adding members to an object using the spread operator: const obj { someProp: 10, ...shouldIAddProp &amp;&amp; {anotherProp: 'yes'}, } But if it's in standard logic flow, `if` makes your intentions far clearer
No, if they allowed custom JS to run it would be a huge security risk.
The chrome debugger statements are unreliable when you change the line your original source is on. That being said I agree, debuggers are always more consistent.
If you're building an actual viable product that has to fully work, then you're going about it the wrong way. Wix is mainly for what we call brochure sites. Websites that are purely about showing a company's brand, information, content, and contact information. I'm sure they have the means to go further into such around that you want, but you obviously will have to pay them for it. If I were building such a sight, I would be cutting it myself, or at least using a Content management system like WordPress. They actually might have a module that will allow you to do what you want to do. I would be using a database to store that information, and make sure in the code that I encrypt all that data so someone can't just easily steal it. Now all you have to show is just a mock-up of how it would work if it was a fully-working website, then I would suggest you simply creates a presentation on that Wix site. Make it look like it actually works, but in reality it doesn't. A prototype basically like what ux designers would do. 
Just for comparison, here are two screenshots how Flow errors are displayed in WebStorm (at least 2017.3.3). To tell you the problem right away: At least on my Windows 10 system the Flow process keeps dying *a lot* when there are errors. No property "foo" in type "TimestampAndHash": https://i.imgur.com/6qz0WwU.png The async. function resolves with a string, not a number: https://i.imgur.com/O8rnwMK.png
[removed]
Just picked up Vue for a project. While there are things I'm still on the fence about, and a few things I don't like, it's hands-down better than Angular. I really appreciate the simplicity of it and how it can easily be worked into an existing application with no overhead.
Reddit: Where you come to read opinions you already have. Of course people who like Vue are going to read and comment on an article about "how great Vue is." Kool-aid responses so far. Wonder what meaningful dialogue can come out of this post.
Three whole modules. A module every year on a specific subject is more than you get for most topics. I’m surprised you don’t know that, or maybe you were just looking for an excuse to be sarcastic. Define competent, remember we’re still talking about a graduate here. So we agree on AWS-like stuff, I’m not sure how someone can make it through a CS degree without encountering networking before though. That’s pretty mind-boggling to me. Did you not get taught about computer networks in your degree? No offence, but your course sounds terrible. I did my grad scheme at a big 4 company and it was expected knowledge, maybe at an agency or somewhere similar you might get a pass and have your hand held a bit... At my current company if I was interviewing a grad and they claimed to know nothing about that I doubt I’d hire them, what other fundamental things did their crappy CS course leave out?
then you just need to append a space to the end to show the implied grouping, (string2 + " ").includes(string1 + " ")
Funny that it should critique JSX on "burring the line between HTML and Javascript" - that's my main objection to the use of templates for virtual DOM. When I'm working with JSX, I am very aware that I am basically creating Javascript objects - no HTML is involved at all, because React in my case is responsible for manipulating HTML. (This is assuming that Vue templates do still use virtual DOM.)
here is what i am doing: in constructor `this.state = {... comments: null} // null by default` assign comments in `componentWillMount` so `comments = [...{}...{...vote:'up|down'}]`. I am rendering comments with `map` function and when a user upvotes a comment, i am doing `comment.vote = 'up'` but react does not rerender to particular comment object so i have to use jQuery to add a class manually. Hope this makes sense
Can you please just post the modified code?
Your main argument is that functional programming doesn't completely correlate to how computers read instructions which is partially true. The same can be said for OOP though, and it would be even more accurate. So now I'm using your same argument against OOP and suddenly that "wasn't your main point"? Nice try.
I don't mind either way and I hope a smarter prettier will decide this for me in the future.
I think a better way of explaining he merits of Vue is that you can use JSX if you want or even plain render functions, but single file components provide a lot of value by making it really clear what is presentation, logic, and styling. For people who have never used a framework, single file components are the most natural.
I have been using knexjs for about a month now and I have been finding it amazing. I looked into objection after reading your comment, and I don't see what it is for. Knexjs allows you to define your tables and execute your queries and inserts and deletes. I don't see what this extra wrapper adds. Please inform ! 
I love it and i use it, i would just hope that something like react native with feature parity would be built. I have heared of weex but its much a chinese thing for me.
I'll bite! Despite being a "fan" of Vue, here's my issues with the article: #####3. Vue as the new jQuery To say Vue is the Led Zeppelin to the jQuery's Beatles is a huge stretch. Vue is far from being that ubiquitous. Vue, despite being simple in a lot of ways, is not nearly unopinionated enough to say "eh, just slap Vue on it" on a whim. I'd argue that a library like hyperapp or a JSX-centric framework like Inferno might be an almost acceptable equivalent. #####5. Virtual Dom As stated in the author's own point, this isn't a unique thing about Vue. In truth, the concept of a vDOM is the reason these frameworks exist in the first place. vDOMs are awesome, and I can't wait for the gold rush that's going to happen when WebAssembly becomes widely supported. The performance gains of having a vDOM/diffing engine written in C/C++/Rust will be incredible (and incredibly small!). #####7. Vue CLI Vue's CLI is pretty great and I think it stands alongside Ember as the gold standards of framework CLIs. However, getting a "true" full-featured full-Vue setup isn't really possible with the current templates they've using. the PWA template gets close, but it still doesn't scratch the frontend itch of someone used to fleshed out backend frameworks like Symfony or Django. For example, none of the default templates come with baked-in support dynamic meta tags, which is pretty crucial for someone hoping to create a "real" website. For that reason, I'd say [Nuxt.js](https://nuxtjs.org/) is the true `vue init my-project`. It's exactly as minimal as it should be for someone new to Webpack/Node/Vue because it keeps most of the "scary" stuff tucked away, sets a good convention that doesn't need tinkering, but configuration is still accessible for the more experienced. #####10. Not maintained by a single corporation Honestly, while I appreciate its quasi-grassroots feel, I overall consider this one of Vue's biggest problems. For as great of a solution Vue can be, the ecosystem's endorsements are very limited. The support from Alibaba is great, and the fact that Vue is in production use on Medium and Gitlab is fantastic, but none of that has translated to widespread real-world use. There's 1000 React job listings for every Vue.js listing, and I think the biggest reason is that you can't sell Vue to upper management on "it's made by this really smart guy guy instead of Facebook!"
TypeORM is great. I made all my business models and then I annotated them. If you need to have your database structure for different than your model structure, you can make all your database fields private and use getters/setters. And you can also use converters which are an annotation as well. I would only use Typeorm for personal projects but it's going to be production ready soon. Technically it already is, though 0.2.0 will have a fair amount of changes. Knex by itself is sufficient if you write your own serialization/deserialization methods. Or you can use getters/setters in a smart way. class Person { private _birthday : string get birthday() : Date { return new Date(_birthday) } } and if you're using Knex then you can use interfaces as well. 
Yes. You are right
Nope, my main argument is right here. &gt;I think it's better suited for developing applications or doing Computer Science related work. You're choosing to ignore it.
That's very true, at certain levels any piece of knowledge can become important again. But if performance is the problem, you should also know about monomorphism (and avoiding megamorphism), but I don't see *that* being mentioned in many articles touting JavaScript interview questions :p
It's a marathon not a sprint. You won't be better than average tomorrow or the next year. Learn a little every day. Do hobby projects, read books, blogs or whatever works for you but try to learn new things and improve. Little by little you will be better than average. Also don't compare yourself to others. Compare yourself with yourself one year ago. 
I'm feeling unreasonably offended by that statement, and I shouldn't be. I perfectly understand my limitations, as compared to people who have studied programming during the decades that I've been *doing* programming. I've forgotten more programming languages in the last 36 years than I am fluent in right now. I've operated in 7 different languages in a single project simultaneously. I've contributed to many different projects over the years, ranging from the Linux kernel, to GTK, to GNU, to tons of random javascript libraries, and many more. I've been on the teams of a dozen different released video games, and several more that will never see the light of day, thanks to publishers de-funding projects. Code that I wrote in the 90's is still in active use today in places. Yeah, I didn't go to school for programming, back when I was college-aged, our only choices for anything computer related were "RPG", "COBOL", "BASIC", and "Learning VMS", despite that the entire planet was using C and picking up C++ at the time, and the world wanted Unix and Windows programmers. But I spend a lot of my free time writing and studying code. Until, 10 years ago, a game studio randomly offered me a job out of the blue, I didn't consider myself even good enough to be profressional. Turns out, I'm more than good enough. Many people that I've worked with have praised me as a fantastic developer, praise that I tend to feel I'm not deserving of. With 36 years writing code, I still feel impostor syndrome. My output speaks far louder than what I'm able to describe. Maybe that doesn't make me an expert in your eyes -- hell, I'm not even an expert in my own eyes -- but my breadth of knowledge and experience in *doing* these things makes me a valuable asset. 
I challenged your statement because I know it’s not valid. Pure functions are indeed part of functional programming techniques, but are not the whole, as you implied - which I though was misleading. You were then unable to demonstrate your point, which with your volumes of experience, should not be beyond you IMHO. But don’t worry about it, it’s just reddit.
Have you ever done any Tumblr-related dev? Of course JS is allowed.
Read,... everything. Learn the concepts of functional programming and how Javascript relates to languages like Lisp and Scheme. When you write code, write it as if someone with half your know how has to read and fix it later. When you come across an intresting article on this subreddit take an hour or so and read the whole blog site for more information. Even if you are just scanning it. Google everything, and get good at using search engines in general. Its ok to cheat.
Yeah, you can add JavaScript to a custom Tumblr theme - have you ever built/are you building one of those? If so, you could wrap the Body of each post in a special class, and then on document ready you'd select all elements that match that class, search them/their child nodes for words that begin with `@` (regex would be useful here) and then replace the matched word with an anchor tag. There's a basic solution to that [here](https://j11y.io/javascript/replacing-text-in-the-dom-its-not-that-simple/) Currently on a phone so can't really draft anything out, but if you get stuck with that please let me know!
When you're first learning the language `!!` can be a good escape hatch, I guess, but really you're doing yourself a disservice. IMHO it is MUCH better to understand the language you are using than it it is to constantly blindly coerce variables into booleans because you don't understand what's going on. In your particular example `!!a &amp;&amp; !!a.username` will always be identical to `a &amp;&amp; a.username`. There is literally never a reason why you would need `!!` there (all `!!` does is coerce the variable into a boolean, which is exactly what Javascript itself will do anyway the moment it sees a `&amp;&amp;`). So yeah, instead of just using `!!` without understanding things, I strongly recommend reading an article or two about type coercion in Javascript. But I feel you on your team's (equally blind) JSHint adoption. For one thing, I feel for you because your team is still using JSHint in 2018 when every shop on the planet uses the superior ESLint and/or Prettier. But I especially feel for you having to deal with the indented parameters; ugh!
It's a pilot episode so tell me what you think ;)
jQuery was also mainly one dude right?
Your last point brings it to the point. Besides that, my other concerns are not technical nature. Even though it looks very popular (according to the stars on GitHub), I don't see it all used on websites, even worse on big players. I have React and Vue Developer tools installed. React is used by: * facebook and instagram.com obviosuly - the latteris an entire react, * reddit (new mobile app &amp; new user page) * khanacademy.org - which has John Resig (the original author of jQuery) on his developer team * airbnb.com * netflix.com * paypal.com and not only websites but apps as well, for example the vivaldi and brave browser are built with react. Even mozilla is using it in firefox e.g. on the about:newtab landing page. Vue.js is used on [alibaba](https://www.alibaba.com/), [baidu](baidu.com) - but even though I believe that and I'm not familiar with their websites, I can't find a page on their sites that actually uses it. Lastly there is [gitlab](gitlab.com) and [facebooks newsfeed](https://newsfeed.fb.com/welcome-to-news-feed?lang=en) - yes facebook useing vue.js in at least one of their projects. :) Second big point is react-native, which is also used by a lot of big companies compared to Weex. Both points are non technical and I know this is a technical subreddit, but I wanted to point this out. Maybe someone can enlighten me, that vue.js is almost as popular as react - not only on GitHub stars but also in real world applications.
Hi /u/froesfroes, For javascript help, please visit /r/LearnJavascript. Thank you!
It's hard to say this without being a dick but my time isn't free, you don't seem particularly invested in making it *easy* to help you, and if you can't be bothered to try to help yourself, I can't be bothered to help any more either. I'm happy to *teach* you how to do this job (because teaching programming is fun and programming is a useful skill that I think everyone should have some small familiarity with), but I'm not going to just solve an apparently never-ending series of problems for you that you can't be bothered to work on yourself. You may not realise, but you're actually being pretty presumptuous now.
&gt; I think the biggest reason is that you can't sell Vue to upper management on "it's made by this really smart guy guy instead of Facebook!". That is true. Instead, the developers at my company were able to sell Vue to upper management based on its merits and ability to keep our developers moving in a productive path forward. All of our stuff is in Angular 1.x, and we have a pretty wide skill-level gap between our worst and best developers. So, we needed something for our developers that is up-to-date, performant, and easy to learn and work with given that skillset delta. We aren't about to switch our whole stack to Typescript so Angular is out. Between React and Vue, Vue looks a lot more familiar to our developers since our stack is currently Angular 1.x. So, for us Vue was a pretty natural fit. Some small-scale POC and production apps using Angular, React, and Vue confirmed that for us as well. My company is in the top 150 largest privately held companies in the United States, and I believe we have over 100 developers at this point.
Interesting, haven't heard of it before. Thanks for sharing. However, I'm using Angular so I don't want to mix and match frameworks
&gt; I realize how little I know You should feel this way for the next 10 years, at minimum. If not, learn a new language or environment. Or if you’ve only used web frameworks, write a web framework. Or if you’ve only used a compiler, write a compiler. Go one level deeper.
Thanks, they seem to organize the code in a similar way
I feel like I got off on the wrong foot here, being entirely dismissive. It's a trait I'm trying to squelch, but I don't do so well on it sometimes. So, I'd like to elevate beyond that low point. You're absolutely right -- I should be able to more clearly define many things -- it's why I'm absolutely 100% positive I'd make a terrifyingly bad teacher. So, I'm curious to understand, what -- explain, or provide a link that you think does a good job -- would the information that you'd be looking for, to answer a question like that: What is functional programming? or.. What points make up functional programming? How might you even phrase that question, and answer it? Because one of the things that I often struggle with, is trying to explain things that I feel like I've absorbed and just understand instrinsically, without specifically studying them -- and it leads to conversations with people that go something like "How can I learn to program?" .. "I'm really not the person to ask about that, because I started learning when I was 5 years old, and you can't just pick up a magazine and learn to write from that, anymore, so I have no idea where someone would begin". . . . and then to conversations such as this, where it appears I have no idea what I'm talking about, meanwhile I'm thinking "it is such a basic level thing, i don't even know how to explain it". 
And I could have added to the "I also love Vue!". But I instead provided a criticism to the same comments being posted over and over again (in every Vue thread?). Just irked. Which comment is the lesser of two evils, that's up to interpretation. 
See, underscore character might not be the pretties, but putting methods on built in prototypes is a really bad practices. It might bite you back only on rare occasions, but when it does, it bites back _hard_.
So...should I learn React first, or Vue? And yes, I know JavaScript. ;)
Are you actually calling `setState` with the updated comments array? Just doing `this.state.comments[n].vote = "up"` won't work - React doesn't know that anything's been changed. Instead, what you need to do is call `this.setState({comments : updatedComments})`. Ideally, the new comments array should be created using immutable updates, rather than directly modifying the original array and its contents.
Perhaps you've confused me with someone else you were discussing this with? You seem to be making several incorrect assumptions about me and my own background in that comment. In any case, the fundamental issue I think we're talking about here is whether a new starter with a degree is significantly better placed to begin a professional development career than someone self-taught. I stand by my claim that while a good degree in CS or similar certainly provides some useful background, it's not vocational training and doesn't give any useful guarantee that a recent grad will hit the ground running in a way that someone self-taught could not. If anything, I think you're making this point for me with your arguments about networking. You didn't mention the specific course you took or how long its modules are, but in terms of hours of full-time work experience, those three modules would be equivalent to what, a week, maybe two? It's not nothing, but it's not enough to be diving in confidently with professional-level network programming either. And crucially, I wouldn't necessarily expect someone with a formal qualification like a CS degree to pick up what they're missing faster than someone who'd been keen enough to write their own game or chat app or whatever and picked up some basic network programming skills to do it. You can do a lot with someone who's enthusiastic enough to figure this stuff out for themselves and had (presumably) 3-4 more years to do it while our other hypothetical developer was studying for their degree.
Absolutely disagree! Nothing prevents you from redefining underscore method in the same way you would redefine native code prototype method. Also, if you overwrite any native prototype methods - you probably know about it and have a reason to do that. Most people in their projects don't do anything sophisticated with prototype chains so my approach will look neat and clean in their code. For the rest I have an issue tracker on a Github. As I said - the project is actively supported and any reasonable "change request" will be addressed. 
https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/ch1.html
Also makes debugging easier, if you've got readily available variables to read from rather than expression to execute.
Absolutely. Just use a function!
How else would you render a list, though?
Jwt can only verify the identity of the user, so it can be used to send data securely but if the client is bad, it can setup the connection anyway it seems fit. Https is only good for end to end encryption, if one end is comprised the data can still be sniffed for example when the client uses a SSL proxy tool like burp. A developer can make it incredibly hard to fake a user client but perfect just does not exist in the realm of software and computer code.
React first. 
Just curious, why?
Learning templating frameworks is throwaway knowledge. Come Vue 3 and you'll scrap half of what you learned about observables again. With React you learn how to use javascript and es-next, the knowledge isn't for nothing. It is also easier for a beginner to learn, grasp and memorize. There's maybe half a page to read in order to know React. there are at least 50-70 pages of Vue until you are proficient.
Almost anything can trigger almost anything anywhere ;) Here's a simplified example using onmouseenter and onmouseleave on one element to trigger changes in another element: https://jsfiddle.net/jonahe/ycqkjfpk/
By writing a loop to generate multiple components and keeping the actual components free of logic that can generate other components. 
As a react lover, this vue code just looks bad and completely turns em off. Feels like a step back in every way. 
Can't read the article. Downvote and move on.
I disagree, Vue works just as well for building full blown apps. React can also easily be mounted on an existing node to add additional functionality.
Absolutely, but the complexity becomes unmanageable quicker when using Vue in that instance, and the overhead is much greater when using react in that instance... horses for courses, as I already said. 
I’m curious to know why you think Vue become too complex as a full web app
Inside your last one: if (url.includes('/embed')) { if(/*check to see if url already has a question mark in it*/) { url += '&amp;autoplay=0'; } else { /* Code to append the autoplay parameter with a question mark instead of an ampersand */ } }
Inside your last one: if (url.includes('/embed')) { if(/*check to see if url already has a question mark in it*/) { url += '&amp;autoplay=0'; } else { /* Code to append the autoplay parameter with a question mark instead of an ampersand */ } }
just time. Your average or slightly below average developer puts in an 8 hour day and goes home and doesn't think about development again until the next day. Nothing new is learned unless its during work hours. On your own time learn new stuff and research. Find a new tech that solves a problem at work. Learn how to write clean code (or cleaner code). Learn a tech that looks interesting just because. Learn some security best practices. That will put you above average.
bump
You typo'ed `dialect`
Sure sounds like a handshake error causing typo to me :)
ha... ha...
It probably doesn't matter.
That sounds rough. From your description, it may indeed be that web dev isn’t for you. React is relatively simple, so if you are struggling with that, you will have serious problems. I learned traditional software development at college in C and C++. Then I applied those problem solving skills to web dev, reading and learning all the time. There were times in my academic career when I was the worst engineer in the group, and my contributions were limited, thoughthat was partly to do with analysis paralysis and fear of failure. It was only when I was finishing up my Masters thesis that I had a breakthrough and really started to understand how to make quality software and solve problems well. I believe that the best way to learn is to have a concrete goal. What do YOU want to make? Is there software that, if you made it, would save you time on something? If so, go out and make it. When you get stuck, learn just enough to get unstuck. Worry about doing it “right” later. If you are just trying to get a good career and are not naturally gifted in software dev, the industry’s speed and difficulty is probably not for you.
Add an event listener to the.object to look for mouseover and make a function run when the event occurs to.change the background. 
&gt; Fuck motivation, develop a work ethic Without motivation you'll do nothing, buddy. 
It doesn't work even though I did it according the code you gave me. Here is what I have: if (url.includes('/embed')) { if (url.includes('?')) { url += '&amp;autoplay=0'; } else { url += '?autoplay=0'; } }
The difference is that if two of project dependencies mess with underscore in non-compatibile ways, or simply uses `window._` in a different way, a fix is usually almost trivial - underscore even provides methods to make it easier. But if one of your dependencies needs Array.prototype.dedup with different behaviour than vertibars, you either drop it, or vertibar. A real life example, old releases of ServiceNow couldn't load newer versions of AngularJS because it loaded prototypejs which modified one of build-in objects. They only way out was to drop prototype. This might sound like ancient history, but it doesn't happen anymore specifically because library authors learnt not to do what you did - the hard way.
It's all contextual. If you're looking at it through the lense of a software engineer (focused on data structures, efficiencies, reusability etc), Vue is a bit sloppy and unorganised at large scale, leading to a higher cognitive load when trying to build a mental model of the app. React on the other hand componentizes the model a lot more efficiently. Also, Vue doesn't always necessarily become to complex, it's all relative to the type of app your trying to build.
&gt; I want to know based off this if i am too slow/dumb to realistically become a web developer Unlikely, It sounds to me that you lack motivation. Self-doubt can eat motivation as well. This type of work requires a certain stubborn self-confidence. A reasonably intelligent person should be able to understand the principles (js, html, css, some framework) of front end webdev -- same goes for backend. It's not rocket science. 
I would look into how `rxjs` used to add features/operators to the `Observable`. It was *something* like this. import { Observable } from 'rxjs/Observable' import "rxjs/add/operator/map" Where map was close to Obsevable.prototype.map = function map(){...} ie, "monkey-patch" the prototype with extension imports. 
There are two basic ways to get stuff done, motivation and discipline. Long story short motivation is fleeting... yadda yadda look it up if you're interested.
That's weird - it certainly looks like you got it exactly right. What do you mean when you say "it doesn't work" - are there any errors displayed? What behaviour do you observe vs. what behaviour do you expect, etc?
That's weird - it certainly looks like you got it exactly right. What do you mean when you say "it doesn't work" - are there any errors displayed? What behaviour do you observe vs. what behaviour do you expect, etc?
Isn't jQuery good though as it speeds everything up?
There is plenty for enough advice!
I kind of guessed it wouldn't be the best for everything don't worry about that. 
...no. jQuery is 80kb for functionality that can largely be replaced by const $ = element =&gt; document.querySelectorAll(element); ...for common uses. jQuery was never meant to speed up anything, only to smooth over browser inconsistencies which have mainly disappeared.
&gt; these days That's great thing to know actually, I see it all the time to when people ask why something doesn't work. After learning a bit more of JavaScript I will look into debugging.
&gt; Th That's actually really helped my confidence out a lot now as you say many senior developers even google for help. 
&gt; your learning Il do the To-do list now. 
il check those websites out.
I think w3schools is not to bad, But it's not helpfuil at all.
&gt; Having to define custom get / set functionality, per target, purely to avoid a dislike of the automatic naming is not exactly ideal. That's fair. In case you are not aware, this library is made by the folks at Basecamp, which is a Chicago-based company heavily tied to Ruby-on-Rails. (considering the creator of Rails, [DHH](https://twitter.com/dhh), works at Basecamp) I may be wrong, but I believe that the way they use the naming comes from the somewhat rigid [naming conventions of Rails apps](https://gist.github.com/iangreenleaf/b206d09c587e8fc6399e). Based on my own experience using Stimulus before they implemented the `static targets = [ ... ]` field, (and using `get`/`set`) they likely did this so one would not have to explicitly write those types of methods, and so you could keep your code fairly DRY and not using `this.targets.find(...)` all over the place. &gt; Do you know of any decent quick start / hello world sample projects I could download? I made a simple ToDo application using it: [here](https://github.com/geoffdavis92/stimulus-test). Again, this was pre-official-release, so the API may have changed. Also, I implement a state helper function that is separate from the Stimulus library.
Yea I wouldn't go on stack overflow I see a few comments there and I believe it's full of devs who thinks they are a know it all :D
With FreeCodeCamp all I see is some html shit that I already know.
Yea I'm going to be getting javascript books to see if that's a easy way to learn.
Angular can be written in JS, but the code ends up being pretty messy and most example code uses TS and annotations. As far as bringing Typescript into our local tooling and stack, we just don't care to add yet another piece of technology into the mix at this point. It's less about TS's capabilities and more about preferences within the organization at this point.
I dislike the kool-aid metaphor. Using a web framework which I like based on my daily experience of convenience, time saving features which help me manage complexity and excellent documentation are not the same as drinking poison based on un-verifiable statements about the afterlife which I do not have any experience back. Comparing programmers who like a specific tool to cult members committing mass suicide based on unverified beliefs / brainwashing is not constructive. Could I lighten up? For sure. Could we use more appropriate metaphors? I hope so. 
Thank you, This will be useful.
&gt; eant When I heard someone say it's faster to program with jquery it's because you can do 5lines worth of javascript in 1 line of jquery. 
I knew it was the same language, I have hardly used any jquery. So I wouldn't 100% know I'm just going off what I seen in introduction videos to jquery.
Again, jQuery is old hat and terrible for writing apps, so keep that in mind.
While embedding Vue in an existing page is a feature and perk of the framework, it's really intended for full-blown single page applications. From my position VueJS completes well against React for SPAs and I can see benefits to both sides. Both allow extreme freedom in setting up your application so can be as complex or simple as necessary. React's mobile options are a huge plus and can be seen in the market. Companies are adopting React knowing they can leverage it to build both their SPA and their mobile app.
From my experience yeah that seems to be most of Udemy lol 
More job opportunities at the moment. 
I'm seeing this more and more. VueJS is the best upgrade path from Angular 1.x. Given the number of websites on Angular 1.x this could be a huge install base. I feel like Vue should start marketing itself as that logical upgrade and putting out tutorials, videos, and white papers.
Any ideas?
Thanks
have you tried looking at jinqJS? it's SQL for javascript, you can groupBy and aggregate values in arrays.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
So you advise to not use it?
I absolutely advise not to use it if it can be avoided.
&gt; I also like the short-bindings provided by Vue, ‘:’ for binding data variables into your template and ‘@’ for binding to events. It’s a small thing, but it feels nice to type and keeps your components succinct This is a very minor point but one that irks me. syntactic sugar is nice, but if thats a selling point you are saying you don't care how your component is designed as long as the tag is short. Its like when a friend of mine discovered the ?. operator in C# and decided it was great becuase he didnt have to nest if statements so much. You are using syntactic sugar to hide a code smell its not a selling point. &gt; 9. Easy to get help Last time i tried vue I had a horrible time finding the right answers. The split between v1 and v2 was awful. &gt; 10. Not maintained by a single corporation Perfect, a huge single point of failure. One of the reasons it won't touch production at my job. 
So much this ^ &lt;ul&gt; &lt;li v-for='number in numbers' :key='number'&gt;{{ number }}&lt;/li&gt; &lt;/ul&gt; Every time I see a thing like this I have PTSD flashbacks about dealing with ng-repeat in Angular.
It doesn't show up in the GreaseMonkey menu as an active script on http://www.siliconera.com/2018/01/30/square-enix-shares-improvements-project-octopath-travelers-demo-feedback/. EDIT: Its because its only including *youtube*. Would switching it to work on * cause any side effects? Oh, and another issue I've noticed is that it is redirecting Google, etc. search results that have the word Youtube in it. Maybe changing it to include just * will fix it...
I was feeling the same way. Going to dive into it after I finish a few projects.
Lets assume you're not dumb. Unless you're picking up signals in daily life that do point in that direction ;-) Even the most intelligent people will never learn how to code if they lack: 1. self motivation and interest 2. being relentless (like in: "I will NOT give up until I understand this and won't forget") I recognise the struggle to become a better developer. I only started programming when I was 30. The first five years were tough. I always noticed these huge gaps in knowledge compared to other developers. Most of the time I couldn't even follow discussions about programming. What really helped me: 1. I learned how to type FAST with 10 fingers blind. Really, it's important! 2. I started memorising the syntax of Javascript HTML CSS with spaced repetition software (ANKI) It annoyed me that I always forgot most of the stuff that I learned from books. So now, whenever I read something new, I put it in ANKI and repeat it until I can blindly type/burst out code snippets without hesitation. Objects, Functions, Classes, Prototyping, Arrays, Programming Patterns, html tags, css props etc etc etc. When you know syntax by heart, a lot of abstract concepts will start to look a lot easier. Try to spend one hour a day with a programming book. Put little code snippets in ANKI and start repeating them. Be relentless for 3 months. After that evaluate yourself. At this point you should be able to come to an easy decision. Programming to me is like learning a foreign language. It's difficult, it's tough, and it simply takes a lot of practice and perseverance. If you don't feel a certain "addiction", you'll never learn how to write/speak it properly. 
This is true and somebody has raised a proposal for this. I don't use classes myself, so this is something I easily over look.
I've managed to fix the issue with Youtube as a search word causing continuous redirects by using the following includes: // @include https://youtube.com/* // @include https://www.youtube.com/* // @include https://youtu.be/* // @include https://www.youtu.be/* By the way, I mentioned the buffer parameter to the developer of HookTube. He asked me why I wanted it and I stated because I (when on my Hotspot provided by Freedompop) and others have bandwidth caps so the parameter would be nice to have. Hopefully he'll implement it and the rest (or most) of my other suggestions soon.
Let's say you're making an application. You have data you retrieve from the server, and multiple containers in your app where the data goes. Depending on what you do with the data, different things show, and user interactions will trigger changes in data. In jQuery, you have to write the logic for getting and storing the data, and then manually write listeners/logic to handle changing the DOM to show the data. The more complex the app, the more ways jQuery elements might be affected by others, the more code you have to write. Basically: 1. Handle data manipulation. 2. Create the initial DOM. 3. Handle DOM manipulation based on data changing. When using an MVVM solution (like React), you only need to define how to manage the data and write the UI portion. The UI portion will automatically react (get it?) to changes in the underlying data, so your workflow is more like: 1. Handle data manipulation. 2. Create the initial DOM. The removed third step vastly reduces complexity for anything other than tiny applications. 
&gt; Learning templating frameworks is temporary knowledge I actually addressed this fairly recently in [The State of JavaScript in 2018](http://www.breck-mckye.com/blog/2017/12/The-State-of-JavaScript-in-2018/). In essence, I argue that churn has slowed down, and the time has returned to invest in monolithic frameworks that trade transparency for productivity (e.g. in the form of templating languages).
I can sympathize with your points. However, I disagree with the last one. For me, working wtih Vue.js was made much more wonderful with ES6 features. Features like object spreading, arrow functions, and new array methods save a ton of time and cut a lot of would-be time sinks into computed one-liners. The next version of Vue also intends on using [ES6 proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) which removes IE support in exchange for a significant performance boost and a smaller/simpler codebase. I think your point really boils down to functional vs. OOP style more than language features. Angular is about as good as MVC/OOP can get on frontend right now, but I'm personally happy with the functional bent of Vue.
Yes, that's mostly correct. However, what I'm saying is not that you can't use ES6 with it - those are syntax features that are useful in almost all cases. I'm saying that Vue doesn't leverage features like classes to handle instantiation of components, where it could and IMO should. Depending on the API provided to developers, proxies might make it look a lot nicer, but I'm not invested enough in it to really care. I don't think Vue is more functional in any way (it's still very much OOP).
Most of these answers are correct about not trying go too fast, but one direct way to get better would be to understand the full stack. Learn SQL, MongoDB, Node, Express, even .NET. You will learn just how much more there is than just front-end JS this way.
Cool - nicely done!
All of the code involved can be extracted out, but it's going to be quite long code, and you'll have to recreatea number of different things, like a mouse event handler etc.
what's so hard about ng-repeat? It's the same for loop as you'd write in JSX. If you have performance issues in one, you'll have the same perf issues in another. Just have to be mindful about the code you're writing
While in the end, `a` and `!!a` accomplish the same thing, I find it handy that it returns a true or false value. Which makes it easy when you are debugging values and makes it clear that I want a boolean there, not its actual value. In Angular 1 you also had the `angular.isDefined` function which basically did `typeof &lt;value&gt; === 'undefined'`. There are many ways to get to the same point, but overall I feel that !! is the most reliable. I can't remember where I saw it, but there were instances where it was better to use !! instead of the value alone. But it was so long ago that its hard to see what it was and if stuff has changed in the meantime. I vaguely remember angular templates not doing the same comparison which kind of rubbed it in to always use it haha
Took the words right out of my mouth.
Thanks. Is it okay if I mention you in the userscript as a contact in case of any bugs, etc?
Speak for yourself, but I work on a very large React app at work and I find it pretty terrible to reason about. HOC’s and recompose everywhere because React people seem obsessed with trying to make things prematurely reusable and decoupled. Trying to follow the props up and down (because Redux is bad apparently) takes up half my day these days. I find Vue embraces a more sensible and pragmatic approach to components and encapsulation, and I find them much easier to reason about in big apps. 
learn the basic i guess, it helps you in the long run while learning the framework. It also depends on your learning capability. I also suggest you read codes from open source projects and try to understand them.
It's funny you say that because the js subreddit feels like a react echo chamber filled with people who are only stoked about react and have nothing but horrible things to say about yesterday's libs and frameworks like jQuery and angular. 
To continue the circle jerk of course 
I dislike any framework that has complicated abstractions over the host language constructs like control structures and ability to reuse existing data structures. There's really no reason to use markup and it's complicated variations anymore as all language providers arrays and objects which can more easily be converted to markup and allow the entirety of the host languages capabilities when constructing and composing markup objects. Libraries like hyperscript and hiccup realized that data structures and functions do a better job of creating markup than markup and its overcomplicated variations are much more efficient and scalable. React at least allows simple escaping to a JavaScript context to be able to use all the language and create components. But vue made a huge step backwards to an angular level
&gt; better than Angular. not a very high bar :)
Doesn't matter how good the error reporter is when the actual errors that are reported are difficult to understand, or reported in the wrong place altogether. Flow's default error reporter is fine. In fact it's better than most other type checker and linter. The problems with Flow isn't something that a new reporter can fix. 
I'm new Here, can someone explain why using vues templates is better than using jsx? I thought the point of using a JS library like vue and react was to have JS render your virtual dom. Why is vues html like templating system better for keeping JavaScript separate from html when the point is to use JavaScript to write html?
Thank you for the information, I will definitely keep your advice in mind just in case we encounter problems with regards to this,
No wai!? I shouldn’t just trust user input blindly and update objects at runtime with no sanitization?
You should know enough about computer science to be capable of articulating the difference between a library and a framework then defend your assertions if challenged. 
CS degree, do front end more than I’d like to. You’re not wrong about lack of front end tech in the curriculum but general best practices from a CS perspective are applicable to all aspects of development, security especially. Having taken a good amount of security and security adjacent courses, I have a pretty good sensor built-in to detect when something on the front-end side feels “icky” 0.02, though, YMMV.
I prefer to look at it as a clean separation between the different bits of presentation logic. Basic control statements within the HTML are fine. It makes everything obvious and clear what is happening and frankly, a list is &lt;ul&gt;&lt;li&gt;....&lt;/ul&gt;. Why write it in a more convoluted way? Vue's syntax is quite limited, and that sort of logic makes sense where it is. Vue components are presentation logic. The &lt;template&gt;, the &lt;script&gt;, are just different parts of the same logic, and Vue's presentation of it is quite nice and clean I find.
I've been thinking about this a little more and it's still bugging me. Coupling is the wrong word, but I still don't understand how it's not bad form to throw the responsibility on to the parent. Let's say I have a generic list component, and it can also collapse/expand. If I made that a prop, that's fine...but what if I have 5 lists on a single parent component (page). The parent needs to have 5 state properties to track the collapse/expand state of each list? I guess if it were all functional, we'd eventually work our way back to the root component and end up with a single store solution ala redux. I guess in my example, the list wouldn't be a functional component, because it has state (assuming it has internal UI that could change that state). But I feel like I see a lot of push for functional components in similar examples.
`` ?
And according to that logic, jQuery is better because it's used on more websites. Vue is just in the middle of the rest of the frameworks and never really picked up a ton of momentum because of Angular and React. Popularity shouldn't matter in determining a framework. If you have any ACTUAL reasons why it's better or worse, then by all means tell us.
Vue has JSX if you prefer it. I know it's hard for you react guys to do research on your own, but it would've taken you only a few minutes to figure that out. 
I'm guessing you've never visited the React subreddit then. 
So I didn't read the article but I've read the comments and I'm still a little puzzled by some of them. From what I can tell, Vue and React are conceptually quite similar and one of their main differences is Vue's single file component (SFC) vs React's JSX. But some of the comments are suggesting that Vue excels at somethings and React excels at others, without proving any examples. I personally prefer the SFC approach as I find it cleaner and more obvious. It has also proven popular amongst the graphics folks I work with who know their way around HTML and CSS, but can't necessarily code. But, those preferences to me are somewhat superficial. I've yet to see how Vue or React could be better at specific tasks. Both use the virtual dom, both abstract data binding as much as possible, both take the concept of UI components to heart, both adopt the idea of keeping all things related to a component close together (just in different ways), so I'd like to see some concrete examples of where Vue is better, or where React is better.
Jesus christ, do none of your react guys research anything before commenting? You can use JSX in Vue if you want. A lot of people don't prefer it though so they have another method as well. And honestly, it's fucking ridiculous how you people pretend like JSX is the answer to everything. Does it really matter if you need to loop over a single list and print out some data? JSX provides absolutely no benefits over something like v-for. It's just idiotic posturing. Tons of components will be dumb or simplistic and don't require the full power of JS to render them. Why is that hard to understand? 
You realize you're giving literally no evidence right? Vue by default is designed for apps so it seems as if you don't really know what you're talking about. 
Really? Is that why the react subreddit has people asking the same questions every single day and getting different answers from everyone? You people like to talk up React like it's simple, yet none of you can ever agree how to actually solve anything using React. Also, AngularJS is supported through 2021. Claiming its throwaway knowledge is just fucking stupid.
No one is saying they're better or worse. They're simpler for when you want it that way. You can use JSX in Vue if you need it. 
It's not exactly currying — notice it's `.bind` on `.apply`, so it's more like regular use of `.bind` to set `this` context: function f(...args) { console.log('this:', this); console.log('args:', args); } f.apply === Function.prototype.apply; //=&gt; true f.apply.bind(f, f); //=&gt; function apply() Function.prototype.apply.bind(f, f); //=&gt; function apply() f.apply.bind(f, f)(); //&gt; this: function f() //&gt; args: Array [] f.bind(f); //=&gt; function f() f.bind(f)(); //&gt; this: function f() //&gt; args: Array [] Not sure why it can't be just `.bind`, maybe there are some optimizations that only kick in for native code?
Just wait for the medium.com post about how this is JS new "This is the Light: The One True Way".
i'm enjoying vue thus far but yes, `new Vue({})` seems kinda backbone era to me. aurelia makes good use of `class`es. there's also too much needless lingo with vue/vuex. `computed`, `methods`, `actions`, `mutations`, `getters`, `commit`, `dispatch`... there are [proposals](https://github.com/vuejs/vuex/issues/866) to cut it down a bit, though.
It's as first class in vue as angular. The primary tutorials and introduction video treat it as more of a first class concept than simply using something simpler as I've stated before. It's a complicated ui library where a lot of development is in that custom markup engine. Regardless of if you can do it or not, they're pushing that paradigm onto most of their users which I think is a fad that should have died with angular. 
&gt; The next version of Vue also intends on using ES6 proxies i would love that but evan you himself pointed out some pitfalls preventing that: https://github.com/vuejs/vue/issues/3020#issuecomment-223326589 i think these issues could be worked around given the effort.
React is easy, they're just bad devs.
You'd be wise to just delete this post before someone cares enough to point out the ridiculous number of reasons that's it's unforgivably ignorant .
The API provides an array of arguments to be passed to the callback, e.g. the API returns [a, b, c] but we need to call `callback(a, b, c)` So here's a couple ways to do it: `callback.apply(callback, data)` `callback.apply.bind(callback, callback)(data)` `callback.apply.bind(callback, callback).bind(callback, data)()` `callback(...data)`
Yeah, I just mentioned it because I stopped using it as a data point in interviews. I've hired and worked with too many people with CS degrees that were either bad or mediocre developers. I would never dock someone for it, obviously, but it doesn't impact my decision anymore.
When you know when to use a framework or not. If you rely on a framework with everything, that's when you're not yet ready. Imo, so take it with some salt
this makes sense. My concern is that there will be 1000+ comments loaded and not sure if i should re-render the entirety of it for this(meaning that the upvoted comment can have many replies to it). 
Yep. 3 years is an absurdly long duration for someone to be stuck on a learning process. 
You can get very far with just knowing how to implement these built in functions: Array.prototype.reduce() // can do both map &amp; filter Array.prototype.map() Array.prototype.filter() Array.prototype.from() Object.assign() Object.key() Object.hasownProperty() // something like that This should get you through hump day. The rest you can learn over time... learn how to use Promises.
Reading these comments makes me feel stupid. This is considered a ok syntax? 
You seem way angrier than this discussion warrants lol. People are allowed to have opinions, chill.
Forget about frameworks and learn vanilla JS. Build a project from start to finish. That way you can get some legs underneath you. 
`apply` is being used because the parameters `userFunc` should he called with we're passed through `postMessage` as an Array.
I don't know much about DataTables. What is the difference between using this and a relational db 
Assuming you already have a solid understanding of the js fundamentals. Try learning current best practices in ES6, and some more " under the hood " concepts. I've heard a the stories of people doing their whiteboarding interview and not being able to explain how var gets hoisted in a for loop.
Thanks 👍🏻
_ 
It's not strictly necessary. The main reason was probably backwards compatibility with [previous versions](https://github.com/developit/greenlet/commit/5b8fdbe5eeef97182d2cf4bb5dbc234a20b8c466) of this code. The `asyncFunction` you pass to the `greenlet` function will be invoked with `this` set to itself. If the second `userFunc` was left out it would be invoked with `this` set to the Window object (or whatever the global is in Web Worker context). I can't say why one is more useful than the other but it seems like they just kept the same behavior as previously in the latest commit that added that particular expression.
I'm in the process of changing jobs (long story) and am now free to use react. I absolutely love jsx (tsx in my case). The joy of having all my logic written in a programming language is incredible. Having JavaScript native array and object methods at my disposal is really great. 
Your best friends are going to be Array.prototype.reduce() Array.prototype.map() Array.prototype.filter() You should have the dataset being returned as an Array of objects === [{...}] 
Hi /u/DueDueProcess, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Most of the times `Array.prototype`'s map and reduce are more than good enough for transforming and aggregating vales, but if you're doing more advanced stuff I would suggest to go with lodash mainly because it has almost every utility one could think of and is really popular so you can get help easily if you get stuck somewhere.
That’s super useful!
This is a fantastic update!
It's not about perfomance issues, it's about not having to use some framework-specific trick to get stuff done. Also some things are just plain impossible to achieve with ng-repeat. For example, I can't ng-repeat table rows because it creates extra nodes that break table. Which prevents me from having a component that returns single table row (or cell).
Just in case you haven't yet, try to add some Ramda. It's pretty good itself and it's amazing when used with framework like React. [assocPath](http://ramdajs.com/docs/#assocPath) and setState are made for each other.
The vast majority are nags that the hash in an `href` contains `%` without hex values (hence, invalid escape sequences). The rest seem like minor oversights (e.g. duped meta charset, missing title, missing lang property, etc). JS error seems to be some bad file reference. Probably another oversight. &gt; Can we fix the situation? Yes, you can submit PRs to https://github.com/tc39/ecma262
Hi /u/js_chap, please just post the gist or project. Thank you.
sure 
The author is? &gt; [using JSX in vue] ... I don’t know why you would want to do that to be honest. For all that is good about JSX, there are some valid criticisms 
Hey, just my opinion based on the software I build. It's not a global absolute for every developer everywhere. That's what's awesome about humans, we all have different opinions. Have you ever built a multi-million loc app? 
Not really. Chaining apply/call/bind's is usually considered bad practice on the grounds of decreasing code clarity. The only reason to do this kind of thing is if there's some concern regarding memory allocations from creating a lot of functions.
There's no need to re-throw from a `.catch`. Doing so does the same as not having the `.catch` in the first place. Just catch in your component and handle there. myFunction() { api .doSomething() .then(this.doSomethingElse) .catch(this.doErrorHandling) } static doSomething() { return axios.get('/url') }
I like the cut of your jib.
Personal opinion here. I think what you saied is what average developers are. To be even better than that what should I do?
Eloquent JavaScript(Free and online/pdf): Eloquent Javascript(eloquentjavascript.net) As It is recommended by many experienced people. JS the good parts: another book recommended but requires some level of knowledge. Also, you can try JavaScriptisSexy’s Roadmap(http://javascriptissexy.com/how-to-learn-javascript-properly) for beginners. They have properly mapped out sections one should read from books and online articles.
&gt; &gt; &gt; Basic control statements within the HTML are fine. It makes everything obvious and clear what is happening and frankly, a list is &lt;ul&gt;&lt;li&gt;....&lt;/ul&gt;. Why write it in a more convoluted way? Haha, obviously I'm not advocated for making templates more convoluted - I do believe they would be unworkable without the `v-for`. That said, my experience is that templates mostly consist of logic, and hence doing it in proper Javascript actually makes it easier in terms of limiting context switching and reducing the learning curve. However, I would still indeed want to separate my presentation logic from e.g. data fetching, but you don't need a different language for that :)
For example with JSX: const listItems = items.map((item) =&gt; &lt;li&gt;{item}&lt;/li&gt;); const list = &lt;ul&gt;{listItems}&lt;/ul&gt;; In other words: using Javascript, the language I already know and am using.
All the Vue articles/blogs/docs seem to confuse or not understand the basic points - - separation of technologies is not the same as separation of concerns - Any custom DSL is fundamentally inferior to full native language support. Its like being asked to write a letter using pidgin/shorthand because its more 'efficient' - Vue can be just as complex as using the standard React toolchain. The e.g of including vue from cdn in html is only for trivial projects - when you start thinking in terms of immutable components etc is when you really see the power of React etc The good things about Vue are its opinionated and provides a single solution for router, redux stye etc, easier for new people to pick up because they don't need to think in components, and its positioned as less 'daunting'. The main use case for Vue is to add stuff to an existing app/site without modifying everything.
Yeah, just try and write it yourself. It's not that hard. It looks like jQuery.draggable just adds a bar (some element with position: absoute) for a draggable direction (so 4 for every direction). It'll probably be something like this: * Attach mousedown eventlistener to the draggable direction bars * on mousedown event, remove mousedown listener, and attach mousemove eventlistener and attach mouseup listener. * in the mousemove eventlistener, track the difference/delta of the x or y position and apply that difference to the resizable element. * on mouseup remove the mousemove listener. https://stackoverflow.com/questions/8960193/how-to-make-html-element-resizable-using-pure-javascript this is pretty much what you want.
Remember the time when everyone hated JSX? I didn’t get it, but look at us all now! 🎉
Dude, have you used Vue Cli yet? That’s a way to do a full blown SPA or PWA right there. Vue is not just for a little augmentation. Also, Nuxt for SSR etc. 
That seems like a lot of ways do one thing. Is this a symptom of how JavaScript is made, or do other languages allow for such diversity?
What does it matter what people say, most will simply confirm their bias and have probably never worked with the thing they criticize. Angular went through a full rewrite, and had you re-write your app from scratch. It will happen again. Come Vue 3 and you'll maintain two incompatible codebases because proxies can't be fully polyfilled. React doesn't have these problems. It deprecates some minor things maybe or adapts to language semantics, but its foundation won't change, because it is based on simple premise.
get inspired and then focus dude
This is just bad. But, if for whatever reason the function was: function userFunc (func) { return this === func &amp;&amp; this === userFunc } Then the syntax you provided would be the only way to make the above function return *true* 
https://stackoverflow.com/questions/24661774/createinterface-prints-double-in-terminal , looks like you need an extra option when you create the realine interface 
There is nice solution without jquery https://github.com/bevacqua/dragula But according to your wording, is it probably some test given to you and not question about what library to use?
Always be coding. Do a bit of code every day.
Done projects in react, angular and vue. Vue clicked right away. 
This is definitely not the average developer. The avg dev comes at 9 and leaves at 17:30 does his/her job and gets it over with. Reading blogs, books, etc., investigating solutions and trying to do the correct solution instead of the one that 'just works' is in my opinion more than the avg developer. I'm overseeing about 20 teams with devs working on specific features and integrating them in a bigger platform. Based on this I can say that if you're eager to learn and don't shy away of investigation instead of code-monkeying, I believe you're already more than the avg dev. 
I just want to take some time to say the spacing for this code is cancerous. 8 space tabs? Who would do such a thing?
Yes I built a large app in vue after doing something in similar in react. If I were to do all over again I’d do it in all in vue. Sooo much better. 
You might be doing it wrong if your getting stuck on complexity. Vue can get handle very complex apps. Can you give an example?
Just like FLow's [union types](https://flow.org/en/docs/types/unions/). Good that they're adding it, although I find Flow's way more elegant.
Stay away from JS sometimes. Learn other programming language, like C, and write something useful with it.
Vue is known to be easier to learn/docs better. If I could go back and could choose which to learn first I would pick vue. React/ang would be easier to understand with a vue base because it originally was developed mostly by one guy and has a clear and clean way of doing things. But as others have mentioned more jobs right now in react. Depends on your priorities. 
Script at the end of body was the workaround before the defer attribute existed. If leaving them there causes your sight to behave correctly for the 0.1% of your users on ie7, why not do it? That being said, in most cases defer is probably okay on it's own
It's *ES2018* ("ES9")
Yes! That's the point :) My experience is that templates are quickly rather full of logic, so if you're building your DOM programmatically anyway, it's better to do so explicitly. You say the reason you don't want much logic in a template is that you want to separate the presentation layer, but I don't see the inference? Yes, I want a separate presentation layer (so I can focus on that rather than data wrangling when working on the view), but with JSX my presentation logic is still separate - it's just in Javascript.
I have built applications in both react and vue. I'll have to entirely disagree that you need to read 50-70 pages of Vue doc. I found Vue easier to learn and faster to get started with than React.
 Again you can use jsx in vue if that’s your cup of tea, but I never liked it. mixing too much logic in templates is bad practice. Separating your view from data logic is key. In fact the simplicity of vue actually pushes you try and try write less logic in the template and try’s to opt for data driven approaches where logic is outside the template. template code is extremely readable when tags are tags . Js/html mixing does not read well. When I open up vue component templates I see nicely indented readable html . When I open jsx I see long lines of mixed html js. Just write a semi deep template in both and you will see a definite visual difference. 
That SO solution for example, just convert jQuery's methods to DOM methods. - Convert `$(function() { ... })` with `addEventListener("load", function() { ... })`. - Convert `$("xyz")` element selector with `querySelector("xyz")`. - Convert `$(object)` to just `object`. - Convert `on()` method calls to `addEventListener()`. - Convert `css("styleName", value)` method calls to element's `style.styleName = value`. - Convert `width()` method calls to element's `offset.width` property. - Convert `offset().left` method calls to element's `offset.left` property. 
I'm starting to see `async` and `defer` being used more and more While also keeping scripts at the end of the body, I think developers just got used to it after all these years
I don’t get it? Are the games just pulled from a DB or do you have the Tatooine API? 
From a brief overview, I have no initial negative comments. It looks well-structured and the code is readable and comprehensible. Congratulations on understanding this much so early! 
I find the last line pretty funny too. If you are looking for a more functional styled library, go for react or even elm. Don't do ue, it's essentially angular's little brother.
The point was never to 'use JavaScript to write HTML'. It was simply to make it easy to bind HTML output to data. JSX is one way to do that: functions can return trees of vdom elements, specified using an angle bracket syntax. Templates are another: describe a block of HTML, annotating elements that will change. The advantage of JSX is that it's very transparent: it's mostly just JavaScript. However, this comes with some tradeoffs: mostly the awkwardness of JS string manipulation, verbose expression syntax (ternaries etc.) and the general annoyances of binding functions. The advantage of templates, on the other hand, is that they make the outputted HTML extremely clear, and can come with nice DSLs to manipulate strings and CSS, but their tradeoff is that they need to be learned. Personally I find that acceptable: I'm happy to learn a new template syntax every few years if it keeps me productive. Others feel differently.
What you mean you're not a fan of beauties like this - an extract from a project I had open today? ``` &lt;Modal fadeBackground modifiers={['x-large', 'high-z']} onCloseModal={this.onClickClose}&gt; {isLoading &amp;&amp; &lt;Loader /&gt;} {!photo.published || !photo[IMAGE_SIZE] ? ( &lt;Error message="Could not load photo" /&gt; ) : ( &lt;div className="photo-viewer"&gt; &lt;div className="photo-viewer__content"&gt; &lt;Media showLoading image={`url('${photo[IMAGE_SIZE]}')`} modifiers={['16-9', 'dark']} /&gt; {photo.room &amp;&amp; &lt;h2 className="photo-card__title"&gt;{photo.room}&lt;/h2&gt;} &lt;/div&gt; {this.numberOfPhotos &gt; 1 &amp;&amp; ( &lt;FloatingContent modifiers={['left', 'high-z']}&gt; &lt;IconButton link="#" icon="prev" modifiers={['large', 'frosted', 'round']} onClick={this.onClickPrevious} /&gt; &lt;/FloatingContent&gt; )} {this.numberOfPhotos &gt; 1 &amp;&amp; ( &lt;FloatingContent modifiers={['right', 'high-z']}&gt; &lt;IconButton link="#" icon="next" modifiers={['large', 'frosted', 'round']} onClick={this.onClickNext} /&gt; &lt;/FloatingContent&gt; )} &lt;FloatingContent modifiers={['top', 'right', 'high-z']}&gt; &lt;IconButton link="#" icon="close" modifiers={['large', 'frosted', 'round']} onClick={this.onClickClose} /&gt; &lt;/FloatingContent&gt; &lt;/div&gt; )} &lt;/Modal&gt; ```
I wonder if native support for a virtual DOM will be supplied as a standard feature soon?
One reason for using a template is to not to have programmatically build out a dom. If you are stuffing templates with logic you might not be doing it poorly. But Yeah if you can keep excessive logic separate that’s ok I see no issue . But I think it’s very tempting to start writing extracode in the template, which I think will lead to trouble. A lot easier to do that in JSX. Here less is more. Vue actually taught me to think more data driven. Also this: https://medium.freecodecamp.org/reacts-jsx-vs-vue-s-templates-a-showdown-on-the-front-end-b00a70470409
Just to clarify (/u/lhorie implied this already), throwing errors in promise chains convert those errors into rejected promises. This is why try/catch doesn't work for promises, at least not unless using async/await where rejected promises get converted to thrown errors. axios.get('/url') .then(response =&gt; { throw "error" }) // promise chain becomes rejected from throw .catch( err=&gt;{ console.log(err) //-&gt; "error" } ) While `catch()` would normally be used to handle a rejection, by throwing inside of the `catch()` it re-rejects the promise.
A fair comparison would be the 'Essentials' section of https://vuejs.org/v2/guide/ and the quick start guide of react here: https://reactjs.org/docs/hello-world.html I don't think there is much difference in the amount of information needed to take in. &gt; But saying you got it faster basically translates to you had no idea what javascript was prior to picking up a framework. I've been using JavaScript for about 10 years. I think both Vue and React were simple to grasp, but in my opinion Vue is easier especially when you consider the wider ecosystem of each (redux/flux vs vuex, and styled components vs normal css etc.). In both cases of Vue and React, I think people can gain the essential knowledge in under a week.
I concur.
You know React after that quick start. And it could be reduced into a few sentences and examples. The *amount* of information is smaller, and not just by a little. You know a fraction of Vue even after consulting the essentials (which still amounts to half a book of reading). You'll still have to browse the API docs afterwards. And as i said, what you learn is throwaway knowledge, so the cognitive overhead is massive because you'll not be able to use it for anything else. As for the eco system, use what you already know. Nobody forces you to learn styled-components. Use css. Other than that Redux is the established option for state just like Vuex is. react-router = vue-router. Next = Nuxt.
Fuck the degree, show me you fucking understand how to think and I will hire you. I have no degree, the kid working for me has one and I swear he didn't learn thing 1 about writing code or thinking logically in school.
We could carry on arguing, but I will just have to respectfully disagree I am afraid. Cognitive overhead of each framework is similar but I found Vue slightly easier. Some things are easier in Vue, such as lifecycle methods and the fact that React does not work out how to efficiently re-render the DOM tree (shouldComponentUpdate) whereas Vue does - this can get complex to manage in complex applications. You know the basics of Vue after reading the essentials, just as you do with React after reading the quick start guide. The real learning then starts when you start building your own real application. Both of those guides set you up to get started building an application. It's misleading to suggest that you have to read 'half a book' to get started with Vue. I don't know of anyone who has learnt both Vue and React to complain of the required reading being much larger.
You are looking for server-side processing, specifically pagination. https://datatables.net/examples/data_sources/server_side.html
It's use of `this` is a big one for me. More of a language flaw in JavaScript, but I try to avoid using it. `computed` makes two-way data binding forgiveable, but it's still two-way data binding. Also, directives. For me, it's putting too much logic in the view. I prefer JSX's approach of saying 'fuck it' and putting the templating right into the logic, lending towards a more functional approach. In Vue, like templating languages, I'm always questioning where the logic should go.
They have nearly the same lifecycles. class constructor = created componentWillMount = beforeCreate componentDidMount = mounted componentWillUnmount = beforeDestroy componentWillUpdate = beforeUpdate componentDidUpdate = updated `shouldComponentUpdate` isn't set by the end-user but by HOC's (redux, mobx, apollo, etc). Even if you use plain `setState` inherit from React.PureComponent instead or React.Component and your component will only re-render if props have changed. You never, ever have to fill sCU manually. &gt; I don't know of anyone who has learnt both Vue and React to complain of the required reading being much larger. The only thing that matters is the amount of information required to understand the thing. And is disproportionally larger in Vue. 
True. Right now one team in my company has decided on using Angular for their project. One team I'm on has been pushing for an SPA front end, and another team I'm on has slowly been incorporating Vue into another app hoping it'll be established in the codebase before anyone who doesn't program (but has decision-making power) notices. Having worked with Angular/React/Vue, I'm at least happy to not be working in Angular. While Vue isn't my first choice, I at least appreciate it and can have fun working with it.
Oh that looks nice. I'm using Redux. I'm sure it's super useful in reducers. At a glance, it looks like functional lodash. Is that about right?
 main.innerHTML += images .map(src =&gt; `&lt;div class='content'&gt;&lt;img class='item' src='image/${src}'/&gt;&lt;/div&gt;`) .join(''); I'd suggest using this structure instead of repeatedly appending to innerHTML at each iteration of the loop, probably wouldn't have much performance impact but can make a really noticeable difference in some cases. Of course the other comments are on point about needing to trust that the images strings aren't malicious with this approach, but it's IMO preferred for generating content dynamically from the server or something. If you do use the DOM API approach I would suggest using a wrapper function (jQuery, custom, whatever) for creating the elements. I think it is a lot cleaner as it prominently displays the relationship between the properties you are setting and the element you are setting them on, e.g. something like this: const frag = document.createDocumentFragment(); images.map(src =&gt; { const div = createElement('div', { class: 'content' }); const img = createElement('img', { class: 'item', parent: div, src: `image/${src}` }); return div; }.forEach(div =&gt; frag.appendChild(div)); main.appendChild(frag); As a side note using a document fragment is a good practice in general to batch appends like this (basically the same as appending to innerHTML once vs many times.) Outside of the one security concern it's entirely preference, both approaches are OK.
[If that wasn't enough](https://github.com/hemanth/awesome-pwa)
bind returns a function and the first argument is the context, the function we are binding is apply, who first argument is also the context. The code above is the same as: const fn = (data) =&gt; userFunc.apply(userFunc, data) const fn = userFunc.apply.bind(userFunc, userFunc) 
Server side processing. Recommended for records 1mil +
Why not learn it? Knowledge is power they say. I suppose if you just need a solution that works, then sure why reinvent the wheel, but I for one enjoy peeling back the layers. 
check out a Jake Archibald course on Udacity for PWA apps, good resource.
when moon?
Yeah it’s basically functional lodash 
By the time you do `someFunc.apply.bind`, you might as well do `Function.prototype.apply.bind`. The two are practically the same thing. Using `Function.prototype.apply.bind` is actually more clear to me, it says you want to bind the native `apply` function and create a new function from it. Referencing it on a user defined function says you actually are doing something to that user function. It's the equivalent of the odd school way of creating an array from an array like object. `[].slice.call([1,2,3,4], 0)` vs `['some random'].slice.call([1,2,3,4], 0)`. Both are doing the same thing but the second one throws me of because I start thinking you want to do something with `'some random'` string while you just needed to borrow `Array.prototype.slice` to create an array.
Am I blind? The article keeps mentioning &lt;slot&gt; yet in the code examples nothing pertaining to that is shown. Confused! 🤔
https://github.com/RandomGenerator42/facemem/tree/master2pointO htts://facemem.tk/ Please give as much constructive critism(insult my code) as you can. And what if would you do if you had the skill I have to better yourself.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [RandomGenerator42/facemem/.../**4127e40d9720d9eddbfb4dda63e1ac5123dc53f3** (master2pointO → 4127e40)](https://github.com/RandomGenerator42/facemem/tree/4127e40d9720d9eddbfb4dda63e1ac5123dc53f3) ---- 
No worries! Here's the example using &lt;slot&gt;: export class FancyButton extends HTMLElement { connectedCallback() { const shadowRoot = this.attachShadow({mode: 'open'}); shadowRoot.innerHTML = ` &lt;button&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt; `; } } In the simplest form, &lt;slot&gt; takes any DOM tree or string inside your component's opening and closing tags. So if we used FancyButton as so: &lt;fancy-button&gt;This text will take the place of the slot element&lt;/fancy-button&gt; The &lt;slot&gt; in our Web Component will be replaced with the text (or DOM node.)
Very interesting that this comes up. I have used your website in the past a lot, as I was in my school's music band. Your tool can recognize chords even from 1990 balkan folk recorded on vcr, thank you for that. Interested in the job too, being a guitarist / front end enthusiast, maybe we can PM.
Haven't union types been in TS for a few versions now?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [RandomGenerator42/facemem/.../**4127e40d9720d9eddbfb4dda63e1ac5123dc53f3** (master2pointO → 4127e40)](https://github.com/RandomGenerator42/facemem/tree/4127e40d9720d9eddbfb4dda63e1ac5123dc53f3) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtkmbn9.)
[Firefox won't even let `carShouldBrake` execute with how this is written](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Stmt_after_return). Other systems will return `undefined`. Be careful with what you take advantage of.
Ah yes, just like in Vue JS. However, I’d check your article. I think there’s mistakes there as I mentioned? Or did I just totally miss it? On mobile so that may be why. 
Valid points, but AFAIK, all of these issues exist without the dialog component API. My understanding is that Chrome has been a bit more proactive about protecting from this kind of malicious event capturing, perhaps the Chrome team has yet to implement this for the new API? 
https://github.com/seanjameshan/coin-cli
Look at other senior dev positions in other businesses - do your skills match or exceed their requirements?
Forgive me if this is a stupid question, but what is the difference between Flow and TypeScript's union types? I use both tools often and can't think of a difference off the top of my head in regards to union types.
Polymer framework adds syntax sugar and data binding to web components, which makes it a complete framework comparable to react. I don’t think the comparison between react and bare web components is exactly fair. Also lack of cascading styles is a feature. 
Yeah, that was my point. Even if you always *use* semi-colons, ASI will insert them where you don't want them. I'm arguing ASI isn't going anywhere and you need to mind it, so you might as well take advantage of it and omit unnecessary semi-colons. You can run into issues with or without them.
yes union types exist, but to make sure you are calling the right type, you have to make type guards. the in function looks like a replacement for these guards. export type UserOrError = AuthenticatedUser | HttpErrorResponse isAuthenticatedUser(user: AuthenticatedUser | HttpErrorResponse): user is AuthenticatedUser { return (&lt;AuthenticatedUser&gt;user).id !== undefined; } isHttpErrorResponse(user: AuthenticatedUser | HttpErrorResponse): user is HttpErrorResponse { return (&lt;HttpErrorResponse&gt;user).error !== undefined; } else if (this.auth.isAuthenticatedUser(user) &amp;&amp; !user.isAnonymous) this.router.navigate(['/account']); else if (this.auth.isHttpErrorResponse(user) &amp;&amp; user.error === 'user does not exist') {
I expected a poorly disguised job posting. Instead, I got a DailyWTF-worthy story. Nice.
Sadly still not as good as IE 4.0 css behaviors, but it’s a step I suppose. I know the tendency today is to shun IE, but it really did pave the way for the modern web, and they did try to get adoption by W3C. Behaviors were one of my favorite features that unfortunately did not make the cut. If you don’t know what it is/was, there are still a few msdn articles around... https://msdn.microsoft.com/en-us/library/ms531079(v=vs.85).aspx
General points: - Extract your fetch requests to an API layer somehow - Don't manipulate DOM elements when you are using React. EVER. Doing so is an indication that you're not grasping why you're using React. You update a piece of state or a store somewhere to indicate that an element should change. - Using tables for layout is horribly outdated and plain wrong. Tables are used for data that fits into tables. Not for layouting. - You need to fix your indentation, it's all over the place - Things like shuffleArray could easily be a utility function. Extract them, they don't belong to your App component. 
Can anyone tell me if there is a need for apply or bind going forward? I see the use cases for them when working with older code, but I've yet to encounter a situation myself where I couldn't express bind or apply in another way.
That doesn't work. Senior dev role ad's all look the same after a point. The only way to establish your seniority is through a duel to the death with another senior developer. 
For now I need a solution that works. I'd love to sit around sipping coffee playing with creating a complete customized solution from scratch for my needs, but ubfortunately this is a project outside of my day job that I need to finish yesterday and get on to the next contract.
I agree! Not to mention its early AJAX implementation. IE would have a much better reputation if Microsoft didn't abandon it during the XP era, but that's also what gave Firefox a toehold and led to the new browser war.
&gt; I had to use the timestamps of records to ball park which records were supposed to be related. I created new matching IDs, and instructed the QA team that I have disabled the delete button because deleting a record would break the website. Never in a million years would I submit any personal data to a website managed with such a sloppy attitude. 
More programmers should stand up for themselves. Just say no, more work needs to be done. What are the managers going to do? Fire you so you can go get another job and a 10% raise because our career is crazy right now? It's not like they could hire someone and onboard them in a week, that takes a month or longer. 
Well, I mean, it's not all that complicated once you get the basic gist. DataTables sends you a request with all the information you need, you do your server-side processing to actually gather the information, and return that to the script. Although I have been quite successful in using client-side processing with a deferred renderer, at least into the hundred thousands of rows.
You may be surprised at just how many "enterprise" websites you submit data to regularly are just thin veneers over bubblegum and duct tape. It's not always (read: almost never) within the power of developers to fix these problems or do a "good" job if they want to maintain employment. Source: Am enterprise developer
This is probably what you want: ``` async myFunction() { try { await api.doSomething(); await this.doSomethingElse(); } catch(err) { console.log(err); } } ... static async doSomething() { return axios.get('/url'); } ```
And that it is. Believe me, I speak up, but my voice is never heard by the powdered wigs that only see dollar signs (or lack thereof). I die a little more inside every day I go into the office and maintain these trainwrecks.
It's not even about how expensive it would be to replace you. It's simply about having integrity and caring about your craft. And it's not about "doing it the right way", it's about being capable of having the conversations that translate the technical into business decisions. You don't explain that the DB isn't coded right, you describe that there's a minor/major/guaranteed likelihood that X business risk will happen without Y amendment.
I’m happy to hear that Chordify has been helpful to you! And, sure, we’re happy to chat and answer any questions you might have. 
I don't disagree with that, don't get me wrong. As I said, though, my concerns usually fall on deaf ears because the people capable of making financial decisions either don't trust my opinion on the matter or it's met with a "We'll look into it" and nothing changes. I've been a developer at a handful of larger companies now and I'm starting to think this is par for the course. I'd love to hear success stories of a low man on the totem pole invoking that kind of change, though.
It starts: &gt;A few years ago, a meeting was held about an issue the QA team was facing. The JIRA work-flow had become too overwhelming. It was tedious to create the hundreds of sub-tasks that sometimes.. I immediately felt at home. Fuck Jira. It's a great story. In my earlier days I'd get to a new job and be horrified by the mess left by the previous developer (oblivious to the mess I'd left at my previous work place where obviously I did amazing stuff even though I was only given a 10th of the time needed to do it properly). These days I'm much more forgiving of historical developers. Actually, related to another thread about "What makes a senior developer", I'm going to say "Forgiving the developer before you and knowing how to understand and fix their stuff" is senior developer material.
So, in order again: 1. You're doing fetch requests inside componentDidMount and some other places. You should make a new file called Api.js or something along those lines and put your requests in there as functions you can call. Then, you should include those specific calls in your app and call those functions instead of directly calling fetch. 2. [Here](https://github.com/RandomGenerator42/facemem/blob/master2pointO/src/App.js#L50), [here](https://github.com/RandomGenerator42/facemem/blob/master2pointO/src/App.js#L56), [here](https://github.com/RandomGenerator42/facemem/blob/master2pointO/src/App.js#L86) and [here](https://github.com/RandomGenerator42/facemem/blob/master2pointO/src/App.js#L95). In general, everywhere you are using refs, you are using them wrong. You should instead make your styling dependant on some data, e.g. a piece of state and then update it based on that. 3. That link is a good introduction to the whole thing. Also check out flexbox. 4. You should get an editor that can format for you. I would recommend Visual Studio Code. No worries, just trying to help you out :)
I've been in situations as the "low man on the totem pole" and gotten things changed. I've also seen junior developers manage it as well. It's pretty rare, since they're so inexperienced, but it happens. But I work for good companies with managers who have strong ethics. And even so, there are still things I have to do that I totally disagree with because it just can't be done cost effectively. You do what you can, speak up about the rest, and collect a paycheck. Anyone who expects more from people is delusional. (And depending on the company, the speaking up part might have to be dropped, too. I'd hate working there, but not everyone gets to work at great companies.)
So &gt; "If we don't take X days to fix this issue, there's a Y likelihood that customers will be making purchases we cannot track, which costs us Z". First that's half the problem. Where's the statement which is "Business will have to stop/be impeded for X (or X2) days and that will cost us Z2"? It's also important for you to be able to accept it when the business says "I like them odds! We carry on and you patch it up. Here's a glue gun". It's really their choice. You make your case for what will happen, if it goes wrong, you warned them. If they're being little bitches about it and want to blame you anyway, that's the time to leave.
By default, the prompt return a string, so your "add" function just concatenate the two strings. Just transform them into int : `function add(first, second) { return parseInt(first) + parseInt(second)}`
Have you checked out [StencilJS](https://stenciljs.com/)? It's a compiler around TypeScript + JSX to develop web components. It's quite nice ([here's an example](https://github.com/tanepiper/mm-components/blob/master/src/components/mm-key/mm-key.tsx))
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tanepiper/mm-components/.../**mm-key.tsx** (master → 20cfe4e)](https://github.com/tanepiper/mm-components/blob/20cfe4e020f10a103edbfa27214c784fc3b66e45/src/components/mm-key/mm-key.tsx) ---- 
Oh, another comment. Now you've put the shuffleArray function outside, but I want it out-out. Make a folder called utils or something and make a file called something along the lines of arrayUtils.js in there. Then put it in there and export it and import it in your App.js 
It's just how GitHub renders tabs, without a `.editorconfig` file that is. I agree that's ridiculous.
&gt; You should get an editor that can format for you. I would recommend Visual Studio Code. But I love SublimeText ;( Also, Interesting fact when I wanted to what I wanted to do with refs on the React documentation page it said that using refs should generally be avoided. See what I don't get is how a child component can communicate with a parent component. The reverse is easy just pass data as props.
Thanks for your reply, I now have: var first = prompt('Enter first number'); var second = prompt('Enter second number'); Function ad(first,second) {return parselnt(first)+ parselnt(second))} Alert( add(first, second) ); I still seem to get them snapped together instead of adding them up. I think there might be something wrong with my alert, but I can't figure it out. 
It kind of is. Jira lulls people into a false sense of utility but the effort to use it doesn't scale well. The decision is usually taken to do all tasks with sub tasks per step because then you don't lose your place when the steps have to be done in order. It makes sense and works great for the workload at first, then as the project grows the workload increases and the number goes up. I do get your point, there are ways around it, but you have to know up front, or change midway and that's hard for various reasons.
If you want a rule of thumb, then are you able to identify high level solutions to existing problems and manage others to implement and maintain said solution? Senior's mostly a title but if you're looking for the skill progression, then it depends on how much depth you have in the domain of your area of work. JS knowledge is great, but do you know when to use sockets over HTTP requests? How to implement them? Performance tradeoffs and mitigations? What layer do you implement your caches, what data stores are appropriate for which project? whats your transaction strategy? api strategy? what other architecture components might you need outside of middleware and a store? how do you handle scaling and rolling out updates?how are your developers collaborating, both VCS and beyond? what about security, are you just doing OWASP's top 10, or do you need way more indepth approaches? How do you verify your apps secure, robust, and scalable? How do you test the integration of disparate components? How do you handle the most esoteric and mysterious of bugs? If you can answer this and more, as well as document and lead other developers to sanely implement these things without too much learning on the job, then I wouldn't object to calling yourself a senior Senior devs SHOULD be the cornerstone of any shop. If a place has 4 Senior developers and loses one, that should be a massive hit to that organization. Sadly most of the time its just seniority and knowing the ins and outs of a particular company's fucked up products and codebases. 
I hate sub tasks, I never read them, they take up space and I always have to drag like 30 cards at from To Do into done at the end of the sprint because I forget which sub tasks are mine since I never look at them. 
That should be right apart from your typos. `Function` -&gt; `function` `ad` -&gt; `add` `parselnt` -&gt; `parseInt` `(second))` -&gt; `(second)` `Alert` -&gt; `alert` (Are you re-typing your code here instead of pasting it? What you posted above won't run at all.)
Well, my goal is to learn both. I'm just going to start with React. As one alluded to, I'm mainly focusing on what will keep me marketable and working. :)
I'll keep it in mind. Thanks! :)
that's like essentially all "enterprise" software, that's why they use use all that jargon and buzzwords in hopes that you won't notice their "Product" is buggy as fuck an looks like something from the early 90s. 
Sorted.. I am hiring some angular developers 
Im retyping it on my phone, I'm sorry about the typos, I appreciate you two helping me out
Aaahhh! That seemed to fix it. Thanks a lot, it now works! 
The downwards counting there is actually crucial for the thing to work correctly. The depth-first search gives me the cells to update in reverse order. I guess I could make it more obvious in the code. Thanks for taking the time to look at it!!
It's been long enough now that it probably doesn't matter, but I once worked on Peregrine Service Center (now HP Service Manager) and it is the absolute epitome of buggy as fuck software that looks like something from the early 90s. I am deeply ashamed to have written a single line of code for it and even more ashamed that companies were buying into it on the order of 7 or 8 figure dollar amounts.
I think it would be more readable if you used the classic array functions, like toUpdate.reverse().forEach(item =&gt; item.updateWithoutDependants()), but it might just be a personal preference
and lets be clear, that "react flow" is just functional programming which has been a long time coming from the ivory tower
Unless you're at one of those companies whose roles look like "Sr. Frontend Engineer IV", like you're a sweater-vest wearing member of a New England dynasty…
Yes. Definitely the feature I'm most excited about!
This was a pretty simple implementation and got the job done. Many thanks!
It doesn't look like you're very familiar with React tbh, here's how it would look: &lt;p&gt;Quasis are {awkward}&lt;/p&gt; {myCondition &amp;&amp; &lt;div&gt;my thing&lt;/div&gt;} &lt;div onClick={this.handler}&gt; The other thing is just your idea anyway. Templates aren't more productive. They just add complexity and limit expression. &gt;Do these two in Vue: const A = () =&gt; &lt;div&gt;hi&lt;/div&gt; const B = () =&gt; &lt;A/&gt; import range from 'lodash/range' const C = ({ params }) =&gt; &lt;ul&gt;{range(...params).map(index =&gt; &lt;li&gt;{index}&lt;/li&gt;}&lt;/ul&gt; &lt;C params={[0, 20, 5]} /&gt;
use value. Its easier and won't cause an error if selectedIndex isn't within the range of options (for example if it were -1).
U mean the first approach?
Seniority has more to do with understanding the company's challenges than with your level of technical expertise. Technical expertise may translate to a higher level of seniority, if for example, the company is bleeding money on regressions and you can demonstrate an improve in that metric by implementing automated testing. Whether you know how to use jest or puppeteer or Jenkins doesn't matter, whether you know how to use webpack or react or FP doesn't matter, what matters is the business value of your work. Often, team scalability is a problem. A higher level of seniority in this case means being able to communicate effectively, prioritize tasks and delegate, rather than being the guy who just does what they are told even though they think it's a dumb idea from the higher ups. Sometimes being senior means being the person that thinks outside box. Maybe you work in one of many engineering teams within your company. Identifying the existence of a systemic effort duplication problem (and doing something about it) takes skills that are considered to be of senior level. CEO's are the ultimate example of the idea that seniority === understanding company challenges. They are at the very top and it's their responsibility to be on top of every problem in the company, whether they actually have the preparation for it or not
This. Our senior developer's expertise relies mostly in a domain specific drag and drop tool, while I'm developing full stack web applications independently from scratch. But due to organizational constraints (ie the upper management and HR not giving a fuck) the senior would have to be hit by a bus before I wpuld have an opportunity to move up. But then again, when I lay an offer on my manager's desk from anither conpany that's 50k higher, we'll see if something magically opens up.
This could replace hundreds of lines of complicated code in a project I am working on.
I know, and have you ever seen most ATS systems? They are shockingly clunky, outdated, and just pure crap and I have no idea why HR people are so stupid that they would sign expensive contracts to use such systems. 
The second one.
Cool thanks. 
Your main point in sharing experience is valid, however... &gt; As with anything -- as complexity grows so does the challenge of maintaining it all. That's not necessarily true of all programming. Take well designed, strongly-typed languages like Elm, or say Scala or Elixir. They scale extraordinarily well -- near constant-time growth in complexity. The challenge with those tools is up front though, in learning them. &gt; herd mentality I think following a herd doesn't necessitate you being a "sheeple". Sometimes there's a good reason everyone is running away from something.
Lol Tatooine API, good one! It was originally pulling data from a depreciated (and buggy) API that the coding school recommended, but I changed it to just generate mock data instead.
Kind of pricey. Looks like you also end up depending on a proprietary DOM API wrapper.
I am not interested in your interminable React propaganda. I know the problems I have with React, and no amount of special pleading can convince me my eyes deceive me. JSX templates are ugly, bloated and cumbersome.
Can't you share any of these horror stories about these huge database leaks big companies keep going through?
&gt; We could carry on arguing Oh, he will. Evangelising React is basically his passion. It's quite remarkable to see the increasingly contrived examples he'll invent to justify his development ideology.
[This](https://www.kitchensoap.com/2012/10/25/on-being-a-senior-engineer/) is a really good article I reference to people who ask the question "What is a 'senior developer'?" There's a lot to chew on in the article but my takeaways over the years are as follows: * Technical expertise and time are poor proxies for promotion. * Being capable of making and keeping commitments * Egoless-ness - knowing when you're right is fine, being *helpful* in helping others why is better. * Be an adult. Don't get upset when your idea is dismissed or ignored, understand the chain of command and the most professional way to have your ideas heard. * Understand that not everyone is on the same level. Being able to help (and almost more importantly being able to ask for help) is a huge part of being a mature engineer. * Be good at estimating. Don't blame X when you're wrong and always try to get better at it. * Admit mistakes, show you are always trying to learn from them. There's a lot in there, as I said before. But this is my bible so to speak when I ask myself "What does 'senior' mean?"
It does sound a bit like what the now-ancient [Tangle](http://worrydream.com/Tangle/) does.
Fortunately no, because I've never worked for a company that had a leak. Color me surprised, though, based on some of the code I've been exposed to.
Take a look at [Angular Elements](http://nitayneeman.com/posts/building-a-custom-element-using-angular-elements/). It compiles Angular components to Web Components and you get all the magic of prop binding and other stuff that Angular offers for free
Why is creating hundreds of subtasks a Jira problem? Are there other systems that make creating hundreds of subtasks for a single story "easy"?
I guess, I sort of stop caring about my integrity once a company shows me they don't care about theirs. I'm not the CTO, it's not my job to tell the company how much they *should* care about their tech.
A measurable criteria is minimum time between feedback/supervision from a business value point of view. The longer the more seniority.
When you're architect is inexperienced... Yes.
lemme sum it up for you guys * hires inexperienced developer * inexperienced developer makes many design and implementation mistakes * hires experienced developer theres literally nothing to learn here. unless you were planning on hiring an intern to architect, design, and execute a site with complete autonomy...
Why not write something yourself? Seems quite easy.
There're a number of things to consider in your words, so I'd like to first point out a couple of details on them, because you ask a clear question at first, but then you drop some hints that there may be something else. &gt; I’ve been coding for 3 years now and I’ve noticably [sic] felt that my skills have advanced. &gt; [ ... ] &gt; How do I know when I’ve reached senior level skills? The first thing is this: How did you notice that your skills had advanced? Probably you now feel more confident doing a number of things you previously didn't know how to do or didn't feel so confident about. Self-awareness is a good sign. But then again, you're asking how to know if you fit into some external definition of "senior developer". So, self-awareness will only get you so far. You also need _environmental awareness_. That is, you need to understand not only yourself, but also what is a senior developer. &gt; There’s a review coming up at work and I’d like to get a promotion. The second thing is that you're _mixing_ things. Or at least you're drawing too hard a relation between some things. What is it that you want? Do you want a promotion or do you want to _get better_? The two, while related, are clearly not tied to one another. Having said this, there are now two different questions. One is _What is a senior developer?_ and the other is _How do I get a promotion?_. The second question, getting a promotion, is easy and generally boring. So I won't say much about it. Only that you need to make your employer think either that they stand to _gain_ something from giving you a promotion **or** that they risk _losing_ something if they don't give you one. In some cases (few), you could try to go for an approach where the focus is that you _deserve_ a promotion. You have to play your cards very carefully, though, as this "moral" approach is hard to sell. The approach of a gain/loss usually has a better chance. In any case, this is all I will say about this part. The first question, defining what a senior developer is, doesn't really have an answer. All of the answers you've already been given are correct to some extent or under some perspective. Sometimes it's just a title, sometimes it's based on the time you've been at the company, sometimes it's about somethingcompletely different. So it really depends on which perspective you want to use. If, say, your interest is really that promotion, then the best idea is using your employer's perspective. _Ask_ your boss, directly. "I've made progress in these three years and I'm thinking about my _future_ progress, so... What criteria do **you** use to evaluate that progress and consider me for promotion?" It's as simple as that. It's a fair question and one that you should feel confident enough to ask. If, on the other hand, you have an interest in just **progressing**, in getting better at what you do, then... why the need for a particular tag or title? I mean, I understand it, but do try to take away some of the importance you're putting on it. Just focus on being _better_. In time, it will be other people who will _see_ that you are indeed "senior". But to give you some ideas... As I said before, being senior is probably not so much about having more in-depth knowledge of some particular technical aspects -but still, do not push that away; it **is** useful knowledge-, but about having some _additional skills_. You should know and care about _the cost of things_, that is, not only the better technical solution, but also what are its downsides, its risks and costs, what other alternatives may be perhaps less correct but actually make more sense on economical/social/whatever grounds, etc. You should acknowledge that _your_ particular personal effort will produce only so much result no matter how good you get, but that if you can make other people better, then your effort will produce much larger results (e.g. if you get better enough to produce say 30% less bugs that is excellent, but if you get all 20 people in your department to produce just 5% less bugs, the impact will be much larger). Not only that, you should _care_ for your team-mate's progress as much as you care for your own. Really _care_. You're never working alone in some code which no one else will touch. You're all sharing the code, the project, the progress, the responsibilities. So that thing I said about _you writing 30% less bugs_? Well, that was meaningless anyway. The code is not _your_ code. It is _the_ code. You need to be, at least to some degree, a _leader_ and an example, and get others to share the interest of progressing. You should show interest and seek opportunities to learn about the details and needs of the business side of the project. This will help you understand better the goals and intentions of each task. In turn that will offer opportunities to _contribute_ suggestions, ideas, better solutions. It will make you go from having to do just what you're asked because you can't know better, to being able to propose alternatives and suggestions because you now understand the goal that you are all seeking. I could think of some more skills and aspects, but I have to go now, sorry :)
&gt; "Monday?" The manager said surprised. "No Monday is their deadline. They need it ASAP." Time to negotiate a raise :o
that's assuming that he have an architect.
It's amusing but not informative, which isn't necessarily bad.
I'm in the midst of a project that has an ATS workflow in the middle (it's a job board). Any advice?
When something breaks do you have anyone to call? If no, and everyone still expects you to fix the problem then congratulations. You are a senior developer. 
https://github.com/richie-south/pi-trainer/tree/master/pi-trainer react-native expo app built with redux and recompose
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [richie-south/pi-trainer/.../**pi-trainer** (master → 2b56a08)](https://github.com/richie-south/pi-trainer/tree/2b56a08890be27506a416eae8629a555ae9e6f1d/pi-trainer) ---- 
So I disagree with you to an extent but it's all subjective at this point. React and Vue both solve the problem of context switching, but I personally feel that Vue does it in a more elegant manner than React. I prefer Vue components over JSX, and even if JSX had some technical advantage over a Vue component, that advantage would have to be quite significant to convince me to switch. In terms of learning curves, I think that's highly dependent on the audience. For seasoned programmers, especially those who do a lot of web work, I don't think React or Vue introduce any steep learning curves, and perhaps the biggest pain points has more to do with the tool chains involved than JSX vs Vue component. Over all, beyond my personal preferences, I don't see huge differences between React and Vue and I haven't seen a compelling argument with examples that demonstrate that either one has a major advantage over the other. So my decision to go down the Vue rabbit hole is purely based on my personal preference for it's component syntax over JSX. But, either way, it's quite refreshing to finally have moved on from Backbone.
Look at your pay stub. You will know if you are a senior developer.
&gt; It was a PHP project. It was also a node project. It was running on Apache. It was also running on Nginx. It was running on a node web server. At least the database was only MySQL. Calling this an Angular project would only be a courtesy. &gt; For a company with such rigid security, it was a mess. Every single line of SQL was prone to SQL Injection. &gt; Every daily stand up, I would tell manager about an issue I have solved. He praised Angular. I explained the complexity that it took to run this very simple tool. He praised Angular. I told him about the 3 web servers that are currently running to serve a single application (Node for SPA, Apache to trigger php jobs, Nginx for the static assets). He praised Angular. &gt; I told him that we need to have someone who focuses on improving this tool and remove the excess it took to run it. I even printed a list of things that this person needed to know to be a qualified candidate. He took the list and thanked me. &gt; The following week, there was a new job post. &gt; We are looking for an Expert Angular Developer. *Facepalm*
I find the attitude of the superiors can completely change the dynamic of the company. Sometimes it’s the developers who can’t translate the technical to the business, but many times it’s the superiors who don’t want to listen to the technical people. A good relationship between developers and marketing, etc. is a big thing I ask about during the interviews. Communication is always a two way street, and without hearing more it’s hard to place blame solely on one party or the other.
Seriously. What in the hell was this company thinking. They had an intern working on a pretty damn complex system, then took it blindly at face value to use. Shit management at this place. For the author of this story, I hope they got a significant raise or got the fuck out of there because that place sounds like its being held together with gum and toothpicks.
I'm waiting on Blazor.
I thought it was interesting and slightly unnerving despite not really knowing what he was talking about. The intern didn't do a good job at creating a stable app, but is there more to this anecdote than using a stack incorrectly?
Yeah 10 years minimum is usually the length before you can be considered senior
Best answer in my opinion.
I believe that one of the points being made in this post was that the management thought that Angular was amazing/the reason why the app was better than Jira, but it had very little to do with anything or had nothing to do with the frontend at all. App works better? That's because of Angular. Even when the new developer fixes something, he fixed it because of Angular. Fixed a SQL query? Thanks Angular. Cookies got fixed? Thanks Angular. Need a new Dev to fix server spaghetti? Get and Angular dev.
The article hints at it, and correctly identifies the differences between async and threads, and is all technically correct, but the _title_ perpetuates a misconception, and erroneously conflates the two. Async and threads are not synonymous or replacements for each other. Threads accomplish parallelism and concurrent processing, while async offloads processing entirely, and is not necessarily about parallelism.
Thats a bit aggressive. I'd say 5-7 depending on the person/company.
JIRA is just a tool, and it works fine for exactly what it is. Guess what happens when incompetents dictate how to use it and set it up? Any tool will fail this way.
That in no way lines up with what I've seen interns get to do. And if it did I think there would be a revolt by the rest of the programmers for not getting to do the interesting work!
I think it was more of a story that could be related to. Not some sage piece of advice.
Like /u/drcmda said, web components are the ideal solution to a lot of people's problems. But Polymer's web components are exactly that - Polymer Components. Since you know that everyone is using the latest Chrome though, you actually do have the option to use vanilla web components.
Nice. But I think it was your duty to sit them down and explain the true state of things. Otherwise, they will never know better.
My whole point was to draw a line between them and show that asynchronous does not mean parallel, backing it up with some facts about how the JS works under the hood. On the other hand, I wanted to show that multithreading can be achieved, and how. Cheers!
A senior developer only needs to be told _what_ to do, a non-senior _how_ to do it.
I think the interpersonal skills /u/name_was_taken mentioned are still a huge part of this. Leadership skills and being able to effectively mentor junior devs is a huuge part of it, not just success on its own. Not saying that doesn't apply to you, but based on what you said your merit seems to be mostly based on success, and maybe experience. That may not be enough at your current job. Another idea: sometimes getting promoted at your current job just isn't going to happen. Switching employers is a pretty surefire way to get a raise, even if you don't end up leaving. If you are really good, your current employer will at least try to keep you on.
I agree. Make a strong case for it, and if they say no, start looking elsewhere! But if you find that you are struggling to get past this ceiling in your career in general, then I think it's time to start asking yourself if there are areas beyond programming skill that you might want to improve.
https://github.com/alsiola/form-and-function A React form management library that uses render props and functional validation.
Sorry if this sounds as showing off, but I'm genuinely curious. I have exactly 2 years of experience with no CS background. Self-taught. I joined an organization a year ago that was using AngularJs poorly with bad practices and state management problem and I persuaded the team to adopt Redux by implementing the pattern without the use of the library itself. I also researched and implemented a path for us to migrate to Angular 4 and we are using Angular 4 now. I've been doing lunch and learn sessions for the team on Redux, Angular, and RxJs, and other developers are asking me for advice on how to build things correctly. Should I be considered as a Senior developer?
This is why senior developers leave. Why not give your senior, seasoned developers a new "no-holds-barred" autonomous but complex project to put their senior skills to use? Why would you give it to the intern? I'd give it to the senior engineer and then tell the intern to pair program with them so they could gleam some knowledge from the senior eyes, and still get the first-hand experience in building a complex project... the right way?
“P is currently Monday. Set the QA team’s expectations appropriately. I’ll let you know how I progress.“
If you can convince someone to put "Senior" on your job title, then I guess you are one. 
Why did I read this?
it's subjective and it's just a label. it requires years of experience though. it's not just about how good you are at coding. there's a kind of intuition, judgment, and sensibility outside of raw technical ability that only time on the job can develop. that's what makes a senior developer. 
you're just really good.
Being self-taught does change things, but there's a *ton* of business skills that you probably still need to learn to really do the job of a "senior developer". You'd probably pick them up pretty quickly if you started the job, but it's easier (and better for almost everyone) if you learn from someone else first. My first real programming job hired me as a "junior programmer" and then asked me to finish a system that had been outsourced poorly. Then they asked me to rewrite that system entirely. Then they asked me to write an entirely new system from the ground up, by myself. I did all of that with surprisingly few real problems. 5 years later, I still didn't consider myself a "senior programmer". I left for another job, and took the "lead programmer" role. It was still another few years yet before I figured I had the experience and skill to call myself a "senior programmer". Some might argue that I was already doing the "senior programmer" job at the start of my new job, but I don't think I was actually qualified for it. I got things done, but a lot of it was flying by the seat of my pants. And for the record, you aren't a "2 year coder" if you taught yourself and were coding before you got a job. Of course, it's really, really hard to label exactly what you *are*, since you've got non-professional experience and knowledge.
ok first of all none of these libs are a "flux implementation". Redux is very close, but it's still doing couple of things very differently. Since I work with react I prefer MobX. I dislike redux for it's boilerplate.
I like mobx the most, by far. Its actually not a flux implementation, but its better: * unobtrusive decorators let you write models that work without react * powerful computed values solve all performance problems that can be solved with caching without having to think about cache invalidation 
I have read your posts on r/javascript and r/programming before. I am generally convinced that you are not sincerely interested in anyone's problems with your personal tech stack, and that your evangelism for react/redux borders on obsession. This inclines me to dismiss anything you write out of hand.
Well, Polymer does not bring only Polyfills, it also brings syntax sugar to write your components, no?
Yeah I've been programming for about 5 years now - had a few internships and almost graduated. Not even close to feeling anything more than junior. I think if you're not sure that your senior you probably aren't and if you think you are you probably aren't as well. 
Polymer is a full blown framework, even one of the gnarly ones that change underpinnings every so often. Prepare to load 5 Polymers on varying versions for 5 components you load. If it's all under your control that's less of an issue, but if it's all freely distributed from here and there, yeah, Polymer will cause some mess.
What does this even mean? You don't need node to run angular. Maybe these people haven't learned their lesson after all. 
Wow, that is hilarious and sad and true and awesome.
You are right. I don't have just 2 years of coding experience. I do only have 3 maximum because I started learning how to code in College and I started with C++ which later I used to build a simple object tracking robot with arduino and OpenCV. I do agree with you on the business skill. I severely lack soft skills and the ability to convey technical information to the management. I am not satisfied with my skills and I will continue to improve.
Yeah that was the best part by far 
Sure, I was thinking about most other implementations of observables and computed values, which are often tied with the UI layer.
Lack of cascading styles. Exactly. It's a huge issue that is a headache to deal with if you want to use someone else's polymer components ugh
Oh, sorry. Reading comprehension is important. If I had more opportunities to interact with the big wigs, perhaps, but we have a highly vertical structure. I get the feeling my bosses don't care because they don't get paid enough to care, but they are certainly aware of the risk. As they say though, shit rolls downhill, and my team is probably at any given moment seconds away from a veritable shit landslide if we ever have a leak happen.
The only correct answer is that you are a senior developer when you convince someone to pay you like one and call you one. What young professionals need to assess is whether or not they can convince their employer to pay them as a “senior” professional and call them one. If not, then they should figure out what it would take. As you can see here, that answer is not the same across all employers. If you think you can convince someone else that you should be paid as a senior developer and called one, but you cannot convince your current employer, then you must look very critically at the reasons you would like to stay employed by your current employer.
Yep, I think you achieved that just fine. I've also found that it's important to explicitly call out the differences when discussing the two together.
All good, you know there are tons of “inheritance-like” patterns in functional programming you can use too. Object.assign is really great for extending objects in a similar way to how class inheritance works.
Agree to disagree, I don’t believe it too aggressive at all, and have heard many consider 15 years the “line”. 
I love Vue, and Vuex is pretty damn good. It's got some things that I'd like easier (e.g., making actions &amp; mutations just normal functions somehow, instead of having to use dispatch/commit) Moving to React, Redux just doesn't do it for me... Mobx is closer, but it's early days for me on these tools. I think this guy has potential: https://github.com/unadlib/iflow 
This is what happens when you think you need to roll your own Jira tool. What a sham.
What does parcel offer that the latest version of webpack does not?
Ha, sounds exactly like what's going on now at my current gig. Our "dev lead" (some guy who was/is the CIO and promised the world to the CEO, so the CEO replaced the CTO who knew what he was doing, with the ass kisser) said to me once, "it's amazing what you can do with a few lines of JavaScript, huh". Then when I first started, our machine learning guy was asking me why I choose Angular because "we couldn't figure it out at my last job". Then our backend guy argues with me on why jQuery and document.createElement are better than Angular. Meanwhile, he sets up a login api with the username and password as url parameters instead of in the headers. Our dev lead doesn't know what the fuck he's doing, so shit like that just keeps happening. But, one of the morals of this story and the article is, you'll come across some dumbasses in management, and those dumbasses don't care how it gets done, as long as it gets done. Even if technical debt is building up to the point where its simply unmaintainable, then, at that point, no matter what you've done previously, they will think you're incompetent.
Good idea. I hate to sound pessimistic, but if you were to get enough traffic to make this useful you will surely surpass Google's free tier and when you pass Google's free offerings they aren't cheap. Have you thought about this? Do you know if Google offers different rates for philanthropy projects?
 if(object.value) { callFunction(object.value) } or object.value &amp;&amp; callFunction(object.value)
its not based around Google Maps
I think this is the wrong question to ask. Redux is a way to abstract writing to an immutable state using actions. Mobx is a way to abstract reading and writing to a state and handling updates. Flux is a data flow pattern that both of the previous can follow if they'd like to. I like redux, but I think one of the first mistakes a lot of people make with it is thinking they need Redux. A lot of Redux implementations could easily be replaced with your own simple immutable data store, and a lot of Mobx implementations could be completely replicated with reselect or even just basic memoization. // Update Store &amp; clear super basic memoization setUserName(id, value) { this.userName[id] = value; this.cached[id] = false; } // Fetch Data and memoize getUserName(id) { if(cached[id]) { return cached[id]; } return this.userName; } For reading and writing a users name, that is basically as feature rich as redux now when you use it const oldValue = currentValue; const currentValue = getUserName(this.id); if (oldValue !== currentValue){ update(currentValue) } Now your component calls its update method with the values as soon as they update ala mobx. All these libraries are doing is adding convention, tooling, or more complex features. Memoization can be replaced with a real memoization library to support multiple arguments, or use Reselect to support nested memoization for example. If you want to abstract your updates to "actions" which can update multiple places, then you could look at Redux. If you need more speed, or you want to prevent interns from manually editing the store and breaking your memoization/cache, you could use a library like Immutable.JS to speed up the comparison between the new/old value when they are complex, or even allowing you to memoize based on the store state instead of just arguments. I think people could probably get more out of these libraries if they took a little more time understanding the problems they solve, rather than how their documentation recommends you structure your broilerplate. For example a lot of Redux can seem like broilerplate if you are just making all your ActionCreators simple mutators that only effect one Store. A mistake I remember making making at one point, and one I've seen countless times.
Thanks for the new option, I like it, I will start using it and see if it sticks.
Do consider if you're actually checking value if it is undefined. What I mean is that, sometimes you are checking that it is undefined and not false. false !== undefined
That's most certainly Google maps API that I'm seeing on that website.
That's a pretty great way for companies to not have to pay anyone "senior" salaries, by the way. 15 years at any tech company you should be a VP in charge of a development group with all your accumulated knowledge of that company's product and process.
No. we've built it on opensource tech. check it on a mobile phone, it interacts differently
Not really, I’m talking about 10-15 years Dev experience overall, not with a single company. There are many facets of development, and being competent in all of it takes time and experience, I’ve yet to meet someone with &lt;10 years experience who could lead a team, handle the lifecycle from dev to testing to deployment to maintenance across the stack. 
I did see it on mobile. Its Google maps. That said you might just be using the map display and not location api or the other limited bits.
You are in fact pulling from Google Maps API. It looks like you have some kind of layer on top of the map, but the data itself is coming from the API. It shows the Google logo at the bottom left of the map, the bottom right has the trademark, and I confirmed by the requests that it's pulling from maps.google.com. It looks like you're using Leaflet on top of it, but that's just a wrapper for different map APIs. 
Doesn't exactly look great to new employers if you're fired though, guarantee they'll ask about why you left in an interview
no, its interesting. we did start with just leaflet, it seems one of the devs must've switched the whole thing at some time (we have a lot start, push it for a bit then drop back). so that means we will be charged heavily when we get more than a certain number of users? (if so i'll have to add moving back to leaflet into the road map)
You're describing a team lead, not a senior. And I'd agree with you there!
No offense taken! I absolutely appreciate anyone trying to help. And thanks about the XY thing, I wasn't aware of it. After trying and reading and trying some more I came up with a solution I'm happy with, for now. Will share it here for anyone in the same predicament: -- Human.js ----------------------------------------------------- const Human = () =&gt; ({ name:'', health: 100, energy: 100, hunger: 0, age: 30, changeProp: function(pair) { this[Object.keys(pair)[0]] = Object.values(pair)[0]; }, getProp: function(key) { return this[key]; }, }); module.exports = Human; -- Scientist.js ----------------------------------------------------- const Human = require('./Human'); const maxAge = 60, minage = 19; const scientist = name =&gt; { let obj = Object.assign({}, Human()); obj.changeProp({"age": Math.round(Math.random() * (maxAge - minage) + minage)}); obj.name = name; let scienceObj = { experience: 'skin cancer', carrying: 'cellphone', talk: function() { console.log(`Well, my mane is ${this.name}, I'm ${this.age} years old and I know about ${this.experience}${this.carrying ? `. And I'm carry my ${this.carrying}` :'' }`); }, }; return Object.assign({}, obj, scienceObj); }; module.exports = scientist; -- main.js ----------------------------------------------------- const scientist = require("./scientist"); const Joe = scientist('Joe Mazzini'); Joe.talk(); [Same code with syntax highlight](https://gist.github.com/nmaxcom/6185503fcfa0732031299cd31d716091)
Thank you, that solved part of the issue
I managed to produce a working prototype, I published down here, lemme know what you think!
This is the best answer.
Yeah, they charge heavily once you pass the free tier. They changed their pricing structure a couple years ago and I think it's better, but I honestly haven't crunched the full premium numbers on it. It's not really that straightforward once you pass the first teir. https://developers.google.com/maps/pricing-and-plans/ https://developers.google.com/maps/pricing-and-plans/ Some rough numbers on the first tier past free, can cost up to about $1,125/mo for 100,000 page loads a month. Which is a very good amount of traffic, but it's not exactly a heavy load. If this went to the front page on reddit, for instance, you'd probably see 100,000 in a day and their pricing structure is based on the day, so I'm not sure how that would work. If you plan on using [Geolocation API](https://developers.google.com/maps/documentation/geolocation/intro) that can add more costs. The next tier starts getting complicated and the price looks like it jumps up. I can't find anything about them offering different pricing to non-profits or philanthropy projects like this, which sounds like something Google would do. But in all honestly I didn't look *that* hard, I haven't done any serious work with their API before, and was hoping you had already done the research. 
A senior developer provides confidence and simplicity. These qualities are hard to bullshit (imposters) and easy to demonstrate. 
That is interesting, but I am not sure that this means. Could somebody describe a useful scenario?
Gross
Sorry, the “lead a team” is confusing. I expect a senior dev to have _the ability_ to lead a team, while team lead handles the responsibility. That’s been pretty common no matter where I work. I trust a senior dev to be able to handle any task on the codebase without any other dev (everyone is sick, for ex). 
It's amazing how pervasive this mindset, yet you should really never need any fix asap. If there is value to having it done in 2 hours, and it's possible that could happen, plan for a 2h timeframe but also have a plan for what happens if it slips. "Get angry and blame the dev for not working faster" does not count as a plan.
You're on Reddit. Don't act like your time is too precious. 
Note that both of these are checking if `object.value` is false-y, which is different from your original examples. 
I think it's informative. Managers and devs looking to take a senior role on a project they see as a beautiful mess could learn something. 
I recommend you use `x.value` where `x` is an HTML `&lt;select&gt;` element as senocular said. Some libraries (like React), will actively discourage you from trying to dig into the `&lt;option&gt;`s for callbacks or accessing data. That said, if you need to access the `text` value for some reason, then go for the `x.options[x.selectedIndex].text` route.
What do you use subtasks for? We just put work into the dev tickets. Our testers will pop out a subtask for their (rigourous!!!) work flow and notes. I find Jira overwhelming sometimes, but only if we size tickets too small. 
My fault, I probably should have explained that. The majority of the time it doesn't matter, but sometimes it does. Since this was a generic example, I just went with the majority of the time. I really suggest getting familiar with this OP: https://stackoverflow.com/questions/19839952/all-falsey-values-in-javascript 
It's gotten kinda crazy. And if you try to keep it simple you get looked down on. Like...no, it's a website, I don't need to package everything with webpack, run a node api against a react frontend, feeding a mongoDB - don't forget the docker cluster. And of course the grunt jobs necessary to parse your work into usable code. Note: All of the above tools are awesome and have their uses.
You’ve got a lot of strong front-end development experience. You aren’t a senior developer, but you have a lot to build on. Write a node plugin. Grab a testing framework and write some tests. Package an app with electron. Venture outside of JavaScript. Pick up a server-side language and framework. A database language too. Learn to handle deployments, continuous integration, releases. There’s no “line” you cross, but eventually you’ll read about a new plugin or library and think “I have/could have written that (better)”. You’ll begin to give direction instead of ask for, PMs and leads will look to you for insight. You’re the on-call in case of any emergencies and server outages. This is a senior dev. 
These kind of time saving wants are generally considered pie-in-the-sky kinds of wants. Not many managers would dare direct senior developers to take weeks, or months depending on scope, of time off the revenue-paying software to build a utility tool. Really, this is the kind of stuff you give junior developers with senior supervision. The senior developer helps guide and direct and the junior developers, with way less meetings and more to prove, can focus on implementation and proving the concept.
Totally agree. If the mess is big enough it doesn't matter how good your developer is or how soon you need it by. If it won't be up it won't be up.
Thanks. With your support and guidance, I know I can do better next time.
It's context dependent. There are a few considerations to make: - Is `object.value` going to be used more than once, where declaring a variable would make the code more succinct? - Would using `value` later in this code be too ambiguous? Would it be difficult to know where its coming from at a glance? So go with whatever makes the most sense for the situation.
We even do this with our experienced developers on new projects that step outside the normal architecture a team works with (such as adopting a reactive JS framework, implementing a CMS, or when moving to Web API instead of regular MVC). An architect (basically our senior-senior) designs the project, sets up everything we need in terms of a POC (proof of concept), then pairs with a few senior team members who then pair with the remaining team members to get everything set up and started on a first project.
&gt;&gt; But, one of the morals of this story and the article is, you'll come across some dumbasses in management, and those dumbasses don't care how it gets done, as long as it gets done. This was the best type of manager I have had. He let the developers discuss and decide on the architecture and stack of our code instead of forcing us to use one thing or another. Because of it, we got rid of the old in-house CMS and created a Vagrant/Yeoman generator that let us build sites in literally 1/2 the time with 99x less issues. As long as we produced, he didn't give a shit about how we did it. Since then I have been in micromanaged positions where a single idiot held all control over the stack/architecture and ones where they refuse to change to any new technology because, "It's what we've always done and all I understand."
Why
My takeaway is that I can skip `this`, start typing the property name, and it'll add `this` for me. That's pretty cool!
What a time to be alive. Can't wait to wipe that smug look off the next interviewer's face when I tell them knowing what *this* refers to is practically like writing assembly now
I came here to say this, parallelism and not blocking are not the same.
I think he means "develop crippling depression"
Lol. Yeah, that type of manager works when they understand what development is and entails. My current one doesn’t. My previous CTO let us take control. He also was in the code base taking on the more mundane tasks we had in Trello. An actual leader.
Just to give some context, the main objective of every programming language, library or framework ever made is to allow us silly humans to grasp larger and more complex problems in smaller, easy to digest, bite sized chunks. So based on that, react, vue, angular etc are all trying to solve the same problem, but with different approaches aimed at different ways of thinking. The advantages of libs/frameworks like those mentioned above is that they standardise the codebase so all developers can work within the same set of rules, allowing for larger projects with more complexity and more developers to be more easily sorted in working memory by more people. Essentially, the more complex and bespoke your codebase, the longer it takes for new developers to ramp up. 'Pfff, how much of an issue can that be' I hear you say.... I once saw a project stand still for 2 years because ramp-up time was about 4 months and we churned 10 developers in that time, essentially killing the project. So yeah, it's quite important. Anyway, back to your question. If it's only you working on the codebase, and it's not very complex, and it's easy to manage, they you can do whatever you want, whatever you personally feel is the quickest, in your own style with your own rules. But, as soon as you try and bring another developer on board you'll soon find out how unmanageable it is for them. Even the simplest decisions you made without thought will not make sense to them. You'll go from 100% productively to 50% productivity as you help then out, while your new team member is only 20% productive... Making a grand grand total of 70%... Essentially losing 30% of your total productivity while doubling the number of hours spent working on it. So yeah, that's the case for frameworks: Humans are not smart enough so weneed help. 
Code review someone's PR that changes the legth of a line but only changes a minor thing, then come back to me and try to argue that vertical aligning isn't stupid.
Indeed, I'll bring one or two more js devs. So.. concretely about Vue and React. Should I dump Vue for the reasons I gave you and go for React?
I can't say that, I'd need to look at the project. I personally like react more, but that's just my opinion.
Neat. VSCode continues to get better and better. Still trying to convince a few of my co-workers to come over from Webstorm.
In my current company, I have never even seen or met the CTO or CIO (have met the CEO a few times though), I have met the VP of my department once and my director three times and I have worked at the company for almost 3 years. Managers make decisions here. And managers are made from loyalty/time at the company. In tech, people move a lot. In a big corp like this, offshore/implants dominate 75% of our tech hires and they aren't being made managers (for obvious reasons - they are contractors), so loyalty is almost non-existent. Which means our managers haven't touched code for over 10 years...
yep, one day you introduce a new variable in there (should be one line change), but the new variable is long and you have to realign all 5 lines to align with the new long variable. What a waste of time.
I guess redux-box would click it for you. Since it feels like vuex in many ways, while maintaing the best parts of redux. https://github.com/anish000kumar/redux-box
Oh, I've been working with startups and small businesses for a while, so the small teams account for the level of direct CTO involvement.
Classes have no place in JavaScript, I hate the use of `this`, and I don't like autocomplete.
&gt; to come over from Webstorm. What does VSCode offer that Webstorm doesn't?
Vscode is faster, only thing I think of
&gt; A senior position, in my view, is for someone who is skilled and confident enough in their abilities to properly initiate and manage projects without guidance That is to be expected from normal software engineers, too. Also most of the part even from juniors.
Webstorm can auto format with Ctrl-Alt-L. Everything is saved automatically. 
Webstorm can auto format on save with the Save Actions plugin.
I know, but they would rather just CTRL+S and be done with it...
I believe Webstorm has all of those, although I suppose the nice UI is subjective. 
You sure like to bait downvotes lol
Don't do that. I hate this kind of attitude in the dev community. Some new fancy shit becomes popular and trendy nerds expect everyone to jump on the band wagon. I'm comfortable with Webstorm, and it seems so are your co-workers. Why not leave it at that?! Huh?
They can add save actions such as format.
If your formatting rules can be expressed in eslint's indent rule or a prettier config, you can use File Watchers to auto format pretty easily.
Could you set up something to format files on the git server as they are committed? Or as a post-commit job, then recommit with -m Formatted. I'm not sure if this is recommended practice.
That, and its free. 
It would awefully polute the git history, but the format on commit would be nice, not sure that was/is possible though.
Maybe access to Java APIs and libraries? In some fields there are very useful, mature libraries that are only in Java. A well written port of V8 to OpenJDK could let me write Javascript code that can access them.
We use TSLint plus a few others (Angular CLI) which works wonders with VS Code. I've not heard of File Watchers. I'll look into it.
Seriously? Let's see here ... Webstorm: &gt; $ 129.00 &gt; /1st year &gt; $ 103.00 &gt; /2nd year &gt; $ 77.00 &gt; /3rd yr onwards VS Code: Free.
FREE
I think a lot of people have said, that depending on where you work, a senior can be viewed in different light. Also depending on who you speak to they will define a senior in different ways (one boss said a senior was 10+, another said you could have 5+ but show key traits). From what i've read/learned a few key points always seem to come up. * Strong core skills * You can justify your reasoning, not just saying "i've just always done it that way" * You can communicate with the business * You are looked upon for answers I feel there are also some other points that help you become a senior * Ability to teach other developers * To spot problems before they happen ( a lot of this comes with experience) * Being able to adapt 
Who says you have to pay?
I like redux because of its simplicity (in that there is no abstract magic) and explicit nature. It works with any generic json structure, it is immutable instead of mutating state into observables. It also isn't tied to a framework, we use it for cross platform and framework agnostic stuff. Currently for instance we deploy a lib that customers use in React, Angular, Vue and vanilla/Jquery, as well as native applications and node. The downside is of course having to write the structures for it. At least for React i believe some things could change due to the new context api. Context can distribute `setState` globally, making extremely [light-weight store pattern possible](https://github.com/drcmda/react-contextual). At that point i think many apps wouldn't need redux/mobx.
Ever try formatting css with vscode? I love vscode but youre a bit biased
Declare each variable individually, declaring by commas can get confusing. Also utilize consts. Assign your css to variables and plug them in to reduce that noisy return statement.
You don't *have* to pay, but it is a product that does have a cost. Microsoft's VS Code is free, period. There is no price whatsoever, no matter what you are using it for.
If you need to ask if you might be a senior level programmer, you're not. One of the things that sets apart "senior programmers" from "junior programmers" \- in my opinion \- is not caring about whether you are considered senior or junior, but instead just caring about the work. And I say "work" because it's a lot more than just code. It's design, and testing, and deployment, and team management, and so many other things.
The ability to format and how well an editor supports or formats are different things. * VS Code with any plugin can format on save. VS Code can attempt to format on save without any plugins. * Webstorm cannot format on save with out a plugin.
Your reply doesnt make any sense to me at all. You're implying that doing stuff on save is far more important than formatting. Who decides that? I downloaded vscode and was really happy with it and then I hit alt+shift+F to format my styling and boom. "There is no formatter installed for this file type: .css" Now are you saying the fact that vscode is able to format at all keeps that from beeing a major issue? That doesnt make sense at all. CSS is an essential. Format on save is seems pretty unessential to me. 
The Go language uses "aligned code" in it's formatting, and it includes built\-in tools that will auto\-format your code accordingly.
Decent diff tools can ignore, or separately highlight, only whitespace changes so that becomes less of an issue.
Something that's not been mentioned. Does `object.value` have any side effects? Imagine this: ``` class O { get value() { doSomething(); return 1; } } ``` Using the above, your first example triggers `doSomething()` once, whereas your second will trigger it twice.
Depends if you're a student
You are fighting a losing battle here. The hardest think i have to do is try and convince someone else your editor of choice is better than theirs.
I actually use VSCode, and thoroughly love it. But I know WebStorm is a great product, and I'd be surprised if they lacked some features that VSCode offer.
Visually the aligned version is definitely better in many cases, but if you adjust the alignment every time something longer comes along it can make diffs much larger and therefore can make code reviews more of a pain. I use aligned code myself, but to reduce the diff problem I try to apply it pragmatically: 1. For early work on your own projects apply alignment dogmatically. At this point diff analysis usually matters much less and when it does you are only inconveniencing yourself. 2. If a single new variable comes along, don't realign everything that already exists immediately. If you do your next merge/checkin will have a block of line changes that can hide the actual difference. 3. In fact don't realign generally. Yes, it looks a little messier than it could, but still less messy than no alignment at all. 4. At some point in the future you might want to neaten things up. Do this as a separate merge/checking to *any* other changes - that way the realignment does not risk masking a smaller change in the diff. This does break diffs spanning multiple versions that straddle this version, of course, which could be an inconvenience, but this happens much less often than diffing neighouring versions. To minimise the potential for irritation don't pick a time when there are a lot of changes being made in that area, for instance if other people have active branches where they are touching that peice of code. 5. If you are (almost) completely refactoring a routine then feel free to relaign, it'll be a mass change in the diff anyway. In shared or otherwise public codebases there are two general rules: 1. When making your own projects available, align as you like. If other's don't like it politely remind them who owns the project. Be prepared to ignore (or politely and professionally respond to) people telling you that your descision is wrong and sometimes being a dick about it. 2. In other people's projects *follow their coding standards* and don't be a dick about it yourself.
That'll work. Really anything you can run on the command line that auto-fixes indentation (or whatever else) can be hooked into a file watcher and applied on save. Not advocating for Webstorm over VS Code btw. They're both great tools but I prefer VS Code.
it's the other way round actually. vs code just starts faster. Not saying that vs code isn't good enough for most web projects though. But you'd need alot of plugins in vscode to archive the same features as webstorm.
also better is very subjective. For some people webstorm might feel to complex / heavy, for other it's the ideal IDE. 
the amount of plugins you need for vs code for simple features on the other hand isn't funny? stop fighting who has the better tool. It doesn't matter. You can archive mostly anything with both.
wtf why would you put a function in getter in a first place?
Honestly this doesn't sound unusual at all and at this point at least where i work this would barely take you outside of the title of junior. Building things with "Accessibility focus" is a standard for any application with a large user base (or anything government related) and hitting WCAG AA and 503 compliance standards is incredibly simple (gets more complicated with AAA). The same goes for testsing, if you (or your company) is not writing unit tests (for ngx you're likely using jasmine/karma) and doing end to end testing and requiring them for any check-in something is wrong. Don't get me wrong, you're doing things completely right and at least based off your post seem like you're likely a good employee. But nothing in that post makes it seem like you should be considered a senior developer. Like the other person said you should just keep picking up more skills and improving your depth of knowledge on your current skill set as well. I would add on to what they said and suggest picking some java or c# and try writing your own rest api and deepen your knowledge on building and interfacing with them, familiarize yourself with oauth if you haven't already, look into getting some web security certifications and find some fun projects to work on outside of work (if you are still enjoying what you do) to help expand your
Yeah I thought webstorm was a web IDE, whereas VSCode can be used for any language with the right plugins.
I'm entirely unsure of what "Node for SPA" even means. An SPA (should) be, essentially, static assets which communicate with an API (Apache triggering PHP will serve awkwardly for the purposes of this conversation) to update the DOM. 
I just call the ghostbusters.
Just use Atom and ignore yet another shit from Micro$oft with telemetry.
 for(let i = 0; i &lt; localStorage.length; i++){ console.log(localStorage.key(i), localStorage.getItem(localStorage.key(i))) } 
Good answer overall, but especially this: &gt; This can happen through good architecture but it can also happen by talking with other teams that theirs interacts with in order to understand what problems are possible. It's a lot about the things *around* the front end code, in my experience. Being able to participate in planning, project leadership, visual/UX design, backend, testing, etc is a good step towards seniority. It doesn't require knowing all those things, but at least knowing how they connect to the front end part of the project. 
I also use VS Code and love it too but I like how fierce the competition in the editors is and at the end of the day everyone wins.
Exaxtly
Even if you're a student VSCode is still free.
If you're a professional and you don't want to pay $100 a year, you've made a bad turn somewhere. 
He probably meant that WebStorm is also free for students, who can get all of Jetbrains IDE's for free.
Atom's autocomplete is a joke.
You saved me the time of searching for all these steps, thanks for sharing.
&gt; I was excited. Everything was broken, this is a developer's dream. What? Having to fix someone else their crappy code is my worst nightmare. Unless I get the time for a total rewrite.
The ability is what is important. The results are not (for the editor). Why? Because there are 100s of formatters for the 100s of languages. VS Code is unopionated when it comes to formatting because they know every developer is going to want to use their preferred formatter/lint. I do concede that VS Code should come with a default lint/format at least but I guess they see as a "why bother" when there are far better librarys there then what they are going to create.
Couldn't care less which is "better". Just find it funny that a simple format on save requires a plugin to do so. Just like inteliJ, JetBrains and Notepad++. Unlike Eclipse and VS Code. I would've assumed to be a standard feature for all editors as it's so darn helpful to keep cleaner code.
Lol didn't mean to add JetBrains. I'm comparing a saving feature, what does it matter if program is classed as an IDE or not. I merely stated I found it surprising that auto format on save is not OTB for any "program that edits a file that contains text".
&gt; If you're a professional and you don't want to pay $100 a year, you've made a bad turn somewhere. I can afford $100, I use Visual Studio Professional for work. But for the price of $0 for a *very* good editor, that sounds good to me. Microsoft is doing the right thing.
Neither does Mobx.
I guess I'll give it a shot! Only way of really knowing...
Fixed a lot of times ago, old fairy tales. I use Atom sometimes on my desktop Celeron (machine for media streaming mostly) and can't remember when Atom was slow last time. Really, I seen it starts after 7-10s, but always without any minimal lags.
"program that edits a file that contains text". so word should also do this right? you realize there is not one right way to format text. most programming languages have multiple flavors and best practices. (unless stuff like go or elm)
Build an index or trie. Or try a js search engine. 
Well if you're talking about the fixed that rewrote a lot of the core of atom to native code, I'm pretty sure i tested again after those. I really wanted to believe in Atom. But sadly i couldn't because, for me, vs code is just miles ahead
Thank you so much for your detailed response. It really made everything clear. I really would like to learn how to build a java backend so I will study that after finishing data structure and algorithm study with CTCI.
Still waiting for the "extend" phase to start :\^)
No, that isn't correct. Syntactic sugar means it doesn't come out the same as classes on the other end. It means it doesn't have all the same behavior as classes. It is prototypes, but wearing a mask, tricking you into thinking they're classes. If you look at how they behave after you use the new class object, you'll see that.
https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53
Just my way of venting about a religious approach to testing being a little too black and white in some cases and how that mindset cost the company weeks of a developers time for something that nobody wanted to merge or maintain.
The link to lit html in the article is broken 
your comment doesn't deserve more than that.
There is a checkbox on the commit screen to format if I recall. Also install a beautifier githook.
I tried going from WebStorm to VSCode. The lack of basic features was annoying, and hunting for plugins to fill the gaps further so. There's still features I miss, which I haven't found replacements for in VSCode. So when I start my next chunk of server/web work, I'll switch back to WebStorm. I don't like that it's bulky, and Java. It's an ugly beast, as are all their IDEs. But it has more features and works better, at least for now.
keep your shit in your virtual reality.
Webstorm is free to students for non-commerical programming
My question would be: why are you doing this on client's side and not on the back-end?
atleast my shit can intellisense from node_modules. Which Atom Ide still can't.
I've been a Front-end Dev for 12 years, but have been using JavaScript on a daily basis for 5 years. When going for Senior roles, I'm always asked about the depth of my js knowledge. That, and gauging my experience as someone who works on teams, can help to educate juniors, why I would choose one direction or framework over the other, etc. Seniors are evaluated as leaders or educators. Though they may be seen as leaders, they don't necessarily have to be a Lead. It always comes down to experience and understanding. 
Atom stays strong and now develop IDE-modules together with Facebook. You decide what to use, but please don't repeat any nonsense from M$ bots.
https://atom.io/packages/atom-ctags https://atom.io/packages/atom-ternjs Yep, your shit.
Good vim bindings 
Sorry it's not service workers it's web workers, +indexing (as above poster said) is a good idea. ~ https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API 
Never tried this solution personally, but maybe maintaining those words in a local sqllite table and then doing a SQL search in that table could be faster. Normally SQL has some optimization for those kind of search.
Not to be a jack-ass, but all of your questions seem to be answered here already: https://stateofjs.com/2017/introduction/
^ The correct answer. John Resig (the jQuery guy) has a great article on trie performance specifically for javascript: https://johnresig.com/blog/javascript-trie-performance-analysis/ The conclusion is that tries are orders of magnitude faster than linear searches, but building the data structure itself from a string or array is expensive, so you you'll want to do it offline (or at at a minimum on the server, just definitely not on a mobile client) A 20k data structure is actually fairly small as far as data sizes go and can conceivably be held in memory on the client, so you might be able to get away with doing that and skipping input event debouncing (i.e. lodash's debounce). For anything with scaling concerns (e.g. something like a few million records), you probably do want input debouncing and you do want to keep the data and search on the server side, and use something like elasticsearch or at least your db's search functions as opposed to hand rolling a custom thing in js.
Then that isn't actually random, is it?
I don't even see the benefit of aligning like that. It may seem aesthetically pleasing, but for an object there's no point to seeing all the values, as the info is useless without also seeing the key. An object is essentially a collection of key value pairs, and the elements in that collection ARE aligned in the first example 
Both of them abandonded (lastest release 5 month - 1 year). Also issues/stars ratio on github repos seems legit.
You can configure your diff tool to ignore spaces, making this a non-issue... A more valid issue in my opinion is that aligned code tends to become either single-spaced (or worse and sadly common, misaligned) when you consider team scalability, because there isn't good tooling to configure alignment in the same way one can setup prettier in a project's workflow. There's always going to be a team member manually dealing with code alignment in an editor that doesn't support it and you don't want to be the jerk shoving your preferences down their throat and having them waste their time spamming the spacebar. Another debatable concern related to auto-format tools like prettier is that aligned code doesn't really play that well with the 80 character width rule.
The word "deterministic" means "non-random". https://en.wikipedia.org/wiki/Deterministic_system
It was actually renamed Javascript to solve a conflict between Netscape and Sun but it did inherit from Java the syntax to appeal to the masses. The prototypal classes of Javascript, though, are inherited from the programming language Self, while the functional approach was inherited from Scheme. Anyway, I think what you're after resembles the mixin pattern. Your code refactored to use mixins would look like this: // Base class. class Human { constructor(name) { this.name = name; } } // Encapsulated composable functionality. let ScientistMixin = (superclass) =&gt; class extends superclass { experiment() { console.log(`${this.name} is doing an experiment...`); } }; let PlayerMixin = (superclass) =&gt; class extends superclass { constructor() { super(...arguments); // required this.favouriteGame = 'Go'; } play() { console.log(`${this.name} is playing a game of ${this.favouriteGame}...`); } } // Apply mixin. class Scientist extends ScientistMixin(Human) {} class Player extends PlayerMixin(Human) {} class PlayerScientist extends ScientistMixin(PlayerMixin(Human)) {} // Make objects. let Joe = new Scientist('Joe Mazzini'); Joe.experiment(); let Marie = new PlayerScientist('Marie Johnson'); Marie.experiment(); Marie.play(); Note: I took the liberty of removing setProp, changeProp as I don't think you actually want that functionality in your base class. Word of warning, I wouldn't recommend rolling your own composition scheme. Either use a framework or just avoid it completely. You can get some really weird bugs and nasty situations if you aren't careful. You never know what assumptions your other libraries make about your objects, so you can't just f*** with them at will :D. It is also why I asked you what you wanted out of your composable elements. Mixins give you the multiple flexible inheritance that you may want, but they have their own caveats (ex: its best to avoid passing arguments to mixin constructors). Knowing what you are actually trying to do, I may be able to help more. Lastly, I am aware but I'm not a big fan of MPJ. It's cool that he shares his knowledge of functional programming as he learns the concepts himself, but he did make some mistakes in his earlier videos which led to spreading misconceptions. I think he rectified them in later videos, but still..
Can do this? Even if it can, the fact that it’s not the default behavior is a dealbreaker for me 
Have linting run on your pipeline
As expected, haters gonna hate.
random is fake news
Excellent. Then you're more than the avg dev. It's a combination of all. Not 1 separately.
“FREE” and “Made by Microsoft”....🤔
Iirc, Google chrome caches randoms or caches the page’s randoms. I use a rand for urls and it comes out the same for every iteration in a single page. 
What about https://www.codecademy.com/learn/introduction-to-javascript
There's one simple yet not so clean but easy way to solve your problem: divide the array into smaller arrays (assuming you can divide the data you have). Then simply use the user's first input to determine which array you'll need to iterate over by using your filter() function. Test it and see if it performs better. Another solution could be to use a proper Database such as SQLite and let the Database handle the search.
wow, this is a pretty cool idea! i was even more surprised by the fact that it works smoothly
Oh yes, they'll definitely take your word for it, right their archaic ways, and ask you to please *please* make room in your schedule, to be senior VP of JavaScript.
Phpstorm and webstorm are better than vscode though in basically every way.
Uh, I wouldn't consider Eric Elliott articles authoritative... Honestly, if you guys are arguing about design patterns, I think you're doing it wrong. You need to focus on solving problems. Not just "ew, you're using util classes" problems. I mean like, business problems. Anyways, I was the frontend guy in a team composed primarily of C# devs in a previous job. We had an intranet built on 10 years of prototype.js+jquery spaghetti, which the whole company used to do everything. Everyone knew it took a boatload of time to add even the simplest features. So I built a toy app in like a weekend with angular and showed that it was a promising solution to the code rot problem we had. A couple years later, we had accomplished some really cool stuff: we revamped time tracking and issue tracking (which were mission critical pieces of infrastructure), added push features via sockets, chat, real time updates, etc. We now had features we had never dreamed of years prior. But angular was starting to show some performance issues due to the insane levels of complexity that we had pushed it to handle. I mean, any given page had like 20k DOM elements that actually did things :) One other related issue that we had known about for a long time was page load times. The layout that wrapped the intranet application was a significant part of the jquery mess we originally had, and it was literally impossible to refactor (believe me, we had many very smart people try and fail multiple times). We had a new pilot project starting for a new feature (basically a clone of trello, but integrated to all the rest of the intranet machinery). I introduced a new framework that I had just created as a trial. I explained that it used a virtual dom mechanism (yes the same principle behind React and Vue) so it would be a lot faster than Angular's dirty checking based approach. Since the pilot project was kinda experimental, I was able to start from scratch and I replicated most of the layout in a fraction of the amount of code that the original layout had. It turned out that backporting things to the new layout was actually doable, so moving away from the old mess was finally looking feasible. And the new thing was blazing fast. Soon after I found another job through my open source framework that was willing to offer me much higher pay. One of the last things I did before leaving the C# shop was suggest productizing the once-jquery-frankenstein-now-world-class-intranet. I found out a few years later that they had done just that, selling it to big pharma companies, and that the whole thing spun into its own child company, going from being a cost center to a profit center. I'm now working at Uber working on another open source framework.
That is how all random functions actually work, you just haven’t noticed it before. If you’ve done any work with microprocessors/Arduinos you’ll see that every time you restart the device it will generate the same random number because by default it will have the same seed value each time the device restarts. I suspect that in that environment it has the same problem, it’s getting a new instance in each test, but the new instance still has the same seed value.
Not all RNG systems do that. You're probably thinking of [PRNG](https://en.wikipedia.org/wiki/Pseudorandom_number_generator). Some RNG take electromagnetic noise as input. IIRC, some cryptographic systems where real randomness actually matters, you can use things like mouse input to generate entropy.
I started learning JavaScript reading this book: http://eloquentjavascript.net/ Very nice for beginners.
I use webstorm for all my open source work, cause it's free for that too. I use VSCode when I'm not able to use webstorm, though.
or open source developer :D
You shouldn't be doing it this way anyway - it should be a linter run on build and the build should fail because of poor formatting.
Also free for open source developers, which is an increasingly common boat to be in.
&gt; Facebook lmao
Apart from type safety - abstractions. Graph upserts/inserts are super neat, eager loading, automatic de/serialization of js types like dates and so on...
404
[You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) is a great series for understanding the language thoroughly.
Yes, isn't that a solution to what they were saying? I'm not sure I understood the git problem. /u/trout_fucker and /u/Madd0g I honestly don't want to start a holy war, just make sure I understood what your side is. I simulated that minor change in the code (which moved the whole spacing to keep it align) and I don't see the problem when diffing: [Webstorm diff](https://i.imgur.com/Bx9Ucct.png) The very crude terminal diff: Δ merl /Users/merl/Desktop $ diff -w 1.js 2.js [18:08:08] 15a16 &gt; missedsomething : 'fixed' Δ merl /Users/merl/Desktop $ [Or git's diff](https://i.imgur.com/e6JCaNK.png)
&gt; And that's a code I came up with just as an example That's written in the original post. It's not even my code, I took it from some js library used by reddit. I just needed code to align.
What if a change the variable name? I do nothing. Whenever I feel like or just at save it automatically aligns everything.
I wouldn't be surprised if we found non-randomness in those, as well, just determined in a way we can't yet link a pattern to.
Yay! That's the point, why not js too?
Like I showed in this response, either you don't use the diff tools correctly or I don't understand your point.
It's interesting that you continue using a dollar symbol in microsoft while downplaying one if it's free products. 
No, you were supposed to describe the advantages of VS Code.
How much does an average developer get paid? 50$/hr? 100$/hr? Depending on your country it will take you at most 3 hours to get back the costs for a full year license. And if you were to set up VS Code with the same features as Webstorm (if even possible) you'll have to take more than 3 hours...
Well, I'm not using classes ever xD No to classes, no to `new`, and no to `this`. I'm using this temporarily in a couple places until I load the properties from a json file.
The reason why I would not use typescript is because it creates a lot of noise which makes the code more difficult to understand. Yes, it makes writing code easier but you will pay a price for this many times over later on.
Awesome but with all this talk about testing they forgot to test their fron-end The css is all screwed up
knex.schema gets used when you're actually creating/editing tables and columns. I've only ever used that inside of migrations. A quick google brought up this site which has a good explanation: http://perkframework.com/v1/guides/database-migrations-knex.html
Well, isomorphic SPA requires you to actually run some JS server, that would render initial page (and I mean send to you an actual HTML instead of a recipe how to build it in a browser). Without such thing you would have to design some dirty fixes in order to e.g. dynamically generate some content for search engines. Of course in-house has no such requirements, so here static js assets would be enough.
One of my coworkers visited the Cloudflare (I think?) offices, and saw that in their lobby they have a bunch of lava lamps, and sensors that take input to use in crypto key generation. Though that was pretty cool.
TypeScript makes working in a team much more doable.
So I don't have to transpile.
Old habbits from my C# days. ;)
That's the thing though, you don't have to add all that actual noise because any JS is valid TS.
just repeating my own experience... 
Sure, for you! :) I find Webstorm incredibly bloated and slow compared to VS. I’m not saying YOU HAVE TO SWITCH NOW!!
[Relevant Tom Scott](https://youtu.be/1cUUfMeOijg)
Why waste entropy when you don't have it. 
There's a [Tom Scott video](https://youtube.com/watch?v=1cUUfMeOijg) about this! It's quite a cool system.
Or, like, binary search.
It is unnecessarily verbose. You can do more with substantially less which means less code to write, less code to maintain, and less code to test. It will in many cases execute faster by eliminating OOP too.
what is Googlebot?
As far as job titles go, it's all random. There is no standard. As far as useful skills go, when you approach a solution by looking for ways to NOT write code I'd say you are a senior dev.
I have had plenty of success with this. Before telling interviewers I write large open source applications completely avoiding *this*, *call*, *bind*, and *apply* I lead in with my Github projects that have a thousand github stars and millions of NPM downloads. It allows me to skip past a lot of nonsense and bad practice questions in the interview.
Really? I actually prefer the vim bindings in webstorm. The vscode vim plugin is really good but it drives me crazy that you cannot access your history of colon commands. I haven't used vscode in a long time so maybe this has been resolved since.
The Google crawler 
The Google crawler 
Tooling is so easy with a little effort to earn. The gain outweighs the negatives. Especially with @babel/preset-typescript 
I'm currently writing my own codebase for a startup. Here's why I decided to use FlowType instead of Typescript. 1) Flowtype is more forgiving when it comes to object types. One of the powerful things about Javascript is that it's struct-like datatype, Objects, can be easily extended, annotated, mutated and changed. I understand that may be one of the things that TypeScript aficionados feel is "wrong" with Javascript, that needs to be addressed. Unfortunately, most JS libraries - even libraries with DefinetlyTyped defined types - were not designed to have objects with strict structures. For example, I have express middleware that I use to manage JWT based authentication. // verify jwt.verify(token, app.get("superSecret"), (err, decoded) =&gt; { if (err) { return res.status(403).send({ success: false, message: "Failed to authenticate token" }); } else { // if everything wend well, save this to the request for use in other routes; req.decoded = decoded; //&lt;-- Throws an error in Typescript because Property decoded does not exists on type Request next(); } }); Yes, I know that I can create an express.d.ts file that contains declare module Express { export interface Request { decoded: string; // etc. } } But while there times I want to be able to define a rigid type structure for an object to catch errors, *this isn't one of them.* Not to mention that Typescript really does assume a very Object-oriented approach to programming, using class structures and the like. Not surprising, given it's C# roots. But here's the thing: I use mostly functional approaches, currying and the like, rather than relying on class and it's related this.properties mutations. To get that working well in TS requires a much more rigid definition structure. I *like* static typing. But here's the thing: I could use Typescript and everything could take twice as long, or I could get 90% of the benefits of typescript with Flow Type with only 10% of the work of Typescript. Are there some errors TS catches that Flow doesn't? Sure. I'm sure I could find some. But I mainly use a type system *because I want to catch possible runtime errors with undefined properties, make sure functions don't crash, etc.* As I said, flow type does 90% of what Typescript does and takes 10% of the work. Why would I ever choose Typescript? 
Because it's a time sink which adds less value than other potential uses of that time e.g. writing more unit tests.
Not using classes while attempting to recreate them in another way is working against the language rather than with it. I don't get it, what did classes ever do to you? xD
I use typescript in my node projects, but I specifically, willfully, purposefully do not use their transpiler. 
It's not that we don't know what's causing the outcome, we actually have proof that it's completely non-deterministic (true randomness). Read up on Bell's theorem.
I use IntelliJ, but you tell me to get VS Code. But the backend I work on is in Java, so... no. That's fine, if you want to write an article about TypeScript, but I don't need your IDE input. Thanks. Also, to answer your question, sometimes I don't feel like writing in TypeScript. I like utilizing prototypical inheritance just how I have been using it, and the majority of time, I don't need types to tell me what a variable is going to be. It's a skill I picked up with coding in js for so long. Plus, when I switch from Java to Javascript, I like the freeing feeling of writing in JS. But then TypeScript kind of takes some of that away, because it's making a loosely-typed language into a strongly-typed one, and I don't really like Java because it's strongly-typed.
What does your filter function look like? A 20k array shouldn’t cause perf issues unless you’re doing very expensive checks on each item.
If you have better typing you don't need as many tests. 😁
It’s never felt they were too hard to use, just sneakily obtrusive, especially on big, fancy projects. Noticeably long running times every save, too many different tasks to keep track of, inevitable dependency problems, and just trying to figure out quirky bugs. I wish you didn’t have to do a ‘build’ task every save. It feels like a corruption of the original spirit of build tools. The sticking point is traspilation. You gotta do that every save.
On man WebStorm has phenomena TypeScript support so you should feel right at home. And you can totally use prototypes in TS still if you want. 
I don't want to have to if I don't need to. Especially if I am embedding a SPA in a different web application.
If you dive into the article, Jonathan mentions `--checkJs` and `// @ts-check` comments which you can use on JavaScript files without needing any compilation step.
First, I wouldn't just take every article by anyone, including Erik Elliot as gospel that you should always follow. Second the only way to win arguments if you are a lone soldier among a self proclaimed elite, is to produce something to backup your arguments. I was the sole frontend dev amongst a team of C# developers at my last job, and we used jQuery for everything in a large single page app with hundreds of pages/views. It was a hassle and a half to get any new features running and out to production, like months for simple pages for just tabular data. I went out of my way and built out scaffolds of new stuff using Vue.js (what I had experience with at the time) in like 1/10 the time it took to get one of our pages running with our spaghetti code. After showing our management team the business value that added, as well as how much easier it was to test, along with the better quality code (partially due to it being a front-end dev to build it rather than one of our backends who gives 0 shits about how frontend code looks. Sadly this is the case at some places) it was an easy sell. 
My last job was shown to me by a recruiter. It basically said, "Looking for Angular developer with Node experience." I said I didn't have Node experience, but she said that was fine. I went to the interview and told them about my Angular experience. They asked if I had any experience with Node. I said I didn't. They said, "We're looking for someone with Node experience..." I said, "If you need an Angular guy, I'm your guy. If you need a Node guy, I'm probably not your guy." After leaving the interview, I got a call from the recruiter: "They loved you and want to offer you the position!" I was boggled, but she said it was because of my Angular prowess. I was there for 6 months and spent *maybe* 3% of my time on Angular and 95% of my time on Node.
I dunno mate, we have swagger generated typescript api. You can drop a lot of unit tests because the code literally checks itself at compile time.
To be honest, that sounds like a bit of a false dichotomy. Most of the time I've seen the work of getting typed JavaScript set up paying for itself long term, allowing you to write more tests that matter as opposed to boilerplate tests for runtime type checking.
Because it's not javascript. Most languages can compile to javascript today, but I don't use those for the same reason, they're not the language I do want to use.
It's not a false dichotomy - you can only spend each hour once. If you spend it doing A, you can't spend it doing B as well. I wrote a lot of code in TS before reluctantly concluding that it costs me more time than it saves.
T JavaScript is valid TypeScript though. 
"Use the firefox debugger" Saved you a click.
My latest project using dataTables and jquery. dbcc.bitballoon.com
Eric Elliott has written quite a bit on Typescript, I recommend two posts (links below). Here's one excerpt that offers a reason not to use Typescript. &gt; I worry about building up a large codebase using TypeScript, only to have the ECMAScript spec introduce conflicting keywords and type features such as `interface` and `implements`. https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3 https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b
1) There's a level below which something is too simple to be worth the effort 2) You might prefer some alternate type system, such as Flow 3) You might be coming from a stronger language, like PureScript, Dart, Fey, or ClojureScript 4) You might be involved with some fullstack junk that doesn't tolerate that stuff well, like Meteor
https://www.youtube.com/watch?v=v2ifWcnQs6M&amp;index=1&amp;list=PL62E185BB8577B63D Any thing you can find by this guy will vastly up your overall programming skills. Its a very college style talk, but its highly educational. This playlist will take you through the full language and point out some extreme stupid points to avoid that you'll find people only get stuck on. This video series breaks everything down so you can see bad decisions very quickly and avoid whole frameworks and styles.
That's fair, but everything has an opportunity cost. I just don't think the opportunity cost is generally that high, but ultimately I can't argue with your experience. It definitely varies from person to person and from project to project. At the end of the day, it's on our team to lower the friction there no matter what, so feel free to DM me with any specific pain-points you ran into.
I hate hearing. We tested it with swagger. I want a api fully tested. 
it's written in JavaScript??
Eric Elliot is a man of many opinions, but I still don't know why I should care. 
No, but it has a Javascript engine to render websites. But it's not viable to have a full-blown one, like chrome (would be to expensive to run). Instead it has a heavily trimmed one to make js rendering faster. As the article outlines, its clock is accelerated and the pseudo random generator doesn't actually work properly. But since it's only the crawler it doesn't need to be that way. 
Are you working alone? The biggest benefit to TypeScript is that when your team mates picks your code it's much easier to understand thanks to all references, autocompletion etc. 
Why do you not like it? Is there any technical con to it? 
ah, ok, thanks. tbh i figured Google just used chrome *as* it's web crawler and just collected website data from there. 
I can piss farther than that
...what about it? VS Code is free, no two ways about it.
You dropped this \ *** ^^To ^^prevent ^^any ^^more ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¯\\\_(ツ)_/¯`
Woah, I walk by there all the time and wondered why they had so many. TIL...
I tried doing this in an Angular project and it was having none of it :/
A lot of this is way over my head, but jesus, super cool. 
Did you ensure the asterisks are included? Also, webpack may need an entry for module resolution.
```Why would I ever choose Typescript?``` Stability :( 1 - ```flow status``` often restarts the server. 2 - flow fails spawn the server after trying 3 times 3 - doesnt support 32bit systems if you have an old computer 4 - ```type X is not compatible with object Y``` is not clear enough. /rant I like itand i'll keep on using it, but it frustrating at times.
This is just a vague ad hominem rebuttal. What does it matter if he's got opinions? He backs them up with long blog posts explaining his reasoning. What, substantively, do you have a problem with in either of these posts? They seem to directly address OP's question, even if you don't like the answer.
How do people use external libraries that don't have typings? 
There's thousands of different TypeScript definitions here... https://github.com/DefinitelyTyped/DefinitelyTyped And VSCode uses that under the covers as well.
It definitely does NOT take hours to write a few interfaces.
Do you have a source on that? Because I think that statement is very untrue.
1) Isn't that what you want? 2) Ditto? 3) Who in 2018 still has a 32 bit system? Even cloud providers are using 64 bit OSes. 4) Then use Glow for the error messages. 
Not to be a grump, but if you were using a staticly-typed language with any half-baked IDE 20 years ago, this behavior was available.
Honestly I just use markdown, but a good software solution is indeed needed
It doesn't matter. What matters is that you can, and somebody else might have done so on the object you are working with. It might be unusual, and bad practice, but it's not impossible.
`git diff -b` is, I believe, the flag you want.
I think I'll try this out today. Thanks for sharing.
Its impossible to know for sure without seeing the code, but its funny that &gt; Node for SPA, Apache to trigger php jobs, Nginx for the static assets Sounds really shit, whereas &gt; Frontend asset build with Node, PHP backend, and Apache with an Nginx reverse proxy for static assets Sounds pretty reasonable.
We used it on a project last year and I felt the same way until I actually started using it. 1. You know exactly what you're getting in every function and variable. This is especially valuable for thirdparty code and built-ins. You don't have to go to the docs to check what things do. 2. Refactoring is unbelievably easy. I knew the value of this on legacy projects, but I figured it'd be overkill on a greenfield project. Boy, was I wrong. It's amazing how many times we realized we named something wrong or needed to tweak something. Refactoring something that would have taken an hour to check various places in the code base, took less than 30 seconds. 3. The overhead is minimal. Some things it can be a pain, 80+% figures out implicit typecasting. 4. Eliminates run-time errors. I haven't seen a single runtime exception from an unexpected conditional with TS. Yes, we still write some bad logic but we don't run into unexpected exceptions.
Even when refactoring? To me the ease of refactoring pays for any overhead of TS.
Nice, well done! A little note is that your styling in the articles are a little bit confusing. Titles and links look the same (green) while subtitles have underline (common indication of links). 
I hear ya. I'm pretty excited for [parcel.js](https://parceljs.org/) though, it's super easy to drop in, pretty much zero configuration, and very fast. I'd definitely recommend checking it out if you haven't yet. Build tools are getting better with each generation.
Its a hexo theme. Uncompiled code is [here](https://github.com/deadcoder0904/100dayz-code) &amp; the static site is [here](https://github.com/deadcoder0904/100dayz)
Cuz I don't wanna.
zero config it seems
Here's my version for bitcoin - let price=10000; setInterval(()=&gt;console.log("$" + price--),1000)
I have successfully searched 25k product listing as follows: Create an in-memory database using Loki.is Import records into database. Use SQL "like" queries to filter the data It sounds like a lot of extra complexity but it actually was fairly simple to implement. The performance was incredible. I could filter the 25k products to 10 or less in a half dozen key strokes and could requery the database on each key up event. 
What about a common UML Editor? An architecture is nothing more than a collection of different packages and classes.
You created these projects day after day? Nice site design btw. Simple, but not boring. :)
&gt; I can't ng-repeat table rows because it creates extra nodes that break table Really have no idea what you're talking about. I've done this many times with no problem.
I am really new to typescript. Recently I tried to get a project working in react-native with redux using it. I couldn't figure out all the different types I was supposed to be using for the redux setup stuff. I think I bit off more than I could chew on that one.
Could someone explain the purpose of things like CoffeeScript and TypeScript? I'm a total noob and all I've seen is it makes everything look less scary and eliminates bracket hell.
Make their own. We make our own typings for our internal modules.
Yeah I had college then so didn't have much time. Also, someone said make 1000 throwaway projects you will learn a lot &amp; indeed I did. Now if I create something, I know if its gonna be profitable or not because of all these stupid projects.
1 - normally flow status should not restart the server if it is active, only parse and validate changed files, but sadly it does and it takes time. see: https://github.com/facebook/flow/issues/3323 2 - it tries to start the server in order to validate your files but fails, see: https://github.com/facebook/flow/issues/390 3 - i used to in 2017 :) 4 - dont know about Glow, I'll look it up, thanks.
This. Types are never really *a problem* when I'm writing JS. I define `const` or use a pure function whenever possible. If I define a `let` I'm easily able to keep track of what it is. Maybe because I come from Java? Types are *by far* not the biggest problem of modern JS (of which there are now few). Prop-types are a perfect medium. If you need complicated inheritance, then you may be doing too much on the front end. 
Thanks for sharing, "Now if I create something, I know if it's gonna be profitable or not because of all these stupid projects. You wot m8? 
The original googlebot predates chrome by a decade though the current version does use some chrome tech
How often do you do interviews?
We are not in 2000 anymore. Microsoft is very clearly not the same company as it once was. Just look at how many open source projects they have.
4 or 5 times in the last 4 years. You don't fail interviews due to honesty.
If using webpack, you can probably just use webpack aliases, no? Or will that mean that the typescript compiler can't resolve the modules?
Is it that you just don't like to work a the same place for more than a year?
Honestly, you'd be insane not to nowadays. I don't care how smart or studied you are, you're never going to be able to mentally target every single line you write to the specific versions of every browser each project you code for (and most of us have many, with different targets), unless you _really_ write for the lowest common denominator. If you're client-side, you'd also be silly not to use some kind of bundler to manage your imports.
*sigh* I wish I had read your comment before clicking
Interesting thanks for sharing. I like the idea of functional programming but it just isn't always possible.
I am very tired of typescript, flowtype, Babel, webpack, gulp, etc... JavaScript is a dynamic untyped language and it's strengths and it's weaknesses stem from these facts. If you want to play around with these axiomatic truths about the core of the language, just use a different language already. Although I will accept babel because it is nice to have access to early features that are coming to JavaScript regardless. The rest is noise. Typescript is noise. 
I've coded for decades in many languages, most of which are typed, and while I generally prefer typing I prefer sticking to the standards. That said I'm always transpiling, usually all the way to stage-2, so I really love having the shiny and new language syntax. What I really enjoy in vanilla is now being able to destructure args, and set default values. It's nowhere near as explicit as a declared type, but it is handy being able to show my input args upfront and imply what type they are later. e.g. if I had something that wanted a string of names like "John, Jacob, Smith" passed in on a prop, I can almost guarantee you that unless I thoroughly commented (and sometimes, not even then), eventually some other dev would turn this: function doThing(props) { // .... const foo = doAnotherThing(props.names); into something that needs to go function doThing(props) { // .... let names = Array.isArray(props.names) ? props.names.join(', ') : props.name; const foo = doAnotherThing(names); but if it were destructured and default valued, the intent is more clear: function doThing({ names = '' }) { // .... const foo = doAnotherThing(props.names); Obviously typescript solves this problem much better, but the risk is mitigated enough that there's less value in me making the move. As it stands I'm more comfortable trusting purely in the wisdom of the ECMA council of elders.
Agreed. I'd love static typing in javascript, but I'm not keen on using transpilers. Last pull request I got by someone adding browserify increased the build time from "instant" (simple concatenation) to 15 seconds initial and ~2seconds incremental. If I wanted long build times, I'd use more C++. 
Is this a public app or a delivery to specific clients? You can sign SSL certificates from your servers https certificate key. Apply those certificates to the clients browser. And on each request validate there certificate. There is a guide here https://gist.githubusercontent.com/mtigas/952344/raw/c9dc77aad02a03e08d53e9e75ee2cea9c3f28160/gistfile1.md. You can use nginx as a proxy to your API and just use this guide or apply the same principles to your node server.
&gt; Plus if you want to play with cool new ECMA features like async/await async/await are part of ES2017, which was released in June of last year. It's already [supported by modern browsers](https://caniuse.com/#feat=async-functions) and has been supported on all modern desktop browsers since April of last year. So you already don't need babel to use them. And you're going to need a polyfill if you use typescript anyway and want to support older browsers. &gt; you don't have to install a bunch of babel plugins and polyfills. You only need to install babel plugins if you're deviating from your default config. It sounds like you're saying that you **can't** pick a particular stage 2 or lower feature and use it, even if you want to, if you're just using Typescript. I don't see why you'd consider that to be an advantage.
Nope they call me a lot but I am interested in creating my own startup which I'm doing right now but having a Github profile helps a lot. So post all your projects there. You might think its a silly project but Github is free so push it. I've get calls nowadays without applying &amp; I haven't even done anything great.
I was talking about my next startup which will be profitable. Not in my dreams or I'm in my illusions. There is actually an audience &amp; similar 1 competitor which is not that great so I'm applying my skills to that niche &amp; I know it will work. But, I know Actions speak louder than Words so see you in a month.
They make their own typings. It can go as deep as you need, or be implemented as you go. Obviously the big typings published to **DefinitleyTyped** are designed to be all-encompasing, but really you only need to get your barebones behavior to get value out of it. Here's the quick &amp; simple typings I made for Mustache 2.0.0 for my project: ``` // Type definitions for Mustache 2.0.0 // Project: https://mustache.github.io/ // TypeScript Version: 2.3 declare namespace Mustache { type Tags = [string, string]; interface Api { /** * Clear the template cache */ clearCache(): void; /** * Pre-parse &amp; compile a template for faster usage later */ parse(template: string, tags?: Tags): string; /** * Render a template */ render(template: string, view: any, partials?: any): string; } } declare module 'mustache' { export = Mustache; } declare const Mustache: Mustache.Api; ``` It's not a full example but you can see it's not really that complicated, you just need to implement the cross-section you use, and add to it as you need more things. Then, there's nothing stopping you from contributing those typings to the Typings project if they get complete enough.
I was at Travelocity for more than 7 years, but it fell apart as a business. It is more than a white label on Expedia now. I was a contract for 5 months after that, but the contract fell apart due to loss of funding from an internal reorganization. The job after that I was a strategy consultant on a 9 month project. The next job was not temporary, but I got frustrated due to various factors and chose to go elsewhere. I was at that previous job for more than 2 years.
As a fellow entrepreneur, i applaud your drive, See you in a month.
Yeah, but look at all of that compared with something like Lisp, R, Python, or even C lang. You gain so much expressiveness when public and private are automatically intrinsic to the declaration context of a reference opposed to manually tagging every reference and manually dictating the association of those references.
Agreed.
Is this exactly the same was what's in chrome Dev tools?
Right, *pure* functional programming isn't always possible, but it is usually fairly easy to incorporate the overarching principles. I view it as more of a "best practices" kind of philosophy instead of a dogma that needs to be adhered to 100% in the real world.
Not in my experience. As long as it was just me, TS was fun, but other developers got tired of it _very_ quickly. And a few type annotations won't save a messy codebase.
Because it failed. Sorry. I actually kinda liked it, but it's a part of a corporate conflict between Microsoft and the company that effectively owns React and GraphQL. That means FB (which has its own competing typings extension) can run as much interference as it wants. This, and the fact that pulling typings from DefinitelyTyped is an exercise in futility and disappointment, means even simple libraries are frustrating to use. I have to either write my own typings, or figure out the exact mix of both dependencies and typings that won't crash and burn. Oh, and it's possible to write a library that will make writing proper typings into a material worthy of a dissertation. Without major cooperation between vendors I don't see this stabilising. Meanwhile WebAssembly (a terrible idea, IMO, but who cares about what I think about bitcoin miner runtimes) is coming, at which point there will be _far_ better typed languages available in the browser. 
The new version of webpack also has this 
wild. where'd you read this, or you work at Google?
😂
Would you consider react components libraries a simple task? Thanks for your suggestion! 
Because fuck you, I'm busy learning the 47 other libraries and tools you're supposed to know if you're a Real Developer (TM). I love web development, but goddamn do I hate web development.
Predating Chrome: I developed websites 10 years ago, googlebot was around then. Find some robots.txt tutorials from the 90s, they'll even mention googlebot. Using Chrome tech now: https://developers.google.com/search/docs/guides/rendering
I work alone and I still use typescript because: 1. Autocomplete fucking works!! I don't touch the code **that** often so having autocomplete is a great "aide-memoire". Also means I can use long descriptive names without having to always type them out. 2. Typos... these can happen but typescript notices them for me. 3. Refactoring... especially renaming member properties. Simple search and replace is just to untrustworthy... which means it's much more work to rename something... which means I'm far less likely to do it.
I’ll be there!
It still uses Leaflet, but Leaflet is a wrapper for APIs and isn't an API itself. The usage is 25,000 hits per day for free tier.
So unfortunately i didn't do any of the research on the tools so I can't in good conscience tell you that this is the best source out there but for all of our front end in house accessibility testing we use the chrome extension "wave" and it has been able to get us to successfully pass all the audit's we've had for all of our projects that required WCAG AA. Along with showing you the errors will explain why it's important from an accessibility standpoint and how to fix it. I think the one thing that was a little difficult to get used to at first for wcag with angular is setting up keyboard accessibility and tab order to make sure that tabbing through a page was smooth and orders made sense and all things (like hints that you would put on hover for a ? icon) are able to be accessed and able to get out of using only your keyboard. but the general stuff like making sure images have alt text, and forms have labels and stuff like that should be quick and easy to maintain. Here is what the app looks like when used to check the reddit inbox page https://imgur.com/cRcz6Rq. Let me know if you have any other questions and i'll do my best to assist where i can.
I have been working with Typescript for over a year now and the Definitely typed collection hasnt failed me yet. The Community is great.
I want to point out that the article makes many valid points, but was written over a year ago. A lot of things have evolved since then, and sometimes the article acknowledges that (e.g. regarding a feature that wasn't in TypeScript until 2.0). Stay cognizant of stale information when reading.
Hey all, I was the creator of a LaTeX resume generator (latexresu.me). I recently just finished making a new version of the website: https://resumake.io The new version has a bunch of new features like saving progress, JSON import/export, switching the orders of sections, renaming section headings, and side-by-side resume preview. Just choose a template, fill in as much (or as little) info as you want, and just press "Make" at any point to see your generated resume. You can change your template on the fly, and when you're happy with your result you can download the resume as a PDF, LaTeX, or JSON document (compatible with JSONResume). Try it out and let me know what you think! Source: https://github.com/saadq/resumake Issues: https://github.com/saadq/resumake/issues
I don't like it for the same reason I don't like tagging Impl at the end of a concrete type. I'd prefer interfaces to be named for what they represent. If an interface is defining the contract for a Payment Processor, I'd name it PaymentProcessor. And implementations can be named for how they implement it: StripePaymentProccessor, ACHPaymentProcessor, etc. 
That is hilarious, thought the title was a joke
Good bot
Browserify is notoriously slower than other bundlers. Have you tried webpack or parcel?
&gt; Not to mention that Typescript really does assume a very Object-oriented approach to programming, using class structures and the like. Why do you say this? What about Typescript assumes an OO style? The support for classes doesn't force you to use classes.
"as many tests", not "no tests needed".
Thank you. And one hit so call the api once? 
It's failed me once on an obscure usage of Winston's color properties. I submitted a pull request and it was merged in a few hours. The community is definitely great. 
Unless I'm mistaken python simply doesn't have the concept of private or public.
Well, you don't *have* to transpile all the time. Chrome and Node support all of ES6 at this point, so for normal Babel stuff, I include the individual files in dev, and have a prod build when I want to commit. For typescript it's a little harder, ts-node works great for development (and I use it in some prod projects too). Browser typescript does need to be compiled, which takes a couple seconds. It's a little annoying, but if you have it watching code it's still worth it to me. 
You can use types for things like (non) nullability and compile-time immutability as well. I can be sure a dictionary key is valid before trying to use it, and I can generate that key type with a one-liner: `type Key = keyof typeof someObject` I can paste JSON output from an API [here](https://jvilk.com/MakeTypes/) and I instantly have type checks and autocomplete for all the properties. Then I can peruse that large nested object in my editor without having to refer back to docs or raw json and risk typos. You're right, type errors are not the hardest problem of modern JS. They are tedious to fix and to avoid, and having no type errors is not something I congratulate myself for. That's exactly why I want automated checks.
Did I say no tests? I said I don't write tests to check types, I write tests to check behavior. 
lol, this is why I never settled for Babel. If I'm going to transpile, it better *really* be worth it.
tbh I'm honestly not sure beyond that. Like I said, I have only used it with small side projects. I couldn't afford it myself and my company has no use for maps.
These situations are pretty easily addressed with a type assertion. `request as any`. Unless I'm misunderstanding your use case?
Then your test coverage is not as good. I've worked on JS projects with lots of tests, but there were still bugs Typescript would have eliminated.
And when you have a base or abstract PaymentProcessor type?
I thought JS already had too many keywords...
The details of submitting a payment to Stripe and processing ACH are sufficiently different that I'd probably not bother to have either, honestly. However, if I did, I'm not above naming either of them `AbstractPaymentProcessor` or `BasePaymentProcessor` -- as that's how they implement the interface, either in an abstract way or as a base meant to be extended. But I don't run into this problem too often since I tend to stay away from base classes. Having something like Single Abstract Method class means I should probably be using composition to reflect the differences rather than inheritance. But that's also my opinion and what I find works for me and the code bases I work in, your experiences might be different. 
What sort of bugs would have been eliminated? I'm curious as I've only ever found a handful of bugs that would've been caught by having a static typing system in place. Most of the type errors I come across are nulls rather than actual surprises like "Why the hell is a list popping out instead of a dictionary?"
I wouldn’t say it’s necessary as a front end dev, but it’s one way to reach the senior status. It’s not a place in the company, it’s a mindset. A senior dev understands the _whole process_, even if the work is only in one facet. 
I'm sorry but I have to disagree. The whole thing is a mess. I commend every single person who has contributed to this effort as they are the hero's here. They didn't cause the mess but they are doing their best to fix it. However, the *need* for this effort is the mess. It's so much effort for so little return. Versioning between JS and .d.ts files are a nightmare. I've gone through JS libaries refactoring but relying on separate god souls who write the typings. But if they don't keep up to the minute, it brings my build down, or I can't use the latest updates when I need to. There's a severe lack of understanding how they are to be created or published. This leads to developers having to config their own ways to get their project to find these type files.... it's a waste of time. The idea is good. But the idea that I have to go and source and configure seperate files, especially from other sources and authors from the original library is a mess. Then comes libraries which publish them but not in an automatically consumable location in their repository, or worse... working with private/licensed libraries which is the reality of enterprise level Web development. They're a nice little thing for a home project I guess when you can just pick standard packages from NPM and don't have to worry about other sources or obscure packages, or it's not a critical app... but other than that... I've left TypeScript behind and can't see myself going back until there's a serious development in it I'm afraid.
Yeah we use Typescript a lot, but rarely uses classes outside of React components
&gt; If you want to play around with these axiomatic truths about the core of the language, just use a different language already. We're trying. We'll leave you for a language without such needless flaws due to backwards compatibility concerns once WebAssembly goes mainstream. Until then, stop complaining that other people are trying to make the language they're stuck with better for themselves and optionally others.
Cool. I'm actually trying to change the background Image.
I seriously do not understand this argument at all. It takes significantly less time to add `: string` to your function parameter then to write unit tests that make sure you only ever pass a string to that function. Not only does it take less time, but you get improved autocomplete while using that function, and if you ever come back to this function you can tell what it's expecting without having to go somewhere else and read tests. This is especially true considering how good the type inference is with Typescript. I rarely actually annotate my variables, only method arguments and datastructures.
I agree but I dont know if I need to know how the backend works or deployment works in order to be considered as a senior frontend. Sure, knowing those will definitely will help me be a better engineer, but we have senior and architect level backend developers who dont really understand the frontend. They dont need to know frontend to be good at their field. That's why we communicate and collaborate, right?
I thought Python has lexical scope. I was horribly mistake: https://bytes.com/topic/python/answers/24416-lexical-scope
I felt the exact opposite. I happy wrote js for 6 years until I started trying and using typescript. I was weary at first that typescript would get in my way but that rarely has been the case. I have been using typescript for everything now. Beside the obvious type checking and refactoring I get free documentation (I have always found it faster to write a ts interface over js doc) and I write much less boilerplate parameter validation. I also can't express how nice strict null checks are. ES6/7 features without having to use babel is nice as well.
I'm trying to!! Right now I only really know Java extensively enough to build credible APIs. I'd love to match it with an Angular front-end but am having a hell of a time figuring out how to do it. (Getting all the pieces and parts to work together then using Angular I mean.)
I don't know if it's just my bad luck or what, but in addition to the minor annoyances that come from transpilation with just the bog standard tooling, I always have that co-worker that wants to do some custom thing and then proceeds to breaks source maps or or some other random shit, often also making things noticeably slower. They get all happy to have made an "improvement", but in reality it's more like one step forward, two steps back. Ugh. 
You have a passwords in your code, I'm hoping those are outdated!
If you're interested, I wrote an article/blog called [JavaScript/C++ Rosetta Stone](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone). In it, I reproduce the behavior of the JavaScript language in C++. It's literally about exploring the level of abstraction just below JavaScript's surface.
I've seen errors in various low-level, high performance codebases where you need to rely on mutability and assumed state/types. Wrong assumptions about `this` that slipped through the tests. Misunderstandings caused by dynamic types that union types would have made clear (or better still - use separate variables.) Some things that may have been avoided with better comments/documentation. But at least with types people can't "not have time" to document the essentials. Worse than that, it makes the code impenetrable when others might want to work on it.
&gt;ES6/7 features without having to use babel is nice as well. ...but you're still transpiling. What's the difference?
Because I want to hurl around untyped objects like the monkey I am.
Im sorry to hear you had a bad experience. In my case, I'm working on an angular application and most of the libraries I am using we're developed using Typescript. Early on, it was common that I encountered the issues you are referencing, but I'm seeing more and more that libraries are including their own Typescript definition files. One example would be moment.js. I was avoiding using it in my project because of headaches around the system.js configuration and type definitions, but I just checked their project the other day and now the type files are baked in. So maybe it's not as good as you need for your project yet, but it's getting better and better every day.
Gotcha 
Found it!!! It comes from putting the class bg-primary in the anchor link for the tabs.
you can use it in desktop in chrome https://chrome.google.com/webstore/detail/easy-noclicker-community/cggbnbfiikmligmjlaklgjbfbkegoane
You can use import if noImplicitAny is false. TS also provides really terse syntax for declaring that a module exists and doesn't have typings. With this latter option, you can use the module with an import statement, without complaint from the typechecker, even with noImplicitAny enabled.
I'm sharing this just in case there are others that would like to build their own word lists from "scratch".
Bye bye linking
`allowJs` permits TypeScript to acknowledge the existence of `.js` files. Without it, TypeScript will only see `.ts` and `.d.ts` files, ignoring `.js`. `allowJs` is also the only way to make TypeScript transpile files with the `.js` extension. For example, converting ES6 to ES5. (it will obviously always convert ES6 to ES5 if it's in `.ts` files) `noImplicitAny` causes a type error every time TypeScript implicitly sets the type of something to `any`. This happens in several situations, not just relating to modules or imports. For example, if you don't declare types for the arguments to a function (for example `function foo(a, b, c) {`) then they are implicitly of type `any`. Similarly, if you import a module, but TypeScript doesn't know the module exists (perhaps because allowJs is turned off and/or you haven't installed the corresponding @types), then the imported module is implicitly of type `any`. Note that `noImplicitAny` and `allowJs` never affect the emitted code, because type errors never affect the emitted code. You can run `tsc`, and it can log type errors, and it will *still* produce `.js` files. allowJs prevents tsc from seeing js files in the first place, which will of course prevent it from transpiling them at all.
?you enjoy only spinning less than two levels of complexity
If you have a large existing codebase, adding Typescript to it is a non-trivial task. Unlike, e.g., Flow, Typescript is an all-or-nothing proposition. Expect to spend a few days to a few weeks making your application work again if you add it in there. If you start with it from the beginning, it's fairly smooth (until you need to import an npm module for which there are no existing type declarations).
[removed]
Please elaborate, ie: i'm trying to do a mouseover an item on the webpage, to thus change the background image. 
This is actually the whole point of [babel-preset-env](https://github.com/babel/babel/tree/master/packages/babel-preset-env). You tell it what targets (`node: 6` or `browsers: ['last 2 versions']`) and it will only transpile what it has to.
What resources did you use to learn other than freecodecamp?
I just started with the course "JavaScript: Understanding the weird parts". It came highly recommended from some friends. As I wrote, I just started it, but I am learning some stuff I had no idea about earlier. Goes a little bit deeper and actually explains what happens under the hood. You can find it here: https://www.udemy.com/understand-javascript/. Unfortunatly not a free course but very worth it's money for 15$ in my opionion.
Some of them I created are using Fake Accounts so don't worry. I emphaise more on security so I never commit them unless they are created from Fake Accounts
FCC, lots of books, blogs, video tutorials, official docs. But the best way to learn anything is by actually doing it. There is no rocket science here. Its just deliberate practice. Anything in life can be achieved with deliberate practice. Although there are exceptionals like Einstein &amp; all but if you practice you will be good. So practice. If you don't know anything post on StackOverflow or here, people will help. They always do.
The best way to learn is to just get your hands dirty! No matter what’ll you do, you will learn something new. I still do a lot of tests and plays and it’s still useful. Keep up the good work and all the best with your startup! 💪
Thank you 🙌
Type errors aren't the only way your code can be wrong. Unit tests have more value because they catch a wider variety of bugs. Your example of adding `: string` is a best case scenario. It takes a lot more time writing type definitions for a third party library that you want to use, or trying to figure out why TS has started giving you false positives. Try doing this... `import throttle from 'lodash/throttle'` ...and then type an underscore. You'll get the whole of Lodash in autocomplete. Time how long it takes you to fix the typings.
Still not sure about TypeScript but thanks for pointing out to VSCode. Wasn't aware how much better it is than Atom!
Thanks does this mean that one can also automatically add html tags like schema to blog posts too.
The problem is that Eric Elliot has a poor reputation for dishonest arguments and evading criticism. He backs up his arguments with links to websites that appear independent, but are actually his own. He asserts that "the community" has a "consensus" on this or that without providing much evidence. And he aims posts at newbies and frightens them by claiming anyone "doing it wrong" (using classes, for example) is making themselves unemployable. Elliot is a charlatan. He is not interested in JavaScript or software development so much as personal brand and the ability to sell learning resources. Commercialising your expertise is no sin, but you have to be upfront about what you're up to, and Elliot rarely does so.
&gt; Elliot is a charlatan. He is not interested in JavaScript or software development so much as his personal brand and selling learning resources. Commercialising your expertise is no sin, but you have to be upfront about what you're up to, and Elliot rarely does so. Yes, a thousand times yes. I have been saying this exact thing too. Thank you for confirming I'm not crazy and alone in thinking that.
You are right that any tool can be misused. The question then becomes: does this tool promote misuse? Trello doesn't promote misuse. Like it or loathe it, it promotes a single, simple Kanban workflow. Tickets move from left to right. Everyone can see everything upfront. Anyone can add anything anywhere. No-one member of the team can act as gatekeeper for the board. The number of cards in play is effectively limited by the size of your monitor. JIRA doesn't do this. JIRA offers the opposite, upfront and well-labelled, as if an endorsement. It offers plugins that appeal to the worst aspects of managers and bureaucrats. Compare how JIRA and Trello display cards. In Trello, a card is displayed in a modal, with simple options - this encourages me to keep cards simple and focus my work on the board rather than individual tickets. Whereas JIRA displays tickets in a full page, and allows me to create long lists of complex subtasks: essentially siloing different parts of the board. Or statuses. JIRA lets me create quite detailed and rarified sequence diagrams for stories. These look useful at first pass and can even be fun to construct, but they rarely reflect reality. Meanwhile, going back to Trello again, the lack of much taxonomy makes it harder to create useless categories divorced from the real world. You can't just blame humans for misusing software. We are all limited by our primate DNA. We like JIRA because it is designed to mesmerise us: with the variety of its functions, the novelty of it's plugins, and the abstract patterns of workflow diagrams. On purpose or accidentally it is optimised to be interesting rather than useful. And prt of being a responsible project manager is recognising your own potential for distraction.
... I count only 21 projects?
Ohh that must be your counting problem then. No worries you can find a lot of my projects on [Github](https://github.com/deadcoder0904) 😃
Thanks for your answer, i'm at the simon game now and i will slowly do it! 
**Note:** I am not the author of the article.
And it shows that your code is actually working and not just doesn't seem to compile right. 
Actually, it's really easy, and it's not even close to "all or nothing." Step 1) Rename "foo.js" to "foo.ts." Bam, automatic support.
Eric Elliott has written a lot about his ass and how far he can stick his head up it.
Why would you try to use and autocomplete with underscore, when you are clearly directly importing the throttle function?
This is crap. First, don't put your code on a single line like that. Also, if you're writing a "tutorial," don't just provide a solution without saying anything about it. There is nothing here for someone who is trying to learn. Second, don't use `__proto__`. Did you bother to [read the introduction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)? It's usage was standardized and deprecated simultaneously.
**[I am the AI Mind](http://ai.neocities.org/index.html)** is the entry portal for a website about artificial intelligence in **[Forth](http://ai.neocities.org/mindforth.txt)** and in **[Perl](http://ai.neocities.org/perlmind.txt)**. The JavaScript AI for Internet Explorer ia a fully functional AI Mind designed to demonstrate how the other AI Minds think and reason. The devious, crafty scheme at play here is to induce Web site maintainers to tweak the built-in web-links and knowledge-base of the free, open-source **[AI Mind](http://ai.neocities.org/index.html)** and to use it to draw Web traffic to their own domain, while visitors see the opportunity to snatch up the JavaScript AI and do the same thing all over again, putting in their own **Control Panel** links and their own innate Knowledge Base (KB) -- if they know JavaScript and artificial intelligence well enough to do so. As the **[JavaScript Artificial Intelligence](http://ai.neocities.org/index.html)** (JSAI) spreads like wildfire across the Web and DarkNet, eager AI coders will grab hold of it and modify it in a kind of **catch-and-release** phishing operation, so that the human race enters into a **pre-Cambrian explosion** of the evolution and mutation of AI life-forms, hopping from website to website, from robot to robot, from server to server. Of course, it all started here in the javascript subReddit where **ZAP! Your mind is infected.** 
It does eventually.
"eh our build step is already complex, what's a little more complexity guys"
Actually I have no experience in OOP. I first learned in PHP/JS to code very imperatively and have since gone isomorphic JS with a functional slant.
@Davisland summed up my stance on Typescript. It's great when you do not have any dependencies... either that or you're working with angular. There was a time, not long ago, when I was only writing projects with next to no dependencies or when I was in my Angular bubble. Typescript seemed then to be an excellent choice and that everybody should use it. However, when you try it outside of these scopes, you will have constant nightmares. Builds breaking not because of what you wrote, not because of breaking changes in your dependencies, but because that one typing file you're using is not complete or is namespace-clashing with another file and typescript offers no serious mechanism to ignore some of the definition files you're not interested in. Typescript is very eager to eat ALL type definitions it comes in contact with. "types" and "typesRoot" configuration keys do not seem to change anything regarding this.
I’m just glad someone appreciated it haha
Pretty much. I work with many Typescript files that [sadly] are bereft of type declarations.
&gt;I hope they now set the random seed and the date using a keyed cryptographic hash of all of the loaded javascript and page text, so it’s deterministic but very difficult to game. What kind of gaming could they be referring to here?
I have this site, and it gives you a weather forecast at the location you click on the map, or by the search bar, at the specified time. It works fine for me (in Europe), but when someone in North America did the same thing, the results were always being returned to them a day early (i.e. if they select today, 03.02.2018, the card that appears at the bottom is 02.02.2018). I am very perplexed by this, because it always gives me the correct date, and I can only assume that there is some strange timezone kookiness at work. The related code snippet is here: $(document).on('click', '#sendDate', function() { diffDays=999; today = new Date(); forecastDate = new Date(Date.parse(document.getElementById('datetimepicker').value)); timeDiff = Math.abs(forecastDate.getTime() - today.getTime()); diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24)); dayWrapper = moment(forecastDate); if (diffDays&lt;=14){ // add marker to map &amp; associated weather card in carousel makeWeatherCard(latitude, longitude, diffDays); map.closePopup(); } else { alert("Forecast maximum is 14 Days.") } Can anyone see here how someone in North America would be getting results a day earlier than someone in Europe? I've never seen this problem before.
Don't use Date to parse the date --- it will parse into the user's local clock time and the offset is what is messing you up. Since you are already using moment, use moment to parse the date string. You can specify the format -- eg: moment(value, 'YYYY-MM-DD') if it complains about the specific format you are using.
create a npm package - gatsby-new-blog, as the name suggests, new blog for your gatsby site. https://www.npmjs.com/package/gatsby-new-blog
Very very similar. 
Thanks, that was it.
Becareful to null-check any references before using them inside moment(). Instead of throwing an error (which it should), moment will just treat it like an empty moment() call and give you the current datetime. e.g. moment(badReference.date) === moment()
Sure, you could use Service Workers on your *landing page* but I would argue that it is not worth it. If caching and bandwidth is your primary concern, there are many more things you can do before reaching for Service Workers. For example, a combination of a CDN and a long-enough max-age should get you 95% of the way there, without needing to write &amp; maintain a Service Worker. This would also work with browsers that do not currently support Service Workers (Safari, etc).
What about? ```js for (let key in localStorage) { // Do whatever with key // Get value with localStorage[key] } ```
JavaScript. Info Very understandable and make it easier to understand basics 
Made the mistake of paying him for a React unit testing workshop once. He blew the first half hour on technical difficulties, and then proceeded to give an incredibly rudimentary walk-through of setting up &amp; writing some very basic testing. I stopped playing attention to him after that. 
having big TS project can slow hot-reloading... though it can be solved using fork-TS plugins for webpack
That’s really good to know. I’m a longtime Jetbrains IDE guy but switched to VS Code specifically because of how superior its TS support was over Webstorm. Do you think performance has improved dramatically in the last year or so?
Maybe learn Angular. It is a popular JavaScript framework used by many employers but angular has moved on to typescript. So the growth of angular js is very limited.
Seems like you're trying to fix what isn't broken. How does this pay off in the long term to justify learning a new API?
I not javascript specific but I can highly recommend the book *Clean Code* by Robert C Martin. I would also look into how to be able to write automated tests in javascript since that is a very good skill to have when building quality software! Check out *jest* for example.
I enjoy coding. I enjoy coding in Java, I enjoy coding in JavaScript. They both have good and bad and I enjoy both. Typescript put limitations on JavaScript but not providing good of Java. Just a fake thing to make some people feel in better world but in reality is not. My personal 2cents
look into typescript... got burnt by javascript... won't code a single line of it ever again... look into react / angular (the recent one - angular 1 can produce garbage fast... nested scope debugging hell and etc) along with nodejs ecosystem (heavily used on most modern web teams)
Thanks!
Thanks! 
&gt; angular js Angular.js refers to version 1.x where Angular is version 2 and above. Actually the growh of Angular is great. It's just that the React growth is crazy.
This looks very good. May I fork it to generate German resumes?
Another issue is source control history. When needing to go back in a file to figure out why some change was introduced, white space changes slow me down (this line was modified in v5, okay let's look at how it differs from v4, white space only change, okay let's look at the blame of v4).
I love this. I can now watch my remaining bitcoins stake melt from the command line. 
Of course, it's MIT licensed so do whatever you want with it :)
Static websites, by definition, contain little to no javascript so no doesn't really make sense there.
If you want to take deep dive into JavaScript give You Don’t Know JS a shot it’s free on GitHub. 
I agree, it seems likely that Typescript will grow alongside JavaScript better than, say, Coffeescript did. But there's some inherent risk in working on an abstraction layer another step removed from runtime code.
Build shit then get a job
Yup, fair point.
Ok, I agree with that, there's a lot to do before reaching for service workers. But if you can write a service worker, is there a downside to it?
You only listed one framework. React and JQuery are both libraries, and JQuery is pointless in 2018.
Don't bother learning jQuery, you don't need it and as someone who hires devs and has gone on plenty of senior webdev/JS-based jobes no one gives a shit if you know jquery. I care that they know vanilla JS, actually know how it works. React, as others have mentioned, will get you a job the fastest. Vue, while not as important for jobs, is far more pleasurable to use IMO. Learn NodeJS, and enter the wolrd of backend webdev. Realistically get yourself comfortable with something like AWS, learn how to set up EC2 instances, learn the basics of NGINX, learn how lambda scripts work. It might not be necessary for whatever your future job scenario is, but its extremely useful. Learn something like webpack, learn grunt or gulp. You may or may not use them, or even like them, but some places require them in their workflow. That should be a ton of stuff to start on. 
Wow Thank you so much for the recommendation. It looks very useful! Thank you!
That's what I'll do, thanks for pointing out that Jasmine and Jest take that approach. 
&gt; Popularity shouldn't matter in determining a framework. Popularity is important if you want casual support.
I second this. This gives a really good introduction to all that gotcha-y stuff that catches out even seasoned JS developers 
The immediate downside is that it will not work for browsers that [don't support it](https://jakearchibald.github.io/isserviceworkerready) and depending on how much you lean on it for caching, it will likely work against your stated goals (bandwidth, etc). From a user point-of-view, I find it mildly annoying when I look through Chrome and find service workers for a bunch of sites that have no business using service workers (and which I'll likely never go back to), but that is me! 😀
Secrets of the Javascript Ninja 2nd edition by John Resig &amp; few other Authors (I forgot sorry)
How do you redux guys stop yourselves leaking mutations from your reducers?
If you have JavaScript on your back end(node) then it is hidden if you call it from there. Do you have any backend code?
do you mean in ecmascript 7 or 8? "Only recently, the __proto__ property has been standardized in the ECMAScript 2015 language specification for web browsers to ensure compatibility, so will be supported into the future. " Please enlighten me, but it seems like __proto__ will continue to be there
You Don't Know JS followed up with Eloquent JavaScript
I have similar university experience and am not learning front end dev. The tools that I have found useful is Eloquent JavaScript (Free EBook) , and Udacity Nano Degree/courses (surprisingly provides a lot of details and is very helpful). Hope that helps. Best of luck! 
If the question is for version control/git, you make a json file with your API keys, require it in your code for the keys, and add it to the gitignore.
The API could be the backend though. Why not just put the token outside of what is accessible to the webserver and call it relatively?
If we look at it as an enhancement I guess that the fact that some browsers don't support it is not problem. I was thinking that maybe websites should not be taking space on the users' devices just because it can.
Several possible approaches: - Careful inspection of reducer logic - There's several [mutation detection dev tools](https://github.com/markerikson/redux-ecosystem-links/blob/master/devtools.md#mutation-detection) available - Use of higher-level abstractions over working with Redux state (such as [Redux-ORM]() ), or one of the [many immutable update utility libraries](https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities) available I would particularly suggest looking into Michel Weststrate's new [`immer` library](https://github.com/mweststrate/immer) , which uses ES6 proxies to let you write normal mutative code that results in correctly applied immutable updates.
https://github.com/michalczmiel/bln I created open source library to simulate a basic set of logic gates and logic elements. It's written in vanilla JS using functional programming paradigm. I use microbundle and Babel for bundling and transpiling, Jest for unit testing, and ESlint and Prettier for code formatting. It has 100% code coverage and is under Airbnb JavaScript style guide. Looking for some feedback or contributions if you find this project interesting.
great project! thanks
No problem! I hope you continue your success and enjoying what you do!
I guess it will do the best it can using static analysis. Of course, if someone calls a target's method without the context of the target, that would be impossible to know ahead of time. class X { method() { console.log("this: " + this); } } let x = new X(); x.method(); // &lt;--- good setTimeout(X.method), 300); // &lt;--- bad. method used as a function setTimeout(() =&gt; x.method(), 300); // &lt;--- good 
Just here to say that Service Workers are a nightmare to work with so beware.
Not sure why you're being downvoted. http://javascript.info is an excellent resource.
Personal preference, I think Jest is terrible. Much prefer Jasmine or karma+chai+sinon
These are not great questions. Sorry I don't have mr specific feedback.
To start with skip a framework and try to write your own MVC framework. It probably won't be great but you will learn more about pure JS this way. Along the way grow your knowledge of the build step tools. Webpack for example. Lastly pick a framework and get studying again. In 3 years be ready to relearn again. Rinse and repeat
Second the book recommendation. Even as someone working with js for years, I found some helpful perspectives in it. It's just as much (or more) about the runtime &amp; dom interaction as it is about javascript the language if I recall correctly. As a language, I vastly prefer and recommend Typescript for anything that will need to be maintained (e.g. - anything that isn't a quick mock or prototype), and would highly recommend it over vanilla, or flow typed js.
Start: ``` a = 10 10 * 2 = 20 20 * 5 = 25 ----- a = 25 25 * 2 = 50 50 + 25 = 75 ----- a = 75 75 * 2 = 150 150 + 100 = 250 ``` 
What is so bad about jest? We are writing all our tests in work in jest and it’s actually a pleasant experience (as far as writing tests can be pleasant).
That's what I thought, and I just realized that I mixed up a and b once in my math... Thanks!
Fun fun function and his friends: https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q And now a collab. on DevTips channel, awesome to watch and lern about React.js: https://www.youtube.com/watch?v=Mg7Ma5i8NgM&amp;list=PLqGj3iMvMa4LFqyGab_aR7M0zfQm2KTuX Inside the Ionic code, you can learn A LOT about web dev. and best practices, which you should use everywhere, not just in Angular code: https://github.com/ionic-team/ionic 
Is it actually a private API token, or are you just assuming so? Some tokens are _supposed_ to be public. Some tokens are _supposed_ to live on the client/frontend.
write a function that returns a dinosaur.
Eloquent Javascript is good, because introduce you to dev. world, like Clean Code book does, not just 'CODE CODE CODE' 
AND IT'S FREE TOOOOO (like You Don't Know JS series)
&gt; promote your project is much easier if you are already ‘popular online’ and, even if a project is not that revolutionary awesome it still can go well. Sure, so it's like those dating tips: \#1 Don't be ugly.
I started work with Angular 2 (now 5) because was the easier way to learn Web Dev., with best practices from John Papa (is inside doc.), and now i have changed to React.js, but i still using Angular on Ionic!
The only really good book I've read on server-side javascript (NodeJS) has been "NodeJS the Right Way". It currently can't find it since it's out of print, but it's a really good idea to check it out if you can find the PDF. Besides that, JS is really interesting
Yeah I actually did too at first :) can be tricky to follow along sometimes
Actually, this may surprise you but tape doesn't really have `beforeEach`. ¯\\\_(ツ)_/¯
These are horrible
Haham I'm learning that!
Dan Shiffman's Coding Train
.
The Coding Train: https://www.youtube.com/user/shiffman
In that case, you could instead of defining globals like op does, define a function that returns your module under test and the related stubs. You'd have a clean one every time. You'd build all the stubs and call proxyquire within that function.
Cool article. I wish he would gone in depth about his experience. I talked myself out of contributing to open source projects that seemed interesting to me because I didn’t know what to expect. After my first contribution, I have become more comfortable and less scared about what project maintainers would say or think about my code. I have since contributed to a few projects here and there. It’s exciting to find projects that need help I can provide. 
To be able to work as a good JS developer you need to learn about 3 things: 1. types and how JS converting them (including difference `==` vs. `===`) 2. prototype chain stuff 3. scope (including closures and so on) As a bonus: learn how to work with node.js and popular modules (such as expressjs). Then you can easily go to a Senior JS Developer role.
Awesome tips, thanks
I actually feel like my main pain point with redux is the extreme bloat you get and the amount of file-jumping (especially if you have constants for action types). This tool seems like it reduces that bloat significantly while remaining relatively simple
Listen to this guy. Learn this book! I'll make it easy for you, here's the [link](https://github.com/getify/You-Dont-Know-JS). The vast majority of interviews will start with questions straight out of the first 3 sections this book. Questions about hoisting, this, closures, lexical/function/block scope are *very* common. If you're super new to JS and you find it too dense, read Eloquent JS, make some projects, and then come back to it.
Start writing an original application. What you need to learn will quickly become self apparent.
&gt; got burnt by javascript... won't code a single line of it ever again... I once shot my toe with a Smith and Wesson, so now I only ever use Glocks.
Surprised there's no recs for JavaScript: The Good Parts. It's a really quick read and probably outdated in regards to new (ES2015+) syntax but it teaches the fundamentals really well.
We mark most of our type definitions as readonly
1. Learn vanilla JS. Like others have suggested "You Don't Know JS " is a fantastic resource. 2. Learn a framework. I would suggest React for job prospects. Also create-react-app is super easy and gets you started with low cognititive overhead. Angular is meh. Vue is very nice and popular in China but there's far less Vue jobs in the US than React. 3. Use tools as needed. If you with React as your framework, don't use Redux, React-router, etc to start. You'll know if/when you need them. Same goes with Angular and Vue. Don't start with Typescript/FlowType. If you need a Type system you'll know. 4. Once you're comfortable with vanilla JS, and a framework start building general knowledge. Try to learn something new every month or every week if you're really driven. Here's an incomplete list of some suggestions: * GraphQL * AWS (Vultr is also very cool and cheap) * Functional Programming (trendy right now) * Databases. If you learned SQL in school you'll be fine * Testing - Jest / Mocha / Chai * Sass / Scss * Node * Express * JWT * ESLint / Prettier Here's a list of tools you may find useful: * [NVM](https://github.com/creationix/nvm) - Node version manager. Makes installing Node and keeping multiple versions a breeze. * [Ngrok](https://ngrok.com/) - Gives you a link that exposes an app running on localhost to the public. Useful if you don't want to touch firewall/router settings just see what you app looks like on your phone/tablet * [Now.sh](https://zeit.co/now) - Instantly deploy to a staging/dev server * [Codepen](https://codepen.io/) / [JSBin](https://jsbin.com/?js,console) - Javascript playground * [VS Code](https://code.visualstudio.com/) Its free and probably the most popular editor. I really like [WebStorm](https://www.jetbrains.com/webstorm/) but it's not free unless you still have a .edu email. [Egghead.io](https://egghead.io/) is my favorite site for video tutorials. Very high quality and a lot of the tutorials are done by the authors of the technolgy. The Redux course for example is taught by Dan Abramov, Redux's creator and he does a fantastic job of explaining the motivations of why he created it. Don't use Windows. Even though it has bash now it still is not a great dev enviroment for beginners in JS. Use Linux or OS X. Mint and Ubuntu are very beginner friendly distros and you can set up a dual boot on your pc fairly easy
Learn these things during one month and you'll be employable. 1.) Npm 2.) Node 3.) Typescript 4.) Angular 5 With these skills you'll find no end of job offers
Another thing I forgot to add. Try to find a mentor. 
I currently try to keep things limited to actions.js and reducers.js (with selectors in reducers.js). So far it seems to help.
I mean, it's a little bit of a wise-ass answer, but it's not at all wrong. The single best way to learn any new programming technology is to build something. You'll start off not knowing where to start, and then you'll figure out that you can just create a simple HTML file with a script block in it and that code will execute when you load the file in a browser. Then you'll learn that there's this thing called the DOM and that JavaScript gives you a way to manipulate it. Maybe you'll write a line of code that makes some text red on the page. Hooray, you're coding now! If you start with a relatively simple project in mind and you start that way, before long you'll have learned a bunch of stuff through copious Google searching, fumbling about and actually LEARNING. Maybe you create yourself a simple PIM (an app for managing contacts, notes and appointments). It's a simple app in almost any technology, but it's also robust enough to force you to learn stuff. So, yeah: build shit, and (eventually) get a job really isn't at all a bad answer. You can watch all the videos you want, read all the tutorials you want, even sit in class all you want, but until you actually try and build shit you won't be learning as much as you need to in order to get a job.
I only said it because I had to go through it myself. I was more trying to be blunt than trying to be a smart-ass. Building shit is the way to learn!
He should definitely learn jQuery, at least the basics of selecting elements and operating on them. If by any chance he gets into a JavaScript position interview and is asked what `$(".elem");`, he should know it right away. It's basic. Please, the real world is plagued with websites built with jQuery and that's something that ain't gonna be changing for some years to come.
That is insinuating he's going to be working at some web dev shop that has to maintain and make sites with jQuery. If you know `document.querySelector` or `document.getElementById` or `document.querySelectorAll` I seriously doubt anyone would turn him away because he didn't know the jquery syntax... My write up is for someone who doesn't want to join some regular run of the mill web dov shop making BS wordpress sites. It's fairly realistic, and literally jquery is not needed. I've never been asked a jquery question in any of my interviews in my career. 
I made this thing to help me make going to the gym a habit https://www.npmjs.com/package/gymstreak It puts an indicator in my bash prompt showing which days I've gone to the gym recently. Planet fitness only. 
Sure! You might already know most of this, but it doesn't hurt to write it out anyway: [Environment variables](https://en.wikipedia.org/wiki/Environment_variable) live on your system and are made available to every process running in that environment (typically your shell). Typically they're temporary (like using `NODE_ENV=production` before running a command) - they're not persisted beyond the current shell session. But you can make them "permanent" by adding their declarations to scripts that are run before your shell is launched (`.bashrc` or `.bash_profile` in your home folder if you're using Bash, etc). You can read the values of environment variables in any sort of program you're running on the system. If you're writing a shell script, it's as easy as just using `$VARIABLE_NAME`. For high-level programming languages like Python or JavaScript, there's usually a library or module that will read in the environment variables before your program starts and provide them to you as variables you can work with. With NodeJS for instance, environment variables are available on the `process.env` object (which is how you can do checks like `if process.env.NODE_ENV === 'production'`). There's no `process` available in the browser obviously, but various bundlers and build tools will allow you to inject it at build time so you can use the same syntax in your client-side code (here are the docs on Webpack's [EnvironmentPlugin](https://webpack.js.org/plugins/environment-plugin/), for example). With just the built-in NodeJS functionality, you can just use `process.env.API_KEY` or `process.env.OTHER_API_TOKEN` in your source code, and then when you want to run your code you have three options for providing the environment variables: 1) Declare them on the same command line. So something like `API_KEY=blahblahblah OTHER_API_TOKEN=anapitoken npm start`. Note the lack of quotes around the variable values - environment variables are strings by default, although most languages will parse things like numbers when reading them. Typing that out each time could get tedious quickly, so you could also: 2) Add them to whatever your system uses to prepare new shells. Like I mentioned earlier, if you're using Bash this would be the `.bashrc` or `.bash_profile` in your home folder. But not everyone is comfortable with playing around with system config files, and with this approach your project-specific environment variables would be global and could interfere with similarly named variables in other projects and processes. So there's the third, most popular option: 3) Put project-specific environment variable declarations in a gitignored `.env` file in your project directory. This would look like: API_KEY=blahblahblah OTHER_API_TOKEN=anapitoken You can then use a library like [dotenv](https://npmjs.com/package/dotenv) to read them into the environment so they get attached to the `process.env` object (it's really simple, just throw in a `require('dotenv').load()` near the top of your entry point file). "But wait," you cry, "isn't that what we were doing with the JSON file before?" Well, yes and no. Yes, we're putting our sensitive tokens in a file that we're not committing to our repository. But using a .env file is more in line with the [twelve-factor approach](https://12factor.net/config) to development. It makes it clearer that _configuration_ is separate from _code_. The cleaner separation as well as the platform-agnostic nature of environment variables makes things like continuous integration/deployment much easier. For instance, the apps I have hosted on Heroku are set up to pull and rebuild every time I commit to my master branch on Github. Since I use environment variables which I've already set on Heroku (and use a .env file for when I'm developing locally), this goes off without a hitch. On the other hand, if I was using a gitignored json file those automatic builds would fail because in my code I'd be importing a file that doesn't exist in the source it just pulled from Github. Same thing with testing with Travis or CircleCI. Because the code is self-contained, it's very easy to automate a lot of the devops because I'm just running the same thing in different environments. Also, configuration via environment variables can be used for so much more than just credentials. I can do things like check if my code is running on a test server (typically the `CI` environment variable would be set, or set one configuration to be used with a multi-language stack.
 A *sophisticated* compare function can be used to sort arrays or more generally define an order over an object type. It is generated by specifying the desired order with a minimalist configuration object. I got the idea for this utility function when I was faced with a couple of scenarios which required me to sort an array of objects by more than three properties (business logic), which translated in having to keep an internal priority list and the resulting code was simply not easy enough to maintain, so I thought I could come with a general solution. I would be delighted if you would check this out and also I'm more than happy to receive feedback. Thanks and have a good day!
No technical reasons. There isn't any benefit for doing so. Props are already a description of the entity. Adding the "I" seems redundant
Disclaimer : The version of React/Jest I'm working with is a little behind, so is not the current version. It's about a year? out of date. The whole "mock everything always unless you exclude it" I have found both helpful and not helpful. As far as I can determine, Jest cannot setup a test scenario where: when doSomething(1, 2) is called, return 20 when doSomething(5, 2) is called, return 10 Which pretty much every other mocking framework can do.
Read [Becoming a Better Programmer](http://shop.oreilly.com/product/0636920033929.do).
Working in a traditional web dev company using jQuery and WordPress is AS respectable as working in a cutting edge web startup with the latest nightly release of react. I hope he gets to settle in whichever he prefers. However, I stand by my opinion that knowing at least the basics of jQuery is a must for any so called JavaScript developer, as is knowing about bootstrap for any css _writer_ or Boost for any C++ programmer.
&gt; The whole "mock everything always unless you exclude it" I have found both helpful and not helpful. This is a config option and no longer the default. Not really a fair criticism when you could have changed the behavior with one line of config. &gt; As far as I can determine, Jest cannot setup a test scenario where: when doSomething(1, 2) is called, return 20 when doSomething(5, 2) is called, return 10 This is pretty trivial. Create a mock that returns a value based on some expected arguments.
fair enough, if they learn vanilla JS well then jquery will obviously be an easy add on for them to learn. 
After graduating I got a job and started attending meetups / user groups. Now I've worked at a handful of companies with many different people. The experience came with time and persistence.
ok yeah, but does it bend??
Backend is where the money is at too. A lot more fun as well. Compared to the troubles of frontend 
I only go to the gym once a week, to listen to "Complete Developer Podcast" when it comes out.
ACloudGurus AWS classes are 100% worth the price! 
I literally just published a video on [YouTube](https://youtu.be/yMUTKFsES6w) talking about my experience joining a SAAS based company as a Front End Javascript Web App Software Developer and all the things I had to learn. I imagine it answers a lot of your questions :-)
&gt;This is pretty trivial. Create a mock that returns a value based on some expected arguments. Agreed, this is trivial in most any mocking framework. But for some reason I could not find any documentation on how to do it. When searching for the answer, I encountered a SO thread the indicated that Jest simply did not have such a feature, which seemed really unusual for such a widely-used tool. Since I encounter jest in my daily work I would love to be corrected if you can point me at some examples.
You're not wrong!
Nice work! Bluetooth biometrics next?
At 2.5 years in your first job, are you sure you’re qualified to build such a course? I don’t mean this with any disrespect, but you’re still early in your career yourself.
Awesome, I’ll take a look at this later. 
And on GitHub!
Very well done !
[removed]
This right here. The author, Kyle Simpson, works through the language from the ground up, with lots of code examples along the way.
**If I were**
Zuck was running Facebook with $13m in the bank by 21. Dan Abramov was 23 when he created Redux and was pretty much unknown before then. Don't discriminate because of age. Is OP the best source of mentorship for clean code or best practices? Maybe not. But as someone who is 2.5 years into his career at a startup OP is actually in a much better position to advise and mentor a fresh grad than someone who has been in the industry for 10+ or even 5+ years. The hiring and entry-level landscape is changing rapidly and people who have *recently* experienced it are probably the best source of information. Shit I'm barely 4 years into my career and I'm a senior dev making $147k a year. My last three interns now have jobs at some of the biggest companies in the industry. OP I wish you hadn't deleted your post. Don't let the bullies of the dev world intimidate you into thinking you're underqualified. In fact I was about to respond to your post. I think there's a massive need for mentors for people in age range of highschool to early undergrad college students. There's a lot of people that could benefit from advice on career growth and what they can do outside of academics to prepare themselves for the real world. I sure as shit could have used it and knowing what I know now I wish there was a platform that could connect me with people looking for mentorship. I'd love to help people out and watch them grow and succeed. If somebody made a non-profit platform for connecting mentors and mentees I'd 100% volunteer.
I am thinking the same, and in some point I came to the 'beginners' label on GitHub issues https://github.com/facebook/react/labels/good%20first%20issue maybe you can look there
awesome, I actually found this at like a second before seeing your post but thanks a lot anyway lol. I found an issue that seems simple enough for a first PR that I don't think anyone else is working on, so I'm gonna take a stab at it. If you end up working on an issue also, I'd be open to helping each other out/collaborating if you want. We could each take an issue of our own but help each other out if we get stuck so we are both more likely to find a solution. I'm just trying to get familiar with the code now so I can figure out where to start looking
Jquery or cheerio (server-side) are pretty useful for scraping contents though
I put everything in one file. Exports are actions typically, and the default export is the reducer. All the contents are typically isolated to that file. It works pretty well - although they can get pretty long if you've got a lot of complicated thunk actions.
what do you do when you have to connect a server request to the state? dispatch(fetchUser('user_01')) fetchUserFromServer('user_01') .then(result =&gt; dispatch(fetchUser.success(result))) .then(error =&gt; dispatch(fetchUser.failure(error)))
Good answer. I'll just add our mutation tool in the library that the tread is about: [redux-toolbelt-immutable-helpers](https://www.npmjs.com/package/redux-toolbelt-immutable-helpers) Another answer is to [write tests](https://github.com/welldone-software/redux-toolbelt/blob/master/packages/redux-toolbelt-immutable-helpers/test/addItemsInIndex.js) like we wrote in this library where you [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#Description) your initial object.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [welldone-software/redux-toolbelt/.../**addItemsInIndex.js** (master → 153e8ce)](https://github.com/welldone-software/redux-toolbelt/blob/153e8ce1c342f27bff63b2a2a011c83a31787dfd/packages/redux-toolbelt-immutable-helpers/test/addItemsInIndex.js) ---- 
in typescript?
Is npm even a skill? 
Polymer sucks it's slow and clunky as hell and pretty much only works on Chrome. I mean the new Youtube was built with it and now all a sudden the site feels clunky and UI is broken on all browsers besides chrome. 
The first one gets the value of an anonymous function and the second one is a function.
I put my work up on GitHub as **[Prior Art](http://github.com/PriorArt)** for artificial intelligence. **[http://github.com/PriorArt/AGI/wiki/MindGrid](http://github.com/PriorArt/AGI/wiki/MindGrid)** The GitHub page explains how the JavaScript **[AI Mind](http://ai.neocities.org/index.html)** works. 
Two key differences: 1. The bottom one will be hoisted to the top, so it can be used before it's declared, whereas the first one must be declared before it's used. 2. The first one will let you call `.bind()` immediately after the closing brace in case you want to do some partial application or control what the `this` context is at the time the function is declared, rather than where it's called/used. The second one will throw a syntax error if you try that.
It **makes a lot of sense**, to make your website work offline and also be installable on the home screen on mobile devices. This is especially nice if you target mobile devices / have lots of mobile users. Android already works, iOS support is coming very soon :) I wrote a guide on how I made my CMS-based website work offline with very little work, [check it out](https://flaviocopes.com/offline-website-pwa/) if you want. 
what is the point of constants if you isolate them?
I don’t understand this. I’ve used Apollo for a year. It’s amazing. The docs aren’t complete, because it’s moving so fast with all the features they have been adding. Jump on the Apollo slack, they will respond and help. Look over the code on GitHub and see for yourself how things work? The real problem for me is that so many things are different to a new graphql developer that you want someone to explain how to do just about everything with it. After you get used to it, you realize how to accomplish authorization, authentication, and everything else. It takes time to have complete docs when a technology is only a few years old. 
But subscriptions, those are hardly explained and I wonder if it can scale. 
That muska board brought back memories 
action creators creates actions. the first parameter will be the payload of the action created. dispatch(actionCreator('aa')) will result in the following action: dispatch({ type: 'SOME_TYPE', payload: 'aa' })
Interesting tool and idea. 
Some frontend guy downvoted. Sorry, but frontend is just boring, very boring. 
you decide what is the payload upon dispatch. when you import it, you don't really know yet what the payload is. when you write your reducer, the action type will be "fetchUser.TYPE". what are you trying to do? write it in a sandbox or something.
I understand what you're saying but I disagree. Docs generally are going to expose an API and an intent. The behind the scenes is in the code and it changes often. If every time a dev changes a line of implementation code they also change the docs then the docs are likely too verbose and are redundant. I think we're all curious how Apollo and other frameworks are working, but the answers to some questions simply exist in the source code (which is open source). So in a way, if you have questions about the internals then you can find a line, method or module and then go on the slack and ask about what that line is doing. I know it can seem like a lot of work, but sometimes learning is work so IMO it is worth it. I think it might be different if people were paying for this software but since it is free and open source there likely are limited resources updating docs. Helping to update the docs is actually a good idea of a way to get involved with open source so as you learn about what is going on then make sure to put in a PR against the docs. Most of them have an edit button.
If I want to dispatch an action from a React component, I need to import the action creator. import fetchUser from 'actions' Now I want to call fetchUser: dispatch(fetchUser()); Normally an IDE will tell the developer what parameters are required. However fetchUser() only has one paramter; payload. What if I want to pass 2 paramters? I assume I pass an object: dispatch(fetchUser({ someKey: 'user_02', someOtherKey: 'someValue' })); How is the developer to know what keys are required on the object? Do they need to go and look at the reducer to figure out what the payload should be?
Bosola explained my thoughts quite well, but an ad-hominem is a perfectly appropriate response to an argument from authority. 
Documentation is that area that no one likes doing and always seems to have issues. I hate it when the examples are super simple contrived examples that make it impossible to extrapolate workable solutions because they elide all the important bits. My approach is usually to define key requirements for a POC (Proof Of Concept). A recent one I did for a messaging framework included things like: Establish a connection, handle reconnection, establish max throughput. Stuff like that. Then I build a POC that covers those cases, usually as integration tests rather than a full application. It allows you to focus on specific problems and figure out if the framework can cope with them. It's not perfect, but documentation is often crap. See if they have a test suite somewhere in the code. That probably indicates some degree of diligence plus it will show you how to do certain things too.
But there are more than two genders.
What do you mean by printThis? Can you make a demo page linked on the repo? it would be really helpful
Just for illustration, here is an example of the autocomplete provided by Codesandbox when accessing both a toolbelt action and a vanilla action creator: https://imgur.com/a/0W5E9 
Yes and no. I like developing in Laravel, and it has a very powerful ORM and IoC / services container, and while the documentation does a great job of showing you what you can do with it, I didn't feel comfortable using it until I had gone through the process of trying to build its features on my own to get a better sense of what it has to do under the hood. Now it's not magic to me anymore. I totally get the discomfort with using something that's magic without really knowing the underlying implementation, but that needs to be conscious decision with acceptance of the tradeoffs and risks. 
No code? What do you mean?
I never touched Meteor myselff...but imo, I just use frameworks when I know that they will cover the specific job they are built for. I discard them whenever I need to do something extra.
Hi Flavio, thank you for the link! I'll read it, can you explain why it makes sense or if there are downsides?
Yes, it's the 'var' part that relates to the hoisting behaviour.
So if you used let/const, would it still be hoisted? 
&gt; I think it's kind of redundant to write tests *snip* when you know the majority of your code is generally side effect free. Because of "majority" and "generally", I'm glad we have something like tests. 
No it wouldn't, only var is hoisted
You can develop Javascript on Windows just fine with no issue. You don't need to dual-boot linux just to dev in JS!
1. we usually use it with very short arguments and don't need it: dispatch(fetchUser(user)); 2. we are going to address it. its a good point. thank you! 3. also we will add typescript and flow support to the library soon.
Ohh, I see. Thank you very much for your help! None of this has been taught in our class (but that's mostly because the professor just tells us to Google everything.) I get it now. Thank you again!
The Meteor forums are a good place to get assistance in troubleshooting.
Great project, I've had this idea to generate LaTeX from JSONresume sometimes before but never put it into practice. Nice job. The design is simple and practical. What would be something really cool is a way to export from LinkedIn or something to JsonResume to be used here. Keep up the good work
Yesterday I just recommended this resources to a colleague who is about to join us: - Clean code (JS): https://github.com/ryanmcdermott/clean-code-javascript - The holy bible of JS (Front-end in general) (Used by developers to consult things) https://developer.mozilla.org/en-US/docs/Web/API - Babel - ES6 (For ES6 reference mostly) https://babeljs.io/learn-es2015/ - This is already slightly old, but still, I think it's a nice "guide" that explains the awkwardness of JS. http://bonsaiden.github.io/JavaScript-Garden - Amazing guidelines to create a project https://github.com/wearehive/project-guidelines - Awesome lists of Github. There are really useful and 😎 - I like this. I used to practice when I had a bit more of spare time: https://www.codewars.com/ Among the you don't know JS and practicing with few projects on your own, you can achieve a good level "quickly" :)
I am pretty sure your demonstration fails in flow as well. We're using flow 0.63.0 on our project and I know we've got similar errors reported multiple times.
Whenever you deal with objects, you can use `this` keyword. `this` in most cases is the object that goes before the dot. Ex: x.toString() - `this` inside method `toString` refers to `x`.
What is your purpose?
Good bot.
Only the declaration is hoisted not the initialization, so these pieces of code are not equivalent: console.log(foo()) // Prints 10 // Both foo's declaration and definition are hoisted function foo() { return 10 } // ------------------------------- console.log(foo()) // TypeError undefined is not a function // var declaration is hoisted but definition // happens after the console.log hence the error var foo = function foo() { return 20 } //----------------------- console.log(foo()) // ReferenceError foo is not defined // let/const declarations are not hoisted so // usage before declaration is simply like // accessing a non-existent variable const foo = function foo() { return 10 }
&gt; very powerful ORM and IoC / services container Not to nitpick, but Eloquent is a very simple active-record style ORM. Powerful it isn't - no unit of work, no data mapping, if you need those features. And service locator is the proper term to describe Laravel's DI container, despite Taylor's deleting his Reddit account in a huff when he was called out on his misuse of terminology.
me too, I don't think i'd ever feel comfortable ever deploying anything without thorough tests. But I guess the process of TDD I think is only helpful for Ruby devs. 
Yeah I ended up writing my own subscriptions by simply subscribing to potential relational events like: ```javascript `${user.id}_likes`, `${user.id}_comments`, `${user.id}_views` . . . etc ``` That way when any change or creation happens the new data will be pushed to the client(if they're connected of course). But with Apollo I just couldn't figure out whether that was possible or how it handles subscriptions because it seemed to me that it could possible do some kind of search on each event which would be inefficient. Anyways, I like control 
Well, ever used OOP?
immutable.js is working well for us 
Yeah subscriptions documentation was poor. I had read several blogs and look at numerous prototypes to understand it properly and implement it with redis
Is there anyway to test this without having to depend on whatever is coming from localhost:5000?
https://github.com/search?l=JavaScript&amp;q=this&amp;type=Code&amp;utf8=✓
thank you for pointing that out, really appreciate 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jackxbritton/motion/.../**9b4e17aad509db4d0eb4cdd27db40415f60def35** (cors → 9b4e17a)](https://github.com/jackxbritton/motion/tree/9b4e17aad509db4d0eb4cdd27db40415f60def35) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtpv6sz.)