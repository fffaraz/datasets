&gt;When learning this you should also make sure to understand they users can redefine "undefined". Which is very interesting Not true anymore &gt; In modern browsers (JavaScript 1.8.5 / Firefox 4+),undefined is a non-configurable, non-writable property per the ECMAScript 5 specification. Also, what makes you think he wouldn't know about IIFE when he already develops large scale Javascript frameworks? 
JQueryUI widget factory is very nice. You can dig through the way they implement Slider and Accordion to see what's the best pattern. 
I suppose it should throw an error instead. I understand your argument and my only hope is that our OP takes note of it.
Please don't immediately downvote me for this question (explanation at bottom) as I want genuine answers. - If you're a a minority or a female and learned with this book, did you feel it was accessible? Why I'd ask this: I mentor people from my hometown. Like me, they fit a particular demographic. I know firsthand that accessibility is a huge factor in whether or not our demographic pursues a cool project. From a glance, this book seems to open up a way to teach my "lil' homies" some effective, accessible engineering fun with a cheap development machine (I want to buy them Chromebooks and standardize a curriculum with a free online editor). - **If this has been effective for you as a woman or minority, please confirm and explain why. Thanks!**
&gt; This also does not take into account any development that has to be done on the back-end, including data structures and schemas, DAL-work, API design, and just general software design and planning in general. &gt; That's a pretty good example of non-agile software development. The idea that you need to lock in data structures, APIs etc. is nice example of waterfall software development. No, that is not an example of non-agile software development. You would do well to [read up on it](https://www.google.com/search?q=waterfall+vs+agile&amp;oq=waterfall+vs+agile) if you are going to criticize people. Agile is not a paperless methodology. Defining data structures and interfaces is not Waterfall. Waterfall describes an approach to project management and development whereby the system's design is fleshed out fully in advance, through the development of requirement and functional specifications before being presented for development. It utilizes very clearly partitioned steps whereby the results of one phase become the basis for the next (e.g. design --&gt; development --&gt; testing). In contrast, the basic tenant of Agile is to create the system in small iterations, using short cycles of design, develop, review and revise with testing done throughout. It is not done without planning, design or documentation. [Waterfall model](http://en.wikipedia.org/wiki/Waterfall_model) [Agile model](http://en.wikipedia.org/wiki/Agile_software_development) 
&gt;You would do well to read up on it if you are going to criticize people. That's condescending and non-constructive. I haven't criticized people, I have criticized ideas. &gt;Agile is not a paperless methodology. I have no idea what that means. &gt;Defining data structures and interfaces is not Waterfall. And I never claimed that you shouldn't define data structures or interfaces. &gt; It is not done without planning, design or documentation. Duh. Obviously planning, design and documentation is beneficial, and I've never argued otherwise. I've argued against (for example) a waterfall process of first planning, then designing, then implementing and then documenting. Agile means that you don't have a waterfall process for that, it means that you can do everything "at once" and not as discreet steps. Your whole argument is based on a strawman attack on my position. You continously claim that I think design (or even documentation! wtf?) is unnecessary. From my very first comment onwards I've stated that design is something one should do. In *no comment* have I stated that I'm against code design. But you repeatedly claim that I am. That's not constructive.
Or just a trivial problem with a straight-forward solution when using the basic language features.
_
Nice, good solution.
Well said, I actually was going to mention this but was already getting long-winded :) Keep in mind that using browserify necessarily requires a "build step" which is another layer of complexity, but one which pays great dividends in terms of powerful stuff you can do automatically. Generally the most commonly used frontend build tool used these days is Grunt, and your grunt build step can watch your code for changes, re-run browserify, lint your code, minify it, minify all your assets, copy files to the build directory, or pretty much anything else you can think of. Virtually all of my frontend projects now use grunt and browserify. It makes things so easy once you figure it out. Now I can clone any of my repos, type "npm install" to install dependencies, then "grunt serve" (or similar) to build the thing, serve it locally, and watch for changes. And generally "grunt build" to build a production version of it with minified code/assets.
 /* I use something like this. Same thing for setting to vivify undefined arrays and objects. */ var obj = { a: { b: { c: [ { d: "efg" } ] } } }; function tokeys (k) { return Array.isArray(k) ? k : typeof k === "string" ? k.split(/:|\./) : []; } function get (obj, keys) { var keys = tokeys(keys), key; do { obj = obj &amp;&amp; obj[(key = keys.shift())]; } while (keys.length &amp;&amp; obj); return keys.length ? void 0 : obj; } function set (obj, keys, value) { var keys = tokeys(keys), key; do { key = keys.shift(); if (obj[key] === void 0) { obj[key] = +keys[0] === +keys[0] ? [] : {}; } obj = obj[key]; } while (keys.length !== 1 &amp;&amp; obj); obj[keys.shift()] = value; } console.log("the result is", get(obj, "a.b.c.0.d")); console.log("the result is", get(obj, ["a", "b", "c", 0, "d"])); set(obj, "foo.bar.0.baz", true); console.log("after set", get(obj, "foo.bar.0.baz")); console.log(JSON.stringify(obj, null, "\t")); 
There is no right answer except "it depends". I have used both, but prefer the JSON method now. I am sure there is a performance impact somewhere in there, most likely rebuilding the DOM when you inject the snippet. If you are delivering &lt;script/&gt; blocks too and the HTML snippet is self contained then why not just deliver the whole block. If the rest of the page depends on that content, deliver it as JSON.
Don't be too hard on yourself, we *all* through that at times. Might want to look up "Rubber Duck Debugging" ;) On a more useful note, JSHint (or JSLint) is really great at catching that kind of stuff.
&gt; I want to pull either a[b][c][d][e] or nothing at all Stick it in a try/catch. That has to be simpler and faster than all these recursive strategies.
'core-select' fires twice for me. Once with event.detail.isSelected = false, and once with event.detail.isSelected = true. 'core-activate' seems to be the right one for tabs.
Interesting. Even their samples in the documentation fire core-select twice. 
Well, if you click, whatever is selected gets deselected and whatever was clicked gets selected. You get two separate events for that because that's how the underlying core-selector operates. And it makes a lot of sense... in those [other use cases](http://www.polymer-project.org/components/core-selector/demo.html), that is.
It seems like core-select is the way to go then. It's firing twice specifically for the paper-tabs usage style and core-activate might be less useful, which is probably why they say to use core-select.
Ah, yea... you can get the relevant element via event.detail.item. So, isSelected = false -&gt; hide the tab body which is associated with that item. And isSelected = true -&gt; show the tab body which is associated with that item. That would work. Still not really sure if that's the intended route though. **Edit:** Well, if you use core-pages for the tab bodies, you only have to tell it which "page" to show. There is probably also a way to wire them up in a declarative manner. **Edit2:** Yep, declarative works: http://www.reddit.com/r/javascript/comments/29rum1/javascript_based_tabs_no_jquery/cio3tiu
Finally figured it out. You can just wire core-pages to the "selected" value of your paper-tabs: &lt;paper-tabs selected="0" selectedindex="0" id="paper_tabs"&gt; &lt;paper-tab id="paper_tab" active&gt;ITEM ONE&lt;/paper-tab&gt; &lt;paper-tab id="paper_tab1"&gt;ITEM TWO&lt;/paper-tab&gt; &lt;/paper-tabs&gt; &lt;core-pages selected="{{ $.paper_tabs.selected }}" selectedindex="0" notap id="core_pages"&gt; &lt;section id="section" active&gt;Page One&lt;/section&gt; &lt;section id="section1"&gt;Page Two&lt;/section&gt; &lt;/core-pages&gt;
&gt; The problem is I’m extremely and embarrassingly incompetent at regex */me closes tab*
Does anyone have any idea on where you could get this book as a PDF for free online? 
I've read all of these "solutions" as well as those on SO. IMHO this highlights some of the really ugly aspects of javascript. Sorry, but all of these solutions are simply ugly and overly obfuscate what is going on. Your language *should* be taking care of this stuff for you. Christ this isn't c. Perl called it auto-vivification and it was quite pleasant. 
He's obviously referring to polling for updates, or whatever the object.observe polyfill actually does, as opposed to the browser handling it. But yeah... There should be a section for "hello, i just learned something here is a js lib that will do this one trivial thing for you"... 
Granted, I'm familiar with Meteor, so maybe it's just obvious to me now, but I think it's pretty clear to remove these packages for any project that should have sensitive data in the DB. IIRC the docs are pretty clear and adamant that they should be removed. Still, I can see a benefit to not including them by default. To defend the choice to leave them as defaults, I honestly use those packages in a fair number of projects; especially when I first start a project. If there's no DB, or if the permissions are super lax because it fits the purpose, why take them out? Or maybe I'm just proving a concept and realize I will have to build a way to limit access, but for now just want to show where you make X and where you view the X you make and where you edit the X. To me, the ethos of Meteor is to get a working app quick knowing full well that ideas are cheap and easy, and functional prototypes should be just as cheap and easy so you can test those ideas. If it's something worth pursuing then removing insecure and autopublish are probably first on the agenda so you can start building business logic *after* you've validated the concept.
this is a perfect comment in addition to this article As you said, insecure and autopublish are there to get you up to speed quickly. You can always create your own template manually if you feel like that's not your style though :)
I think it's in ES6
I can see where you're coming from, but I don't know if I'd agree. PHP is designed to output HTML. I don't think it's an exaggeration to say that 99% of the PHP scripts in the world output HTML. To me, for AJAX calls, it depends on the usage. Quite often, I just put an include into the PHP file that generates the whole page, where it includes the PHP script that outputs the part of the page that will change. And then the AJAX call would call that "sub" PHP script with new parameters as necessary. So I guess my point is saying that "there is only one correct way to do it" isn't quite right. It depends on the specific case.
AWK WAAAAAARD
TIL jQuery is useful
one way I like to do it is to have a "template" div in the original markup, something like: &lt;div class="hidden-template&gt; &lt;article&gt; &lt;h1 class="title"&gt;&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; Then in jQuery (after getting the json obj) I do something like var $article = $($('.hidden-template').html()); $article.find('.title').html(myobj.title); I like it bc it frees me from typing HTML strings on JS, the only drawback is that now you have this empty divs in you document, if you can live with that this may be a solution.
I hosted a copy of the slides [here](http://pointersgonewild.files.wordpress.com/2011/08/maximechevalier.pdf), in case anyone wants them.
There is no VM inside a VM, and no direct link with minifying, I'm not sure where you got that. Higgs is a standalone VM/JIT that generates x86 machine code. I'm not sure what you're talking about wrt null and undefined and "default values"?
You're right that there is more than one way to do it. The way you describe it is pretty similar to how my Wordpress sites come together, in the fact that the PHP generates the whole page with the theme files. However, in 2014, SPAs are so much cooler than typical websites, and the user experience is monumental when you can slim down all server-side queries to just the raw data, then let a front-end framework run the show from the user's device. Shifting the processing work from the server to the user as much as possible is what makes HTML5 SPAs competitive to native apps when you require an interface that fetches XML or JSON. I like this approach because you can say "here's the model/security of the app (back-end), here's the view and controllers (front end)" and its easy to differentiate. The line between design/development becomes clearer and this approach has improved my workflow and tightened up my skills as a web programmer that still has to think like a designer.
It has been known for quite some time that economic pressures themselves do not drive an individuals desire for knowledge (as opposed to public education). It is also well known that institutions themselves have driven out women and minorities from pursuing technological backgrounds. So, I am not entirely sure why you are asking if it has been effective for women or minorities as it implies women and minorities have to be written a certain kind of book (i.e. more beautiful). If you are teaching mainly women and minorities and they don't have an interest, then they won't learn. But your question isn't the right question and you run the risk of, well, you know what I mean. But you should be able to form a good review of the book yourself if you have a technical background. Everybody knows visual representations are pretty much the best way to learn programming anyway.
I'm not frustrated at all by this because the code itself is still extremely slim for the amount of work being done and the digging/querying is a core function to the app. I'm calling that 4-5 line function about 20-30 times instead of having 20-30 really bloated if statements.
I guess, and that's something I consider whenever I do an AJAX call. Like for example, say I want to change a row of table. I can have a PHP script output just the data and the &lt;td&gt;'s (so HTML code), or I can have it returned as a JSON with separate variables for each column and have javascript go through the row and replace each table one by one. Typically I'd go for the first one (though, considering things like attributes for the &lt;td&gt;'s, possible javascript listeners on the &lt;td&gt;'s etc should also be taken into consideration).
With this approach, the HTML now lives in two separate places, and that is considered sloppy. If you use raw data, you separate the model from the view completely and your flexibility on what you can do with that model is no longer bound to just &lt;td&gt; tags. The goal here is to cut loading time to near-zero. The less processing the server has to do, the less loading and page refreshing the server does, moving all of the work to the user's browser. And that is essentially why web apps can compete with native apps, because devices that run JS are becoming faster and can handle more on the front-end than a busy server can handle from the back-end. When you download an app on your phone, your experience is awesome because all of the files are local and loaded up and ready to view at the drop of a hat. The only waiting you do is when you make CRUD requests to a server. So to keep your user happy, you keep the requests as light as possible.
Looks like a simplified version of Blaze: http://meteor.github.io/blaze/
You could just use a try/catch statement...
does the function *need* to be optimized, or is it fine as is? Prolly depends on if it's game code that's being executed a bunch of times every tic or something that happens every few seconds/on specific user actions. That said, I always prefer a recursive method, if it's not gonna slow things down too much.
This guy's name is splattered all over my Node books. Interesting that such a major player has so many bad things to say about Node. I know he likes Go, but how does Go compare to Node for building web apps and web apps only? Just curious.
I just purchased the book from a local Barnes &amp; Nobles. With my membership discount it came out to ~$37. SRP (suggested retail price) printed on the back of the book is $39.99. I have also been trying to learn JavaScript via Treehouse, but I find myself confused. I personally feel that Treehouse gleans over the details and the *mindset* of learning and adjusting to a script language. Nevertheless, I am 100% satisfied with my purchase, and plan to complete this behemoth of a book (+600 pages). TL;DR: Marketing guy getting into front-end development. This is a great book.
We have also build a tool that feels quite similar to Prezi, however the focus is more on creating home pages. In contrast to Prezi we do not use canvas but HTML, which allows search engines to index our pages (SEO) and to embed almost any web widgets (YouTube, maps, contact forms, ... Prezi ;-) You can see a presentation like home page under http://story.webpgr.com/ and in the slide http://story.webpgr.com/market you can also try out a demo of our editor.
Why not Erlang? 
Why not any language. GO fits the problems he is having other people might do sorethig different.
This is considered good style because it's explicit. You will always need to flow data the other direction -- the real value is minimizing it and making it explicit and reasonable.
&gt; Interesting that such a major player has so many bad things to say about Node Yes, this is certainly unexpected. This guy has 181 GitHub repos with JavaScript as the main language, 129 of which owned by him. I wonder what drives developers to stick with a technology they actually dislike. But then, it took me several years before completely ditching PHP because of my job... Source for GitHub numbers: http://coderstats.net/github/visionmedia/
&gt; Go is amazing for building web apps or any kind of networked service. They built it for that purpose - to make writing Google type software easier. *Google type software* is enormous in scale with server farms spread around the world. Go's purpose is to tackle the problem of concurrency and replace C(++)[[source]](http://golang.org/doc/faq#creating_a_new_language) for networked services on a corporate scale. &gt; It's definitely easier to reason about Go's channels than Node's async callbacks. I totally agree with this. I think Go's channels are inspired by [Tony Hoare's CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes) which has also been implemented in clojure(script) via [core.async](https://swannodette.github.io/2013/11/07/clojurescript-101/). I'm optimist that node will evolve to incorporate this pattern in vanilla js, even if 3rd party npm modules are necessary. &gt;Node is nice if you want to share code with the client but otherwise I would use go. Currently, node's greatest strength is not as a server, but as a build system for client-side web apps. I'm not aware of anything comparable to gulp or grunt in terms of performance or modularity. Node is single threaded, so the overhead of scaling node is complex and requires novel patterns of programming. Node will always be unpredictable and error prone, just like people are. It currently has the largest and fastest growing open-source ecosystem in the programming world. 
Whilst this approach may certainly be simpler, I would be nervous that it gave other developers the opportunity to use domain objects inappropriately. For instance, one project I worked on had a serious problem with people writing business logic in the presentational layer (basically, using excessive expression logic in JSPs to the point where only a small ratio of lines were actually involved in rendering the view). Possibly most applications of JavaScript are too 'small' fpor this to be an issue, but it's something I would consider in a large web application. As ever, it's all a matter of discretion.
I don't even know what to do with it - upvote or downvote :) So far, Node worked great for me, both for Web and standalone modules. We all read articles like this in the past about Java, PHP, Ruby. Everyone thought that they will die, but luckily they are still alive after some improvements here and there. So, I think that this type of articles are a good sign that the language is moving forward, following the traditional pattern. Of course, it took me a while to get used and understand how to handle the errors in Node, especially the ones that the third party libraries generate. But, luckily, you can receive a quick answer from the community when you're in doubt. Adding CoffeeScript and async (https://github.com/caolan/async) to your app, makes code readability much better and the callbacks, scopes less annoying. Also, now that everyone knows the weak points of Node, I think it's time to take some patience and improve on them rather than ditching the language. Anyway, one thing TJ is right about is that it's not healthy to be focused only on one programming language and get stuck in one way of doing things. I owe this guy all my respect and most of my money that I've earned from Node and Express and I'm really sorry that he has to GO (see what I did there?). Farewell TJ!
i like your feedback (: scrolling is sometimes not as smooth as it should. working on some webkit optimizations. there is a ios safari bug which causes the crash. we will prevent this by limiting zoom. and you're right: its not so useful for just text.
I found that there's an experimental module called [node-csp](https://github.com/olahol/node-csp) which is inspired by Go's channels.
Component.io is a bit in shambles though. They are trying to move to a new API but the transition is really sloppy. Documentation is outdated in a lot of places or is just missing. Also at the project level it seems they are suggesting to use a custom builder based on a middleware abstraction which means we now have grunt, gulp, broccoli, component.io builder and many others which all need their own plugins. There seems to be some fragmentation as well with component.io itselfl. If I remember correctly the new maintainer works for segment.io but a while back in the component irc channel somebody else (who also works for segment.io I think) linked this: https://www.npmjs.org/package/duo which is suppose to be the next version of component but I don't think it's build on top of the new builder2.js API. To add to the confusion the new maintainer also has a different [project](https://normalize.github.io/) which tries to solve the same problem (in a very different way). 
&gt; does the function need to be optimized, or is it fine as is? Depends on what else it is doing. You see, /u/carbonetc didn't suggest to write a function which uses try/catch. They suggested to just wrap it with try/catch. Naturally, one has to assume that the function does some other things besides just transversing through some object. There could be some loops which would benefit from optimizations, which means that preventing optimizations could have a significant negative impact. A try/catch in a function which doesn't do any heavy lifting doesn't really hurt much, however.
&gt; However, in 2013, he had a sudden change of heart and now sometimes prefers to declare them like this: OMG he changed how he writes his code, he must not be real! Why is this garbage getting upvoted? 
&gt; Handling concurrency isn't just a node issue Friend of mine likes to say this (which he heard elsewhere): *There are two problems in computer science: caching and concurrency.* 
"Just write a distributed map/reduce in Erlang!" "Did you just tell me to go fuck myself?" "Yes, yes I did." 
:)
That's probably the weakest argument of them all, but its certainly interesting that he's never been seen publicly, and supposedly held a full time job while pumping out about 3/4ths of the node ecosystem, single handedly (including documentation), contributing to books, and tweeting like a madman. Its almost positively a pseudonym... like the bitcoin guy.
I think it's more likely a combination of trust fund, language nerd and polyphasic sleeper. If he is an amalgamation of people it begs the question: **why?** No one stands to make any money here -- unless you count books. If you think people are getting wealthy off writing programming books... 
There have been plenty of examples of collective names used throughout history... the most recent one being (probably) the founder of Bitcoin, [Satoshi Nakamoto](http://en.wikipedia.org/wiki/Satoshi_Nakamoto). There doesn't necessarily have to be a reason why.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Satoshi Nakamoto**](https://en.wikipedia.org/wiki/Satoshi%20Nakamoto): [](#sfw) --- &gt; &gt;__Satoshi Nakamoto__ (中本 哲史 *Nakamoto Satoshi* ?) is a person or group of people who created the [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) protocol and reference software, Bitcoin Core. In 2008, Nakamoto published a paper on The Cryptography Mailing list at metzdowd.com describing the Bitcoin digital currency. In 2009, he released the first Bitcoin software that launched the network and the first units of the Bitcoin [currency](https://en.wikipedia.org/wiki/Currency), called *bitcoins*. &gt;Nakamoto is said to have continued to contribute to his Bitcoin software release with other developers until contact with his team and the community gradually began to fade in mid-2010. Near this time, he handed over control of the source code repository and alert key functions of the software to [Gavin Andresen](https://en.wikipedia.org/wiki/Gavin_Andresen). Also around this same time, he handed over control of the Bitcoin.org domain and several other domains to various prominent members of the Bitcoin community. &gt;Nakamoto is believed to be in possession of roughly one million bitcoins. At one point in December 2013, this was the equivalent of [US$](https://en.wikipedia.org/wiki/United_States_dollar)1.1 billion. Nakamoto's true identity remains unknown, and has been the subject of much speculation. It is not known whether the name "Satoshi Nakamoto" is real or a [pseudonym](https://en.wikipedia.org/wiki/Pseudonym), or whether the name represents one person or a group of people. &gt; --- ^Interesting: [^Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) ^| [^History ^of ^Bitcoin](https://en.wikipedia.org/wiki/History_of_Bitcoin) ^| [^Gavin ^Andresen](https://en.wikipedia.org/wiki/Gavin_Andresen) ^| [^Nick ^Szabo](https://en.wikipedia.org/wiki/Nick_Szabo) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cioh2pa) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cioh2pa)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
He's needed contributors for a long time. Maybe solving every problem alone starts to highlight the bad parts of the platform you're working with? Or at least exacerbate what's bad about the work.
I'm a web developer and I absolutely hate js. But I'm a web developer. After many years in the business and a life outside the job one doesn't just change direction. I'm trying but it's going sloooow. 
Maybe another way to describe what you are looking for is: An abstraction to represent GUI components. I think jQuery widgets have their place, but they become less convenient to use because they are initialised by enhancing existing markup. I have worked on my own GUI abstractions, called Controls, and have made them conceptually similar to ASP.NET web controls. They are also quite a lot like Backbone Views (but designed to work on the server-side too). I would recommend you see what you can do with Backbone Views. I have used them successfully to represent widgets and subwidgets.
Except koa. Which is super cool.
Man, you're thick. I was just giving an example of a recent use of a collective name.
And it has little to no bearing on the "question" of Holowaychuk's idenity. 
I'm assuming you realize what a black and white observation of developers that was...
Uhhh "never been seen publicly" ??? I've definitely had drinks with him in San Francisco and a good buddie of mine worked with TJ at Sencha. Sadly TJ was gone when I arrived at Sencha.
Look man, we need video proof. If you could get video proof of him holding up today's paper and talking about the US loss in the World Cup then we _might_ believe he's real. 
Exactly. Also, when ECMAScript is updated it isn't implemented right away. Most changes in JS programming have been through creating libraries and new patterns with regular old Javascript, not by updating the core.
I think that's missing "naming things". And "caching" should maybe be "cache invalidation".
Nice, thanks bendman.
In theory it's open source, but I have not published a new version ages because want to make a few API changes, plus I want to use a more complete version of my framework to host demo and discussion pages. The controls themselves rely on other parts of the framework (the lang-essentials and data structures). Yes, I will send you some code but don't want to clutter up the comments section with it here. If anyone wants to help get this unfinished but powerful framework into a more complete state, and released as open-source, please let me know. I'm also thinking I could use Kickstarter to get it funded and would appreciate help with that side of things too (both making the Kickstarter proposition and funding it).
Nitpick: distributed systems and concurrent systems aren't the same thing. All distributed systems are concurrent, but not all concurrent systems are distributed. Clojure and (from what I've seen) Go are solving the concurrency problem, not necessarily the distributed systems problem. Rich Hickey has said several times in his talk that communicating across a network is a bigger problem that requires more consideration than what core.async can do right now. 
Why? Maybe because the organization/hivemind/codebot that might be TJ doesn't want to be known to be a/the major driving force behind Node.
I got one word that explains it all: ALIENS. 
"You see that guy over there?" "What, the really quiet one with the magic hair?" "Yeah, that's TJ." "whaaaat"
I know substack's case is similar. Except instead of already having money he just doesn't really WANT money. :)
Also I'd add the entirety of es6 is likely not going to be implemented across all browsers for years most likely. Some things are already available in some browsers but I think things like class, extends and yield are still a fair ways off. Also, you can already accomplish these things with existing patterns in Javascript so there is certainly no reason to wait. However, if you would like to play around with them it is possible to use transpilers now to get es6 features on the client and node already has the ability to be used in es6 mode as well. 
Yeah I was thinking about that while writing the comment. We can use async abstractions for maintaining our code base internally, but if we're dealing with distributed systems across a network, and not multi-threaded internal processes, we need to consider the middle way. Even though you can generate a server in c++ or java or go or clojure, it's not quite as simple as working with a node server. I own a few raspi's and like to experiment with miniature distributed networks. When you're dealing with single-core embeddable devices, or browsers inside of phones, you can't leverage languages optimized for multi-core devices. I feel like node is stuck between two worlds, and that's a good place to be.
Good to know.. Thanks html6dev
It's not recommended to put it at the top of the file because that can cause conflicts with concatenation. It's best to put it at the top of a function, either an IIFE that wraps the code, or individual functions within the code. I think JSHint tells you this by default. Mind you, if this is for commonjs modules (such as in node or browserify), top of the file would be fine, since those are wrapped in a function before being evaluated.
Makes sense. I added it to the top of my JS file and everything is still working on my site properly. Is this an OK practice if it does not cause any conflicts? Does it have any impact whatsoever on performance?
None that I'm aware of. I've been trying to find the post I read before that went over why it was bad to put it at the top, so I could link it, but google isn't being kind to me.
Node is so yesterday. It's Go time! ;-)
Doesnt help your js, but Coffescript's existential operator is useful for this. It soaks up undefined/null values: f = a?.b?.c?.d?.e?.f 
If it was going to have an effect on performance, it would improve performance. [Many of the things it changes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode) are things that cause JS engines to have to de-optimize code, like the magic aliasing of `arguments` or the ability of `eval` to manipulate the symbol table of the enclosing scope. You're probably not using any of those, so there will likely be no effect, but the point is that strict mode was designed to even out all the rough edges of the language, including those that make it difficult to optimize. For example, most JS engines give up when they see the `with` statement and refuse to optimize a function using it. Strict mode removes `with` from the language, so that becomes one less issue to worry about. 
I thought Dart was what Google is pushing to replace Javascript. Geesh Google, this is just like Chromebook vs Android. I mean pick one thing you want to succeed and push that. Wonder how much they paid this guy.
That depends, are you as prolific of a contributor to the JS community as Dustin Dias and TJ Holowaychuk are?
That was sarcasm. I definitely enjoyed reading the TJ article, but this one is pretty pointless. It feels very defensive about TJ leaving the Node/JS community.
"If you ask him if he's TJ he'll say no. Classic TJ!"
&gt; Node’s direction, which favours performance over usability and robustness. "Node's" performance isn't even a Node or JavaScript feature. It's the result of [libuv](http://nikhilm.github.io/uvbook/introduction.html) and the technologies it builds on (epoll, IOCP). These technologies are available in other run times and thus other languages. C# comes to mind. Why developers choose JavaScript and v8 baffles me.
If you wait for ECMAScript 6 to be implemented in browsers you're probably going to be waiting a decade. We're still not up to date on the ECMAScript 5 spec yet in terms of support.
UnityScript is not JavaScript, I'm afraid. Unity advertises it as being JavaScript, but the only thing they share is syntax. You might have better luck in /r/unity3d.
"callbacks suck" is a pretty bold statement - it's a very different approach to programming that makes sense for certain applications, and is a pain in the butt for others. I look at them as one of the main deciding points when evaluating node for a project. If I'm pulling many different data from different sources and sending it all back via a websocket, callbacks are actually pretty nice. They're not the only way to do it, but it's a very natural approach for this sort of thing.
Kampground of America?
I think you might be confused about...everything. 
I think even lacking the use of chaining and functional callbacks, using Underscore is a good idea because of the graceful degradation it hides away in its implementations. As a for instance, here's the implementation of `_.contains` _.contains = _.include = function(obj, target) { if (obj == null) return false; if (nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1; return any(obj, function(value) { return value === target; }); }; The subsequent `any` and `each` calls hidden behind can be left out, but what this means is essentially any Object that defines length and has sequential integer keys starting with 0 is a valid array, whether it has the Array prototype of not.
TIL TJH is from Victoria. Guess he works remotely?
I try not to have solid retorts cause they mess my pants.
It's reddit's lot in life.
Thanks. I've been bothered by his post all day, but now I understand what happened. The dude got burned out. Koa, co, what he's been working on, it just makes way more sense to do that stuff with golang 
Maybe we can get him to hit someone and catch it on video to break the 1st Law ;) That's a great short story.
This is internal to JavaScript, and not node. You can do things more or less efficiently in any language.
&gt; Interesting that such a major player has so many bad things to say about Node. Cliché saying, but worth thinking about: "*Familiarity breeds contempt*." When you get to know something really well, you go beyond "this is icky" to understanding its deep and irreconcilable flaws.
reddit likes to block googlebots :(
:-| don't be sad!
Maybe about the Dart vs. Go part but NOT about Chromebook vs. Android. Google fucked up big time there. Windows was ripe for the picking but they pushed Chromebook--fucking stupid. They should have just pushed a unified android os and have been done with it. So why both Dart and Go? What's the point? Seriously. If I'm confused...hep a brotha out.
Yeah, but node core increasingly focuses on performance instead of easy to use APIs.
or Lazy.js
Jesus why would they do that?
Wouldn't a non-solid one make even more of a mess though? 
Never heard of that one before. That's pretty awesome. Add some tail call optimization and it's basically Clojure at that point.
I wonder anyone has ever tried to combine it with reactjs?
So there's a few aspects of this that I imagine you aren't familiar with. I'll do my best to walk you through them. To begin with, the browser is a unique execution environment in that it only supports one language. That language is Javascript. Many people hate javascript which is why, in many cases, it is treated as a compile target and acts in many ways as the assembly of the web. Google's Clojure compiler is an example of this, allowing devs to write Java that compiles to javascript. Dart is an experiment in developing an alternative to Javascript. It's the only other language that has an interpreter natively included in a browser, albeit just the one. Dart has nothing whatsoever to do with Go. Dart exists because we are reaching the limits of what can be gained from improving on JS interpreters like V8. In case you aren't familiar, Node is just a port of the V8 engine that allows the use of javascript outside the browser. Go is a completely different thing. It is a general purpose programming language designed for the type of massive distributed systems that google builds on a regular basis. It was designed by the same guys who created Unix and B (predecessor to C). These guys are CS gods. While I haven't used Go myself, I don't know anyone who has that doesn't love it. I only know one guy who has used Dart, but that's miles off from widespread adoption anyways. The point here is that both serve completely different purposes and in no way mutually exclusive. More accurately, Google isn't really "pushing" Go at all. They built it for themselves, and were kind enough to share. Dart is a great idea, and I'm sure they'd like to see it get more widespread adoption, but the reality is it will probably never replace javascript. Neither are consumer technologies which is the really big difference when thinking about this from a corporate strategy level. As far as Android vs Chromebook goes, I'd even contest that. Android is not suited to be a desktop OS, and 90% of users never use any application but their browser anyways so why not just ship a browser OS? I know guys at google that run a Chromebook Pixel as their primary dev machine. It's just a linux box with a browser for a UI. If you want to talk about fucking up, let's talk android fragmentation, their six or seven attempts at some form of TV OS that collide directly with Android offerings of other TV manufacturers. Basically their complete failure to reign in their OEMs and present a unified front for Android. That shit drives devs and users insane. If you've got both of those groups pissed at you, you're definitely doing something wrong.
Not that I know of. I'm happy to help if anyone wants to give it a try...
[x](http://i.imgur.com/CakjE.png)
Not everyone is as in-love with Go as TJ -&gt; http://yager.io/programming/go.html
WHO? 
I never got around to trying it, but you might be interested in this too (TCO for JS): https://github.com/puffnfresh/brushtail
&gt;Underscore comes with a ton of utility functions for quickly checking if a value is a particular "type". I use the word type loosely in Javascript, because it's essentially typeless with it's dynamic typing and type juggling features. I stopped reading here. "type juggling"? No. This is someone who is not comfortable with javascript trying to make it seem mysterious or error-prone. Type coercion is pretty easy to understand, and calling it "juggling" is disingenuous. Javascript is not "typeless", and this kind of misinformation will only serve to keep people from learning javascript. Javascript is weakly typed, it is not "typeless". 
See currying
It is going to be successor with reverse compatibility. Learning makes sense.
Do you have a legitimate purpose for this script, or are you just asking for help to spam some web-survey with hundreds/thousands of fake submissions?
Even once ECMAScript 6 is widely supported, knowing ECMAScript 5 is still useful, because, in many ways, it’s the foundation of ECMAScript 6. ECMAScript 6 is a strict superset of ECMAScript 5, which is necessary, because new ECMAScript versions must not break existing code. Quite a few ECMAScript 6 features are already available in browsers [1], but it will take a while until all of ECMAScript 6 is supported everywhere. However, there are now a variety of tools [2] that enable you to compile ECMAScript 6 to ECMAScript 5. There will eventually be introductory material that requires ECMAScript 6, which means that it can avoid or postpone explaining some of the quirks of ECMAScript 5. (Creating such material is on my to-do list for 2015 or 2016.) That will definitely help beginners to get started more quickly. The question is: can you wait that long? Moreover, if you are the type of person who wants to understand everything, you may not even gain anything by waiting. [1] http://kangax.github.io/compat-table/es6/ [2] https://github.com/addyosmani/es6-tools
Honestly, it seems kind of pointless or disproportionate - any handful of seconds' speed increase you'd get from going to all the hassle of writing, testing and debugging a script to fill in the form and then packaging it up as a browser bookmarklet would likely be completely negated by the time taken for the initial e-mail to make it across the network, through any automated spam-filtering/virus-scanning/etc that your ISP does and then sits in your inbox on their server waiting for whole real-time seconds or minutes for your e-mail client to periodically decide to check for new e-mail again. Plus, if the form is different in any way (eg, different IDs on elements, they change the order or number of questions at the last minute, etc, etc) then your script breaks and the time to realise and either diagnose what the problem is and fix it or to just abandon it and fill in the survey by hand would cost you more time than simply filling it out by hand in the first place. Or worse, it completes the survey and submits incorrect/nonsense values but does it so fast *you never know*, and either get signed up to the wrong month or your submission is rejected or only caught right at the end of the process by a human eyeball and you get offered the chance to correct it after *everyone else* has already had their (correct) submissions processed. Honestly, unless you can guarantee your e-mail client will literally receive it within a few seconds of it being sent *and* that the form will be exactly unchanged from your sample form *and* that other people will also be racing to submit it within seconds of the e-mail going out... well, I'd just keep a notepad open with your answers already typed out, then cut-and-paste them into the form, click the month you want and hit submit manually. You'll already have a massive advantage over everyone typing out all that info by hand, and you minimise the risk of your automatic script screwing up and costing you more time than it saves you.
Can't help but notice there's a really unhappy smiley face in this code fragment http://i.imgur.com/2izcCDs.jpg
I'd use params = params || {}; instead of params || (params = {});.
The riposte always gets a laugh from people who haven't heard it before: &gt; There are only two hard problems in Computer Science: cache invalidation, naming things, and off-by-one errors.
A lot of times it's just script errors in the malware. The script errors keep your code from loading correctly. Depending on the malware, they can do nasty things like overload [] indexing which can cause issues in what appears to be correct code. If your code assumes an external resource is loaded like jQuery, it might not actually be loaded due to the malware. 
according to [this](https://forum.avast.com/index.php?topic=36454.0) Vundo is a spyware that is injected into Javascript on webpages. This is very interesting, I didn't even know this was a thing.
This looks amazing. I've played with Clojurescript before, but didn't realize he ported that functionality out into it's own lib. I'm definitely going to play with this. Thanks.
"Our engine is easy to code in!"
&gt; they can do nasty things like overload [] indexing How would you do this? I didn't think JS supported operator overloading. As best I can tell, it seems like it's possible on certain browsers (i.e. IE)?
ES 5 vs ES 6 is nothing like Perl 5 vs Perl 6 or Python 2 vs Python 3. ES6 mostly adds new features, some of which are backwards-incompatible because they add new syntax. It doesn't remove existing features or break existing code. Also, ES 6 likely won't be usable in production for at least another year, even if some features have already been introduced experimentally in most JS engines. Not to mention the market share of legacy browsers if you want to use it on the client-side.
Array.prototype
And how specifically would you overload array indexing from Array.prototype? Which method would you need to override?
I think using ECMAScript 6 transpilers has helped me get a better understanding of what ES5 can do. I'd say there is no reason not to start with ES6 today. At this point, you're definitely learning both, to your benefit. With all of the major browsers switching to an 'evergreen' distribution model, we'll be able to see more frequent releases of ECMAScript versions, so why not get on board early.
eh
&gt; he's never been seen publicly Why should that matter? Did I miss the PSA that you have to appear in public if you like something a lot? Maybe he's just not into conferences.
Bah! Lies! Just lies being perpetrated by Big Node. 
This seems like an awfully strong reaction to two words. Lighten up. 
Not sure you can actually. I'm wrong. If there is a way, it's browser specific. The only way I can think is if the malware takes over the global scope by creating an object and setting window to it, but not sure if that would work either. 
For anyone who's interested by this stuff, I recommend you listen to his episode of JavaScript Jabber: http://javascriptjabber.com/107-jsj-clojurescript-om-with-david-nolen/ Aside from clojurescript itself being really interesting, Nolen's projects Om and Mori are both work a look. I don't think it's a "secret" to anyone that we may be looking at real paradigm shifts (Don't worry, I hate myself enough for using those words, you don't need to say anything) in JavaScript programming in the next couple years to come. At the very least, new options are available, and great minds are working out how we could build apps in these new ways. I'm excited for the future of javascript, and Nolen's work / product of mind is a big part of that.
Gross
TL;DR: "I want to feel validated by using Node!"
Why? Both are wrong.
You are talking about perfect use cases that everyone agrees upon and is the main reason they started using node.js in the first place. Considering the amount of code TJH has written that constitute the backbone of numerous applications, he is especially entitled to say so, he must have earned that much credit. I would not care to read about a newcomer's issues with "callback hell", but I am keen to read what kind of issues TJH runs into due to callback. I had looked at GO before but reading his arguments convinced me to experiment more with it.
Both are correct (they do what the programmer wants to happen). It's up to discussion if there's a better form. A third alternative exists: ` if (!params) {` ` params = {};` ` }` I prefer `params = params || {};` as the third alternative is more verbose to my liking, and `params || {}` is known enough in the JavaScript programming community and culture. What's your preferred way to set the params variable to an empty Object if it's falsy?
&gt;I know of no Sublime Text plugin that does this, though, the functionality is pretty common in more full-fledged IDEs like Eclipse. No, the solution isn’t to start using Eclipse or Webstorm. The author never really gave a reason for that not being a valid option
if "people know javascript" is much of an argument, then surely "people know java" is even better, because java is all over the backend, not just web/http stuff.
because vim is the only option. emacs is acceptably contrarian. everything else is UNACCEPTABLE.
Show us your current code
Neither is correct, because `0`, `false`, `''` might all be legit values for `param`. I would use param === undefined &amp;&amp; ( param = DEFAULT_VALUE ) or, given `function ƒ ( param ){ ... }`, even '1' in arguments || ( param = DEFAULT_VALUE )
We've been having similar issues with something called PassShow.
Seems like an odd complaint but the font choice does not play well with lower res large screen devices. I imagine this would be hard to read on a lower end tablet as well.
I can see you watched [this awesome talk](https://www.youtube.com/watch?v=m3svKOdZijA&amp;feature=kp)
So all functions should be prepared for any kind of parameters at all times? I bet your code is pretty verbose. 
I really like this. Great work!
What's also nice about Lo-Dash / Underscore is that when you use the iterator function you create a new function scope for each iteration. This prevents you from having to use an IIFE in some cases if you want to bins a function in a loop for example. In Lo-Dash you can also return false inside a _.each to break the loop. Not sure if Underscore does something similar. Not using a utility library is ridiculous imo. You can also hook Underscore.string into Lo-Dash by the way. Another great library to manipulate strings.
No, it's a correct reaction to the built-in aversions and misinformation a lot of programmers have when they first hop into javascript from a different language that may be less object oriented, or more strongly typed.
&gt; misinformation a lot of programmers have First, that makes no sense. Second, you're the second person to misuse that term here: &gt; misinformation: false or inaccurate information, especially that which is **deliberately intended to deceive** 
Why would you want a (more or less) shitty language like javascript on the jvm, when there are already languages like Scala, Clojure and Java itself? If I really need to have the same language on both ends, I'd rather try to use something like scala.js for front-end code.
Sorry. You are correct. I was non thinking in the context of the article, but in general.
Use a lazy evaluation library instead. Like Lazy.js. It is incredibly faster on larger data sets.
Yes, if you're using angular then ng-flow. Otherwise you can use flow.js or blueimp.
Vim is a valid and acceptable argument for not using any other editor with fancy features. If only IDE makers understood why Vim is so great.
Misinformation, such as that javascript is a lesser language, or somehow wrong in its differences from what they know. Yes I would consider that misinformation.
&gt; Most visitors, once they see a blank page, won't return or bother emailing.. so this kinda hurts. Well, and otherwise everything they do might be transmitted to a third party. Completely breaking the page really isn't the worst case scenario. Also, this might tip them off that something is wrong with their computer.
Hi, you can just turn auto-rotation off and draw with landscape orientation.
The purpose was to make a Firefox OS app, so I didn't put a lot of time on the desktop. But I'll fix that if I get time to. thanks.
Actually I followed Firefox OS' style guide for fonts and stuff and I couldnt test that case because I dont have a tablet. I'll try to use a friends tablet to test it out. thanks.
You can find the Firefox OS version here: https://marketplace.firefox.com/app/sketchy/ You can install it using Firefox for Android too but that's experimental and might not function properly. Thank you!
I don't actually use the build system -- instead I use Component for module discovery. Most of the modules on there are dual-published on NPM, so in the end I just end up using Browserify.
What about [P vs NP](http://en.wikipedia.org/wiki/P_versus_NP_problem) problem?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**P versus NP problem**](https://en.wikipedia.org/wiki/P%20versus%20NP%20problem): [](#sfw) --- &gt;The __P versus NP problem__ is a major [unsolved problem in computer science](https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_computer_science). Informally, it asks whether every problem whose solution can be quickly verified by a computer can also be quickly solved by a computer. It was introduced in 1971 by [Stephen Cook](https://en.wikipedia.org/wiki/Stephen_Cook) in his seminal paper "The complexity of theorem proving procedures" and is considered by many to be the most important open problem in the field. It is one of the seven [Millennium Prize Problems](https://en.wikipedia.org/wiki/Millennium_Prize_Problems) selected by the [Clay Mathematics Institute](https://en.wikipedia.org/wiki/Clay_Mathematics_Institute) to carry a US$1,000,000 prize for the first correct solution. &gt;==== &gt;[**Image**](https://i.imgur.com/edygnv3.png) [^(i)](https://commons.wikimedia.org/wiki/File:Complexity_classes.svg) - *Diagram of complexity classes provided that __P__ ≠ __NP__. The existence of problems within __NP__ but outside both __P__ and __NP__-complete, under that assumption, was established by Ladner's theorem. [1]* --- ^Interesting: [^Computational ^complexity ^theory](https://en.wikipedia.org/wiki/Computational_complexity_theory) ^| [^NP-complete](https://en.wikipedia.org/wiki/NP-complete) ^| [^Boolean ^satisfiability ^problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem) ^| [^NP-hard](https://en.wikipedia.org/wiki/NP-hard) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cipiq5f) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cipiq5f)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Well TIL. Good heads up man/woman.
What about jquery.**min**.js?
To me, this seems like an error state. The request failed to complete (never started), so that's an error. 
same. dont use latest version from cdn in prod.
Just have a local fallback and use the CDN as default. A lot of people have the CDN jQuery already cached so it's not an extra request, so you're saving a request most of the times. Edit: to add: a CDN is almost always closer to the user than your server. The request to the CDN will be faster thanks to the reduced latency. CDN's have multiple servers across the world, and most of the time, you have one.
Another caveat to cdn: http://wonko.com/post/javascript-ssl-cdn if you are ssl-ing, then skip cdn altogether for sure (as you cannot verify the "secure" part anymore). Sorry, just thinking out loud here, never really considered a cdn in the first place (except as an initial experiment). Another thing is that it is likely to cause silent errors if the network fails somewhere. If you have everything possible on your server and have a monitor on it to notify you if it stops responding, then cool. If your users browsers can't connect to an arguably unnecessary cdn, you might never know, because it is a different network path and your monitored server is out of the loop.
That blog talks about an example library by a company. We're talking here about the biggest Javascript framework, hosted by the top CDNs in the world. Those CDNs are not interested in the customer information on your little website. Being a CDN is their business and they are showing that they do an excellent job. Just use MaxCDN (provided on the jQuery website) or Google's CDN, this will also ensure you get the performance benefits I describe below. It doesn't cause silent errors if you implement [a proper fallback](https://stackoverflow.com/questions/1014203/best-way-to-use-googles-hosted-jquery-but-fall-back-to-my-hosted-library-on-go). This way, even if the CDN fails the users will get jQuery loaded on the page. The last thing: Performance. Users don't even connect to the CDN most of the times because it's already cached. They visited some other place which also uses MaxCDN or Google's CDN service. In the browser, rendering stops when loading Javascript (that's also why you should load Javascript right before the &lt;/body&gt; tag). By loading it from your own server, the browser does another requests, and executes jQuery before continuing. On a CDN, it only needs to execute it most of the times.
I like the irony of jquery.latest.js forever being locked at an old, soon-obsolete version. 
Good work guys, downvote someone for asking a question. That's the spirit! (posted when this was -2)
The kind of stories that build scripts tell around the camp fire. 
[Google Hosted Libraries - Developer's Guide](https://developers.google.com/speed/libraries/devguide)
If you don't want to listen to another opinion, you shouldn't post yours here. Most websites use CDN's because it speeds up the experience, and every second counts. If you think it's 0.001 you should know that even initial latency on 3G is around 300ms. Most of the web developers use jQuery with a CDN. If you think that's bad, you're disagreeing with a large community of experts, and your answer to them is two lines. If you really think you're better than all of them, I wish you good luck making progress as a web developer.
I see, appeal to "authority", yah that addresses my concerns. Lets put MORE web developers on the server side please!
Is your whole assumption based on "all CDNs are non-TLS"? If so: you're wrong.
It's in the first sentence of the article
My security concerns AND your performance concerns can be addressed via concatonation/minification/gzip. multiple connections add overhead and ssl especially so. You can't claim your site is as secure as possible with CDN, plain and simple. Sounds like a bad habit to me, as anyone can add a javascript keyboard listener to your webpage and you would never know it. Adding external dependencies should never be taken lightly, you have no idea what you might break. http://stackoverflow.com/questions/19943588/is-google-web-fonts-or-cdn-bad 
Doesn't localStorage have size limitations? My site sends 169k of gzipped minified javascript across the wire, but after decompression, it ends up being 561k. A quick Google search shows that we have 5mb to work with (depending on browser implementation), so that's a little bit over 10%. Factor in irresponsible usage of localStorage (e.g. saving base64_encoded images, XML data, etc), and you'd very easily hit the ceiling... ... But I do wonder if basket.js could gzip the scripts before storage as well... 
Thank god I use modern package management and build tools so these kinds of things are non-issues for me.
Anyone know of sweet.js macros for Mori? I saw the ki project already, but was looking for something just focused on the Mori side of things.
To be a bit provocative, if you didn't consider directly including a file called “jquery-latest.js” controlled by an outside entity a very very bad idea in the first place, you probably shouldn't do software development at all.
Power drill, screw driver, or a forge?
If you are ever making a web app that gets rotation/acceleration/etc. data from the phone, your users will have to download an app, whether it's ours or yours. Instead of having to write your mobile apps, and the interface to communicate with them, you can just use ours. If you just want to have browsers communicate, you don't need the app. And as far as having your own server goes, the savings are in the development time and not having to manage all the real time communication between devices and browsers. In fact if your only server need is the real time communication, you can just have a static webpage. For example, if you wanted to make a basic IM site, take a look at this example: http://tiltedlamp.net/dev/example/messaging_example
What? Nobody is going to use that. And why not use the new sensor Web API's directly? These are being rolled out in modern browsers so you dont need a shady app like this.
Link? And if they aren't fully supported, you'll need an app to fall back on. Also, there is considerable utility even without the mobile app.
Also, out of curiosity, what part of the app seems shady?
I'm not brtt3000, but it's shady from a users point of view, because it's something that you have to download.
What are "clean arrays?"
A quick Google search gives this: http://w3c.github.io/deviceorientation/spec-source-orientation.html
I see where you're coming from, but if, as a user, I'm gonna be using my phone as an input device, wouldn't I expect to have an app installed on my phone? Much in the same way that Netflix uses sliverlight, which is an additional software that the user has to install
&gt;TiltedLamp uses socket.io for communication, thus it must be included You should specify which version of socket.io to use. &gt;Thus we will use tl.ready to wait until we know the user id. Have you consired using promises instead of callbacks in your API? &gt;button = tl.createObject({ Why is HTML and CSS reinvented using a JavaScript api? I rather use HTML and CSS and maybe add an attribute to the button instead of learning a new syntax. As for the whole concept, I can't see much value in this except for maybe beginners. TiltedLamp doesn't seem like it can integrate well with other libraries and frameworks, so it'll work well only for simple apps. In addition, since TiltedLamp owns the data most people will want to host the servers themselves.
An example of the code you'd normally need, vs your API would be helpful. I've never implemented anything like this, but I imagine that I'd: 1. Generate a number, and display it either as text (if short) or a QR Code 2. Scan the code on mobile, which would take you to a page on my server that would listen to `deviceorientation` and send the data via websockets back to the server 3. Back on the original page, connect to the websocket server as well, and receive the data. Now, I'm aware that that probably isn't that trivial - an example on the page that clearly explains why I don't want to dive down that rabbit hole would be helpful. Also, why is the app needed? Why wouldn't you do it without?
Just so you know, the QR code specifications require a ["quiet zone" or margin](http://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/QR_Code_Structure_Example_3.svg/800px-QR_Code_Structure_Example_3.svg.png) equivalent to two data squares on each side. This will allow faster reads.
I'm not sure, I've never seen it done like that before: * http://bemoredog.o2.co.uk/frisbee * http://chrome.com/maze/ are two sites that spring to mind that I've used in the last year or so that use a phone as a controller without needing an app. Conversely, I can't think of a site that does require a companion app.
Thanks for the advice, we'll add an example like that! And a bunch of people are mentioning using deviceorientation/devicemotion. We'll look into that, and if the user's mobile browser doesn't support it, we could always fallback on the app.
TiltedLamp doesn't own any data, it only serves as a channel of communication. 
A 3rd party companion app for a website with network privileges? That kind of app is notorious for spy/scam/bloat/add-ware.
Yeah, we should definitely add the version, oops! So you're saying you'd rather send a block of HTML/CSS for me to render on the phone? We can do that, we just felt it would be clunky. And you can use whatever other libraries/frameworks on the browser side.
If I understand this correctly, Phonegap lets you make apps using HTML, CSS, and Javascript and as awesome as that is, thats not what TiltedLamp is going for. Think of it as a platform that allows a web developer to use input from mobile devices without worrying about any mobile code at all
 This is why we can't have nice things. "Are you happy now, lazy coders?"
thanks! we'll give it a shot and leave the app as a fallback in case their browser doesn't support the deviceorientation/devicemotion stuff
That link shows that if you provide valid fallbacks, you'll be fine... Were you thinking about something else? Also - Google's CDN as well as the other well-used CDNs offer TLS and have had a good history, no? Do you have any examples of a CDN of that caliber being broken into and had a "javascript keyboard listener" injected?
Your link says: &gt; Summing up - you should use google CDN and font only if you provide a valid fall-back. I've said that you should use a fallback. Your argument however is security. The link doesn't say anything about that. &gt; as anyone can add a javascript keyboard listener to your webpage and you would never know it. Do you really think MaxCDN or Google could get away with that?
Heh you should think that it would be a lot faster to serve the assets with the appropriate cache headers and rely on the built in browser cache. 
I honestly think they should let sites break. It's the only way people are going to fix it.
So they build the mobile page, and tell us which buttons/events to send to the browser(s)? And we just provide functions for automatically sending the data/scanning the QR code/communication? Then you can make the mobile page look/do whatever you want.
This isn't r/coffeescript
In ES5, when you say new SuperArray(), you get an instance of SuperArray (which is just an object) that is then passed to the Array constructor (which does nothing you want, btw, if you look at its signature). [] and new Array() return you an array instance which has a few [special properties](http://es5.github.io/#x15.4.5) not found in any other object. ES6 fixes this situation with a feature called "Subclassable Built-ins". Date is another "class" that you will find resistant to "subclassing" in ES5. A workaround in the meantime is to make your constructor body something like var instance = []; Object.setPrototypeOf(instance, SuperArray.prototype); return instance; This is obviously inefficient and doesn't work well cross-browser but it does work. Zepto, notably, uses this workaround.
Because I like performance when I spend 3 minutes on it, but I don't like it anymore when I spend a 3 days getting a build system into my workflow.
Node authors have many times stated they keep the standard API to absolute core of what you need and then let the user land build the nice APIs on top of that.
Imo this is exactly what I think you should do have to do and was what I was going to give as an answer. This is a prototype based language, it makes sense that extending something would require taking on its prototype and then calling it's constructor function from my point of view. I noticed the prototype piece being missing instantly just because that's how I would've started the exercise. I think you are correct that OP was thinking the constructor function would be doing something different than it actually does (which would make since if it wasn't a prototype based language). Edit: does it work to set the super array prototype equal to the array prototype and then call the array constructor function in the super array constructor as in OPs example? Can't test it atm unfortunately. That way you avoid having to create the instance like that which is a lot less 'magic' in my opinion. 
&gt; A lot of people have the CDN jQuery already cached so it's not an extra request, (...) Citation needed. I know this is an often heard argument, but I would really like to see some numbers to back this up. Even though jQuery is the most-used library, it's not on every site. And not all jQuery-using sites use the CDN. Finally, provided you indeed don't use jquery-latest, this request-saving advantage only applies between sites who use the exact same version of jQuery through a CDN. I'm genuinely interested to know how likely this is.
Most people use jquery for websites, not web applications. For the first one you use a CDN, for the second one you can choose both routes. I currently choose the CDN route in my web application. Most of the discussion however was about security. But using a well known CDN doesn't give websites or web applications any security problems. A build system could be better, but for most users that would be a step too far (too hard to do, or too much time), so I didn't discuss that possibility in my comments.
Prototype and instance allocation are orthogonal concerns, although the unfortunate part about ES5 is that you cannot separate special allocation semantics (eg. arrays which allocate a special instance object with special semantics for setting length, typed arrays allocating the backing buffer and etc.) with initialization semantics (eg. setting 'state' to 'initialized', setting array properties to be empty arrays, etc.). The confusion is that for objects that don't need any special initialization semantics (ie. they are just plain objects, such as anything you can make with a JS-native constructor) the pattern of calling the parent constructor from child constructor just works. This pattern is used pervasively across the Node world, and works just fine. Unfortunately, there are cases where it doesn't, namely built-ins with special allocation semantics. The solution is hinted at above - separate out the allocation semantics. In ES6, allocation is done via a special method called @@create, and the constructor just focuses on initialization. Subclassing works because you don't override @@create in your subclass, and thus your subclass constructor gets an instance of the superclass to initialize. Likewise, the pattern of calling the parent constructor as OP does just works as well because the parent constructor is just doing initialization and not trying to allocate anything. ES6 classes' super keyword works pretty much exactly like ParentClassConstructor.apply(this, arguments).
&gt; Just have a local fallback and use the CDN as default. How? I tried doing it and could not without some crazy hacks. Is there an easy method I overlooked?
I couldn't find a recent source for this. Edited my comment with another reason: the request to the CDN is faster than the request to your server most of the times. So even if they don't have it cached, it's faster. I'm going to research the amount of people who have jquery cached later on.
The best way is described here: http://stackoverflow.com/a/1014251/3759427
it burns my eyes to look at such ugly syntax oh and yes, this should be an error state as psayre23 said, indeed.
CDNs have TLS and resources from TLS hosts can also be cached.
If you are in china (1/4 the worlds population) the google cdn is gonna make things slower (extra dns lookups and connections over ssl), every time. Folks who test cdn vs concat/minify also find there is often little to negative benefit of cdn performance. I don't know anything about their "caliber", I do know that it is run by people and sometimes people have a bad day, and that they are under no obligation to ensure the security of your users, they are not on your payroll. Have you tested that cdn was necessary for your site and did you compare it to alternatives with better security guarantees? 
That might be the best way currently possible, but it's not a very good way. For example: "...any jQuery ready event handlers should be in the &lt;body&gt; to avoid errors (although it's not fool-proof!)." When I tried it with google blocked as a test every single page took 30 seconds to load, waiting for the google url to time out. And worse, meanwhile the page was loaded and displayed in the browser, but completely broken. I decided this fallback method was a failure and went back to simply hosting it locally. If you are using jQuery just for some minor effects and stuff then fine, but if your page is entirely dynamic this doesn't work.
Just use a gender-neutral word. Like "bitch".
Well if you don't test that your site needs cdn, then using it is premature optimization, and several comparisons of cdn vs concat/minify don't show show much if any performance benefit. probably %99.99999 of its use nothing more than an unnecessary external dependency. Do I really think MaxCDN (or google, i.e. china) is perfect? Why would I put myself and my company and users in that position when I can have a known and tested copy on my own domain (and avoid multiple domain connections etc to boot?)
I suppose if your user base is largely in China than it makes perfect sense to have a Chinese CDN of some sort instead of something off-country (or even maybe locally hosted, but if there's a Chinese CDN that's widely used that's where you want your jQuery and whathaveyou to be). The benefit of a CDN should be determined if it matches the majority of your audience. I definitely get that there could be security issues from Google or Max with their CDNs in the future. That sort of turns things into a "what-if" hypothetical game. You'd have to weigh your options either way. I don't think going CDN or not going CDN is by default more secure than the other. And yeah, I tested CDN usability on the sites that I make. For some sites (especially internal ones), it makes no sense. For others, it's a definite no-brainer.
The support is very good, it's been around for a long time now - http://caniuse.com/deviceorientation iOS 4+, Android 3+, even in desktop Firefox/Chrome if the device has an accelerometer (e.g. Macbooks without SSDs). Mobile IE is the only current browser that doesn't have support.
It's about time we ditched gender-specific terms. I think I'll start casually using "bitch" now.
There's [hammer](https://github.com/EightMedia/hammer.js/)
If you haven't compared it to minify/concat (which you can arbitrarily break into 6 parts if you like) from a single domain then it isn't yet a no-brainer. If folks can't get to your domain then cdn is a non-starter, if they can, then it seem like a no-brainer to keep them on a network path that is known to be working (and code that has been validated). I get that it is essentially "free" bandwidth for your site, but there is no service level agreement with a CDN unless you have a paid contract with them, and none but google seem to have the geographic penetration to make a real difference (except in china). At least with DNS you are paying someone for the service and there is some accountability. And if they already found your page then they don't have to do any more DNS-ing without cdn (which given the 1 hour cache timeouts and number of versions is pretty likely). I just don't see it being a no-brainer, external dependencies for trivialities shouldn't ever be. 
I wouldn't say they are orthogonal in that one depends on the other. We have no notion of class so 'instance' has zero meaning without prototypes. Es6 will add syntatical niceties but it does nothing to change the fact that instances are created based on a prototype. There are plenty of libraries that give you the ability to create special allocation semantics and inherit/extend already, es6 isn't actually changing anything other than providing syntatical sugar (a credit to the nature of prototypal language that the abstraction can even exist). What I still wonder about is whether the abstraction is sufficient to completely hide the details of the prototype and it's existence for people who use it solely as 'class based', otherwise it's not of much value imo. 
Which should be fixed with Windows Phone 8.1.
Where is it?
&gt; I'd prefer to not use a library or plugin of any kind, my inquiry is really related to what's going to be the best in terms of performance. Do you want bubble warping of the panorama image, or just a flat 2d scroller? For bubble warping then WebGL would be the fastest, so perhaps you could try [three.js](http://blog.thematicmapping.org/2014/01/photo-spheres-with-threejs.html). That article talks about a canvas fallback mode. If it's a flat 2d scroller then CSS transforms would probably be the fastest. Break up your image into tiles and CSS transform them in a requestAnimationFrame callback. 
Ok guys since noone did it before me publicly I created an obfuscator for a whole Nodejs project and made it open source. **node-uglifier** It worked for me on a juge real life project, hope it works for you as well: https://github.com/zsoltszabo/node-uglifier https://www.npmjs.org/package/node-uglifier 
Just to be clear: Hammer is too low-level to detect gestures shaped like the letter Z (as the OP asks) but you could write it by recording the last second's worth of gestures and detecting shapes in that.
[this](http://anantgarg.com/2009/05/21/jquery-fancy-gestures/) ?
What? You already have access to the parent constructor through the prototype.
It's in downtown London. Venue isn't confirmed yet. More info here: emberjslondon.eventbrite.com
How was my statement boastful? I was just making the observation that stuff like worrying about how the jquery cdn decides to handle versioning become non-factors when you decide to take ownership of your own dependency management with the modern tooling that is available.
You should read the project description.
Uh... The super classes constructor? How is this not currently possible? Edit: oh and here is a very simple write up 5 seconds of googling turned up from a guy that knows a thing or two about js showing current js equivalents including for super (not that we didn't already go over it. I'm confused) http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/
His point is that it's "statically" bound (this behavior is not shown in the desugaring you linked). See also: new ES6 function Function.prototype.toMethod.
Ah and that's why science has nomenclature. No toMethod is not possible (it is an addition to Function . prototype afterall). Static binding is however afaik and I believe Traceur supports it now. 
Give me a specific example in es6 of what you would be wanting to do. Edit : I mentioned to a different users reply: I'm nearly positive I remember an esdiscuss thread where a dev for Traceur mentioned it can handle exactly what you are saying (typescript pretty clearly would not implement it properly imo) . However, in case I am misunderstanding exactly what you'd want to do I am actually quite happy to be proved wrong by an example. 
prerender.io does not require you to use #! in your URL. In fact, html5 mode is preferred! The URL will just look like http://example.com/?_escaped_fragment_= instead. -todd@prerender.io
My only point was that everything here is possible in es5 but is made cleaner with es6 (as has been reiterated the Internet over for years at this point). 
Thanks. Do you have any recommended sources for poetry theory?
'SuperArray'.replace(/Super/, 'Quantum')
What's an exotic API? Sounds sexy
You could do it with a timeout. Hammer can detect the direction of a drag or swipe. Just have a timeout in the function that waits for a second/third/fourth swipe, detect the direction of each, and then assign it a function. Source: did this for a javascript app. 
Start with this: https://en.wikipedia.org/wiki/Meter_(poetry)
This: [javascript-guide](https://github.com/azer/javascript-guide) [declarative-js](https://github.com/azer/declarative-js) [NPM Everywhere](http://slides.com/azer/npm#/) Welcome to the new age :)
Great resource! Honestly though, I'm really hesitant about using es6. Compilers aren't optimized to run it yet, so even when it's 'live' there'll be es5 alternatives that work better (at least initially), not to mention legacy support (jesus christ). It'll be a few years before I feel comfortable using 'vanilla' es6 in the browser... And I kinda like the chaos of npm :) 
Google finally crawled it, got the content (dynamic) off the homepage, we'll see if they manage to do a deep crawl. I think these "SEO" hacks for SPAs are pretty much over if that happens.
&gt; I don't think it's a "secret" to anyone that we may be looking at real paradigm shifts (Don't worry, I hate myself enough for using those words, you don't need to say anything) I largely agree, but Om and Mori only represent the intersection of two paradigm shifts occurring right now. The first shift is related to Rich Hickey and clojure, specifically his design of immutable data structures and emphasis on using functional programming in an OOP world. I think the second shift is related to React's abstraction of the DOM, which I consider to be as profound as the introduction of ajax with Gmail. The examples mentioned above were (and still are for some), considered counterintuitive. And that's why no-one tried to do it. Our technology is advancing exponentially, while our culture is trudging along linearly. To this day, programmers are still using patterns that were developed for systems with a few kb of RAM and processors running in the mega-flops. 
He's gonna be using the most unused default functions out there. On a serious note though, javascript is barely a learning curve compared to PHP/Python, and if you want to be a serious coder you shouldn't break a sweat over Javascript API's. There's always jquery and node.js for Javascript libraries. Don't laugh at me for saying this, but I learned Javascript mostly at W3Schools lol
I can't tell if this is all going over my head or whoever wrote this just isn't very good at explaining it, but I don't understand a lot of this. For example, by "tail calls" does it mean tail recursive functions will now be executed iteratively instead of recursively? Because if that's what they author was trying to convey, he did a poor job of it. 
You'll likely get downvoted for admitting the thing about w3schools. :) If you are just throwing some interaction on pages and doing fairly simple stuff, vanilla js or jQuery are fine. I got by with it for a long time, but I was mostly server side. I'm full tilt front end now and that's where you gotta start looking at design patterns and really understand the language a little deeper. Coming for a strongly typed OOP background (C#) this was a little painful for me, but I think I finally have my wits about me. Pluralsight was a pretty good resource, and MDN.
Yes that is what a tail call is, it folds recursive function calls by not allocating new stack space for each subsequent invocation, provided the stack isn't required after that point.
Why do you mention npm? Is node not updating to es6?
Generators are exciting because they can make asynchronous code [more straight-forward](http://taskjs.org/). You can use a lot of ES6 features today including generators by using the [Traceur compiler](https://github.com/google/traceur-compiler), which compiles ES6 javascript to javascript that runs in today's browsers.
This is nice, but I was salivating at these features three years ago. It's now 2014 and arrow functions, destructuring, and for..of still aren't usable in Chrome, not even with experimental JavaScript turned on. :/ I've sort of gotten tired of waiting...
I did, and I'm still surprised. 
The owner of this account has requested this content be removed by /u/GoodbyeWorldBot Visit /r/GoodbyeWorld for more information. GoodbyeWorldBot_v1.2
I'm the most excited about TCO and the syntactic sugar (arrow functions and classes) Being able to skip the annoying boilerplate of function Foo () {} Foo.prototype = new Bar(); Foo.prototype.method = function () { ... } And all of those freakin var self = bar when all you wanted to do is map an array..
Wonder what DC thinks about the class syntax? Well, I for one really look forward to es6, but I wonder when its actually going to be usefull (because Of IE), im betting that polyfills are going to be needed for many many years. :(
:'-( don't be sad!
I want this here, now!
Crockford said in a talk that he's certain the `class` keyword will be part of the bad parts of JS, but they kinda had to add it because it's so commonly requested. As for the new features, the new methods we get will probably be usable straight away with polyfills. New syntax can't be polyfilled however, as existing JS engines (IE...) will just throw a syntax error. To use the new syntax we'll probably need to use a compiler which compiles es6 syntax to es5. 
Some good data from Steve Souders (creator of YSlow) from a little over a year ago: [HTTP Archive: jQuery](http://www.stevesouders.com/blog/2013/03/18/http-archive-jquery/)
a lot of ES6 works already on node 0.11, using `--harmony` flags.
Indeed. Use TypeScript or Traceur or some SweetJS macros and feel amazed.
This monologue might be indicative of the onset of depression.
I guess his work takes place on listing the features and making a small introduction. If you want to dig deeper, you must go to other sources.
Unfortunately this is why I think it's a safer bet to become some sort of "management" as you get older. :-/ I already feel this way and I've only been coding in industry for 10 years or so. Either that or get some business chops and start up your own consulting firm. 
Out with the old and in with the new I guess.
I assume from your reply that you are young. I used to be too, not too many years ago. At the time I assumed I was just great, and would continue to be. Now, not too many years later, I have a family to care for, not only by providing for them, but by being WITH them. I can't help but identify with the writer in this article, but my worries are not only on what will I do when I am old enough to not be able to keep up with every new thing that comes out twice a week, but that this profession, although exciting and exhilarating at first, might just be unsustainable in the long run. That might be something to keep in mind especially when you are young.
What I have done is try to drive technology choices at work, that way I can learn as I work. I've found it much harder to learn something without a real need or project. Also, my guess is that many family dudes have more time AT WORK that could be used to tighten up fundamentals and learn new things, but isn't.
Jamun is an open source (Apache Software License 2.0) Server and Frontend Framework for the Web Designer (and also Java Programmer),HTML5, and Javascript developer, to quickly create CRUD Apps for Database, Cloud, Mobile, and Web Services. Confused by MVC, REST, SQL, noSQL, and other programming jargon? The Problem with too many frameworks - they all try to do (promise) too much. Thus creating too many unnecessary complexities. Jamun was designed for the rest of us. Jamun abstracts all of the above so you can really concentrate on what you do best - CREATE cool Cloud-ready apps. Create backend without any code. Jamun makes the server as dumb as possible (from a frontend perspective) - by putting most presentation logic on client, without compromising integrity and security on the backend server. Jamun minimize unnecessary back-and-forth traffic between server and client. With the advent of client based apps like HTML5, many security issues have arose, e.g. client spoofing. Jamun allays those concerns without any programming via field level security. Some of the highlights of the features of Jamun: Zero or no server code. Server-side JavaScript and Java. Clear separation of concerns between client and server - that is the server is 100% Web Services API and therefore there is no exclusive View binding. One can use the same backend resource for multiple frontends or apps. The server is client agnostic. Abstraction to the underlying frontend. This means less client side code changes in the event of a frontend change. Scalable - Event-driven - Non-blocking architecture. Single-page client model. Easy App Deploy and Update with App Manager GUI. Designed from the ground-up for Cloud environments. Coding is fun once again!
I feel so fortunate to work in a small shop where my co-worker and I get to decide what technologies to use. I've learned so much in the past two years, it's nuts. I'm afraid a day might come where I have to go work for someplace else and be maintaining some busted ass piece of legacy code, using some busted ass workflow and not have the power to change anything.
Is this a type-o or am I missing something. Under [Arrows](https://github.com/lukehoban/es6features/blob/master/README.md#arrows): // Lexical this var bob = { _name: "Bob", _friends: [], printFriends() { this._friends.forEach(f =&gt; console.log(this._name + " knows " + f)); } } I'm just wondering why `printFriends` is missing a semicolon in its declaration and isn't something like this: printFriends: function() { or this: printFriends: () =&gt; { I don't know much about Ecmascript 6 yet.
You just need good fundamentals (Which is what a CS or similar degree should give you). You need to have a solid grasp of OO, design patterns, functional programming, knowledge of common data structures and collections and a solid grasp of computer architecture. That will enable you to pick up new tech quickly when needed. 
'printFriends' doesn't have a semicolon because it's being declared as a property in an object literal. For your 2nd question, I believe the arrow syntax only works for functions being defined as object properties (correct me if I'm wrong).
&gt;Things change when you’re part of a team. It makes tons of sense, but I do miss it. I miss being able to play at design and HTML and CSS and see it into production. I miss being able to tweak server configs to see if I could squeeze extra performance out of PostgreSQL. Now I feel terribly specialized You can be in a team and still touch all the parts of the stack - it's called being a full-stack engineer.
[object literal value shorthand](http://ariya.ofilabs.com/2013/02/es6-and-object-literal-property-value-shorthand.html). Makes sense now. I think the arrow syntax is shorthand for function declarations and so it should work anywhere you would declare a function. If there are restrictions on where you can use the arrow expressions, I'm not aware of them. ['1','2','3'].map(n =&gt; parseInt(n)); // same as ['1','2','3'].map(function (n) { return parseInt(n); }); var squared = (n) =&gt; n * n; // same as var squared = function (n) { return n * n; }; 
Is simply impossible to keep updated and trying to do so will cause a lot of stress. I realise that building things is what i enjoy , no matter what technology is behind and that has worked for me. I know js, node, .net, java, lua and trying to keep up with new versions of libraries and frameworks did not make me happy. My approach right now is to value more the creative process over the tools, i dont't want be an expert , i don't have to be one to build things that i or other find useful. Life is good after accepting that.
Thats the definition of hell to me.
I'm still young, but not as young as a growing number of developers. I still love what I do and intend to keep up with it for as long as I can. Still, I can't help but wonder where I'll go and what I'll do before my career ends some decades off. I guess many developers eventually transition away into management. Maybe that's the way that I'll go, but not having an exit strategy worries me. After all, we all get old some day. At least, the lucky ones do.
Speaking as a fifty-two year-old, my observation is that not all new things are equal. I agree with people who say "Yes, learn what the hell a generator is, already!" But I empathize with the author that sometimes, the new thing isn't worth that much, and the number of new things that aren't worth that much far outweighs the number of new things that are Aha!-worthy. For example, if you know Smalltalk and you learn JavaScript, most of what you learn is just different and finicky ways of expressing the same damn ideas. But you have to learn them, because they work in slightly different ways. A few things, like prototypical inheritance and the lack of encapsulation, are major differences. But mostly, it's like learning to drive a car where you steer with foot pedals and push a big joystick back and forth to accelerate and brake. But you can't just learn the "good" new things, because the little things that are mostly the same, but slightly different will break you if you get them wrong. So you grind on, learning thing after thing with only a few of these "new" ideas providing any major benefit. That can be depressing over time, and it's important to recognize that not all learning is deep and transformative learning. OOP, FP, iterators and generators, these kinds of things matter greatly. But those are the exceptions. Most of the time, it's the difference between `a..b` and `a...b` in Ruby, or the umptillion ways to set `this` in JavaScript. EDIT: p.s. Truth be told... You may have a greater tolerance for this when you're young, but you aren't learning anything new when you're learning a new way to express the same old ideas. If anything, not recognizing that this is "junk" learning might be holding you back from investing in learning something new that will help propel you forward for the rest of your life.
OTOH, no one ever got fired for sticking with Windows Server and .NET.
I think there is a BASIC misunderstanding here. I think one is not plaid to innovate code. One is plaid to bring creative Solutions in whatever language one is using. Does an innovative Jsf application whorth less them a nodejs one? I don't think so. I think one should be able to select the area Needed to stay on the average. So if the market shift on client side select a stack you can work with. It should be sufficient because the important part are the applications you are able to assemble with it. There is no need to know and test everything. On the other hand if everything seems unuseful and the real problem is the motivation probably the best move is shift on the manager path. Honestly I prefer ways too much managers that knows what they are talking about, but, the true is there are plenty of managers that don't know or care about it. So you might find a place there.
All too often, conversations about new projects sound like this: &gt; "Hello, you're a carpenter? Great! We need some work done on our house. How are you with Brown? It's the hot color and we definitely want to work with someone that has Brown experience."
What kills me is that I can't get more than 10-15 minutes in a row of uninterrupted thought at home. When I was in my 20's I'd have the nights I didn't go out to screw around on the computer while I half-watched a crappy movie or just listened to music. Now in my 40's and married with kids, someone always wants to interrupt me :) I have realized why all of those old dudes show up to work at 7am. That time before everyone else gets to work is the only peace they get. 
If the author had these feelings about his entire life rather than just his programming work, I would agree. However, he seems to be reallocating his passion/interest/motivation for work towards other endeavours (family, hobbies, ect.) rather than suffering from a general net loss of passion/interest/motivation.
family core or hardcore, become a manager or start writing C# and .NET code
No I associate that stack with the stagnation of legacy enterprise code, a perfect environment for aging developers who fret new innovative technologies that are not subject to vendor lock-in.
Good catch, but of course it has nothing to do with Backbone per-se as you've discovered. Read the code for the extend function! What you pass there extends the _prototype_ of your base object.
\#3 -&gt; Memory Leak Example 2: Circular references It isn't true, modern JS GCs can collect objects with circular references or even objects in closure scope. 
On c# changes, I have witnessed devs who were solid with c# 2.0 be completely lost with linq, lambdas, var, iterators, async/await, dynamic, etc, etc, etc. Since they are newer, they are "impure" and to be avoided. Foundations of The Expert Beginner: http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner
This is actually really cool! Just got it set up on my Tumblr page. I also added a `&lt;noscript&gt;` that contains the `&lt;img&gt;` with its src attribute intact so that the gifs still work for anyone without JavaScript enabled.
Item #8 correctly describes' JS behaviour, but the explanation does not sit right with me. It's not how a variable is defined that determines whether `this` is bound to a receiver, it's the way in which the function is invoked, modulo `.bind`, `.call`, and `.apply`.
Would you agree that the general use case is using C# along with .NET and Visual Studio?
I agree that it's used with .NET - but Microsoft has open sourced at least most of the .NET stack, including the compiler. I don't know what parts are not open sourced. There are alternatives to the Visual Studio IDE.
This is exactly why I've never been tempted to learn, say, Java [again]. What's the point? It's c# with some stuff added and some stuff missing. If I'm going to invest time in a "new language", it better offer something, well, new. That said, being paid well to write what you know tends to crowd new things. The opportunity cost of learning a different programming paradigm becomes hefty as you become more valuable in Blub.
I can totally appreciate the author's perspective (I court the same ideas, myself), but my knee-jerk response is, "Well, what do you expect? You work in the technology industry as a software engineer. Change is the only constant." I'm a 30-year-old UI engineer without the responsibility of supporting so much as a gold fish and have often marveled at the veritable shitload of new things to learn on any given topic just within the realm of front-end development. This is both at once a blessing and a curse. That there is so much to explore and to learn is highly appealing, but it's also a bit of a hassle; when there are several new frameworks (e.g., Backbone, Ember, Angular, Knockout, etc.) that each sort of addresses the same problem in its own distinct way, I become a little irritated, because my feeling is that the expectation is that I have years of experience in each, the underlying concept (i.e., MV*) be damned. (I have chosen to just learn Angular and to call it a day. Could this be a mistake? Should I at least learn Backbone as well?) This is not an altogether unreasonable expectation, since each framework is idiosyncratic enough to warrant its own set of best practices (basically, its own idiomatic way of accomplishing tasks). I have also been learning Ruby on Rails, which, it would seem, is sufficient for much of what one might hope to accomplish online, yet the expectation now is that I also be adept with Node.js. That's fine. My experience in learning and using Node has been fun, but, to be sure, learning Node is its own rabbit hole--similar to (albeit separate from) learning Rails. (Yes, I realize that Rails and Node don't warrant direct comparison as they are not directly comparable.) All of this learning and practice requires time. I suppose this is to be expected and no different from any other area of life. If you aren't growing, then you're either maintaining your current station or regressing. If the rest of the world continues to grow and evolve without you, then you are stagnating. No surprise there. For all that, I've simply come to expect that the job of a software engineer is to, apart from shipping a product by deadline, always stay apprised as to the best way to do so, whether it be the newest, most bleeding-edge way or not. I think it simply comes with the territory, regardless of what priority changes might be occurring in one's life. I've come to adopt the view of software engineering as being comparable to a medical practice. Doctors are always spending hours outside work trying to stay abreast the latest medical advancements, because the field is ever evolving. Likewise, I think that, apart from however many hours a developer spends each week working for a client (or even for oneself), they need to also spend several hours studying and practicing new software-engineering-related things as well as brushing up on the basics. 
I agree with your sentiment but it's hard to ignore the rate of change on the front end relative to that of the backend. This is technology after all, if you don't want to deal with change then you're in the wrong industry. But if you want to mitigate it as much as possible, then the backend might be more friendly. And by "you" I'm speaking very generally.
Can't see a JSON utility without plugging [jq](https://stedolan.github.io/jq/). You'll never use anything else again.
Seems to me that much of this is sugar that can be easily translated to es5 by a compiler, similar to what CoffeeScript does, for legacy support. The app would have to pull down the correct version for the browser of course. 
Still trying to understand why one needs an interface to describe a class. Can't the class definition simply be the source of truth in that if you try to access or set methods that exist/don't exist, you get proper warnings? An interface seems like duplicative work...Am I missing something?
I only do node.js occasionally but it sure seems like there hasn't been much movement on the number of ES6 features in node-harmony for a long time. Sure seems like at the very least the Math function library should be something someone could bang out in a week. 
Free software has a clear definition by the Free Software Foundation. As far as I know, the .NET foundation complies with that definition. &gt;I have contributed or at least tried to contribute to some M$ projects on github only to be asked to sign waivers. That doesn't mean it's not free. In fact, it's standard practise in many projects, including Google's free/open source software projects. The reasoning is that without copyright assignment it's impossible to change the copyright at a later time. There's likely some additional legal reasons for it. Node.js had that waiver too for a long time, but recently removed it to decrease bureaucracy.
I dislike CoffeeScript, and now it's all up in my grille. Get off my lawn!
https://www.npmjs.org/package/unistroke works like https://depts.washington.edu/aimgroup/proj/dollar/index.html
yup!
Software development is evolving. It's breaching the line of "profession" finally. This is a good thing. You can't keep up on everything, and that's okay. Software development is becoming more specialized. A civil engineer can't draw blueprints, and manage the contractors, and pour the concrete, and manage funds, and so on. As a software engineer's responsibilities grow, we need to realize what we can and can't do, not because of skill or a lack thereof, but what's humanly possible. We can't manage build systems, and infrastructure, and design architecture, and write all the code, and do all the testing, and so on. Eventually, employers will realize this. Some already do. So what can we do? Focus on what we enjoy. Go deeper. Find an employer who wants your skill set. Demand higher pay. Be better than you were in your previous days, weeks, months, and years. 
I'm sorry but some random foundation doesn't get to define words. 
&gt; If there are restrictions on where you can use the arrow expressions, I'm not aware of them Arrow functions are bounded, so: var squared = n =&gt; n * n is equivalent to: var squared = function(n){return n * n}.bind(this) ~~You can't use them in an object literal in this form:~~ You may be able to use them in object literals, but since `this` is bound, it won't refer to the receiver object when you invoke the method with dot notation. var obj = {squared: n =&gt; n * n} // nop 
Well, the founder of the Free Software Foundation came up with the term 'free software'.
In this case, there is no class. They are using TS to describe the interface provided by some built-in stuff. It's kinda like using IDL for describing how some DOM API works. Take a look at the "DOM Interface" box: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element Anyhow, you'd probably like the idea of Dart's implicit interfaces. Any class is automatically also an interface which can be implemented. This way you don't have to (preemptively) write boilerplate code you usually see in languages like Java. ES6 doesn't seem to have interfaces or an `implements` keyword. Well, "interface" and "implements" are reserved as potential future keywords, but they are currently unused and there doesn't seem to be any plans to change that.
I don't disagree with your general point regarding software as a profession, but one of the things I really _like_ about programming with Javascript is that I'm working with build systems, infrastructure, architecture, and testing all at once. "Full stack engineer" is an actual job title (even if it is hard to fill), and that's also a good thing. We can't keep up on everything, but we have the opportunity to at least _skim_ everything. 
I agree, I don't think you should have to spend your free-time sharpening the knives, that should be part of the job. If you get inspired to do something in your spare time, great, but it shouldn't be considered the norm.
And RMS does? "*Free*" has a set of meanings, as does "*software*". Using them together isn't limited to some subset of the Cartesian product of those meanings because RMS said so. 
Removing the plugin from jQuery won't automatically update the DOM, you have to manually tear-down everything that it's done (like the added HTML/CSS for each image). Try this, though it's a quick hack and I'm not sure if it'll have any side-effects: jQuery.fn.stiOff = function() { return jQuery('.sti-share-box', this).remove().end(); }; Then to use: $('.widget img').stiOff();
Traceur, or even better, sweet.js
Yes, there is a cleaner way to do it. function slowDelete (nodes) { nodes.shift().children[2].children[0].click(); // WTF! if (nodes.length &gt; 0) setTimeout(slowDelete, 1000, nodes); //setTimeout(function (){ slowDelete(nodes); }, 1000); // If you care about IE... } slowDelete($('.del-button').toArray()); But, really, pick up a book or something...
FYI if this was your verbatim code... None of the more nasty answers were correct. Arr truly is undefined in the second code block because you aren't prefixing it with 'this' in the process method. It is true that you shouldn't need to call bind, however, and you should look more deeply into the details of bind, call and apply but it doesn't have to be said like a complete douche bag either. We were all learning once and hopefully still are. I'm sure ive recently asked quite a few 'stupid' questions about Haskell I am sure :) 
Not sure if this is a bug with Firefox's implementation but it looks like you can define the squared function in an object literal like that: http://jsfiddle.net/GzYJ6/ (*Note: Ran in Firefox v30.0, not sure of other browsers supporting ecmascript 6) The JSFiddle editor starts acting up after I wrote out the IIFE Arrow Block. When I made a new line it started it indented which normally means there's some syntax issue. JSHint throws a TypeError. TidyUp changes "`=&gt;`" to "`= &gt;`". Probably just JSFiddle. So now I'm not sure what to trust or believe.
In my experience, old programmers are either total frauds or complete badasses. Rookies are always pretty much rookies. They all make the same mistakes and have no respect for our field's history.
Well you don't have to be a dick sir/madam Javascript genius, Rockstar, ninja, 'code poet'. Your example also is not equivalent. You've, 'recomposed' (that's the antithesis of 'decompose' I just made it up in the context of programming I think) the 'next' method which means that logic cannot be reused and added your new function to the window object when clearly he wanted a reusable function object with multiple methods bound to the prototype. Are you no longer learning new things? If not, do you automatically know everything about a new language when you begin learning it? We don't need this sort of shit. *It* is the antithesis of what the Web is about. Finally, what version of IE? Lol. 
What the fuck are you talking about? &gt; 2. 2. Is there a cleaner way to do this? And what exactly is more reusable than a fucking function? Edit: Also, "we" who?
youtube video is broken
I'm currently in web development. I work with C# and ASP.net + the build systems for those, as well as TypeScript, AngularJS, and SASS. I work with PHP, Python, CoffeeScript, JavaScript, you name it. I architect our solutions, I help guide UX, and make infrastructure decisions, and I stay abreast of many things to help guide the team. It's exhausting, and it's a lot to demand of a single human. Arguably, there are people better than you or me at any single one of these things, but at the moment it's enough just to be good at these things individually without being an expert in most. When this kind of development extends to wearables (Google Glass UX? Watches?), peer-hosted cloud computing (every person's brain is part of the cloud?), and so on, will we have to sacrifice expertise in our core functions to keep abreast of everything? Edited to add: Perhaps these will always be part of web development. Many trends will die off over time. A similar situation that we're all already comfortable with is the segregation between the folks developing chips, writing operating systems, and writing application software. We recognize that each of these are separate aspects of the profession that require much more detailed knowledge than the current profession we each work in individually. Maybe this is a problem that is (at the moment) unique to web development.
If TCO is actually happening in ES6, I'd be really happy.
You may want to consider allowing the "playing" of the gif's to be done on a per-element basis. This could be useful for "play-on-first-rollover" functionality, or even just having a "start" button for each image. Right now, it looks like your script is all-or-nothing. As a side-note, I'd highly recommend moving away from the pattern of using 1,2, and 3 letter variable names. While you may be familiar with your code, I'd like to be able to read through it and not have to go hunting for what isC, con, cls, c, and cc stand for :)
That's a good point. I'm curious if they're planning on writing it in such a way that you can force it to fallback to the old-school method with a config toggle.
You should try to learn new things at work. It sounds idealistic, but working somewhere progressive where they use and try new technologies is a great way to stay up-to-date. If you treat your job as a pay cheque then you are definitely going to fall behind. Also, writing code isn't the only way to satisfy your passion for web technologies. Throughout your years and career you have likely acquired precious experience that can benefit other teams and companies, and that might be a role you can transition into later in your career.
&gt; But I do wonder if basket.js could gzip the scripts before storage as well... Looks like someone is working on making gzipping possible in the browser https://github.com/beatgammit/gzip-js It does state that it's not 100% compliant with the standard yet, however.
You acting like a dick caused someone to comment on you being a dick. How is that illogical? 
The problem is that STI is a 3rd-party script, and I don't have access to the unminified source... so altering the original `$.fn.sti` would be risky in itself.
Why not just filter out functionality based on a toggled disabled class. By default the plugin events work fine, but then if you add a disabled class the event functionality ceases to function. $el.on("mouseover", function(evt) { // Reject. if ($(this).hasClass("disabled")) { return false; } // Otherwise continue... }); 
I'm always tempted to think that it's more important to shove your extra time into understanding how things work in the general instead of understanding each and every framework/library/new thing out there. It makes it easier to learn and harder to fall behind on new technology if you're ahead of the game from a theoretical perspective. It's impossible to learn every single new library that comes out, but it's not impossible to keep up with research in a single area of expertise, or even more simply, learn a variety of general purpose skills (computer architecture design, compiler design, parallelism &amp; concurrency practices, algorithm analysis, the list goes on...) and use them to drive your career.
Ok, well I did an entire comp sci degree, started a freelance business, and had a family to take care of. I think the problem is scheduling more than anything. You must schedule your learning, whether it's 1-2 weekends every 6 months, or whatever works, the first step is to not just do 30m when you can but actually schedule time to learn.
Generators in JavaScript. I hunted down the simplest tutorial I could find. :) http://youtu.be/OYdP1tQ9Rnw?t=9m32s
commenting only because I've been looking for such a thing too for a while and haven't found it...
I love jq.
well, do I have news for you. no one else has any leads either, so I think that means it'll be time to look into making it. would you be willing to help when I get it rolling?
sure, why not -- I write a lot of js for work, though I wouldn't consider myself particularly good at it, but if I can assist, sure! I have a few projects coming up that will need something like this...
Continuing to think about this, some basic requirements for me: * supports dragging and dropping on a target * supports sorting via drag/drop, snapping to spaces between elements * works in scrollable modal boxes like fancybox (so can't have position calculations tied totally to the window, has to be aware of a box that it's in and scroll the box if the element gets near the top/bottom/sides) * IE9+
Same here, and I don't think I can do it by myself. I'll post back when I get started.
[JSON Editor Online](http://jsoneditoronline.org/index.html) Is my tool of choice. It allows me to view &amp; edit JSON, useful for when I'm debugging the PUT/POST data, and I need to add sub items
One of the best devs I know is married, has 2 kids and rarely works more than 40 hours a week. People have bought into the fiction that you have to work yourself to death to be "good". Instead they should build on their experience and learn _what to learn_ instead of just learning as much as they can. 
Why are you writing JS with Eclipse? I don't use Eclipse but one thing you might consider is setting up [node.js](http://nodejs.org) and [Grunt](http://gruntjs.com) because then you could just setup a watch task with a [Closure SOY module](https://www.npmjs.org/package/grunt-closure-soy).
Yeah, I was just curious as to what was possible. I would never write code that I wanted to maintain like this. To me, the arrow syntax is best suited for passing an anonymous function to higher-order functions or any other situation where an adhoc function makes sense. I'll have to play around with this more.
is this the same thing? https://www.npmjs.org/package/JQ is there an alternative specifically for node? this one doesn't seem to have the same API
Nice!
cool
Browserify + npm, motherfucker. There, you happy now?
You should try yeoman. The angular generator helped me get a grasp of the framework. There is a generator for backbone and ember as well.
Setup a repo in github. I can lend a hand on doing hit detection for the droppable stuff :)
It's better. But doesn't address the extended caching available from google's CDN.
Of all the images you could use to illustrate this you had to use one of lone female walking at night?
Interesting, a little jerky on my older laptop though, wonder if it would work faster without repainting the whole image every move. In caveman days we would stash just the part of the screen(canvas) that we were about to change then restore it when we moved. Maybe using a layer would help? http://www.ibm.com/developerworks/library/wa-canvashtml5layering/ and you just clear and redraw the layer?
Thank you, still need to test it, but will probably use this polyfill. Simple and nice solution for a common problem when some code needs to be run both in browser and Node.js environment. A couple of notes/concerns: - By default whatever is exported via module.exports when executed in browser will be directly exported to the global scope. A workaround for this is to define additionally the namespace object where stuff should be exported, something like: module.exports.__namespace = myNamespace; module.exports = toBeExported; then in a browser environment toBeExported will be available as myNamespace.toBeExported - We also would like to try to play nicely with the AMD modules. No further thoughts on this yet, but it would be nice to be able to define a module that will be usable when either AMD modules are available or CommonJS modules or no modules. Currently we support only the CommonJS or no modules cases. When there is time I will maybe fork the code and try to address those.
I agree actually, I don't use the CDN. But I was pointing out that your solution doesn't solve the problem at hand, it solves a different problem.
I assume you want the current page to continue to exist? That you don't want to navigate away to the URL, you want it to load in the background? If the URL is in the [same origin](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) as the page, you could load it using XMLHttpRequest (aka Ajax). jQuery provides a convenient wrapper around XMLHttpRequest; if you don't care at all about the actual response, it could be as simple as `$.get('http://example.com/');` However, again, this only works for same-origin requests, assuming that the target site doesn't set any CORS headers. If you need to make a cross-origin request, you can load the URL in a hidden iframe. [Here's an example using jQuery](http://codepen.io/anon/pen/nCJdz). If you open up the browser's developer tools and look at the 'net' tab, you'll see www.google.com loaded when you click on the link. The same-origin policy technically still applies here, it's just that you can't access any of the content of the iframe from the main window since they have different origins.
So would it have been better if they used some other person? Why would that have been better? I think any person illustrates the effect well enough and I doubt that the OP used this particular picture *because* it had a female in it.
The problem I've been referring to throughout this thread has been dependency management. My solution addresses it handily, dear friend.
The URL exists in another domain on the Third Party server; so am I right in assuming that the only way to get around this in my case would be to use the IFRAME? Is there any other way I could make it work?
That's what you are talking about, but others are talking about how to make a single unified long term cacheable CDN. To fit that in with dependency management the tool would have to automatically pick the correct CDN and version. It's a different problem from what you solved.
Do you need to be able to detect the output of the call? Or just to make it?
I was actually a little taken aback but I quickly got over it
This book by mixu would satisfy the backend development part of what you are looking for: http://book.mixu.net/node/ First it goes through Javascript basics using node, and then goes through the key parts of the node standard libs. It also looks like he has begun work on a second book for front end development using single page apps, and he might release that soon! 
The problem isn't using a CDN or using jQuery. The problem is using a library that can change each time you reload the page. If you link to jQuery 1.9.0 then each time that resource is requested it will return the same library, when you link to jQuery-latest, who knows what it will return?
If you want to hide your API key then putting it in the front-end probably isn't an option. You may need to look at other solutions.
Just to make the call.
jq itself if just C, so any machine you run node on will also run it. I'm not sure there are any JavaScript bindings, but that would spurt of be reinventing the wheel when JS already has intrinsic support for JSON... 
Querying the page with Ajax or any other methods like including the url in a script or image tag will make the call. In the case of Ajax, it will throw an error in console(on Chrome at least) that cross domain requests are not allowed, but the request is still sent. You just cannot get the response. For example: var req = new XMLHttpRequest(); req.open("GET","your url here"); req.send();
You can also use an `&lt;img src="http://test.com/status.aspx=1028"&gt;`. The easiest way to send a request, if you don't care of the response.
The *only* way, really. No matter how you obfuscate it, once you start sending things to the browser they're out in the open, literally.
Hi, Thanks. It worked (though I had to delete this to get it to work.)
IFRAME is cool. You can set it to a size of 1x1 pixel, and invisible. And you don't have to hardcode it into every HTML page, you can actually generate and include it using Javascript, at runtime.
I have been following the developments of Meteor for the past year and am very impressed with all the enhancements. I have a tremendous respect for those that envisioned this framework. As most of my work is based on Windows environments, I look forward to the integrated Package Manager with Meteor. The current package manager is Meteorite which is not supported on Windows and although the 1.0 version also won't have official support, there will be very good unofficial support through the win.meteor.com project and according to the Meteor roadmap, post 1.0 will have full Windows support. I also believe that once there is a DDP for some common Enterprise databases such as MS SQL there will be a huge adoption for Meteor. I plan to dig hard into Meteor shortly after 1.0 or whenever there is good support available for Windows. My hope is to build specialized DDP server(s) within Node as reactive consumer of .NET MVC Web API, DSL models and to utilize Polymer as well as Routing/DI from AJS within Meteor. 
Does that help? If someone wanted to use the API and you're just passing it through, they now just hit your server instead of the actual service. Unless your server requires an API key... then you're back to square one. You can limit the exposed functionality or throttle the API that way, though. IIRC Google's API are locked down by referrer associated with the key. Is that not common for others?
for now.
Very cool, but I don't understand why you'd make the effort to produce something that works without javascript if you require javascript for it to work anyway.
It helps because the API key is now only in server-side code, not code they can download and browse for themselves. We're not assuming that the end-user needs direct access to that API, just that your website does. Some services may lock a key by IP address or hostname, but some may not do, and it's not impossible to spoof those values anyway in some cases.
Plus 22936 lines of Angular...
Uses "goto" to avoid a function call.
And a a sensational reddit title for only 27 characters!
Interesting idea, but after an hour's worth of reading, I found out its problem: it's not well supported by debuggers yet. You can't easily debug your code with it.
And still the benchmark don't include a measurement of the same logic but in a regular inline for-i loop.
Exactly. There's too much cargo culting around degrading "gracefully". Is it really graceful if your spreadsheet is no longer a spreadsheet? Maybe show the user a message that they've got js turned off and need to turn it on but trying to do something OK without js is dumb.
Well, I see the null system and type safe variables as features, and could see me liking the "conditionals don't evaluate expressions" system as well. Good write up though, I probably will never use swift (I don't do apple programming) but it was a nice overview of the language from a new (to me) perspective.
Mr Stan you are very knowledgeable.. but.. after all that trial and error, disappointment and tears, i can tell you one thing: Javascript SUCKS! 
Damn, that's a really detailed walkthrough. 
??? where is the link? articel? no? what? hamagad
&gt; Can not change type after variable assignment AKA "I don't like strict typing" &gt; Optional semicolons and parenthesis in conditional statement. &gt; Call me old school but I like to explicitly end my statements. This is also a topic of contention in the JavaScript community. The reason it's a topic of contention is because the automatic semicolon insertion in JavaScript is faulty. &gt; Optional Values This seems like a good thing. It's like a maybe monad. &gt; Why not do it as you would in JavaScript and assign a reference to a variable (or constant in this case)? Is this, like, a thing? I don't understand. Something like `var MyString = String; new MyString();`? I feel it would be strange to allow for variables to point to types and then initialize new variables with that type... perhaps if they were constants, but that feels like tougher logic to implement then a `typealias`.
30 lines of vanilla JS without angular: http://jsfiddle.net/ondras/hYfN3/
I've created a repo [here](https://github.com/seiyria/dropsort.js). Currently I only have the goals available, but feel free to discuss the goals (especially since you have requirements as well) - I am looking for feedback on that, especially in regards to using coffeescript. I'm currently developing in a plunk until I can get a basic drag working, then I'll start pushing changes to the repo.
I've created a repo [here](https://github.com/seiyria/dropsort.js). Currently I only have the goals available, but feel free to discuss the goals - I am looking for feedback on that, especially in regards to using coffeescript. I'm currently developing in a plunk until I can get a basic drag working, then I'll start pushing changes to the repo.
I think you're in the wrong subreddit for that claim
Not sure if I found a bug: Ticker for AAPL shows up to 600 before June 5th, and then dramatic drop back down to 100 (which seems more correct). Cool chart though :)
I disagree with the author about a few of his bad/superfluous points. * IMO, type safety is an advantage and the author fails to explain why he thinks it's "unnecessarily confining". Why not explicitly create another variable? When I write JS, I avoid type changes on variables because it's somewhat confusing and can introduce subtle bugs. * Conditional statements not evaluating expressions as booleans automatically is a great thing. The concepts of "truthy/falsy" is often not well understood. Tables like [this](http://zero.milosz.ca/) remind me why lack of type coercion is a good thing. * Assigning a type to a variable as opposed to typealias - ideally, variables should have one function so as to avoid confusion down the road. Marking something as being a typealias means you know exactly what it's used for, as opposed to a var whose purpose might not be immediately known. Further, the author fails to talk about his experience with JavaScript and why/how he thinks his particular use of JavaScript is better in his specific domain. Does he do mostly Angular, Node.js, jQuery or something else? Other than that, it's a pretty typical "I prefer these language features" piece with not a lot of substance.
It's faster because it doesn't conform to the spec.
Thanks! The reason the AAPL chart is skewed is because they did a stock split.
You clearly know a ton about ES6! so correct me if I'm wrong. Outside of the solutions you brought up, how about using proxies to catch the assignment with [] ? That'd probably work right?
Let me get this straight. Your method SQL.query returns false when? If there are no results? If there is an error? This example doesn't clearly illustrate why returning different types is a good thing - in fact I think it's the very definition of an antipattern.
it looked nice for testing sniper night vision, doesn't matter male or female, he/she won't die from firing anyway :)
yes using a layer would be better but it's just a demo concept &amp; drawing few elements on screen so i thought it's unnecessary to add additional complexity with layers
What part of it, exactly? I don't want to have jQuery as a dependency.
Previously: [fast.js - Faster reimplementations of native JavaScript functions](http://www.reddit.com/r/javascript/comments/28ynkw/fastjs_faster_reimplementations_of_native/)
Basically what everyone else said: - use API's on server only, not client - make a config.json to hold keys/values like this - put config.json in your .gitignore and a config.example.json with non-real values into git, that way your keys are only on your machine and if you lose your config file you can just copy the example and set it up again. BONUS POINTS: Pretty print error messages if someone tries to run the app with the example.json instead of filling it out.
You're absolutely right, you could implement a proxy over a vanilla object that behaved identically to an Array. In fact, proxies in part came about due to a desire to build all of this custom behavior defined in ECMAScript (and DOM) natively in JS. That said, it will be a long time before the performance of a proxy-implemented array-like approaches that of a native array, if it ever will (there is some disagreement about whether it's even possible but everyone agrees it's extremely hard to get there and may take years).
&gt; ...and could see me liking the "conditionals don't evaluate expressions" Absolutely...and actually, this is how I write my javascript now essentially. Inside of statements I always make sure I put an explicit comparison in there...I find it makes it much more clear what the intent was. I often find that '!someBoolean' is far less readable than 'someBoolean === false'.
Thanks for your insight! I'm not super familiar with AMD modules, but I threw together a [pull request](https://github.com/fraction/exports-polyfill/pull/1) for changing the namespace – great idea! Would you mind taking a look at it to make sure this resolves your concern? Thanks!
That was my first thought as well. Just like when Casey Liss announced that he'd written himself a node.js blog engine in under 500 LoC...then followed up with "if you don't count the few hundred thousand lines of Node+plugins that I'm using."
This would be done with an Optional type in swift.
I love the documentation. Don't see them like that very often.
How to write a blogpost: just compare new language X to Javascript and complain about the differences.
You can also move the 99 lines in an external file, and say that you did it in one line.
Then you should definitely look in to grunt. It has modules for everything, including LESS compilation.
Well, SQL.query would throw an error. false means no results. It was a simple example to point out where rows can be an array or a boolean. In answer to the question "I'm wondering: what case..." Maybe not a perfect example, but this sort of thing happens a lot.
My take is that swift is a really interesting new language based upon LLM and with many of the limitations of C and OBJ C made much nicer to express. It has types because C has types, etc. 
&gt; JS already has intrinsic support for JSON I'm using [JSONSelect](https://github.com/lloyd/JSONSelect) in one of my projects, since it exists and I need it, the need is there :) I hoped jq could replace that, but I can't find recently updated wrapper
I wouldn't really count that though. Angular is so prevalent that there's a damn good chance a browser will already have it. 
You said you didn't want jQuery**UI** as a dependency. Nothing was said of jQuery itself.
Protip: Prepare for seizure
Fyi, it has a warning on the page. You dont need to say this
You're right, I didn't. I should have been more explicit that I don't want any dependencies like jQuery or jQuery UI.
&gt; I often find that '!someBoolean' is far less readable than 'someBoolean === false'. I disagree. It's only less readable if the person reading it doesn't understand what makes a value truthy, which is a level of basic understanding that I personally expect a person reading the code to have. Meanwhile, your scenario would result in a false positive if the value is undefined, null or an empty string, which are in all likelihood equivalent conditions that would require much more expressive code to test for. You could simplify that by using a non-strict equal, but then the code looks ambiguous. The reader is left to guess if you meant the coercive behavior or not. There's no ambiguity in using a single or even double not operator, the intent is clear.
&gt; There's no such thing as classes in JS (yet) By what measure of feature are you defining this? Inheritance in JS works nearly the same as it does in other languages, the syntax for defining a class is just different. ES6 will provide a near syntactic equivalent, but it's just sugar for the same old prototypical inheritance.
&gt; It's only less readable if the person reading it doesn't understand what makes a value truthy, which is a level of basic understanding that I personally expect a person reading the code to have. I disagree...visually it is less readable...at a glance/skim I can much more easily pick out a strict comparison (for example) vs a random bang (!) to indicate falsyness (especially if it is butted up against a variable or near some other non-alpha character like a parens). For me (as far as 'readable' is concerned), it isn't about the understanding of truthy/falsey so much as being more *easily* readable/skimmable and taking less effort on my part. &gt; The reader is left to guess if you meant the coercive behavior or not Not providing the strict equality check is another form of type coercion...and is exactly the type of ambiguity I try to avoid in my code. It may require more code to accept other inputs as truthy/falsey...but at least at that point you are forced to trace out (and understand) the code path and are less likely to introduce bugs than with that not-explicitly-checked-for value. Most of the time you would be fine...but occasionally (ok maybe rarely) you will have problems. I like to avoid rare problems as they are typically a pain for me to figure out.
Aha, as I was typing that out I realised what you mean. As far as I know jq is the only implementation of 'the jq filter language', but I don't imagine it being too difficult to write an interface for it to abstract away from calling the executable, given that you just need to pipe in a string and give it your filter as an argument.
I guess we agree to disagree then. I've never had a problem of failing to read a bang against an isolated identifier. That sounds like the sort of thing that would only happen if you're using a non-monospace font with weird kerning. &gt; Not providing the strict equality check is another form of type coercion Of course it is, but the intent of the coercion is much clearer than with a loose equals. There can be no mistaking if the author meant the coercion, compared to simply leaving off an extra equal sign on accident. This is why linters default to pointing out loose equality, but have no problems with truthy coercion. Can you truly say that this if (!foo) { is harder to read than this? if (foo !== false &amp;&amp; foo !== 0 &amp;&amp; foo !== '' &amp;&amp; foo !== undefined &amp;&amp; foo !== null) {
&gt; I guess we agree to disagree then. I've never had a problem of failing to read a bang against an isolated identifier. That sounds like the sort of thing that would only happen if you're using a non-monospace font with weird kerning. It's not that it is *hard* or that I have had difficulty...it's that I find I can read over it more quickly and integrate that statement into my thoughts more easily if things are spelled out more explicitly. My brain just has to fill in less gaps, think a tiny little bit less. &gt; is harder to read than this? Well of course not...but I have never had a statement checking for truthyness that was near that complex...95% of the time I only have to do a single check, the other 5% it is for one more.
&gt; the author fails to explain why he thinks it's "unnecessarily confining". Why not explicitly create another variable? That works when you're talking about a local variable, but how about when you're processing the form input from a POST action that's been stored into dictionary? Because it's HTTP, the form has no typing info and everything is a string. You will likely want to parse those strings into the types you actually want. Dynamic typing allows you to just overwrite the strings with their parsed values. Strict typing would require completely rebuilding the dictionary. Now, yes, strict typed languages have system to handle these kinds of things, but the point is that a dynamic typed language doesn't need them.
no matter what concepts or patterns you are using if your documentation and examples are neither complete nor useful your library won't be used by anyone!
You have user accounts to limit access to your server. 
Sure, in JavaScript the loose comparison means that test is equivalent - and yes it's a great space saver when that's the exact logic you want. But faced with the second comparison I would say "why the hell am I testing for all these things and treating them all equivalent?". It's probably just a matter of personal style, but if someone is passing 0, '', undefined or null for a parameter that I'm expecting to be a true/false value I like to catch it earlier in the process - not necessarily through static typing, but just by the fact that the code will stop sort of working through equivalent values.
Swift actually does support semi-colons at the end of lines - it's just not idiomatic.
I've seen this shit all over the place and it drives me up the freaking wall! assuming some bullshit synchronous method: /** * Some craptastic query * * @param {string} query * @return {array,boolean,whothefuckknows!} **/ function OMGRecordset(query) { var result = SomeOtherMethod(query); return result.length &gt; 0 ? result : false; } /u/ModusSchwartz if you find yourself using a method like this or if a library you've implemented returns false as the result of a query: *stop using that library* there's more shit wrong with it than you probably are aware. The problem with loose typing is that it leads people down this exact path. If your method returns an array or an object in one instance it should return an array or an object in another. There are exceptions but they should be fucking rare! &gt; *But: what about an error?* No fuckin way! It's this same shit all over again. Oh some error was trapped, lets not pass it along or, I don't know throw an actual *Error* or anything, let's return false! (Or my personal favorite: null. When all else fails newbie JS developer, return *null*. It's the new *false*!) 
look at github, choose the most starred project
&gt; This may be more convenient but after the failed parse the original value is now gone forever and the error is unrecoverable. Unless you made that part of your parsing... If the value can't be parsed, you leave it as it was originally provided. Then, when you go to use the value, you can test if it's still a string to identify if it isn't in the correct format.
&gt;Inheritance in JS works nearly the same as it does in other languages, the syntax for defining a class is just different. Erm, no? Javascript's inheritance model is one of its most-commonly-documented differences from other languages. It's [prototypal inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain), *not* class-based. You don't define a class, the instantiate it. You define an object that is used as the prototype. It just so happens that because of how flexible stuff is in Javascript, even functions can have a prototype -- and can *be* prototypes. So you can create a function that has specific properties, then use that function as the prototype for other objects. It's not the same as having a base class whose properties are copied by other objects; it's more like having a reference to some other instance object somewhere else as a "fallback".
Learn several, and pick at least one or two to experiment with to get a deep understanding. Each of the more popular frameworks have different strengths and weaknesses, so where one will excel for one application, a different framework might be more suitable for a different application. A few thoughts: Don't just learn the framework- learn the concepts the framework is built around. Once you get that, you'll be able to implement the ideas on your own in cases where the framework might be overkill or where you want bits and pieces from several. Angular is backed by Google, doesn't enforce a lot of architectural decisions on you, and as such has a wide range of applications and gives you a lot of rope to trip yourself up with, not to mention a lot of concepts that aren't commonly found in other frameworks- big learning curve. It's driven by the content found in the DOM, so it's easier to work with than some of the others in multi-page applications, especially CMS backed websites where the server can't do a lot to inform the JS code about what needs to run. Keep in mind that future versions of Angular may not have the browser support you (or your clients) need. Ember is a much more straightforward framework, in that it enforces a lot of (familiar) architectural opinions on you- great for single page applications, straightforward learning curve, but it's a HUGE library with lots of components to learn compared to others. It's got a lot of traction, but might be overkill for a lot of applications, and I'm not sure I'd use it for anything other than a single page application. React doesn't come with nearly as much as the others, but it's useful to understand, and I use a lot of the principles of React in my Angular and other applications (some people even use React views in Angular applications where the high level of performance is necessary). Backbone is great for tiny applications, but the cyclic reference between models and the collection that they're in irks me to no end. It'll also have pretty terrible performance if you have TONS of data in memory, as pretty much everything triggers events. You'll want to grab Marionette or similar to provide the much-needed support for composing views together. Backbone was a great inspiration for me once, but I've pretty much switched over to using one of the above frameworks for larger applications and hand-rolling my own for the smaller ones instead. There are a few others, but I don't have enough experience with them to give an informative comparison. 
I'm a professional Angular.js developer. I get recruiters seeking me out specifically because angular is listed on my resume. I'm on my second angular job, despite only learning the tool no more than nine months ago. Here's my honest opinion. It's a roll of dice. I have no idea which framework will 'win out' in the end. Angular is easy to pick up, opinionated, and extremely complex to master. Backbone is more lenient and versatile, but doesn't give you much at first. Haven't played with ember, react. Meteor looks awesome but I hope it's not just a fad. Thing is, this is the first generation of front end frameworks. There are still a lot of conventions to be made, kinks to be worked out, all around I feel like there's no guarantee that one or another will be better than another. [mtbinkdotcom](http://www.reddit.com/user/mtbinkdotcom) probably has it right in that a statistical measure is probably the best indicator of return.
&gt; For example, if you know Smalltalk and you learn JavaScript, most of what you learn is just different and finicky ways of expressing the same damn ideas. But you have to learn them, because they work in slightly different ways. A few things, like prototypical inheritance and the lack of encapsulation, are major differences. But mostly, it's like learning to drive a car where you steer with foot pedals and push a big joystick back and forth to accelerate and brake. There's not much conceptual utility in learning JavaScript, in your example, but it certainly enables you to do a bunch of stuff that Smalltalk will not. That seems significant.
&gt; It's prototypal inheritance, not class-based Which doesn't make a lick of difference for how you use them. You're still defining distinct object structures which extend from one another to create singular inheritance dependency chains. You still initialize them via the `new` operator, you still provide arguments to a constructor, and the result you get back is interacted with in the same way. Libraries that add "classical inheritance" to JS are just providing a convenience wrapper to functionality that's already in JS and is easy to implement yourself. The same is true when you create a class in ES6, you're still creating a constructor function with a prototype that descends from another prototype. It's just happening internally instead of explicitly. The only practical difference is that most languages which implement classes don't let you alter the class from outside the definition, which JS allows. Internally there's the difference in how the object's properties are accessed, but that makes no difference to the way you interact with the object. When you press down on the gas petal, it doesn't matter if it's a diesel engine, unleaded, or electric, the car will drive the same either way.
Angular if you want something big and flashy for your resume, Ember if you just want to have fun with smaller projects 
I agree about the strict typing, one should not be allowed to mess with a variable type once it's cast. It makes debugging better, it makes for more robust and structured code.
Could you elaborate on this? This sounds backwards to me.
Redis support: https://groups.google.com/forum/#!topic/meteor-core/Jl5Jt739wdA
Your thoughts on backbone as far as performance are...Basically the opposite experience of every one I know (provided you understand the common ways one can create memory leaks in backbone). In fact, I find backbone collections actually *help* with manual memory management when using object pools in contexts where I truly need that sort of performance/control. Otherwise, a very well reasoned response. Do you really think angular is low on opinion? I've found angular and ember to be the biggest culprits there and react to be very low (and backbone has basically none). 
I'd also point out that react is the closest in terms of 'paradigm' to Web components and what polymer is doing. That is pretty clearly the way things are headed in my opinion but I agree, it's unlikely any of these tools will be all a real standard, orange even necessary at that point. The whole thing is pretty much going to get flipped on its head again. Of course, these tools are extremely valuable now and these things are what inform the future specs as well. 
Mobile comment bookmark
I'm a big fan of Ember. There's a lot of imposed structure, which, if you're coming from a loose JS background, can be good for learning. Just in the process of learning Ember, I feel like I've become a better software engineer in general. Like free master classes from Yehuda Katz et al. I think a lot of the value of Ember is in what it makes difficult, rather than just what it makes easy. It has a lot of design decisions about what has access to what, to keep you from shooting yourself in the foot with arbitrary and overly tight coupling. These are things you'll have to watch out for on your own in something like Backbone or Angular, or have your team watch out for you. So your base knowledge of the framework has to be supplemented with best practices, which everyone will have their own opinions on. With Ember, the best practices are more tightly integrated into the framework. This is a value judgement. Some people value more freedom to do things their own way. Personally, I prefer to have decisions that aren't vital to my application's domain out of the way. I don't like bikeshedding. Ember's approach is to make as many decisions for you as are widely applicable by default, and to provide escape valves for things you'll need to override. Another one of the big benefits to Ember is that, because it's so conventional, it's pretty simple to jump from one project to another, with minimal time getting your bearings. 
&gt;Can not change type after variable assignment Flip-flopping types is horrible for performance and it also makes the code much harder to understand. You really shouldn't be doing this anyways. In a code review, stuff like this should get criticized. &gt;Conditional Statements do not evaluate expressions Also not really a bad thing. Sure, we all like the terseness, but what does "if (x)" actually check? Well, that's the problem. That line doesn't tell you that. It's not explicit enough. &gt;Optional semicolons It's not like JS' ASI. Omitting semicolons in JS is a controversial topic, because semicolons aren't actually optional. There are only cases where they can be omitted. In Swift, you only need semicolons to separate multiple statements in a single line. &gt;Optional Values &gt;I do not like the fact that you cannot assign nil (null) to a non-optional value Yes, you can't assign *null* to a *non-null* variable. That's the point.
I think you ignored the original question and used it as a jumping-off point for a canned rant. The OP asked if it's possible to alias classes in JS, like so: var MyString = String; var test = new MyString(); The answer is: yes, because {constructors, methods, callbacks, etc.} are all just functions in JavaScript, you can alias a constructor just as easily as you can a callback.
It's also on github: https://github.com/josdejong/jsoneditor/ I haven't done it, but I've heard of others embedding it into their own apps.
Have to disagree on this one. Ember was made for "ambitious" app. If you just want a simple web-app then Ember is an overkill. Angular is fit all pseudo-framework, meaning, you make your own rules on how things flow which is less opinionated than Ember. Ember has quite a learning curve than Angular for beginners but once you know the basics then it's the same process for all apps meanwhile it's quite the opposite for Angular. Angular is something that you can pick up and start writing "Hello World" with very less knowledge than Ember but you're on your own as far as the architectural design of your app. 
I'm impressed... 
The 295 byte golfed version is still functional enough to be considered a spreadsheet: https://cdn.rawgit.com/aemkei/aemkei.github.io/master/sheet/index.html
Just because there are many ways to do one thing doesn't mean something isn't opinionated. (maybe that's my opinion ;)
I see more Angular and Backbone jobs than anything else. Occasionally a Knockout or Ember job. Nothing for React but it has me very curious. Meteor seems to be gaining a lot of traction too. I know a few people who are using that for their current, far-off professional project. I think the most important thing is to learn a little about all of them and then go deep on one (it doesn't really matter). Make sure you watch the way the wind blows as these things can change quickly.
Awesome job. I especially liked: var letter = String.fromCharCode("A".charCodeAt(0)+j-1);
&lt;sarcasm&gt; yeah, you should require .js for all form submissions, since there's no underlying protocol/method to handle a form post. JS for all! &lt;/sarcasm&gt;
Not my work just to be clear. It was making its way around HN a few months back in the form of this fiddle. Original creator's credits are included.
Maybe if we push hard enough we can get some sort of spec going for bytecode in the browser, and we won't have to fight over what language is best for it. Seems more achievable than ES6 ever finalizing.
thanks. thats +1, still a few more
*I don't think I like Dart.* I guess the reason is, I already love JavaScript. I've never been sold on why Dart is a good idea. I only hear half-confident mutterings like "it's more like Java", and "it's has classes, thus making it.. more like Java". At least in the meantime, until native support, the concept of writing JavaScript in Dart, and having to compile it back to JavaScript, seems literally insane to me -- it just seems to scream "this language is literally a reskinned JavaScript with no practical differences, however the syntax certainly gives some higher-ups at Google web 2.0 hard-ons!" Apparently, Dart (these days, at least) doesn't even perform significantly better.
Well of course, and that's why you do it. Just like if your old car with a steering wheel runs fossil fuels, and the new one with pedals is electric, so you learn how to steer all over again. But there's a big difference between learning the browser DOM (new stuff) and relearning how to write a class (same-old, same-old). So you do it. But it's depressing.
asm.js? Runs in anything and its faster than javascript. Emscripten has a very lovely compiler that pulls both C/C++ (and I believe obj-c) into a subset of JS that runs, mind blowingly fast.
I'm also not so enthused with Dart, mostly due to the current status of the Dart runtime. Having to choose between Dartium (potential lock-in) and Dart2js (which is still somewhat inefficient and in its infancy) is a significant sell-off. Don't want to completely discount dart just yet though, as whether or not the language will change in light of es6 being standardised remains to be seen. Hoping for less Java influence and more baked in functional support. :)
I think Vue.js is on the same conceptual level as React. Which one do you think is better?
I have seen code that looks that looks like this: if (!!!user_status) ...
If anything, I'm optimistic for Ember because Yehuda has done a ton of great things for the Ruby community. Admittedly I don't know a ton about the maintainers of some of the over frameworks, but Yehuda's stuff makes my life easier in Ruby land on a daily basis. Ember gets a vote of confidence from me on that front. 
Yep, only way. If you want a laugh, start searching for tokens like `API_SECRET` on GitHub - it's mind-boggling how often API keys are left in the open. 
Still javascript.
The script you're linking to is just [Modernizr](http://modernizr.com). I see a handful of other scripts as well that could be causing your issue. It doesn't matter if they're in the head or not, they'll still effect the page. What browser are you having trouble selecting text in? I'm able to normally in Chrome.
Learn node, use npm. - [browserify handbook](https://github.com/substack/browserify-handbook) Simple npm modules can be composed to replace the entire functionality of any framework, client-side. Learning node also gives you the advantage of customizing build systems. [Simplicity Matters by Rich Hickey](https://www.youtube.com/watch?v=rI8tNMsozo0) 
Why would you set the collection on the model? In my experience we set the model on the collection and off we go. I'll play around with single model multiple collections today to see what affect that has though. it would be interesting to see.
The type system is where the magic happens. It allows for some pretty powerful static analysis. It is so about catching errors early.
Hey kenman, im working on a github pages branch now. Hopefully in the next day or few I will have that up and running so there will be a good demo site up and running!
If that is what you are looking for then TypeScript is probably a better option. 
If Google put it in Chrome, it will make no difference with `&lt;script langauge="vbscript"&gt;`
how about something like mootools?
Maybe it is better to improve the existing standards than invent new ones in the same area. TypeScript does not try to substitute JavaScript and looks much nicer as a target to which JavaScript can evolve. Google may need Dart and actively promotes it everywhere because it gives more control over the development platform and ability for more extensive speed optimizations, but not sure that as developers we really get that many benefits. Although I certainly welcome Dart as a language that can speed up the evolution of JavaScript and influence its further development
What's wrong with JavaScript? For most applications JavaScript is already fast enough and bottlenecks are elsewhere. But if for some reason you still need faster low-level subset, just go with asm.js
Declare a byte code for JavaScript since it already has sophisticated support in all browsers. Fallback would be to load the cross compiled js version of the byte code. From that point on, development to the standard is focused on the byte code and VM instead of js and language features. Edit: Eventually fallback could be to load a js library that expands the byte code to plain js and nobody need to maintain multiple targets. 
Isn't this better solved with sweet.js? You get to keep JSX syntax intact that way.
I never tire of brand new programming languages with which to do the same tired shit all over again.
`language` != `langauge`
Very interesting read. Thank you, stranger!
just made a example its more then that guess i need to hammer out the alghorithm
&gt; Dart is purely OO, with mixins, named parameters, and only public or library-private, so Java it is not. You completely missed the point. That is far too close to Java as far as most JS developers are concerned, which is why we will never touch it regardless of how superior it is or how sloppy JS is. Bottom line: I don't want to be forced to dick around with OOP.
The problem with Dart is that it's so boring. If/when JavaScript will be replaced, I personally hope that's it's heavily inspired by functional programming languages. Maybe something like ClojureScript.
Yes, there is some syntactic sugar and nice things but we should not miss the big picture behind it. Otherwise it is a bit like selling an old house because it is not of the right trendy color, instead of repainting it. How it looks on the outside is important, but what's inside is still worth our attention. &gt;It has pretty easy to use streams and futures instead of messy callbacks. Promises were included into ECMAScript 6 draft, you may want to read up on those. Also there is RX.js &gt; Block level lexical scoping. &gt; It has standardized modules, classes, and collections Again in ECMAScript 6 &gt; It has tree shaking to only include the actual functions and classes that are used instead of pulling in the entire library. Imports etc. And if you are really eager to use this today, just use something like Traceur https://github.com/google/traceur-compiler/wiki/GettingStarted
Okay,I just wanted to know your motivation behind wanting to learn a framework before giving suggestions. I think that there are a lot of frameworks out there. You would benefit from looking at ToDoMVC.com and finding a framework which fits your coding style and has patterns to which it follows. Don't jump on any bandwagons if you just want to learn. Its good to take a look at the frameworks and learn how they are similar and how they are different and learn from all of them!
Solid advice indeed, but a note to say that sometimes ill-employed "Agile" projects can also be vile things :D 
Javascript the language has a lot of flaws. Very loose and inconsistent type system. No decent module system. Unintuitive scoping rules. And so on and so on. Javascript the implementation is better, but you can't run away from the baggage of Javascript. Ideally, we'd have a bytecode system in the browser that any language can compile to. Asm.js is a good start, but its still a hacky workaround. We shouldn't have to compile C++ down to JS down to bytecode, we should be able to compile C++ -&gt; bytecode.
Quite true. It is basically GWT reborn, the same goals, the same target audience
The problem with sweetjs is that you can't use syntax extensions its not capable of: there's stuff in traceur that there aren't sweetjs macros for, and so you end up in a weird place where traceur can't parse the stuff the sweet processes and sweet can't parse the stuff that traceur does, and you're back to the beginning. There's also an argument to be made about the fact that quasi literals are part of the harmony spec, and not an extension that requires a specific vendor's tool. But yeah, for production code, you're probably right, because the extensions in traceur that require this aren't really ready for that anyway. 
Take a look at ECMAScript 6 draft, most of those issues are fixed. Those flaws are repairable and not as bad if you are a good JavaScript developer and know how to avoid them. JavaScript still has a lot to offer, even in its present form. Otherwise, why GWT which used Java and had type system, decent module system, scoping rules and so on and so on is not yet the standard with which we build Web applications and is pretty much forgotten.
Oops, I had commented it out last night before I went to bed and forgot to re-enable it. That's definitely the script that prevents text selection, and I've now taken the comment out so everything "works" (minus the text select).
I don't think the JavaScript community hates/avoids OOP as much as you think it does. OOP is used in pretty much every popular JS library. Although, If you wanted to state that JS has nicer *functional* features, that might be a valid claim.
Except TypeScript doesn't provide runtime type checking.
jsontwikkeling said a lot of the stuff I wanted to say already. ES6 fills in a lot of the holes in JS. Some of the remaining problems on your list like the dodgy type coercions can be mitigated and avoided with better tools support like IDEs and linters. If you want to go the static typing and better static analysis route, then TypeScript is a better candidate. It just aims to add optional typing to JS and that is all. It also aims to track ES6 and ES7 etc features and remain JS+typing. 
It aims for static compile time checking. If your program is fully typed then you don't need runtime checking. If you need to mix and match TypeScript code with normal JS code, then runtime checking may be a useful feature and is something which could be added to the compiler I guess. (i.e. a type checked dev build mode.) 
Assuming a mix of ES6 and TypeScript solves most of these problems in JavaScript, the proper tooling available in Dart, with the first-party IDE, is quite appealing.
OOP is used in pretty much every MVC framework, but all other popular JS apps limit their use of OOP. OOP does not scale well in any language that does not have a static compilation mechanism. As JS apps grow in size the ratio of OOP constructs dramatically decreases. Dart does not have this problem because it does have a static compilation mechanism. Anybody who writes a large application in Dart without compiling that code will wish they hadn't. This is part of the reason why Java developers get hostile when forced to program in JS and require libraries or frameworks to do absolutely anything.
I would really miss the prototype based implementation of objects on javascript. It is one of the best feature of the whole language
Regardless of the outcome I see the development of Dart as a positive for the web. Competition breeds innovation; even if Dart is a comets failure it may help contribute some new ideas and nudge JavaScript/ECMA forward. As for the actual outcome of the language, I have my doubts. But I bid it the best of luck.
I made a simple [jspref test case](http://jsperf.com/float-vs-int-addition/5). The answer appears to be no.
Interesting how you complain about stuff millions of people have no practical problem with.
You mean like asm.js?
There are pros and cons to both techs. Some of the pros, which are unique to dart, are tree shaking, the language makes it hard to write code that is hard to optimize, and the language itself avoids many of the warts of javascript (=== vs ==, semicolon insertion, and the whole undefined vs null thing). You give up the ability to do prototype object oriented programming easily, but you gain a pretty syntactically clean language, even if it is a bit boring.
No, because teven the round numbers will be handled as 32bit float Numbers... except for certain code optimisations like those proposed on http://asmjs.org/ - but those aren't widely supported yet.
Yeah I think it's very similar to a lot of the ideas in the Web components. More modular, self contained, components that are easy to reason about. Where you been? 
&gt; As JS apps grow in size the ratio of OOP constructs dramatically decreases. I don't think I'm sold that JavaScript is the root of the issue there. I suspect this is the consequence of many programming teams having insufficient regard for application architecture or the true importance of prototypal inheritance. Perhaps JavaScript doesn't always force proper coding etiquette, though I do not believe that JavaScript imposes any real limitations or obstacles in the way of creating efficient, beautiful, properly structured applications. I'm not so sure such rigidity (as seen in classical languages like Java) is good for the language of the Web. Perhaps rigidity really should stem from the coding standards of the team you're a part of. If JavaScript was more restrictive and less flexible, it would have became an obstacle as programming paradigms evolved beyond it's 90's era language design. JavaScript doesn't make assumptions about how I should code, so it doesn't *get in my way* as a programmer.
I'd agree that angular does allow you to pick and choose what you use which is great and makes it easy to start utilizing in existing pages (I think backbone is pretty good here too but ember would be nearly impossible). I see what you mean about rendering performance. Two way binding helps a lot with that problem but in most cases we like the control we have with backbone and are just extremely cautious about how views get up date and have created a plug-in that is sort of similar to stickit I'd say but leverages promises and transition events to be super flexible about when rendering and rebinding events get put in the event queue. I'd actually argue that backbone is *more* complex (when done right) than angular, but we really need the flexibility for most of our projects. 
Well that's just silly.
&gt; who taught you to do this? 18 years of experience. I started writing JavaScript in 1996.
Isn't asm.js just minimised js with a lot of macros the are faster than iteration and such? 
https://github.com/harthur/brain - I think a neural network is going to be your best option (it needs to be trained to eliminate false positives and -negatives).
No macros. &gt; asm.js is an intermediate programming language consisting of a strict subset of the JavaScript language. It enables significant performance improvements for web applications which are written in statically-typed languages with manual memory management (such as C) and then translated to JavaScript by a source-to-source compiler. Asm.js does not aim to improve the performance of hand-written JavaScript code, nor does it enable anything other than enhanced performance. https://en.wikipedia.org/wiki/Asm.js
That's an interesting way to look at it. I'm sorry, my AI is a bit rusty, could you give me a way that I would apply this? I'm guessing I feed it my sound data and tell it what's correct, but that's as far as I can get.
&gt; I'm not so sure such rigidity (as seen in classical languages like Java) is good for the language of the Web. Perhaps rigidity really should stem from the coding standards of the team you're a part of. Unfortunately, coding standards aren't well known for helping you debug code. &gt; JavaScript doesn't make assumptions about how I should code, so it doesn't get in my way as a programmer. It actually makes numerous assumptions about how you should code of course. C makes no assumptions though.
It's built-into backbone; Backbone uses it for a few things, among them propagating events (I think) as well as determining the model's URL for the sync component / feature. Take a look at Backbone's documentation for the model constructor; it's mentioned there and a few other places as well. It's incredibly vexing when you want to have multiple views of the same set of data; whereas in my hand-rolled code I create copies and filters of a collection class that allow me to resort or filter collections without affecting the 'master' set of data, in Backbone you get one collection per model.
In the experience I mentioned before (rebuilding a custom+backbone application into Angular) we became more efficient at adding new features and fixing regressions and bugs; the change was very, very noticeable. The complexity from Backbone is mostly what you add yourself; the complexity of Angular tends to come from the built-in components (transclusion, isolated directives, so on). To each his own, I suppose.
24 bucks for an ebook? No way! 
Agreed, are you in my office?! Haha. This is something we are battling with at the moment. There is a misunderstanding of the distinction between XP, Scrum and agile. People unfortunately believe that because you follow some Scrum processes you are an agile workforce. This said, wagile is still better than waterfall, 99% of the time.
What's wrong with it is that it's JavaScript. It's both a language I don't like, and a language I'm forced to use. If we had the option to run byte code in browsers, I wouldn't need to concern myself with it.
ES6 provides a ton of syntactic sugar, lexical scope, and a different way to organize your JavaScript. In the end, the behavior or the language is unchanged (lexical scope withstanding). ES6 doesn't *fix* issues so much as add to a base with many unresolved issues.
&gt; Again in ECMAScript 6 ES6 isn't here yet though. While Traceur is really neat stop-gap solution, `let` and `const` are unfortunately prohibitively expensive: https://github.com/google/traceur-compiler/issues/6 &gt; Imports Tree-shaking is about omitting the parts you aren't using. E.g. if you import Underscore, but actually aren't using half of the functions, those functions don't need to be included in the output. jQuery is also a good example. Most sites only use a tiny fraction of its features.
&gt; Bottom line: I don't want to be forced to dick around with OOP. You don't have to use classes. You can do everything with top-level functions if you want. Sometimes, a top-level function really is all you need.
&gt; Does he do mostly Angular, Node.js, jQuery or something else? The blog is within the moduscreate.com website, suggesting that the author regularly uses Sencha's Javascript products and AngularJS as described on the [Services Section](http://moduscreate.com/services/). The company also is active in [several regional JS meetups](http://moduscreate.com/community/). Perhaps this should have been explained in the post instead of implied via context.
This is a pretty good starting point - but is there a way to do it without a webpage?
&gt; Having to choose between Dartium (potential lock-in) and Dart2js (which is still somewhat inefficient and in its infancy) is a significant sell-off. Dartium is used during development. This way there aren't any compile times and you can directly debug your code from within the IDE. It's very convenient. Dart2JS is used for deployment and when you want to run integration tests and things like that. So, you really don't choose one over the other. You use both. Dartium a hundred times a day and Dart2JS a few times a day. &gt;Hoping for less Java influence Java actually wasn't a direct influence. This is where the ideas came from: http://i.imgur.com/y7b3R19.png It's more like a scripty C#. It got things like `var`, fat arrow functions, named arguments, and operator overloading. In the future, it will also have something like async/await. Java got none of that. Compared to ES6, the only thing that makes Dart closer to Java are the type annotations, but that bit of syntax looks like that in virtually any language with C-like syntax.
Software is not a solitary activity. If the ecosystem promotes OOP, everybody has to do OOP, whether they like it or not.
PNaCl is LLVM IR bytecode.
You can have an Emscripten/Asm.js fallback: https://github.com/google/pepper.js Also note that they were talking about NaCl, not PNaCl. NaCl used platform specific binaries. PNaCl (=portable NaCl) uses bytecode and the native code is generated on the client. Modern JavaScript engines also generate and execute native code.
I have no experience with it. I know two people who enjoyed working with it a few years ago, but don't know that they've used it since. With the class system, it sounded a bit like what the Dojo developers would have come up with if they were to replace jQuery
Neat!
Wow there are some neat things coming out recently. Well done!
Thank you. You’ve been a great help.
Worked out pretty well for Flash and Java applets. Oh wait... 
Might get a decent performance gain by storing the result of all those Math.cos and Math.sin calls in the animate function that are doing the same calculations over Theta1 and Theta2. Math.cos(Theta1-Theta2) is getting called 6 times for each animate.
Are you experiencing performance issues?
So I'm trying to make a function as part of a Backbone view superclass that probes for when a condition is true and then calls a callback after it. Eval might be evil, and obviously I could use promises where they're available, but I came up with the construct: this.callWhen(lazy('this.__lastLoad &gt; 0', this), function() { this.__draw(); } ); The exported `Lazy` is a factory function that wraps an expression and returns an object with a `value` property; accessing the value property causes the expression to be evaluated in the context of the second parameter. The only problem I've run into is that I can't see variables local to the function you call `value` from. I'm pretty convinced there's not a way to see these except something like `var scope = {};` `scope.x = 1;` `var L = lazy("this.x == 2", scope);` `console.log(L.value);` **&gt; false** `scope.x = 2;` `console.log(L.value);` **&gt; true** My question is then, outside of where `arguments.caller` is available, is there a pretty way to get access to variables declared in the local scope of a function's caller?
Sorry for a small delay. Thank you for addressing this particular case, it works for me. Well, it may be more challenging to also support AMD modules and I have no partiular idea how to do that yet. They are more suited for browser environment and support asynchronous loading http://requirejs.org/docs/whyamd.html The current functionality is also already quite nice.
If you put your API key out on the client in any way, you are basically exposing it. It's no longer a secret. Sure, it can still be used as a key, but it's a key everyone in the world has a copy of. You can expect zero security.
Does that mean you thought of it on your own?
Use a streaming server instead of direct downloads. Something like [red5](http://www.red5.org/). Nothing will be perfect tho, because users will need the file to play it in the player, but it will make it harder.
It's a very bad idea what you're trying to do. You can never store the passwords safely in the browser. It doesn't matter how you structure your application - since your own application can read them, any script, extension or other third party code can read them. Even if you have the passwords encrypted or hashed - they can still use your own code to decrypt it. If you need to keep the user logged in, use sessions and cookies. This means you have to use a server-side language like PHP, Python, Java or JavaScript (nodejs server). Also be sure to salt and hash your user's passwords. Never store the actual passwords on the server in case of an event where your server gets compromised - whether by a hacker or by your curious niece.
It means that I picked it up somewhere along the way and it has worked well for me over the years. Where did you learn that `typeof` is "bulky and hard for the compiler to optimize"? Data type is just a field on the memory allocation, a value that indicates what kind of information is stored in the variable. It is no more costly than any other string comparison.
Oh really? Why do linters exist? Why is there stuff like CC, GWT, TypeScript, and Dart? Why does ES6 try to address some of those issues? Also, you're using TypeScript yourself. Why aren't you using ES5? I thought you had no "practical problems" with it. :P
This would require some effort from the server side I'm afraid.
It's just as much of a replacement as any other compiles-to-JS language. Also, you didn't answer my question.
It is not a new language, it doesn't really change how you write code, there are no new constructs.
AS3 is also just a superset of ES3. Do you consider AS3 to be the same language? &gt;there are no new constructs Huh? It has classes, interfaces, and modules. ES5 has none of that. Interfaces aren't even planned at all. **Edit:** Mixins also aren't planned, as far as I know. Certainly not with that syntax. The "implements" keyword isn't used yet.
I think you're missing what the purpose of byte code would be. Byte code would not be a plugin, or an application external to your browser that runs in the browser. Byte code would run in much the same way JavaScript would. You could write JavaScript and have it compile to byte code, if you felt so inclined. You would still have access to the same DOM API you're familiar with. Your "wit" aside, Flash has been a huge success, whether or not we like it, and whether or not it is giving way to JavaScript applications.
First thing you want to do is not set the same ID value on each image as ID's are unique. Remove the ID on each image and add the value to the class: class="fade_in" becomes class="fade_in product_zoom" To init the script if it's not a mobile device, just under your call to detectmobilebrowser.js use: &lt;script type="text/javascript"&gt; if(!jQuery.browser.mobile) { $(function() { $(".product_zoom").elevateZoom({ zoomType: "inner", cursor: "crosshair", zoomWindowFadeIn: 500, zoomWindowFadeOut: 750 }); }); } &lt;/script&gt; This should allow your hover zoom to work on non-mobile devices (as dictated by the mobile detect JS).
To clarify your problem is something like, var foo = 'bar'; var L = lazy("console.log(foo)"); // foo is undefined Could you rework 'expr' to a callback function? var foo = 'bar' var L = lazy(function(){ console.log(foo); // bar }); 
What other specific unresolved issues would you like to be fixed and how does Dart fix them? Can you, please, provide a couple of examples? &gt; the behavior or the language is unchanged What exactly should be changed? &gt; many unresolved issues What specific issues? Can you name them, please?
&gt;Why aren't you using ES5? Every language evolves to adopt to new needs, so it is only natural to use newer versions when appropriate. &gt; Why do linters exist? Can you name a language for which no linters or code conventions exist? Such a language should be pretty rigid and strict about how you should indent and organize your code. Is Dart like this? &gt; GWT, TypeScript, and Dart Although listed together, TypeScript is quite different, it is a superset of JavaScript and it does not try to replace JavaScript, so there is probably something good and useful in the language if it tries to preserve it unlike GWT and Dart. By the way, what is best in your opinion, GWT or Dart? Should GWT still be used? Will Dart have the same future as GWT? Is GWT going to be actively supported and evolved further?
&gt;It's just as much of a replacement as any other compiles-to-JS language. False. TypeScript is a superset of JavaScript. Valid JavaScript code is valid TypeScript code. Valid JavaScript code is not valid Dart code. Another interesting question. Should all the old JavaScript libraries be ported to Dart or will we have some compatibility means that will just mix JavaScript and Dart code in one project? Will you have to learn 2 languages to support such a project: JavaScript and Dart?
I suspect that actually, it has types because people have realised they're a good idea.
I don't think this is premature optimization. In fact the code would look cleaner the way he describes.
Due to fat-fingering \^R, here's my now truncated response. I don't use Dart, so I can't answer in that context. Everything in JavaScript can be anything. Unnecessary run-time checks for types to guarantee type safety at any arbitrary point in code. Difficult for editors and IDEs to provide hinting. Type safety isn't a thing. Limited to linting for compile-time checks. Testing is not a replacement for this sort of check. Huge JavaScript applications are difficult to maintain, especially as teams grow larger. And promises. Promises are a kludgy, but necessary evil.
&gt; TypeScript does not have a virtual machine or runtime code. That doesn't really change anything, does it? Someone could create a VM for it. &gt;you are left with plain JavaScript that looks identical to the TypeScript code If it would look identical, the compiler wouldn't be necessary.
Pretty much all modern JavaScript engines have support for representing numbers as integers, as an optimization. So you do get speed differences between using floating point numbers and integers.
What? That doesn't make any sense.
&gt; E.g. if you import Underscore, but actually aren't using half of the functions, those functions don't need to be included in the output. This indeed speeds up loading of sites further and this is probably one of the main goals of Dart. But every optimization also affects the code for which it is applied and has its costs. If this optimization is not possible in JavaScript to begin with, I would not switch to a whole new language only because of it. Also loading and executing some extra code is usually not a huge performance problem. Of course, if we are trying to squeeze out the last possible bit of performance from sites, then yes, but often the speed is already good enough for users. Again, the question is, does it really help us as developers? Ideally something to enable this optimization should be done for JavaScript and included into the standard. Also what about using JavaScript libraries that use other JavaScript libraries from Dart? If I use in Dart some JavaScript library that references Underscore.js I doubt that this optimization will really work for Underscore.js and we will have to load all of it anyway.
Im impressed. well done sir. 
I think a lot of problems ext was trying to solve, is solved with modern browsers. Its a bit behind and creates a crazy amount of div soup. I feel if they released a version that only supported ie9+, it could be a lot lighter. However that maybe a bit optimistic. 
&gt;Every language evolves to adopt to new needs, so it is only natural to use newer versions when appropriate. TypeScript isn't a newer version of JavaScript. &gt;Can you name a language for which no linters or code conventions exist? I wasn't talking about style related rules. I was talking about rules which are meant to prevent errors ("practical problems don't exist"). &gt;Although listed together, TypeScript is quite different, it is a superset of JavaScript and it does not try to replace JavaScript You're arguing as if "superset" would mean the same as "subset". It doesn't. If you want to contribute to a TypeScript project, you have to use TypeScript. You can't use JavaScript. For this project, JavaScript was replaced by TypeScript. &gt;so there is probably something good and useful in the language if it tries to preserve it unlike GWT and Dart. Or maybe it's about being familiar and having a reason to exist. Either way, they also seem to think that regular JavaScript just doesn't scale. &gt;By the way, what is best in your opinion, GWT or Dart? I prefer Dart, because it gives you most of GWT's and CC's benefits without most of their downsides. Dart is the next logical step. &gt;Should GWT still be used? Sure. E.g. if you write a libGDX based game for Android, you can use GWT to deploy it also to the web. GWT works great. &gt;Will Dart have the same future as GWT? Is GWT going to be actively supported and evolved further? GWT's inital release was back in Mai 2006. The project is still alive and kicking with a new release every few months.
Yes, your statement doesn't make any sense. The output form the TypeScript compiler is of course not identical to the source code.
It's close enough. But what do you want from me?
&gt; If this optimization is not possible in JavaScript It is. You "just" have to add CC type comments everywhere and write code in a style which is compatible with CC's advanced mode. &gt;I would not switch to a whole new language only because of it. Of course not. It's just something the compiler can do because it has a much clearer picture of the whole application. &gt;Also loading and executing some extra code is usually not a huge performance problem. Actually, unused functions aren't even properly parsed in modern JS engines. This step is deferred until someone tries to use it. &gt;Again, the question is, does [dead code removal] really help us as developers? It sure does. It means you're free to include rarely used utility functions in your library. Or have a bunch of convenience constructors. It's just one thing less to worry about. &gt;Also what about using JavaScript libraries that use other JavaScript libraries from Dart? Those have to be minified separately. Unused stuff can't be removed unless you have a way to tell the minifier which parts you're actually using.
You'll want to do your best to obfuscate the location of the download, but as /u/Fidodo said, there is nothing you can do to prevent a very determined programmer from decoding your obfuscation and getting access. Obfuscation will prevent most of the user base from gaining access immediately, and you may have "plugins" or "extensions" being created to get around your attempts at blocking direct access.
I think better than obfuscation would be creating a one off link for each listen. The primary benefit of streaming though, is that it takes the length of the song to download it. Couple that with creating a one off link per user and only allowing each user one stream at a time and that prevents bulk downloading of the entire song library. You'd still be able to create a ton of users to parallelize that, but that kind of behavior would at least be easier to spot.
Ok, here, have fun with it: "you are left with plain JavaScript that looks nearly identical to the TypeScript code"
Personally, I prefer (though I don't use either) Vue over React, for two (somewhat opinionated) reasons: I don't like mixing languages in the same file, and I don't like having to build my JS files in development. React strongly encourages mixing JSX into your JavaScript code, which just smells to me, and requires a build step. Personally, I use require.js on my projects and load templates with the text! plugin. Of course, if you use Browserify or Coffeescript, you're already accustomed to building in development mode, but that doesn't really excuse mixing languages in the same files. 
I've had a pretty similar experience after putting Angular on my resume as well. I would like to point out that this is far from the first generation of front end frameworks; Dojo, ExtJS and YUI have been around for quite awhile. Don't expect any JS convention to last more than a few years, as the low barrier to entry and constantly evolving environments (browsers, servers, etc) continue to encourage innovation and change. That would be why I recommended understanding the concepts the frameworks promote, so your skills and ideas in one can apply forward as you pick up others.
This is super cool. * Nobody wants to talk to me * It should only ask for the cam/mic once, I think * Muaz Khan's work on WebRTC is awesome * Did you setup your own TURN/Stun/signaling servers? What did you use and how are you finding it? 
I could make it a closure but part of the impetus in making this use eval was that I felt using anonymous functions was 'ugly' ? In a perfect world it'd be a language construct like `var k = lazy(x + y);` and that's what I'm trying to emulate I'd love it if I could also use arguments.caller as the context for `this` without having to specify it, too :(
I got [wildly different results](http://jsperf.com/float-vs-int-addition/6)... The difference is so drastic it makes me think I messed something up. 
I'd argue that passing code in a string is pretty ugly.... I mean, it'll probably work, but it leaves a dirty taste in your mouth... and has drawbacks, as you've identified. You can get what you want by using a closure though, var k = lazy(function(){ x+y });
I agree that you should generate links, and maybe expire them after a while, so that sharing is less likely.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Expert system**](https://en.wikipedia.org/wiki/Expert%20system): [](#sfw) --- &gt; &gt;In [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence), an __expert system__ is a computer system that emulates the decision-making ability of a human expert. Expert systems are designed to solve complex problems by [reasoning](https://en.wikipedia.org/wiki/Automated_reasoning) about knowledge, represented primarily as [if–then rules](https://en.wikipedia.org/wiki/Rule-based_system) rather than through conventional [procedural code](https://en.wikipedia.org/wiki/Procedural_code). The first expert systems were created in the 1970s and then proliferated in the 1980s. Expert systems were among the first truly successful forms of [AI](https://en.wikipedia.org/wiki/Artificial_Intelligence) software. &gt;An expert system is divided into two sub-systems: the [inference engine](https://en.wikipedia.org/wiki/Inference_engine) and the [knowledge base](https://en.wikipedia.org/wiki/Knowledge_base). The knowledge base represents facts and rules. The inference engine applies the rules to the known facts to deduce new facts. Inference engines can also include explanation and debugging capabilities. &gt;==== &gt;[**Image**](https://i.imgur.com/ydMF6ij.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Symbolics3640_Modified.JPG) - *A Symbolics Lisp Machine: An Early Platform for Expert Systems. Note the unusual "space cadet keyboard".* --- ^Interesting: [^Legal ^expert ^system](https://en.wikipedia.org/wiki/Legal_expert_system) ^| [^Inference ^engine](https://en.wikipedia.org/wiki/Inference_engine) ^| [^Shyster ^\(expert ^system)](https://en.wikipedia.org/wiki/Shyster_\(expert_system\)) ^| [^Connectionist ^expert ^system](https://en.wikipedia.org/wiki/Connectionist_expert_system) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cit40wr) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cit40wr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It will turn into sordid camsex website in 3... 2... 1 But yes.. very well done. Congrats.
Your post got caught in the filter, do you think you could add some more info to it? Stuff like libraries/frameworks/build tools used and why you chose them, maybe some of the surprises or challenges you faced along the way, etc. I like the concept, and for feedback... have you thought about using 2 words in the animation? "Epic stories", "Boundless comedy", etc. would add some flavor, and would also make the quotes 6 words long. 
i'd be fine with that, and sort of expected it really. The service allows mp3 downloads for 80% of the files, for the other 20%, I'd like to make it a little more difficult to find the source file. Currently all you need to do is view source, ctrl+f and type in .mp3 to find the file. 
What about nested functions each with their own respective scopes?
The animation thing is interesting; I had never noticed it was only five words (good one!) I will add that in my next update. As for the tools: I use [Brackets](http://brackets.io/) as my main IDE and use [Grunt](http://gruntjs.com/) for code linting and other tasks. The main body of the website is managed by [Express](http://expressjs.com/) and and the database is MySQL. I will update the description above. Thanks!
JS is not the root of the problem, OOP is. It is ultimately an institutional problem. Many programmers are taught programming in a school that primarily teaches C++ and Java. To those programmers programming is only OOP. Trends in programming language design are moving far away from OOP. You do not need OOP to have inheritance or scale logic structures elegantly. The largest benefit for OOP in modern languages is to appeal to Java developers.
There is proper lexical scoping. There are first-class functions and you can also nest them. main() { foo(x){ bar(x) =&gt; x * 5; return bar(x) * 4; } print(foo(3)); // 60 }
So you know it's going to be impossible to hide it from 100% of users, but if you could hide it from 95% or more you might consider that a win. If so, a basic level of protection isn't that hard to implement, which can at least protect you from someone doing view-source and then hitting `ctrl-f`. For instance, base64 is supported in JS and many other languages as well... I don't know your backend, but say for PHP you could do: // should be aHR0cDovL2V4YW1wbGUub3JnL2Rvd25sb2FkX2Zvcl93aGF0Lm1wMw== $url = base64_encode('http://example.org/download_for_what.mp3'); And then in JS: http_file_path: atob('&lt;?= $url ?&gt;') More on [atob](https://developer.mozilla.org/en-US/docs/Web/API/window.atob), and be sure to read the part about [Unicode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding#The_.22Unicode_Problem.22) as that can definitely cause some PITA bugs...
Thanks! I unfiltered the post.
I wouldn't recommend starting with Node if one has 0 programming experience. Start with the JS lessons on Codecademy before moving to Node
its been so long since i saw math like this, guess thats one of the advantages/disadvantages of doing only web work with no animation stuff
Very interesting. Once it get a little more attention perverts will abuse it. Just a suggestion, you should have some sort of login that verifies the person's identity so that they'll think twice before doing something dumb otherwise it'll turn into a nasty omegle. But I don't know what your intentions are.
Thanks so much for the response! I'll look into this. I think an expert system may be more than I need, though, since an answer can be arrived at by following the path down the map to the final product? For example, I could create this quiz with a series of separate pages if each answer links to a new page. Do I really need AI to do this in javascript form?
Bias disclaimer: I mostly work alone, and I always trust myself with JavaScript's powerful flexibility. Perhaps if I was managing a hundred interns, I'd have a different bias ;)
&gt; I could make it a closure but part of the impetus in making this use eval was that I felt using anonymous functions was 'ugly' ? Yes, it's a little burdensome, but it's the only way to capture the enclosing scope. However, [with ES6 it's going to be less-ugly](https://github.com/lukehoban/es6features#arrows)! &gt; I'd love it if I could also use arguments.caller as the context for this without having to specify it, too :( If I understand correctly, I've sorta wanted that too. Something like this right? function outer() { var foo = 'bar'; inner(); } function inner() { console.log(arguments.caller.context.foo); // "bar" } Though, it sets off alarm bells too... just seems wrong. I mean, what's the point in arguments anymore? I think learning how to use `call()` and `apply()` helped me to learn how to approach the problem from a saner frame of mind.
Ok, here's a crazy idea... when a user first visits a given page they are given a random token in addition to a link to a source file. The "source file" is really just a back end router of sorts that accepts an ID of the related song file and a token. If router is accessed with both a valid token and ID, allow the download -- this is how they player runs -- then disable the token, this is so if they try it again (i.e. from viewing source to get the filename) the token wouldn't be valid for the ID and it should throw an error. This would take quite a bit of effort to setup I imagine and wouldn't be completely effective -- one would be able to perform an HTTP GET to the page and just read the response without actually rendering it in a browser -- they'd be able to snag the file path and download it. Despite this, I'd wager a setup like this would probably stop the majority of people.
It looks really nice, I'm very familiar with Javascript and was going to become more familiar with objective C to start making apps, but now I'll just use swift. Unfortunately I can't get Xcode 6 beta without a paid dev account, which I don't want to do until I can justify it by being able to make an app in swift. I guess I'll just wait until it's released.
This is a great example of a micro optimisation. Given the fact on my laptop I can sum an array of 10,000 values 4,000+ times per second. That's 40,000,000 additions per second. Because JavaScript only has one number type (IEEE 754 floating point) truncating the precision probably wont make much of a difference. And even if you did choose to use a smaller precision, it's going to be slower to shorten the precision and do the summation, than it would be to do the summation in the original precision. Anyway, if you need to add numbers faster, use a faster language, like C.
I am genuinely intrigued: do you have a list of JS engines and what is necessary for them to handle numbers as integers?
The performance benchmarks are nice and all, but what really got me was this example with the mouse: // First we define our "sequence" of events. var mouseEvents = Lazy(sourceElement).on("mousemove"); // Map the Event objects to their coordinates, relative to the element. var coordinates = mouseEvents.map(function(e) { var elementRect = sourceElement.getBoundingClientRect(); return [ Math.floor(e.clientX - elementRect.left), Math.floor(e.clientY - elementRect.top) ]; }); // For mouse events on one side of the element, display the coordinates in one place. coordinates .filter(function(pos) { return pos[0] &lt; sourceElement.clientWidth / 2; }) .each(function(pos) { displayCoordinates(leftElement, pos); });
You can look at the post of Dr. Rauschmayer http://www.2ality.com/2012/02/js-integers.html
That only shows how to handle numbers as Integers, not how to trigger the internal optimizations in any JS engines in order to gain performance.
This looks like Promises.
For me is a surprise that other libraries were working with raw arrays.
_fewer_ than 100 lines #mildlyinfurating
IsThisConsideredAValidZhong? iThinkIcanProduceAShortEssayUsingLessThanSixWordsWell ThisIsJustFourWordsOnlyActuallyHueHueHue #mtbinkdotcom
Using CSS http://css-tricks.com/adding-stroke-to-web-text/
For anyone who may till be interested/come across this reddit. I now have a demo available: http://blog.ilikeprograms.com/BootstrapThemeEditor/ Take a look and see it working!!
Could you elaborate on why this "got you" please? :)
You might be able to access the WebAudioAPI using nodejs (which is what I think whistle is using for FFT analysis). There is an extension here in progress: https://www.npmjs.org/package/web-audio-api
Because at first I was thinking 'ah yeah, lazy lists, that's cool, you can map and filter', but I hadn't thought about its potential application in this way. Maybe I'm way behind the times in JS libraries and this is pretty standard, but it seems like a really elegant way to start doing UI design. Similar to the approach taken by Elm and FRP in general. I suppose it _got me_ because what makes me excited is not so much performance as elegant code that does cool stuff.
I don't think you're way behind. I was asking because I just can't see anything at all and wanted to learn what it is that is advantageous :)
Once you go lazy it is hard to go back. It saves so much speed.
Here's [Underscore's `_.map`](https://github.com/jashkenas/underscore/blob/0a53eba8129bd3a2d01ac6f4bab9b0b65c98052e/underscore.js#L121), for example.
Why? Do you think that backbone and marionette is a winning combination?
Cool, thank you! 
Don't know if winning, but i like it a lot. It is collection of common design and implementation patterns for backbone, and added some missing classes. I expect them to be merged one day. It has "add what you need" approach (plugins). Personally, I don't like frameworks. I like JavaScript and Marionette only extend it. Not modifying! Everything else is on you. More code, more flexibility, more responsibility. Don't get me wrong, any mvc is good. This is only tool, you are creator. If I wouldn't do Marionette, i would probably look for CanJS. Good luck! 
The source code is here: https://github.com/batiste/likely.js/blob/master/examples/todomvc/js/app.js The template is there: https://github.com/batiste/likely.js/blob/master/examples/todomvc/index.html#L13-L50
For laziness, I have used http://fitzgen.github.io/wu.js/
when you render the page/data on the server, you omit the direct download link data. You can "obfuscate" the link as well (i.e. add a single use token tied to their IP for the auto player, get a chunk of javascript from the server and run it in an eval, have the server examine the headers on the request to see if it looks different when auto-playing vs just getting the file, etc).
You could write that, but there is also a word length restriction, plus it counts negatively to your score.
I imagine you're overwriting `input[a]` without realising it. Let's say you function (with parameters) is function auto_scale(x, y) { // ... } You say you log `y` at the end of the function and it's still 0. What if you log `input[a]`. If you haven't changed it from within the function, that should also be 0.
Java != Javascript visit /r/java
Probably not. You could just use a massive conditional loop. Or several pages. I only mentioned expert systems because I assumed your quiz would be more complex. I allow my users to create the question chain and it gets pretty complicated. Like &gt; 15 questions with some questions having more than 2 answers. I'd look around for a general quizz script. Like the ones you see on Facebook which character in x am I? Etc.
I wouldn't build it in javascript, but that's kind of an aside. There's probably an infinite amount of ways to go about building this kind of app, but I'll give you my ideas. First off, in one way or another you will need to implement setInterval or setTimeout. http://javascript.info/tutorial/settimeout-setinterval. That will keep your JS running into the future instead of all just executing at once when you load up the page. You can do one of two things, as I see it, to make this a very simple app. You can either have the setTimeout wait a specific amount of time (til the time the alarm should go off) and then turn on the alarm, or you can use setInterval to check the time, say every 5 seconds and when the time equals the specified wake up time, turn on the alarm. And then, to really simply "turn on" the alarm, just call a function that runs window.location = "url of youtube video"
Just the answer I was looking for, thank you very much!
Java != JavaScript try Deitel book How To Program Java http://www.deitel.com/Books/Java/JavaHowtoProgram9eEarlyObjectsVersion/tabid/3622/Default.aspx
This *is* a good start. I didn't realize what all it could do until i launched it Chrome on accident. Counter-intuitively, the native colour pickers aren't working for me in Safari. (on Mavericks) 
Oh dear lol. I havent really done much testing of it Tbh. It was kinda a side project idea, but I figure im really happy with it and im going to continue developing it! At the moment I feel like I need to do some good work on improving the API in general, the build process and then updating the readme. So everything is clear! If theres anything else you noticed which is going wrong then im all ears. I would like it if some people started using it, as I said in my previous post!!
Interesting that all three answers that exist --- as I write this --- use programming idioms to "help" you understand that Java and Javascript are two very different things. Javascript has an unfortunate (nick?)name, and is almost, but not quite, completely unrelated to Java. From the [Wikipedia entry on Javascript](http://en.wikipedia.org/wiki/JavaScript): &gt; Not to be confused with Java (programming language), Java (software platform) ...and... &gt; Although it was developed under the name Mocha, the language was &gt; officially called LiveScript when it first shipped in beta releases of &gt; Netscape Navigator 2.0 in September 1995, but it was renamed &gt; JavaScript when it was deployed in the Netscape browser version &gt; 2.0B3. Perhaps LiveScript was rebranded as JavaScript in order to ride on the even-then meteoric rise in popularity of the Java name? ¯\_(ツ)_/¯ In any case, there is a [Learn Java subreddit](http://www.reddit.com/r/learnjava) that you might try. Cheers. [edit: formatting, punctuation, de-stoopidfying]
It did eventually freeze the Chrome tab I was using — all work lost. Ooops.
At the risk of sounding dumb... Can someone ELI5? Lazy evaluation I mean.
Lol yeah, thats less :) Everytime you drag the mouse in a color pickers its recompiling. I will need to only let it update once a second or something. So it doesnt do that! Im working on some changes atm, might be able to do that later on. Who knows! AS a workaround for now if you want to keep using it: Go into the JS console. CMD + ALT + J in Chrome on Mavericks. Type: `themeEditor.getJSON();` Then Copy/paste the text between the start and end `"` output somewhere. (The " at the start/end will make it an invalid object if you paste it back in with them). Then type: `themeEditor.modifiers = ` and add the output you copied earlier with a `;` to end the statement. Then type: `themeEditor.applyModifications();` So for example: themeEditor.getJSON(); // {"@brand-primary":"#aa7942"} themeEditor.modifiers = {"@brand-primary":"#aa7942"}; themeEditor.applyModifications(); 
NP. It helps that I developed the API haha. Once im done making some more changes to improve the building, im going to update the readme/docs (hopefully) with a proper API reference.
It's not exactly ELI5, but see https://pay.reddit.com/r/javascript/comments/2abbz7/lazyjs_like_underscore_or_lodash_but_with_lazy/citirlq
I'll try, briefly! Basically, laziness (which is a _particular strategy_ under the broad umbrella of _non-strictness_, because apparently you can be _not strict_ in different ways, but I don't really understand that) means that expressions are left unevaluated until they _really need_ to be. For example, to print them. Here's the classic example: function good() { return 5; } function bad() { while(true) {} } function chooseOne(x, y, which) { if('first' === which) return x; else return y; } console.log(chooseOne(good(), bad(), 'first')); Obviously this _should_ log `5`, but it never does. Because JavaScript (along with pretty much every imperative language) is _eager_ (one type of _strictness_), it will try to fully calculate the results of `good()` and `bad()` before passing them to `chooseOne`. In this case, of course, `bad()` never returns and your program hangs. It looks like of like this: console.log(chooseOne(good(), bad(), 'first')); // Evaluate good() console.log(chooseOne(5, bad(), 'first')); // Evaluate bad() // ...waiting // ...waiting If you were being lazy, calls to `good` and `bad` wouldn't ever be actually evaluated (ie. the functions wouldn't be called) until the _last possible moment_, i.e. somewhere inside `console.log`. So the evaluation would look something like this: console.log(chooseOne(good(), bad(), 'first')); // Substitute chooseOne console.log(if ('first' === 'first') good() else bad()); // Reduce console.log(good()); // Substitute good() console.log(5); Note that I've decided to treat `console.log` as something that can't be simplified or broken down, or it'd be substituted first. Laziness works outside-in, breaking down top-level expressions first, rather than strictness, which you saw worked kind of inside-out, trying to evaluate the arguments before the enclosing functions. And you'll notice that because the result of `bad()` was never actually needed (because of the conditional), we never tried to evaluate it, and avoided that infinite loop. Note that laziness isn't just about avoiding infinite loops - `bad` could have contained some expensive operation, or a side-effect, or possibly the tail of an infinite list. Anyway, I hope that was slightly illuminating. I'm clearly not an expert, just trying to help out :P. It's a bit of a jump from that to infinite lists, but there's plenty of resources out there. Give it a google. I've found that I only really _got_ laziness after writing Haskell for a while, until it just sort of made sense by example. **EDIT** Oh, and someone will probably mention this: JavaScript does have built-in laziness! if(good() || bad()) { console.log('hi'); } Most C-like languages have non-strict boolean expressions. So if the left-hand side of an `||` is truthy, there's no point evaluating the right-hand side, because the result _will be_ true regardless of what happens on the RHS. So in this case, you'll see `'hi'` instead of an infinite loop. **EDIT** And just to blow your mind a bit, here's a cool lazy toy program in Haskell suggested by [this blog post](http://alpmestan.com/2013/10/02/oh-my-laziness/#hello-laziness): main = print (length [1, sum [1..]]) This does successfully print `2`, because `sum [1..]` (i.e. the sum of the infinite list `[1, 2, 3....]`) doesn't need to be evaluated! We don't care what its value is, just that it's in the list. **Finally,** remember that laziness can be a double-edged sword if you don't fully understand it. I like it, and I find it a really natural way to think of some programs, but it's different to how we usually think about programming. This means it can lead to space leaks, unpredictable performance, etc., if you use it everywhere (like, for example, Haskell does) and don't understand the implications. Just wanted to bring some balance to the post ;).
I haven't actually tried running the code yet, I just like the way it looks! I saw this posted in /r/haskell and thought it might go down well here...
You should check out [Bacon.js](http://baconjs.github.io/). It may actually blow your mind.
Without the source its impossible to tell...
I didn't see examples of pattern-matching on arbitrary objects, which seems much more useful than integers and types, to me. Though `wu` does look kinda cool.
Which browser are you using? Are you sure it's using the adobe plugin for PDF rendering and not something like Chromes built in support, foxit or Mozillas PDF.js? JS in PDFs can be very tricky, and you can't really rely on it to work everywhere the PDF will be opened.
That's what I thought: looks like Bacon. 
I'd probably check out http://www.sitepoint.com/an-introduction-to-javascript-for-acrobat/ but if you are only expecting it to render in the browser why not just use HTML?
Right, by arbitrary objects, I meant the actual structure of the object, not the constructor. Like destructuring assignment, or `match` in Scala - though I guess that'd be hard to actually do in vanilla JavaScript.
[**+Douglas Crockford**](https://plus.google.com/118095276221607585885) [_2014-07-09T13:54:19.464Z_](https://plus.google.com/118095276221607585885/posts/QQTG9RsSJZi) &gt; &gt;In the next edition of JSLint I will be removing several options. I never recommended use of these options. I regret having ever added these options in the first place, and their removal is long overdue: ass, closure, continue, eqeq, newcap, nomen, plusplus, sloppy, stupid, sub. 
Can you put an example of this up on http://www.jsfiddle.com, I'd be more than happy to help you resolve this, along with others in the community, but we can't unless some additional information is provided (ie: source code) or an example is given. EDIT: In your original post you have the following lines: &gt;_a = a &gt;_b = input_data[a] &gt;auto_scale(a, input_data[a],false) &gt;a = _a Are you really setting **a** to be the value of **_a**? Aren't they already the same value? Depending on where this is (if you're using "classes", and the scope/context this code is being run in, setting the value of **a** to be the value of **_a** could be causing your issue. If **_a** is no longer defined, you'll be setting it to **undefined** which would cause **a** to be undefined, therefor returning **undefined** when looking for the key **a** in **input_data**. Also, why are you setting input_data[a] = _b, when you set _b to equal the value of input_data[a]? I hope you're demonstrating that input_data[a] is equal to _b, and not actually resetting the values like that, because that is a horrible idea/bad practice. 
I had a feeling you meant that. Yeah, I don't think wu has a way to match arbitrary objects. I don't think it would be *that* hard to implement though. Something like this: wu.match([{ foo: wu.__, bar: 'baz' }], '...'); would just require iterating over the objects properties.
I thought most people had migrated to JSHint by now, which is a fork of JSLint run by people who aren't interested in ramming their opinions down every user's throat. 
&gt;`` &lt;blink&gt;What are you doing here?&lt;/blink&gt; `` You are a *monster*.
Oh yeah, of course, I was expecting to be able to actually bind variables in the pattern, which is hard. Just matching doesn't seem like it would be that difficult after all.
JSHint becomes even more attractive.
I see, you're right, that would be tricky. Sorry I keep misunderstanding you, I'm sick and having a hard time keeping my head on straight ha.
Nice! It's quite an elegant way to show images in full size. My only criticism is that it would be a bit nicer if the cursor rotated on click rather than after you move the mouse once the image has gone full size. This would be great for Photography portfolios and galleries etc. 
I'd rather stick with using `$scope`. The only reason for wanting `this` is laziness. `$scope` is a dependency and should be injected like the rest. This makes testing easy (inject your own scope), it makes things clear (there is only one `$scope`, there can be multiple `this` depending on actual scope). Would you rather define `self = this` (or keep binding everything as in his example), instead of just use `$scope` like a normal person? This is the kind of feature that gets implemented because lazy people with bad practice keep pushing for it. Being able to reference things in views is very useful, though. The ability to name a controller really does clear things up. Oh and this existed since last year, FYI. Fairly old feature that goes against angular practices/patterns.
Learn how to write good JavaScript, and write something. I am a firm believer in proving yourself as a developer. "Show me the code". Maybe start a project, or join an existing Open Source project and contribute changes. Lookup and read more JavaScript code, how they are constructed, best practices etc. This will help you to write better code.
Using `new` is not a problem. The article describes how it's possible that omitting the `new` keyword can be a problem, and it also describes the fact that `new` doesn't compose with other functions, which may or may not be a problem, depending on your programming style.
Author here. Here is the version — by popular demand — that only uses DOM methods and does not use Angular, still clocking at 99 lines: https://github.com/audreyt/500lines/tree/master/spreadsheet/as-without-angularjs Comparing it with the Angular version at http://jsfiddle.net/audreyt/LtDyP/ would illustrate the issue of separation of concerns: The DOM-only version had to construct its own view in JS, and use an additional #_A1 encoding to fill in calculated values into display, while the AngularJS version is declarative in that regard. In any case, I should have explained the context better; this is for "500 Lines or Less", the fourth in the Architecture of Open Source Applications series, aimed more at new students than professional programmers, so separation of concern serves a pedagogical, rather than practical, purpose.
Thanks for the report! There was a bug related to high-latency links; this should be fixed now in http://jsfiddle.net/audreyt/LtDyP/ — Please let me know if you still encounter that bug.
Yes, that work was the inspiration for this chapter. :-) Back when it appeared on HN, the first thing I entered was =(function(){for(;;){}})() — which predictably froze the browser. Trying to find a sufficiently-robust way around this restriction ended up shaping the Web Worker based structure in the 99-lines version.
Great read. 
And millions of people solve practical problems with languages that compile to JavaScript.
I looked at wu. It indeed offers some of the same functionality, but I feel lazy.js has two advantages: first, it offers a nearly identical interface to Underscore/Lo-Dash, so it's familiar; and second, it really takes the sequence-over-array paradigm a lot further. You can use lazy.js to traverse strings, streams (in Node.js), event sequences, etc. That said, wu.js is quite nice. However it should also be noted that it's significantly slower than even Underscore and Lo-Dash in most cases, at least based on my (admittedly old and possibly out-of-date) measurements: http://danieltao.com/lazy.js/comparisons.html
What about panning diagonally for large images?
How about doing some backend stuff with Node.js?
Yeah... sorry about that :( Basically Lazy.js has lain dormant for months now. There's no good excuse—mostly laziness, with a bit of busy-at-work mixed in—but I have every intention of getting back to it and fixing this and some other dumb bugs.
it seems like the example with `logArguments` which is a function that evidently takes a constructor function, then returns a new constructor is poorly written. If it's "wrapping" the passed constructor, it should be returning a proper subclass of that constructor. The simple `if(!(this instanceof MyClass)) return new MyClass();` will be fine... time to refactor that `logsArguments` function.
write stuff
It's true. Fortunately somebody's submitted a PR for it (no doubt thanks to this Reddit thread)! https://github.com/dtao/lazy.js/pull/92
Solution #4 - use static analysis tool.
True, but then the `logArguments` function will only work with constructors, and not with ordinary functions! There is a more complex pattern for writing decorators and other combinators that work with either constructors or with ordinary functions, but that doesn't help if your decorator is a library function, such as the things you find in Underscore, allong.es, or Ramda.
What TYPE of SCRIPT supports that?
I completely agree, I think using $scope is a much more angular way to go. Unfortunately I've been seeing this controller as syntax popping up everywhere now and people saying Google will push for this kind of syntax in 2.0 :(
Use [Underscore](http://underscorejs.org/) to easily loop through arrays/objects (after all that's all jQuery is doing). You can either use it straight out or bake it into your code.
Oh neat, it works now, cheers for the gold amigo.
Well, if JS is disabled and your app doesn't work, surely there's no point in even bothering to show the table? I think I would probably just replace the whole thing with a nicely designed message saying 'Sorry, but this app doesn't work without javascript! Please turn it on to continue', or something to that effect. I know this is a controversial opinion, but personally I don't think you should even consider making sure a page works without CSS. If you disable such a now-vital part of the internet, you shouldn't expect everything to work as intended.
A pattern I like is writing the constructor as a factory first. This means its first line is declaring __self__ as either this (if its not the global object) or an Object.create of the factory's prototype, and then we return self at the end. It's basically the same as the pattern op describes, just with you put in the mindset that .call and .apply are also ways to use the method.
&gt; The only reason for wanting this is laziness. &gt; Being able to reference things in views is very useful, though. The ability to name a controller really does clear things up. I'd argue sticking with $scope is lazy in comparison. Controller as clears up things *immensely* inside templates.
I've been reading up on rendering and performance optimization lately and this article is one of the best I've read so far! Optimizing relayout and repaints and taking advantage of compositing can go a REALLY long way on complex animations and devices with less CPU.
You need to ensure your knowledge remains up to date. javascript is moving and fast. I would continue learning the language. Then learn jQuery. Then unlearn jQuery. 
I don't think what you want is clear at all. Here are some parts I can tease out though : *cloning an object. Object . create and constructor functions give you everything you need here. _.extend is somewhat applicable too. *there is no need for the plug-in thing. You can literally add anything to any Javascript object any time you want to or use the normal methods of object creation/instantion. *event publish and subscribe. This is pretty easy and there are untold libraries for it. It's part of core node with event emitters. *if you just mean being able to act on object properties or arrays of objects as a single unit, as someone else mentioned any of the libraries like underscore or Ramda can help you out and there are now the native array methods for forEach, map etc. I'm not positive I understand what you want though. 
This is pretty cool! I had fun playing around with it. What's been the largest challenge so far? I see you're using Angular, what's your take on it?
Get 10 full days from Pluralsight with hundreds of videos. https://pluralsight.com/training/Subscribe/Step1?isTrial=True&amp;failedCaptcha=False
Composing and decorating constructors. Oh you. 
Makes me wonder if ["Fake Operator Overloading"](http://www.2ality.com/2011/12/fake-operator-overloading.html) could be used for laziness...
Interesting article, there are so many ways to solve *this* problem. I've been experimenting with constructor patterns all week actually. I've found that having functions return functions (within functions) wrapped in commonjs modules works pretty solid :P
He who must not be named 
I think maybe you missed the point. It doesn't *have* to take a constructor function. Iirc he introduced by passing in a simple sum function. 
Here's a quick snapshot of the changes - in my opinion some of them seem a bit too strongly opinionated. Pretty sure JSHint won't follow suit. This will make it no longer permissible to: **Tolerate assignment expressions** any assignments that aren't at statement level **Tolerate Google Closure idioms** no idea **Tolerate continue** **Tolerate == and !=** **Tolerate uncapitalized constructors** **Tolerate dangling _ in identifiers** identifiers with underscore at start or end **Tolerate ++ and --** **Tolerate missing 'use strict' pragma** **Tolerate stupidity** As far as I can tell, using any method whose name ends with "Sync" **Tolerate inefficient subscripting** using brackets were dot operator would have sufficed
Thanks! Biggest challenge: Since it was (and still is) my very first full javascript project then most anything here has been a challenge (like learning node, like taking me half a year to get the connection via socket running, like building my first API). Since the jQuery version was built really tightly, then figuring out how to use jQuery and Angular at the same time has been phun. By now, I'd just love to see how other people would solve the things I tried to solve. The very first commit already was written 15 times smarter then my code and added preview for memes and shortcuts. We had been thinking about it, but definitely not this way. It's not totally ready yet, but we love it already. &amp;nbsp; Angular: I started using Angular since I needed routing inside a single page application. Angular has a (bigger) learning curve (than we'd like to admit), but the moment stuff starts to work it's supercozy. I was just interviewed for "what are your go-to tools for a new project?" and mine are now nodejs, angularjs and bootstrap. 
In the land of kitty cats, unicorns, and rainbows peoples emotional considerations are really important. For these people there is JSHint. For people who actually give a shit about better code and faster development stricter is better. For these people there is JSLint and the newer and more flexible ESLint. If your code passes JSLint it will always pass JSHint, but the opposite is not true.
Came here for the "Write JavaScript" response, close enough.
i ordered mine no problem... came in two days (amazon student account)
But I like it better than Bacon.js, looks like unix command line For example, this is how I select the most frequent 20 lines in a file: cat file.txt | sort | uniq -c | sort -nr | cut -c 8- | head -n 20 Looks a lot like Lazy
Huh?
You might also want to check out /r/LearnJavascript :)
I'd recommend learning frameworks. Jquery, Angular, Node, etc. Build stuff in all of these. Build plugins that can be easily applied to other projects, beautiful UIs, and innovative design features.
Great read! 60fps for everything all the time is awesome.
What I do is figure out menial tasks and see if I can make them easier or faster with JavaScript. I've written about 4-5 JavaScript apps for my work to make it go faster. I saved them dozens of man hours a month. Got two raises in 4 months from it too.
I think what you want is available natively in js but you are not familiar enough with the language yet. Check out object oriented JavaScript by stoyan stefanov or a different book. Although maybe I'm wrong because it's a little unclear to me from your code what you are trying to achieve. Also up vote for underscore.js. 
You can use an HTML canvas.
Since you don't need high performance for chess game, you could use an HTML table to do it. You can also use an HTML canvas, like most of the HTML5 games. You can draw on it directly, only using the canvas api, or you can use a js game library which will abstract most of the operations. I personnaly use phaser.js, which is really great and easy to use, but lacks tutorials. I also used Quintus, which is also great, but a bit more tricky to use, and less powerfull.
Oh lol yeah its a good one
For Chess, a table should work fine. It has the advantage that you can easily rig it to scale with the size of the window, without any extra scripting. That said, most Javascript games these days use the HTML5 canvas feature. You can find a reference for the Javascript canvas 2D API [here.](http://www.w3schools.com/tags/ref_canvas.asp) There are also ways to use it with 3D graphics, although that's more advanced stuff.
Also wu.js development is dead while there is still activity in Lazy.js.
I'd love Reddit to scroll fast...it's the clunkiest renderer of any website anywhere. =/
It feels like all the hard part has been done, but the learning curve is still too steep. These days it needs to be easier to pickup than react to be interesting to me. I can see this being great with another iteration or two.
The question seems answered, but you may still be interested in [gameQuery](http://lmgtfy.com/gamequery). EDIT: Link fixed
http://www.pixijs.com/
**inside templates**, yes, thats a fantastic idea (giving a controller a name). However, *inside the controller*, it just makes things terrible and non-angular. The whole reason `$scope` exists in its current form is for DI, to allow for easy mocking and so on. Why bother moving over to using `this`? It goes against the angular "way".
This. If it's something simple, there's no reason not to just use canvas drawing although you'll probably want to save the assets as images rather than redrawing them every time they move. Context drawing is costly.
Thanks for the feedback. Most of the points are now fixed here https://github.com/batiste/likely.js/commit/6b19828937755df60ebe3bb18c281daf59685b83
I might be biased as the creator but I think it's way simpler than React. The template language is a simplified HAML with 6 special keywords. The code part is just plain javascript, you manipulate the data, and then call an update to reflect your changes. Maybe have a look at this piece of code to see how simple it is: https://github.com/batiste/likely.js/blob/master/examples/crud.html I believe this little library, for good of for bad, is way simpler than React.js. As a point of comparaison, React source code seems to be around 15'000 lines of code when likely.js is around 1'500 lines.
http://justbuildwebsites.com/
&gt;JavaScript isn't going anywhere. False. Yes another emotional statement with no substantiation. JavaScript is evolving, next version introduces better support for big projects. &gt;You can dodge some problems In 99% of JavaScript code you just do not see these things. This was maybe more the case years ago when JavaScript programmers were not really programmers but Web designers with some programming knowledge. Nowadays this is not so much of a problem. Again in any language, including Dart, you can write code that will look messy and unstructured. So trying to sell Dart as a magical silver bullet here does not work.
And why is that? Maybe you just do not have any appreciation for it? Then trying to improve or fix something you do not understand will likely not succeed. Why are you then here and trying to convince everybody to use Dart? Is Dart not that convincing by itself?
&gt; Seen that infamous WAT talk? It is a funny video, but in normal code you just do not encounter such things which is maybe 99% of the available libraries and frameworks, including even Google's very own Angular.JS Can you show me any examples of those things from the WAT video in the source of Angular.JS? I think you will not find them. Use linters, give more control to developers and do not force them into your own understanding of programming languages thinking that somehow everybody else is not as good and as smart as the language designers are. Also I do not see a community effort behind Dart, rather it is something being pushed by one vendor and developed according to its own requirements and understanding of what a language should look like. &gt;New versions of JavaScript can only add things, they can't remove anything. &gt;So, there is strict mode, but non-strict mode does continue to exist. There is now block scope, but function scope continues to exist. You now get a lexically scoped this in fat arrow functions, but you still get that really weird scoping elsewhere. Newer versions of Dart will not be backward compatible and will break things in the future? Did Dart get every feature right in the beginning and for the foreseeable future (10 years)? I doubt that the answer is "yes".
&gt; False. &gt; &gt; Yes another emotional statement with no substantiation. JavaScript is evolving, next version introduces better support for big projects. Eh? Mind the context. /u/sime was talking about killing JavaScript. I said this won't happen. &gt;In 99% of JavaScript code you just do not see these things. Of course not, because these things are bugs which need to be fixed.
&gt; It is a funny video, but in normal code you just do not encounter such things which is maybe 99% of the available libraries and frameworks, including even Google's very own Angular.JS Again, those things are bugs which prevent your program from running correctly. This is something you'll fix before you commit it. Naturally, bugs like these also won't be deployed. However, that doesn't mean that it didn't waste any time. &gt;Future versions of Dart will not be backward compatible and will break things in the future? The point was that in order to get rid of those issues, you have to start over. You can't go back in time. Future versions of Dart will be backward compatible. The language itself has been stable since 1.0. The next version of the standard will include a few more features.
Most modern games use Canvas and requestAnimationFrame. Good intro: [Google I/O 2011: Super Browser 2 Turbo HD Remix: Introduction to HTML5 Game Development](https://www.youtube.com/watch?v=yEocRtn_j9s)
&gt;&gt;In 99% of JavaScript code you just do not see these things. &gt;Of course not, because these things are bugs which need to be fixed. OK, good, does it mean that the existing language should be improved rather than replaced if we are dealing only with 1% of bad code written in it?
Flash was extremely successful for about 15 years. It's still wildly used. Anyhow, there never was anything wrong with bytecode. The problem are plugins. They need to be installed separately, they are a security nightmare, interacting with them is very clunky, they hijack the keyboard, and they either require lots of copying or they simply draw on top of everything. Also, without Flash, we wouldn't have all those things like HTML video, Web Audio, WebGL, full screen, and so forth. Flash was some kind of proof of concept or feasibility study for that kind of content.
lmgty is out of context here, which is forgivable...but you also mistyped the url. Your link is a 404. :)
This isn't an either/or thing. JavaScript will of course continue to be improved. However, there are limitations. You do like things like garbage collection, don't you? How about control flow structures (if/else, for, while, do-while) instead of having to use conditional jumps? That stuff is pretty great too, isn't it? That stuff makes writing code so much easier and less error prone. It wasn't possible to add something like that to ASM. Type coercion sounded like a good idea at the time, but it turned out to be a mistake. It's just a waste of time. It doesn't help one bit. It doesn't make anything easier. It only adds some levels of indirection when you want to find the error. Unfortunately, we can't go back. We can't take this away. Stepping outside the bounds of an array is also a very common error. We even got a name for that category: off by one. Being told that you made a mistake at the spot where it happened makes it much easier to fix. In JavaScript 'foo' - 2 becomes `NaN`... which eventually will surface *somewhere*. `[][-1]` is `undefined` which may accidentally be coerced to `0` or 'undefined'. This is something that just wastes your time. Same thing with putting a typo in a property name or handing the wrong arguments to some function. The earlier you learn about these problems, the better. By the way, people were also able to write perfectly fine programs in ASM or by using punch cards. Personally, I think it's better to look for ways to improve productivity. This is what got us here.
Oops. On mobile, otherwise I would have gotten the actual link.
this is probably what you want to do: function Person () { /*....*/ } Person.prototype.blablabla = function (a,b){ /*....*/ }; myself = new Person; myself.blabla( 'jason' , 'compsci'); myself.handleSomeEvent = function () { /*....*/ }; anotherPerson.handleSomeEvent = function () { /*....*/ }; andSomeoneElse.handleSomeEvent = function () { /*....*/ }; var people = [myself, anotherPerson, andSomeoneElse]; // when 'someevent' is fired, call .handleSomeEvent on each person $(window).on('someevent', function (){ $.each(people, function (person){ person.handleSomeEvent() }); }); // when 'blabla' is fired, call .blabla on each person $(window).on('blabla', function (){ $.each(people, function (person){ person.blabla() }); }); also, if you want to clone a regular js object, use: var clone = $.extend({},original); 
I don't think there is a simple way around this apart from creating a wrapper class. Something similar to how jQuery works, where the jQuery object is always returned from a function even if there are no selected elements. Perhaps an engine similar to Sizzle exists but for general objects, but I do not know of one.
You could wrap this in "try" "catch" or made a wrapper method for making it for you. I'm talking about method like this - http://stackoverflow.com/a/6548416
It's not totally new, it has exactly 500 registered users and about 90 000 messages (80% of them in private rooms) on my server, but I'd like to welcome more users and more rooms (public or private). And I'd be happy to discuss here about Miaou.
Use coffeescript, and then this will look like: x = result.a?.b?.c? || result.x?.y? || result[0]?.a[n]?.x || "lol";
var x = (result) ? (result.a) ? result.a.b.c : (result.x) ? result.x.y : (typeof result === 'Array') ? result[0].a[n].x : null : null; Not tested.
Guilty as charged. I went though half of them already, once done with all of them will start reviews with the best one in my opinion. 
Yep, you can't solve this the way you would in C++ so you need to think of it in different terms. The best way I can think of in this case is to expand each term like this: var x = (result &amp;&amp; result.a &amp;&amp; result.a.b &amp;&amp; result.a.b.c) || (result &amp;&amp; result.x &amp;&amp; result.x.y) || (result &amp;&amp; result[0] &amp;&amp; result[0].a &amp;&amp; result[0].a[n] &amp;&amp; result[0].a[n].x) || "lol" It does look a bit verbose, but mostly because the example is so contrived. In practical situations it wouldn't be nearly as bad. If you really are doing such bizarre logic like this often, you can split it off into a function: var x = extractFirstWithDefault(result, "lol", ["a", "b", "c"], ["x", "y"], [0, "a", n, "x"])
Just do the simplest thing first and the take incremental steps toward what you want to build. Simplest 'alarm clock': window.setTimeout( function(){ alert('wake up'); }, 1000); Now maybe you want to call this function given an input box for the time. Then perhaps you want to update the UI instead of having an alert. Then maybe you want to be able to specify in hour of day as well as hours/minutes from now. Then you want to ajax in a youtube video while you update the UI. etc. Just slowly move along until you get each one right, then go on to the next one. It'll be a good way to learn each step thoroughly, build something you know works, and avoid getting frustrated by tackling too many problems at once. Building a robust alarm application that saves your session, let's you close the window &amp; come back and still alerts you is hard. Window.setTimeout is easy :). 
&gt; I don't think there is a simple way around this apart from creating a wrapper class. To be clear, it's impossible to define an object such that you can specify some kind of default value for `obj.x` when it would normally be undefined. You could do something similar with function calls, though: wrap(result).get("a").get("b").get("c") or: wrap(result).get("a", "b", "c") or even: get(result, "a", "b", "c") that would do what the OP wants.
Please no. Don't make exception handling part of your data flow.
Right that's what I was implying. Something that abstracts the interfaces to the values in the object. Although depending on what browsers they want to target there are [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get) but I've never used them simply because of the lack of IE support which unfortunately is something I always have to keep in mind.
I agree with your exception opinion (I asume you are talking about try/catch). So the wrapper method would be better.
Getters won't work. For a given attribute name like `x` you can define a getter function to be called when `obj.x` is written. However, you can't define a general getter that will be called for _any_ attribute.
https://gist.github.com/Ginden/b1ccdcf29a50119522d7
Not crazy about this method for a few reasons, but for one thing if you define `ckudf` outside the current function then it will fail if `result` is scoped to the current function. You'll have to redefine `ckudf` in every scope where you want to use it.
really interesting, we're curretly using echoplexus - https://github.com/qq99/echoplexus - on http://chat.tetalab.org and we'll probably give a try to your chat server.
I'm not crazy about it either, just saying this technique is available. you can do all sorts of nutty things with eval (including in-scoping of reusable function bodies).
Tried it out a bit and it has many interesting features. Also works smooth which is the most important thing. Oh, and it's cat related - this counts too.
"Crockford, the good parts".
Also don't google "google", you'll break the internet.
An alarm clock I would do in a language more suitable for for a desktop app, rather than a web app. The simplest solution would be like VB or something similar with an easy GUI builder and event handling.
I have found a solution to this problem. I used the Autodesk converter to make the changes and removed blender from the entire pipeline.
Works fine on my version. I'd suggest updating jQuery.
Use Canvas. There's many tutorials out there and you're bound to learn some stuff along the way about keeping everything neat so you can get the highest frame rate. I love Canvas, making a chess game in it would be neat! 
You're trying to autosize the field before it exists on the page. Try putting the `&lt;script&gt;` tag with the autosize at the bottom of the page.
Cool.
I tried on this page by using Chromium's inspector. It took a while and it broke inspector hehe.
Hey! I have just finished making big changes to everything. It should really freeze or anything like that anymore. It also support alot more features!!! Other than that its more code-ey stuff which wouldnt really affect what you see with the Demo :) The demo has been moved to: http://demo.ilikeprograms.com/BootstrapThemeEditor. Im currently inpatiently waiting for the DNS records to update and propagate :( EDIT: http://demo.ilikeprograms.com
I'm not trying to convince any one to use Dart. In one of my responses *to you* I even stated "I don't use Dart, so I can't answer in that context." I also don't see the relationship between appreciation and understanding. I understand JavaScript just fine, which is a large part of why I don't appreciate it. I am here because as much as I don't like JavaScript, I still have to use it. It is important to stay abreast of things in my daily life. I stopped paying attention to /r/javascript because of the typical "lalalalala javascript can do no wrong I'm not listening to you" attitude (and the subsequent, unexplained downvotes), as well as the thinly-veiled insults in many responses, like yours.
what I dislike is a framework becoming an industry "standard" and employers questioning your skill if you don't know a given framework. if frameworks are well documented with plenty of examples then this shouldn't even come up, IMO - because yeah, today's framework is gonna be obsolete in a matter of time and the amount of time has been getting shorter and shorter. 
Does this actually happen?? I could understand if there was a startup who needed a person who knew a specific technology stack because thats what they are using, and they need to work under a tight deadline/low budget I could also understand if an employer wants some experience with a JS framework, but not a specific one. E.g. they are looking for someone who has used angular, but if you used a different framework (durandral, ember, backbone, something else) then you probably would be able to pick up angular, as well. 
What an annoying thing to do to the user! Disrupt the entire page when they hover over a link.
I'm sorry, but it appears as though your post doesn't meet our [Guidelines](http://www.reddit.com/r/javascript/wiki/index), mostly because it really doesn't have anything at all to do with JavaScript, and is merely self-promotion. If you'd be willing to post a link to your source, or write a blog post about your architectural decisions, etc. then the post would be welcomed here. Thanks for your understanding!
Yeah a lot of people have said that! I learn so much by just trying to build stuff like this and r/javascript always has great posts about how to get started. Thanks. 
&gt; What makes a framework good? Productivity. For you and your team, over time. Sometimes this won't be apparent right away, when your project is small and young. A very liberal framework will let you throw together a working prototype very quickly, but may force you to thrash later because of bad design decisions it let you make. Likewise, I think a framework that lets a project continue to develop smoothly as team members leave and new ones are introduced gets bonus points. &gt; What makes a framework popular? Mostly low (learning curve / utility). Confidence in the framework developers helps. &gt; Is building frameworks good for the community? Absolutely. These are hard problems, and every solution informs every other solution. Everyone's learning from everyone else, and that's a great thing. &gt; How should a JavaScript framework developer get their framework out there? Make it good for starters. Throwing it in front of social media helps after that. I've heard about some interesting stuff on the JavaScript Jabber podcast. They do a nice job providing introductions to JS projects. I find that hearing from authors does a lot to inspire my confidence and get me more interested in helping out. Knowing about development motivation is big. Sometimes the pieces aren't all there yet, but knowing what a project is aspiring to can make all the difference in drawing support.
If this could be backwards compatible with IRC somehow, I'd be all over this.
This project is so much more impressive than the last time I saw it! The chat message-thread highlighting is awesome.
There are discussions from time to time on miaou over whether and how to implement a bridge with IRC in a plugin (miaou accepts plugins).
sorry maybe not javascript - although i'm seeing plenty of "must know node.js" but it does happen in java i don't care how widely used Struts and Spring are. if they are so complex you need courses to learn how to configure and use them then maybe they aren't such time savers.
I wish it didn't take 20 books to learn a framework.
Ah, fair enough. Yeah it's a bit difficult to conceptualize because of all of the hurdles you would have to overcome.. mostly not flooding the IRC server you'd be connecting to. Once you get past that I think it'd be okay, but there aren't really any good IRC libraries for node that are stable for use immediately, either, which is the other problem.
&gt; faster development stricter is better Forcing strictness will not always result in "faster development", unless you are already coding "strictly". There are plenty of great developers who ship perfectly good code that isn't "strict".
On the website, if you go to the first div under the #services section. Please add `overflow:hidden` so that you don't get that crazy horizontal overflow :) If you fix that, I will definitely look into using it :)
You mean in the introduction ? I'll look into that.
Same topic: http://www.reddit.com/r/javascript/comments/29r6dm/how_can_i_reduce_redundancy_in_my_if_statements/
It actually seems to, at least with the version Reddit uses. Open your dev tools and try it.
Hello, I am the author of Seth. If you have any questions or would like to see some code examples, I am here for you. Seth sprung out of an idea I had about applying set theory to a type system, which I originally modeled in Haskell. It has become a bit more generally applicable. The code is well tested and works in Node and the browser.
I love IRC, but I wouldn't have the faintest idea where to start, and I'm currently a bit occupied. I'm keeping tabs on the project though, I like what it is currently and I'm curious to see where it will go.
&gt; I do agree with Crockford when it comes to spaces vs. tabs. That topic isn't open for discussion. You just use whatever the official code conventions recommend. If there aren't any official code conventions for that language, you can just borrow the code conventions from some other company or make your own. If your company generally uses spaces, use spaces. If they generally use tabs, use tabs. Either way, you stick with that decision. Whoever made it. And that's the end of that. Personal preferences are secondary. I use tabs (tab-size: 4) for JavaScript/HTML/CSS, 4 spaces for Python, 2 spaces for Dart, and so forth. I used Whitesmiths, Allman, and the 1TBS indent style for a few years each. I have a personal preference, but it's just that; personal. They all work about equally well, really. JavaScript is a bit unusual. There is a technical reason to use 1TBS. However, there is no technical reason to use spaces over tabs or vice versa. Crockford is like the new guy who wants the whole company to switch to his personal style. That just won't happen.
The one that fits your workflow. Seriously, there's not a "best" right now. They have strengths and weaknesses. It's all about how those strengths and weaknesses line up to your project's needs. 
Awesome! Here's hoping that we're all able to make use of ES6 stuff sooner rather than later (looking at you browsers who like to do their own thing).
it is the slider thing. with the big "&gt;" on the right side. screenshots: [Imgur](http://i.imgur.com/cvsUjLo)
PR'd https://github.com/jquery/jquery/pull/1618
It recognises the gestures you make on your (touch) device, and emits some events so you can do cool stuff.
There are benefits to everyone using the same style.
Look into require.js. Unless you plan to use coffeescript or typescript, you can learn the one that any of them use. Edit: This was legit advice, please don't use downvotes to disagree with me. Instead reply to me and explain why you think my advice was bad.
[AMD is Not the Answer](http://tomdale.net/2012/01/amd-is-not-the-answer/). Not that I agree or disagree, but it's a good viewpoint nonetheless. In other news, [AMD is the Answer](http://geddski.tumblr.com/post/15994566577/amd-is-the-answer).
Sure, but which indent token to use isn't a decision for Crockford to make. He's not the king of JavaScript land. Even in tiny companies, switching from one to the other will cost a few hundred dollars. Everyone has to be told about it, everyone has to change the settings of their editor(s), and every file of every project has to be changed and committed. This will "just" take a few hours, which will "just" cost a few hundred dollars. Who'll pay for this immeasurable non-improvement? Crockford? Just switching to JSHint is clearly the more economic choice.
seems nice , but on my desktop the intro doesnt do anything special
I namespace everything I do as little modules. When I want to import one, I add a `&lt;script&gt;` tag to my HTML document -- preferably an inline one (automatically, with PHP's `file_get_contents`). window.carWash = new function CarWash() { var carWash = this; // Public properties carWash.total_employees = 4; carWash.employee_percentage_naked_ladies = 100; carWash.drug_testing_policy = "never-ever"; // Private variables var soap_brand = "noname-crap"; var water_allowed_per_customer = 10; // liters var max_vehicle_height = Infinity; // outdoors lol // Public methods carWash.wash = function wash (car) {}; carWash.pay = function pay (creditCard) {}; // Private functions function stealCreditCardNumberMuaHaHa () {}; };
I also put all my `&lt;script&gt;`'s after my DOM content, so the page can be fully loaded and styled before the scripts start loading and executing.
Nice post. I noticed the Dune references.
Backbone was designed to communicate directly with a RESTful backend interface, so if your backend supports it already (which I think MongoDB does), then it's just a matter of configuring your models to hit the right endpoints. Otherwise, you may need a RESTful lib/framework to sit between your backend and Backbone. For more info, see [Backbone.sync](http://backbonejs.org/#Sync), as well as the `Backbone.Model` methods `sync`, `fetch`, `save`, &amp; `destroy`. 
Thanks. Have you seen node-webkit? If so, what are your thoughts?
Great library that has really helped me in phonegap. So what's new?
commonjs + browserify is so far beyond anything else i'm surprised there is still any debate.
It would be good to mention source maps in the minified code section -- it might be a bit more of an advanced topic but they are so useful. 
Maybe it helps to think of the problem this way. You have a list of things, where only one single thing can be active at a time. You have transformations on those things, to show them or hide them, or to tell if they're visible or hidden. This can apply to anything, from numbers to DOM elements, and it can be represented in many ways, for example: // Transformations var show = function(xs){return xs[1]=1, xs} var hide = function(xs){return xs[1]=0, xs} var go = function(i, xs) { var out = xs.map(hide) show(out[i % out.length]) return out } // Example: var xs = [['a',0], ['b',0], ['c',0], ['d',0], ['e',0]] go(2, xs) // `c` is active //[ [ 'a', 0 ], [ 'b', 0 ], [ 'c', 1 ], [ 'd', 0 ], [ 'e', 0 ] ] go(3, xs) // `d` is active //[ [ 'a', 0 ], [ 'b', 0 ], [ 'c', 0 ], [ 'd', 1 ], [ 'e', 0 ] ] go(5, xs) // `a` is active, loops around //[ [ 'a', 1 ], [ 'b', 0 ], [ 'c', 0 ], [ 'd', 0 ], [ 'e', 0 ] ] With those basic building blocks, you can write functions like `next`, and `prev`: var isVisible = function(xs){return xs[1] &gt; 0} var idx = function(xs) { return xs.indexOf(xs.filter(isVisible)[0]) } var next = function(xs) { return go(idx(xs) + 1, xs) } var prev = function(xs) { return go(idx(xs) - 1, xs) } Now think, instead of having arrays like `['a',1]`, you have HTMLElements, in other words, a collection of DOM elements: var toArray = Array.call.bind([].slice) var slides = toArray(document.querySelectorAll('#slider .slide')) And the transformations operate of those elements: var show = function(el){return el.style.display='block', el} var hide = function(el){return el.style.display='none', el} But keep in mind that DOM elements are mutable, so when you `map` over them, you're actually mutating those objects. You don't need jQuery, altough it is very convinient, and it reads well; the DOM is quite verbose.
As someone with an education in mathematics, I think this is pretty neat!
What's new?
12pm @ Ugly Mug in Soquel.
From the [Github](https://github.com/hammerjs/hammer.js): &gt; Completely rewritten, with reusable gesture recognizers, and better support for the recent mobile browsers by making use of the touch-action css property when possible. Also support for multiple Hammer instances the same time, so multi-user became possible. 
I wish people would put something about the library in the title for library posts. Just a few words about what it is. Hammer is about as vague as you can get. 
&gt;when its respective button is pressed Uh huh... `$("button")` = any button element. **Edit:** Also, create a test case on jsfiddle.
http://jsfiddle.net/
I think I know you from somewhere :P
Thank you, I hope it opens some doors for the community in general. I was searching for set theory libraries and there just aren't many implementations. While the feature set (no pun in intended) is not complete, it is a start and just bringing more attention to set theory is reward enough.
No it does not. I had actually never even heard of Sets until you mentioned them (I did know of Maps and Weak Maps). Seth is functional, sets do not behave as a collections of objects that are checked for the existence of an given item. Seth creates composed functions that return Booleans to determine if an element is of a given set. The code examples showing a literal array passed in are a little misleading. Under the hood, the array is used to create a Boolean function. Seth is all function at its heart. Seth does take advantage of Array#map and other methods if they are available. The shims are local to Seth so you can avoid Seth's implementations overriding your own shims. The performance is already pretty great using just functions. Thank you for introducing me to Sets, I will check them out.
There is a JSHint extension for Brackets: https://github.com/cfjedimaster/brackets-jshint/
Thnaks!. I laught a bit because was closed as WONTFIX, and probably deserve that type of close. Haha. I don't think anybody will left this accidentally in the code. And people intentionally crashing javascript have many other ways. And according to this thread, not all versions of jquery are affected. 
node is effectively the same thing as CommonJS. tl;dr use Common JS and keep an eye out for ES6 modules. Facebook uses (modified) CommonJS. I built the first pass of Instagram.com with AMD and later moved it to CommonJS. AMD is strictly more flexible than CommonJS. But this flexibility encourages practices that lead to slower (cascading async loads of modules) or less predictable systems (I'd argue that, everything else held equal, a synchronous system will always be more predictable than an async one). I also think the tooling around CommonJS is probably better than AMD, but webpack supports both AMD and CommonJS and does everything you need and more so it doesn't really matter. CommonJS also has way more momentum in my observation and a decent package repo (npm). So basically I think that the additional flexibility of AMD are features I don't want (kind of how I feel about most of CSS) and the momentum behind CommonJS makes it the obvious choice. But for the love of God please use some established module system for your project, no matter how small.
Frameworks are great if they increase productivity, but they can be very prescriptive. It can make it difficult to change to a different framework later if all the code that you have written is tied to the first framework. It is good for the community to create frameworks because it increases the knowledge and experience of the contributors and thus the community as a whole. It is not good if the community blindly uses whatever framework has just been produced and finds later that it was not the best idea. This is where libraries are preferable, they should not dictate how the code you write should work and should be replaceable with a different library that does the same job.
Yeah, half my upvotes these days are to nudge up a comment that has sunk to negative for no good reason.
OP here. Currently only CRC32 and MD5 (through `SparkMD5` for now, Node's `crypto` soon) are implemented. The SHA family was next on the list but it appears the new web crypto API has no progressive hashing mechanism (for streams/files). If I were to implement the SHA family, it would most probably need to use Node's `crypto` and, in the browser, something like `jssha`. But I do not know of a browser lib which has progressive hashing for these. Also, this lib works on these types: - `string` - `ArrayBuffer` - `Buffer` - `File` (via `readAsArrayBuffer`) - `ReadableStream` Finally, this may well fall apart when you try require it with an AMD loader, totally untested on that end.
I had been trying to do the same exact thing for some time now but failed, as I was missing something. Thanks for posting this, it will really help me!
For people who want a two days pass to Code School: http://go.codeschool.com/To7k1A
I was undecided what I would do if it was my library. It was best to leave the choice to them. They decided they made the right choice for them :)
The concept is sound, though I tend to dislike having a library sitting between me and my ability to create instances. Because I also usually have either jquery or underscore available, the respective extend functions do this job for me. As in this: _.extend(Cat.prototype, Animal.prototype, FurryMixins);
You could use setInterval() and count downwards (it's not 100% precise... to do that you need to use the Date() object and check for seconds since started, but I'm guessing that does not matter) var timeout = (5 * 60) * 1000; var _interval = setInterval(function() { timeout -= 1000; // Do something with timeout here... its in milliseconds if ( timeout &lt;= 0 ) { clearInterval(_interval); } }, 1000); // Every second Edit: clarification, spelling
Note *experimental*. It's huge, it's slow and not really compatible with anything. However it is *not* a regex converter.
can you do anything about the space-bar scrolling the page sometimes?
I don't think your Start button is taking into consideration the position offset from the DOM elements above it. Took me a while to work out to click Start because the click event sits just above the text to the left. Same with the replay. On Chrome. Sweet game though, love the sounds. Edit: So the first time I played it, I got 1 meteor then 5/10 seconds later 2 more meteors came on screen... The second time I played it I had 5 meteors show up within the 1st 5 seconds. Was pretty difficult considering I'd only just started. Edit: score of 1953, really enjoyable. Shockwave is awesome, love the way you get blasted off too. Though I feel I only got that far with the score because of this random special power.
this is Firefox on Mac. can you return false?
Wow, this game is very fun. Good job! First I thought that it was just another Asteroids clone, but that physics is unexpected and hilarious.
I didn't initially get past the weirdness of JS syntax to represent the virtual DOM for both React and Mithril. Then React started to impress me and a friend reminded me Mithril exists. My only hesitation with Mithril is that it seems to lack the functional programming pattern of storing shared data in the common parent component and passing that data down the component hierarchy to children. I like how in React explicitly mutating the shared data re-renders the dependent hierarchy. Is it accurate to say that Mithril does not allow a parent component to pass children a value and then have a child trigger a re-render of all components that use the shared value when it explicitly sets that one value? It seems like Mithril doesn't allow the Flux pattern React favors?
How does it modify the code? The around meld can change the return value and prevent it from running but the actual function won't be aware of that, nor will the code that calls the function either but I'm not sure about that. 
Glad you enjoyed it. I did not quite understood your issue. What browser are you using?
Thanks! I glad you link it
A new module syntax is coming in ES6. This is probably the most future proof option. http://jsmodules.io/ Using the es6 module transpiler from Square, you can export to any of the es5 module formats if need be.
How do I javascript in something that is uploadable to Google play?
"Useful" depends on context. A function that's incredibly useful in one design context can be utterly useless in another. So as it stands, your question as it currently stands is rather vague. Having said that, you might find [the 'JavaScript' category of code examples on Rosetta Code](http://rosettacode.org/wiki/Category:JavaScript) to be interesting.
Could you not replace the method on the prototype and the caller is none the wiser? Somewhere you would have to do the replacement but just from the calling context it would be indistinguishable. It's would be kind of dirty and seem like magic but I think it might work. But that aside if meld is returning a new wrapper function that you have to call then that is indeed not AOP
Sorry for not giving enough detail. I meant functions that can be used in many different situations.
This flat out does nothing for me. No start button, zip. Asus android tablet.
Well my work is agency SEO and I'm often doing a lot of tasks in Google Analytics and elsewhere and so I write JavaScript bookmarklets to speed up the process of creating accounts and such. They enter in static information and submit forms and such with one click. For full fledged apps I have one that grabs data from Analytics using the Google API and then produces a relevant message based on the stats for that month (for each client). It basically takes the raw data and makes it human readable. Before Analytics let you export and import goals, I had a bookmarklet that would build five of our common goals that we use. One click per goal. Same with filters. Pretty much all stuff to reduce the number of input actions. A lot of this stuff was being done by hand before I joined the department and I've saved dozens of hours from all of these little improvements. I always have the mindset of how to do a task smarter with less work.
If you come from a language like php, it's natural to ask what the useful functions are because there are tons of global functions in php and knowing them is how you become productive in that language. In JavaScript, you want to learn about the various api's available to you. * Do you want to manipulate the DOM? Then look into jQuery 2+. This is good for beginners and serious developers and has thousands of tests to verify that it works across all modern browsers. * If you're not using it, it's because you want to dig deeper into JS and learn the fundamentals. If you are working on a serious project and are not using jquery, then you are likely using a different library like underscore, ember, meteor, zepto or angular. * Do you want to work with collections and lists, then check out underscore or the ecmascript 5 array methods. * Avoid anything referencing IE8 or lower, that shit is done. If someone mentions it, just push in their eyeballs and scream rape. (ok, maybe a little harsh, but look at the analytics.) * There are APIs for lots of things * date and time (Date object) * Timing and animation (setTimeout, requestAnimationFrame) * math, trig, random numbers, rounding, etc. (Math) * working with files, binary data, ect. * working with audio, video * Canvas and pixel control * geolocation * Asynchronous and out-of-band data (jQuery, XMLHTTPRequest, Sockets, Web Workers) * real-time communication, video chat and peer to peer data transfer (webRTC) * 3d (webGL) * working with css * server-side APIs are numerous and growing (see nodeJS) 
A fellow developer friend of mine just introduced me to this browser. As the alpha was just released, there are very few modules available at the moment, but this looks really sweet... 
I'm totally going to play with this some. Thanks OP
Because this is JavaScript, it's going to get a lot of attention, and people are going to love it inherently. It's likely critical opinions of it will be buried. That said, I need to ask, what is the sense in developing a new run time in JavaScript on top of Node.JS to use the Chromium API?
I had a look. The way its written, won't every object get multiple anonymous functions assigned to it? This seems like a terrible waste of memory. Better to assign a reference to the function instead like this: http://jsfiddle.net/7D3SD/3/
I believe you that it's simpler and that it has the potential to be easier to use than react.js. Perhaps it's just the documentation that needs one more iteration. One thing that I do think would help is a set of examples that use as close to 100% of the HAML-based syntax as possible (ie. don't even include a body tag in the example html) and a set that use HTML as the templating language with six custom tags instead of special keywords. Encourage new users to learn one feature at a time.
Different tools for different jobs. For complex games and 3d graphics I wouldn't recommend SVG, but for simple games such as yours and 2d vector graphics SVG can present an alternative. Generally canvas offers greater freedom to paint complex things such as particle effects and the like since it's not constrained by a DOM.
Same as the Atom text editor - customisability. People that already know JS and HTML can dive in and tweak their browser to their heart's desire. To add vertical tabs to Chrome, to use the example from the home page, you'd have to know C.
Can't wait for this to come out on Windows.
Didn't look at it too much, but I was really put off by its C-style use of underscores in method and variable names. The JavaScript world uses camel-casing for that.
There is touch ! It just doesn't work very well because I've nothing to test it on at the moment. The game can be played with a mouse by clicking inside the game area. I was hoping this would be all that's required to give touch functionality, but it seems it isn't. For instance, a long mouse press at the bottom of the game window should speed up the tetrimino's descent, but it doesn't seem to work on touch devices.
I see both arguments, but I can't help but get caught up in the fact that the author almost bashes the concept that anyone can create a WordPress site... On a WordPress site.
What type of security flaws would this have compared to more standard browsers?
If you read what zombie code actually is, you will understand that it has nothing to do with any video games http://zombiecodekill.com/2014/01/09/zombie-code/
If you need a really primitive template engine, look at riot.js' template.js, because that at least precompiles the templates. While being quite fast, it is not suited for more complicated templates; in that case, mustache.js is a better choice.
I like JavaScript, and you maybe able to build huge, maintainable apps with it. But with a team of programmer using Grails for MVC on java, trying to convince them to use JavaScript and node is not going to happen. It's not practical from a skill set point of view. Large apps are made by big companies that have to support old browsers. Even when JavaScript gets to that point in 7 years, it's going to be going up against things like ClojureScript. I'll state again, I like JavaScript. I also like guitar, but when a song requires a piano, I could use effects and audio tricks to make a guitar sound like a piano. It can work. But I could also just learn piano. 
Isn't this essentially the same concept as Firefox? 
It's not.. Chromium is like 6-8 million lines of code? Obviously not a small task to compile, but billions of lines is nonsense.
Will do! Thanks!
Because the point of the whole project is to build a browser to look and run however you want. They could show samples of custom browsers built with it I suppose but it's probably too early in the project to do so.
There was no discernible sarcasm.
We're having a blast using TypeScript, which is Microsofts bid to make big JavaScript maintainable. It is still JavaScript but with some standardised structure (ES6 style classes, arrow functions etc) and the sanity of explicit typing and compile time validation. It makes large codebases less *write-only*, but leaves no runtime overhead. Works great with node.js and browsers and you can still take full advantage of all the good parts of the JS community (eg: take stuff from npm &amp; bower, use browserify/webpack to bundle etc etc). I'd totally recommend it to anyone who has/sees issues maintaining large JS codebases.
Because detecting sarcasm over the internet is an easy task.
Glad to see async/await on the list for ES7
I'm not sure what the point is. What can I do with it? No offense, but customizing my browser isn't really high on my priority list.
I like this image: http://zombiecodekill.files.wordpress.com/2014/07/javascript-the-good-parts-the-definitive-guide.jpg?w=700
The problem with the developers is that if you ask ten of them wich is the best tool for a task you'll receive four different answer. Try to do the same in other competence area.... ;)
Congratulations. Making this game entirely without libraries speaks to your programming skills. &gt; Might dynamic SVG be a good alternative to HTML5's canvas? Nope &gt; What are the pros and cons of each? SVG is a vector based standard; canvas is a bitmap tool. One is not better than the other, they serve entirely different purposes. For instance, as others have mentioned sprites are better suited for gaming than vectors. Google 'svg vs canvas' or 'vector vs bitmap' if you want details. &gt; What about making an entire website in SVG? SVG is a tool for graphics not for web building. SVG is a XML language that can be embedded into XHTML but it is not a replacement for it. Part of our work as developers is choosing the right tool for the job at hand. You can always force a technology beyond what it was originally intended. This is a good idea when there are not other technologies available, but it a terrible one if there already are other technologies better suited. Building reddit on SVG would be a terrible idea even if it could technically be achieved. &gt;I haven't tested it in IE; only Chrome, FF, and Safari. My last piece of advice, if you are interested. The code you shared seems to my eyes like a port of C code (I'm not saying it is, I'm saying that's what it looks to me). If you want to eventually be hired as a JS dev I would recommend reviewing JS code standards, use of modules, prototypes, etc. I always recommend 'JavaScript Best Practices' book for newbies and experienced devs. Lastly don't forget that a web developer must develop for all browsers. Browser compatibility is one of the main things you would get asked in an interview. Good luck!
JavaScript will not get easier to maintain. ES6 *barely* adds features to make JavaScript more maintainable (lexical scope through the `let` keyword, and "classes"), and the finalization of that standard is taking an exceedingly long time. TypeScript, Dart, or something new will replace JavaScript because they actually fix JavaScript's problems and make maintenance and usability a priority.
It looks like the value you're setting for url is not a url but rather a file - passage.html vs. www.mysite.com/passage.html so that's the first thing. You can add any tags you want to a marker object, but I'm not sure if url is a built in marker functionality. IIR you'll also need to create an event listener on the map with an on click to open the link. Something like google.maps.event.addListener(markers, 'click', function() { window.location.href = markers.url; }) You'll notice that this won't work for the way you have your addresses right now which is actually just the name of a file. Most likely they should be something like http://localhost:xxxx/file or something like that if you're just running it locally. Case in point if you're using chrome you can open your console and type window.location.href='http://google.com' and your window will redirect to google Additionally since you're trying to do that to multiple markers, I suggest markers be an array you store all your markers in.
Pretty neat I guess. Don't see a huge difference here from just doing some concatenation. Little bit of a cleaner syntax though, and maybe I can set up some string templates to use for error messages message popups or something. In the time it took me to write this I actually do think its kinda useful, just wouldn't really call it an engine..
none, but the point is maintenance. Keeping up with that can be a fair bit of work, so I'm interested to see how much traction this gains given such issues.
A lot of the front end is implemented in JS+XUL, I believe.
This is a very good JavaScript library. May I know the license? MIT please :P
Yeah I was coming from ruby when I wrote this so wasn't used to js style for naming things. Will redo it so the methods are camelcase (on the fence about var names). Thanks!
[SpiderNotes](https://chrome.google.com/webstore/detail/spidernotes/mgghkmeinhhcldkigpioebfjfghdeofl) is a little just-for-fun project. Of course, there [are](https://keep.google.com/) [lots](https://evernote.com/) of great note-taking apps around, but hopefully SpiderNotes will be a good fit for some. The source code is available on [GitHub](https://github.com/spidernotes/). The [tech stack](https://spidernotes.com/open-source/) is described on the spidernotes.com website, but some of the bigger pieces are Backbonejs, Browserify and Google App Engine. Contributions of any sort would be very welcome.
Those are awesome, and I look forward to using them, shortly before I retire. Unless we outlaw old browsers, we will forever have old crap that we have to support.
Right, I didn't consider that.
Might want to rename it: https://github.com/ripplejs/ripple
Using tools like [regenerator](https://github.com/facebook/regenerator), it's possible to compile generators (and soon, [functions with async/await](https://github.com/facebook/regenerator/pull/101)) down to JavaScript that any browser can understand.
Yes, always keep a reference around to your markers.
I don't like the accompanying quote "Here's a book about the good parts, and here's a book about the bad parts" No that's not what the phrase good parts means. Good parts in this case means the juicy bits, the awesome shits. It doesn't meant the rest sucks, it just means that tiny book is just the surface peaks, but there's a whole shitload of iceberg to dive into when you want to.
&gt;Hands up, who wants to maintain 500k lines of outsourced Javascript? Only if it's in brainfuck.
I've grudgingly tried phonegap/Cordova, but hadn't heard about cocoon yet. Will check it out, sounds more like what I'm looking for.
Although I, along with almost everyone, bash JavaScript for its numerous flaws, what is great is JavaScript is a multi-paradigm language that can and is being taken in a number of interesting directions by the open source community. There is a wider understanding now that JavaScript is not like Java and can be more powerful as an FP language than an imperative language. Compared to many server side languages ES5 is still a primitive language but it has gone a hell of a long way since 1995. I think we will continue to see the EcmaScript standard lag behind the trailblazing technologies by about 2 years but it is important that we have that standard so that we can reduce the impact of the TypeScript/CoffeeScript/Dart split that I think is harmful to web development. ES6 is important although just another milestone in the journey. 
I know I know. I just thought it was funny. 
yeayyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy \^\_^
I think its more interesting to learn some tricks from than to actually use to solve template problems
Yeah and I'm just saying that's an editorial load of horseshit. The good parts of Javascript have made it one of the most prolific languages of all time. It's the easiest language to teach programming in because of its EXTREME ease of entry. The bad parts are often uninformed misconceptions of how programmers from other languages wish that it behaved, as apposed to actually learning how extremely versatile it is.
Hopefully, evergreen browsers will help these kinds of things come to fruition much quicker in the future.
Can you add a pattern match feature that works on array-like objects? Eg. t(arguments, [String, Function], t.pattern)
To Node's credit, it gets pretty good throughput per-process due to its non-blocking nature. A common pattern in Node is to design your app to not rely on intra-process/intra-thread communication, then use `cluster` and fork for every core your CPU has. Although, if you're doing something CPU heavy, rather than I/O heavy, Clojure will likely win.
Node is also nice as manager for a farm of heavy duty worker processes, using something like ZeroMQ to distribute work directly, or use a native module and build workers from Node.
It's competition, really. What if you disliked the top bar in chrome, or the settings page, or the way bookmarks worked. Then you create a component that is better than theirs (or the others) and if people start to use that it becomes the standard. That way we built the best possible browser to some extent. It's not something we just get, but requires work. If Breach can get a great developer base around it there is a chance it will compete with Chrome/ff/ie and thereby we all get better browsers.