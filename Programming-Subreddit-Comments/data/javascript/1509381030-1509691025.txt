I thought it was MtG
Yeah, that's a very distinct difference in behavior. Redux middleware allow a middleware to do anything they want with dispatched actions: log them, modify them, delay them, dispatch something else, serialize them and send them elsewhere, etc. Responding to a state change is a different concept entirely. I'll quote [another comment I made on HN recently](https://news.ycombinator.com/item?id=15519059): &gt; I've seen _many_ "Redux, but without $X" libs pop up over the last two years. Their existence isn't a bad thing - after all, Redux itself started as "Flux, but with functions instead of stores". &gt; That said, I do think most of these "Redux-lite" libs are missing the point of why Redux was designed the way it was. Plain action objects and reducer functions are a _very_ important aspect of Redux's design and reason for existence. Without those, there's no straightforward way to track the state updates, implement time-travel debugging, or use the hundreds of middleware that implement centralized behavior. &gt; It's not like Redux itself is an overly large library in terms of LOC, either. If you strip out the comments and error checks, [Redux's core fits in under 100 LOC](https://gist.github.com/gaearon/ffd88b0e4f00b22c3159), and I've seen miniature versions of React-Redux that aren't much bigger. &gt; Earlier this year, I wrote a pair of blog posts that dig into the history and intent behind Redux, why it's designed the way it is, and the reason why common Redux usage patterns exist: [The Tao of Redux, Part 1: Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/) and [The Tao of Redux, Part 2: Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/). Dan Abramov's post on ["You Might Not Need Redux"](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) is also an important read to understand the tradeoffs involved in using Redux, the limitations it asks you to follow, and the benefits you can get in return. &gt; So, while it's great that people continue to experiment with new ideas and build things that are inspired by Redux, I do feel like most of the spinoffs are throwing away the things that make Redux special in the first place. I'll also throw out Justin Falcone's recent post ["What's So Great About Redux?"](https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b), which is a fascinating read that offers insightful comparisons between Redux, OOP, and message-passing. 
But can you not see the problem? I need to have Node installed to have npm AND Docker so that I can get your package which will then install Node in a container, apparently to "protect" me from complications of installing Node which, regardless, I need to have to be able to install the package with npm in the first place. 
Yikes... How much do you know? Have you tried anything thus far? Are you willing to pay for a solution?
I had tried to throw it into an array to make it easy on myself. I had tried to put it into multiple classes but I really don't like splitting up my code. It really isn't a complicated program itself. But just don't have the tinker time to get it working. Depends on the price I guess haha. 
I would personally devote exclusive time to React for a while. It's the biggest of the 3.
Totally agree here. TypeScript is nice but you really need a solid understanding of React first before fighting your way through issues you'll run into between it and TypeScript. I say, do either a React project by itself or even React and Electron but leave TypeScript for your next project.
One can even reassign undefined to *whatever* outside strict mode. 
I did it in one day..even created a finished desktop app..although I wouldn’t call 1 year experience in node an experienced dev so it might take a bit longer but it is really straightforward :) 
Angular whatever is long dead ..doesn’t really have a future if we check latest npm stats and where the community is heading..almost all job offers I get are rewrites of an existing angular app to react or vuejs
Just check where software development was a few years ago..everything is changing and evolving..js is not changing that much from the global view
Not to sound harsh but isn't this something react 16 already does? What's the purpose of this? Also why would i use npm to grab a project that's the equivalent of const ShadowWrapper = ({ children }) =&gt; (children)
I've got years of dev experience, just not in the web world. 
Probably just take a hit on this project and Google "Javascript war code" or something and get something working for yourself. I guess the real lesson here is to watch your deadlines closer.
Yes it is man! But you know life sadly doesn't ever seem to pause for me to just work on this type of stuff haha! 
Not everything. Python, C++, Java, etc. Is pretty much the same setup, same best practice for the last 5 or more years now. JS has so many options for better worse. The only legit reason is that JS change so much because it is the only language for the web (plus it is a simple to learn and is a liberal language). Web development is in every parts of business nowadays.
Auto Import is going to be built in to the next release, too. I also recommend Document This, which adds a keyboard shortcut to automatically generate JSDoc comment skeletons with the types and so on already filled out, and can check if the signatures are still valid (works better with TS than JS obviously). If you write Go, there's a Go plugin by Luke Hoban that hooks VS Code into gofmt and so on.
VS Code comes with this built in. If you type 'doc' and hit tab, it will autocomplete a full HTML skeleton for you, with a couple of good default meta tags setting the initial scale and character set. And you've got the Emmett functionality too, where `(tr&gt;td*5)*10` will unfold to 10 table rows with 5 cells each.
But, that's other issue anyway. It's invalid OS issue. 
I would say no, they'd just be distractions, and would add some confusion without a big speedup. But maybe bookmark them for later. Prettier might be the exception, you can use it without thinking and it's nice if you ever work in a team. By default, it will just automatically format your code according to its style guide every time you hit Save. You can stop worrying about how to align, format, lay out etc your code and just let Prettier do it for you, and if everyone uses it, there are no more arguments about style.
OSX 90% of the time 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Javascript App Generator, NinjaCodeGen, beta.3 Release! • r\/javascript](https://np.reddit.com/r/programming/comments/79prrb/javascript_app_generator_ninjacodegen_beta3/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Well, there's no clear line between an IDE and a text editor. VS Code ships with Git support, a breakpoint debugger, some refactoring tools, a task runner, some static analysis tools for JS/TS and so on, so it's a bit more than something like Notepad++, but less than something like IntelliJ. As you want more of those rich IntelliJ/IDE-style features, you enable more plugins. If you enable lots of plugins, you might call it a more modular crowd-sourced IDE; if you disable lots of things, you might call it a simple text editor. Depends on perspective, really.
I've been there. I won't go into details, but it is possible, but you might lose sanity. I had to learn few techs at the same time while building project that depended on broken API that was wrapped in broken PHP code which was written over a weekend by college. My biggest issue was: Confusing Redux global strings... Everything else should work itself out over time. 
VS Code is free in both senses of the term (it's MIT licensed), and I believe MS are the #2 contributor to Electron, which underpins both Atom and VSC.
const applies to everything equally. The only reason it may appear immutable on non-objects is because it’s about *binding* and *not about immutability*. So you are free to chop and change object properties as much as you like since the original reference is the same.
Especially if you are going to use 3rd party libs, TypeScript gonna make everything much harder because default expectation for React is usually ES-babel
Similar to a project I assign. However, there are multiple solutions, and which one you should use depends a bit on what you've already been taught. A card game has two main issues to solve: 1. How do you represent the cards? 2. How do you represent the hands and the deck? Each of these has multiple solutions based on what you've already been taught. A card can be most easily represented by a single integer 0 - 51. You can then use (int)(cardnum / 13) to get a suit number 0-3 and cardnum % 13 to get a rank number. For many cases, this is all you really need, so it isn't often necessary to make a more complex card class. Since you are not required to make a user-defined class here, this is how I would represent the cards. You can also make a custom card class, but that is not necessary here, so don't worry about it yet. There are a couple of ways to think about deck and hand management, too. In physical card games, the deck and the hands are actually not arrays, but lists or vectors (or maybe stacks) You can do all these things in Java, but I'm not sure they've been taught to you yet. If you know how to build an ArrayList or Vector in Java, you can use those for the two hands and the deck. The key difference between these and the arrays you're probably used to are that arrays cannot change length, which makes them not suitable for card games where the number of cards in each hand changes. You can still get this behavior by making all hands 52 characters long and using something like -1 to indicate an empty value. A more elegant solution is to ignore hands altogether and to simply keep a database of card positions. So the index of this array is the card number, and the value is an integer indicating where the card is. For example, look at this array: 0: 1 1: 0 2: 1 3: 2 4: 2 In this array, cards number zero and two belong to player 1, cards 3 and 4 belong to player 2, and card one is still in the deck. This (along with a mechanism for converting each card number to a rank and suit number) is probably the best overall solution. 
Do NOT pay for a solution. Sooner or later you will be found out, and it just isn't worth it. 
js2-mode, rjsx-mode, js2-refactor-mode, magit, git-timemachine, git-messenger, flycheck, projectile, nodejs-repl, helm... so many incredible productivity tools.
The trick with Typescript is knowing when to disable the type checking - esp with 3rd party libs. Sometimes you just have to disable it to be productive.
&gt; Yeah, that's a very distinct difference in behavior. Redux middleware allow a middleware to do anything they want with dispatched actions: log them, modify them, delay them, dispatch something else, serialize them and send them elsewhere, etc. Responding to a state change is a different concept entirely. With Babydux it's the same thing, because every Action maps to a state change. Again, the difference is it's a "post-update" hook, which does not allow interception/modification/etc. And as I said, a "pre-update" hook (like Redux's middleware hook) could also be reasonable, and I am open to adding it in the future. Think of Babydux as an abstraction of Redux; it doesn't replace anything, it just offers a higher level API that gets rids of a lot of boilerplate and gives you a whole lot of safety. Try it out and let me know what you think - to me, as a longtime Redux user, the difference in developer experience when using Babydux &gt; Redux is really stark.
It's node, should be fairly trivial to run on windows without docker I would think.
TSLint, Path Intellisense, Git Blame, Chrome Debugger, Darcula Theme, and some other little things like framework/tool-specific icons and syntax support.
*Douglas Crockford https://www.youtube.com/watch?v=v2ifWcnQs6M&amp;t=5s
Yeah, it's true...it's just me hating on Windows. Tried to switch back to win many times, but whenever I had to write any code, it became such a huge pain in the ass to do anything on that OS related to programming...they promised so many improvements in Creators update, but it's still unusable for development...(unless ofc you are .net developer with VS, then you are in heaven)
My point is that while Babydux is clearly _inspired_ by Redux, it's _not_ the same in terms of capabilities and approach. What you refer to as a "pre-update hook" is core to Redux's implementation of middleware. Similarly, saying that "Babydux has reducers built-in" doesn't appear to be correct, based on this snippet: this.emitter.on(key).subscribe(value =&gt; { let previousValue = state[key] state[key] = value From what I see there, there is no "reducer" at all. It's a shallow merge, same as `setState()`. That also means there's no way for multiple reducers to respond to the same action, or to only update a deeply nested field in the reducer. Again, those are certainly valid design choices, and I can see how they're _inspired_ by Redux. But, to say it's an "abstraction of Redux" or "same as Redux" or phrases along that line seems misleading to me, because those choices lead to distinctly different behavior and design.
Huh. I didn't realise it was MIT licensed. That certainly makes me feel better about trying it. Thanks!
If you're looking to drop 1 of the 3 I would drop typescript. You will get the largest pay off from using typescript when your application is being maintained. Chances are if you are just learning react you will write 10,000 different small apps until you find what libs you like. In this phase you will be writting and throwing away alot of code. Since most of this code is never maintained worrying about typescript would be pretty pointless. 
&gt; Similarly, saying that "Babydux has reducers built-in" doesn't appear to be correct, based on this snippet Maybe we're defining "reducer" differently? That code is mapping an Action (`key`) and a state (`state`) to a new state. For performance it's doing so by mutating the existing `state`, but it would be trivial to keep it immutable if we wanted. Is this the difference you're talking about? &gt; That also means there's no way for multiple reducers to respond to the same action With Babydux 1 Action maps to 1 state mutation, always. There's no 1-to-many baked in. If you do want 1-to-many, once again you're free to use an Effect to do it. &gt; only update a deeply nested field in the reducer. There are no deeply nested fields that Babydux is aware of, only top-level fields. If you want to update a nested field, you have to replace the entire top-level property. Babydux does not share Redux's concept of lenses (in any cases, I don't think lenses are a core part of Redux, but they are a Haskellism for applying functions over nested state that makes a common Redux operation more ergonomic).
Found some layout examples here: http://element.eleme.io/#/en-US/component/container
Thank you!!!
I found this example couple of days ago https://github.com/ElementUI/theme-chalk-preview which is source for https://elementui.github.io/theme-chalk-preview/#/zh-CN
I have yet to look into jsdoc but I have always been intrigued by it. 
&gt; But you know life sadly doesn't ever seem to pause for me to just work on this type of stuff haha! Lame excuse. Do your work.
work on a large'ish JS project and contribute to it. Look for a JS library you use (2-3 k stars) and help out. Stop learning concepts for now, and start applying these concepts and get your "skill", and get your code reviewed with feedback by better developers. You can revisit those fundamentals once you get feedback. Follow their contributing guidelines, and make pull requests. 
Its weird hearing advice of drop one technology versus another. Especially when referencing TypeScript. It speaks more of people that have never used the language or use it based on their own poor experiences. Yes, you can learn all three. For TypeScript, just have the set up on loose and add typings where it would make sense. Start off writing JavaScript then when comfortable with typing, turned on strict mode. React is easy to learn there are tons of tutorials and CreateReactApp is awesome. There is a TypeScript version of this if interested. Electron is a different beast. The general concepts are difficult. React will help during the rendering process but understanding differences and communication between main / rendering process requires some work. Security is a concern since you are shipping chromium shell. There is just a lot of things to unravel with Electron. Honestly, TypeScript is the easiest since you can just use it like babel to compile ES6 code initially. React is very simple. and Electron to me requires the most work. 
Only one way to find out friend. I'd go for it. 
I'm a full time employee taking 18 credits.
This is great! Working on a team that's building a React Native app - This problem is a very common occurrence. Thank you for putting this together!
This article doesn't say much, imo. It barely mentions the api vs apis of other possible soutions. It's kind of a "we use it because we tried it and that's what we're still using".
We actually don't need to keep track of cards. So in theory we just have to randomize the number to a maximum of 13. I had asked him before the end of class today.
I am pretty sure that Java 9 is not the same as Java 7 ..just look at gradle..you use it only for mobile now..or .net, php..ai, machine learning, big data, vr..thing are moving on and that is how it should be
&gt;I am pretty sure that Java 9 is not the same as Java 7 ..just look at gradle..you use it only for mobile now..or .net, php..ai, machine learning, big data, vr..thing are moving on and that is how it should be No, you're JuliusKoronci.
I honestly think autocomplete is a bad thing while learning... You end up never typing the full names of functions or the full definitions for control structures, so you have a harder time getting them ingrained into muscle memory
Than it will be easy..react is dead simple, just don’t get dragged into redux and the ecosystem and you will be fine and electron is also easy to start with. 
&gt; ...taking 18 credits Well you're not even keeping track of your due dates, so I wouldn't be waving that flag too hard.
Let me guess a baby boomer? 
I'm working on it. Should have it done by no later that Midnight tonight.
&gt;I'm working on it. No, you're ForScale.
first thing google has made that i absolutely hate
Yeah I was just confused on how it would be formatting it
You can spend 1 or 2 days reading about each, but don't waste too much time on that as when it comes to starting a new project you will likely stare at the screen and wonder where do you start as its quite overwhelming. Typescript actually works pretty well in react for props and state, but as soon as you start to involve redux and other libraries you can end up in a fair amount of pain. I knew a little react and tried to incorporate typescript. Be prepared to get absolutely nothing done for a while (going around in circles for weeks) and end up in a massive mess of type 'hell' and being confused on how to structure your app. For example I made a chrome extension in typescript and react, but the chrome api's are pure javascript and using typescript adds 0 benefit there. Id imagine electron would be similar. 
https://github.com/MaximAbramchuck/awesome-interview-questions#javascript - A collection of blog posts on the subject, but check out the other categories for other languages and JS frameworks https://github.com/h5bp/Front-end-Developer-Interview-Questions - well-maintained list of actual questions that get asked in interviews
React (via create-react-app) and electron (electron-quick-start) are fairly simple. You don't need a day to get something running, a couple of hours at most. I had more trouble with typescript, all the reading and options and problems i ran into. I would maybe keep that for later. 
lol, no. I'm a millennial :)
Sounds like the perfect blog post!
Not as fast as JavaScript. I agree with Gradle. But, if you learn Java, the practices from 10 years ago are still the same. Features are not changed but added. The way you program in Java is still the same since I started in 2009. With Java, you can still make enterprise app with technique you learn years ago (well some adjustment will still necessary). JavaScript introduces new things every year, Yarn, Webpack, use of transpiler become common, you now compile your CSS, pack everything with Webpack. Things that was used religiously before now considered a bad practices. Popular libs went deprecated or outdated. I am not the only one who think this apparently.... * https://medium.com/front-end-hacking/how-it-feels-to-learn-javascript-in-2017-a934b801fbe * https://medium.com/@peterxjang/modern-javascript-explained-for-dinosaurs-f695e9747b70
Or an older CPU that doesn't support Hyper-V.
thanks... I don't really have a JS developer that I admire. Do you know any open source projects on github that I can contribute to? Is there a website where people will volunteer their time to review your code? I think this is the best way I'll improve is if a more experienced tells me what I'm doing wrong and how I can improve.
EditorConfig for VS, Prettier, Git Blame, Settings Sync
Ah even less shocking. 
Windows 10 + Ubuntu VM's for Node / build stuff.
I made a no-ampbot for reddit just two weeks ago but it turns out that only a handful of people are annoyed by amp and most people are actually more annoyed of the noamp bot. Anyways, I think I can turn the source from a reddit bot to a simple browser extension in a few days which will remove any amp-url and replace it with the regular url. Bad thing is that the extension would have to check every URL the user **might** click on as you can't effectively detect the source (noamp) URL from a URL only, you have to check for specific meta tags and/or other amp related artefacts. Maybe a community driven list of rules to strip out amp would be the best solution, so kind of like a ublock list which doesn't block but replace based on pattern matching. Are you webheads annoyed by amp? Do you even notice it? Is there someone who thinks amp is the great? During my testing I found that amp pages are really nice to read on desktop as they all have a simple layout without much noise compared to the noamp URL. But amp is certainly not needed for this, you can very well write efficient good looking news websites and even add an advertisement or two while using only 5% of the original bloat. Maybe the bloat is the disease of a every-growing-every-changing newspage which just grew and grew in size dur to customer requests until it cthulhu'ed it's way up to 20MB. An amp rewrite (albeit additional learning curve) suddenly turns this beast into a 60kb hedgehog - how? Maybe because they now have the backend already in place and just need to focus on frontend? Hell, just make amp a guide-only/best practices thingy for efficient mobile optimized articles, give them a big bump on the google index, and outsource the assets automatically to a Google cdn... No need to rewrite scroll mechanics on mobile at all. Oh well, guess that's a different story.
Lulz.
First of all, you need to format your code better for Reddit. Add 4 spaces before each line. Second of all, when you create object literals, functions defined inside of them will be bound to that object. The problem you're running into is that in your "iterator" function, you're returning a new object literal meaning that "next" is scoped to the object returned from "iterator". There are two main solutions, one being storing "this" in a local variable like you did. The second would be to use an arrow function for "next" iterator() { let iterationIndex = this.index; return { next: () =&gt; { if (iterationIndex &gt; this.index) { iterationIndex = this.index; } else if (iterationIndex &lt; 0) { return { done: true }; } else { return { done: false, value: this.array[iterationIndex--] }; } } } } 
Not really relevant — so in the screencap of the medium article is shows the web browser with everything but text. Is there a name for that? I don’t know what that’s called. I see it for Facebook as well, it’ll load up that black page and then fill in text and the actual body later. I know it’s not an image but I don’t know if there’s a formal term for it...
Ubuntu everywhere. i3 at work, gnome at home.
Looks cool! Can you please briefly how similar/different this is to swagger-codegen js???
I think his point is that you could have node 0.12 and his code has to run on node@latest due to &lt;insert feature here&gt; or you could have node@latest but his script depends on &lt;obsolete/removed api&gt; from node 0.12. 
The term I've seen used is 'skeleton screens'
I’m really not convinced by CSS in JS, after reading this my opinion has not changed. Just had a quick look and trying to do breakpoints with styled components is of equal madness. 
Sure. While I've never been paid to speak beyond the occasional $50 amazon gift card, through connections I made at conferences, I became a Pluralsight author. Had I not been speaking at those conferences, I wouldn't have done that, and it has paid well over the past 3 years.
I spoke with people from the AMP project ~2 years ago, and it was never a secret that Google search gives AMP preferential treatment. That was (and still is) its biggest selling point.
What? Redux is fantastic for anything beyond trivial applications. Lifting state and passing down handlers is nasty.
Thanks for all the upvotes!
Fuck amp! I already use [an extension](https://github.com/da2x/amp2html) but would welcome AMP bot as well, if just for spreading awareness of this plague.
Just curious. How and where do set breakpoints for CSS/SCSS?
I found these 2: https://www.npmjs.com/package/js-breakpoints https://www.lullabot.com/articles/importing-css-breakpoints-into-javascript
&gt; Maybe the bloat is the disease of a every-growing-every-changing newspage which just grew and grew in size dur to customer requests until it cthulhu'ed it's way up to 20MB. An amp rewrite (albeit additional learning curve) suddenly turns this beast into a 60kb hedgehog - how? tracking scripts.
There is plenty of innovation to come as in many ways the current ecosystem isn't even as good as what we had for compiled languages 20 years ago, or e.g what Visual Studio/C# had a decade ago. Browsers will soon understand modules, do dead code elimination, tree shaking, use http/2, streaming etc etc. All this basically removes the need for many things like webpack or at least we can make the whole process simpler. 
Thanks for putting this together. I've been working through part 1 and 2. I have had some trouble with the .css portion of the tutorial though. The whole beginning of the styles.scss file has problems: &lt;style lang="scss"&gt; @import "./assets/styles"; body { background: url('./assets/images/background.jpg') no-repeat I ended up having to remove the &lt;style lang="scss"&gt; tag and @import line. I also ended up with the background.jpg file not being found when compiling unless I put it in the Authentication directory. Otherwise, so far so good.
&gt; its biggest fuck neutrality im going to use my power to force the hand of developers. FTFY 
Hi Affekt, did you properly install sass-loader and node-sass on --save-dev? It's needed for the scss part.
awesome! thanks so much
Yeah. That's not a "reducer", that's a "setter". A "reducer" is explicitly a function that does `(state, action) =&gt; newState`. It's certainly possible that a reducer could act like a setter and just drop a value into place, but a reducer could respond _any way it wants_ to a given action. It's up to the user how deeply nested their Redux state tree is and how they choose to handle the update logic, but we recommend using [reducer composition](http://redux.js.org/docs/recipes/reducers/SplittingReducerLogic.html) so that each nested reducer function is only handling a small piece of the state. We also heavily encourage having multiple independent slice reducers responding to the same action as appropriate. Redux reducer and selectors can sort of be compared to lenses if you squint the right way, but they're definitely not the same. My post [The Tao of Redux, Part 2: Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/) quotes [several prior discussions from Dan about how lenses and cursors relate to Redux](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/#cursors-and-all-in-one-reducers).
Chrome Dev Tools works great for watching css.
I guess I’m the only one using Cloud9.
Upboat for Cthulhu. \m/
I'm in the same boat. However, if you want a real nice shell on Windows try cmder. http://cmder.net/ I love it.
Thank you e_to_the_pi_i,I'll take notice of the format next time.
CEO of Interview Cake here! Obvious bias :) We hate pricing people out. If you haven't already, definitely check out some of the *free* stuff on our site. Especially this new collection: https://www.interviewcake.com/data-structures-and-algorithms-guide
It's only transpiring the test - import has its benefits when using named imports (e.g. import { oneThing, anotherThing } from 'blah'; Much prefer that to the require equivalent - if I need another import, can just modify that line instead of adding more requires etc
aha thanks, I recently listened to you (i think) on "Learn to code with me" - Nice interview. I like the idea and format of Interview Cake. Does the paid content have a lot of Javascript specific prep? Or is it mainly general programming logic and algorithms?
I'm not going to google every acronym people throw around. You mentioned it like it was a common thing that everyone apparently is aware of. I'm 40yo and I've never heard of IRS in my life. You should probably rethink your position and try to figure out how it's possible that I have never heard of this thing called IRS.
I love AMP. Disclaimer: haven’t yet needed to write a site that needed to worry about being AMP compatible, speaking strictly as an end user. AMP, for all its other issues, does two things: makes my loads super fast, and strips out most of the annoying BS every site wants to load me up with. No pop ups, no “subscribe to this site”, and when I tap it the page loads nearly instantly- even when I’m on an extremely thready HDSPA connection. Couldn’t care less about tracking scripts. Don’t care about total data. All I care about is a good experience, and AMP delivers that. 
In the time it took you to be a whiny little bitch, you could have googled it Here, I'll help you out http://lmgtfy.com/?q=irs
What's madness about it? You just use regular breakpoints. https://www.styled-components.com/docs/advanced#media-templates are you seeing something else in the docs?
I think you might be misreading the Rx syntax. `this.emitter` is an emitter, or a sink for a stream of Actions. Redux doesn't explicitly construct a stream of actions, but Rx does. `subscribe` is the reducer part of it - it's fired whenever an action of the given type is dispatched. It's like having a separate reducer for each type of Action, and then composing them together. Also note the way Babydux's `set` is implemented: key =&gt; value =&gt; emitter.emit(key, value) `set` dispatches an Action, which triggers the built-in reducer, which updates the state, which then notifies any subsequent listeners. &gt; a reducer could respond any way it wants to a given action &gt; having multiple independent slice reducers responding to the same action as appropriate. That's what Babydux's Effect API is for. For example: store .on('someAction') .subscribe(() =&gt; ...) Babydux has built-in reducers, but you can write your own on top of that default set. The Redux version would be: let myReducer = (store, someAction) =&gt; ... The syntax is different, but the idea is the same: we're scanning a stream of Actions over an initial state, giving an infinite set of intermediate states. This is the conceptually beautiful thing about Redux, and though the API looks different, the idea is alive and well in Babydux. 
How you tainted the human race by reproducing yet? Do you plan to?
Here's what I came up with: https://codepen.io/anon/pen/xPbBeX?editors=0010 I think it covers everything except the multiple instances of war. I got distracted and got a bit bored with it and didn't have the energy to come back.. sorry bout that. BUT you're free to add that bit in yourself. Let me know if you have questions.
I don't know. At least I'm not a conceited piece of shit who thinks looking up an acronym is beneath them, but expects other people to go out of their way to explain things to them. God your parents probably wish they had gone for the abortion
Yeah, I may be misreading the Rx stuff, but it also sounds like we're kind of talking past each other here. Your `store.on('someAction').subscribe()` example appears to be allowing subscribers to the store to react to actions themselves, rather than allowing reducer functions to decide how to produce updated pieces of the state and notifying subscribers that a new state value is available. Very different approaches when you get down to it.
I'm a fan of TopTal's interview questions (they have way more than just js). They also have a pretty good blog.
&gt;I'm a fan of TopTal's interview questions (they have way more than just js). No, you're tenbigtoes.
Bad bot
Thanks!
This is a great conversation, I'm learning a lot about how to best explain the ideas here. `store.on('someAction').subscribe()` is used internally to update the store, but externally it is used to do stuff when something happens, like in Redux. Here's an example from an app I'm working on: Observable .combineLatest( store.on('distribution'), store.on('serviceAreas') ) .subscribe(async ([distribution, serviceAreas]) =&gt; { let points = await getRepresentativePoints(distribution, serviceAreas) store.set('representativePoints')(toGeoJSON(representativePointToFeature)(points)) }) When the `distribution` or `serviceAreas` properties on the store change, we fetch data over the network (that's what `getRepresentativePoints` does), then emit an action to update the `representativePoints` property on the store (that's what `store.set` does). The idea is that Redux's `subscribe` and `state, action =&gt; state` are awfully similar. The difference is that in Redux (1) the former can't update the state directly and the latter must, and (2) `subscribe` doesn't know what action triggered it. With Babydux (1) is impossible because there is no API to update the state directly even if you wanted to, and (2) collapses into something that looks a lot like a reducer when you add a lens to it. Hopefully that makes sense!
It is official; npmcharts now confirms: Angular is dying One more crippling bombshell hit the already beleaguered Angular community when IDC confirmed that Angular market share has dropped yet again, now down to less than a fraction of 1 percent of all SPAs. Coming close on the heels of a recent Stackoverflow survey which plainly states that Angular has lost more market share, this news serves to reinforce what we've known all along. Angular is collapsing in complete disarray, as fittingly exemplified by failing dead last in the recent Front End Developer comprehensive networking test. You don't need to be a Kreskin to predict Angular's future. The hand writing is on the wall: Angular faces a bleak future. In fact there won't be any future at all for Angular because Angular is dying. Things are looking very bad for Angular. As many of us are already aware, Angular continues to lose market share. Red ink flows like a river of blood. Let's keep to the facts and look at the numbers. All major surveys show that Angular has steadily declined in market share. Angular is very sick and its long term survival prospects are very dim. If Angular is to survive at all it will be among Typescript dilettante dabblers. Angular continues to decay. Nothing short of a cockeyed miracle could save Angular from its fate at this point in time. For all practical purposes, Angular is dead. Fact: Angular is dying 
I kinda wish there was an open standard that offered the AMP content experience without the vendor lock in
Same in that it looks at json schema. Different in that this currently only looking at definitions for CRUD and does not produce the API explorer, but instead produces more a fully working UI and client code. We have produced some server codes too and plan to add more. Also this does not rely on java and is using angular. 
The simplest way would probably be to assign the global yourself after importing it. import $ from 'jquery' window.$ = window.jQuery = $ However, since imports are hoisted (same as `function` and `var` declarations) this might not work if dependent libraries require access to it, since they'll be imported before jQuery is assigned. To solve this, use require. window.$ = ... require('jquery-dependent-1') require('jquery-dependent-2')
Enjoy the ban.
Fuck AMP. It's Google's attempt to centralize the whole internet on their own servers and increase user surveillance while decreasing decentralization and influence of third parties.
Hi /u/AllsWellThatsHaskell, last warning on the personal attacks.
I wrote a tutorial earlier this week on how to use web components: https://ayushgp.github.io/html-web-components-using-vanilla-js/ This is a description of approach I used to create components.
Is there a react native component library with a similar design aesthetic? I think this looks great
Angular is a complete structural framework that is used for developing dynamic web applications Whereas React.js is an open-source JavaScript library that was developed by Facebook for creating User Interface that could handle change in the underlying data over-time. The choice between angular5 and react solely depends upon the nature of the application that is to be built.
No offense to your article, but my opinion is your style for template generation is a bit old school. lit-html offers some ways to generate templates efficiently with some really cool logic for the next re-rendering. Also, html imports is on it's way out. Webpack and loaders won the war.
FYI, you can achieve this same level of smoothness by setting the canvas context [imageSmoothingQuality](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingQuality) property to "high". Works in Chrome and Safari (not Firefox tho). Live demo: https://jsfiddle.net/e0ae3vw6/
Can anyone comment on how this compares with Vuetify?
I spent much of last year testing all the leading IDEs. IntelliJ won hands down for me. So far I’ve had no issues and it still feels like the right decision. 
OSX at home and at work (though I also work on a bunch of RHEL servers at work). I absolutely have to have a Unix-like OS, so Windows is right out for me (despite the recent addition of a Linux shell). My work pays for my hardware, so I don’t care about the Apple tax. 
I actually wanted the tutorial to be without any dependencies(except polyfills) hence the direct manipulation. I mentioned about HTML imports there and I'm currently reading up on how to replace them with something similar in the tutorial. 
Mainly general data structures and algorithms stuff. Just a couple JS-specific questions: https://www.interviewcake.com/question/javascript/js-scope https://www.interviewcake.com/question/javascript/js-whats-wrong
Redux is great if you know it. But if you are first time diving into react at the same time electron than redux is too much I guess..it is not something you can master under a day or week
+1 Fuck amp
did you just Google it?
I heard AMP secretly runs your microphone in the background and speeds up websites when you say good things about Google
Try with MEAN framework!! So easy and will complete in few hours/days.
That's a bit too lenient, don't you think? I mean, I feel like it's pretty obvious by this point that they aren't mature enough to be a decent member of the community. Might as well ban them
Try dotnetcore or loopback for api and vuejs for front end. Can't beat them in terms of fastest development time.
Because "A Desktop UI Library".
I'm aware of that. I plan on pushing the container on a public Docker repo on an upcoming release ; makes more sense.
[removed]
ಠ_ಠ
Yah, being able to write a web element from scratch is super useful. I wonder if teaching templates is really all that useful even (from a teaching perspective). I mean, it's cool to get syntax highlighting, and there's some kind of speed boost in cloning, but it kind of seems like a distraction unless you are really concerned for performance. I personally found the real a-ha! moment occur with Shadow Dom V1 slots. Might make a good next article?
They pass it off as AMP getting priority because it performs better, which is a lie. Any time you bring up the carousel with a member of the team they stop replying. Liars. 
I use feathersjs.https://feathersjs.com It has cli to generate services and a js client which means you dont have to write the api calls. For frontend vuejs with http://element.eleme.io/#/en-US/component/button and some dashboard templates like this https://github.com/cristijora/vue-paper-dashboard These options helped me build prototypes with auth and a couple of pages under a day. Its a really good combo. Another alternative is loopback for your api but loopback is somehow bigger and harder to grasp.
Yeah it actually took me a lot of time to wrap my head around slots. I was thinking of writing around 3 more articles in the following order over the next couple of weeks: 1. Attributes 2. Slots 3. Styling using new selectors like slotted Maybe one more comparing React and how it maps to web components. 
I like yeoman.io, it has a lot of templates to setup your boilerplate code.
Rails
Awesome! Will definitely keep an eye on this one.
If you are under a deadline, go with tools/templates/frameworks that you already know - and use a code generator if appropriate. Best strategy: 1) Design your data models up front. 2) Generate CRUD code from your data models. 3) Add Authentication/Authorization 4) Voila NOTE: - Django already has a built-in admin solution + python is a very productive language. - If you are comfortable with rails, check out activeadmin - If you are using mysql, search for mysql code generators - Use existing templates preferably bootstrap 3 or 4 (mobile friendly) - Don't waste too much time on the front-end customization. Keep it simple and functional and minimal. Best of luck.
I noticed, it lives in the same github organization as moment.js. Is it going to replace moment in the long term? I found a page in the docs which explains the differences between the two https://moment.github.io/luxon/docs/manual/faq/moment.html 
&gt; trying to do breakpoints with styled components is of equal madness. I don't understand this sentence. Having a breakpoint in styled-components is just like having a breakpoint in CSS? const Block = styled.div` color: blue; @media screen and (min-width: 500px) { color: red; } ` It's just a media query like you would have in any other `.css` file! styled-components generates actual `&lt;style&gt;` tags with actual CSS, so we don't have to hack around media queries or pseudo-selectors, we support everything that CSS supports. See my blogpost about the difference between inline styles and CSS-in-JS: https://mxstbr.blog/2016/11/inline-styles-vs-css-in-js/
I like AMP. I don't see anything wrong with it. Tell me by I should hate it
Yes you’re right, thank you guys. I skimmed over this one too quickly. 
If people just made their mobile sites not suck then we would be fine. 
I don't really see that much of a change..we have es6 so we have different variable declarations and a few utility functions(map, filter, reduce) and yeah thats the gro of the change, maybe arrow functions..pretty much the same change as when they introduced lamdas in java(check the changelog). Yeah there is webpack..but if you think about what it is than it is just a build tool, grunt, gulp, webpack they just take your javascript and build it the way you need..the javascript part will remain the same. No rocket science there. npm or yarn who cares, they do the same even use the same file they just install packages. So at the end not much changed, what changed is that we have new libraries and frameworks which became popular and promoted a certain approach to SPA's. It is like if a new Spring competitor would emerge and say you can do it in an other way and a lot better. But see Java..the faults of the language and need for change actually gave space to Kotlin..which is like typescript to Javascript..but you actually can write Javascript in Kotlin :) ..so basically Javascript is like PHP after 2005 when composer and all the fancy frameworks emerged. Everything is cooling down now and we have React and Vuejs and some kind of approach to work and that will last at the front end..same with nodejs..not much to invent there..will be more like focus on frameworks and libraries
Bad bot 
If I'm building something out quickly I use firebase 
Just a couple of examples from searching for "review" in this subreddit: https://www.reddit.com/r/javascript/comments/5z8hdc/code_review_is_my_code_poorly_written/ https://www.reddit.com/r/javascript/comments/6ofd2w/can_someone_do_a_code_review_on_my_first_public/ https://www.reddit.com/r/javascript/comments/rbgyk/can_some_one_do_code_review_for_my_assignment/ https://www.reddit.com/r/javascript/comments/6516f9/can_someone_do_a_code_review_on_this_snippet/ Not all get the same kind of responses, though.
Thankx for pointing that out, my motivation was to play with the pixel manipulation and later it concluded to support of image loading, form files and URL load with unified interface. I also added canvas resizing for cases when input image is too small, it gives a slightly better quality. I think I will include imageSmoothingQuality usage in the function, if the browser supports it. For now, I guess, the solution can be used on slightly older browsers.
The proposed function can produce URIData or Blob data, that can be transmitted to the server using old foms with hidden inputs or new [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) methods
Well your post tell me there are many changes, even things I have never heard before :). Between Babel JavaScript and current non-Babel JavaScript there are a lot of things changed. The style of coding is also way different. All in all, it is up to you to admit or not. JavaScript changes so much, for all coding style, environtments, and best practices. They are all for better or worse. I have found a lot of posts in Medium that expressed the same. One point of this post is to know whether JavaScript is still newbie programming language. Some years back I recommended people to start with ActionScript. After dead of Flash, JavaScript become better entry-point. But my doubt grows as JS become really hard to get into. I don't think everything is cooling down just yet though.
haha..yeah I gues it depends on the point of view..I think Javascript was always a hard to grasp programming language..but I mean real Javascript not JQuery :) ..so it is more like standardizing for me. from having no best practices we got to airbnb and a more clean style of writing code. I can agree that the environment changes and it can be overwhelming for newbies..but than again you can just take a starter kit and don't worry about the environment. I take it more like after 3-4 months you can actually get employed..for Java you need 3-4 years :D
I take it you've never written an Android app.
But AMP is an open standard. What would they need to do differently?
My goal isn't to be toxic here but I would like to give a warning to stay away from this library if you can help it. This library is from the moment.js guys. I'd like to point you to this issue: https://github.com/moment/moment/issues/2373 This issue was made in mid 2015 about modularizing moment.js, and they failed to make any significant progress or give any sort of confidence that they would address this. date-fns popped up to fill the space moment.js did not fill, and literally a full 2 and a half years later, they finally sort of address it, with a chainable style approach. I'd advise using date-fns. It's a great library, much smaller than moment.js, and we've been using it in production for quite some time with decent success. Edit: You also have some other popular libraries that are similar to this: https://smallwins.github.io/spacetime/
&gt; Months in Luxon are 1-indexed instead of 0-indexed What is this?! Blasphemy! 
I still think, given how, in your own words: &gt; I don't want people to handle the whole NodeJS side. I want the project to separate it's own tech from user concerns. you should really, really look into zeit/pkg and consider distributing your app that way. The way you do it now just doesn't seem reasonable. For example, I really like the idea of your app, I am into Swagger/OpenAPI, work as a "full-stack" developer, have legitimate uses for Faker and Casual from time to time, and your app should be a Godsend... except "Wtf why should I need docker for it!?!" I mean. I'll still come around to try it (probably figure out a way to install it natively in a nodeenv) but I'm not sure you've reduced user friction with your choice of distribution method. In fact, from the sheer fact that it is highly unusual as it's neither a case of `npm install ..` nor `docker run ...`it's quite obvious **why** you've actually **increased** friction. And Pgk would make it cupcake-easy to support Windows users Just my 2c + a tiny rant.
I don’t hate it but the one thing that annoys me slightly is Google’s cache of AMP pages. It’s just not a great experience - top bar is annoying and people share Google’s URL instead of my own. What’s the point of making faster-loading AMP pages if they’re not loaded on my site? Google may as well just cache my regular pages. 
On a more serious note, this is an unusual design choice for a JS date library. If your project expects zero-indexed months then will make adopting Luxon less of an easy drop-in replacement for native dates or some other date library that you might be using, and more of a serious refactoring. I wonder what was their reasoning behind this decision.
While I personally wouldn't do this sort of thing in the form of a web page, I think you should _at least_ consider: - using a `&lt;textarea&gt;` instead of an `&lt;input&gt;`. Use the contents of that as the input of the transformation. - putting a `&lt;button&gt;` and running the transformation on the click of the button instead of on page load - adding some other inputs to insert the x and y offsets. Having to edit the source to set your inputs and reloading the page is cumbersome. You also might want to use regular expressions to greatly reduce your code.
MeteorJS has enabled me to go from idea to code pretty quickly! Built-in MongoDB, easy commands to target mobile devices in app form, built-in User/Auth system. Just a thought
Looks pretty good. Moment has long been the datetime champion but it's starting to look pretty dated towards the end of 2017. Do you know if date-fns has timezone support? moment-timezone is super nice.
What version of Node are you on? Seems like it doesn't understand optional arguments.
Very excited that someone has replied! :) (been pulling my hair out over this for the last few days). pi@raspberrypi:~ $ node --version v4.2.1 
That is a pretty old version of node and apparently it doesn't support default parameter values.
I'm installing node from here: http://node-arm.herokuapp.com/ That's a wget then sudo dpkg -i node_latest_armhf.deb Any ideas how I would get the latest version?
It's possible that that's the latest version that works on a raspberry pi. The simple solution is to remove the part of your coffeescript that uses the default parameter and just check for an undefined value in the body of the function and reassign it.
Honest question: what use cases does this have? I've always been underwhelmed by this set of Web standards. I appreciated the effort to standardise something in this spirit, but it seems to fall significantly short of a complete template and data binding engine like Svelte, Angular, Vue, or React. It seems more verbose, less easily dynamic, and lacking in functionality like conditionals.
I upgraded to 5.12.0 (nodejs this time) - still same problem. I then upgraded to 6.11.5 (also nodejs) from deb.nodesource.com and it now starts up! Unfortunately, whilst the site loads, it's blank, but I think I can take it from here. Thank you very much for your help!
I've been doing web dev for over a decade, and i have no idea how frameworks function, so i'm not so sure about that.
Fair enough! I'll be looking into that, thanks for the feedback :)
I'm using these on (one of) my current side proje... https://www.reddit.com/r/javascript/comments/78u3u0/html_web_components_using_vanilla_js/dox41af
Yes, both are showing as dev dependencies and all other scss stuff seems to be working fine.
&gt; Are you webheads annoyed by amp? TLDR; It might be nice to have the single page load with content, but I don't think it's worth the investment in time to develop and maintain. You simply don't see the ROI. As a developer, AMP is good for content that's text heavy or not very dynamic in nature. It's good if you are sitting around twiddling your thumbs looking for things to do like make a secondary rendering path for your content. It's not so great with pages that have dynamic content, account based content, or content/structure that changes frequently or changes to keep up with trends. The premise of AMP is to provide (mostly) pre-rendered HTML with fixed sizes of elements, singular css file (or more precisely, heavily in-lined styles and elements specifying exact widths and heights defying everything learned over the past two decades), no third party scripts (except Google's script and cached CDN scripts are out), and very strict requirements on layout (you basically pick from a set of layouts). This means that if I wanted to provide amp version of our e-commerce pages I'd have to maintain two different rendering branches or litter my render path with a bunch of conditions to specifically handle AMP. It comes with special tags and boilerplate that must be present so converting your existing site can be tedious. &lt;img&gt; tags are invalid, for example.
So much this!
Looks like a subset of the things that Wappalyzer detects: https://wappalyzer.com/
go date-fns imo
Why not just make contacts and index two sub components under one app component?
Cool! But I know I can do that. My question is **"Is it possible to have ReactJS render multiple HTML files like it is a classic ~2005 websites? If it can how?"**. Just for curiosity sake.
In React HTML does not exist and the concept of a "page" is only holding you down. Think in components and everything will be easier. Yes, eventually you render a root component into a dom node, but you could just as well [set up a router](https://reacttraining.com/react-router/web/example/basic) and link /contacts to the `Contacts` component, /about to the `About` component and so on. 
Cool. So it is not possible to have separate index.html, contacts.html, ... a la classic HTML templating engine (Mustache, Jade, etc).
The above is how a single page application does it, no matter how many routes it can yield. If you really need separate files like in the old days, this is more a task for webpack. [Stackoverflow](https://stackoverflow.com/questions/39798095/multiple-html-files-using-webpack) should cover it. As for React, it's just a view layer. It's usually driven by webpack, but your approach is entirely possible. That's how site generators like gatsby work, too.
React doesn't 'render html files'. It can make it seem like that to a user, but just like in 2005 - when the user comes to your site you serve them a html file. The html file loads a JS file. It you have a single page app, essentially you are 'tricking' the web server to serve index.html for every url, and the routes are handled in the JS.
Didn't know about wappalyzer, thanks for the heads up! :)
Alright thanks, I know how routing works, .... I just started with ReactJS and want to show make some prototype for off pages with it. Then, I realize there is no option to make multiple HTML pages in a project.
Like they said in the linked question. Create multiple entry points and link each chunk into the HtmlWebpackPlugin and that'll do it. Best of luck!
&gt; React doesn't 'render html files'. Nice point thanks....
The link did not appeared at the first time I saw your post. That is way too much works than using plain ol' Mustache + HTML + JS + CSS. For my purpose I will not use React.
Well, what stops you from just using HTML + JS + CSS + React. Inspect the source of this HTML file for instance: https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html It's a generic HTML file, but can tap into components. 
Isn't using CDN bad practice? I know I can do that as well.
You can use local files. But it's easier to share right now, otherwise it would have been a zip. ;-) Thinking about it, maybe stay with mustache if it suits you better. Doesn't feel right to load the entire framework shebang on every page your visitors click on. This is what routers solve, but if that's not what you're after, i think it creates complications that aren't warranted.
Hi /u/Twanekkel, For javascript help, please visit /r/LearnJavascript. Thank you!
I am referring to this SO: https://stackoverflow.com/questions/41885560/why-should-i-not-use-cdn-for-react-babel. This is for a job interview in local Maker's Lab. Although I will not be worked for doing 100% web dev there will be some occasions of web development. I am not confident if I can show something that is not the best practice.
Will do, thanks! 
This is the core of the issue. If people want to stop AMP, they need to make their sites not suck. Don’t prompt me for a newsletter. Don’t pop up a half screen ad for your latest article. Don’t get in my way, and above all don’t make me create an account just to view your content. Modern web content presentation makes me want to scream. 
Are you serving over https?
There are a number of ways to make these components fully reactive with minimal JavaScript. I'm working on a project right now that uses ES2015 template literal tags and will reactively parse the HTML similar to React's render function—it also includes support for Angular-style event and property bindings—[you can see the code here](https://github.com/calebdwilliams/templiteral). It's still really new though, but I think it has promise. Also the Polymer guys recently released a similar tool called [lit-html](https://github.com/PolymerLabs/lit-html) that does the same thing, but without built-in event and property binding (although I believe it can be added easily enough if you write your own partCallback for their render function.
OS X at home, windows at work. Will probably switch to some Linux distro when I get a new laptop I can use at home 
I have 0 experience with React Native so I can't comment on quality but Element is based on the Ant Design Language which has a RN version: https://github.com/ant-design/ant-design-mobile
Serving from localhost which should work as well.
The best way to convince people is to appeal to their ego, vanity, laziness and fear. So praise them for mastering the really hard stuff (the backend) then explain how nice and easy it would be for them to just build Rest apis and get that pesky front end stuff off their back. Then throw in some horror stories about SQL injection and xsite scripting because of a messy front end with no clean secure Rest apis. **Edit:** Thank you fellow Redditors for the gracious upvotes. However I'm afraid I forgot the most important part - The ego appeal. The praising is about vanity. To appeal to ego we must give the feeling they are in charge and are making the important decisions, and for this we use the illusion of choice: During the presentation, you show some flaws of the option you dislike and the benefits of the option you want. However it's very important to be subtle here. You should never point out the flaws yourself but they should be apparent to the audience. You should even consider to argue against the flaws and disadvantages of the option you don't want but in a not very convincing way. This way the audience will feel smart when they see the things you don't, especially the one with the biggest egos. And when it's time for a decision you should be very humble and not favor any option, but the information shown in your slides should make the decision easy. You can also step this up a notch by *only* presenting options you actually want (the full fledged illusion of choice), but make it appear there are big differences between them and that you must have other more competent people than you making this important decision. And by coincidence this happens to be the way the world is pretty much ruled. Take the latest US election as an example. I admire every American who did their duty and voted. But I'm pretty sure most of you would have wished for some better candidates than the ones presented to you as the only viable options - The illusion of choice. 
oh man I love this video +1 OP.
YOUR DATA WON'T EVEN DESERIALIZE!!! 
I think you have a misunderstanding of how React works. In normal usage, React does not "render HTML files". You load the React JS library into a given HTML page, and then use it inside the page to render more HTML _inside the existing page_. That existing page could be almost empty, or it could be full of other content. Each individual HTML page that loads React would act as a separate React application. So, you might have `index.html` render the `&lt;MainApp /&gt;` component and all of its children, while `contacts.html` might render `&lt;ContactsApp /&gt;` and all of its children.
or WhatRuns
Host a weekend hackathon. Have two teams. One using Knockout.js and jQuery, and one using Ember. The goal of the hackathon is for each team to build the same minimum-viable product. It doesn't have to be a complex product, but it must have some representation of solving the problem your agency most commonly solves. So if your company does short-lived ad campaigns, then pick a random brand and do an ad campaign for them. Or if you do ecommerce, build a tiny little online shop. Both teams MUST agree on and build their own version of the same product to the specifications outlined. Give yourselves 24 hours to complete the project. When both teams have finished, get someone to judge you on these metrics: - How long it took to finish (faster = better, obviously) - How stressed out either team is during the work (less stress = better) - How relieved each team is when the projects are finished (more relieved = worse) - The number count of total code reviews (less = better) - The average time between code review and merge (less = better) - The size of the test suite (measure this via coverage) - Of the two projects, which one is the most complete Have someone record these findings as a table of comparison and present them to management along with referenced studies into the effects of stress on productivity. In other words, let the work speak for itself. 
Wappalyzer is great! 
wait, who is the zealot here again? There are much more secure/performant/mature/reliable options on the server than js, why are you closed minded about them? Have you ever been on call? edit: it has nothing to do with spa for that matter. And nothing stopping you from having a standard approach for the client code, but that pretty much HAS to be js these days, not by choice. If your server team can't provide finer grained api than reload the whole page, that needs to be addressed, but not the entire stack. Maybe have them look at vertx and possibly kotlin if they want something reasonably performant and well supported with GOOD tooling and maybe you can add any reusable javascript in your own verticle at some point (if it doesn't suck).
or https://builtwith.com/
Just installed, this will be really useful thanks! One thing I've noticed is it shows React on every site regardless if it's used or not for me, e.g. https://i.imgur.com/f63rARD.png May be because I have the react dev tools also installed ? 
Are you sure you don't have any extension or script installed that injects React into the page? I have the React DevTools installed this is how the angular page looks on my side: https://i.imgur.com/rx8diXr.png
One thing about best practice...there really is no such thing as best practice. There will be great solutions and terrible solutions, but no single one is going to be the "best" so I wouldn't worry about that too much. Just find a solution that you like and understand, and know the pros/cons of it.
How does this work if the source is minified?
I'm talking purely client side. I have no issues with .net on the back end.
Forget about single-page applications. They seem very attractive on the surface - but too quickly do you get sucked into the "maybe this should be universal" and the "i really want to use these .vue files to keep things organized" and all of a sudden you're knee-deep in a webpack config that you've been fiddling with for 3 days. Just go with a classical server-rendered MVC framework. I personally am a fan of https://adonisjs.com/ AdonisJS is inspired by Laravel - most of the structure and syntax is as close to Laravel as possible. It comes with this out of the box: - Validation - ActiveRecord SQL ORM - Expressive Routing - Built-in authentication via session, JSON Web Token, API token, Basic Auth and Social Login - Templating via nunjucks - Dependency Injection - Mail - Websocket utilities - Middleware pipeline - `ace` command line tool for generating models, controllers, etc - SQL migrations - Database seeding - Database seed factories with random data generators - more i have not mentioned And it uses generator functions so there's no such thing as "callback hell" in AdonisJS. AdonisJS is *very* opinionated, but despite that, it really gets out of the way and just allows you to code. It has everything you need to just buckle down, focus and write code.
I'm afraid that _part_ of the problem is that you're not right. Neither are they, though. Because the thing is that there is no single _right_ answer here. Given that, my advice would be to: 1. Be extremely critical with the arguments you use to defend your position. To the point of discarding them if they, honestly, don't feel completely solid. This both will give you a more solid argument for your position _and_ will give yourself a better understanding. E.g. The thing about SPAs; they are _not_ becoming "the norm". They are popular in certain situations. Sometimes they are a good solution, sometimes they are not that good. Given that, you would first need to establish the point that indeed, a SPA is a good fit for your circumstances. Not only that, usage -or not- of a _framework_ is not exclusive or even related to building a SPA or some other type of website. So, in any case, the point seems _mostly_ irrelevant. 2. Acknowledge that _"they"_ have valid arguments too. This not only makes people more receptive to your suggestions, but will also force you to think and present alternatives or solutions to those aspects, making your argument more complete. 3. Focus on the most painful problems you find in the current situation. But do _not_ blindly believe either that "using a framework" is a magical solution to everything nor that it is the _only_ solution available. It's quite possible that some of those problems can be solved in other ways. e.g. many consistency problems may be easily solved by using a -more or less restrictive- style guide and adopting code reviews. 3.bis Do embrace those alternatives and include them in your proposal. In fact, don't present your proposal as a all-or-nothing solution. Try to present more than one solution, present different solutions for different parts of the problem, offer adoption of some parts without obligatorily enforcing the others. 4. About those pain points... Document them clearly but objectively and dispassionately. In particular avoid at all costs making it personal or pointing out problems with people. That is, abandon the idea of even mentioning that some code may have been written by "people who don't know how to use JS". Focus on the code, not on the people. _Do_ present bad code, duplications, messy code, differences in style, inconsistencies, etc. Sure, do that. But present it all in a neutral and impersonal way. In the end, it's all about _the code_, not about the people.
https://builtwith.com/
method names in URIs? Sounds like someone has a CGI masquerading as a RESTful endpoint
If you are setting up webpack yourself you can do code splitting to generate multiple bundles and include them in different HTML pages. https://webpack.js.org/guides/code-splitting/
https://stackoverflow.com/questions/6307514/is-it-possible-to-override-javascripts-tostring-function-to-provide-meaningfu
Javascript scales terribly. You won't be able to convince someone who understands that. Instead, stop using javascript and start using typescript. 
Can you elaborate on this point a bit? He didn't say he's adverse to using Typescript, which is just an abstraction over Javascript anyway right?
I worked at a company that had an API endpoint for every individual property of an object. (Think /object/5/getColour, object/5/getSize, object/5/getPrice) They also used POST as a get mechanism. Sometimes. They thought their API was the bees testicles.
I bet it hurt like bees testicles to work with that API
Lol was actually listening to the real song when I read the title of this post.
They complained when I bundled them all into one function (so it hit the api about 20 times). But you're making 20 api calls, they said. Yes, I said. That's bad coding, they said.
What are the benefits and drawbacks of react-native-web comparing to using plain react and then react native for iOS and Android? After all react is about "learn once write everywhere" instead of "write once compile everywhere".
As someone who was expecting to talk to a REST API for integration but ended being served a non-conform SOAP webservice that also contains unicode within xml tags, this song made my day. The kicker? In the envelope, it's quoted JSON.
I worked at a company that had so many internal APIs (which were granular as yours) that they needed to create a special API router that take complex multi-api query, merge them and cache the result. At that point you know things got out of hands a long time ago and there's no going back to sanity.
"a person might want 1-indexed months for a new project" with a healthy dose of "0-indexed months are weird i guess? look we're doing an immutable date library, we're already being wildly different from the core product, give us a break"
the obsession with REST is tiring. Its no more than a standard convention that can make certain tedious tasks easier. It helps people spend less time learning and more time doing. But like any convention, if its not well understood, if people claim to follow it but make tons of exceptions, then it doesn't look useful. If everyone had REST compatible projects and followed REST api standards, there wouldn't be any problems. People are what's wrong, not some arbitrary convention.
Ah, apologies, for my misconception and your current situation. I'm not intimate with .net, I assume mostly asp templates then? I'm not a fan of REST for REST's sake, but if you can post json to the server and get a json response containing reasoned commands and errors and responses and data structures, then you are good to go. Maybe look at whatever the .net layer is talking too, if it is other services then talk to them... if it is an entombed database, with various batch feeds mixed with user updates, then you still gotta look at the big picture to see what manner of finer grained API works. Probably more likely to gain traction on new projects than existing ones, but don't expect everyone to think nodejs is a swell idea, and it is still pretty much needed for ember builds (more tech stack, you touch it you own it) even if you don't use it on the server. So it is client side AND development side more accurately, and can open a lot of holes on your development box. If you aren't on board with that whole mentality, I would pick something lighter weight that doesn't require elaborate builds to function, possibly vuejs if you don't get too fancy.
Speaking for those who might not know, Typescript brings types to javascript. Types make scaling and maintaining an app infinitely easier. In application development, a lot of time is spent adapting old components and logic to evolving expectations. If 10 components rely on component X having a string property `foo`, and you need to change that property name to `bar`, you want the compiler to let you know you need to adapt those 10 other components. Ask any backend dev why they don't write core web apis in python. Python doesn't scale well in the same way javascript doesn't scale well. 
I think you should take their perspective instead of calling them zealots. First off your points 2) and 3) have nothing to do with the backend - these can be fixed without an SPA at all. SQL Server/C#/ASP is a standby that powers many, many applications and has proven to be stable and to do it very well over almost 15 years, and it sounds like most of the company is well trained and capable on this platform. SPAs have only become popular in the past few years, and I wouldn't consider all of the frameworks exactly stable. Even Ember, which is probably one of the most stable, relies on a JavaScript/Node ecosystem which is considerably less stable than what an average .NET/Java developer is used to. Retraining also has a huge cost associated with it, more so at larger companies. Are you asking them to convert existing applications to Ember? This is another huge cost to the company. &gt; environment of extreme fear of change This is perfectly natural and I would be more concerned if it wasn't there. You are asking them to abandon one of the most stable software platforms available that all of their developers are currently productive in...for what? Do you have a competitor that recently added an SPA that is faster/more user friendly? Can you demonstrate that features can be released more quickly? Have you built any prototypes/mockups to show capabilities an SPA has that the current tool chain doesn't? 
yeah that's what the song's about
Great stuff in here - I especially appreciate the tooling improvements. Keep up the good work! 
This is a great, clear answer, thank you! So if I understand well, a frameworks makes difficult things easy (easier) for you but you pay a price in terms of less flexibility and using libraries in JS, you have all the flexibility you could need but the price you pay is added complexity. Right? Thank you again.
Why go back to sanity when you can go full batshit insane?
If they had an endpoint for every property weren't they already making a ton of api calls?
When logging an object you need to know that it shows you the value under the object reference but at the specific moment when the browser shows this to you - not at the moment of your .log call! Try to console log the json string of the object with console.log(JSON.stringify (yourObjectOfInterest)). Logging values like strings instead of objects will give you the most accurate results! The missings property probably just gets defined later - maybe even in a completely different function!
Look at the guy's other uploads, I think it's a pretty safe assumption to make that he sang this himself. 
but isn't javascript synchronous, how can it show in a different moment than the log call? 
Ah okay
Thanks, you we're correct. The extension was https://chrome.google.com/webstore/detail/loom-video-recorder-scree/liecbddmkiiihnedobmlmillhodjkdmb 
Well, there are two ways I know this can happen: 1. The program or browser may be modifying the value in real time, and what you see logged refers to some previous state of the object that got modified between logging it and you typing a line into the console. Yes, js is synchronous, but that doesn't mean only your actions can cause changes. 2. A less likely method: the object could be defining a getter that, once accessed (by printing the value to the console), it deletes part of itself by changing the reference to undefined.
Just fyi, it's a superset, not an abstraction. No part of js is abstracted away by ts.
Dude. Did you even watch the video?
Thats an accurate description of GraphQL. I like GraphQL.
They liked it so much that they reimplemented it for fun :D
+1 post as "get" mechanism, use post for everything really. And it doesn't get much more micro than getColour. I mean what do you think microservices are supposed to look like? Return just an object in an array? return the whole array? The whole discussion gets rather religious. I mean if you could bundle the requested properties into one call that would be good, and I wouldn't be surprised if it actually did that. FWIW I write the server API FOR the client, if they need all the data for a datagrid, or just a page at a time, that is what they get. The more you bundle just what the client needs into one call, the less network load on the server (assuming multiple users). REST isn't a panacea, it is just the same old problems with new problems.
Sounds like they'd be interested in http://graphql.org/
yeah I thought as much. I was just confused with his comment was all.
Generally speaking javascript is a single threaded language, but that doesnt mean that everything just is synchronous! As a very cheap example you can request resources from a server while doing something else. Or you can schedule functions to run at a later moment (setTimeout).
My issue is that... just because it's Typescript, doesn't mean it's not Javascript. So when he says Javascript doesn't scale but Typescript does... it's a bit confusing. It's like going "React development is super bad. Make sure to use Webpack with React instead".
Your argument should be yours and yours alone. Learned this great quote yesterday. "Stop trying to borrow wisdom and think for yourself. Face your difficulties and think and think and think and solve your problems yourself. Suffering and difficulties provide opportunities to become better. Success is never giving up." - Taiichi Ohno, Toyota Production Systems You have to figure out what's right for your developers and for your customers. You have to be open to all sorts of ideas, including the idea that Ember might NOT be the answer. What are the costs of using Ember? What are the costs of converting people to use Ember? What are the benefits? If the majority of your employees are traditional asp.net developers, what does that mean for the migration? What is the makeup of skill sets in the surrounding region when you go to recruit new developers? Are there enough resources/ enough on boarding to make the change? There is a lot to consider and only people who know the full context of YOUR problem can truly answer it. The one thing I can share with you is that proven successes mean more than any verbal argument. You need to show them that not only does this work, but it works completely, with more complexity than your simplest use case and with everything, such as testing, deployment, etc, has been thought out and proven.
freestyle RPC all day
It evolved like Tetsuo.
True, it depends on what their concerns are. TS makes enterprise development easier in one respect (static type checking) but if the other devs are weary of the node ecosystem (for example) it doesn't help there.
Homegrown.
I'm not entirely sure what you mean
[Norvig's "spelling corrector"](http://norvig.com/spell-correct.html) is a great example of this imo. Hard to believe it does what it does with so little code.
There is definitely a RESTful way of building APIs. But what you've described is using http as an interface and nothing more. Don't get me wrong - in my experience for a lot of organizations this is a huge improvement. But there are definitely best practices, conventions and constraints to what classifies a truly RESTful API. It really is getting a bit religious talking about it. Sort of like DevOps heh. I've almost come to hate the term DevOps just because of the shit arguments it stirs up in the industry 😂😂
https://www.youtube.com/watch?v=l1URmUxNdqg
Video linked by /u/mothzilla: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Akira: Tetsuo's End](https://youtube.com/watch?v=l1URmUxNdqg)|KingDukas|2010-08-22|0:08:25|2,454+ (92%)|720,108 &gt; One of the greatest WTF moments in film history. From Akira. --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/mothzilla ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dp5lck7\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Well I largely ignore http protocol, yes. i.e. what do you do with websockets (or real genuine sockets? Or an event bus, or any other transport mechanism?) I keep as much control of the logic at the application layer as I can. There are plenty of things get/put/etc don't describe, nor 200 ok or whatever arbitrary return codes. I mean if you can put together a very opinionated URL, you can put together a blob of json and post it. P.S. I also ignore anything calling itself "best practices", because that isn't much of an argument in itself, usually lacks real data, and the authors aren't usually receptive to feedback regarding it, since their goal is to appear to be an authority on something, not dealing with reality. Maybe if more "best practices" were actually good in the bigger picture, I would care, but that isn't the environment I'm seeing. 
Firebase.google.com - this coming from someone who started developing webapps in 1994. To me this is a real game changer.
This is relevant. Implemented in v8 6.3 http://2ality.com/2016/10/asynchronous-iteration.html
Borrowed wisdom is intelligence... I don't think it's a quote, but wisdom is learning from your mistakes, intelligence is learning from others mistakes.
&gt; If 10 components rely on component X having a string property foo, and you need to change that property name to bar, you want the compiler to let you know you need to adapt those 10 other components. You have more problems than just using javascript, ie there should probably be some type of interface sitting between those 10 components and the dependency.
Yes.
Holy shit you're good
Yes. That's the joke.
its difficult for me to give you an OSS to start working on. Not sure you would be interested. Do you use any plugins ? like maybe a date picker, a form validator or helper package. Contribute to those. or if you really want, here are some trending repos: https://github.com/trending/javascript
Just stop using the combination array/interval in all of the examples in the documentation and it will be 100% better. It makes it really confusing as to why a person would need to use rxjs in the first place, because you could just use an interval and array shift/push to do the same work without any of the complexity.
Just stop using the combination array/interval in all of the examples in the documentation and it will be 100% better. It makes it really confusing as to why a person would need to use rxjs in the first place, because you could just use an interval and array shift/push to do the same work without any of the complexity.
WHAT are you trying to convince me of? ;-)
Don't forget to OPTIONS before your getlike POST.
Maybe propose using F# (Fable) and React so you can cross-compile on .net.
This is the nerdiest thing I've ever seen in my life but I love it!
Yay they fixed [my issue](https://github.com/Microsoft/TypeScript/issues/15809)!
I promise you, you will regret converting a website to a SPA if what you actually have is a website and not a web app. Websites written as SPA's are often terrible. Be honest with yourself, do you have humble 'content' or an online application? In other words, closer to wikipedia or gmail? My rule of thumb is consider the browser's back button: When using your website, is the back button a major component in the experience? Websites like this one rely on the back button, its like free functionality. Not only is it free, but the browsers back button has been laboured over by lots of developers making it the most pleasant, fluid experience possible. If you replace that with a SPA's 'back' experience, you end up with a shitshow of scrolling horrors, spinners and stale state. I don't care what SPA apologists say about it getting better, it still sucks, especially if you have a lot of 'content'. I'm admitting this as a SPA developer myself.
You're not really putting the logic outside of the app by designing an API restfully. You still have to decide with the logic of your code what happens based on the HTTP verb. 
&gt; If you replace that with a SPA's 'back' experience, you end up with a shitshow of scrolling horrors, spinners and stale state Have you ever used EmberJS? That's actually one of the things they got right. I also strongly encourage my team to pay attention to not break the browser's back button, because webapp or website, your users WILL use it.
if it depends on a specific protocol, it is outside of the application api and an implementation detail. Like just another network layer. You shouldn't have to worry about it really except as a low level thing that fails sometimes, instead you are saying integrate one specific protocol into all your inter-business logic, even though it is much more portable and testable and etc as part of the payload. I'd rather be able to exchange json blobs with anything, than just web browsers and things pretending to be web browsers.
And I'd agree with that =) I'm not saying don't borrow anything, obviously I don't want everyone reinventing the wheel. But when you need a circle but you end up using a square because everyone else is using a square, you really put yourself in a tough position. And at the same time, if you think you need a rounded square but most of the world is supporting and using a square, you should look and evaluate if your use case is really that special. You should look at all variables involved.
"Hey, coders, e-mail and go home. All in all it's just an enterprise waterfall!" https://www.youtube.com/watch?v=Mq1MD5qXI08
I feel you. I think npm the cli was stagnating and yarn came along and woke it up, which was a good thing, so now there's some competition. On the other hand, I've recently started an express.js app and had to choose a templating engine, and there were probably 15 of them, two of them with the same name!, some abandoned, a lot of them seemed to add nothing except give the authors some street cred. The fragmentation of effort in the javascript world is something that could be argued as a good thing, but I can't help see a lot of wasted effort, a lot of it abandoned (some of it mine). If you start a rails app, you use ERB, and you know you aren't going to have to create a github issue anytime soon. I look at the javascript world like its a giant junkyard. You poke around, find useful stuff, some of it fixable. Once in a while you come across a giant stack of stuff that's been gathered by developers to accomplish a task, like React, or Vue, and as long as you stick to working with that pile, you are good, if you don't, you'll feel truly lost ( like a feel now working with express.js ) The ruby world is like a desert with a giant gleaming pyramid, which is Rails, and all the developers are dutifully pushing the blocks into the right places. You could probably continue this metaphor with saying there's also a Pharaoh in this world, that drops F bombs. I think the pains with the javascript language itself are not related to the javascript junkyard, but its a mess since the language standard is pushing ahead of the implementations, so you need to transpile, but eventually browsers/node will run everything we want natively. If ECMA doesn't calm the F down and forces us to transpile for the next 20 years I'm gonna lose it.
So are you saying that somebody could clone wikipedia in EmberJS and I wouldn't notice when using the back button? If this is true I'm going to check it out, but I'm skeptical.
I went to a bootcamp 3.5 years ago. I have been hired full-time professionally for 3 years.
This is great, thank you for posting. I also found this video helpful for learning React https://www.turbo360.co/tutorial/react-demonstration---stevens-institute-of-technology
Yes, they will hire a self-taught dev if you interview well and can show your proficiency. You'll be an even more attractive candidate if you can get a recommendation from someone already working in the company or is well established in the industry. So, do some networking. Also, fill your github with projects that are working, well documented and have a demo. This is an easy way to demonstrate competency.
So you found a job pretty fast? 
Yes, I will do it. I also heard that is a big plus when I fill out codepen.io with some projects! 
I never realized his fingers were growing fingers before.
Yes. I would say the hardest part is finding your first job, after that it gets easier since you have experience. Most companies look for experience and not schooling, especially in web dev since it moves so fast.
Hate to be a one upper: https://www.youtube.com/watch?v=Fow7iUaKrq4
Other videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r79vtub?feature=playlist&amp;nline=1) VIDEO|COMMENT -|- [Enterprise Waterfall](http://www.youtube.com/watch?v=Mq1MD5qXI08)|[+5](https://www.reddit.com/r/javascript/comments/79vtub/_/dp5tzmj?context=10#dp5tzmj) - "Hey, coders, e-mail and go home. All in all it's just an enterprise waterfall!" [Monzy performs at Stanford Univ.](http://www.youtube.com/watch?v=Fow7iUaKrq4)|[+3](https://www.reddit.com/r/javascript/comments/79vtub/_/dp5x3t8?context=10#dp5x3t8) - Hate to be a one upper: [Akira: Tetsuo's End](http://www.youtube.com/watch?v=l1URmUxNdqg)|[+2](https://www.reddit.com/r/javascript/comments/79vtub/_/dp5lbdy?context=10#dp5lbdy) - http://www.youtube.com/watch?v=l1URmUxNdqg [Dual Core - "All The Things"](http://www.youtube.com/watch?v=X0WNQ3UYbJE)|[+2](https://www.reddit.com/r/javascript/comments/79vtub/_/dp60651?context=10#dp60651) - If you're interested in nerdy music, there's this group called "DualCore" that raps about hacking: I hope they show up on Mr. Robot someday. [We're Gonna Build a Framework](http://www.youtube.com/watch?v=Wm2h0cbvsw8)|[+1](https://www.reddit.com/r/javascript/comments/79vtub/_/dp6akw5?context=10#dp6akw5) - http://www.youtube.com/watch?v=Wm2h0cbvsw8 I'm a bot working hard to help Redditors find related videos to watch. I'll keep this updated as long as I can. *** [Play All](http://subtletv.com/_r79vtub?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get me on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
Omg that hurts to watch! Haha
"That's Mr. Kaneda to you punk"
Once I had to work with XML in CSV. Yeah! I asked where this is coming from and it was so high up the food chain that I said fuck it.
Ecma could even not be "the best" practice anymore later on. Some programming languages are being developed to replace it. And with everything changed annually, next it could be the language itself. I like JavaScript but the project is pain in the ass to setup and maintain according noawadays standard.
Or you could have server side rendered React and get all the benefits of a SPA without any of the downsides
I've never understood why REST is so widely used. What if I have an error for which there is no suitable HTTP code? Or operations for which there is no suitable HTTP method?
As /u/KatyWings said console.log can be inconsistent, especially in browsers. You should try to use a debugger and breakpoints to interrupt the execution and look up what you need. 
Yes, but there is a lot more competition for junior positions now-a-days.
Currently writing a client for querying MS Dynamics CRM; this hits close to home.
Doin' some goddamn tasty work 👍
But when you go beyond CRUD the HTTP verbs don't suffice. 
Not from a browser. You can do this with Node.js though.
If you're interested in nerdy music, there's this group called "DualCore" that raps about hacking: https://youtu.be/X0WNQ3UYbJE I hope they show up on Mr. Robot someday. 
That has to be one of the worst ideas I've ever heard. Can we throw redux in there to make it even more painful?
Best practices are often like driving on the left versus driving on the right -- there isn't necessarily a huge benefit to one over the other, but there is a huge advantage in picking one and sticking to it. REST is by no means perfect, but it really does have a lot of value in that a well designed REST API will be immediately familiar because the pattern is familiar.
But I can't create a chrome extension through Node.js right?
&gt; bees testicles hahaha!!!
Well calling it "best" is the sticking point, especially when it isn't a life and death thing like driving. I mean we can go back to whole page refreshes if you are worried that "programmers" can't be trusted to do anything more complicated than that over the wire. But really driving is a horrible example. Calling it "best" assumes the worst in people in this interpretation. And even then it isn't like the rest of the object graph is self-explanatory, and if it is documented, adding a command (verb/method) should be part of that already. I don't see what it buys you, except an unnecessary dependency on your business logic and lock-in to a specific protocol, historically lock-in is one of the worst practices.
Simple jQuery DNA Template library that is very practical. No stand-alone &lt;script&gt; templates like Mustache, jQuery Template, Handlebars, single call to parse/process/apply the template, very practical in-HTML templates, non-destructive (can re-apply new datasets to already processed template - lovin' it!), understands natively forms, classes, ...
Custom HTTP methods then. That's what Internet of things devices do in that case. I can't imagine that very many people need them though. The default methods are quite generic.
This doesn't really have anything to do with the initial problem, however Ember also offers server-side rendering.
I don't get how it's a bad idea
KILL DASH NINE God I love that song.
Love it. This is very underrated, based off of YouTube views.
Can you describe an error that doesn't fit an HTTP code? 400s cover user input error, 500 covers server error. You can even throw the one that makes the most sense and send back a response body with more info about the error, you dont have to just look at the status code to see what happened.
You could connect it to your server's api I suppose. But that could be expensive if it gets really popular.
Object.freeze can be used in application code as a way to increase the performance if you're using an object as a dictionary.
Jesus. XML in CSV. I'll never bitch about double-encoded JSON again... ha
hahaa Except for `return false` or `stopPropagation` is used
We don't know. I just kind of wrote it and because I'm on the MomentJS team and we all liked it, we decided to give it a home in the Moment org as a kind of "labs" project. We don't have any specific plans, except that I'm going to keep maintaining and expanding it.
I usually throw a JSON body in with http error responses so clients can parse additional data / subtypes / error messages / etc. It works okay.
That is pretty toxic. Maintaining a widely-used library is a ton of work, and telling people they shouldn't use my library because I didn't volunteer to refactor Moment for you is pretty lame. I also think the idea that me building a whole other library is us "finally sort of address"ing it reflects a poor understanding of how open source projects come about and are maintained. By all means, use and promote your favorite library, but come on, man.
It was mostly because it's a common stumbling block for Moment's users. It's true that it makes it less of a drop-in replacement, but immutability makes it that anyway.
Except how it opens a new tab to let you know it updated. Which is all the time.
👌🏼
Pretty good demo!! Are you planning to add more documentation besides the demos in the near future? 
https://youtu.be/Wm2h0cbvsw8
Hi /u/rick4470, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Well, I guess you can just say `400` or `500` if you don't have a more specific one...but for example, just today I've been coding up an API, and what code should I give when there are missing JSON parameters that are required? I just give a 400 because there's nothing better to do.
I am flabbergasted that this exists. Delighted. But flabbergasted. 
If you're doing REST, they suffice. In fact, you don't even need HTTP for REST. Are you going to tell me that there's something you can't model as transferring state?
What you're doing is using HTTP as a substrate. It's perfectly acceptable. In fact, there's even a BCP about it (RFC 3205).
No, but look into whether Chrome still has a file system API. I believe they used to but it was limited to Chrome *apps* and not *extensions*, and Chrome no longer supports *apps* outside of their OS. Also look into Electron, as it might be able to accomplish whatever you're trying to build.
HTTP status codes aren’t really part of the REST specification, btw. But generally speaking, the best practice is to use _less_ HTTP codes, not more. The idea is that they are broad and prescribe general solutions. 400: the client is bad and needs to modify their request. 503: the server is busted, but if you try the exact same request later, it might work. You should avoid the more esoteric codes because the solution may not be well understood by your client. 400, 401, 403, 404, 500, and 503 will probably have you covered. Now if you want to get really specific, that’s great too, but you should come up with custom codes and error messages to send back. No general standard will ever have everything you need anyway. [Twitter’s ApI](https://developer.twitter.com/en/docs/basics/response-codes) follows this strategy. As for operations for which there are no HTTP verbs (also not part of the REST spec), there aren’t any. At least none I’ve ever run into. Like the status codes, they are a limited set of broadly applicable categories, and have very explicit behaviors clients can rely on (PUT is idempotent, PATCH is not, etc etc). The idea is not to describe exactly what the route does, it never could, but to prescribe a widely understood set of behaviors. 
Isn’t that what you’re supposed to do?
The REST one was a lot better.. But I've been there too lol The same company decided their solution for one of their big problem was to build their own CMS. I told management they didn't have the resources and time (they managed over 50 devs) and would fail hard. I told them I had a better solution, but they disregarded it and fired me from the department for pissing on their dream. Same management gets fired a year later for not having even started to address the problem. Project falls back on my desk, built my initial idea with standard and proven building blocks and shipped within 3 month with a single other dev. Didn't even get a bonus, an apology or even slap on the back.
The codes themselves are *supposed* to be general, and 400 ("Bad Request") is the correct code for a... bad request. Additional information is supposed to be in the message body.
Not really..
Writing the server for the client will just ensure that it's a total pain in the add to work with when you or anybody else has to build another client.
Can someone explain why method names in URLs is a bad thing? Obviously you need to whitelist methods for security. But are there other reasons? Is it about being more flexible?
Well 400 means Bad Request, as in the user submitted incorrect data, so that is what you want. As for what else you return to explain to the user what happened thats up to you. Personally my errors look something like this: 404 response: { "name": "APIError", "code": "NotFound", "status": 404, "message": "Resource Not Found", "success": false } Which provides a program readable error code, user readable message, and a boolean to help you parse whether this is a successful call or error (which you can tell by the http status but here you dont have to care what the http status is at all)
Not necessarily, it follows the YAGNI principle, I mean unless your gui/client is just random values displayed at random times at random granularity with arbitrarily constrained functions, there will at least be some thought to the server interface as well, and it will be at least partly user driven, not just arbitrary ivory tower assertions about "best" practices. and often you can just build on the existing API and say "use this function" if for some reason they can't make use of the existing functions for everything. There are of course "best" practices when writing a straight json interface too, types, schemas, etc, it is far richer and far more appropriate for an SPA: https://mmikowski.github.io/json-pure/ 
The first codepen you linked to actually accomplishes this effect without using any external libraries except jQuery. It's only 31 lines of code - I don't think it'll get much simpler than that! For video, would it be video you're just displaying (like a YouTube &lt;iframe&gt; or an html &lt;video&gt; element), or video that you're generating programmatically using Javascript? If it's the former, you could do something similar to move the element around, right? If it's the latter... I have no idea where to even begin.
Well, couple of my extensions do that. But I never found it annoying. 
[removed]
No. The R in URI/L is Resource. So your URL should be a resource (/users/1, /posts/32/comments, etc). The HTTP Method (GET, PUT, POST, DELETE, PATCH, etc) is the action on that end point. Generally, the HTTP verb is what you want to do on the resource. For example, GET post /posts/32. POST a new post at /posts. If you put the method name in the URL you are a) exposing your internal logic and making your code brittle and b) breaking what most consumers would expect and c) making it so that consumers need to know the internal implementation of the API rather than what they do. There is a pig difference between POST /posts to create a post and POST /posts/createNewPost (why wouldn't it be /post/create or /post/createPost, for example). Hope that helps!
I don't understand why 400 wouldn't be the right code in that case. If they are missing a required field, it should be 400 (input error) with a message coming back saying "xyz is required" or something. That's what I do for missing required inputs.
Ah so "method" refers to http verbs in the video? I thought it meant method/function names in server-side classes/objects.
Dictionary is subpar for performance in most scenarios. [Hidden classes](https://www.html5rocks.com/en/tutorials/speed/v8/) are better. If you really want to do micro-benchmark/optimization, don't do it in application -- create a utility library (i.e. lodash) and do it there. If you do, you better know how to debug assembly. [Here's](https://www.youtube.com/watch?v=65-RbBwZQdU) a pretty good video on it. 
It's no longer a REST API at that point, just a RPC (remote procedure call) type API. A REST-like API at a minimum should generally constrain endpoints to representing some sort of objects, and the expected payload &amp; return values should be the state of the object. Some of the fields being passed back might come from methods, and modifying values on these objects might set off methods behind the scenes, but in general the goal is that the frontend shouldn't need to know about any of the methods involved, they should just be able to fetch or modify the state of an object and have it handled etc. 
Would've been nice if you had the other management's budget to work with too.
Yeah.. the things I would have done with 35M :p
And then we're surprised clients want full-featured CRMs for 500 dollars, no? The manager that fired and rehired you surely got a bonus bigger than your and your colleague 3 month salaries. But, hey, your ego got bigger for proving yourself right, right?
The difference being that Wappalyzer is an Open Source tool, not just a service.
&gt;I've never understood why REST is so widely used. Same reason most of the world uses the metric system. Is it objectively the best possible system? Probably not. Is it a product of universal truths or some fundamental mathematical laws? Nope. It's convenient and works pretty well for most things we need it to do, though, and the biggest benefit of having a standard is just *having* **a** *standard*. It means that, so long as everyone actually understands how it works - which, obviously, not everyone does - everyone is (metaphorically) speaking the same language. This is more useful than most people ever appreciate. To overuse the metric system example, one of the most expensive programming mistakes of the last century was the result of one program returning imperial units when another assumed the numbers it was receiving were metric. Both pieces of code worked perfectly, interacted correctly, but because neither of them considered the possibility that the other might be doing things differently - because someone at Lockheed skimmed the contract or just didn't think, I guess - the US government flew two hundred million dollars into Mars. As for the rest: &gt;What if I have an error for which there is no suitable HTTP code? The existing codes are supposed to be broad enough to apply to everything. For things where you feel the need to be especially specific and *really* think it's important, feel free to make your own, just be prepared for the top comment the next time this is reposted being about how someone had to work with an API with a different HTTP code for every damn error. &gt;Or operations for which there is no suitable HTTP method? The four existing verbs are *also* supposed to be broad enough that they can apply to everything. It should be possible to model any behavior as a change in state. 
Sure you do! I am 21, and also live in europe(Latvia), haven’t finished my bachelor yet, but I work in pretty good job in the same sphere as you! I think you just have to have decent skills to get hired and that’s really it.
Take a look at the [core concepts](https://guides.emberjs.com/v2.16.0/getting-started/core-concepts/), and specifically at the first section. &gt;Imagine we are writing a web app for a site that lets users list their properties to rent. At any given time, we should be able to answer questions about the current state like *What rental are they looking at?* and *Are they editing it?* In Ember, the answer to these questions is determined by the URL. The URL can be considered "the single source of truth", as everything else directly depends on it. An Ember app must behave as you'd expect if you refresh the page or go back.
So it's TypeScript, but without the TypeScript. Nice. Joking aside, simple shape checks are super useful, and the lib looks to do a really good job of making it flexible and comprehensive.
Yes! Currently, all the demos are documented a fair bit. Was there a particular demo lacking in doc that you found? I’d love to know where I can add more!
Yeah, but sometimes you have doubts. Are you good enough and so on! But I think I will be fine, my current co-workers are jerks, because low entry jobs so not very high IQ . Can't wait to be with people who are more relaxed and nerdy! 
What verb represents "send an invite to this e-mail", for example? The HTTP verbs are great for CRUD but if you need to trigger actions instead of database changes you need to put the verb in the URI, no? 
No, it does mean having URLs built around methods that exist somewhere on the server, instead of the resources they represent. The client shouldn't know or care about how an API is implemented internally, it's similar to your URLs all being paths to `.php` or`.aspx` files.
 element.addEventListener("breath",function(e){ e.preventDefault(); console.evilLaugh("bwahahaha"); });
I was just thinking that it's pretty common in web frameworks to have controller/action naming conventions that correlate with URLs by default. i.e. In Phalcon the URL `/hello/doggy` would execute the PHP class method: class HelloController { public function doggyAction() {} } Obviously you can use routes on top of that for custom URLs for more flexibility. I guess with an API it makes more sense to always define all routes for flexible longevity? 
&gt; you need to put the verb in the URI, no? not really, you can simply create a resource for a task queue or similar. Like POST /api/events/2455/invites
&gt; What verb represents "send an invite to this e-mail", for example? It depends on your required idempotency. If you want an idempotent operation, `PUT` the invitation to a resource that represents an invitation sent to a particular e-mail address. If you want to be able to send multiple invitations, `POST` the invitation to a resource that represents a collection of invitations, and the server will tell the client the new resource's identifier. &gt; if you need to trigger actions instead of database changes Changing the database *is* triggering an action. It's a state change, as is sending an invitation. &gt; you need to put the verb in the URI You never *need* to put anything in the URI. In the REST style, they should be opaque to the client, which should neither construct nor parse them (the use of relative URIs excepted).
&gt; endpoint *Resource*, since we're talking about REST. In fact, since we're talking about HTTP.
yes, right
&gt; There is a [big] difference between POST /posts to create a post and POST /posts/createNewPost Actually, there isn't. REST doesn't care what your identifiers look like. 
&gt; I've never understood why REST is so widely used. It isn't. Read the [chapter](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) and think about whether you've actually seen anyone doing that. What is widely used is something *called* REST, but would be more accurately described as "using HTTP correctly".
Thanks for your informative answer! So you think I could use the above codepen for a YouTube iFrame? That could work for me. Any option is possible. I also thought about hosting the video myself, but if YouTube can do that for me thats even better!
Thank you
Hey, reddit! I'm the main author of [maptalks.js](https://github.com/maptalks/maptalks.js). Any opnions or suggestions will be appreciated. Thanks for your attention!
I think you can get this in the form of an API.
This is amazing. 
thxxx : D
totally agree
Have you run `npm install --save-dev babel-plugin-transform-class-properties` on the project?
of course i did "babel-plugin-transform-class-properties": "^6.24.1"
So you turn every complex operation into some form of a task queue? I guess that works, but it seems like over complicating things for the sake of not breaking the convention. I don't think there's an advantage to using a task queue because you're going to need to read the documentation anyway, to know what to put in the payload, so why not make the "action" requests RPC-like? 
Use babel-env instead of es2015. Env specifies everything that has survived the draft stage, so you don't have to worry about importing es2015, then 16, 17, 18, etc. "presets": [ ["babel-preset-env", { "modules": false } }], "babel-preset-stage-0", "babel-preset-react" ] And while you're at it, you can just as well go to babel 7 now in order to save you the trouble of having to screw with it again in a few weeks. Babel 7 also has updated stage definitions, everything's in there by default so mostly you don't need extra plugins. npm install @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-0 babel-loader@next "presets": [ ["@babel/preset-env", { "modules": false }], "@babel/preset-stage-0", "@babel/preset-react" ],
same thing. it keeps complaining about * inline function calls: {(() =&gt; { // some code here })()} it doesn't like the () that calls the function at the end * 'super' outside of function or class: componentDidMount() { const $this = this; getData().then(function(data) { $this.setState({data}); super.componentDidMount(); }); } it complains about the super.componentDidMount. babel 5 did not complain about this.
I know it seems obvious, but you never know :)
I haven't played around with it just yet, but from the readme it seems great (and is something I will likely use). Good work. 
Strange, ripped it straight out of my config, using tons of inlines. Using `super` here seems strange btw, why'd you do that? You're not in the context `super` is expecting, you are inside a anonymous function. Calling cDM() like that also seems off.
Yes. It does. URLS are resources. What is a createNewPost? Why does POSTing to /posts fail? If I am POSTing a createNewPost what does that mean?
No, ES6 destructuring is most similar to Python destructuring.
i agree the context seems off, but it compiled and worked before, maybe babel 6 got better at catching those. anyway, i changed it to the following: const superDidMount = super.componentDidMount; getData().then(function(data) { $this.setState({data}); superDidMount(); }); and it compiles. let's see if it runs same as before, there should be np. for the first one, i noticed that some of these inline functions were not surrounded by parenthesis, lie this {() =&gt; { // some code here }()} once i put parenthesis around the whole inline arrow function, the complaint went away
I've found that RxJS is most useful for websockets and UI interactions. So maybe you could make a custom dashboard type of thing with different widgets that you can drag around, collapse and expand. By the way, RxJS is a fundamental part of Angular 2+. If you want to put yourself in an environment where you have to learn it, you could try making something with Angular. All events in Angular are RxJS Subjects.
There's something called gatsby which does static page generation in react. If you would like to actually split a real react app into different files without a router then it'd be pretty complicated. 
Thanks!
The only way I've seen POST-as-GET necessary was when you're having the client post some kind of user-provided query that is sanitized and used server-side to query for a set of data (or even an individual object). If the query text (or object ID?) just won't work in a URL (and it's too nasty to base64 encode it or whatever) then sure, you POST a QueryContainer object that has the text inside it. Is this bad?
I had hope for this as well!
&gt; {() =&gt; { // some code here }()} Is there a reason you would want to execute code inside an anonymous inline function? It seems odd, given that you're dealing with a class into which you could put any function or helper you want. As for the componentDidMount, the function is called by React, calling setState when getData is resolved is enough to re-render the component. Calling super.cDM again by yourself shouldn't have any effect, or worse, cause undefined behavior. You could do it in one line using async/await. class Comp extends React.Component { async componentDidMount() { this.setState({ data: await getData() }) } Last but not least, you never have to store `$this` any longer, this is what fat arrows `=&gt;` are there for, they auto-bind `this`. So given we're back with a regular promise, you could write it like so: getData().then(data =&gt; this.setState({ data }))
Correct, Electron does enable file system access. 
In the github repo for this project, the following is said on browser support: &gt;Of course we are not covering things like IE11. The way I see it, IE11 could easily be supported, exactly the way you'd do it with Polymer 2 today; transpile the code and include the polyfills. Any reason why this is not supported in the boilerplate? That will likely be a deciding factor for most people.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment https://gist.github.com/revolunet/537a3448cff850231a74 this has nothing to do with imports, so not sure what you mean?
it's legacy code. but yeah you may be right about the CDM call.
I think it's better to represent, and provide an interface for the data in the most generalized way reasonably possible. If you have multiple clients that need to interface with the data for different purposes, it will end up being much more flexible and less brittle then targeting a single client. This is especially true when you're providing the API to third parties where you likely wouldn't want to build specific endpoints to support them. If you REALLY know this isn't going to be the case, then YAGNI applies. I'm building HTTP APIs for a large conglomerate that will be consumed by the admin portal I'm building alongside it, as well as other companies under the enterprise's umbrella as well as third parties not under it at all. Imagine how difficult it would be if I built my endpoints around my admin panel's specific requirements.
I have walked this dark path before. It was a bulk data importer for expressionengine, which lacked a native importer. The guy who wrote it chose to create a very xml-like CSV schema. I inherited the project before he finished it, so I had to finish it the way he designed it. Later, I asked him why he chose the weird CSV format instead of XML and just using the native XML functions the language had built-in. He got all wide-eyed, then sighed and buried his face in his hands and said something along the lines of "I didn't even think of that." I don't remember exactly what the data looked like, and don't have any examples laying around, but it looked something like: import,,,,,,,, ,BEG REC &gt;&gt;&gt;,205,,,,,, ,,,BEG FLD &gt;&gt;&gt;,1945,,, ,,,,,DAT TYPE,string,, ,,,,,,,content,"This is a record" ,,,&lt;&lt;&lt;END FLD,1945,,, ,&lt;&lt;&lt;END REC,205,,,,,, ,BEG REC &gt;&gt;&gt;,206,,,,,, ,,,BEG FLD &gt;&gt;&gt;,1973,,, ,,,,,DAT TYPE,int,, ,,,,,,,content,865 ,,,&lt;&lt;&lt;END FLD,1973,,, ,&lt;&lt;&lt;END REC,206,,,,,, ,,,,,,,,, ,,,,,,,,, Future import/exporters were switched to XML. 
This is pretty sweet.
Pity "npm does not support Node.js v9.0.0" though npm does suggest that "You should probably upgrade to a newer version of node as we..."
Hi folks I'm presenting you Zircle UI, which is a circular zooming user interface library based on Vue.js. The main idea was create a library to build apps or sites that use zoomable navigation. It took me a lot of time to develop it since I'm not a programmer. So, I had to learn Javascript, how to use Git and a lot of tools first. Also I experimented with many concepts before achieving what I had in mind. The development of Zircle took me more than a year. At the very beginning I felt overwhelmed with the amount of js libraries so I tried to built it using vanilla js. The outcome was, to say the least, a spaghetti code. After a while, a friend of mine said that I should use MVM pattern to tidy up the mess. With that in mind, and having learned a bit more of JS, I found Vue.js very friendly for me. Right now Zircle is under active development.So, feedbacks and contributions are very welcome! I hope you like it! Thank you, Martin
Reduce the barrier to entry. The number of tools you either end up needing or think you need scares a lot of people off. Unpopular opinion: webpack and friends are too complicated for what they do. Community and OSS involvement are great, but you have to have people on board first. 
Technologically, no difference, since you can route it however you please. Architecturally and conceptually, there is a huge difference. /createNewPost isn't a resource, it is an action. Keep the URL/URIs as just that: resources. Use the HTTP verbs to say what you want to do on that resource.
IE 11 could be supported, but not with the standard setup of this Skeleton. You can add your layer to support IE, it's your decision.
Despite what we in the JS world like to think, not everyone is sold on the idea of web apps taking over. There are huge segments of the market that consider native apps to be the top of the class- and critically *they are often right*. JS PWAs are great for “write once, run everywhere” and their performance and feature set is surely approaching native, but to think they’re the pinnacle of app achievement is inaccurate, in my opinion. Instead I think the shift will be in the opposite direction: writing a native app will feel more and more like writing a web app, and we will see a resurgence of native app popularity, not the other way around. *Bracing for downvotes*
sorry I'm just seeing this response - would you mind elaborating on what you mean by this? asynchronicity is a universal truth (whether you're waiting for user input or a database query, etc.) but I feel like you have an interesting point to make. Do functional paradigms generally avoid asynchronous calls? the first functional Javascript framework that comes to mind for me is [cycle.js](https://cycle.js.org), which is built around the idea of asynchronous pipes/observables.
Kinda reminds me of [Spark Framework](http://sparkjava.com/).
fwiw, I've done the middle of everything in an enterprise gig too, through various data feeds and clients, mergers and acquisitions, consumer vs business, connecting disparate groups like billing, sales, operations, etc. The thing we always paid a lot of attention to, and worked with every client, was the API, as it is essentially a contract, ideally with service level agreements with well defined schema and value types/ranges where appropriate. When we had to talk to a provider that didn't care, it was always a nightmare. Yes it took some extra time, but there was always a lot of reuse, and we were there to work with the clients, and we always looked upstream and downstream and tried to firm up as much as we could. Because our internal clients have real clients, and they might expect things to work reliably and timely or go somewhere else. But yah it is a bit more generalized at the enterprise level, I'm mostly talking about a browser SPA facing api, in the wild, where google punishes you for being too slow on an old android gsm phone, and since I only deliberately use JS in the browser anyway (this forum). Plus various concerns like keeping business logic out of the client and containerizing as appropriate. Also enterprise generally has much better networking than consumers. Fwiw no other programming forum seems very excited about rest, just the javascript folks for some reason, but there are numerous and even better ways to do things that have nothing to do with http (or javascript). So many half-baked rest api implementations, not general at all. Post with json nails it down for http browser clients just fine though, and ports seamlessly to websockets as appropriate (and other transport mechanisms). Plus sometimes you are better off just sending binary data (not urlencoded/bloated) so it isn't like http is everything. Sometimes programmers on both end of the wire know what they are doing. Sure there are workarounds, but that is just extra overhead you don't want, esp if you are considering a raw binary connection. 
Where I work we just had a data leak because some of our data files had fields that were position-based...I would kill for something as structured as CSV in that case LOL. Thankfully we are using better tech in other areas
Cool free resource, but realistically this feels more like 3 days of react, 1 week at most
service worker in webkit is [in development](https://webkit.org/status/#specification-service-workers).
Yeah, I get you. I was fired last year, since staff reduction, that was the best thing in my career. New job was infinitely more fun and interesting, with great people around. So don’t fear job change that much.
Anyone used this? is it legit? 
But are your current job more secure, as developer compered to your old low entry job? 
What helped me learn about RxJS/reactive programming in general was building a Slack clone using a vanilla view layer. I did have to use `ws` on the server in order to create a web-socket server for everyone to talk to but besides that, building the rest in plain JS + RxJS really helped me understand the *why* of RxJS along with some of the *how*.
Maybe the best tutorial is the example itself!, but I thought when I saw the title that it would be a classic tutorial with steps and this kind of things. It was only my own perception. Good work!
Thank you! I might write a medium post about it as a classic tutorial as well! :D
&gt; There are huge segments of the market that consider native apps to be the top of the class Well, I mean they currently are and have been, but this discussion is more forward looking than "what is the current opinion". Look at Android's upcoming [trusted web acitivities](https://developers.google.com/web/updates/2017/10/using-twa) which will allow for an Android app to transition between web based (presumably pwa) activities and native activities. Consider how [pwas are coming to windows store](https://www.thurrott.com/windows/windows-10/135665/pwas-coming-windows-store-windows-10-version-1803). Web assembly may reduce need for native code in performance intensive applications. &gt; ...not everyone is sold on the idea of web apps taking over. So, while everyone might not be sold on the idea, Android and Windows are rolling out strong support for PWAs and iOS is implementing the fundamentals required for a PWA. I guess we're still waiting on Linux?
I think you have to look at the problem from another angle completely. If you really want a blocking (synchronous) promt, you can use the [`prompt`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt) global function. But if you wish to build anything more dynamic, you have to accept that the user input is always asynchronous. Next, HTML and HTML Forms in particular give you structure. You should leverage that, not ignore it. You have already created a form. Give it a [submit handler](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit) and there you can see what values the user has chosen/entered.
You should post your question to /r/javahelp . This subreddit is for **javascript** not **java**.
Windows just announced they will support PWA on windows 10 !
Bite sized he said, i forwarded this to a college who'd like to learn. Sometimes bite size if the format you can digest. 
ok thank you
For sure. I work for a smaller, fast growing company, and compared to older job, I feel that I am needed here, and that I am trusted to do a lot more meaningful and important things.
I mean, you'll have to tweak it a bit, but yeah, you can move around a &lt;div&gt; or &lt;iframe&gt; the same way they're moving around an &lt;img&gt;.
AFAIK, Apple generally doesn't use major front end frameworks for some of their websites, https://apple.com, for instance. Their web applications, like iTunes Connect or https://developer.apple.com/account, use Angular 1.x
If your talking about websites in the sense of big ecommerce websites or corporate websites etc. There are multiple reasons. - Legacy, these frameworks are relatively new, the bigger the codebase the harder it is to move to a new technology stack. Months or years which costs tons of money. - Not neccesary, most of these websites are not that dynamic. It’s mostly just serving data and pages and user interaction is mostly navigation, only things like shopping carts cause actual writes to the server. It’s perfectly fine to just serve these pages as server rendered html and enhance with some javascript. - Performance. These websites are accessed from all kinds of countries, slow mobile phones, bad wifi. Serving a lot of client side javascript used more data and client cpu. And if the client doesn’s load the user can’t do anything. Ofcourse there are techniques to resolve some of this but still, it’s a thing. - SEO. If data is rendered client side that’s bad for google. So service side first websites are convenient here. - Developers - there are still a lot of devs that don’t have experience with these frameworks, also at big companies. I’m working at a big ecommerce company and we use React and stuff for interal tools like CMS’s. But for the website we want it as light as possible and render most html with PHP. It actually works fine and I have not come across a lot of use cases where I really felt the need for such a framework.
Yeah, effectively means that no one is upgrading today.
They will support PWA when net neutrality gets killled and they can some how figure out a way to take a 30% cut from web apps. 
&gt; I keep getting this error: Exception in thread "main" java.io.FileNotFoundException: input.txt (The system cannot find the file specified) Yeah, I have no idea why it isn't working either! 
so cool, thanks for motivation mate :) 
twitter uses react, they wrote a few blog posts about it
I saw the backlash to a similar article which was a bit short on actual concrete examples so with this I've attempted to provide some.
Amazon just released its own reactive front end framework/library Marko. Edit: never mind that was eBay. Whoops. 
If this is all one covers in a month that does not bode well. The official documentation/tutorials for react, redux, flux are far more useful in my opinion. What we have here are 1-page blog posts packaged together as an ebook, with the express purpose of building an email list. Agree to disagree I guess :) 
Great! Thanks. I got it to work!
Not sure why you say it's "for the express purpose of building an email list". All of those bite-size entries are available right there on the website by clicking on them. I'm assuming the PDF is intended as a way to read them all in one document. (Oddly, clicking on the "Get the PDF" links just jumps me to the top of the page.) **edit** I don't have a direct affiliation with the FSR team, just trying to clarify what I'm seeing there. I _did_ have a post published on the FSR blog, have talked with the FSR team in the past, and generally recommend the material they've written. The "30 Days of React" list is a pretty good overview of concepts for React and related technologies, and [I have it listed in the "React &gt; Getting Started" section](https://github.com/markerikson/react-redux-links#getting-started-1). on the front of my [React/Redux links list](https://github.com/markerikson/react-redux-links) as a recommended resource.
Yes. Try clicking on the individual entries to read the tutorials :)
Yes. If you want to learn React and some related concepts through a book, it's one that I'd recommend.
As a simple example, for the same http request, you're not guaranteed to always get the same response (It could fail, timeout, give a 404 etc.) You're absolutely right about asynchronicity and promises can be functional too; however, the libraries in question do not have that as a focus (although they could, at the expense of library size, performance etc). There are dedicated libraries out there who handle async flows and for good reasons too.
so is this backwards compatible with 4?
&gt; Doubtful google does as well...Frameworks save you time, but it's better in the long run if you only write the code you need. google has multiple frameworks in production, the biggest of which is angular. you might have heard of it.
Hehe funny joke
There are some breaking changes as with every major release, but most are related to pipes and i18n: https://github.com/angular/angular/blob/master/CHANGELOG.md#breaking-changes
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [angular/angular/.../**CHANGELOG.md#breaking-changes** (master → 60b9165)](https://github.com/angular/angular/blob/60b91656cd131378b62cf23c99203e637bf548a3/CHANGELOG.md#breaking-changes) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dp79c81.)^.
http://store.steampowered.com still uses jQuery 1.8 and un-concatenated un-minified CSS.
Alternatively I've tried to convert this code: &amp;nbsp; Function RemovePunctuation (sInput As String) As String Dim sCharacters As String Dim i As Long sCharacters = "\/:*?""&lt;&gt;|" For i = 1 To Len(sCharacters) sInput = Replace$(sInput, Mid$(sCharacters, i, 1), "") Next RemovePunctuation = sInput End Function &amp;nbsp; But I also couldn't get that to work. Any help is much appreciated.
upvote because it makes sense, tho google still sees the web platform as being ideal for data harvesting (due to its ubiquitous status vs native) so it's at least _somewhat_ less incentivized to improve dev UX experience on native apps. google could see its current UX as "basically solved" &amp; limit future investment.
Yeah, heard of it, but never ever used
Amazon still uses version 1.4 of jquery - i know this because i get creative with filling out their onerous vendor central shipping labels :)
Left Angular 1.x for React... Never liked all this Angular Typescript stuff... Still don't... 
I have a friend at Tumblr who says they have a bunch of custom stuff, because of their large codebase and a lot of their specific needs, but they're looking at switching. I think too much custom stuff and it gets really hard to hire and onboard.
I really like the bite sized nature of this but it's a bit much to say 30 days of react. It's more like 30 morning coffee's of react. 
Cool friend. Have fun.
Craigslist.
sounds perfect for me 
I wish I could redesign the Steam Store. There are so many minor annoyances. For example, I'd like to add stuff to my cart from my wishlist. And the interface just feels generally clunky with no real specific things I can point to unless I were to actually sit and make a list.
```${["S", "U"].reverse().join(' ')} ${["O", "O", "T"].reverse().join(' ')}```
There's at least one major issue with this post. I've only skimmed it but it's big enough that it makes me wary to trust the resource at all. The Author confuses a Pure Component with a Functional, or Presentational Component. As most of you no doubt know, a functional component lacks the lifecycle methods (and state) and is simply a factory function. A Pure Component, on the other hand, is simply a regular React component except that shouldComponentUpdate() uses a shallow comparison rather than a deep one on state/props. 
What the fuck has this got to do with JavaScript
Now that is a list I can support
ah, I see what you're saying, that definitely makes sense. thanks for the response! I wasn't able to find any library with flow that handled combined async/synchronous transformations, but it makes sense that libraries would try to keep it as simple and lightweight as possible
Some mobile browsers e.g. Safari has this functionality disabled. It requires a user interaction (e.g. click/touch) to initiate the play.
Photo editor sdk (https://www.photoeditorsdk.com/) works really well
You're conflating two different things. The **resource** is abstract and conceptual. URIs are not resources, the are **resource identifiers**. You could make the URI path a UUID or a random string and it wouldn't make a difference. In fact, that's arguably better, because it discourages people from constructing URIs based on their pattern—a big no-no with REST. The important thing about the REST style is not the resource identifier (which is effectively opaque), but the semantics of the resource. You should be **transferring** a **representation** of some **state**, regardless of whether you identify the resource as `/posts` or `/post/createPost`. Your semantics don't change just because the URI changed. People don't understand this, because they think REST is that thing with the pretty URIs that everyone started doing when Rails came out.
No, it's not bad. It's not REST, but it's valid HTTP. See: GraphQL.
I use Aurelia now. Never missed Angular since, not even for a second... 
http://google.com http://reddit.com
afaik reddit uses backbonejs https://www.whatruns.com/website/reddit.com
Amazon
Just throw it in some sort of JS Beautifier. =)
`TOO US`?
I've made grids with P5 before: [1](https://ajrussellaudio.github.io/squares/), [2](https://ajrussellaudio.github.io/isometric_grid/), [3](https://github.com/ajrussellaudio/expanding_grid) &lt;- interactive! It shouldn't be lagging. Mind sharing your code? And if it turns out P5 isn't the right tool for this, there's plenty of ways of doing it in vanilla JS, creating square divs and changing their style.
Hi /u/RyanLaserbeam, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/antoninj, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/souljabri557, For javascript help, please visit /r/LearnJavascript. Thank you!
Steam has been in 100% cruise-control mode for around a decade now, it's sad because they used to be an industry leader in their space.
I thought Reddit uses react? 
Yes sure. function Cell(i, j, width) { this.i = i; this.j = j; this.x = i * width; this.y = j * width; this.width = width; this.highLight = false; } Cell.prototype.show = function() { stroke(0); rect(this.x, this.y, this.width, this.width); this.highLight = collidePointRect(mouseX, mouseY, this.x, this.y, this.width, this.width); if (this.highLight) { //change color! fill('purple') } else { fill('green') } } function Grid(width, height, cellWidth) { this.cellWidth = cellWidth; this.width = width; this.height = height; this.cols = floor(this.width / this.cellWidth); this.rows = floor(this.height / this.cellWidth); this.cellArray = new Array(this.cols); for (var i = 0; i &lt; this.cellArray.length; i++) { this.cellArray[i] = new Array(this.rows); } for (var i = 0; i &lt; this.cols; i++) { for (var j = 0; j &lt; this.rows; j++) { this.cellArray[i][j] = new Cell(i, j, this.cellWidth); } } } Grid.prototype.show = function() { for (var i = 0; i &lt; this.cols; i++) { for (var j = 0; j &lt; this.rows; j++) { this.cellArray[i][j].show(); } } } var grid; function setup() { createCanvas(1921, 1081); grid = new Grid(width, height, 10); } function draw() { grid.show(); } 
I'm sorry if this is the wrong place. I read the questions and I did not find anything about not posting programming questions, so I thought it would be ok to post here.
I love using TypeScript with React!
I'm pretty confident they are still the industry leader - which is why they've been in cruise control. There is 0 reason to fix what is already the leader and grossing tons of $$$. (As a gaming platform, not design wise)
UGH, why? Is Javascript/Babel not good enough? 
You could also post in /r/processing. Lots of P5 types there.
Theres a strong case for Typescript with react with static analysis of proptypes etc. If it's a small app it's not worth it, but on larger more complex apps it's definitely worth it. Can be difficult to set up, personally I found it easy but I have a C# background so was like riding a bike.
UGH I know. What does Typescript offer that Javascript doesn't!?
&gt; webpack and friends are too complicated for what they do. Typically `node` applications don't make much use of webpack. 
From a different perspective... a few years ago as I transitioned from mostly back- end to mostly front-end I suddenly became enswarmed by Javascript zealots. These guys were embedded in a large media organisation and had managed to convince management that they were the be-all and end all, and backend devs were an anachronism who soon faced extinction. As a result... EVERYTHING was front end centric, and needlessly so. The number of times I went rogue and smashed a solution together in 4 hours using PHP and / or MySQL, while they spent weeks fucking around with missions like trying to get S3 buckets authenticating through the business's aging IDM / SSO was insane. These dimwits were proselytizing Nodejs when it was barely months old and calling the end of PHP. 7 years later... here we are. Don't get me wrong... I love the various flavours of Nodejs stack and the new paradigms... but horses for courses. Sometimes good old PHP + .htaccess and a few Mod Rewrite s gets you there quicker, and usually scales pretty well. 
My editor tells me exactly what props each component I use needs, and what types those props need to be. When I change a prop or add a new required prop, my editor and the compiler tells me every single location where I need to update the component usage before I even try to run the app. When I want to change the name of a variable, I can hit F2 and my editor will intelligently refactor the name across all the files in my project. While I'm typing, my editor gives me accurate autocomplete suggestions. I catch whole categories of bugs before they ever have a chance to run. I never have to write tests that check the shape of an object returned by a function - my editor and the compiler checks those kinds of things for me. I can hover my mouse over any keyword in my code and see the type and shape of that variable. I can hit F12 in my editor and it will bring me to the declaration or type definition of the keyword that my cursor has highlighted - I rarely have to check documentation for things like the properties of an object or the call signature of a function. I can refactor large pieces of code and have greater confidence that my code still works. My code documents itself. TypeScript type checking is now built into Babel as of v7 beta - so I still only have one compilation tool. TypeScript is highly compatible with the duck typing commonly used in JavaScript and its typing system is sophisticated enough to describe the vast majority of JavaScript APIs with features like generics, structural interfaces, signature overloading, etc. Typing is optional - I can always use the any type for something and fallback to plain old JS behavior.
With Babel v7 having TypeScript checking built in, it's really not that complicated to set up. Certainly no more difficult than Webpack or Express.
Static typing is a big thing for starters. 
https://www.reddit.com/r/javascript/comments/7a5g6j/version_500_of_angular_now_available_angular_blog/dp7nc1e/
&gt; `collidePointRect` I think you're using the [p5.collide2D](https://github.com/bmoren/p5.collide2D) library, right? I think that's what's slowing you down. Collision detection is pretty slow, and like you say it's happening so many times a second. But p5 doesn't have a built-in way of getting mouse events for shapes. Once a shape is drawn it's just pixels, p5 doesn't care about it anymore. I think you want to look into the [p5.dom](https://p5js.org/reference/#/libraries/p5.dom) library, which will allow you to create HTML elements in the same way you make shapes in regular p5. HTML elements have built-in mouse events which p5 can make use of, like a [mouseOver](https://p5js.org/reference/#/p5.Element/mouseOver) function which calls a function when your mouse touches the element.
Why does the end user need to be engaged in Node.js? End user is only be using the interface. The language used to build it shouldn't matter.
If you've ever worked on a large application, you'd know that it's pretty much a necessity to have static type analysis.
 This would be good review of Typescript if you were able to distinguish Typescript and IDE features. 
Didn't read it yet, but In functional terms, a function not depending on state and not having side effects, but just being a computation on its input is called a "pure function" , maybe the author is referring to purity in that sense. 
Those IDE features aren't available or don't work well if I'm not using TypeScript....
Which would be fine if 'pure component' wasn't already a taken name, but it is, so it's incorrect to call a functional component a pure component. 
1. I can see a lot of potential here. 2. Wow, that npm name is a steal. Kinda feel compelled to build its package, y'know?
Parts of it use React, like the user profile page.
Yes! Signed up.
As someone who knows React it's easy to pass all this information as simple material anyone can flash right through, but in practice as someone new to React truly understanding each of these concepts takes time and should be supplemented with personal exploration. I sure as hell didn't truly understand all these concepts in my first 3 days of using React.
Kinda explains why it's still so bad. The steam store has never been a pleasure to navigate IME
Would this support OpenStreetMap out of the box?
Sarcasm detected
Thank you very much. This was a good suggestion.
Thank you this suggestion. I will let you know how I make out
They peaked in 2015 with Monster game event.
Neat.
 I followed this tutorial. It's good. I appreciate the testing part.
Yeah in game platform/delivery, they have the lead still, you're right about that. I guess I was referring more to their client (off-topic, yes), which is falling behind companies like Blizzard more every day. &gt; There is 0 reason to fix what is already the leader and grossing tons of $$$ I respectfully disagree -- this is how you give a foothold to newcomers. On a long enough timeline, someone _will_ create a more compelling platform (+client), and if Steam just treads water, they'll be woefully unable to recapture lost users once they've jumped ship.
oh man, sounds great. Too bad they don't support async/await.
Postman has a GUI. If you're looking for a command line program, you can use curl. 
They do in the latest version :) https://scotch.io/tutorials/whats-new-in-adonisjs-40#toc-es6-features
Yeah every since updating to node 8.5+ I don't include webpack or babel/transpilation in any of my node.js applications since I don't need any of the features they provide. I know in a lot of cases you can use webpack for other sought after features, but transpilation is my number 1, and I rarely need it with the speed that node adopts features.
Not a necessity but it sure is a pain in the ass to debug/make sure all of your models and contracts between modules/api's aren't broken by even the simplest of changes. Our large scale application didn't use typescript until recent and it wasn't until we made the decision to use it that I finally understood the godsend that static typing can be.
Should I have a base understanding of JS before looking at this?
I didn't find any tutorials on udemy.
It's a "relatively" new framework, so you won't find much learning material *yet*. The good news is its pretty easy to learn and straightforward - just the official documentation is enough to get productive. If that's not enough, the creator has a series of YouTube videos (albeit a bit outdated): [Getting Started with AdonisJS Playlist](https://www.youtube.com/watch?v=3dRbd2G9QZI&amp;list=PLWmIA5YpCsizOMoM3tH5NSp1sHmdzVLvW) [Edge - Node.js Templating Engine Playlist](https://www.youtube.com/watch?v=0gTR9fRB__g&amp;list=PLWmIA5YpCsiyO7LmrJcs2Z8ys_rW1A3w2) There is also an Awesome list: https://github.com/zgabievi/awesome-adonisjs
&gt; Dictionary is subpar for performance in most scenarios. Hidden classes are better. You obviously missed my point. Object.freeze allows the compiler to do optimizations by knowing that this object won't change. That can include the optimizations involved with hidden classes, and most likely does. Object.freeze might not do _anything_, but it certainly doesn't hurt, and as a standard language feature I see no reason to avoid using it when it could actually provide some benefits.
and this is a server side framework right? so it's seo-safe?
just to be that guy: "factoid" actually means usually-false information that is repeated so often that people just assume it's true 
welcome!
What's the goal?
Hi /u/account0007, For javascript help, please visit /r/LearnJavascript. Thank you!
absolutely - just as safe as laravel / ruby on rails / asp.net mvc
There is no indication that any of the current JS engines are doing that at the moment, and historically the opposite is true as we have seen performance degradation due to Object.freeze. So instead of scattering Object.freeze() in your **application** code, you should just use a library (or create your own utility). In the library you can attempt environment detection, which would do the appropriate thing. 
Wow, wasn't it only early last year that we had Angular 2.0? How did it get to 5 so fast? 
There is a new release each six months and Angular 3 was skipped to re-align the version numbers of all packages and switch to semver.
The simple fact is JS has had a huge amount of effort spent on it, and it's good enough for 99% of use cases. So it makes sense to use the same language and often code base as much as possible.
yeah, sure! Just checkout [this demo](https://maptalks.org/examples/en/tilelayer-projection/fragment-shader/#tilelayer-projection_fragment-shader)
I'm also new here, I like the mobile version on Reddit more then the desktop version
To be able test API's and also as a dashboard for status of tests. Ease of use and central service. closer to what assertible does.
vuejs here. skipped town when learning angular 1 and no upgrade path. also too much faith in name brand
I'm learning Angular 4 now! Because to find a job, they demand more Angular than any other framework, at least in my afea! For a junior developer the requirements getting higher and higher :(
What if i've worked on over five large applications over thirteen years and disagree with you? I do love that the kids find the IDE stuff so impressive!
The only problem with Aurelia is no one supports aurelia.
&gt; closures As import as closures are, I would not consider them an 'advanced' JavaScript idea. Most of the time, the situation in which these are used *are* pretty basic and simple. You don't need anything fancy or complex. If you deal with async code, you have closures. &gt; promises Understand promises before you even try to understand async/await, as those two are just promises wearing pretty clothing. To understand why promises are so wonderful -- simple. Take any piece of async code you have with callback hell (more than one callback level) and re-write it using promises. You'll be hooked. &gt; async/await Write promise based code with some syntax sugar to make it look nice. &gt; apply, call, bind With a lot of modern programming tools and arrow functions, the use of these has become a LOT less common. They just control how `this` looks to the function you call. If you write modern ES6+ code, you may never need them. &gt; prototypes &gt; OOP These are hard for people coming from C#, Java and C++ to understand as JavaScript is OO, but it isn't a class-based language. (The introduction of the `class` keyword is weird, its still not class-based.) &gt; higher order functions &gt; currying I've spent HOURS -- HOURS and HOURS wrapping my head around functional programming. Take everything you know and forget it... then realize just how beautiful functional programming is. Job security -- nobody else will understand your code. Ever. &gt; modular code Think of `Math` as a module. Isn't it nice to have (most) Math functions grouped under a common name-space? That's a basic module. With advanced modules, you can use a module loader to keep things from loading globally. That way, I can write a 'Gizmo' library and you 'Gizmo' library and the two libraries can be totally independent. No name collisions. For small projects, modular code doesn't always make sense. For any project above about -- oh -- 500 lines -- maybe? It really helps. The best way to learn and understand coding concepts is to 1) Read good code. See beautiful code. See huge programs that are so cleanly laid out you can follow them. 
Is this a joke? 30 days? Facebook recently redid the docs and they're even better than before, should take an afternoon to digest. My favorite part of this is that the website hosting this crap isn't even built with react.
Start here: https://www.w3schools.com/js/
Thats what I've been doing all week, but there are a ton of files in this game and I have No idea how to properly package them together, I havent gotten that far yet. What im trying to do is edit the code of the game to add variables and certain things. 
 I hope this is as awesome as it sounds! I can't wait! Thanks so much :)
React is dead. Even Netflix is moving away from it.
Why not both? 
I did c# in school and it helps you understand a lot of the syntax and how object oriented coding works but overall I see more postings for js and now that node.js is growing for backend it puts more js in the picture. 
Hey thanks a lot! I wrote about how I got it: https://medium.com/server-for-node-js/getting-a-great-npm-name-b0b2b27a0e1b
anyone in this thread actually using it?
The title is misleading - the term "fullstack" suggests that there will be SSR (Server Side Rendering) involved, but I only saw client side React. Otherwise, thank you for the free material.
5? Lol fuck off.
Don't know why this is getting so many down-votes. Angular is dead to me, and every developer I know now.
With typescript it would take less than 5 years instead of 13.
Does it have a readme file? If so, hopefully that has some instructions. If it has a package.json, run `npm install` (do you have npm?) and see if it has any relevant “scripts” entries in the package.json. 
There's not really a right answer to this question - it depends on the job and company you want to work for. If you're interested in a full stack job with a smaller or younger company, Javascript is likely a good choice as many are using Node/JS for exactly the reasons you specified. If however you'd like to work for larger enterprise corporations, C# will be better for backend and Javascript may be used (although less frequently) on the frontend. One way to figure out what would be best to learn is to find 10-20 job listings for a job you'd like and see what languages and skills are mentioned. If you see more or less of one maybe that can point you down a path?
Cheers for hooking this up!
Here is a web based solution: [https://github.com/brookshi/Hitchhiker](https://github.com/brookshi/Hitchhiker) It looks and feels similar to Postman.
Signed up
Adding a link to the Github page you downloaded it from might help people give better answers, or at least more context.
Yes. Otherwise at some point (rather soon) it will become very frustrating.
I like the introduction and usage of redux there, seeing it grow step by step.
Thank you.
Much appreciated.
Thank you
It's strange mine is working. Maybe I'm using wrong IDE. 
Thank you for signing up.
https://blog.jetbrains.com/webstorm/2015/05/ecmascript-6-in-webstorm-transpiling/
To continue this discussion (this is great! :D), I've used Origin, Battle.net, and UPlay for serious games. In my personal experience I have found most platforms to feel more clunky then steam (often using 1% - 5% cpu on their animations, I have an overclocked i5-7600k). Battle.net is really nice, their auto updating works great. On the other hand so does steams. I'm not aware of any features of other platforms that offer an advantage over steam. The only thing I can see is game selection, and there isn't much Valve can do about that then either A) Drop profits or B) Offer some feature that is really hard to replicate. tl;dr, I haven't really seen any "innovation" from other platforms, they're either playing catchup or they work fine, but without notable features that outmatch steam. 
In settings, under language, and javascript, there is a dropdown that will let you change js version. 
Does this include a Firebase security rules tutorial?
If you have a jsconfig or tsconfig file, set your project settings to use it for your linting.
Yes, for certain. Initially I'll do everything without security so that it's easy to understand how firestore (or stoage) works. Once we add authentication to the mix I will explain how security rules work and why they are impotant.
Me! Despite the anti-Angular circlejerk on Reddit, I’m finding it excellent.
I think you didn't understand what netflix was doing when they tweeted about react client side.
React 15?! Fuck off.
Firefox Dev tools allow you to replay post requests in the network tab. 
I grew up with C++ and later C# became a major part of my job and career. But nowadays i rarely use it, almost never. Strangely i use C++ more than #. We use JS on the web of course, JS through Node on the server and write desktop applications either with JS through Electron or natively with JS in React-Native. The biggest thing C# has going for it atm is the backend, we still have some Azure roles written in it. But it has to share space with Node and perhaps Go now, and the reasons to use # over the two are getting fewer and fewer. As for applications, # in my opinion is getting irrelevant. Xamarin has never attracted much attention, Microsoft did buy it, but now they are heavily invested in JS and React (react-native-windows, reactXP, officeFabric).
Firebase is good for what use cases? I've heard of it but know nothing about it.
I have tried p5.dom as well. Only difference is that in Cell I had a function called Hover() where I check whether or not the mouse pointer is in the cell. Same result, it has to loop over all Cells to check the mouse coordinates relative to the Cell. I think I need something where looping over all Cells is not necessary. Something that calls a function on hover and on Click in stead of looping over all of them to check for a hover / click.
It doesn't necessarily have to be p5 or processing. I just thought that would do the job nicely but perhaps I'm wrong.
I don't think Perlin noise is ideal for that sort of _terrain_. In general Perlin gives you _gradient noise_ while that terrain looks "mostly flat with some random elevated pillars", i.e. not _gradient_ at all. You could, of course, generate Perlin and then apply some sort of threshold, but there's probably simpler ways to do it. Anyway, the subject's too big to answer here. I don't know if this helps, but Daniel Shiffman has both a series on Perlin Noise and [this challenge](https://www.youtube.com/watch?v=IKB1hWWedMk) where he creates a 3D terrain from Perlin noise in 30 minutes.
They merely moved react to the server. They're still react driven. As for react being dead, [it's going up in usage stats more rapidly than ever before](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core).
Great question. So Firebase offers 5 things to web developers: It gives you a real-time database, it handles authentication so that you can create user accounts, it lets you store binary data on your app like images or movies, it lets you write serverside code as cloud functions and it takes care of hosting your app.When you are starting out, the idea of building a full-stack application is exciting but the reality is hours and hours of fiddling with boilerplate and configurations you don't really understand. This is dangerous because motivation to build an app is quickly brought to its knees by the amount of configuration you have to do in javascript land. Firebase takes care of all this boilerplate associated with the initial stages of backend development. So if you are a front-end developer looking to make the jump to full-stack development, it gives you everything you need get an app up an running.
This only means less dependency problems ;-)
Aurelia is such a great hugely underrated framework.
Thank you.
Good bot.
If you do a segment on optimising for speed I would be very interested. In this day and age lightning fast load times are very important for me. Shaving every 10ms is a big deal to the kinds of projects and contexts I work in. I've avoided firebase for this reason but I would love to use it if there is a way to actually build something that can be fast. 
UC browser was support! [https://itunes.apple.com/cn/app/uc-liu-lan-qi-ji-su-yu-le/id586871187?mt=8](https://itunes.apple.com/cn/app/uc-liu-lan-qi-ji-su-yu-le/id586871187?mt=8)
you can see [uc-cartoon](https://cartoon.uc.cn)
React went from 0.14 to 15. All it is is just dropping the first digit in the release cycle. React 15 or 16 is effectively 0.15.0 or 0.16.0
I’m posting this in /r/javascript because JavaScript is the most used language on Github so you might be interested
Good answer :) I'll have a look at it this afternoon :)
Not something I thought of, but it's an interesting idea. Noted. Thank you.
Great stuff. Thank you.
That demo in the end would only make sense if it's ported correctly. I've seen a bunch of them and they always run without the artificial slowdown, which they have cut out for whatever reason. In the original each node executes a long drawn calculation in order to emulate slow components that take lesser priority over the whole tree. Fiber takes that into account and prioritizes the tree animation, that is how the framerate reaches 60fps. Someone added it back via PR in Stencils case but they never got around updating the online demo. I tried their demo with the PR, it lags badly, even on high end hardware. When they demoed it at PolymerSummit they essentially tricked people into thinking the browser is as fast as Fiber, when all they did is render a couples of bubbles. I feel like this will become critical. Scheduling is a userland decision, the browser can't and won't know which components have lower or higher priority. You can optimize the browser engine as much as you want, it will never perform like Fiber once it switches officially to asnyc rendering. Unless of course we get a low-level priority API. But until then it's kind of silly to fake demos in order to make Polymer/lit/Stencil and Skate "look" fast.
Very cool
Importantly, most people can upgrade React versions with no API changes
Thx! This helped!
it's semver. a breaking change +1 the MAJOR version
Rather than document.location.href, you should be using window.location.href
Is there any online certification course which also provides job assistance after the completion of the training.
But how will you tell your PWA to use UC browser when the someone click on it's icon, instead of using the default browser.
&gt; Instead I think the shift will be in the opposite direction: writing a native app will feel more and more like writing a web app, and we will see a resurgence of native app popularity, not the other way around. While i do think you have a point there, let me remind that there's also a push towards web assembly atm ;) All in all i see a lot of potential for an app that would encompass PWA features plus wasm level code. But apps serve their own purpose they'll live on whatever happens.
Agree let the project pull requests do the talking.
I wasn't planning on adding anything like that. My goal was to proivide a practical understand. The successful outcome is to build an an application that you deploy. That way you can show a potential client or employee what you have built rather than a showing them a certificate. That said, I do understand the value in a certificate if you are looking for a job. Rather than issuing a certificate of my own, is there an authority that provides these taht I can associate with? Forgive me, this is unfamiliar to me. What kind of certificates have you recieved form other online courses?
https://www.bankofamerica.com/
Pretty good shit post.
Sure!
Practice practice practice. Also, 3 years? None of what you described is new in the last 3 years. You're just describing the natural transition from beginner JS to slightly above beginner but not yet intermediate JS. 
US TOO....
Hmm, must've been edited, sorry about that...
Excellent recommendation for react by Wes Bos 👍
An authority that provides these might be udemy or something in that vane. Wes offers certificates primarily for tax and proof of purchase for employers. I do think having a useable app that you can explain decision making on will serve better in interviews, but doesn’t do much for you before that. The job hunt struggle is real, especially for noobs :/
Try this: https://blog.jetbrains.com/webstorm/2015/05/ecmascript-6-in-webstorm-transpiling/
I can definitely do what Wes does, that's just putting a pdf together. I will look into udemy and see what they offer. Thank you for bringing this up. I will add a certificate, and I'll loook into teh best way to do this. Good luck with the job hunt till then.
Do you know of a good reading resource regarding TS in Babel? Where would i start if i wanted to try that out?
It was so useful when I was learning react. I couldn't not recommend it. 
i found it easiest to have a root/layout component that renders all of the general content and have the routes define what component they want to render ([example](https://github.com/r6db/frontend/blob/29eab5dfcb71f82547f84c61701b177b929fee3d/src/app/components/index.js#L82) dev-branch of the same file is with dynamic import). its the same as in any other vdom-library: write components for each logical part; combine them into pages and you got a viewlayer going. you can do a switch (or your preferred way of choice) over some variable to determine the page/template/whatever to render inside your layout component what i want to emphasize here: you really, *really* want to separate your business layer. use redux or something and just pass that in to your component tree.
Who ever said they are the pinnacle of app achievement? They are good enough, that's the point. In many cases indistinguishable.
It’s all react around here. Looks like there are red and blue territories all over...
The way I coped with it is considered all of them as part of a standard. If it already is standard, I don't mess with it unless I needed to. One example (pre modernJS era) I love to use is the ASP.NET development era. Most of us used Visual Studio, which hid all the underlying complexities in a very good manner. We never need to know about MSBuild (unless we chose to), we don't need to know about even wiring (because events is automatically wired). I just need to write my code in aspx/cs files, and somehow, magically, it runs. To think that we need to get an ASP.NET up and running from scratch without VS would be a nightmare. My approach is the same for modern JS and build process. I considered them as a standard toolset, so I started our projects using pre-built starter kits and boilerplates, so we don't NEED to know all those webpack/babel/etc upfront. We just need to write code the way they told me too. Eventually we will need to touch them as our requirement changes, so it comes to us naturally. The important thing is we have a playground of preconfigured components to tinker with. It's much easier to start with that then, say, setting those up from scratch. 
Did you install the typings from DefinitelyTyped? 
I know it’s not new, but when I started out it wasn’t as used as it’s now (I started about 5 years ago, the 3 years are when I was capable enough to make real projects for profit). Now it’s like you can’t do anything without Node. I understand raw JS quite well, it’s just Node and VCS that’s new for me. I did quite few complex projects by myself with just JS and jQuery, that nowadays you can just install packages for. I got no problem with the coding itself, it’s just the environment/project structure I’m strugling with.
Hmmm. I was thinking of creating the pillars individually. Not make them part of the same “graph” if that makes sense. So they are not connected to each other at the bottom. 
Oh perfect, thanks! Signed up😃
Thank you.
That’s a good way of looking at it. I actually worked with VS and .NET when learning C# in school, I was pretty good at it then. I don’t know how it compares to ASP but I imagine it’s very similar. I really liked the simplicity of VS, that all I had to do was write my code. I can’t seem to find that in Node projects. Maybe I just wasn’t looking hard enough for some templates/boilerplates. I just need to find my *main.cs* alternative in Node and I’m good to go.
&gt; Suddenly I learn that everyone is making their projects on GitHub and using this thing called Node.js. Uh, since about 2012.
I would sign up for a Vue + firebase course
&gt; Until we get a low-level priority API, a v-dom will perform faster, and looking at the Sierpinski demo the difference is night and day. Can you expand on this a bit? What property of V-dom would it make it "perform faster" than html fragments/templates and slots? 
I never needed it until recently and I don’t really follow what’s going on in the tech world. Thus my surprise of how much new stuff there is when I finally needed to use it.
The thing is then I don't see much use for a Perlin noise map.
thanks ;)
I'm afraid I can't help you there. There is definitely a few vue + firestore tutorials out there though. I bumped into them when I was looking for react + firestore ones.
speaking of the Sierpinski demo, i never did get an answer to my question. perhaps you can help out? https://www.reddit.com/r/javascript/comments/77zhy4/build_a_mini_react_fiber/doscgsb/
Maybe you have to use webpack.NoErrorsPlugin() with it
Everything overcomplicates stuff. Things really haven't changed all that much. There are a multitude of new tools, yes. And everyone is all about jumping on the next big thing. That doesn't matter, all the old tools still work. The new stuff simply provides more opportunities. You can jump into it bit by bit if you'd like. Anyway, Node is simply used to run javascript outside of the web browser. Javascript can be used on both the front-end and back-end of a website. Many developers use node to create and run their HTTP server. Other developers now use node to run build tooling. This helps them to automate setting up and maintaining their codebase. These tasks could be as simple as concatenating and minifying their build scripts together or as complex like parsing, validating, and transpiling code from one language into another. Basically, you can use javascript for everything anywhere now. A huge amount of javascript developers use node for package management. They use the tools NPM or Yarn (which are simply javascript applications) to download and maintain libraries that will be used in their applications. If you're writing for the backend, then you don't need to do anything to use these libraries. They can be included in your project right a way, as node has built-in support for modules. However, if you're writing for the web browser you'll need a second tool -- webpack, browserify, or rollup for example -- to bundle together your javascript. This step is a bit more complex than simply concatenating the files together, as it translates the module APIs into one cohesive system the browser can use.
https://claudiopro.github.io/react-fiber-vs-stack-demo/ Fiber implements a scheduler which can defer work in order to favour components that are more important, for instance to maintain a steady framerate. In that demo each node carries an artificial slowdown, and as you can see in the stack implementation it lags badly. Fiber favours the overall tree and defers the nodes if they're over their budget. The Google team took this demo, removed the slowdown and presented it at the recent PolymerSummit saying the templates and browser scheduling is now as fast as a scheduled v-dom, which the linked talk also claims, in the end it concludes with that demo. The browser can't schedule. It can be optimized but the difference between Fiber v-dom and templates/browsder-scheduled will always be drastic.
programming isnt fashion where you just look at the latest trends to be cool.Working for bigger companies means a stable codebase for years.
Yes! I should’ve been more clear in my post, NPM and the packages are what’s causing me the most headache. I am writing for web browsers mostly and trying to avoid using Node (or NPM or what was it), the first thing I did was exactly what you wrote - trying to mash the files together.
I haven't tried putting my flow validation step in webpack _per se_; I normally pop the flow validation as part of my linting with `eslint`. So my stack is most often just `eslint` and `babel` (with a `flowtype` plugin).
I don't know p5js, but my suggestion is to start with each pillar as a rectangle, subdivide each side of the rectangle into a number of segments, and then perturb each point on the side in the X coordinate using Perlin noise. You might also want to take your question to /r/proceduralgeneration.
Yeah, I’m slowly starting to realize that. I’ve never worked for a company, I always did good by myself, so I was never required to adhere to certain rules or use certain tools (never used git for instance). That made me a bit isolated, so now I feel like a caveman who just discovered fire, looking at all the things I missed out on.
well, let us know what do you want to do, then we can start searching together. Other than that, you can just create an main.js and start running it by node main.js. 
Dont stress it out.If you are proficient at inner workings of a languange , anything that comes out will be a piece of cake.Git takes at most week to learn well and can help a lot for future projects.Node js is basically a JS server which has good I/O but sucks at anything else so i would rather use java for serious software or php for faster ones.
once you install an npm package (npm install {{package}} --save) you'll be able to include it in any source code. To do so you'll probably use const package = require('packagename'); That will essentially import the package, making it accessible under whatever variable you define there. In this case "package". How you use the package will be included in the package documentation. Usually the readme file on their github (or elsewhere) page. To bundle it all together, most developers use webpack these days. Webpack is a crazy behemoth that can instantly overwhelm the best of developers. Start super small. Simply use it to bundle your javascript. Install webpack with NPM, but use the --save-dev flag instead of --save. The difference is what's included in your project vs. what's used to build your project. create a new file, webpack.config.js, include the following code module.exports = { entry: "./entry.js", output: { path: __dirname, filename: "bundle.js" } }; where entry.js is your "main" javascript file, and bundle.js is the file you'll include in your webpage. Name them whatever you want. Run "webpack" from the command line, there you go!
&gt; For some reason js programming looks like having a very simple task and trying to make it look more complex by using the latest "insertWord.js" framework for ..reasons. Many applications built with JavaScript are far from simple. Frameworks and libraries exist to help make some tasks simple. &gt; I remember ember being the holy grail and angular being used everywhere.Now noone will use them cause hey , react exists. Angular is still incredibly popular. People haven’t just dropped everything for React. &gt; Not to mention 99% of them dont even do anything that you cant easily do with pure JS.No you dont need 500kb of scripts to add some handlers or select elements. Right. You don’t need a framework for simple tasks and you can write everything with pure JavaScript and access the browser’s APIs directly. Deciding to use a framework or library is a trade off between code maintainability, engineering resources, and code size to name a few. You can also write all of your native programs in assembly but being able to use Python to abstract all of that away is pretty nice. &gt; By the way , there is one framework which i love and thats typescript. TypeScript is a language, not a framework.
Could you provide an example where there would be a reason to change from a framework to another?
I can't speak to what the junior level requirements were in 2010, but as a Junior Developer looking for my first full-time gig I can say that in my market(Nashville TN) that is a correct statement. I'm a junior dev that was taught CSS, HTML, JQuery, Angular 1.x, and React from a local bootcamp, and I'm still finding it hard to land my first full time position. 
Well of course you could write your own JS to do what JS in libraries does. Why would you want to keep solving problems that have already been solved over and over though?
In [our case](https://twitter.com/0xca0a/status/884851183051001856) it happens almost all of the time that we have nodes that go deeper than just mere representations. They look up state that's non reactive, do calculations in them, etc. Even in simple examples like a virtual list, why'd you render 1.000.000 elements when your screen can present only 10? In Fiber making a "virtual list" is very, very simple as well as deferring anything really that takes up work. 
C# is dead... 
Because to use the "solved" problems you have to learn an entire framework with possibly 100s of documentation pages.Next year you have to do the same thing with a newer framework or what another company uses.So you end up with the same problems you started with , having to read how to do X , and solving bug Y. If in that time you had become proficient at JS core you could instantly write anything new you come up with with your existing knowledge
Google vendor lock in.
Each framework has their own pain points. Maybe you don’t want to deal with Express passport authentication so you switch to Meteor. 
You can do virtually everything in vanilla JS. However, if you're not a single person with almost infinite time on your hands, that's something you don't want to do. For smaller tasks, I'll still recommend vanilla HTML/CSS/JS. Also, you don't have to learn every new framework, just the major differences, because most of them are now rather similar, or at least approaching similar patterns. They contain some kind of model abstraction, a template engine and/or virtual DOM and some glue code for components, controllers and side effects. By the way, typescript is not a framework, but a transpiler (like babel or coffeescript) that adds a few features of future JS specifications and type checking to the language.
Well it's hard like everyone is saying that to land a job as Junior Developer you should speak CSS/HTML, Javascript and Jquery but it's actually more. I'm speaking for Switzerland! Of course if you plan jsut want to be a designer, than yes, you only need these, but than you need Photoshop and so on...
But animation prioritization has nothing to do with HTML literals. I think they only wanted to show the true cost (processor usage, not UX/jankiness) of diffing a whole tree vs using native dynamic slots, so maybe that demo wasn't a good choice. I think that not using V-dom doesn't prevent you from doing animation scheduling.
Angular 1 is a good example: there was no migration strategy for the developers, so some of them switched either to Angular 2 to find themselves stranded again, while others made the switch to React, Preact or Vue.
Have js frameworks ever been "needed"? No. Has js ever been "needed"? No. Has the Internet ever been "needed"? No. Have computers ever been "needed"? No. But they are all extremely helpful and usually desired. I am just old enough to remember when most of the world population used no computers at all. They lived their lives, ate the food they "needed" to survive, and had kids. In fact, if you asked them, many would have questioned the need and even the desirability of computers, the same as you are questioning js frameworks.
Animation wasn't the point of that demo. It was made to demonstrate that Fiber can favour the entire structure over a small node that interrupts the overall framerate. This is what makes the major difference between native and web apps in general. Not using a scheduled v-dom will prevent you from reaching native performance. Because you have no means of telling the browser which components can be favoured. This is why they took the demo, and people were clapping hard. But as i said, they have removed the slowdown, thereby rendering a couple of div tags. I have ran their demo with the PR, it lags as bas as stack on my 2017 MBP. 
Who said anything about look at "the latest trends to be cool". More like "current technology to stay employable." Pretty big difference.
I was a junior in 2008 and I remember my interview test having jQuery/CSS/HTML and thats it. The important factor was willingness and capability to learn. Even tho my current company looks for more skills in a junior dev (having at least looked at React/SASS) we still prioritise interest and enthusiasm to learn over any current knowledge/experience. 
You'd rather use PHP than Node which "sucks at everything else"? Can you explain why?
I can only speak to my environment, but in general the landscape for front end development is always evolving and thus so are job requirements. That being said, if we hire junior devs it is mostly because we see drive, interest, etc from them - we like of course if they're familiar with our stack, but usually junior devs are given focused/simple tasks in our daily work that is only a snippet of what our mid and senior developers know. Focus on good fundamentals in JS, have a decent understanding of how the web and operating systems work in general and that should get you in at most places. Keep in mind 99% of junior dev jobs are with the idea that you will grow and ultimately provide value to the org at the exchange of you learning - so you need to highlight and make apparent that you are someone who can and will do that :). Good luck!
This is so far from the truth. You do not need to understand every bit of a library or framework to use it effectively in a large number of cases and there is nothing requiring you to switch to the new hotness every year.
Do you have a link to that demo.
You can pick a modern front end stack that will let you just write code without installing anything from npm. If you use Vue and load it from a CDN, you can build a component-based application without installing anything or needing to introduce a build step during development. Granted, if your project is large, you will probably want to separate it into modules, which means that you will still need to use rollup or some comparable tool when you are ready to ship it in production. But yes, it is still entirely possible to get started and be productive without a heavyweight boilerplate that pulls in megabytes of garbage from npm.
Yep, that's the one they showcased: https://stencil-fiber-demo.firebaseapp.com/ You can go to their git, build it (the PR is merged), and see it chugging along.
There's no empirical answer. For instance, a lot of companies now don't care if you know jQuery, but some do. It's always going to be different. You'll be served much better by looking on job sites for junior developer / intern positions and looking at what experience they require so you can get a feel. For my field and my type of work, I expect you to have general knowledge of css and layout, know how to use React, know fundamental Javascript, be able to make async calls, comment your code without being prompted to, know how to use git and have unix and terminal experience, and I expect for you to be able to teach yourself (e.g. once I get a handle on what you know, if I ask you to figure out something you don't know and learn it, how quickly are you able to do that, what type of resources do you pull from to learn it, etc)
You switch when what you currently have no longer meets your needs and it is more expensive to make what you have for those needs than it is to switch to something that already fits those needs. For example, when I started at my current company our frontend was all jQuery. As we grew and added more features that jQuery became very difficult to manage and its brittleness slowed down our ability to add those features. We began moving to React, slowly at first and in a limited set of places. At this point the majority of our frontend is now React with only some legacy sections persisting as jQuery. It’s greatly increase our ability to build our product and so the switch has been hugely successful. Since React meets all of our needs today there is no reason for us to even investigate newer libraries.
It's a lot of new tooling, but most of it is pretty easy to pick up. I'd recommend the following (based on the last 2 yrs of "modern" web dev experience): Use https://github.com/creationix/nvm to manage your Node installation. It makes upgrading to the latest releases an absolute breeze. Should take 5 mins to learn. After installing node, try `npm install -g create-react-app` followed by `create-react-app myapp` wherever you want to setup the template. This gives you all the build tools ready to go for a modern, ES6 react project. You can learn a ton just by studying the boilerplate. As for Node itself, I personally recommend using Koa over Express, as it is more async/await by default (v2 is, at least). TJ Holowaychuk wrote both and recommends the former as being "superior". As for the guy saying Node "sucks" and you should use PHP, that is very bad advice. Node is awesome.
I use this package https://www.npmjs.com/package/npm-run-all So I can have the following scripts in package.json ``` "lint-js": "eslint", "lint-types": "flow", "lint": "run-p lint-*", "validate": "run-s test lint", "prepush": "validate" ```
Google script is based off of Javascript and as I couldn't find a subreddit for Google script I thought I'd try it here. Anyway I found the solution and it's pretty simple: &amp;nbsp; function RemovePunctuation (sInput) { sInput = sInput.replace(/[^a-zA-Z0-9 ]/g, ""); return sInput; } &amp;nbsp; So leaving this comment in case someone else runs into a similar issue.
Being able to write JavaScript *without* relying on JQuery is actually more helpful than knowing JQuery. 
Well here is the problem.If you start integrating a framework which you have not thoroughly studied then you might unexpectedly find an issue in the future and say "damn i should have known this framework is incompatible with thing y"
Hello Friends, I'm cross-posting this link from /r/math. I learned a few tricks with WebGL and mobile optimization, vue.js and lazy script loading. I hope this could be interesting to /r/javascript community. The source code for the tool with description of how it's made is available here: https://github.com/anvaka/fieldplay Lot's of great vector field examples are in [this thread](https://www.reddit.com/r/math/comments/7a4z4u/beautiful_world_of_vector_fields_this_is_the_tool/). Here are a few of my favorite: [Shear zone](https://anvaka.github.io/fieldplay/#?dt=0.01&amp;fo=0.998&amp;dp=0.009&amp;cm=1&amp;cx=0&amp;cy=0&amp;w=8.539734222673566&amp;h=8.539734222673566&amp;code=float%20r%20%3D%20length%28p%29%20-%201.5%3B%0Afloat%20c%20%3D%201.0%2F%281.0%2Bexp%28-5.0*r%29%29%3B%0Afloat%20vx1%20%3D%20-p.y%2C%20%20%2F%2F%20circle%0A%20%20%20%20%20%20vy1%20%3D%20p.x%3B%0Afloat%20vx2%20%3D%200.2*p.x%2Bp.y%2C%20%2F%2F%20spiral%0A%20%20%20%20%20%20vy2%20%3D%200.2*p.y-p.x%3B%0Av.x%20%3D%20c*vx1%20%2B%20%281.0-c%29*vx2%3B%0Av.y%20%3D%20c*vy1%20%2B%20%281.0-c%29*vy2%3B%0A%20%20) by /u/TooLateForMeTF [Circle Convergence](https://anvaka.github.io/fieldplay/#?dt=0.01&amp;fo=0.998&amp;dp=0.009&amp;cm=1&amp;cx=0.0010499999999997733&amp;cy=-0.0020000000000000018&amp;w=8.547699999999999&amp;h=8.547699999999999&amp;code=float%20r%20%3D%20pow%28p.x%2C2.%29%20%2B%20pow%28p.y%2C2.%29%3B%0Av.x%20%3D%20-0.2*p.x*log%28r%29%3B%0Av.y%20%3D%20-0.2*p.y*log%28r%29%3B) and [Trigonometry River](https://anvaka.github.io/fieldplay/#?dt=0.01&amp;fo=0.998&amp;dp=0.009&amp;cm=1&amp;cx=0.8731&amp;cy=2.1007&amp;w=19.7106&amp;h=19.7106&amp;code=float%20r%20%3Dlength%28p%29%3B%0Av.x%20%3D%20cos%28r%29%3B%0Av.y%20%3D%20sin%28r%29%3B) by /u/Pyromane_Wapusk The simulation of a vector field happens entirely on GPU. I'm not using floating point textures, which allows me to cover wider set of devices. It comes at additional code complexity, because we have to pack floats into uint texture. Finally, I tried to make sure that the code loads as fast as possible, so I leveraged webpack's bundle splitting and lazy loading of vue.js/glsls parser.
Yes.Php with all its problems is specifically tailored to serving web pages.Its extremely fast computing wise , and integrates with apache.It does literally everything web except threads. Node is single threaded which means anything that needs server processing will slow down.Also it has much less server oriented tools unless you import a lot of libraries
&gt; Nowdays you have to speak CSS/HTML/Javascript [very good.](https://youtu.be/SU_KhcbVWVA?t=0m30s) Things like framework experience are obviously going to be job- or company-dependent. If they're already using a framework, they'll prefer people who know the framework. However, I'll bet that they won't turn down someone with experience in other areas if that's all they have. If you're a competent programmer, it won't take long to learn the framework.
Angular 1, or angularjs as it is officially called, is a completely separate product from Angular 2, or Angular as it is officially named. Saying there's no upgrade path between the two is the same as saying there's no upgrade path between react and vue. No kidding, they are completely separate products. And yet despite that Google still did [create one](https://angular.io/guide/upgrade). In truth it's mostly wrapper type stuff. But it does exist. And has for most of angular's release time. Sure it didn't exist during beta. So what? It's beta.
Keys in your object must be unique.
Your issue is probably more the boot camp credentials than what you know. A lot of places don’t want to take a chance on someone that doesn’t have a CS degree, but you will find understanding people eventually. 
Ita all about having a degree first.Even a 10 year old can write js without knowing what he his actually doing. I believe someone knowing less specific js but having 4 years of academic tech knowledge is infinite more attractive and rightfully so
We enforce it with the flow eslint preset.
Covalence?
I believe that's a recommendation, not a requirement.
Have you tried to set your javascript to ecmascript 6 ? Go to Settings-&gt;Languages and framwroks-&gt;Javascript and set the javascript version to es6
Sounds like, forget node, just use npm if you are using enough third party dependencies, if not, your old ways still work fine. In crypto, everything is new so good luck, no avoiding learning at this point. I struggled to find simple enough crypto examples with minimal dependencies, crypto itself has so many possible setups, then layer on node/react/webpack etc it could be overwhelming for sure. Is this bitcoin, ethereum or other? Or will you be using an api?
If you have multiple keys in an object that are the same, only the last one will stay. The rest will get overwritten. So while it can be done, it's most likely not the behavior you were intending.
No it's not. How would one know which property to select if there are several with the same name? 
It sounds like people are trying to pay less for more?
Requirements for Frontend are getting higher on all levels. Used to be you could be a great frontend just knowing html/css/jquery. Now you gotta know those plus ES6, build tools, Git, at least one JS Framework, etc getting more and more every day.
but this enforces the linting rules for flow, ie the syntax and all, not the type validations, right?
Don't copy what other people do, because they most likely did it that way because it made sense to them. Do what you were always doing, and figure out from there how to do what you want to do. What is the first thing you need to be able to do? How would you have done it before. Start from there. 
So take some time and learn Node. Setting up the environment takes like one minute. Install node and npm. If you find node too hard, you might want to reevaluate your stance that you understand js quite well. Hit the books for a bit. That's what everyone else here had to do. (Especially if you want to take on a crypto currency project next)
This is true, but keep in mind that front-end development was much less sophisticated in 2010 than it is now. Much less was done on the front-end then, and many sites held the vast majority of their complexity on the back-end. ### jQuery: Being able to write JavaScript *without* relying on jQuery is actually more impressive, in my experience, than knowing jQuery in the first place. I would not prioritize learning jQuery if I were you. ### Preprocessors You only need a small amount of experience with them, but you should be able to talk about them and recognize the concepts. If you have a solid handle on CSS then the basic stuff about preprocessors should come naturally, if not as a relief. Also, you only really need experience with one. ### Front-end frameworks Yes, you should learn at least one of React + Redux, Angular, or Vue + Vuex. ### Other areas to focus on I would say that you should also know how to create a responsive webpage, even if all that means is that you know how to use Bootstrap. Bonus points if you're able to build an API Gateway in NodeJS.
Your comment basically sums it up. Git is imperative, but ES6 should not be treated as something different to js - it **is** js.
According to this https://github.com/PolymerLabs/lit-html/issues/155 lit-HTML doesn't have components or scheduling, but that doesn't mean another library can't implement it atop of this. This answer confirms what I originally thought, that templates and slots are superior to virtual DOM diffing and are probably the future of many libraries (including React).
From 2010 to now? Yeah, it is higher.
I’ve recently written a blog post that may help: http://2ality.com/2017/11/proxy-method-calls.html
&gt; Plus as a self taught developer is harder compared to a guy who went to university! Going to university has the disadvantage (at least in the states) that much of what you learn is dated. You have the advantage of being able to focus on learning the newest technologies and getting a step-up in that regard.
While there are some places that solely look for a CS degree, some of our most talented developers didn't have degrees. For our company, experience trumps a degree, hands-down. We're much more interested in someone who has BUILT something (even if it was a side-project while in school, or a hobby site/app) versus someone with a CS degree who can only show us Java assignments. What matters most (degree-wise) for us is that they completed a degree and had decent grades. We were about to hire someone who was about to finish a CS degree until we asked for their transcript: A's in Ultimate Frisbee (seriously), and D's in their programming course work. Pass.
Stylus or I won’t apply! It’s my fav
Doesn't work in Firefox ESR 52.4.1 (32-Bit)
Absolutely. Learning SASS/SCSS would be a huge help (as well as using a compiler whether it’s Gulp or Codekit). jQuery is becoming almost necessary in my day-to-day work. In terms of moving up, learning Wordpress or Shopify will give you a competitive edge. It never hurts to learn React or Angular but in my experience as a FE Dev I haven’t really had many projects that required their use. So start with SASS (I personally dislike LESS) and jQuery and you might get more bites.
Hi /u/PurpleWho, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
They should be unique. [json rfc](http://www.ietf.org/rfc/rfc4627.txt)
Thinking about this some more: among the following two variants, the second one is better, because it passes the proper `this` to getters (_not_ `target`). target[prop] Reflect.get(target, prop, receiver) `receiver` is the third parameter of `get()`.
Agreed relative to modern times. But I think there are probably a lot of older devs out there who have worked with js a lot but not touched Promises, etc.
I'd agree with this. If I was hiring right now, a bootcamp qualification would actually count as a negative. The problem is that they are notorious for spitting out devs who can use the latest framework – usually whatever the flavour of the week is – but don't understand the basics. Ask them to build a site without bootstrap? They're fucked. Ask them to build a site using just jQuery or vanilla JS? They're fucked. Even their HTML knowledge often leaves a lot to be desired. But this has always been the case to some extent. Now, it's sorting the wheat from the chaff that 'graduates' from these bootcamps. Before that, it was filtering out the idiots who described themselves as developers when the only way they could build a website was using a WordPress theme.
If our company were looking for a junior frontend developer, here is where we would focus: - HTML / CSS3 -&gt; Be familiar with how responsive websites are built, and don't you dare tell us "with Bootstrap." You should be able to name 8 or more CSS selectors off the top of your head (and know what we mean by 'CSS selector'). Knowing how CSS transitions work is great, and yes, preprocessors are great too. If you know CSS, SASS/LESS is not a giant leap. - Javascript -&gt; jQuery is a must. We'd really love if you could tell us a bit about how Javascript works (objects versus prototypes, closure, typing), but knowing jQuery is the bare minimum. I don't think we'd expect a junior frontend developer to know Angular/Backbone/React. YMMV in that regard, though.
Yep, if we have real specs for it, then that's a done deal. Until then, comparing performance is futile. Templates and slots are inferior in many ways, performance is just one aspect. Could be a tiny bit faster in diffing, but that's not a bottleneck.
`Audio` is the built-in browser [HTMLAudioElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement) object representing an audio HTML tag. It's not really anything specifically to do with the Web Audio API - it's a completely different (and older/less reliable on mobile) way of playing audio files through a browser. The only real interaction it has with the Web Audio API is that you can load sound files using the audio tag and then use that as an input buffer into a Web Audio API graph, instead of using AJAX (or whatever) to request a file, decoding it to raw PCM data and then creating an input buffer from that. If you want to learn *HTML* then by all means read up on [the `audio` tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio) - the `HTMLMediaElement` JS object is just the internal JS representation of one of those HTML tags.
&gt; Templates and slots are inferior in many ways No they aren't, they are actually superior. Scheduling has nothing to do with Virtual DOM or templates.
When I first started as a front-end dev in the 90s, all I had to know was HTML (CSS didn't exist really, and knowing JavaScript was a bonus.) Web tech is constantly evolving - change in the requirements for a dev is going to be the only constant...
Thank you for reporting this. I checked in FF on my end and it works here. Does it work in Chrome for you?
&gt; Before that, it was filtering out the idiots who described themselves as developers when the only way they could build a website was using a WordPress theme. We STILL filter those out. My favorite- Us: How would you build the frontend code for this page? "Drupal Expert": You mean using HTML and stuff? I don't know.
Yeah it does. Firefox gives the following console error: TypeError: invalid arguments app.f1fc2c12614895403646.js:1:27965 r https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:27965 r https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:28700 r https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:10705 .YJWA/&lt; https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:21847 .YJWA https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:21657 n https://anvaka.github.io/fieldplay/static/js/manifest.ccae1d8134e9973afdab.js:1:96 window.webpackJsonp https://anvaka.github.io/fieldplay/static/js/manifest.ccae1d8134e9973afdab.js:1:418 &lt;anonym&gt; https://anvaka.github.io/fieldplay/static/js/app.f1fc2c12614895403646.js:1:1 
Us too, unfortunately. It's a sad state of affairs when we're pleasantly surprised that we found someone who actually knows what they're doing. It's part of the reason why code tests are so prevalent (though I've come across a few recently that take the piss – *no, it is no acceptable to have the candidate code up an entire page that will take 20-30 hours to build and test*). I've actually had someone who said they were looking for a HTML expert for their WordPress website, because none of the developers they had spoken to could help them...
Not true for our company. Anyone can complete a degree, not everyone can switch from doing assignments in Java that they spent a whole week on to creating bug-free, responsive code for our clients under tight timelines.
thanks 
Don't feed the T_D trolls
True.But there is no better way to achieve that than knowing the actual pc architecture and best practices.You will never get bug free or responsive code from someone who doesnt know what half of the bugs mean , or what affects performance.
i had it since the beginning
Didn't even notice.
You learn to learn at university. We recently hired a CS graduate junior who knew nothing about web development but he taught himself enough Django and React and our code from the docs that he's quite productive after a month, with a lot of potential.
So for me, graduated from a bootcamp and found a job within 4 months of searching in Austin. I landed my junior dev job at an agency. Here, they wanted me to know HTML/CSS and a little bit of Jquery and Javascript. Even though most of our websites run with PHP, i had no prior knowledge of PHP which i told them outright during the interview. I knew tons of JS frameworks and a little bit of SASS and LESS which the agency didn't care about at all. They were more concerned of me understanding the fundamentals of front-end HTML/CSS, and was prepared to teach me whatever else comes down the road. After getting hired, my coworkers told me they were looking for someone who was trainable, cultural-fit, and not pretentious. I also played the job-hunt game and took several initiaves to push them to hire me (like finding and getting offers at other companies/businesses, keeping in contact with them via email, trying to find natural networks/connection to the people at the company). Lastly, making my coding quiz rick and morty themed helped a lot as well. ;) CHO GIIIRLLL SAW THEM R&amp;M FUNKOS SITTING ON THE DESK WHEN INTERVIEWED. 
I'm glad someone else is feeling this way, although I'm way more old school and learned back in the day when things were really simple. The workflow has changed a lot and I don't even know where to begin. Everything seems to be done in weird (to me), unnecessarily complicated steps, even just creating a basic html page. It seems there's a lot of compiling that goes on that I don't really know. It feels to me almost like a front end developer has transitioned and the line between it and back end has blurred. 
So, why not just create an html page and put links to those files in the header manually? What does this do that makes it beneficial? (this is a serious question, I'm not trying to say it's not beneficial, I really don't know)
I guess this is cool? I don't see the use in serializing functions, i find that you're giving devs enough string to hang themselves with lol. Also you mention how a use case would be writing config files, but again the biggest difference between the two examples is a successfully serialized function which is invalid json anyway. I suggest a better example as to why you would use this over JSON.stringify. I'm struggling to imagine why a user would want to serialize an object as invalid json. 
Sort of. I believe the rise of single-page applications has dramatically changed the meaning of "front-end". In 2010 it was much more likely you would be authoring HTML/CSS for a server-side website, and progressively adding some JavaScript for convenience, almost always with jQuery. So back then, those were the skills you interviewed for. Today, much more of the work is on single-page applications. The frameworks are necessary, but they also require the kind of engineering a "back end" or "web app" engineer would be doing in 2010. This means understanding JavaScript more deeply, as well as object-oriented programming and other skills to ensure you're using the framework as intended and can interact with engineers writing services for your front end. Also, there are so many competing frameworks it's really hard to fairly interview a candidate using anything other than vanilla HTML/CSS/JS. My shop uses Angular, so I can't fairly evaluate someone who uses React or Vue. My best shot is to see how good their fundamentals are.
Hi /u/GuillermoF, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'.
A small code test goes a long way to filter out those that can program and those that cant.
Webpack is really powerful as a build tool. If you include a transpiler like Babel you can write / import es6 packages and get somewhere around 95% of the es6 stuff polyfilled to es5 so you don't have to worry as much about browser compatibility for the packages you are using. With webpack you are also probably going to minify / uglify all the code in a single file, so instead of retrieving multiple resources in your html you get a single file that has all your JS up front (you can also manage code splitting if you want different scripts to be loaded for different routes in an SPA environment for example) Also not to be forgotten is tree-shaking, which will remove dead code from your build so you are only going to be delivering code that has the potential to be used to the browser, instead of entire packages that you may only be using part of. Basically the advantage is that you run your entire JS through a single build (webpack is most popular but there are also others such as rollup), making it consistent and easier to manage than retrieving your separate packages individually. 
Did you know that 80% of the CS grads in the US can’t code?! They just code for the grades, to get credits to get the CS degree. Most do not learn as a skill. That’s what the white board test is for.
If you start rolling your own framework (which you will inevitably be doing in any reasonably complex vanilla js app), you will likely still end up having troubles integrating with some technologies you didn't anticipate needing. Except your framework won't have a community to help or potential existing solutions.
That CS degree is just a piece of paper. Put him or her in front of a white board and lest see what he or she can do. Why do you think companies are turning to coding challenges? It is because the industry needs people who have the skill, not just a piece of paper from a University.
That’s a real programmer in the making.
disagree, I just started to learn well as soon as I wanted to learn well! In school i studied very bad, inefficient! What helped me is to study how to study. Pomodoro, Pareto effect and calm spirit, these are my friends. I learned much more in a month than I even could imagine, even though I work 42 hours a week. 
Yeah, I was recently looking to hire a junior front-end developer and we phone screened all comers - the boot camp guys were definitely noticeably more lacking than the college guys on average. Not just on the obvious stuff like big O notation, either. I think a lot of it is just time - if someone comes out of a bootcamp and just plays around with frameworks, creating applications, that sort of thing for two years, I think they'd be on par with the college people. (And to be clear, a lot of the college people *suck* too.)
I'd argue big O notation isn't something you really need to be worried about with junior front enders. Junior backend developers should definitely have an understanding of it, but unless we're talking about FEs who are going straight into application development, it's overkill to be honest. Completely agree with the problem with college/uni graduates. They've learnt how to pass their degree; not how to solve real life problems. That's why, time and time again, the best developers I've come across have been those who have come from other careers and have self-taught themselves – whether through books or online courses like Treehouse. Sure, they're rough around the edges, but more often than not, they have a better foundation than most grads of more structured courses.
If someone asks if I know JQuery I usually tell them that I know it so well that I write it myself when I need it const $ = (selector) =&gt; document.querySelector(selector)
I would suggest deleting that function, forgetting it was ever written and never speaking about it again. In any case, there are too many missing pieces to help you. _On what `elem`_ is this function called? And where does that element come from?
I completely agree with you, I had a semi technical degree and went through a bootcamp. What I'm saying is that when you're looking at someone who has no professional experience who just came out of a bootcamp, that's not an easy sell to most employers. Once you get your foot in the door and have some exp to back yourself up, it doesn't matter much after that.
You totally can if you want to. Thing is, npm installs files to ./node_modules/package Then you have to figure out if the package is built with a distribution file, or meant to be consumed as a module. Still, people do that sometimes. Hell, I have webpack copy a few files out of my node_modules directly in some projects. The biggest advantage, in my mind, is modules. Now you can split up code into multiple single-concern files, yet have it all packaged up together nicely. Sure, you could attach each module to the window and create your own "module" system, but this doesn't pollute the global namespace. Furthermore, you now have only a handful of bundles (many developers separate out their own code from vendor libraries). Now instead of 18 http requests for scripts, there are only 1 or 2. It's more performant. Yeah, you can also transpile, and minify, and do any number of other things. But in my mind the biggest advantage is code organization and ease of development. 
Yes, I'd say that frameworks are needed - but not always needed, and often may get adopted for the wrong reasons. If you are in the case of say: * mostly static site * fine with full-page reloads between pages * minimal state held client side * minimal dynamic/interactive elements on the page Then chances are you might not need a framework, or at least a larger one. Although I've found usually in this scenario - you end up doing a bit of 'roll your own' anyways. However, as you start working on stuff that has * much more dynamic data * more state / information held on the client side * more dynamic / interactive elements - complex forms, workflows, graphs, calculations, notifications, validation, etc Bringing in a library / framework can help with this. There are a few reasons, * doing a 'build it your own' - takes a lot of effort, especially once you consider cross-browser quirks / issues, security concerns, edge cases, etc. Now and then this might be the right solution, but for many people it can fall into simply a 'not invented here' syndrome. * large community / ecosystem available around them - you don't need to re-build everything by hand. There are lots of component libraries / tools / etc available for AngularJS, Angular, React, Vue, etc. Also, if you get stuck - lots of resources to get help * Can be easier to onboard people onto a project - yes, simply knowing JavaScript well is very important - but when jumping into a massive codebase that is using a popular framework that is well known, with great documentation, support, community, etc - can be easier than 'learn this framework I built myself' * My daily job is to solve business problems / provide value to my customers, not figure out "the most efficient way to update the DOM based on state changes", or "how to build reusable components" - frameworks can abstract a lot of that away for me, letting me focus on the parts that matter. * JavaScript is more than just the DOM - and frankly, I hate manual DOM manipulation - it's a pain in the ass. I'd rather let the framework take care of that for me. Also, just because things get released frequently doesn't mean that you need to learn everyone, or continually move from one framework to another. I know a few people that work on Ember projects, love working with it - and has a cult following, and they have no need/interest in migrating. I've seen a number of really well done AngularJS apps that are performant, run well, clean codebase - and they are in no hurry to upgrade. Does every page/web app need to use a framework? nope But, for most of the stuff I work on daily, I'd cringe at the thought of doing everything vanilla / from scratch. Having also done the 'build my own framework' before (before things like react / angular / etc) took off - it's not something I have a big interest in trying to do again. For anything on-trivial - you are eventually going to start building up a collection of helper functions / utilities / ways to reuse components / etc - and eventually build up your own library and/or mini-framework in the process. 
I’d say they are getting different. You used to need to know how to program, now you really don’t, you just need to know how to use the framework.
Well it was supposed to be for Ethereum at first (Web3.js), but I couldn't run a full node due to disk space, so now I'm looking into BitcoinJS. That was my problem as well, not finding a simple (lightweight) example with good enough documentation. Maybe I don't have a problem with Node/npm as much as with the crypto itself.
I added updated the original post above... Thank you for your help. 
Don't forget about the testing frameworks too! Gotta know how to do unit tests and e2e tests.
I think it’s more that it’s different tech rather than new or harder tech. Sass instead of CSS for instance, it’s basically the same thing and if you know CSS you’re 95% of the way there for Sass and if you know Sass, you know CSS. I do full stack, and it seems more and more that front end is getting more “programming”ish. JavaScript used to be an odd language, it’s still got its quirks but anyone who argues it isn’t a real language now is identifying themselves as a tool who takes the meme too seriously. Now that JS is getting all the features of other languages there’s more to learn, and as the language grows and evolves the weight of the front end is being shifted more towards JS. A decade ago you could get by knowing photoshop, CSS and HTML. You can’t do that anymore, but no serious employer will expect photoshop from their devs anymore. Swings and roundabouts.
Nope it can enforce the typing as well.
Yes, I also see this trend. Like my friend told be, they have 10 Frontend developer and 8 from them do only JS. Seniors didn't touch HTML | CSS anymore lol wtf? 
What makes you think that this can only be acquired through school, 'cause that's the impression you're giving? That's quite a close-minded outlook on things. Any *decent/solid* self-taught developer/programmer would surely be familiar with bugs and how to deal with them as it pertains to performance. 
Hi /u/cputek1, For javascript help, please visit /r/LearnJavascript. Thank you!
Ah ok, that makes more sense, thanks
Hi /u/ageblade, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
The fundamentals of programming are never dated. You should be going to school to learn computer science, not how to make a kickass webpage in React. The languages and frameworks come easy when you have a good base. That being said, the fundamentals of programming can be learned outside of school very easily.
Hi /u/wbhyatt, For javascript help, please visit /r/LearnJavascript. Thank you!
It's not something we "worried" about, it wasn't a requirement at all. I'm just saying it wasn't only the academic stuff they were missing. Our first phone screen question was simply "tell me how you would write a function to output a multiplication table" and I'd say more than half our applicants failed it more or less completely. 
You know, I really hate to say it, but it's 2017 and you're just hearing about Node.js? And you call yourself a Javascript developer? You gotta be living under a rock. 
I don't know of a library that does this but doing a GET on the file and checking the returned content type might work. The CORS requirement is tricky because the only way to do this is starting your browser in insecure mode, otherwise its not possible to bypass without using your own server.
Frontend development is actually programming now instead of scripting markup. We have been doing very nasty stuff for a very long time... Thank god times have changed.
I'm not against it or adverse to learning, I'm mainly just having trouble understanding and keeping up
Well, it's still hard to say, but it _looks like_ your function `DataGrid` (called by `loadGrid`) is the one that _draws the grid_ in the page. As such, it's very probable that `DataGrid` is drawing the `"#tblRpt"` element in the page. Otherwise it doesn't make much sense. So, it _may be_ that there's some error occurring there that, for whatever reason, makes it fail and not draw the grid or whatever. In that case, the element won't be there and `elementReady` will never finish. Suggestions: 1. Instead of using alerts to debug, do use the debugger. And do look into the console to see if there are any errors. 2. Try to actually find where the `"#tblRpt"` element is actually being drawn into the page. My guess is `DataGrid` but I may be wrong. Debug that and see that it is actually being painted.
I don't know about NY specifically, but Assurant uses ExtJS 5-6 in some places. It's really a dying technology, though.
Because if it takes 4 years to learn 40 courses while guided , having to attent lectures , and providing 6-7 projects each semester , then you will need at least 6 for the same knowledge while researching alone and thinking you know everything.
dayum
Great answer with lots of info.Thanks a lot.Definitely clears things up a lot. Mind posting a large app (if you know any )that actually utilizes the power of a framework? So far i havent seen anything that doesnt look quite easy with plain JS.Maybe the streaming and chunking of videos , i couldnt do that manually.
I think some bootcamp grads may struggle the same as most people coming out of CS degrees. However the point of a Junior-level position is that you would have someone senior over you to further your education. You will occasionally find diamonds in the rough (i.e. people who are self-taught code aficionados), but most of the people coming through are not going to have that kind of knowledge. A junior-level position can and should be filled by someone who many not be well-versed in every technology you need. We've all been at the stage where we are just starting out. Most people are capable of learning, they just need someone to guide them.
Where exactly do I call myself a JS developer?
Exactly. I'd rather them show a solid understanding of the basics of HTML, CSS and JS rather than the ability to use coolFramework2017.js and so on.
Exactly. I'd rather them show a solid understanding of the basics of HTML, CSS and JS rather than the ability to use coolFramework2017.js and so on.
Exactly. I'd rather them show a solid understanding of the basics of HTML, CSS and JS rather than the ability to use coolFramework2017.js and so on.
Bit disappointing that a 'git gud scrub' reply is so upvoted. In the real world of professional software development it can be very difficult to keep up to date with web development technologies, especially when old technologies work perfectly well (until they don't, as OP described) and your managers don't understand the need for developers to keep learning. If I didn't use *a lot* of my personal time on this I'm sure I too would be falling behind. In a lot of a ways I already am.
Don't get discouraged. There is a place out there for you I'm sure. You have to find the company that truly knows the meaning of a Junior Developer. A Junior Developer is not someone who is supposed to come in and be autonomous, they require instruction. My advice is this: don't be afraid to apply for positions where you do not have experience in the technology they are using (e.g. Apply for C#/Java jobs). A bootcamp teaches you primarily how to figure stuff out. You will do much better in your career if you are able to solve problems/figure things out rather than being a walking encyclopedia. Also don't be afraid to apply at larger companies such as banks. They have developers, and typically they understand what it means to be a Junior Developer. They will put you on a team with a senior-level person who is responsible for helping you get up to speed on their technology.
Exactly. I'd rather them show a solid understanding of the basics of HTML, CSS and JS rather than the ability to use coolFramework2017.js and so on.
I do this for Prettier in both eslint and tslint. Then use the fix on save feature in Vscode. 
I have no CS degree, but I've been doing dev work for over 2 years - started with frontend but have been converted to full stack (depending on project), and the only time I've heard of Big O is the anime. Although, after Googling it, I have seen others talk about the O(N) O(N^2), etc. I had no idea what they were talking about. Now I will!
Why promises and not async-await?
No. It's primarily latency, not bandwidth, which drives the need for those things. And latency is limited by the speed of light, so it's not going to be improved upon. No matter how much bandwidth you have, you're going to have some dozens-to-hundreds of milliseconds of latency between you and whatever machine you're connected to. 
Thank for this comment. I feel better now that as least i have a good understanding of these 3
I'm currently working on an app that is written in JSF and jQuery. It's the most horrific thing I've ever worked with in my life. The guys that wrote the frontend are backend guys - they don't keep up-to-date on any frontend trends, and they keep trying to tell me how awesome jQuery is, and I wrote this almost exactly (I used 'var', because they don't know 'const'). Their response? "What's a query selector?" 
&gt; Isn't lastname pointing to the prototype? No. Why do you think that? When the constructor function is invoked, `this` refers to the newly created object. Assigning to `this.firstname` is assigning a property of the specific object instance; the prototype is not involved at all. And if you think about it, that's the only way it can work. If each person has a different name, then they must be properties of the individual instances, not shared between all instances as would be the case of properties of the prototype. That's usually only used for things like methods which do you want shared between all instances. 
Pretty nice list. Prob could remove all the TLDRs, as there's not really a longer version.
In the definition of hasOwnProperty(propname): Returns true if object has a noninherited property with the name specified by propname. Returns false if object does not have a property with the specified name or if it inherits that property from its prototype object. In your case the property is noninherited, in other words, it‘s the object‘s own property, thus the function hasOwnProperty() returns true.
Node is just JavaScript. It runs the same code. Granted, some browser specific APIs are not included and some server specific APIs are included. However, if you make `index.js` with `console.log('Hello, world');`, save it on your machine and then pull up your CLI and type `node index.js`, you will get a result of `Hello, world`. So, just practice. If you're just discovering Node, then you have a lot to learn still.
Roles are becoming more specialized. CSS HTML and light js or jquery are still in demand but are now more suited to a frontend designer. A frontend developer will be a slightly different role and will be expected to be familiar with the concepts in at least a first year computer science course (big O, streams, the approximate nature of different paradigms, that kind of thing) and a few basic professional tools, frameworks or platforms (react, git, SASS). You have to pick a side now and tailor your job search accordingly. And even design has fragmented between UX, CRO, graphic design for the web and the more general design positions.
To be clear, the constructor function is NOT john's prototype?
Almost forgot SVG graphics, knowing both Photoshop and Sketch, CSS animations, BEM naming convention, Sass, Babel, etc etc this is why I drink.
This is roughly what happens: var john = { __proto__: Person.prototype }; john.firstname = 'John'; john.lastname = 'Doe';
range with recursion: const range = (n, m) =&gt; m &lt; n ? [] : range(n, m - 1).concat(i); explanation: `n` is the lower bound (inclusive) `m` is the upper bound (inclusive) You keep on adding `m` which you decrease to an array. You do so until a base conditions meets: `m` is lower than the lower bound, then you return the base value: in the case of arrays: `[]` Functional language heavily support this pattern by providing a "cons" (concat) operator for lists.
Fair enough, but maybe that addresses discrete HTTP connection. If we just think about shear payload size (e.g. one 15MB javascript file and some ungodly 10MB CSS file), would increased bandwidth make that moot?
It's not about the languages and tools you learn, it's about the different experiences you gather using many of them, and the depth of your experiences using some of them for a long time. There is a reason we are called Seniors: We are old! Of course some quick lessons in "the-latest-shit" are always ok. To not be unhelpful: Git is a really, really powerful tool. Javascript will become even more prevalent. And forever, everything will always be held together by shell-scripts and command line, so learn to use the CLI.
Right, the constructor and the prototype are two separate things. When creating a new object, the constructor function initializes the object's prototype from the `prototype` property of the constructor function, so that is usually where you place methods that you want to be shared by all instances. function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayName = function() { console.log(this.name); } let bob = new Person('Bob Jones', 42); bob.sayName(); In this example, the `bob` instance has an own property of `name`, but `sayName` is on the prototype. 
Not necessarily. For one thing, the inherent nature of how TCP performs congestion control means that the beginning of a new connection is a period where both ends begin with small bandwidth estimates of the link's capability and increase them gradually until ACKs start becoming delayed or missed entirely. That is how TCP is able to estimate the bandwidth of a link, and keep from sending more packets than it's able to handle. But it means you don't get the full bandwidth available of a new connection immediately. Secondly, a giant fraction of the world uses the web on mobile, and it's only increasing. Mobile connections are several orders of magnitude worse in both latency and bandwidth, so the idea that you can just abandon proper engineering and let things work themselves out with an excess of bandwidth is not realistic. 
I don’t hire jr devs for what they know now. I want people who are smart and play well with others. The team can teach them what they need to know. 
Take a seat young Skywalker. I mean... On demo site (on mobile) it shows only 21 rows and text is blurry. So not very impressive.
You can do this with: const makeRange = (x, y) =&gt; { if (x &gt; y) return [] return [x, ...makeRange(x + 1, y)] } Which is nice because there is no mutations. There are situations where you can't do this though, and the standard solution is to just do the recursion in an internal function. Where you can define your own parameters. So you can do your function like this too: const makeRangeAccumulator = (x, y) =&gt; { const loop = (start, end, arr) =&gt; { if (start &lt;= end) { arr.push(start); loop(++start, end, arr) } return arr; } return loop(x, y, []) } It's also easier to make this one tail recursive (the recursive call being the very last thing you call in the function). Which is good practise as JavaScript is now starting to get optimizations for it. const makeRangeTail = (x, y) =&gt; { const loop = (start, end, arr) =&gt; { if (start &gt; end) return arr; arr.push(start); loop(++start, end, arr) } return loop(x, y, []) } 
from my experience, error handling on AA is not as clearly though out and needs try-catch or put entire function into a proxy-promise: const process_data_proxy_function = data =&gt; new Promise( async ( resolve, reject ) =&gt; { try { resolve( await acly_process_data( data ) } catch( err ) { reject( err ) } }).catch( err =&gt; console.error( err, 'from process_data_proxy_function' ) ) 
I did essentially with three random people, selected from a pool of 30 applicants. None of them had a CS education. Maybe college helps slower people learn to learn but the bright ones already have that down.
This is a good way to get hate from the no degree crowd...they know how difficult it is to get a degree and that’s why they don’t like it when you point it out...completing a 4 year (maybe more) takes dedication, selflessness, and doing things you don’t agree with, all very important traits in what makes a good employee and coworker. 
In terms of jobs, despite what people seem to be saying, for every 1 JS job, I still see at least 2 or 3 C# jobs. TONS of companies use the .NET stack, and a lot are using Node along side .NET. Learning both C# and JS will give you the largest advantage in terms of a full stack dev. 
I understand that, I already did a couple basic tutorials on Node. What I'm confused with are the packages and dependencies on even more packages. Some packages use standard JS syntax, while others use something I haven't seen before that barely even resembles a syntax in any other languages.
Ok... I guess what I'm leaning at is will there EVER be a time in the future, like 200 years from now, where shear firepower can overcome the bandwidth hurtle, or are we actually limited by some mathematically proven limits that will always produce limitations. This is given that computers are either still von-neumann, or quantum at that point. I understand that this seems lofty, I'm just wondering if given our current computational schemes, theoretic or otherwise, will there always be a limit (i.e. need these sort of tools) even with massive advance in material science.
Any package pulled from NPM will be JavaScript. It may have supporting files in other languages, but it's main files will be JavaScript. It's a JavaScript package manager, after all. 
I guess I don't understand the reasoning for why you'd ever want to do that. Not compressing images is always a losing proposition, no matter how much bandwidth you have. Even if you have tons of bandwidth, you can use it much more efficiently by adding compression, so why would you ever not want to do that? There will always be a need to use bandwidth more efficiently, because even if you instantly gave everyone on Earth 10x more bandwidth than they currently have, new applications would soon emerge to eat up that bandwidth and you'd be right back to where you started. It's like how adding a new lane to a highway never actually makes commute times go down; you just get more people trying to use the roads. And the amount of bandwidth you can get out of a given type of link (wireless, fiber optic, coaxial, etc.) is always going to be constrained by hard physical limits like noise floors, cross talk, reflections, etc. It's not going to just increase forever. 
Ah the old magic statistics! Do you have anything to corroborate this claim?
Check out points 2 and 5; would that fix the problem you described: https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9 
I would look for help in r/ethdev. You can run testrpc or geth in dev mode so you would be running your own blockchain for dev but to be useful you at some point need to connect to a live testnet and then the main net. I have not gotten there yet. 
I tried your code and I believe there's a typo, instead of `i` there should be `m`, right? http://jsbin.com/xogexifiho/1/edit?html,js,console
Here's a sneak peek of /r/ethdev using the [top posts](https://np.reddit.com/r/ethdev/top/?sort=top&amp;t=all) of all time! \#1: [THE big Ethereum Development resources list](https://np.reddit.com/r/ethdev/comments/5s9avy/the_big_ethereum_development_resources_list/) \#2: [If you need some Ropsten Testnet ethers...](https://np.reddit.com/r/ethdev/comments/61zdn8/if_you_need_some_ropsten_testnet_ethers/) \#3: [A practical guide to cheap IPFS hash storage in an Ethereum smart contract](https://np.reddit.com/r/ethdev/comments/6lbmhy/a_practical_guide_to_cheap_ipfs_hash_storage_in/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Alright this is making more sense. And since all objects created from that constructor function share the same prototype, they could also all access this method by only writing it once: Person.prototype.sayHi = function() { console.log('Hi'); } bob.sayHi(); jane.sayHi(); kyle.sayHi(); Very cool. 
nice idea to create inner function with custom parameters, thanks! I don't understand that part though: &gt; It's also easier to make this one tail recursive (the recursive call being the very last thing you call in the function). Which is good practise as JavaScript is now starting to get optimizations for it.
oops. of course. fixed. thanks!
http://blog.indeed.com/2017/05/02/what-employers-think-about-coding-bootcamp/ There are stats to support both sides, but since you asked for corroboration...
While it's true that people would most likely find a way to fill up any extra bandwidth, I guess I'm asking if our CURRENT payload desires could be solved by material science and algorithm science if introduced at a scale that is orders of magnitude. As in I have some website that has a noticeable performance delay because there are just too many assets or something. Could simple things like that, given their current sizes, be solved by hardware improvements alone.
[a stack overflow answer](https://stackoverflow.com/a/37010)
The requirements were getting high since Aristotle times. Good news are that tools are getting better and more convenient. So you don't have to worry. Complexity is the same. 
Hi /u/DevD00d, For javascript help, please visit /r/LearnJavascript. Thank you!
those points dont acly fix the problems, they just show how to workaround them also i added to my comment above
Many places I've worked will consider you as a junior if you have learnt well from self teaching. If you've had no training but made something relatively well that shows promise, which is what you need in a junior - a promising future. Other places, junior is a synonym for graduate, so it's worth doing your homework on a place before approaching them. Some places don't accept non graduates, just blank these from your mind, they aren't places you'd want to work anyway. I'm a graduate, bit not of CS, and some places won't consider me. The places I end up instead are lots of fun. I'm currently writing software for 19m TVs.
...and a shit ton of money? As a note I still owe $40k after 10 years post graduating, the degree didn't do shit to me to get my first gig. Showing personal projects and small freelance work did.
This was interesting from an academic perspective, but I won't be writing code this way. **tl;dw** Everything can be functions. The main stride of the video was to implement the expression `!x == y || (a &amp;&amp; z)` using only functions and no boolean operators. // Building blocks const I = a =&gt; a; // identify const K = a =&gt; b =&gt; a; // return first const KI = a =&gt; b =&gt; K(I)(a)(b); // return second const C = f =&gt; a =&gt; b =&gt; f(b)(a); // reverse const M = f =&gt; f(f) // self-application // Boolean operations const T = K; const F = KI; const not = p =&gt; C(p); const and = p =&gt; q =&gt; p(q)(p); const or = p =&gt; q =&gt; M(p)(q); const eq = p =&gt; q =&gt; p(q)(not(q)); // Final implementations of expression const withBooleanOperators = (x, y, z, a) =&gt; !x == y || (a &amp;&amp; z); const withFunctions = x =&gt; y =&gt; z =&gt; a =&gt; or(eq(not(x))(y))(and(a)(z)) withBooleanOperators(false, true, false, true) === withFunctions(F)(T)(F)(T)(true)(false) withBooleanOperators(true, false, true, false) === withFunctions(T)(F)(T)(F)(true)(false) withBooleanOperators(true, true, false, false) === withFunctions(T)(T)(F)(F)(true)(false)
Yes, it should be.
Oh, don't get me wrong. I fully get the importance of higher education, and in this case in CS. I've had it too, right up to obtaining an advanced/grad degree. All I'm saying is that it is not the be all end all of programming/developing. With tons of resources online these days, a guy can create a fairly well structured and specific guide to follow in order to become an excellent developer. All without worrying about other not-so-essential subjects we take in school.
I like your approach with recursive functions but I tend to avoid mutation: function range(start, end) { return (function _range(start, end, array) { return start &gt; end ? array : _range(start + 1, end, array.concat(start)); })(start, end, []); }
Depending on how old your browser is, you can use `fetch` to request that URL, and parse it into a Javascript object. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch From there, get a reference to your textbox (using something like `document.getElementById("myinput")` or other dom methods), and update it's value using the fetched object. Whether you'll run into CORS issues is up to the server you're fetching from.
Pseudo-precision it’s called. Just giving you name of the fallacy that is used in everyday speech. My Statistics professor said that you can make the numbers say anything you want. He ranked it up there with religion. A system based on belief and faith.
Hi /u/ncubez, For javascript help, please visit /r/LearnJavascript. Thank you!
[Here's a massive of sites using react](https://github.com/facebook/react/wiki/sites-using-react). AirBnB, Facebook, BitBucket, CodeAcademy and Discord are a few obvious ones that I'd pull out as clearly worthy of a framework behind them. Funny enough Reddit is on there as they use it for the mobile site. Which supports my guess that where they starting today, the main site's front-end would be in a JS framework. Instead of using (I think) templating with a python framework server side. 
are you talking about [eslint-plugin-flowtype](https://github.com/gajus/eslint-plugin-flowtype)? i cannot see how this can be done. all i see on their page are simple syntax rules, do you mind showing me an example?
If I correctly understand you need sth like Svelte (https://github.com/sveltejs/svelte)? Evan You recently mention that Vue could achieve the same. There are some drawbacks - the more different/separate components the size grows because many things are repeated/duplicated.
Just this week, I created Acceljs (https://github.com/ThreeLetters/Accel). It is the first library to allow DOM manipulations within a JS Web Worker. It is also blazing fast.
If you must, you could use headless chrome to convert the dom back into html, something like chrome --headless --disable-gpu --dump-dom https://www.chromestatus.com/ On my machine its google-chrome, not chrome https://developers.google.com/web/updates/2017/04/headless-chrome I'd consider this a weird path to go down though. I'd just use something like ejs if I wanted to build static content. I don't think its a trivial task to convert a javascript generated dom into readable html.
Honestly, at this point I wouldn’t even bother with promises. They were just a weird stop gap before our one true god arrived: async await.
*FREE EXCLAMATION MARKS!!!!*
I've seen this sentiment in a few places ("[bootcamps] are notorious for spitting out devs who can use the latest framework [...] but don't understand the basics"). I think there are a significant number of people who are both CS grads AND go to bootcamps to pick up some skill they didn't get in uni, like Rails. disclaimer: not a bootcamper myself.
Can you letter in Ultimate Frisbee? Just curious. I'm a frisbee-golfer myself.
In addition to the fundamentals staying the same, a university CS education makes sure you have some depth of knowledge across the board: networking, kernel architecture, compiler design, different language paradigms, etc. I majored in biochemistry, but I've tried to make sure I have an equivalent level of knowledge to a CS major, and know the areas I'm deficient to correct over time. The big ones for me are math (chemistry has a heavy focus on calculus, not discrete maths like linear algebra) and graphics.
And just to sweeten the deal, you better know some Python and be super comfortable with command line in Linux!
Observables!
I think some of that hate could be a product of the arrogance and self perpetuating ignorance that comes from some CS grads. One could say this debate is a matter of perception; you say completing a 4 year degree takes dedication, a self taught individual might say it shows a lack of dedication as a CS student requires handholding and someone standing over them in order for them to learn what they need to. Another few traits you might want to add to your list include humble and open minded.
What is the roadmap for async await for js?
It's sounds that you are lucky to find this job, but for a long term you cannot relly on these! Particularly if you want to go over 100k a year! It's kind of a marathon, and it's not bad but it's sucks if you learn like for months a framework and than you have to learn something new! P.S I don't work but it's something I kind of feel, for example I plan to learn next week Angular 4 and it's allredy Angular 5 out. WTF? Or best are these companies, which demand Angular 3 and up and then you see companies which still relly on Angular 1 lol
I think it's safe to say that requirements for most jobs across most fields are increasing with every year.
In stores now. 
Yeah that's a bookmark. It's not often clear what choice to make when writing for speed. This is perfect. Tiny piece of feedback, please show a visible loading icon or something in the "run" circle so I know something is happening.
In the real world of professional software development, professionals keep up. Crying about it won't change the demands of the market.
I have a comment to add in addition to the other things mentioned in this thread. Learn SEO. First, parts of it are very much a FE dev concern, and that will only grow in importance. Second, finding a job is about selling the best product you have -- yourself. Start a blog. Generate content relevant to your local market (unless you plan to relocate), and get it ranked. Pay attention to your social media accounts - your Twitter, Facebook, and LinkedIn profiles should be professional, well-designed, and be mostly about FE stuff (show you're mostly about the code). You're better off sending three applications out, where you've done a ton of research on the companies, the people who make the hiring decisions at those companies, you've tailored everything about yourself to show you're a good fit at those companies, and you follow up persistently to *get the job you want with them* -- than to waste your time sending out resume after resume, with no preparation and little follow-up.
Through the browser? Don’t think so.
Yes, that's cool :) happy for you mate, but keep learning even though you probably don't have to but it will help you to find better job. Plus you are in US, which means you aren't granted with a job security like we in Central Europe! If I get fired after 2 years, I will get 80% of my income for the next 2 years, I cannot imagine that in US!
This is what I use as an alternative to postman. https://github.com/getinsomnia/insomnia
Hey, I'm flattered! Thanks! I feel like I just won some kind of award for artistic merit. :)
The long versions are the "Read more" links.
I was going to reply but this pretty much sums up my experience. It is definitely harder than it was 4 years ago, but I think having a solid background in plain javascript, knowing one framework really well (I personally like React) and being confident that you can take a code test puts someone at an advantage. I am more concerned when hiring about someone that is excited and can demonstrate proficiency than someone that has been around for a long time. You can be around for years and still not be competent. 
How does it handle native functions? JSON.stringify({ alert: window.alert }); JSON.stringify(JSON.stringify); Or circular reference const x = { }; x.x = x; JSON.stringify(x); 
Found the poser!
So much this. Back in the day there were some issues, but these days it is the smoothest and most performant framework I've had the pleasure of developing in
Sure. You will certainly find a problem in the future which your framework can’t support. In the future your requirements may change causing your chosen framework to be inadequate. You can’t avoid having to rewrite or heavily modify your software in the future. You plan for what you can see and you make your best guess as to what’s coming. Choosing a framework needs to take that into account.
Arrogance and self perpetuating ignorance? Please elaborate. 
I recommend this. Get really good at UI / responsive development =&gt; keep learning, then learn React / Angular (which ever is most in your area) =&gt; Get a good better job repeat and keep learning
I would just use hapi and write mock services.
But `async`/`await` is heavily relying on `Promise`s. It's just syntactic sugar on top of it.
Useable with babel since like forever.
Totally fair, but pretty much every new feature in JS is sugar when you get down to it anyway. Just makes development faster and cleaner.
agree, with all that social media (I don't like social media ;)), I not even thought about it, but you are right! I do prepare myself, it's takes longer than I thought, but this kind of sacrifice I'm ready to make!
true, true. In Switzerland is rediculous, some jobs for example as a janitor, they will not take you without a 3 year degree (apprenticeship) and some useless further education! 
is php not more important for a Frontend Developer?
Fuck BEM though. 
Which one are you using?
Thank you!
Companies are also looking to replace experienced workers with junior developers and expecting them to know as much as much more experienced devs to save money. This is also upping the requirements for junior devs. 
A bit of a different insight. I've worked as a front end developer for close to 20 years. I've worked with small media/advertising agencies, eBay power sellers, large multi-national advertising agencies, national banks and several large online retailers/classified, etc. As well asl doing freelancing on the side for small to medium size businesses. Bottom line is that both start ups and recruitment agencies keep being more fancier and fancier in their requirements. I'll often get job specs sent through to me that ask for experience in "React, Angular, and everything under the sun". **The truth is that most of the companies that I've worked for need:** - Someone that can communicate really well with other people (project managers, team members, stakeholders, etc). - Someone that has solid responsive HTML, CSS, JavaScript (jQuery) skills. - And is both a keen learner / problem solver **(probably the most important part)**. Just as an example, the last two online companies that I've worked at have evolved by adding various technologies and platforms as they grew. (Current companies stack includes jQuery, Prototype, Knockout, Vue, Ionic, etc and a ton of tech debt.) At established businesses you'll typically find a random collection of libraries/frameworks, etc to deal with, and a lot of what you'll deal with at is far from glamorous. **Best bit of advice that I can give to junior front end developers is:** - Don't get overwhelmed by all the various libraries/technologies. (Pick a framework, stick to it and go from there.) - Don't just practice your tech skills. Work on your inter-personal skills as well. - Practice your core skillset and don't think for a second that jQuery's going away anytime soon. Most importantly. When you start off, keep in mind that there are small media/advertising agencies and established small to medium sized businesses out there that also need help. How I started was by looking at my local area to see who was serving my local area. The businesses in your local area need websites, email newsletters, banners, etc. And chances are that someone is already serving them. And probably struggling with resources. More resources typically means more business, and that's were you come in. Start small, start local and go from there. Don't get overwhelmed. You'll get there.
PHP? Muhahah! For those who are trying to rank up a site on Google, PHP just slows down the site and makes it even more hackable. Django. That what it’s for.
don't think so, in German part of Europe you have to visit some bullshit courses to be a better skilled worker. I do understand as a web developer but as a janitor? A good friend of mine was forced to go truth 2 day course which he has to pay from own pocket. Cost around 600 USD. And they learned what they have to do, if the area will be contiminated with radioactivity, common man! And he works in school, not god dam Chernobyl! 
fake Jason server npm package
That comment is exactly the difference between a bootcamp and a CS degree. I’d argue that Big O notation is more important for a front end developer cause using the right data structure and search algorithm is the difference between a lagging UI and a snappy responsive UI
Why do we have to sign up? Is the class a Livestream? Regardless, thanks for helping others and being a teacher.
Look into D3.js
Thanks for the response. That may be true, but I tried them and the scripts still aren't working :( Any other suggestions? Thanks again.
I would also add two things. One, if you know CSS and JS, something like SASS and (the basics of) jQuery is not complicated, they're logical extensions that address things which are obviously missing from the former. They're so obvious that it takes half an hour, maybe an hour, to get a working knowledge of them. It's far from an unreasonable demand. Two, the frontend has changed. It used to be mainly a form of desktop publishing with some dynamic sparkle added on top. Now it's a full fledged application platform. The bar for this is higher.
Arrogance in the manner of, “Because you did not go to college to learn these things you’re not dedicated enough, or as dedicated as I am”, or “Because you did not go to college to learn these things, you couldn’t possibly be skilled enough, or as skilled as I am”. Self perpetuating in that it appears many times that this particular type of individual makes statements similar to yours on platforms such as this, and shortly thereafter another, or several other, individual(s) of this same type will show up to “confirm” the statement and show their support, also known as a circle-jerk. Don’t get me wrong; I’m not saying a college CS course is not difficult and does not require serious dedication, but it is insulting to imply that those who take an alternate path do not face a series of difficult obstacles themselves, and while some may give up, just as I’m sure some drop out of college CS courses, there are some that push through, even though the deck is stacked against them because they opted not to get a piece of paper that attempts to summarize their abilities.
If it’s only happening to third party modules, indexing may be switched off for node_modules
If you claim to know async/await but don't know promises, you're gonna have a hard time.
Hint: it's the local job market. Someone who knows all that and has certifications to show for it to boot should not have a problem getting a job.
I do. Years of interviews in a market desperate for developers (Eastern Europe). I have absolutely no trouble believing that statistic.
There are a lot of tutorials out there and honestly, if you're just starting out then I'd assume most of them will work just fine. I found this one (https://javascript.info/). Seems cool. To get going all you need is a browser! Open up Chrome's developer tools and head to the console and there you are! Javascript world! Here are some super basics! A variable can be done very easily `let name = 'TimeLordofWInterfell` Now display it by simply typing: `name` And there's your name variable! Next there are functions. Write a function like this: let name = 'TimeLordofWInterfell; function sayMyName() { return "Hi there " + name; } Call it with: `sayMyName()` You could also try a function with a parameter `otherName`: function sayOtherNames(otherName) { return "Hi there " + otherName; } This function takes a parameter and you call it in a similar way as before but this time you add a parameter to it: `sayOtherNames('Gimmeslack12')` Variables and functions are just the beginning! But check out the tutorial above, start with the introduction and come back with more questions!
To answer your question bluntly, yes. If you’ve ever worked on a large codebase that didn’t use a framework or something to keep the codebase consistent and segmented, you’ll absolutely know on of the main reasons frameworks are useful. Also, TS isn’t a framework, it’s a superset of JavaScript, and React is a library.
People who are in a position to optimize algorithms are one in a hundred (hell, make that 1/1000). The vast majority of development projects are about connecting tools and modules and frameworks. It's mostly about using legos, not (re)inventing them.
Sweet!
There is a setting in tsconfig.json. actually many settings. First, set module resolution to node. Set rootDir to a folder where you want to import modules from. There is also some webstorm config: If you use tslint, point webstorm to your config file Change language settings to Follow youýr 
"Look, this is a brick and this is a 2x4. Look at them very carefully, then go build a house."
Async await _is_ Promises!
Very few, but I think Xero do (not sure if they have NY office they're mostly Australasian).
No, it's just that the junior dev is out of the loop by about a decade. A frontend job in 2017 has different requirements from what it had in 2010. The industry has transformed. They need to either step up their game or go for different jobs: website designer or graphical designer. They are both still in demand — people still need websites and things that look cool.
&gt;I guess we're still waiting on Linux? Linux has had support for a long time through using Chrome or Chromium. Even Gnome Web has support.
PHP is only important if you have a burning desire to use PHP.
Well you need to be able to use some command line tools at the very least. But it's not that surprising, the command line is a very powerful interface and it's widely used. If you're completely unfamiliar with it, as a developer, in today's day and age, something is very wrong.
It isn't just junior devs that are feeling the taxing needs of the front-end position. Everyone feels the weight of that. Mid to senior developers have mastered a lot more techniques to make them more efficient and effective at accomplishing more in less time. But what do you expect in a field that is reliant on advancing technologies to stay relevant? If you don't love learning and growing you probably won't love development. I know guys who have been coding for 20 years who are doing Ruby on Rails now. I guarantee they didn't start that way since it didn't exist back then. HTML/CSS/Javascript are the cornerstones of modern web development. Those will always be needed and will be requirements but on top of that in order to be a great developer you need other skills too. Do you know how to write less and do more with SASS/LESS to improve the efficiency of coding up styles? Do you know how to architect out the styling of a project to scale as it goes up in complexity? How do you handle namespacing, compiling, and so on to ensure that you are getting the fastest load times? Do you know how to write consistently with a code style guide? Do you know what to look for when looking at other code? Do you know how to have accountability when writing code with code versioning? All these things make you a better well-respected developer when you write with others in mind. 99% of the time you aren't writing code for yourself so expect to adapt to thrive.
Agree, Python can be used to program much more than only for web. But I'm working with WordPress thus PHP is mandatory to know :/ 
Hi, you abandoned my project after I paid you and you've ignored me since. Please get in touch Arian.
You think so? Why?
Serious question. Is there no expectation of people entering the industry as interns? I entered as an intern (paid, I could not afford anything else) and worked my way up.
Im sure laws like that make companies a little more conservative when hiring new people. That's a big risk if the new hire doesn't work out.
Our one true god are promises lol
Oh it's the worst!
async/await *is* promises. You work directly with promises when using it, and therefore need to understand how they work. `async` functions return promises and `await` consumes them. Sometimes raw promises can be better. Recently, writing ReQL queries (query format for RethinkDB), I've encountered situations where using await would make the code much more difficult to read and understand. And since async/await is about making asynchronous calls synchronous, it doesn't help you when you want to take advantage of the async nature of promises via `Promise.all` or similar.
There's no common API across platforms for accessing track information. There might be a way of simulating keypresses like the media keys using something like `node-key-sender` but I haven't tried that myself.
With Flow, it would take less than 1 year instead of 13.
Front end dev here. Have no clue what a multiplication table is. Lol. No degree tho so there’s that. I’m sure I could figure it out tho if a requirement called for it. 
You can understand that doing a nested for loop is gonna be a performance hit without knowing that the label is for that is “quadratic” Seriously big O isn’t “understanding”. It’s just a language to communicate theoretical performance of an algorithm. Of which you use other people’s algorithms 
There was one of those guys at my boot camp. He was great 
You can use `catch` with `await` and omit `try-catch` like so: ``` const result = await aPromise().catch(e =&gt; e) ``` This might alleviate your pain a bit. reference: https://medium.com/@craftgear/go-ish-error-handling-with-async-and-object-rest-800d821fc0ad 
I've been playing with using error monads within async await stuff- it's been my favorite all round solution so far! Highly recommended 
Absolutely. As programs and automation becomes more refined and intuitive, Front End devs will become less in demand. Finding high paying FE jobs usually require an additional skill like Angular, React, Python or some kind of management background. Even then, breaking 100K with a Front End position is very difficult. On the bright side, once you learn one version of Angular the subsequent versions are just souped-up versions. Try combining that with a Ruby on Rails backend (Ruby is easy as it’s semantic) and you should be in the clear. Mentioning a knowledge of Ruby/Angular will definitely pump up your portfolio. Check out scotch.io for tutorials as well.
Just hard code data and use it as if you received it from the server. No need to make an actual request until your ready to.
Coinbase has a really easy to use API for this as well.
Ensure you have a `tsconfig` file and a `package.json`. Also install `@types/node` once you find you need to get `require` to work.
I was a Java / PHP backend developer that never really touched JS/CSS/HTML. Back in 2010 I got a junior front end position by lying i.e. I can do this stuff because I had £50 in the back account. I spent the weekend basically learning everything I could. Ended up being a pretty good full stack dev after a year. These days you couldn't do that. However I think if you learn JavaScript properly i.e. read JavaScript the good parts. Regarding things like SASS, LESS, transpilers and such. I wouldn't worry about it. You won't be expected to know everything.
This, folks, is why you never tell people about your reddit account.
Question piggybacking off this if you don't mind: How would you view someone with an unrelated degree, but 5 years experience developing Wordpress themes (aka not customizing a theme, but building one from the ground up). Very good HTML knowledge, very good CSS knowledge, good Git, decent Gulp, not great JS (but shows an ability to build things and learn how to solve problems)?
Netflix is dead.
ELI5? 
Apples proposal to bring html more inline with modern JavaScript frameworks. I can’t imagine this will have much traction, if it does it will take many years to implement and we’ll still be polyfilling many years after that. 
Think [handlebars](http://handlebarsjs.com) but native to the browser platform.
Why is SSR so great? This article has more many more cons than pros.
Are you fucking serious? Big O notation for a jr. front end dev? Lmao.
Async/await do not absolve you from using Promises. Just as one example, you can't use await alone to run multiple tasks asynchronously...like you can with Promise.all.
Username checks out.
Mostly just a list of things of all the things I️ want to do but be able to maintain lol
A “times table” like they give to [elementary school students](http://www.activityshelter.com/large-multiplication-table-to-train-memory/large-multiplication-table-simple/).
whatever man. you don't need to know that shit for front end work. I don't know any of that and make good money doing front end work.
Here's an example https://www.mathsisfun.com/tables.html I think these are usually covered in elementary school :D
I agree with you, which is exactly why I said it was not a requirement in another post. 
Should be simple but anything I tried only set a gradient on the background. After 10 minutes of counter-intuitive tinkering I decided I should probably get back to work. :D 
The amount of hand holding one expects is independent of education. Sure there are people that bellyache about the prof not helping enough and whine for the TA's attention, but there are also those that take the assignment and self learn the proper skills to complete the requirements. A degree recipient from a strong research university most likely did not have anyone standing over them -- all the profs are concerned with research.
Why? Chrome has had this feature since forever and it's pretty awesome.
&gt; if it does it will take many years to implement and we’ll still be polyfilling many years after that. I don't really understand the negativity folks have around new browser standards. Over the years I've heard people make the exact same argument (it's gonna take years!!!) for at least a bunch of other now-commonplace standards such as: * rounded corners * flexible boxes * `&lt;video&gt;` * `&lt;canvas&gt;` Anyway, the list goes on. Instead of focusing on all the reasons why this is not relevant to you today, I think it can also be useful to appreciate all the work people are doing today, to make your life better in 2020 or later. New technology will be here quicker than you think. Some fail of course and new standards should be judged by their merits. However, if everyone just focused on the fact that we can't have this tomorrow, we would still be where we were when IE 6 was the baseline. Anyway, sorry for calling you out for that partial sentence, I think I just needed to vent about something I've been noticing time and time again. I started doing web development using 'Netscape Gold Edition' and whatever frontpage shipped with MS Office '97.
Apple is not an omnipotent entity but a bunch of individuals. They have their eggs in several baskets.
Around 2010 was a time when IE6 was still an enterprise favourite, HTML5 hadn't yet met widespread adoption, standards were something that merely existed not necessarily adhered to. The value of a Frontend dev was in their wild array of knowledge over all things browser-quirk related. Now, with slightly more standardization we're seeing rich native (to the browser, i.e. no Flash plugin etc) experiences and a much closer knit relationship between frontend and backend. Preprocessors are designed to make your life easier in the long run. Code that is easier to organize and maintain. JS-Frameworks, it's important that you take a gander at them at some point, but for the love of deities, learn 'vanilla' JS/CSS first. The most important thing to understand about these frameworks is that they're all vanilla JS under the hood. They merely expose snippets of JS for you to depend upon, a boilerplate from which you can craft an experience without reinventing the wheel each time. So I'd suggest it's not that the requirements are higher or harder, they've just changed. Moved focus away from the quirks of various browsers and their versions through to now focusing on the way you craft your code. This is a good thing! Rather than focusing so intently on what others are doing (i.e. browser vendors) you can now focus on the best way to organize your own goals and product. Get fundamental JS/CSS knowledge and you're golden. You'll soon realise where these tools on top of JS and CSS help and where they hinder. It'll seem insanely overwhelming if you put the cart before the horse. Looking at LESS and SASS before you understand the very thing they're trying to produce (CSS) would I imagine be a scary prospect. Similar to looking at Angular/React/Vue/Polymer before understanding their end product (JS). To be a junior you really just need to have a thirst for knowledge and a drive to get it. That's all we want when hiring. No one goes into a coding job of any kind knowing *everything* and I'd never want them to. Someone who "knows it all" doesn't always demonstrate a willingness to keep that up. I'd want someone who'll not only know how to research a problem and look up accepted practises for fixing bugs they come across, but also someone who'll keep on top of the industry. You don't need to know Angular/React/Vue/MobX/etc, just know that they exist, know what problems they solve, maybe know a little about the pros and cons of each one. All you need to know about these frameworks is where it'd be a good fit. If you have an understanding of JS, you'll pick up a framework relatively quickly, you'll also know where to look for help, and what sort of search terms you'd need to Google solutions.
https://github.com/mdmccarley89/playlistify-app-v2.0 I built this simple Angular2 project for personal use (and to learn Angular by making something I actually wanted to use) about 6 months ago and have been using it myself so much that I thought others might get a kick out of it. It's just a little side project but any feedback is welcome. 
In order: 1. Ruby on Rails 2. Node.js 3. Go w/Revel 
I prefer C since it's modular enough to run on most hardware... raspberry pi, VCR's, smart fridges... it's a bit more setup but worth it for projects that need horizontal scale.
It's very tricky. I did hours of mindless experimentation to get to [this](https://www.reddit.com/r/destiny2/comments/7ah909/misty_mountains_of_nessus/). I don't even know how it works. I'm serious, I won't be able to explain which gradient applies where and which shape uses which color.
I don't understand why you would ever write: resolve(await acly_process_data(data)) If `process_data` is a function returning a promise, you can easily write anything like: try { const processed = await process_data(data) await send_data_to_server(processed) } catch (err) { console.error(err, 'from process_data') } Means you don't have to do any sort of Promise chaining, and it all looks clean like synchronous code.
This is great! Thanks for sharing.
Node.js
Node.js with Express js
ohhhh wow i haven't seen that in ever. 
I used the free course on codeacademy. I feel like it gave me an awesome start with plenty of practice
As some people mentioned, in 2010 there was no MVC on the frontend. The business logic stayed on the back-end, so on the front there was only some DOM manipulation with jQuery. That's why and frontend job requirements were simple, but also salaries were much lower than say Java backend dev. Now is different story and frontend is sexy ;) 
nodeJS, but then, this is r/javascript...
So far I've tried (from the suggestions): - Setting js version (in lang and frameworks) to es6 and react)--this only works for js files not ts - Setting up the tsconfig.json for node module resolution, changed the rootdir - Changing the rootdir in tsconfig - Making sure node_modules is marked as library root - Marking node_modules as "not excluded" from indexing (default is excluded--it is better for webstorm to index this as a library only and not with src files). And nothing works. If I import react, I can get to the top level export by pressing CTRL click, but if I try: import { Component } from 'react' The ide can't find the export from the module. Weird. 
Right, thanks alot.....i would add a progress indicator right away. Please dont forget to star the repo on github :)
Right, thanks alot.....i would add a progress indicator right away. Please dont forget to star the repo on github :)
I have never run into the types of people you are describing. The CS guys I know are pretty decent. That said, I typically don’t take CS into account when hiring. Having a degree, any degree says to me that you can complete a long term project in disparat domains. 
This reminds me alot of https://github.com/PolymerLabs/lit-html that Google is exploring. Only lit-html is extensible, and available here and now.
https://stackoverflow.com/a/44601770/3410616 I did setup it here. (I asked the question, and then endup answering it)
The sign up is so that I can let you know when it's ready. Won't be doing it live. I'm thinking a free text version and then a video series on skillshare.
I'm living in Berlin. After mine Ukrainian front end experience I feel like Rick surrounded by Morty's. 
Webstorm. 
Misleading thumbnail