Is this compiling into native code, or wrapping a webview (like PhoneGap/Cordova)?
I like it! Let the flame wars begin!
If you scroll down I did see the point, "Build Android, iOS and Windows Phone apps from a single code base" With an image of the generated xml view. The video also highlights, "No wrappers". I'd love to take a look at this. 
You should try using stampit. I've found that it greatly simplifies prototypical inheritance, and does it in a way that is intuitive.
Ah, nice, that's helpful. I added that as a comment on the post.
Neither. It uses the platform's JS engine to execute your code, in which you can call the platform's APIs. It then also provides its own abstraction layer so you can write cross-platform apps with UIs. It is definitely heavily influenced by Microsoft's XAML, as used in Silverlight and Windows Store apps, but they keep pretty quiet about this in the docs! (Maybe to avoid scaring people off). Telerik have a lot of history with Silverlight.
One thing I feel as someone who develops primarily in JavaScript but also comfortably hacks around in Java and Haskell is that when it comes to native development - be it iOS, Android, or Windows platforms - the desire to use JavaScript stems not from a resistance to learning a new language, but to adapting to a new ecosystem. I practically look for good reasons to learn new languages. That's why I'm learning Haskell (without, even, a 'good' reason). But when you tell me that to develop for iOS I will need this IDE, a familiarity with this package manager, these packages that are used by a lot of people/projects, this build tool, these new open source communities, and all sorts of stuff about iTunes store processes I start to get a little intimidated. JavaScript is a good language (if not just because of the pure will and mindshare behind it). It has an ecosystem that I have a grasp of. I'm comfortable with my own toolset and I know what resources to use when I'm stuck, when I'm searching for an open source project or when I want to publish an open source project of my own. Oh, and if I want help I know a lot of people in the JS community who can help me, because there are JS Developers and meetups all over the place. I understand the criticism of the trend towards trying to write everything with JavaScript (and for the record am not meaning to project - you're probably just cracking a joke and I get it). Sometimes, though, there's an oversimplification and people get really vigilant about why JavaScript being used in X domain is just plain wrong. Learning new languages is awesome but entire new language ecosystems can be fucking scary.
lodash v3 is modular which enables cherry-picking modules, e.g. require('lodash/array/chunk'), great for smaller builds with browserify/webpack. There's per method packages available too https://www.npmjs.com/browse/keyword/lodash-modularized and in v3 their dep graphs have been greatly reduced.
As someone who is only just getting into node/mean stack - how hard is it to apply what I've learnt and develop further node projects with typescript? I come from a software engineering background so the syntax really does look more appealing to me. 
[You can download and try the early build now](https://angular.io/download/)
Cordova/PhoneGap, as I understand it, uses a WebView. This uses the native JS available on the platforms -- so it should in theory perform better. This, I belive, is the same approach taken by React Native.
Sounds pretty cool. I wonder how this compares to React Native. I have to say however, this website really annoys me with all the content fading and sliding in. I'm probably just cranky right now, but that unnecessary animation really irks me. Just gimme the content already.
Correct.
This sounds like Titanium, which is literally the worst thing I've ever used. I don't see how they solved, here, what Titanium couldn't solve.
The problem with this approach is that you won't really get away from the ecosystem. The only thing that's similar is the syntax itself. To publish an app for iOS you still need to learn about code signing, provisioning, and the whole iTunes Connect thing. You will still need to learn the overall API structure (unless your app consists solely of things that can be shared across platforms), and in order to find help on an issue you still need to learn the main language to read examples or to formulate questions that other developers can understand. On top of this, things gets harder to debug and optimise. Now if Apple, Google, and Microsoft sat down and agreed on a common language, API, and functionality to use on all platforms I could see a real, tangible benefit to all users. However, that's a pretty unlikely scenario. 
My (vague) impression was that with React native they've done a lot to speed up development cycles and avoid the iOS / Android dev environment buy-ins. Obviously, to publish in the store ultimately you're going to have to go through the same hoops. I see what you're saying, but the marketplace was only one part of the ecosystem that's daunting to learn. Tooling, libraries, etc. is a whole other beast.
I don't develop phone apps... nor do I use *React* or *React Native*... so I'm not really qualified here, but I think you're wrong. The point of React Native as I understand it is that it doesn't use the DOM, and ties into "Native" android and iPhone APIs.
No license, so we have to assume "all rights reserved". Not much of a point in showing the code if no-one can legally use it. TIL /r/javascript doesn't understand how copyright works. Learn to license, plox.
Calling `.then()` on any promise returns a new instance of a Promise. When you call `.then()` it's not returning the inner chainablePromise, it returns a vanilla instance of a Promise without a `test` method. It will eventually resolve to whatever the inner chainablePromise resolves to though. Here you go: http://jsbin.com/xazazefiwu/1/edit?js,console
You can use it /u/sigwhite But nobody else. Only you.
Darn it, ok, give me a minute.
I'll tell you what. Build a comment system. Write it in vanilla JS and have it bounce off an express API. Then write it with jQuery. Then write it with Angular. Then write it with React. Oh, and try to support IE8 the whole time. Realistically, I could tell you React is end all, but I've been doing this for over a decade. You should see what tools solve what problems, and then you'll be in a better position to make technology choices moving forward. Quick anecdote, my wife had our daughter and was breastfeeding, taking notes on paper. Me wanting to help out, I decided to make her a breastfeeding tracker. I did it in angular before she could finish one round of breastfeeding. It worked great and she used it for months. I think what I'm trying to say is, check out the tools, and realize what problems they solve, and then pick the right tool for the job. I use React almost exclusively now. Shit, I wrote McFly! So I can tell you that *most* flux libs support server rendering. Some more than others. I recently forked McFly into a project called Biff, because it wasn't the right tool for a project I'm building. TLDR: Go play with some shit. See what you like, see what the tools do, and then make some informed decisions based upon what you are trying to achieve. 
Much respect. I gave up after 10 mins. But something isn't right... fm('Entering the front-end JavaScript world, I now feel paralyzed.', 'front')
Just don't use em! It will be ok, I promise
They don't. Edit: Instead of bashing without providing much context, I'll expand: these folks have made a similar framework to Titanium - they use a Javascript bridge to interact with native Objective-C UI elements. The problem is if you aren't doing this extremely efficiently, the UI will lag - which is what we're seeing with this UI (or so I've heard from reports from users on HN.) I'm personally waiting for React Native to be released. I've got access to the pre-release and I think everyone should wait for React Native to release before they go about building their applications - it's on another level. So smooth, so easy to work with. It really doesn't feel like native development at all.
Turned out to be an error going from my "cheat sheet" to the one-liner :P http://jsfiddle.net/tvhpz2t3/2/ Uh, there are still some issues though. Or maybe it's fine. If you include HTML it starts breaking. I could fix that but meh.
I think there are escaping issues in my version. Otherwise, works great. And only two super-simple lines of code. Practically writes itself...
I added a comment to explain what's going on. The link in my previous post is updated. Ok, I'm going home now. This was fun. Also, I can't call this a 2-line function with good conscience because of the reduce() callback, which has 3 statements :/
React works in the browser, React native works for native apps? Basically Cordova implemented with React, without the maturity of Cordova.
Well, isnt backbone already dependent on jquery and underscore? And jsdom/mockjax is probably just for testing (guessing). Admittedly i haven't brisket personally, i've just heard about it.
Yeah, React Native is actually pretty interesting although I have only looked at it very briefly. However, at the moment I see it as a (very cool) way to run and render a *"web app"* in native elements on screen. When I say web app - as opposed to native app - I mean an app where the business is processed on a server and where the app is mainly handling the view + controller. React Native exists where you would otherwise write the UIViewControllers in a normal iOS app. Now, this is useful for a very large section of apps out there, but one of the great benefits of native apps is the things you can do on top of that. Image processing, multi-threading, running a local database, rendering 3d content, etc. Perhaps it'll be easy to use React as a view + controller layer and interface with native code for the rest, but I'm not sure about the idea of abstracting the native code directly over to JavaScript without a good reason. React brings a totally different paradigm for handling views and that might warrant using a different language. Putting a thin wrapper over the entire native code base just to make it look like JavaScript doesn't quite appeal to me though.
what /u/jcready . IMO you shouldn't add methods to the promise like you did. if you want something called after a promise has been resolved, just make it a function and pass it to the promise. 
Development slowing down isn't necessarily good or bad. I use Marionette for some stuff and it works great and solves my problems. That doesn't mean I'm not excitedly following and playing with React, but I'm not gonna rewrite huge apps and appreciate that those old ones are written on stable frameworks. The really cool thing about this ember stuff, though, is that developments from other frameworks are making their way into it in a way that most users can take advantage of them without any code changes. I'll admit thats pretty badass!
All of the reviews of the one sample app in the Play Store are complaining that it's painfully slow. Edit: they weren't lying. Starting the sample app takes 20s on a flagship Android device. The UI is NOT native and very laggy. 
Wrong. NativeScript (and React Native) uses a JS scripting engine to push around native objects (eg UIKit-&gt;UIView/UIButton/etc on iOS).
When did you use it? It has changed a lot since 2012. Also, I am assuming you haven't used hyperloop yet.
:[]
Not that this has anything to do with the plugin itself but geeze does that site suck. Fuck scrolling effects man. If they're subtle whatever but if I can't see the content in the lower third of my screen then that's just hurting usability and design.
They touch on dates at the very end of the keynote. In alpha now, they are starting to covert large angular 1.x google sites to 2.0 in May and see how it goes from there.
Hmm... this looks promising **I think**, I'll have to check it out more in depth. Also, wtf, my god, that website looks like 1999 threw up on it.
The content fading in, and the gigantic text. Moth look nice aesthetically, but it also makes for a worse user experience.
I've been experimenting with column-aligning keys and values. I've been fairly happy with it, but you're not the first person to bring that up. I may relax it in the future.
What you've expressed is the *exact same* sentiment someone coming from any other ecosystem would have concerning client-side web development, or web development in general. Someone who's already well versed in iOS, Android, Windows, Linux, BSD, Solaris, or whatever else may have an entirely familiar toolset and ecosystem for writing software than what usually appears on the ever-evolving web stack. I think the difference there is that the web stack is changing frequently and sometimes dramatically, where those other platforms change only so often - or are standardized enough that the changes are universal. Just another perspective on things, I guess.
This may be splitting hairs, and people may take issue with this, but I don't really consider React a framework. I use React in almost every new project, both at work and in my personal projects. I love it. It is amazing. But I don't consider it a framework. In my opinion, and I think the opinion of the React team, React is a smart view layer more than anything. React takes so much of the headache out of manipulating the DOM in response to changes that I have almost completely eliminated jQuery from my projects altogether. You still need an underlying data model of some sort, whether is be Flux stores or Backbone or simple JS objects (with a render call or a change event emitted when they update). This is why you see so many articles and tutorials on "using React with X framework". React is hot right now. I think React knowledge will be valuable in the job market. I say learn React, whether or not you learn Angular or Backbone or any of the other frameworks. 
You can optionally write your code in ES5, ES6 or TypeScript (or Dart?) ES6 gives you a lot of benefits over what's currently in the browser. TS extends 6 to give you an optionally typed language. Now because of AtScript's annotations you also get those, which are convenience syntax around attaching various metadata to objects. Angular uses it for DI, Components etc. Basically, each time, less typing. Smaller code (before transpilation).
from the github issue list - stats on using localCache (not isolated to using just for font) http://blog.mebooks.co.nz/using-local-storage-to-improve-page-load/
How is hyperloop? Did they solve the ~20mb minimum app size issue on Android?
Good point on childNodes changing length :) If you batch up your appendChilds then browsers optimise that and wait for reflow until a read afaik only IE9 and earlier will cause a reflow
http://jsfiddle.net/dws4d72o/1/ This is the classic JS way. Yes, it's a lot of manual wiring up you have to do yourself in this form. This is the (verbose) equivalent of ES6 classes. I don't get what your approach is trying to achieve. This guy gives a pretty good explanation of what's happening. https://www.youtube.com/watch?v=PMfcsYzj-9M
I will watch the whole video later. Took a brief look at it and the use of Object.create in the video is similar to my example. Later in the video the new class constructs are explained. That's the classical OO approach most developers (including myself) are familiar with. What I'm interested in is to skip the whole class concept entirely in JavaScript and use pure object prototyping. My example is an attempt to make the code as simple as possible and at the same time dynamic and powerful enough to be used as a design pattern for real applications.
Oh, I forgot. This example in my other thread is a better illustration of the design pattern: http://www.reddit.com/r/javascript/comments/2y3x14/cleaner_javascript_object_inheritance_example/
how about bringing just one &lt;tag&gt; across so it looks like this &lt;div id="source"&gt; &lt;tag&gt;data1&lt;/data&gt; &lt;tag&gt;data3&lt;/data&gt; &lt;/div&gt; &lt;div id="target"&gt; &lt;tag&gt;data2&lt;/data&gt; &lt;/div&gt;
Great small library with clear purpose and readme. However I have to disagree with the way you're stringifying different types. You're using these "magic strings" like `::type::`. Why not express them in a nested structure, after all this is what JSON can do: {"d":{"__type":"date","__value":"2015-03-06T03:08:59.391Z"}} Also in my opinion your library is a little too modular because some files only have couple of lines of actual code. I would separate it in modules by functionality like `date`, `function`, `regexp` so modifying and adding types would be much easier.
I wouldn't think so, Google's V8 team probably have lots of other priorities than just ES6 support, so I don't see why they'd commit to a date for it.
then it'd be, var sourceDiv = document.getElementById("source"); var targetDiv = document.getElementById("target"); var childNode = sourceDiv.childNodes[1]; // Note [1] index targetDiv.appendChild(childNode); or in jQuery... $("#target").append ( $("#source").children()[1] ); //again, note [1] index (agan, untested code)
There is an interpreter that takes your javascript commands and eventually turns them into machine code. The interpreter itself is built using other aliases which use other aliases etc.. until you get down to machine code. 
The languages are for humans. The compilers and interpreters are for the computers. They bridge the gap. Of course you need to know what your code will tell the computer to do.... But an if is nothing more than a statement that returns true or false to conditionally run some additional code. 
They are doing the same thing Titanium does with its native solution and Alloy. Titanium built what I thought an impressive system, "Kroll" (https://github.com/appcelerator/kroll), which lets you interop with multiple languages. However one thing Titanium has failed on for a long time was providing the same level of API features across Android and iOS. Then they also tried to add Black Berry and that died... Plus the crashing, and no idea what made the application crash. I remember a few arguments I had where I would say, that you cannot build ONE ui for them all, which funny enough since they finally admit in the recent years. Now Titanium has Window Phone support but its native counterpart is in preview. While Titanium is an amazing feat, building complex UI has been extremely difficult, more so than just going the truly native approach. With NativeScript and Titianium the UI is "native", its not using a webview (like Cordova does). So native means anything as simple as a "View" which exists in iOS, Android and Windows Phone, can be used to build a UI. That lets them do a lot which includes building UI that is not using the built-in components / widgets / etc. However you can look at their Git repo, in fact they are trying to use as many native components / widgets as possible, for example the datepicker (https://github.com/NativeScript/cross-platform-modules/blob/master/ui/date-picker/date-picker.d.ts). To be honest the most appealing feature I see is its Xaml like bindings, its UI layer, TypeScript support, and Telerik Platform for cloud based build (not needing an Mac to build applications). However I would be hard pressed to not also suggest Xamarin Forms, as with that approach, if the Layout / UI is not possible, with the primitives it provides you, then you can use the native tools. I am sure it has its own bucket of problems, but its not _just_ release. As for your comment about the 20 seconds... Its a known issue, remember this is new software, a 1.0 release. &gt; First time an Android application is started, it may take several seconds to load and there is no visual indication that the application is alive and loading. &gt; A second start will be much faster. We are aware of this limitation and we are already working on a prototype, which improves things significantly.
Like a snake eating itself.
Not sure why you are downvoted.From the site. &gt;The Angular 2.0 API is currently in active development and not production ready. This page will showcase a preview of proposed methods to help further the discussion in the development community. 
You only have to use TS if you want to contribute to Angular itself. As a user, you have the choice between Dart, ES5, ES6, TS, and to-JS languages like CoffeeScript.
As someone who is quite fond of typescript, I'm excited for the improvements to typescript if not for angular.
&gt; The only thing I really want that isn't in today is destructuring and the spread op. How about fat arrows, classes, and default function parameters? I'd consider those to be more important.
Hmm, I'll try this on different devices but I'm unable to get anything to shift sides of the screen.
What!!?! How dare you like something that came out of Microsoft!!! Don't you know that everything they create is crap! I don't need to look at it to know that it's crap. /s Seriously though, the bad things I hear people say about Typescript almost always come from ignorance of what Typescript is.
Why not?
So your problem has nothing to do with Typescript and everything to do with Microsoft. Got it.
The "fact" it breaks compatibility isn't true. The new router will support both Angular 1.x and 2.x so you can slowly attrit your Angular 1.x code from within your Angular 2.x code base. Watch Brian Ford's stalk from ngConf for more information 
You rock! Thanks for all your contributions. I use slick a lot. ^_^
_that isn't in today_ &gt; console.log( a =&gt; a ); [Function] undefined &gt; class Foo{ } [Function: Foo] defaults, ok. But not as important to me since it's easy enough to simply write `varName || default` (plus Babel supports it)
I just recompiled an app for android and it's only 10mb using 3.5.0.GA with 1.5mb of images in /app/assets. However, hyperloop will drop the file size even lower-- 6mb for an android app. Once they release the android build, you will have the option of going engineless. They kept the developer APIs (TI.UI.xxx) stable, but 4.0 will be a complete rewrite. The Windows phone build is the first to use the hyperloop based version of Titanium. More accurately it should be said that it is the first HAL + TitaniumKit based version. They are working on Android and iOS now. disclosure: I am an owner at CodexLabs.com and offer a 5 day instructor led training class on Titanium.
6mb seems very reasonable for a file size. This is one of the things I worry about for react native: their only android example (groups) is 20mb. It's hard to tell what is and isn't assets. Is hyperloop in some sense usable now? Is it possible to make a very simple production ready app, like a basic to do or something?
I have hopes in React native
Why do you expect me to care that you don't care that some features you're using don't actually work as specified? :P "They do not have their own code generation yet and are simply compiled as ordinary functions as a dummy choice (i.e., scoping of `this` and `arguments` also does not work)." Currently, V8 does not implement ES6's arrow functions. And that's the end of that.
Googlosoft or Microogle?
&gt; And that's the end of that. What a fucking arrogant, douche thing to say. You're not worth having a conversation with.
so why did they make it typescript? isnt everyone using javascript
He's a troll
it extends JavaScript to do some stuff that isn't already in the language...think of how people are using Babel (6to5) to compile from ES6 -&gt; ES5 so that they can get the features that 5 doesn't have.
yeah, it blows my mind how, despite the amount of times they've said that, I see people complaining that there's no migration path...I guess people hear what they want and ignore everything else.
I think you meant TypeScript == AtScript because one got coerced to be the other :)
Welcome back. Plagiarism isn't going to get you anywhere. The time you spent trying to *avoid* doing your assignment would have been better spent learning what you needed to complete the assignment. Find a canvas tutorial. It's pretty simple and shouldn't take you very long to learn everything you need to know to use it effectively. Next, find yourself a requestAnimationFrame tutorial. You should be able to work with it after just a few minutes. All-in-all, you'll need about an hour of study time before you can start your project. Had you just done that a few days ago, instead of searching for a project to steal and pass-off as your own, your project would be done by now. You'd also be better prepared for future assignments.
I haven't used Hyperloop - my experience dates back to around 2012 using *mostly* device agnostic JS. 90 or so percent of my code was pleasantly cross platform, and the 10% that wasn't was easy to manage. I actually rather liked the model! My hatred of Titanium stems to how buggy it was, and how unreliable the build system was. I assume it's improved since then. But I was burned really badly, and am now fully in the "native" camp.
Yeah, if any of those factors attribute to the decision to ignore each platform's UI guidelines, then the end user experience suffers. I would consider that wrong in most cases, even though it's fully possible to find a reason why you can live with it. I do things that I know I should have done differently all the time, often due to deadlines. But I have to accept that what I did is wrong and that it has certain consequences.
I have worked with a bunch of them. Have used jQuery, backbone, angular and ember, etc... The one I am using right now is Meteor. Probably the most fun I have had developing in quite a while. It is worth giving them all a try to figure it out. However, I can see how that can obviously be overwhelming. Honestly, go look at the docs for them. Pick a couple that seem interesting to you and then try those. You don't have to try every single one right off the bat.
The "one part" you are dismissing allows you to run your Angular 1.x components within your Angular 2 apps. What more could you possibly want? 
I think it's typical of the fast moving JavaScript framework scene at the moment. It's almost become normal to go for the "greater version number is better" temptations and people will feel they have to migrate to stay current.
I don't know about that. If you ignore the new frameworks and do-everything libraries that seem to come out daily, the web has pretty stable for years now.
&gt; I'm looking to put together a code style guide for my team's front end. Don't bother. It's a lot of work and there will be countless useless discussions. I highly recommend to just pick one of the popular ones. https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml http://javascript.crockford.com/code.html **Edit:** http://nerds.airbnb.com/our-javascript-style-guide/
Promises used to be non-standard too :p Edit (after reading the github page) I would agree that it's slightly "simpler" than promises. But in this case simpler doesn't mean better. Promises have this added advantage of being chainable, so you can say *"When the (first) request for map data has been completed, THEN go ask google maps for directions, THEN (when directions have been received) render a map into this &lt;div&gt;"*. I like the idea OP, but I doubt its usefulness.
And I'm willing to accept that if I can see another benefit, which is why I was asking :) It honestly looks more confusing to me than promises (or rather it looks a _lot_ less organized)
well for instance it does not force the two outcomes. for some events it's simply not natural (page load for instance). Second, only subscriber is supposed to be exposed to a user. Meaning that you need to only deal with whenSomethingHappened() method to subscribe your listenere and be sure that it will be invoked when needed. The Whenable instance itself remains private
I'm not against Promises, I just see the features of Promises a little bit superfluous for some cases. The idea beyond Whenable solution is to extract a single tasty feature out of Promises, namely an opportunity to set a listener for an event regardless of if it has already been triggered, in the simpliest manner possible.
&gt; namely an opportunity to set a listener for an event regardless of if it has already been triggered Again, promises do this... If you call `.then()` on a promise that's already been resolved, your cb executes. &gt; in the simpliest manner possible the code for the callback is identical, except for the word `.then`
You should rewatch the talk again, Brian Ford clearly defines what a component is for Angular 1.x. He also spends plenty of time talking about using 1.x components in Angular 2. (Talking about the talk from yesterday at ngConf.) If you don't have to change your Angular 1.x code for it to work with Angular 2, the migration path is completely solved. The router supporting both 1.x and 2 components means you don't have to change your Angular 1.x code. QED
Yep, you are right. That's the point: Promises have more features, Whenable have only this one.
So... why is that a good thing? You don't have to use the other features of promises if you don't want to :) You can argue file size, for now, but promises are becoming native so that won't be relevant for long.
Visual Studio will become the most productive SPA tool out there
I don't really see it, not as a blanket statement. I think it really, very much depends on specific scenarios. It's exceedingly rare to not be able to do something in one general purpose language that you can in another. Certain languages might make it easier to do certain things by having them baked into the language but that doesn't mean you can't accomplish them in other languages in more verbose ways. As for making you approach problems in different ways: There's almost always multiple ways to approach a problem in any given language already. If the features or limitations of a different language create more approaches, there's only benefit in knowing those approaches if you use that other language. I can implement every design pattern in any of the general purpose languages I know. There are nuances to each one but knowing those nuances doesn't help me be better at being a developer, they just help me be a better [insert language name here] developer. I think a better analogy is like saying you can't be a good auto mechanic if you only know how to fix Hondas. Knowing how to fix Audis and BMWs too makes you better at fixing Hondas. Also, you noticing that better developers tend to be polyglots doesn't mean that they're better *because* they were polyglots. It's very likely that good developers *become* polyglots, not that polyglots become better developers.
Technically yes, it is open source. No one has stepped up to the plate yet though.
What's not to like about 2.0?
Hi /u/ovvn3r, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.mgechev.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.mgechev.com](/search?q=%28and+site%3A%27blog.mgechev.com%27+author%3A%27ovvn3r%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|7|58%
Why the downvotes? Anyway, according to the video a component is a template and a controller. However, AngularJS 1.x consists of other code which doesn't fit this definition. Mainly directives and services. I don't know how the migration works for those. AngularJS 1.x can also have components inside components, I wonder how the new router supports that.
Pretty much. People are probably overacting over this TypeScript thing because of Microsoft's name (new Microsoft is balls deep in open source now, move on from old M$ people!). The end result is just that the Angular 2 *library* will be easier to maintain (statical analytic tools/refactoring tools and all that fun strongly typed fun). Nobody is going to be forced to use TypeScript to make angular *apps*. They'll take the angular2.min.js and it's going to be "good" old JS.
I don't know, I've just seen people who like it and who don't since it seems to be an entirely different framework
With a canvas
You were right; the elements don't have the attribute until after they're clicked.
you guys must not be .net developers. Telerik might as well be named "bloaterik". It would take a whole lot for me to be excited about anything they have to offer.
ITT: People who havent used Telerik products. 
Now I watched the Angular1 to 2 talk I'm actually understanding the 2 concept alot better. I think the annotations in TS will be a nice addition to keep your code cleaner from all the boiler plate.
WTF! How could I miss their webinar. Is it online?
You should really take an assembly class or better a C class that has a two week section in assebly. When you're that close to the metal, the "machine" of things makes much more sense.
I think the argument is that because v2 is so different that we'll have to re-learn the framework so people are asking the question why learn Angular 2 over say Ember/React/etc.
Man, I'm so glad I'm not the only one that feels that way about Telerik.
Optional types are nice for large teams. Annotations. Can use ES6 features now, etc.
Dont worry, they have a staff of developers and integration specialists to help you use their convoluted and ridiculously bloated products! 
Mentioning Kendo is a sin in the office now.
Someone at work decided before I was hired that Kendo was 'the best option at the time'. I'm now stock working with it.
Long live moment! Brings to mind Computerphile's wonderful rant about how horrible writing code that deals with time(zones) is: [The Problem with Time &amp; Timezones](https://www.youtube.com/watch?v=-5wpm-gesOY)
If you consider the significant fact that promises come free as they're now part of the language, taking a library dependency that offers very slight simplicitly wins (ignoring the time spent learning how it works and differs from existing solutions) at the cost of functionality and interoperability with other libraries seems very questionable, IMO.
Speaking from experience as a front-end lead: Setting up Overcommit with the default JSHint config will do more for your codebase than any written standard ever will, and it causes way less work and frustration for you.
Hey thanks for the tip. We do actually have jshint integrated with our CI such that no PR can be merged without passing jshint first. It has both improve the readability/uniformity of our code and even helped us spot actual code errors. I'm looking to build on what we've gained from this by just adding a few sensible code style standards that jshint doesn't or can't enforce. And just to be clear these ideas aren't arbitrary. It all stems from actual observations with working with our current team and reading our existing code.
http://aurelia.io/ (sort of like Angular 1.x continued... by some guys that worked on Angular core)
Embrace, extend, extinguish.
It's a superset of JavaScript - it brings in some static typing, things like generics/interfaces/etc, but also compiles to plain old JavaScript. It's still very much 'JavaScript', but with a few nice extra features on top, and it's not like learning a whole new language.
In my experience, everything is easier. Get type declarations from DefinitelyTyped (install them automatically with TSD). Use an editor or IDE with intellisense/autocomplete. Voila: your productivity sky-rockets.
JS is the C of the web. As in: both a compilation output and a very popular high-level language used by human coders.
It really does sound awesome. Thank you. 
Does this provide any method of composing 'Whenables'? That's really the main selling point of promises, and without this it's only going to be simpler in the most trivial of scenarios (I'm not actually convinced it is even then - the examples to me look more complex).
If your team does settle on a new style guide please [let me know](https://github.com/prettydiff/prettydiff/issues). I would like to [support it](http://prettydiff.com/guide/styleguide.xhtml).
JSCS with the Grunt preset and some company specific changes is working well for us. If a tool can't enforce your guide, it will be largely useless. (JSHint + JSCS) or ESLint are a must. 
&gt; Your IDE will know where something came from and knowing the types of things means it can do sanity checks and make smart suggestions. Do you know if anything like this exists for Sublime?
[**@asvd0**](https://twitter.com/asvd0/) &gt; [2015-03-07 01:10 UTC](https://twitter.com/asvd0/status/574014098939232256) &gt; function Whenable(l,e){l=[];function a(c){if(c)l.push(c);if(e||!c)while(c=l.pop(e=1))setTimeout(c,0)}return{emit:a,whenEmitted:a}} ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
 whenFirstThingLoaded(loadSecondThing); whenSecondThingLoaded(loadThirdThing); whenThirdThingLoaded(initialize); .... But now we're back at square one with continuation passing. Other than the most trivial of examples, how is this simpler than promise chaining? (Especially with async or do notation?). 
https://github.com/Microsoft/TypeScript/wiki/Roadmap I think Generators are targeted for 1.6
IntelliJ supports it out of the box.
Pfffffffffffffffftt. You all should do what my team has done up until this point: disregard how dates should be handled completely. It's great! You should see the amount of bugs we get to work on because a timezone offset doubled, or we have a good 'ol NaN shows up instead of that pesky date. My favorite thing that we do is that we are always trying to find new and clever ways to reinvent the wheel. Pull our date logic out into lib functions? *fuck that,* let's just do it all throughout the application AND let's keep each implementation unique like a god damn snowflake. I lied about my favorite part. The real reason I'm so passionate about how we do things on our team is that I am the one who gets to clean it up! Ever looked at dates and time zones so much that you don't even know what to believe anymore? (Send help, am dying) Note: the preceding statement is laced heavily with sarcasm. Things like dates are best handled by dedicated libraries as awesome as moment is. Don't end up in a situation like me boys and girls, just say NO to manually handling js dates.
Yeah, but Crockford uses K&amp;R style brackets. I'm pretty sure it's considered an unforgivable sin in several major world religions. (The example he give of problems caused by correct use of brackets, a large multi-line object literal in a return statement, is also a stylistically evil thing you should never do.) Now, to settle the matter of tabs vs spaces ...
What is simplier is a bit subjective thing, I guess. On my opinion, the code I just wrote is simplier because of the following reasons: 1. It literally expresses the relationships between the events and processes; 2. It uses the simpliest constructs (a function with a callback). So for me it looks like Whenable does not need any kind of sugar, since it's sweet by itself :-D I mean, combining the given approach with whenAll() and whenAny() functions should likely provide enough flexibility to describe the most tricky cases in simple ~~words~~ constructs. Is there something wrong with continuation passing that I probably miss in this case? An asynchronous event shipped with a callback function, seems like pretty natural to me..
I haven't been able to remember how to correctly spell that product's name between mobile screens. It makes me think of areolas though which is nice. 
not a superset of ES6 though yet, TS do not support a lot of basic ES6 features, like the module system ,quasis and even generators.
Don't forget about the plugin [Twix.js](http://isaaccambron.com/twix.js/). Adds much needed duration handling, iteration, lots of functions for dealing with multiple ranges, and it all works seamlessly with your moments. Also, reminds you of the tasty candy.
The expressions "Callback hell" and "Pyramid of doom" come to mind. It can be hard to encapsulate complex flow control using raw continuation passing, and attempts to try usually end up as spaghetti code. This is why Promises are so popular - they solve one of the biggest mistakes in the js ecosystem - the reliance on calbacks - and instead wraps it in a simple abstraction that allows imperative looking code to run asynchronously. In the past Promises in Javascript were a little ugly syntax wise. But now that ES6 has async/await syntax, the overhead is minimal. It's not quite do-notation, but it does the job. The only difference between 'Whenables' and Promises is that whenables don't allow the monadic(ish) composition the Promises provide, which is the entire point of promises in the first place. (And if you don't use that functionality and want to revert to continuation passing, promises are effectively identical to whenables). I apologise if this post comes across a little patronising - I don't mean it that way. I definitely appreciate active contributors to the ecosystem and encourage you to continue hacking on libraries such as this. 
That's strange - it works for me in all of those same browser versions (I just checked them all). Obviously WebGL must be enabled, which you have to manually do in Safari, but Chrome and Firefox should have it enabled by default. I'll look more into it, but thank you for the error report!
If this worked with html and regular web code, that would be pretty cool. But that XML mark up looks like bullshit to me. Like that trash you're supposed to work with for WPF layouts. NIEN!
https://cloudup.com/ckRU0IphC4j We also made coding bible
Microsoft like any other company has strengths and weaknesses. Dev tools are not their weakness.
&gt; I think the argument is that because v2 is so different that we'll have to re-learn the framework They made the framework simpler while allowing it to build more complexity. I feel that as a lazy programmer it is my duty to "re-learn"ing easier way to get work done.
Browser not supported. No help for how to fix it with my current browser, or which ones are supported. Chromium Version 41.0.2272.63 Ubuntu 14.10 (64-bit)
[Ô¥æÕ°‡πèÃØÕ°‡πèÔ¥ø O'RLY?](http://i1.kym-cdn.com/entries/icons/original/000/009/993/tumblr_m0wb2xz9Yh1r08e3p.jpg)
I'd suggest downloading their showcase apps and testing them out. It was a bit disappointing to be honest, transitions and such were quite sluggish. But one can hope that it's something they will improve. 
From what I gather from reading their blog he's not alone and has some sort of team.
I love moment and we use it throughout our activities. My only wish is that it would be immutable by default so I wouldn't have to clone so often. var now = moment(); var d = now.add({days: 1}); assert(d.valueOf() === now.valueOf()); // we probably didn't mean to modify "now"
Doesn't work on Safari 8.0.3 and Chrome 41.0.2272.76 on my Macbook Pro Retina. All I see is a blue sky image.
Okay after seeing bunch of these posts I have to ask, why was it necessary for angular to add these features in the language for their framework to work when Ember and other framework were able to function just fine without them? What's the crucial benefit that I get from this? I know TS is optional but was it really necessary to be part of the framework? 
Works for me and looks great! I did some work on a 2.5D game with Babylon a year or so ago and enjoyed it. I should get back into it.
Indeed, I'd recommend to choose one from jslint/jshint/eslint and then add jscs.
Gotcha, was just the first thing to jump out at me. Really enjoyed your talk at react conf by the way!
Don't worry, my point of sharing this was exactly to get some critics in order to figure out if something is wrong with Whenables, and if I miss something about Promises :-) So thanks. But the questions is: is the chaining via .then() method just a syntaxic sugar over the continuation passing?
Michael probably writes for circlejerks... Backbone required jQuery. Not to mention how useful data-attributes are. Especially in using Web Components and Polymer. What makes a good web designer is knowing how use these effectively. Telling people not to use them is a mistake and creates lazy developers. I'm not a fan of jQuery myself. I like to keep things as Vanilla as possible, but jQuery is definitely necessary, especially with large scale apps. I find myself using Backbone and Marionette more often than any other frameworks. Anyone who mentions alternatives for Word press and Drupal probably isn't well off in web programming. We don't need alternatives. We need web programmers. Python and Django are still very much as useful as CakePHP, and, in fact, run a lot better. I feel like PHP is far too old to have as many problems as it does. Not to mention Golang is on the rise and is about as powerful, if not more, of an injection tool that makes PHP and Backbone next to unnecessary. Go has some seriously cool packages that can do exactly what Backbone and Marionette do, and with less lines of code. And don't get me started on the fact that Go is currently the fastest JSON parser next to C. It's time to step away from the baby crib and start learning the more fundamental aspects of modern day web programming. 
even when you click and drag around? I only saw the blue sky image at first too, until i dragged up and down with my mouse. 
Or use Browserify and require('url') clientside.
When he mentioned aurelia, he could have mentioned JSPM too, with it you don't have to wrap the library in those weird checks and just use commonJS module everywhere without much hassle.
I would have opened an issue but I don't have a Github account atm, sorry. Anyway: Your output is not valid JSON.
You don't need JS for this. Just use &lt;a href=&gt; or forms, and implement it server-side.
Nope. http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts But it is really close. Just ironing out kinks.
Looks good - the collision detection seems to hurt my FPS by quite a bit though. Looking around is fine though.
Nice! I remember trying the instances demo from the website on my macbook pro, and the frame rate was kinda bad. Seemed like it wasn't build right or something. need to remember to try this on my laptop later. As i think it's much nicer looking. If you don't mind me shameless self promoting: Recently built a game for iOS using babylon. Can play the desktop version here: http://projects.agmprojects.com/wrathofthecube
This sounds very awesome. I've wanted to do something like this for a while (or at least try it out) but I have a few reservations: * web workers seem to require a separate JS file. I don't know why, but this totally skews my build process. Is there a way to just pass them a function? * Is this actually a sensible thing to do? * Is there any chance this could happen natively with angular in the future?
Entertaining presenter and a really interesting talk, thanks!
I really can see that as the future of cloud development. Thanks for sharing!
Ive seen websites function just fine without frameworks. Does that mean they shouldn't exist? Infact, vanilla js is able to function just fine for everything, so lets just quit. TS adds type sanity to JS. Anyone who works on large complex javascript applications that came from a typed language knows that typing is a very useful feature we have to bend over backwards to handle in JS. 
Thanks! Always nice to know it helped somebody! üòÅ
Sorry, but I do get it. What am I missing? If I have to write scope.set('foo', 42), then I do not need dirty checking, the scope always knows when it changes. Ditto if I write scope.foo=42, and use Object.observe, again I do not need dirty checking, I actually do not even need scopes, I can attach anything to the model and Object.observe it. Problem is that Object.observe is only on Chrome for now, and the polyfills do dirty checking, so they are useless. Once Object.observe lands in all browsers, Angular's dirty checking, ember models, etc.. are all history.
&gt; figure out where the mouse click event fires and which tile is in the mouse's x/y location. Finding the "pixel" clicked in a canvas can be tricky. Essentially, you'll need to convert from the dom coordinate system to the canvas coordinate system. Start by getting canvas.getBoundingClientRect() and window.getComputedStyle(canvas) You can then use that to find the left, right, top, and bottom offsets, being sure to subtract the margin and border of your canvas element. That will essentially get you the size in dom space of the part of your canvas element you care about. This is likely to be different than the width and height you specified for your canvas, so we'll need to convert your mouse x and y coordinates in to canvas space. For example: canvasX = ((x-left) / (right-left)) * parseFloat(canvas.width) Once you have that, it's trivial to figure out which tile was clicked. &gt; I also need to make sure the click event doesn't trigger from the mousemove event. No need to worry about that. 
I actually don't think it's weird that doing something like if (myundeclaredvar.property) { // Something } throws an error. The conditions in between the if statement parens can be any expression, and this one tries to get a property of an undeclared variable. Now, typeof is a bit different, and the real shame is that (again, for an undeclared variable) this does not work: typeof my.undeclared.chain.of.properties 
I figure it is, I just see it as annoying that in my coffeescript application, handled by grunt (that gets minified and concatenated), that I just have to have this random js file floating around to do web worker stuff. How would you do it with a data URI if you don't mind my asking?
It only throws an error if the "myundeclaredvar" doesn't exist. The purpose for the if is that once you know the var exists you can check it for a property. You aren't supposed to use it on variables you don't know exist. var x = ["blue", 5, {ok: true}, {}, undefined], i = 0; while(i&lt;x.length){ if(x[i].ok){console.log("okay")} else{console.log("nope")} i++} The above prints: "nope" "nope" "okay" "nope" And then throws an error.
var xPrice = 100; var yPrice = 120; var zPrice = 130; var x = prompt('Enter the number of X shares'); var y = prompt('Enter the number of X shares'); var z = prompt('Enter the number of X shares'); var total = x * xPrice + y * yPrice + z * zPrice; alert(total)
`if(obj.prop)` works when prop is truthy as an incidental, logical product of boolean coercion. Trying to read a property of a non-object (undefined) causes an error. How does this not make perfect sense?
thank you
`if (myundeclaredvariable)` is trying to access a local variable that doesn't exist. This is a valid runtime error, it indicates that either there is a bug in your code, or you're trying to access a global property which hasn't been defined (in which case you should be using `global` or `window` to retrieve it). This is consistent with most all languages (even PHP does it if you've got error reporting set properly). `if (declaredvariable.absentProperty)` is trying to access a key on a hash table (this is a simplification, but accurate in application). You can think of it as calling a function on `declaredvariable` to fetch the value stored under `absentProperty`. Since no value has been stored under that key, it returns undefined. A series of object property references is not a single variable reference, it's one variable reference and then a sequence of hash table accessors. `value.undefinedProperty.something` results in an error because the first accessor returned undefined instead of the expected hash table. From the engine's perspective, the `something` accessor is just another statement, trying to perform an action on a hash table that doesn't exist, so the engine informs you that it can't retrieve `something` from an undefined value. --- As for your issue with truthiness, this can be simplified quite easily. There are five values which directly (eg, when used in an if clause or logical comparison) evaluate as falsy. Everything else is truthy. 1. `undefined` 2. `null` 3. `false` 4. `0` 5. `''` (empty string) (Note, this is not the same as coercing to a boolean using `==`, [which has much more complicated rules](https://dorey.github.io/JavaScript-Equality-Table/)) If you've not read it, I highly recommend Kyle Simpson's excellent [You Don't Know JS: Types &amp; Grammar](https://github.com/getify/You-Dont-Know-JS/blob/master/types%20&amp;%20grammar/README.md#you-dont-know-js-types--grammar), which has a whole chapter on coercion rules.
wow, glimmer is sick. 
&gt; Just because you can evaluate true for a variable being present doesn't mean you can evaluate false for it's absense. That would make way too much sense. It would make a lot less sense. Of course a truthy property of an existing object evaluates as true. This isn't some special mechanism to "test for a variable being present" (in fact it won't distinguish between an undefined property and a falsy property), it's basic boolean coercion of a variable or property. If you try to read a property of variable that isn't defined (`undefined`) you'll get an error. &gt; In any functions this refers to the owner of the function Not true. `this` usually refers to the *calling context*. There is no "owner". `this` is simply whatever object is named before the `.` when it's called. Also see `bind`, `call` and `apply`. &gt; So you can see where it starts to get confusing. The same keyword has 2 totally different meanings in 2 totally different contexts. `this` is a highly contextual keyword in any language. In an event handler it refers to the element because, put simply, `myElement.onclick()`. Exact same rules. &gt; Tripple equals is probably what you wanted every time you put ==. This is the only valid complaint in your post. `==` can be dangerously unreliable.
I agree it may be non-obvious, but I'd say it's just one of the things that you learn once and then know. It's like saying it's weird that you can't concatenate arrays with +. It's a functionality I'd put in if I was making it up, but javascript isn't whatever I want it to be, it's one exact thing that already exists. God I wish I could concatenate arrays with +.
That's very elegant use of map. Is there a reason to use map over for loops?
I saw the talk about this a while back, but I can't help but feel like it's a _horrible_ idea: - Setting styles directly is _much_ slower than setting class names - This _completely_ "disallows" common CSS across a site - If you pass the CSS down through the component tree you're left with a mess of how to figure out where CSS is coming from - If you have any CSS keyframe animations, the code for that is still going to be in stylesheets, no? This means you have CSS for the same component in two different places - You're now slowing down things like `mouseover`, etc by _forcing_ JS to be necessary for everything instead of letting the browser handle simple transforms. You also now need a lot of extra boilerplate code to handle simple things like this. Discussion?
`== true` doesn't convert any truthy variable to true. What you're saying applies to any truthy value, and '0' is a truthy value because it's a non-empty string
XAML is excellent in my opinion. I used it for a few years in the late 00s.
Your paste is a bit sloppy and hard to follow. Here it is formatted a bit better: https://gist.github.com/jbest84/85321cd7b8d2d9164a55 My advice would be to run JSHint on your scripts. I see several implied globals (index, and i in the loops are missing var) and missing semicolons. timeStr is defined in the callback function to jQuery's getJSON call. This means it is scoped to that function only. lineChartData is global, so the timeStr reference on the labels property is looking for window.timeStr. A quick fix would be to make timeStr global. A better solution would be to move the jQuery getJSON call and the other vars into window.onload, or scope them in a closure. - *-EDIT-* Here is a line chart we use in our CRM mobile product: https://github.com/Saleslogix/argos-saleslogix/blob/develop/src/Views/Charts/GenericLine.js
Hey, this is actually pretty great! Was dealing with some animations earlier with unique easings and this would've been great - will definitely use this in the future, probably
This sounds awesome but something about this guys presentation grinds on me. Can somebody ELI5 so I don't need to watch it?
cute
@mrsud this is awesome
Nice one, will definitively be looking into this 
I love the apps on the desktop.
The readme mentions a Webpack plugin that would extract out the styles into a separate CSS file.
Hi /u/mrsud, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Here are some examples: http://tldrify.com/7l8
I still don't understand the hatred for ==. It is, after all, a very important operator in any dynamic language. I very rarely use === (possibly out of rebellion against the nonsense) and have never (in at least 10 years) encountered a problem. That should be particularly amazing, as I (like so many others) hadn't bothered to learn much about the language until 5 or so years ago. It's not dangerous. It's not complicated. It is, however, essential. Don't limit yourself.
Hey thanks. I think I get the sentiment now. Although, I wouldn't be using types anytime soon for the sake of simplicity I'll probably dabble into it on a large code base. 
upvoted for "definitely, probably"
I think project is really useful. There was not a direct link to the Github repo for me to you give a star. For others who like this repo here it is: https://github.com/caspervonb/amok
But it could be more prominent i guess.
Thanks for the feedback! Yeah I know a fair bit about closures and the module pattern but thanks for the suggestion! My reason for using objects as opposed to the module design pattern is that it's far easier to test in an automated fashion. The re-binding isn't totally necessary just yet but it's a good thing to put in place if you're ever removing and/or disabling objects. If I were to have an addEventListener('click', function() {}.bind(this)) and then attempt to remove it via removeEventListener('click', function() {}.bind(this)) it wouldn't work because it's not the same function reference anymore. Thus the re-binding.. Would love to hear more about smooth scrolling and general tips about canvas performance if you have some good links/books you can send along. Thanks again
This is really well done... Particularly that demo! Awesome 
I don't have any good links or books for canvas performance or smooth scrolling, though I can pass along the less-than-perfect example project I mentioned earlier. He was also new to JS, and working on the project with his 6-year-old daughter. It does run acceptably well, and smooth scrolling is pretty simple. (Don't take it too seriously. There's only about 8 hours of effort put in to the thing, with some nasty short-cuts taken. Ignore the following, at a glance: 1) timer in utils. Don't do that. It's beyond lazy, and there are much better methods to achieve the same thing. The single-timer thing works well for games, but this one is seriously ugly. 2) setup_display. it's completely unnecessary. Can easily be handled with CSS. 3) level loading code. it's so he can drop-in the things his kid makes quickly. 4) resource loading, because it doesn't. It's on the 'Gee, I sure hope it's loaded' system. 5) animations that call timer, because it's ridiculous to add that dependency when it can be trivially avoided. 6) probably some other stuff.) http://www.recompile.org/josh
Sixty percent of the time, it works every time!
&gt; Type coercion in general is undesirable. Then why use JavaScript? (Though languages lacking implicit type conversion are vanishingly rare. If you say "what about C" you'd be wrong! C does implicit type coersion as well.) &gt;No, it's not. In most languages, == and != do not coerce types. But they do! Implicit conversions aren't even exclusive to dynamically typed languages, but exist in statically typed languages as well. If you think == in JS is complex, take a look at the rules for C++ some time!
interesting
&gt; Then why use JavaScript? The question is: "Then why use coercing equality/inequality operators?" Well, I don't. I use === and !== in JavaScript. I also prefer Dart which doesn't do any of that nonsense in first place. &gt; But they do! No, `5 == "5"` is generally false. Try it in Python, Java, C#, Dart, Lua, or whatever. Note that PHP is [exceptionally silly](http://www.reddit.com/r/lolphp/comments/2tpxc9/if_6_chickens_4_geese_10_birds/). &gt; If you think == in JS is complex Actually, I think that it's just stupid.
I wouldn't say "even generators". Generators are by far the most complex feature of ES6.
Or that they want static typing. As long as the language doesn't support type syntax there will be languages that transpile to it.
&gt;You don't seem to have a problem with implicit conversions in other languages. Do you have any examples? Do you mean things like int + long = long or int \* double = double? Type promotion isn't a problem. It works just as one would expect. 5 \* 0.5 is 2.5. Your IDE/compiler also keeps track of that. It will tell you if you try to pass a double to a function which expects an int. You'll have to truncate or round/ceil/floor it. &gt;Why not be a bit more honest, and be specific about what implicit type conversions you find offensive? Honest? Offensive? Why would anyone be dishonest about any of this? Why would anyone be offended by any of this? Whatever. This is how equality/inequality usually works: http://www.lua.org/pil/3.2.html "The operator == tests for equality; the operator ~= is the negation of equality. We can apply both operators to any two values. If the values have different types, Lua considers them different values. Otherwise, Lua compares them according to their types." Things like `5 * 'asdf'` are usually a type error. In JavaScript, == and != coerces the types. Arithmetic and bitwise operators coerce, too. That's just silly. 5 is not "5". 5 \* 'foo' doesn't make any sense. It's clearly an error.
This just means that I will be rendering 7 blocks in each direction around the player position instead of having the entire overworld rendered at all times 
I'm using Babel on a project both for the server and client and like it a lot. I use ESLint which supports ES6 and JSX. One thing to look out for is that some features generates slower code. A let binding in a for loop creates and invokes a function inside the loop for example. And for-of loops should be avoided for iterating (large) arrays as the generated code creates a real iterator instead of a for-loop.
They removed the "Tasks by Telerik" app from the playstore. No surprise there. That app was a joke.
I've been using TypeScript (transpiled to CommonJS; ECMA5) for 3 months and bundling with Webpack. TypeScript also has AMD support, so the bundling is fairly optional. In my opinion, TypeScript has a larger community than Traceur or Babel and it's been around for quite a while. It was not easy at first. I have found that [this project](https://github.com/Bartvds/pixelbutler-starter) is a great starting place to getting the basics down. These npm modules will assist you (if you use grunt): * [grunt-ts](https://www.npmjs.com/package/grunt-ts) - uses TypeScript 1.3 still, but you can install 1.4.1 and point it at that * [grunt-tslint](https://www.npmjs.com/package/grunt-tslint) * [webpack](https://www.npmjs.com/package/webpack) * [source-map-loader](https://www.npmjs.com/package/source-map-loader) - preserves TypeScript source maps (couldn't get this to work with Browserify) * [html-loader](https://www.npmjs.com/package/html-loader) - for templating If you plan to use third party libraries in your code: * [tsd](https://www.npmjs.com/package/tsd) - A typescript definition manager, [all available definitions here](https://github.com/borisyankov/DefinitelyTyped). Webpack can do a lot more than loading JS, but I find it a bit unconventional. I only use it to concat/minify the output JS and HTML partials. As an aside, my code is 5x cleaner, and the source is at least 2x shorter; although that may be attributed to a rewrite of a project and removed some unnecessary code as well. It really is just ES6 with types, and soon to be annotations. I use IntelliJ IDEA and the editor support is phenomenal. Editor support: * IntelliJ and VisualStudio both have built in support. * Atom - https://atom.io/packages/atom-typescript * Sublime - https://github.com/Railk/T3S
I am using ES6 in production for our entire stack. The main advantage for us, is that our code is forward compatible, and will require minimal changes when native ES6 is available. My suggestion is to practice via implementing a project in a test-driven fashion. I use Mocha + Chai + Sinon. There will be just a few gotchas such as "how do I do private properties?" which the tests will help you to verify. The second suggestion is to handle transpiling via gulp.
Sort of. You're right that current stable (1.4) does have poor support for es6, but the 1.5 beta covers 95% of es6 and because it's not running on a production server it shouldn't be a big problem.
The site strangely enough, is kind of broke on mobile. Really great work though, I love easing as well as visualizations and this will come in hand for future projects!
SystemJS is a great alternative to Webpack since it doesn't require a bundling stage during dev. It's also based on the actual ES6 module loader spec. Even more relevant to OP is that it can handle ES6 code automatically using either Traceur or Babel. TypeScript works with it perfectly too. Just tell it to output CommonJS and it loads everything perfectly. It can even work with AMD, CommonJS, and ES6 module formats at the same time.
If you wanted to create a variable for each for loop iteration, you would have to write the same code. Right?
This is very interesting. Basically it's a library that allows you to easily utilize web workers for multi-threading tasks. Curious to see some benchmarks on how much this can improve performance of cpu-heavy tasks.
It's the combination of features that make it amazing. With the types and new syntax TypeScript code is so much more maintainable then our old vanilla JS. A niceside effect is how clean and readable code becomes. Less funkyness in local code and less guessing of what is passed around between modules.
Thank you for your interest, the web site which will be online soon will include detailed documentation and a jsfiddle like playground &amp; demo area so you can easily compare different task. If you want to get started now take a look at the debug section of the github readme, that should tell you what you need to get started with some local performance comparisons. In my testing the speed ups were pretty impressive, my test case was limited by how big of a random array i could generate which was 45million numbers. I did a ton of testing splitting that data across as little as 4 and as much as 500 threads, absolutely pegging my i7 @ over 700% utilization in chrome.
At the moment I'm not doing anything too cpu-heavy in my app, I'm interested in what the overhead tradeoff is and what kind of "real-life" tasks this solution starts to be beneficial for. Possibly this could be very good for web game developers.
I think web games would be a very good use case, in fact web games are the reason i implemented a working thread pool, most other use cases dont require one but with the pool you can ask the library to do as many things as you can think of at once and it will pre process them into individual threads and then execute them when a thread is ready. The trade off is why i recommend in the readme researching amdhals law, i took special effort to minimize the libraries resource usage and only keep data in memory at the time its needed. Real world use cases are pretty much any data heavy operation that can be broken into smaller parts efficiently. Physics, graphical rendering etc could potentially see massive speed ups as those task are normally easy to make parallel. 
Using ES5, yes. But when we have native browser support for ES6, they won't implement it this way.
Someone knows why [] == false and if ([]) evaluates to true?
It is good to actually profile these things when uncertain though. Modern JS engines like V8 will do all kinds of optimizations like function inlining, etc so it can be hard to know at times what will actually slow things down.
Exactly - when making perf-based decisions or code changes, don't rely on intuition, always profile. The percentage of time your intuition will be wrong will surprise you. :)
Thank you for using it!
One interesting way to get some exposure to ES6 is to mess with http://aurelia.io/ That is Rob Eisenberg's new framework (he was joined up with Angular 2.0 for a while but split back off). The framework itself is written in ES6 using the modules and runs on top of jspm, gulp, babel, etc. The sample project has everything set up already to use as a base for your own things.
Typically you are going to load your app server side, and then put your data into a script tag, then when you init on the client side, grab that data and initialize your app with it. I have a McFly-less tutorial on this I wrote here: https://scotch.io/tutorials/build-a-real-time-twitter-stream-with-node-and-react-js A Mcfly example can be seen here: https://github.com/kenwheeler/react-postocracy I dont think flux is overkill for small projects at all, unless its like a single component. Re: sockets, you can either listen to the socket and then call an action when data comes in to load data into your store, or have your socket emit a simple "changed" notification, at which point you fetch your new data from the server.
Either way, I think you will end up learning both.
Wow, the source is actually way simpler than I imagined. I'm amazed that no one had written this already.
This isn't python 2-3 type situation. There are practically no breaking changes. ES6 features aren't available everywhere right now, so you have to be mindful of that when using ES6 features. But other than that they are the same language with more standard features sprinkled in. 
Ugh, drop the isomorphic buzzword already. It's tacky. A lot of us have been writing apps that run on the server and client for years now.
Yes, if you need it for something like an event handler you would have to create a scope with a function. But if you're just iterating an array of numbers that you're doing arithmetic with, you wouldn't need the block scope and the extra function would just be an overhead. 
I don't like transpilation's effects on my dev workflow, but I've been using the `--harmony` flags in node/iojs. These flags work for Chrome too. For deployment of browser code you can just treat transpilation as an additional step like minification. Overall, this workflow is roughly as lightweight and streamlined as ES5.
Learn it all, but pay attention to which bits are es6-only, because that will be useful to know for a while yet.
no, don't skip ES5. you cannot effectively write Javascript applications without eventually using library code to help you out, and the vast majority of JS libraries will be in ES5 and probably never be ported to ES6, or will be ported only very slowly. You need to understand the syntax and constructs of ES5. all of that is still in ES6, by the way. its not like you're going to be learning something that is instantly obsolete.
I think so, I believe it pulls the modules down using XHR, so it should get some caching there. That's only dev time though, you can still bundle everything together with the SystemJS Builder but I've not really used that very much. Interestingly, the Angular 2 docs recommend SystemJS as a module loader but I agree it doesn't necessarily make as much sense with 1.x.
If you're lucky enough to be running io.js on the server, one relatively non-insane strategy might be to: 1. Run io.js with no es6 flags and no server-side babel-ifying; just stick with [what io.js supports by default](https://iojs.org/en/es6.html) (which is basically the most stable and well-baked parts of es6 supported by v8). 2. In your client-side code use babel, but limit yourself to that same subset of es6 supported by io.js on your server side (babel can be configured to enforce this). 3. As more es6 features move out from behind runtime flags on io.js (which means v8 has good, stable support for them) update your babel config and start using them everywhere.
Nice to see framework authors all learning from each other. Friendly competition leads to innovations like these.
[Underscore templates!](https://twitter.com/jashkenas/status/572890621062606848) EDIT: Missed the /s tag. I don't actually believe Underscore templates are a suitable competitor to React, whatever it is Ember is up to, or even Handlebars. While I use Backbone and Underscore every day, to me Ashkenas comes off as inflexible and combative in a lot of his public interactions. This one, in particular, I found just silly.
I love the extra perf they can squeak out of templates, compared to using functions in React. Although the diff isn't the bottleneck so it's probably not too significant. But no complaints here; this is some really awesome work!
[**@jashkenas**](https://twitter.com/jashkenas/) &gt; [2015-03-03 22:45 UTC](https://twitter.com/jashkenas/status/572890621062606848) &gt; Unsurprisingly, a simple Underscore.js template ‚Äî 2009 technology ‚Äî beats the pants off Ember‚Äôs new Glimmer ‚ÄúEngine‚Äù. &gt; http://jashkenas.github.io/dbmonster/ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
There's also an extra `(` bracket in the `console.log`
Do you think web browesers will learn from this and these frame works will not be usefull?
Ah great advice thanks! So the overworld is actually just one image and I do a ctx.drawImage on that specifying specific 16x16 areas I want to render. Does that make a difference?
What doe you think of inline CSS stylesheets if may ask? https://github.com/rickwong/react-inline-css 
Fucking finally. I've hit this problem with rendering long lists of items. The client didn't have the budget to rewrite everything in Angular, and React didn't exist back then. We ended up with a slow app, well, one of the screens in the app was slow.
Which one has the best build tools and community?
How is this not the top comment? Its the only one that actually lists a tool to enforce style. Just pick a preset that is close to what you want, and update from there https://github.com/jscs-dev/node-jscs/tree/master/presets 
Don't know how experienced you are with Ember, but it may help to wrap your updates in an Ember.run, so it doesn't try to update the DOM a million times. http://emberjs.com/guides/understanding-ember/run-loop/
&gt; it can detect moved or renamed elements in addition of deleted and inserted elements. This is good stuff. Edit: Actually tried it out now, it's better than I expected, I thought it would literally show differences between AST's. However, it just looks for differences between AST's and then highlights these differences in your source code. Neat stuff.
It depends on the kind of performance you're after. Rendering chucks is great for performance if you have to render multiple layers. Rendering one tile at a time is great if you have the cpu to spare. For example, using the method you have right now you're doing 13x13 tiles? If you want some leeway for smooth scrolling you have to extend it to 15x15 which is 225 tiles per tick, and then if you want more layers, that's 225 tiles per layer per tick. It's not a very efficient method. Instead if you prerender the map, you are just rendering chunks using a srcx and srcy and dimensions equal to your game window, which is tons faster. The only downside is the size in the browser's cache. For example, a 100x100 tile map with 16x16 pixel tiles using 32-bit colors is around 10 MB, and might have a few seconds "loading" time. But to me, performance is everything, so I always use chunked rendering. If you need animated tiles, however, you often have to resort to drawing tile by tile, but there are some tricks to do sfx like water using the canvas's putImageData() function. Another benefit of chunked drawing is it makes it really easy to do neat mode7 effects for that old-school rpg overworld look.
&gt; it doesn't require a bundling stage during dev On the other hand, Webpack supports hot code replacement, which helps quite a bit with responsiveness when your build times &lt; browser reload.
Well duh, but for developer sanity you don't want to have to write that all explicitly for every bit of functionality... 
Thank you! Got it.
jQuery
Thank you!
I have a problem with being vague. I meant this whole caching Dom changes and only doing a redraw once. It seems like this would be balest and then there would be no need for a virtual dom
Ember has support for ES6 modules when using Ember CLI: http://www.ember-cli.com/ - it's great for making client-side Web apps.
In case you didn't know, you can use the standalone Dart VM like Node. It comes with libraries for doing I/O. Also, Dart supports operator overloading which makes working with SIMD code a lot nicer. JS: var a = SIMD.float32x4(1.0, 2.0, 3.0, 4.0); var b = SIMD.float32x4(5.0, 6.0, 7.0, 8.0); var c = SIMD.float32x4.add(a, b); Dart: var a = new Float32x4(1.0, 2.0, 3.0, 4.0); var b = new Float32x4(5.0, 6.0, 7.0, 8.0); var c = a + b; JS: function simdAverage(list) { var n = list.length; var sum = SIMD.float32x4.splat(0.0); for (var i = 0; i &lt; n; i++) { sum = SIMD.float32x4.add(sum, list.getAt(i)); } var total = sum.x + sum.y + sum.z + sum.w; return total / (n * 4); } Fully typed Dart: double simdAverage(Float32x4List list) { var n = list.length; var sum = new Float32x4.zero(); for (var i = 0; i &lt; n; i++) { sum += list[i]; } var total = sum.x + sum.y + sum.z + sum.w; return total / (n * 4); } ES7 will most likely support SIMD and probably user-defined operators, too. Anyhow, if you want to modify V8 itself, you'll have to use C++ and you have to be pretty damn good at it, too.
You're saying the teams behind Angular and React are unwilling to learn from others?
React still has the bonus of giving you the full power of javascript in your views. No BS templating syntax or directives to learn and be limited by.
ARM (NEON) only does 128 bit SIMD. 256 bit means AVX, as far as I know, which is currently rather poorly supported since it's relatively new (2011). See slide 217: https://deplinenoise.files.wordpress.com/2015/03/gdc2015_afredriksson_simd.pdf Also take a look at #221.
Yes, but I'm already using it and know it well. I don't exactly have a choice about using JavaScript or not based on my web related work.
Dart does look reasonably nice. Thanks for that sample. At the moment I'm unsure about the abstractions used and what performance overhead there would be. Also, I'd like the wider SIMD as available on Haswell.
&gt; unnecessary steps That's where the intrinsic stuff comes into play. When I write "new Float32x4", it doesn't actually create an object and when I write "a+b" it doesn't actually call that method. Instead, the compiler directly generates the native code to do these things via SIMD instructions. Something like the ASM on the right on slide #19: https://deplinenoise.files.wordpress.com/2015/03/gdc2015_afredriksson_simd.pdf
https://www.dartlang.org/articles/numeric-computation/ https://www.dartlang.org/articles/simd/ (also check the SIMD talk at the bottom)
In my opinions they should support wider SIMD lanes.
Right, you do want your logic intertwined with your markup to some extent so that it's clear what's going on. React does this, it merges HTML into your JS. So you're using JS to control the logic of your view and not some proprietary, limited, middle man syntax.
Setting a single event will be faster than setting multiple events, regardless of which DOM nodes. This has absolutely no bearing on the execution speed of the event handlers though.
I want very little out of handlebars, but I want to be able to do {{1 + 1}} or {{#if (condition1 &amp;&amp; condition2) || condition3}} Completely logicless templating is such a reactionary take on the problem of amateur developers clogging up their templates with business logic.
I think you're on to something here, but I'm not sure if I'd use a whennable over a promise. If I'm understanding whennables properly, it seems more like a specialized event emitter / observable than a promise. I can't see myself swapping out promises for whennables, but I might be able to swap out some observables for whennables. Your example of the DOM loaded event is perfect for whennables, but aside from that I can't think of another use case. Any other examples of real world scenarios where a whennable would be preferred over a promise or observable?
Why not use https://url.spec.whatwg.org ?
&gt; Your backend and frontend should be separate. I totally and completely agree. Hence my not being on the "*JS all the things!*" bandwagon just quite yet. All that said, I get the impression that Ember is mostly client-side rendering? Is that correct?
Sorry, I wasnt specific enough. Almost all of the big JS frameworks (Ember included) are client-side. Ember has fastboot to render it server-side, but it is not a server-side app if that makes sense. Ember still typically needs to consume an API. Whatever you want to make your API in is fine, the language doesn't matter to your front end.
https://egghead.io/
Just check how long the string is and add the right amount of zeros on the left. function pad3(n) { var s = n.toString(); return '000'.slice(s.length) + s; } You can of course also use a loop for this.
That sounds about right... I see Angular as becoming the next YUI, Ember the new Prototype, and React becomes the new jQuery. React isn't the most performant of the bunch, but it wins with jsx, which is instantly familiar to anyone who knows html &amp; js, similar to the advantage sizzle selectors give jQuery. 
https://www.npmjs.com/package/in-words 
React's API is probably 1/10 the size of jQuery. I use up to 30 npm libraries in my front end apps sometimes, and I don't think I've ever come close to reaching the API / documentation complexity of jQuery. (I typically use libraries with 1-3 methods).
I'm impressed. Take an approach that's objectively better, and incorporate it into an existing framework without breaking changes? That's impressive, loads of respect for these guys, even though I've never used ember, i'll consider it for future projects.
That was sarcasm. jQuery doesnt even have a render engine. 
I think we're both off topic, I didn't even realize we were talking about a render engine :P
I found this book to be one of the best resources: https://leanpub.com/marionette-gentle-introduction There's a free sample you can download, you'll probably learn a lot just from that, and then decide if you want to buy the whole thing.
I just completed the Code School lessons and they're a great intro - and free thanks to a Google sponsorship. https://www.codeschool.com/courses/shaping-up-with-angular-js
Also, you can save memory by using only one event. This is especially useful in older browsers (IE, here's looking at you, punk).
Pretty sure it's a fundamental skill for virtually every job in the world. Because, you know, that's how we teach new people and stuff.
So when will Ember Native come out to combat React Native?
Cool! what do you use to parse the code? Esprima?
or just `this.dataset.url` in modern browsers (or if using jQuery/IE shim). no need for `getAttribute`
TypeScript isn't exactly new, though Google contributing to it is.
This only makes sense when the condition makes sense as a computed property. for example, {{#if userIsAmerican &amp;&amp; userIsAdmin || userIsSuperAdmin}} //link that is only relevant to american admins {{/if}} this makes much more sense than having a isSuperAdminOrAmericanAdmin property. 
roll your own easily enough 
Awesome! JavaScript needed a framework.
Good article. However, correct me if I'm wrong, but the provided FizzBuzz implementation appears to be incorrect. On multiples of 15, the provided solution would print "FizzBuzz Fizz Buzz". EDIT: the author fixed it after I posted. The original example had no elses or else ifs.
No, it would print FizzBuzz only and then it would cycle to the next for loop. For example if i = 15, it checks the first condition i % 15 (true) and prints FizzBuzz. It's not going to enter inside the other if conditions because it already entered in the first one. EDIT: so the author changed the code, it was wrong when he posted the comment and it was right when I posted mine.. got mixed up, no need for downvotes
Indeed. Looks like the author fixed it. It originally used ifs exclusively.
It was changed
Am I missing something? The .call and .apply examples both show .call method.
&gt; Until ES6 is better supported, we're stuck with call, apply and bind. I don't see why ES6 is a factor in that discussion. I have seen several posts comments in this sub-reddit that make it sound like developers need ES6 right now just to write code, as though they cannot possibly write JavaScript without something like Babel.js. I am curious where this line of thinking comes from. Maybe those people are all incredibly new to JavaScript or maybe they have never learned to build large applications in this language without it looking like Java. I would like to learn more about why people are forming such conclusions.
Works fine, however FF 36/Win7 keeps on throwing "TypeError: onFinish is not a function" on every mouse release.
Upvoted, because I think this language looks really clean. I can understand why this is being downvoted though. White space as syntax is an amazing convenience, hence why Jade is so popular, but there are some costs: * White space is easily corrupted during transport. The protocol of the web is HTTP (and HTTPS), but code goes through all kinds of more channels: git, svn, email, various web tools, preprocessors, and so forth. Many developers have a huge insecurity when it comes to code that is less portable. * White space is a bastion of holy war arguments when it comes to code style. The only correct answer to holy wars is to defeat the validity of any argument by removing it from a topic of consideration. To solve this particular holy war languages must be designed to not use white space characters as any kind of syntax and allow users to style the code however they want. Vanilla JavaScript fails at this since white space characters are needed to separate word tokens and ASI makes the language less predictable with regard to white space.
Fat arrow functions lexically bind _this_ value, so it is more predictable for people coming from other languages. When you have window as a this value it doesn't help anyone, it's clearly not intended, and depending in the caller of the function to call it correctly is **risky**
I completely agree, which is more reason to avoid to my above mentioned list. I can understand why that would make ES6 more desirable, but not why so many developers on here sound as if they cannot live without it. How can people not live without it if these features are less than a year old in the browser and ES6 is not even finished yet? 
I think he is missing something.
"*Because Node.js is Javascript at its core, the learning curve is non-existent if you already* **no** *a little bit of Javascript.*"
LOL, actually, I think it was me that wasn't clear. I think the key word that I left out was "templating." I know that Backbone, Swig and frameworks like that can do server-side templating, basically serving up mostly complete HTML, similar to what PHP, Ruby, et. al. are able to do. I'm still in the camp that thinks that server-side templating with client-side enhancement (via JS) is a *much* betterconfiguration than rendering templates completely in the browser. To that end, and my apologies for the confusion, I'm guessing Ember is frontend templating, but that Fastboot *might* be a server-side templating solution? *edit:* left out a word
I also agree js devs shlould learn js. 
Just use babel and start with es6. not really a big deal.
TLDR: All JS dev's should read one of the great introductory books on JavaScript.
i'll +1 this and also say that the next book takes it even further... https://leanpub.com/marionette-serious-progression
&gt;Could you explain further in what ways bind/call/apply can affect performance? Not quite sure I can explain the whys, but I can certainly show you the benchmarks with various ways of calling things: http://jsperf.com/javascript-bind-vs-function Of interest to you is the poor performance of the very first test.
Also pass by reference/value, dot-notation/bracket-notation, closures and how to defend yourself against programming bullies.
Neat. Don't forget, git has alias support which is another viable option for these sort of features: http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/ I tend to float around github and read others git configs to improve my tools as I go.
Thanks for this. All the more reason to avoid bind.
Oh, I can name you a few times it's worth using bind. Currying, for instance. But you should avoid bind unless you need it. Simply using it to permanently set scope is not a good usage; use an anonymous call (apparently not apply!!) for that. It is strange that apply is slow; I would think that would be optimized better than call.
I couldn't resolve myself to add the ¬¥:¬¥ as it is completely unnecessary in the grammar. I also forget it from time to time in Python and I always wonder why it has to be there and if really it make the language easier to read. My conclusion that with good syntactic coloration it doesn't at all.
Here's an example of how you would use its "vanilla"/non-React API: http://requirebin.com/?gist=f4fb7470d0ac865a5988
Cool. This talks about some useful dev tools functionality also. Specifically console functions beyond log and error. Such as "copy". 
Very interesting. I've heard people not use `new` and `Object.create` and I've heard Crockford said he doesn't use `this` anymore (which I am a bit confused about since I am a novice still, so maybe you can explain?), but never heard of anyone that does not use `bind`, `call`, and `apply`.
It completely agree it is definitely worth using bind to ensure that *this* is commonly understood and doesn't get lost. If you don't use *this*, though, you don't need bind.
User the event handler's parameter to get the element. function swapvideosource(event) { var ele = event.target; //the "youtube-selector" element object var dataAttr = ele.attributes["data"]; //the "data" attribute object if (dataAttr) { var dataValue = dataAttr.value; //the attribute value console.log(dataValue); //"www.youtube.com/blahblah" } //else: attribute not found. i.e. null } var youtube_sel = document.getElementById("youtube-selector"); youtube_sel.addEventListener("click", swapvideosource); PS) You can't use dash character for a variable or function name, but you can use it as a property name.
Thanks, I appreciate it. :)
you should check out the setTimeout function. You could do something like: setTimeout(hideOverlay, 5000); function hideOverlay() { $('.my-overlay').hide(); } Darkening the page could be done by having an overlay div that's 100% height and width, position fixed and top:0 left:0. The background for the overlay would be a transparent black. Inside that overlay you would have the pop-up itself.
I agree, I wish that in my country (Venezuela) had this kind of competition, everything here is a monopoly with no intention to growth :(
But all of them pretty much do the same.
I too think JavaScript developers should know JavaScript... /s
Er, currying. Doesn't necessarily require use of _this_, but used to bind a parameter value to a function. See http://kishorelive.com/2012/02/06/currying-in-javascript-using-bind/
Yep I got it done and it works great; just doesn't look as good as I thought it would :/ thanks :)
&gt;As a rule of thumb: ALWAYS define your variables at the top of your desired scope. If you are using ‚Äòuse strict‚Äô; at the top of your script files (or within your functions), an error will be thrown if you try using a variable before it has been defined. &gt;Most Javascript linters like Jshint will complain if you haven‚Äôt defined ‚Äòuse strict‚Äô anyway, so provided you‚Äôre applying best practices it should be impossible to use variables before they are defined. Everything after the first sentence describes why the first sentence is wrong...
In the case of `call`/`apply`: They are the only way to "simulate" argument forwarding in ES5. For example the following ES6 code: function traceAndCall(fn, ...args) { console.log("Called function"); fn(...args); } To write something similar in ES5 you need apply. Or in other words: &gt; Until ES6 is better supported, we're stuck with call, apply and bind.
I call this piece "Super Mario Paint!" http://imgur.com/j7VFaIA
&gt; You are being silly Not quite sure how this fits into the general idea of civilized discussion about a technical subject. &gt; You don't need to specify arguments or an explicit return value to achieve functional programming Perhaps I was being too abstract, I will try a concrete question. How do I write a partial left application or partial right application function in ES-5 without `arguments` or `.apply`?
Is anybody else a little disappointed by Object.observe? It seems like a hack to me.
Okay, thank you! I will keep this in mind!
Yeah, but really? If I'm to hire a dev I expect them to know how to use relevant dev tools. X devs should have knowledge about X's dev tools.
Hi /u/ArtBIT, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt; I'm still in the camp that thinks that server-side templating with client-side enhancement (via JS) is a much betterconfiguration than rendering templates completely in the browser For websites, I agree. For webapps I don't see a benefit. Using PhantomJS you can do any frontend templating on the server. Ember has their own implementation but it is basically the same thing.
Thanks. I was trying to jump ahead and print before I was supposed to. Still don't understand why it printed twice, though.
&gt; Call, apply, and bind are all new with ES5. No. http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf Sections 15.3.4.3 and 15.3.4.4
Let me put it like that: Do you abstract every condition you have in your JavaScript code do it's own method? The answer is always no. So why is it expected of us to abstract all of our handlebars conditions to their own JS methods? 
I don't know why you got downvoted. Condition1 and condition3 are not even conditions. Condition1 is 'do this piece of code on begin', and condition3 is 'do this piece of code every iteration given condition2 is true'. Only condition2 is a condition.
It is generally considered bad form to pass arguments of **unknown** type or quantity into a function. This makes the reference invocation (function arguments are reference declarations) challenging to predict, which interferes with compilation in the JIT. I am sure this may be of great convenience to your code, but I would recommend against it.
I guess so, but I just never saw anybody use these before ES5.
I don't know what a partial function is, but it sounds like something I would never do.
Uhh either way, if these frameworks are fulfilling the same task in a different way, they ARE competing for users whether you like it or not. But the question I want answered is "How will Ember become platform-independent (at least mostly) like React Native promises?" That makes React the better choice over Ember, imho. 
I also try not to depend on jQuery when things can be done using native JavaScript. What I was trying to say is jQuery uses the above APIs so much that they will be used anyways if someone decides to use jQuery.
Can you give me a list of the great introductory books on Javascript? Genuine question.
Code academy can be really strict and sort of janky sometimes. Looks like they want you to return, not console log. The actual function has nothing wrong with it. 
In that case, you have convinced me that you do not need `arguments` or `.apply` in ES-5.
The good takeaways are: 1) Your browser has an element selector engine built in 2) JS has a few different types of loops 3) There is more than console.log() available to you 4) Use strict, and what it does 5) Call and apply, use them 
eh sounds like an idea
Yep, that's what I was pointing out.
I'm not a fan of replacing Coffeescript's arrow functions with a "def" keyword, though I noticed that def creates a hoisted function, which is interesting. The scoping fix with the := operator is nice, because Coffeescript makes you write it in Javascript, but I remember the lack of if-scoping just fine when coding. And what complex operations should I be excited to have programmatic access to the virtual DOM? Shouldn't React just take care of that for me? Overall, I will have to say that I'll be sticking with Coffeescript, but I'm very excited to see people working on alternatives!
&gt; http://i.imgur.com/XvJyAi7.jpg Both of those sound like things you would do inside of a react component?
All I want at this point is ES6 to actually be supported.
I liked "Javascript, the good parts" by D. Crockford (a good starting point, though not the easiest read), "Eloquent Javascript" by M. Harverbeke (it has nice practical examples) and "Learning JavaScript Design Patterns" by A. Osmani (more advanced since it's specifically about patterns, read this one after the other 2).
&gt; Also you say "allow users to style the code however they want". What if writing significant whitespace is the way they want to write things? What if having good boundaries is how they want to write their code within a team? Coding holy wars. It's why I wish there was a language that saved the source to a compact form with no syntactic sugar except that added by the development environment (per developer settings...) Unfortunately, this would mean the source code is all but worthless to someone without a said coding environment. Most coding holy wars are meaningless in the grand scale of things, but when you take my code with tab indentation and drop the code into someone who prefers spaces and the code now breaks. That's a problem IMO. It's not my problem, because the code works in my environment. It's not your problem because you have a preferred method. It's a significant whitespace problem. So one person has to compromise their principles in order to work with you? &gt; I believe having a opinionated way on how the code should be structured ingrained within the language is a benediction not a curse. And I believe it's a curse. I like programming in Lisp, but I HATE the indentation practices that are "standard". I don't read the code that way and it leaves potentially tens of parenthesis trailing off into nothingness at the end. It's the same with Python standards. If you didn't rely on whitespace to make your code work, it wouldn't be a problem.
For def vs -&gt; it is a matter of opinion... Def is short enough and is used both in Python and Ruby which are the inspiration for the language. I am not sure where the thin arrow syntax comes from. Maybe you have an idea? For the if scoping I am not sure what you mean. I think both languages behave exactly the same. The problem with CS is better explained here https://donatstudios.com/CoffeeScript-Madness For the Virtual DOM the idea is that if you have to go trough a compiler for JSX, why not using an unified, improved language? You don't have JavaScript + JSX, you just have CokeScript and any feature added to CokeScript are directly available for HTML generation. Thanks for you support but yeah you should stick to CoffeeScript as this language is not ready for prime time. Almost nothing has been written in it yet.
Or my favorite. When I was sitting in a Microsoft conference in 2005 and they were pitching how .NET would allow managers to build flowcharts to make programs while programmers would make little black box pluggable nodes for them to drag and drop.
Just read the docs. https://developer.chrome.com/devtools/docs/console-api https://developer.chrome.com/devtools/docs/commandline-api https://getfirebug.com/wiki/index.php/Console_API https://getfirebug.com/wiki/index.php/Command_Line_API
Thanks for the info! My idea is for my Tessel to ping a remote API, do a little text-to-speech, and have a button to ping on demand. Nothing too crazy. It sounds like I could probably accomplish this with a RPI too, and that may save me some cash.
Maybe, but that only matters for new projects which is a tiny percentage of the work available. Legacy applications require knowing them all, to some degree.
(bad; maybeOk; allgoodNow)
 but when you take my code with tab indentation and drop the code into someone who prefers spaces and the code now breaks This problem you describe is due to allowing several type of "whitespaces" to mean the same thing. Which could be avoided by allowing only normal spaces for indentation. I was thinking to fix that in CokeScript to 2 spaces. Also is that really a realistic scenario to copy paste some code from project A into some files in project B without some major refactoring? You either use the source code as is or as a library. I have an hard time to understand your argument in your last paragraph about Python coding standards (which is basically: use space, not tabs). Maybe you would give me an example how you would write some Python code in your own style? With brackets? I do not know.
Eloquent JavaScript. I'm reading it now, it's really well written, gives a lot of practical examples, and goes beyond JavaScript and into the programming and browser side. It's free to read online at eloquentjavascript.net, the website also contains environments to practice. 
If I have a condition that is that complicated and I use it in more than one place, I certainly would abstract it to a method...
Is it really? You have a click event on a button. If you are able to click that button a thousand times a second, I might see a reason to care about a few clock ticks of performance, but for the use case bind provides an easy readable way to implement event binding.
I use tabs. And yes, for the most part you'd use a library or an API to communicate between various bits of your codebase. But for someone coming into development, copying code from stackoverflow or some other source would include indentation that is not compatible.
***what?***
&gt; and I use it in more than one place Of course, but no one promised that. It might just be an extremely specific condition you will only use in one small place, and still you'd have to pollute your model with isCondition: function () { .. }.property("dependency") You can't even do simple comparisons. {{#if x == y }} has to be written as {{# if x.isY}} isY: function () { }.property() I'ts ridiculous! You can not make developers abstract every single condition to a model method, it doesn't really make you stop repeating your self, and abstracting conditions to a method that performs nothing but that condition is pointless, counter productive and ugly. 
Effective Javascript - I'm prepping for job interviews and this book has helped out a ton.
I see. But if you copy space indented code from the internet into your tab indented code base wouldn't you have to convert it anyway or you do mix them? If you answer yes then your argument doesn't stand as you would do the exact same thing in Python. If you answer no then I would hope I will never work on any code written by you.
&gt; I disagree about call and apply though. I prefer to never use: new How do you create a XMLHttpRequest object , an XMLSerializer or a FileReader in the browser without using new? Oh wait, you CANT.People shouldn't listen whatever you have to say,because it's obvious bullshit.
It could probably be argued that knowing a language has little to do with how well you know its associated libraries and frameworks.
Yes, it's wrong for that. You could abuse it to make it happen, but it's very much a RAD-based walled garden. Ember or Angular are both similar but with a less desktop-y toolkit. On mobile you can stretch a bit further. source: Spend most of my time in Ext 4 and 5.
Dojo has seemingly suffered quite a bit lately, even though they were pretty innovative several years ago (one of the first big libs to include modules, a module loader, plus a lot of other things). But, Dojo was traditionally a jQuery competitor, and with the current landscape of JS development, do-it-all libraries are being replaced more and more with purpose-built microlibs and frameworks. It appears as though [development on Dojo has been waning](https://github.com/dojo/dojo/graphs/contributors), almost to the point of non-existence, for awhile. And it appears that a Dojo2 is in the works, but [contributions there are also concerning](https://github.com/dojo/dojo2/graphs/contributors). Anyways, to your question: I assume you've exhausted [Dojo's documentation](http://dojotoolkit.org/documentation/)? It looks like they have quite a bit there. The only person I know that ever wrote about them with any frequency, /u/rmurphey, [hasn't blogged about Dojo in almost 4 years](http://rmurphey.com/blog/categories/dojo-/). There's nothing inherently wrong with Dojo, it's just that the current trajectory of web apps kind of excludes the type of library that Dojo is, and so you may want to reconsider your choice -- unless you have really good reasons to stick with it.
Pot calling kettle black...
I am waiting for the second part of "Every JavaScript developer should know 2 build tools, 3 async file loader, coffeescript/typescript/es6 to contribute to all broken libs you use, the front-end framework of the week, 3 different ways to define REST end-points and one of promises/async-await/genertors/fibers/callbacks style."
I think you should be clear about the objective. The original FizzBuzz question was designed to weed out people who were 100% bullshitting about the things on their resum√©. So the only point was to show that you could put together an `if`, a `for`, and get some output. It was just a filter at the start of an interview, nothing more. So literally, the shortest and fastest route from problem to correct output was the best program. Anything more complicated was fine, but if it took extra time to complete, it was taking tiem away from the proper interview. If you follow that theory, you don‚Äôt even want to discuss the code or try to pretend that it could or should be coded in any particular style. Of course, some people have different expectations. So I advise that if you‚Äôre asking this question, be clear about what you want. Don‚Äôt assume the person taking the test knows, you may just want working code quickly, they may try to do TDD to show off their process. And the obverse, if asked this question, ask what the interviewer wants to see. Don‚Äôt assume that all they want is working code, they may want to talk about testing or code style.
I'd consider a good solution one that realizes that any number divisible by 3 and 5 is also divisible by 15: for (var i = 0; i &lt;= 100; i++) { if (i % 15 === 0) { console.log('fizzbuzz') } else if (i % 5 === 0) { console.log('buzz') } else if (i % 3 === 0) { console.log('fizz') } else { console.log(i) } }
Thanks! So, your example would be used when, say, I want to pass an argument that is NOT related to the button. So the button calls some function, but say it needs to pull information from another div somewhere. Excellent!
&gt; Ember or Angular are both similar but with a less desktop-y toolkit. neither Angular nor Ember come with "widgets", they have nothing to do with ExtJS which is pretty much "widget oriented". 
&gt; I find the framework obtuse, obstructive to development and difficult to throw templates at (basically all the tasks I'm used to doing, don't work the same in this framework) Why would you want to use it then ? you know it's not adapted to what you intent to do. Do you need confirmation ? that's silly.
Parent is *technically* correct in that it saves a mod operation, *but* it also can save up to 2 comparisons (and associated jumps) as well, that's the real optimization. Using the other method requires ***exactly 3*** comparisons every loop, but the posters method requires ***at most 3***. This is also the definition of overthinking things. 
I'd consider a better solution one that realizes that you don't need to add in the 3rd if in there for fizzbuzz.
"Best". Heh. There really isn't much to improve over a simple loop with some ifs. What you can do is putting that piece of logic into a function. Not that it matters, but this way you won't have to do any string concatenation. Bonus points for always returning the same type. function fizzy(n) { if (n % 15 === 0) { return "FizzBuzz"; } if (n % 3 === 0) { return "Fizz"; } if (n % 5 === 0) { return "Buzz"; } return n.toString(); } for (let i = 1; i &lt;= 100; i++) { console.log(fizzy(i)); }
Cool. Then we are using the test for analysing different things. I think fizzbuzz is rather pointless. A solved problem usually gives the applicant a pass. For me fizzbuzz is about demonstrating the use of modulo operator. For others it may be about being smarter than the rest, or about coming up with the shortest solution, or about code style, or about string concatenation...
My attempt: for (let i = 1; i &lt;= 100; i += 1) { if (i % 3 === 0 &amp;&amp; i % 5 === 0) { console.log('FizzBuzz'); } else if (i % 3 === 0) { console.log('Fizz'); } else if (i % 5 === 0) { console.log('Buzz'); } else { console.log(i); } }
I never heard of it. Maybe because I am not from the US or because I never actually interviewed for a developer position, but I don't understand how this example can be challenging to someone who wants to work in this field.
Ext has a router, an EXTREMELY capable data layer, an eventing system, a controller, and yes, widgets. The others give up the widgets to be more webby. But to say Ext is widget oriented is not giving it nearly enough credit. I still think they're comparable. 
Ember team really cares about not breaking your app with future releases. Every feature is carefully thought out, hence why Ember 2.0 and other ember 1.0 add-ons/tooling will be officially out June 12.
Oh, I almost forgot. I don‚Äôt advocate it, but some people deliberately leave the ‚Äúdivisible by fifteen‚Äù thing out as a trap, the theory being that a good developer will identify the inconsistency.
Hi /u/wenhaokho, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `codelution.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [codelution.com](/search?q=%28and+site%3A%27codelution.com%27+author%3A%27wenhaokho%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|7|100% edit: You also copied, mostly word-for-word, the [Select2 github.io page](https://select2.github.io/). This is heavily frowned upon, please don't simply copy text from other areas of the web and then try to pass it off as your own. Your domain will be banned if it happens again.
My point is it doesn't matter what your freakin coding style is when confronted with APIs or libraries that will mandate a specific coding style. Instead of stupid answers like "I never use this or that, i'm a badass" , point the issues in using this or that feature in the language. The message served no purpose except obvious trolling.
Do you really need real time data or would it be enough that it just refreshed every 30 (or whatever) seconds? Also I would not suggest D3 unless you are really interested in expanding in that field. Something like flot ( http://www.flotcharts.org/ ) would most likely be enough. Or you could go with something that is based on d3 but has created some basic stuff for you like http://nvd3.org/ 
Interesting to see all the different results
No, legacy application require that you need to learn the platform which that legacy app is build on fast, is tiresome to learn all the wizz and wisel of boring JS frameworks.
Why are you being so daft? If the legacy application is built on Ember, it's probably useful to know ember. If the app is built on Angular 1, it's probably useful to know Angular 1. The point here is that knowing them all is what we, as developers, should strive for.
Oh, shush you. People don't need to know that as everything is frameworks and classical OO twisted to fit in the confines of the language (and therefore why "JavaScript sucks" is considered a valid opinion). Who needs to care how the language *actually* works?
Shorter: for(var i=0;i&lt;100;)console.log((++i%3?'':'Fizz')+(i%5?'':'Buzz')||i) By the way, you should have written "&lt;101" or "&lt;=100".
Not looked at the code for jQuery then? It's *everywhere*.
See, that's a problem. It's all very nice having these short forms, but readability for those used to a different language is not a valid reason for having them. Does Spanish add arbitrary constructs to make it easier for English speakers?
What is fucked up is having to write defensive code to cater for the dickheads who decide that a keyword in the language isn't worth bothering with when instantiating a **NEW** instance of something.
yes congrats on pointing out a typo
Mainly, I just wouldn't call a simple example on how to write a function a javascript pattern.
&gt; just some reimplementation of the MVC pattern And every language is just some re-implementation of machine code, so we should all start writing in machine code, right? Frameworks abstract stupid stuff that we don't want to do. Why is that bad? &gt; And to be honest, every other month the JS community get all wet for the next new shiny framework and forget about the previous like they change clothes. Ember has been around for how many years? Backbone? Angular? The community always gets excited about cool new ways to do things, but you talk like that's, again, a terrible thing. &gt; Did Angular Js care about backward compatibility when they re-wrote the entire code-base, architecture in a new language? Yes, which is why they have a migration path to 2. You should probably watch ng-conf. Or you can whine about the good old days when we could just jquerysoup entire applications.
You are confusing me with a junior dev.
Your assuming a lot of stuff with my little comments, I am you just replying your notion about learning all this boring piece of architecture for the sake of doing so instead when the time actually need it. If one is looking or must work with a Angular JS code-base then yeah they need to learn Angular JS for doing so and the same apply for all others. Why thinking for yourself is such a bad thing? Edit: After actually taking the time to read your comment more carefully. &gt; And every language is just some re-implementation of machine code, so we should all start writing in machine code, right? So you take my comment as some opposition to the MVC pattern, I never said that you shouldn't learn/use the pattern, I just state that you don't need a framework for implementing it, is just a patter, and a very well know one, JS frameworks have no exclusivity over it, I state that, yeah most framework are some reimplementation of that patterns which make them very easy to learn. &gt; Frameworks abstract stupid stuff that we don't want to do. Why is that bad? * What are this "stupid stuff" that you talking about? * Do you know the specific trivialities of my applications to make such assumption? * Will the framework magically swap away all the trivialities related to my domain specifics needs? Most frameworks today are build as an abstraction for the specifics needs of a specific type of application or some sort of monolithic behemoth intent to cover most needs of the masses, they introduce a lot of bloat while you end up using less than 10% of the whole features of the tool in 100% of the time, even your application is really big. &gt; Ember has been around for how many years? Backbone? Angular? The community always gets excited about cool new ways to do things, but you talk like that's, again, a terrible thing. My words above don't event touch the context that you are complaining about, which terrible thing again? Yes the JS community always get excited when "new things" comes along. Is always good to see how the community "growth", but I don't tend to choose my tools base on shallow trends, there always something new too learn but I don't gonna implement the things on my work just for the sake of it or unless the reality call for it. &gt; Yes, which is why they have a migration path to 2. You should probably watch ng-conf. Or you can whine about the good old days when we could just jquerysoup entire applications. The framework if too different and I don't think that big code base are going to "update"/re-write they whole business when they can go with more stable/reliable solutions. For the record: I'm not fond of jQuery. 
A Python 1 line comprehension. In long form: print(["FizzBuzz" if x%15 == 0 else "Fizz" if x%3 == 0 else "Buzz" if x % 5 == 0 else x for x in range(1,101)])
Well you could see if that container has an Id and then search for that Id in your JavaScript -- you might get lucky
which is what he was pointing out
it is argued by me, right now
ignorant.
I started to code in ext more or less with way I sort of expect it to work, which was NOT the way it works... so immediate road block. We use it in our administration tool, and they wish to use it else where - and not use any other tools. So I'm not the one interest in hammering in this screw. I was asked to. But I'm going to talk to them about alternative strategies. They are very gun shy about changing up anything.
Did anyone else *want* to vote for something but chose something else because they just "know it better" ?
For what Dojo is, it's a fantastic library. It feels a bit old because it IS a bit old. It doesn't offer all that new hotness of a virtual DOM and 2-way binding. It's also NOT a jQuery competitor. The domQuery module from Dojo is a tiny part of its vastness. The Dojo docs suffer from being a bit scant at points. They also assume you have a bit of foreknowledge of how Dojo works. If you want info, SitePen's blogs offer up to date info.
I would stay away from the big frameworks. They introduce a lot of bloat into your project that you don't need. Instead, plan out your project in small parts and begin to write those parts in javascript. Do searches on npm for modules that can help with your project. 
No, examples 2 and 3 are preferred patterns that use the features javascript is built on, such as being a prototypal language. 2 suggest a "classical" pattern (since it looks like a constructor function), while example 3 can be used with a prototypal pattern or classical. I suggest looking into this 30 minute video http://www.objectplayground.com/ to get an idea of the two patterns. Overall, it isn't very useful to add properties on a a function object. It is common to add properties on the function objects .prototype property (which is an object). 
this is the best explanation of the *this* var i've ever read
It applies the array-like object on its skin or else it gets the hose again. Just remember that `call` is the one which is more like a regular function call.
Why **is** bind so much slower in comparison? Considering you can write a simple context binding function using `apply` like this: function bind(fn, ctx){ return function(){ return fn.apply(ctx, arguments); } }
You cannot make generic websites with Ext, it's meant more for desktop-like widgets. As someone who has to maintain an Ext 4 application please for the love of the gods don't use Ext. Bringing on new developers will cause such ache. Also, any request that Ext.js can't fullfill with it's widgets will leave you high and dry. In the long term getting developers who know it or training new ones will become more difficult because it's so dependent on you knowing everything about it.
Edge cases. It's the same reason the built in forEach and map are so slow, they have to account for all sorts of possible inputs. Also bind doesn't just change the context, it also allows for currying and de-currying. [The full polyfill is a bit more involved](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill), and even it doesn't fully implement the spec, as the text below the code describes.
See for yourself: http://jsperf.com/function-calls-direct-vs-apply-vs-call-vs-bind/14 Also: http://jsperf.com/bind-vs-closure-setup/32
Espruino is a similar board in that's worth checking out: http://www.espruino.com What I'd probably recommend is a Raspberry Pi Model A+. It's still very cheap but because it's a full computer you can run node and wifi is a little easier. Interfacing with external hardware with the GPIO pins is pretty simple. Also very interesting is the Spark Core. That uses a very similar programming language to the Arduino boards, which are really well documented, but it has on-board wifi (and cellular soon) while still being very cheap, and there is a javascript api for interacting with the device through their web service. All cool things, but the RPi A+ with a $10 USB wifi adapter is probably the most flexible and is easy to get started with.
But it's still an incredibly shitty implementation. var result = ''; if (!(i % 3)) result += 'Fizz'; if (!(i % 5)) result += 'Buzz'; 
That's pretty. 
bind is new in ES5, but call and apply aren't. At least, I hope call and apply existed before ES5, or I won't know how to write that polyfill for bind.
No. Just making my point. You should never mix tabs and space whatever the language. The fact that it can cause problems in Python is a bad argument.
Most of my experience is with Ember, and I really like it. I see React and Ember being relatively similar in capability, but slightly different in approach. Honestly I like Ember's completeness more - no need for extra components like Flux, and the tool chain with Ember CLI is excellent now. It used to be shit, and it put me off. Angular is in a bit of a no man's land at this point IMO. It's always been the dominant, but 2.0 is such a change that it's essentially a reset, which will give the other two a chance to snatch market and mind share. I would recommend going with either React or Ember, and seeing which one "clicks" for you. If you go the Ember way, do it with CLI. It helps enforce the conventions Ember is based around, and simplifies builds a great deal.
As an ember user (dabbler, really) I'm impressed too. It takes a humility and open-mindedness to say "That's better than what we're doing. We should do that." Rather than doubling down and saying "No, ours is bestest because &lt;artificial reason&gt;" 
This is really awesome!
thanks, this is what I'm doing with grunt: gulp: { // grunt task using grunt-gulp app: function() { var babelify = require('babelify'); var browserify = require('browserify'); var transform = require('vinyl-transform'); var through2 = require('through2'); var files = [jsDir+'/MyBootstraper.js']; return gulp .src(files) .pipe(through2.obj(function (file, enc, next) { browserify(file.path) .transform(babelify) .bundle(function (err, res) { if (err) { return next(err); } file.contents = res; next(null, file); }); })) .pipe(require('gulp-rename')('app.js')) .pipe(gulp.dest(builtDir)); }, }, Check out https://github.com/thoughtram/es6-babel-browserify-boilerplate to fully understand this example
I think the only way it'd be unsafe is if multiple things were modifying i, such that it could decrement to a negative number in the span of the loop
This is exactly what I shouldn't be bothered with when using a "high-level" framework. Just saying...
Wow, it looks nice :)
No. Microsoft does not bring JavaScript developers to Office 365.
&gt;Rival BackboneJS won the battle; AngularJS is winning the war. The clue is in referring to anything that is not a "battle" or "war" as such. Clearly this article is for clueless cto's and project managers, and not dev's. 
Not sure if it helps at all. But here is the .js code that i believe to be the menu in question http://paste2.org/UZBNtXvI
Also, electricity becoming popular.
&gt; old science Well duh, but the fact that it can be done in the browser is the cool part.
Just use a proxy if you want to respond to setters.
From what I understand you are trying to achieve. You could: In controller use a scope variable to store your form data in, $scope.credentials = {}; And Use a directive similar to this to catch the enter button: .directive('actionOnEnter', [function(){ var directiveDefinition = { restrict: 'A' , replace: false , link: function(scope, el, attrs){ el.bind('keydown', function(e){ if(e.keyCode == 13){ scope.$eval(attrs.mwmActionOnEnter); } }); } , controller: 'formController' // same controller as your form scope variable }; return directiveDefinition; }]) Then your form and button in your view will be like: &lt;input action-on-enter='login()' type="text" ng-model="credentials.user" placeholder="Username" autofocus/&gt; &lt;input action-on-enter='login()' type="password" ng-model="credentials.password" placeholder="Password"/&gt; &lt;button class='inline-button' ng-click="login()" ng-disable='newDevice'&gt;Login&lt;/button&gt;
Here's my take, in ES6. I don't like the `slice` at the end to remove the 0 index. Anyone know a better way? [for (i of Array(100).keys()) ((i % 3 ? '' : 'fizz') + (i % 5 ? '' : 'buzz') || String(i))].slice(1) PS it only works for me in Firefox. 
[A]pply is with [A]rray
**A**pply uses an **a**rray to pass the arguments. That's how my pea brain associates/memorized them.
Node.js is a Javascript engine with access to low-level system APIs. What /u/ZyklusDieWelt said is correct but it can be used for a lot more than just the server. For instance, for me Node is entirely irrelevant on the server because I do mainly frontend stuff (or backend stuff with .NET/PHP) but thanks to: 1. It's ability to access the filesystem in a cross-platform fashion. 2. NPM (the dependency manager) and the huge ecosystem surrounding it. 3. The resulting build tools like grunt/gulp. It's given me [UNLIMITED POWAH](http://www.youtube.com/watch?v=kNS4t5UCBfI) when developing JS on the frontend. It is **fantastic** for scripting and automation. You can also create cross-platform desktop applications, see example GitHub's Atom Editor if you want an example of that. So yeah, try not to think of it as "JS for the server" as it's more "JS that has access to low level APIs and just happens to be able to bind to ports and serve requests". It does have some things on the server it's very good at but I'm not the best person to talk about that.
Doesn't work in IE11.
the property should be called shouldDisplayAmericanLink
NodeJS is JavaScript running on a server. More generally, it is a platform built on the V8 engine (same one running under the hood of Chrome), with its own [module pattern](https://nodejs.org/docs/latest/api/modules.html) (CommonJS), a rich package manager ([npm](https://www.npmjs.com/)), and a [standard API](https://nodejs.org/api/). This means you can do things like: - cross-platform file IO operations - build command-line applications like [gh](https://github.com/node-gh/gh), [http-server](https://www.npmjs.com/package/http-server), [replace](https://www.npmjs.com/package/replace) - run automated tests on your JavaScript applications, and integrate them with cloud services ([Travis CI](https://travis-ci.org/), [SauceLabs](https://saucelabs.com/)) - easily compose complex applications with modules on npm (some listed [here](https://github.com/sindresorhus/awesome-nodejs) and [here](https://gist.github.com/mattdesl/73e3b9f902f9c834b721)) - build tools like Gulp, Grunt, Browserify, etc which act on frontend code and bring some of the same benefits of Node (streams, modules, etc) to your web workflow IMHO Node and its ecosystem is one of the best things you can learn as a JavaScript dev, regardless of whether you work in frontend or backend code.
But the link should only be displayed to admins as well
`call()` has the same syntax as a basic call.
That's funny, but it's surprising how few actually do...
This would speed up small updates and slow down large updates (think replacing the whole body).
I looked through the github pages and through the other select3 page, but couldn't find a simple demo of what this is supposed to be. 
here are the contents of webdatatree.js It seems to be a part of the infragistics suite http://paste2.org/aaHnchL2
https://arendjr.github.io/select3/ seems to be some sort of a drop down.
Very cool. I wonder how hard it will be to deal with ambient noise?
I don't see a JSFiddle link.
Mike? MIKE? MIKE WHERE ARE YOU
I think I would just stick with PHP I'm still having shitload of brain quirk trying to run JavaScript file on a localhost. Thanks guys for give me an insight. 
Node.js and io.js are command line JavaScript interpreters with additional utilities, such as: process management, http, and file system libraries. Both Node.js and io.js use the Google V8 engine to interpret and JIT compile JavaScript code. The benefit of command line execution is that you can run JavaScript code on your local computer outside of a web browser or on a server to provide services.
There are bindings for MongoDB, NoSQL, PostgreSQL, LevelDB, etc.
Would love to see something like this released as a React component that's free of jQuery...
While you are correct, it wouldn't be much of a stretch to say that Angular 2 is a new framework. It shares the name with Angular 1.x but it is a complete rewrite for all intents and purposes. 
That's unfortunate and confusing project naming.
Agreed. We used this on a project and all it did was cause us issues. Adding anything that isn't Ext-driven is a huge pain in the ass. So things that are usually simple become incredibly complex, very quickly. 
Those blend in a little too well with the page background. Didn't even notice right away that they were inputs.
Many software packages that bump major version numbers (1-&gt;2, 2-&gt;3, etc) are rewrites. It's rarely ever 100% (probably never with any sizable code-base), but rewrites of the architecture are common every 5-ish years. I wouldn't call "windows 8" a "new OS" (in the sense that it's still windows/Mac/*nix), but an upgrade, even though a huge part of it was rewritten. Same for anything else.
The thing is, batching things intelligently is something the computer can do. react.js proved that, angular 2.0 has it and now ember.js will also have it. And that's great news for everyone. Saying "well, you just have to learn the low-level stuff of X" imo is denying there's a problem that can be solved, so other people don't have to solve the same thing over and over again.
&gt;\#clock .digits div.three .d1, &gt; \#clock .digits div.three .d5, \#clock .digits div.three .d2, \#clock .digits div.three .d7, \#clock .digits div.three .d3{ opacity:1; } Clever.
There is also a point of diminishing returns, but node out of the box doesn't seen to do much...I'm running grunt for my builds...that is someone else's stuff. I would not advocate grabbing a package for everything...but Grunt,Express,database drivers,etc with notable usage, I don't want to write those. I want to write my application.
My problem with stuff like this is the first/current version of Angular is kind of a nightmare to work with. I actually agree with the Angular team's general direction after using Angular 1.x, but of course they probably could have handled the transition better than "fuck you, rewrite your app". I don't know much about Ember but I would probably recommend it over Angular as well.
&gt; the Angular team says they will work on an upgrade path from 1.x to 2.0, but I don‚Äôt believe it. ...Okay. I guess that's your choice. This article seems silly. Angular 2.x won't be out for another couple of months and 1.x won't be sunset for a long time. The Angular team has said that they'll monitor both 1.x and 2.x and provide support to 1.x as long as a significant percentage of people are using it. So why the panic? Rather than choosing to incrementally upgrade, the team chose a bold, new path for 2.x. I think that's cool. It frees them up from a lot of the things people *dislike* about 1.x. But in the end, if you're happy with 1.x (as this author claims) then just stick with 1.x.
Lost me at &gt; Here‚Äôs why: every member on Ember‚Äôs core team is actively working on one or more production apps that use Ember. On the flip side, no one on Angular‚Äôs 2.0 core team can say the same thing. That‚Äôs because Angular 2.0 won‚Äôt even be out for another year. How can you compare a working lib with something not released (or even in beta!) yet?
Right. I remember being in a meeting with C# devs and biz guys where we were trying to decide how we would build web apps. There actually was no decision to be made because the party line was "Angular is the future of web development". Because of stupid shit like this article. (I don't work there anymore)
&gt; I want to write my application. That's the exact reason why you should depends on as few dependencies as possible. The more you depends on, the more integration you'll be doing, the less you'll work on your application.
Personally yeah, unless I'm already using jQuery for other purposes. jQuery is after all a pretty big piece of software which I will not include in a project because something purely aesthetic relies on it.
&gt; And you would need 3 to 6 months to learn how to work WITH them Of course, if that is the requirement from the company to get the job that you are aiming for, which they wouldn't care if you spend one year or one day learning such tool, but the actual apps that you made with it. What exactly is your point and context?
Are you trying to be obvious or pedantic? Browsers didn't use to support access to the microphone without the use of external plugins...
A lot of the old shit in JS doesn't make any sense. Including isNaN - isNaN won't actually tell you whether the value is NaN, it will tell you whether, if you were to coerce the value to a number, that number value would be NaN. So, in order to *really* check for NaN, you have to test whether the value is not-equal to itself, because NaN is the only thing in JS that is not equal to itself. How's that for crazy? (Here's the relevant section of the ECMAScript 5 spec http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.4 )
I have some ideas for games using Meteor as well. How intuitive are the Phaser APIs? Would you recommend it for game programming beginners? I will check out your site later.
30 minutes of integration is a lot better than 3 days re-writing existing packages.
To test for a type (boolean, number, string, etc.) there's typeof as in var a = 1; typeof a; // "number" and var b = NaN; typeof b; // "number" For obscure floating point reasons NaN !== NaN, so testing for NaN is kinda difficult, that's why there's isNaN(). Late on it was discovered, that first coercing the value to a number wasn't a great idea, so ES6 will bring [Number.isNaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)
https://github.com/arendjr/select3/issues/1
Why are there 2 "render" functions? I removed the first one. http://jsfiddle.net/br8wzjv2/1/
Do you have experience in preventing from cheating in games that rely on physic (Phaser P2/Arcade). If so, what is the best pratice to do it. Run Phaser in headless mode on a server side and validate the data that comming to the server or you have other solution? 
&gt; For obscure floating point reasons NaN !== NaN To steal a quote, "Happy families are all alike; every unhappy family is unhappy in its own way." NaN can arise from hundreds of different invalid calculations, so it shouldn't be able to compare equal to itself. Zero times (either positive or negative) infinity produces a NaN. But you definitely can't argue that 0 \* ‚àû === 0 \* -‚àû. Every erroneous calculation has a different flaw that makes them all incomparable.
Node packages aren't blackboxes ,you can always go read the source code,which saves quit a lot of time. I don't buy your argument. Someone has already solved the problem you need to solve,go read what that guy did instead of starting from scratch. Arrogant developers will start from scratch, pragmatic ones will use third party packages while reading their source code. I personnaly judge developers on their capacity to read other people's code. Surprisingly,most developers cant do that.
Then draw us a line in the sand. When you build a web app, what's your line for dependencies? Do you roll your own REST or install Express or what?
Yeah, I'm not advocating to write everything yourself at all costs, but I see it as a downfall of node vs php, in that php does a lot out of the box, where as with node you have to add lots of things, and continuously add more stuff you have to keep adding more stuff. It's maybe a problem with the JS community in general though because I remember even a long time ago people would ask simple javascript questions and the top answer was always to install Jquery and then several lines of using jquery when the answer could have been achieved in 1 or 2 lines of pure JS. Probably due to the fact that multiple browsers really kind of forced you to add libraries to be sure it would work on them all, whereas on the server side there really shouldn't be any need for that. It just seems to that in the end you're learning less about coding and more about integration of other packages that when they break or you want to change something is going to require a lot more work. Also there's the problem that certain packages generally do a lot more than what you need which adds complexity that you don't benefit from and then becomes a nightmare to modify just slightly. It's just my experience, obviously everyone's needs are different.
&gt; The more you depends on, the more integration you'll be doing, the less you'll work on your application. You write your own DB drivers, ORM, caching layers, and MVC frameworks when starting a new project, then?
You could write a custom directive where in the linking function it watches a variable in the scope. When the variable is of a certain value, focus on the element using .focus(), then fire your keypress event. You could implement it so it works like this: &lt;input directive-focus-on='scopeVariable' attribute-focus-when='InputName' /&gt; if scopeVariable == InputName then call .focus() I would attempt myself but I'm buried IRL problems :( I foresee a need for a similar directive for my future elf. So you may hear back from me.
I use them and I go and read their code. Thing is most people do not. I'm not saying don't use them, just include as few as possible as a rule of thumb. The first thing is never to look for a dependency when trying to solve an issue but to look for a standard which answer your question. Then only as a second step you go and find an implementation. 
Potentially, yes. What does the HTML of the page look like? Note: it's very unlikely that this will result in you figuring this out. It's probably better to find a friend who knows JavaScript to have a look at your webapp.
Most people have problems knowing *one* whole language. Hell, I'm using Python for more than 10 years know and learned about `contextlib.redirect_stdout` last week (ok, it exists for only 12 months now, but still).
These new rendering engines address intelligent handling of batches of updates, but not really the batching itself. Again, Glimmer will help Ember's general performance, i.e. by making one reflow per flush of the render queue in the run loop, but it can't magically know that there are a thousand related updates coming that should be batched together and rendered in one shot. It already has lazy evaluation and the run loop to help in the general case (e.g. if you loop over a thousand elements to update them, the calls are temporally close enough together that it'll automatically batch them), minimizing recalculations, and will soon be bolstered by Glimmer, but sometimes you have to get your hands a little dirty because it makes sense for your app's special cases, and async is complicated. The more high level a framework is, the more you need to make sure you expose these kinds of lower level escape valves, because the general case isn't always what you need.
For the most part, things that aren't too crazy can be accomplished without jQuery. The more external dependancies that are added the more that the developer has to worry about with integrating with. ReactJS can handle all the stuff for the dropdown as far as I'm aware. I built one for the city dropdown on my businesses page: https://trumpet.ca/ without using jQuery at all. The only reason I included jQuery on the page at all is because I didn't want to stretch Backbone to not use it.
Something like Python and urllib would be good for this I think. That will allow you to POST the forms. Filling them in requires looping through the spreadsheet, which Python has libraries for. 
Is that a good idea to compare absolutely different tools? I know that is possible that you can do a lot of stuff in node that is usually done in PHP, but for me it will be always different beasts.
Well yes, you will almost almost find new things in a language since it is evolving but I imagine after a year of writing full applications in it you were fairly proficient.
Shameless plug: [my select replacement](http://github.com/robdel12/DropKick) lib is also accessible. It's the first thing I check for all of these, because it's the #1 thing the authors miss.
Some of my point has to do with the environment I am in now. The statement of "no dependencies" is a rabbit trail with no end. In the end, Node is a dependency, your database is a dependency, as is your own code. So what DON'T you consider a dependency? And at the bottom of each stack is just another API -- not real knowledge. At my work, one of the developers didn't trust 3rd party install packages for our dependencies. So when setting up a new instance on a new server, we are downloading and compiling Postgres, ffmpeg, and ImageMagic ourselves. We have gone back and forth about writing our own JSON parser vs using JSON.org's parser several times. We implemented our own authentication code -- which has caused more issues than I care to count as authentication requirements have changed over time. How many hours did we gain from all of that -- so far it is a net loss. Our efficiency gain on the platform? 0%. But that developer is ecstatic with the results so I guess that counts for something. On the practical side, have you looked at the browser file api for doing drag drop with the file system...do you really want to go there? No thanks, I'll use JQuery-file-upload.js thank-you-very-much. I have a good understanding of SVG and the canvas api (I've taught classes on it)...but sure as heck don't want to write my own charting library. I understand the browser api -- but still use JQuery (I have to support old browsers). So yes, how many wheels need to be reinvented before you can get actual work done.
The "Wut" was not meant to astound readers but to impress my first reaction which was like WUUUUAAATTT 
Wow man we're sorry we're boring your genius.
‚Ä¶nice try meteor.js developer.
I use the lebron stack. http://lebron.technology/
If you run a script on your domain like "localhost", "reddit.com" or else you can only get data from the same domain. If you want to grab data from a different domain you need permission via [Cross-Origin Resource Sharing (CORS)](http://www.html5rocks.com/en/tutorials/cors/) or the other page has a API that support JSONP. If both is not available then you can grap the page via PHP-Proxy script. The PHP-Script is loading the page and returns it content to your js. If you create a Chrome Extension then you dont have the restriction you only need to at the domain to your [manifest.json](https://developer.chrome.com/extensions/manifest) in the [Permissions](https://developer.chrome.com/extensions/declare_permissions) section.
Apologies aren't necessary. I already understand the crowd.
Cool. I just started a project in react that does a lot of class name manipulation, I'm glad I got the deprecation news early so I don't have to go refactor everything. Brb updating
Integrates in what way? Rhino?
Watch out: this loop fails for `obj = { hasOwnProperty: 0 }`. Safer: for (var k in obj) { if ({}.hasOwnProperty.call(obj, k)) { console.log(obj[k]) } } I find `for-in` too much trouble and normally avoid it.
Still not quite the same as having the same language, full-stack, on both sides.
Watch out, standalone object like that can fail in old IEs. Safer: if (Object.prototype.hasOwnProperty.call(obj, k))
I wish there was more content in the article; I feel like it could have said a lot with that level of PHP knowledge.
Yes, it's not the same. It has advantages like better library support and compile-time type checking. You can still share code between server and client.
I'm actually in the middle of deciding if I want to jump on the "avoid loop" bandwagon. I have been reading up a lot on the functional programming side of Javascript and I absolutely see the use there, but I don't see my workplace transitioning to that until the libraries for it are more unified, so for now we are sticking with classless objects and interface/module patterns and it is working amazingly well. Anyway, back on topic, what is the gain by removing loops? Loops run about 20x more efficiently, which honestly is likely neglible in the grand scheme of things, and I also know loops are immutable, but is the gain from that so great? If I could have the worth of this explained to me more, I would deeply appreciate it.
Well they obfuscate their form code pretty well. But that's what people need to know. Maybe someone in his sub feels like figuring out where the data gets sent and has some way to automate that.
Best served with es6ify! I love it so very much. Still not using classes since I love mixins.
I'm personally not a fan of the prototypal approach. I like the classless object approach where you return an object that is essentially an interface into the guts of the real object (abstracts everything away except what the implementor needs, and it forces you to write modular code). I find it to be much cleaner and easier to work with, and I'm honestly surprised it isn't mentioned more. 
I just tried it out! Pretty sweet. What are your thoughts on MeteorJS? How did you structure your project? Did you use packages for each individual game? Edit: also, did you have any trouble compiling to iPhone and Android on phonegap? What are your thoughts on your experience?
Why would you use bind for currying? function sub_curry(fn /*, variable number of args */) { var args = [].slice.call(arguments, 1); return function () { return fn.apply(this, args.concat(toArray(arguments))); }; }
Yeah I work primarily in Node and Im thinking of trying Golang out because I heard it's a relative of C and I love C. I think JS should stay in the frontend where its dynamic typing makes it very useful for the DOM. It's a pain in server side though because it's so damn hard to debug and the dynamic typing makes it hard for the code to be reasoned. But, maybe the one language deal is big after all and I may be wrong. Only personal experience will tell. I am not taking sides in this until I try it out first.
[Selenium](http://jroller.com/selenium/) can automate browser tasks. Another option is using some other programming language with a cURL (or similar) library to automate form submissions.
MeteorJS == the best!! The games are written using the Phaser engine, which has been wrapped into a Meteor package: https://github.com/thinkong/meteor-phaser I'm not sure what specifically you are interested in regarding the structure of the project, but in terms of playing the games: Basically, the server configures any required game data (i.e. randomizes the game parameters) before the games starts. Then the client plays the game with the pre-configured server data and sends back scoring and other data when finished. Then the server compares all the client scores and concludes the game. We haven't yet used phonegap at all... it's just a browser-based web app for now.
For those with windows and visual studio: cl -nologo -EP test.js or cl -nologo -EP -DBAR=1 test.js
I used to like that method as well. And it is useful in some contexts, but it's akin to private methods/properties in classes due to the closure. This makes it inherently impossible to test the inner guts in an automated fashion. But TDD experts will tell you that private methods aren't supposed to be tested anyway :) To each their own.
It's taken me awhile to get my head around a more functional approach to JavaScript/programming - and still lots to learn. The library that actually had the biggest 'ah-hah' moment for me is actually RamdaJS. But, some things... If you look through your code, many of the patterns you see in your loops tends to boil down to removing things (filtering), transforming things (map), summing/adding things (reduce). When looking through code, and I 'var x = R.map(....)' - I know quickly know what's going on 'taking a collection, and transforming it', instead of looking at a long for loop - often which just encourages more and more code to get rammed into there and wondering 'what is this actually doing?' By returning new instances of data instead of mutating it - it can also help avoid side effects in your code. When you get those hard to debug things of 'if I click X, then Y, then do this, then do that, and well - why the hell is this getting that value?' -- chances are you've gone and mutated something somewhere, and not always sure where. You can also know that you can safely do something on the returned collection w/o affecting the thing that sent it in. It also makes it easier to compose functions / reuse them / etc. It gets easy to fall into a 'for loop within a for loop within a for loop' that is mixing filtering, transforming, etc - and get into a rather tangled mess of hell. Then the bigger the block of code is - like flies to shit, more stuff tends to creep on in. Lets take an example of 'give me a list of kids with brown hair', with a forloop you might do: var kidsWithBrownHair = []; var kids = [{ firstName: 'So', lastName: 'andSo', hair: 'brown', age: 9 }, { firstName: 'John', lastName: 'Deer', hair: 'brown', age: 15 }, { firstName: 'Alex', lastName: 'Willson', hair: 'red', age: 16 }]; kids.forEach(function(kid) { if (kid.hair === 'brown') { kidsWithBrownHair.push(kid); } }); It works, but takes a second to see 'oh, I'm doing a filter'. Then, lets say you want to do 'kids with brown hair, and over 10. Then, you tweak it to be: kids.forEach(function(kid) { if (kid.hair === 'brown' &amp;&amp; kid.age &gt; 10) { kidsWithBrownHair.push(kid); } }); Then ... you need to get a full name.. kids.forEach(function(kid) { if (kid.hair === 'brown' &amp;&amp; kid.age &gt; 10) { kid.fullName = kid.firstName + ' ' + kid.lastName kidsWithBrownHair.push(kid); } }); But wait, now you've mutated kids - and some of them have a property fullName, and some dont. The kind of thing when debugging later on you wonder 'why the hell do some of these have a fullName and some dont?'. So, maybe you tweak it again. kids.forEach(function(kid) { if (kid.hair === 'brown' &amp;&amp; kid.age &gt; 10) { var newKid = { firstName: kid.firstName, lastName: kid.lastName, age: kid.age, hair: kid.hair }; kidsWithBrownHair.push(newKid) } }); You are now getting a bunch of things that can't easily be re-used - maybe having a 'age &gt; 10' filter would be handy, maybe having a generate fullName would be handy. Or, say with Ramda: [Try it on their REPL](http://tinyurl.com/qesqcln) var hasBrownHair = R.filter(R.propEq('hair','brown')); var olderThan10 = R.filter(R.compose(R.lt(10),R.prop('age'))); var kidWithFullname = R.map(function(kid) { return R.merge({ fullName: kid.firstName + ' ' + kid.lastName },kid); }); var mySearchAndTransform = R.pipe(hasBrownHair, olderThan10, kidWithFullname) var results = mySearchAndTransform(kids) You can now easily use hasBrownHair, olderThan10, kidWithFullname in other spots if that'd be useful for you. You can also easily add other steps to the pipeline - maybe you want to sort, add another filter, etc, and that's just scratching the surface of Ramda. Doing it with normal for loops would be faster - but generally for the type of things most people are doing - it'd be a premature optimization. And, by taking an approach like this first - if something did become a bottle neck, it can be a bit easier to identify and pull out the choking points of the code. It could also be a thing like 'I'm doing the filter at the end - if I was to move it to be the first step, the other steps have less records to go over', and it's pretty trivial to move olderThan10 to be the first thing in the chain. 
I've always found functional code to be easier to read: things.forEach( thing =&gt; { doSomethingTo(thing); } ); vs for (var i = 0; i &lt; things.length; i++) { doSomethingTo(things[i]) } Honestly, I don't remember the last time I wrote a for loop before this comment, but it's been many years.
Oh, I gotta read this. I'd like to do ten weeks of node.js after 15 years of ASP. Should be easily translatable. My html/javascript is getting pretty good, but I'm still writing my ajax handlers in classic ASP, and I've been wanting to put that final nail in the ASP coffin. 
Why the fuck would you redefine `hasOwnProperty`? I wonder the same thing when I see people writing `var undefined` to assert that `undefined === undefined`. I understand _how_ you're protecting yourself, but I don't understand _why_ you would ever need to.
I've read arguments stating the same sentiments as you, and there is also an argument to be made about removing the chance of leaking the iterator to the global scope. If it's a question of coding discipline, maybe I will make the jump. I was heavily considering it until I saw the different in performance and I started second guessing it, despite knowing in most cases it likely wouldn't matter which gets into the whole debate of avoiding optimization during the development phase of a feature. Is there anything anyone else can add to this, or does this mostly come down to style (with the exception of that 1% case where you need the 20x speed, in which case the loop may not even be the source of the bottleneck)
Can I get an actual code example, if you don't mind?
I recently wrote a few small go projects. I will say it was very enjoyable and you will definitely see the savings down the road in a statically typed language. https://github.com/michaeljs1990/freetime here is an example of what a simple API could look like in golang I wrote this when first evaluating the language.
I see you don't like to live dangerously.
Readability the first one does do better, but it's important to remember that `Array.prototype.forEach` is still a mutable function like a for loop whereas `Array.prototype.map` is immutable. You'd use map/filter/reduce/etc. to 'turn' input into output, then last step should normally side effect-y function like forEach (i.e. IO like console.log, DOM manipulation, etc.). When you start building more code without side effects, you get easier to reason about code with less errors. Anyone needing a primer may find James Coglan's talk, [Practical functional programming: pick two](https://www.youtube.com/watch?v=XcS-LdEBUkE), useful. He writes some Haskell and CoffeeScript, but don't let that scare you off as it's mostly for conceptual ideas and brevity (like the implicit returns most FP languages have).
Don't undervalue the lack of a context switch. When you've got both PHP and JS files open in the same window it can be strenuous to remember which functions you can use in which file and in what syntax. PHP compounds this be by being pretty close to JS in general syntax, except in critically significant ways. I can't even count how many times a day I misuse periods in one or the other language.
Agreed. I used `forEach` because /u/Sinistralis asked about `for` loops, but most of the time, I'm `map`ping and `filter`ing away!
&gt; accessing missing properties throws I hope that doesn't include truthy checks. Would suck to have to start doing typeof all over the place. edit: After reading the slides, I actually don't care, since I'll never be using this. I actually _like_ function scoping.
Thank you for your help! The method I ultimately used was from http://dev.enekoalonso.com/2010/07/20/little-tricks-string-padding-in-javascript/ String.prototype.zeropad = function() { return ("000" + this).slice(-3); }. It allows me to pad the element to zeros and by using a negative number in the slice property, it will always return the right number of zeros. -3 makes it start from the end of the string and and moves leftward rather than the opposite. And the method can be called with .zeropad at the end of my array, so it would look something like hexconversion = decimalNumber.toString(16).toUpperCase.zeropad; Thank you all.
Something that will definitely speed things up is to remove the function creation from the loops. Just create the functions at the top and call the appropriate one. You are currently creating a million functions (10,000 * 100).
I'm still not sure I understand the argument of for loops having less side effects than the array helpers. I am familiar with the concept of writing pure functions, I've done some functional programming research, and I understand the purpose behind it, but what I don't understand is why functions like Map, Reduce, etc are considered more pure than the for loop. In both cases you are iterating over something, performing logic, and then exiting. I don't see the difference. I understand the for loop is mutable, but I guess I don't quite have as deep of an understanding of why that matters as I should? Sorry if I am being a nag but I really want to get a concrete definition of this hammered out in my head because I want to eventually transition the other front-end guys to writing more pure code, but I need to make sure I present it correctly, and I can't do that if I don't understand it completely. I'll check out that video when I get time, thanks for the resource!
You could try your hand at implementing a few. It should give you some good insight at the inside. Implementing Forth is pretty easy, as far as that goes. It should build up your confidence.
Im still declaring my classes via react.createClass but im able use es6 stuff like let, const, spreads and fat arrows to name a few. Not mutually exclusive but will allow me an easier time to make a switch in the future.
First thought: I wouldn't handle events this way at all. &gt; Is there a better way to handle calling methods from a method on the same object? An easy solution to your troubles with 'this' would be the so-called "revealing module pattern". You even get to skip typing 'this' over and over. It shouldn't take more than a few minutes to update your code. &gt; And I can't seem to pass arguments using listening events. I'm not sure what your intention is there, or what you've tried, but you can create your own custom events and pass along anything you want. &gt; While this works really well, I don't know if better option that might be faster. There is (or was) a faster approach, but I wouldn't bother. It's not as general, but it saves two multiplies, and trades a square root for a sin or cos (really cheap if you use a lookup table). Back in the good old days, it was significantly faster. Today, the "if" alone might negate any possible gains. (Branch mispredictions are expensive.) Remember your trigonometric ratios (soh cah toa!) and find the distance by the angle (atan(slope) or atan2(rise, run) if you need the orientation): if x1 != x2: d = (x1-x2) / sin(atan2(x1-x2, y1-y2)) otherwise: d = (y1-y2) / cos(atan2(x1-x2, y1-y2)) &gt;Seems like a lot of math to do something so simple. It only gets worse from here. :)
http://www.samsung.com/us/solvefortomorrow/js/sft.signup-form.js
http://www.samsung.com/us/solvefortomorrow/dist/assets/js/votes-service.js
I don't think he even alluded to it, given that the same description was used for the speed of each framework. I can understand why you'd think so, but to me it seems he is willing to believe that they are all sufficiently fast. 
You could try http://bower.io/docs/api/#list with the `-p` flag.
Setting innerHTML is just about the last thing a decent front-end developer should do. If you go that far out of your way to avoid using the DOM, bloody well just render everything servier-side and just deliver it statically to the client.
Wow, I've been spending over half an hour on this... Edit: probably not something i should admit &gt;.&lt; Thank you!
I know sometimes these URL's which contain code in the query string can be tricky to post, but at least for this one all you needed to do was escape the `)`'s: http://ramdajs.com/repl/?v=0.11.0#var%20kidsWithBrownHair%20%3D%20%5B%5D%3B%0Avar%20kids%20%3D%20%5B%7B%0A%20%20%20%20firstName%3A%20'So'%2C%0A%20%20%20%20lastName%3A%20'andSo'%2C%0A%20%20%20%20hair%3A%20'brown'%2C%0A%20%20%20%20age%3A%2010%0A%7D%2C%20%7B%0A%20%20%20%20firstName%3A%20'John'%2C%0A%20%20%20%20lastName%3A%20'Deer'%2C%0A%20%20%20%20hair%3A%20'brown'%2C%0A%20%20%20%20age%3A%2015%0A%7D%2C%20%7B%0A%20%20%20%20firstName%3A%20'Alex'%2C%0A%20%20%20%20lastName%3A%20'Willson'%2C%0A%20%20%20%20hair%3A%20'red'%2C%0A%20%20%20%20age%3A%2016%0A%7D%5D%3B%0A%0Avar%20hasBrownHair%20%3D%20R.filter(R.propEq('hair'%2C'brown'\)\)%3B%0Avar%20olderThan10%20%3D%20R.filter(R.compose(R.lt(10\)%2CR.prop('age'\)\)\)%3B%0Avar%20kidWithFullname%20%3D%20R.map(function(kid\)%20%7B%20%0A%20%20return%20R.merge(%7B%20fullName%3A%20kid.firstName%20%2B%20'%20'%20%2B%20kid.lastName%20%7D%2Ckid\)%3B%0A%20%20%0A%7D\)%3B%0Avar%20mySearchAndTransform%20%3D%20R.pipe(hasBrownHair%2ColderThan10%2CkidWithFullname\)%0Avar%20results%20%3D%20mySearchAndTransform(kids\)%0AJSON.stringify(results%2Cnull%2C2\)%3B%0A [In practice.](http://ramdajs.com/repl/?v=0.11.0#var%20kidsWithBrownHair%20%3D%20%5B%5D%3B%0Avar%20kids%20%3D%20%5B%7B%0A%20%20%20%20firstName%3A%20'So'%2C%0A%20%20%20%20lastName%3A%20'andSo'%2C%0A%20%20%20%20hair%3A%20'brown'%2C%0A%20%20%20%20age%3A%2010%0A%7D%2C%20%7B%0A%20%20%20%20firstName%3A%20'John'%2C%0A%20%20%20%20lastName%3A%20'Deer'%2C%0A%20%20%20%20hair%3A%20'brown'%2C%0A%20%20%20%20age%3A%2015%0A%7D%2C%20%7B%0A%20%20%20%20firstName%3A%20'Alex'%2C%0A%20%20%20%20lastName%3A%20'Willson'%2C%0A%20%20%20%20hair%3A%20'red'%2C%0A%20%20%20%20age%3A%2016%0A%7D%5D%3B%0A%0Avar%20hasBrownHair%20%3D%20R.filter(R.propEq('hair'%2C'brown'\)\)%3B%0Avar%20olderThan10%20%3D%20R.filter(R.compose(R.lt(10\)%2CR.prop('age'\)\)\)%3B%0Avar%20kidWithFullname%20%3D%20R.map(function(kid\)%20%7B%20%0A%20%20return%20R.merge(%7B%20fullName%3A%20kid.firstName%20%2B%20'%20'%20%2B%20kid.lastName%20%7D%2Ckid\)%3B%0A%20%20%0A%7D\)%3B%0Avar%20mySearchAndTransform%20%3D%20R.pipe(hasBrownHair%2ColderThan10%2CkidWithFullname\)%0Avar%20results%20%3D%20mySearchAndTransform(kids\)%0AJSON.stringify(results%2Cnull%2C2\)%3B%0A) I bring this up because using a URL-shortener will automatically trip the spam filter, which requires us to manually approve your comment or post. I went ahead and approved this one, but in the future you should try to avoid using them.
Welcome to the club . Happy Hacking ! 
Haha, Maybe in a year or two. I don't think i could code much of anything, but soon! Edit: and Thanks again!
It won't take that long. Coding can be challenging but it's not that hard. I'm no pro but you can always PM me for help,critique , advice.
Global is bad. Local is good. [global &gt; file scope &gt; function scope &gt; block scope](http://i.imgur.com/NZRAsoI.png) Say, there is a somewhat larger function and, inside some if/else/loop block, you want to do add a few lines of code which need one or more temporary variables. With block scope, you can just add them. With function scope, you need to be aware of *all* variables inside this function (except for those which were declared in inner functions). function a() { var q = 5; for (var i = 0; i &lt; 3; i++) { var q = i *7; // redeclaration of q is silently ignored console.log(q); } console.log(q, i); // 14 3 } With block scope, `q` would be still 5 and `i` wouldn't exist (it would get a squiggly line in your editor). The inner `q` doesn't affect the outer `q`. Some JS style guides suggest to declare all of your variables at the very top of the innermost function, because that makes it easier to check which variables exist in this function. With block scope, you can just declare on first use and everything will be fine. The variables from the outer blocks which exist now or in the future won't collide with yours.
Seeing how data-driven it is Meteor might be a good pick too. Can be paired with Babel and ReactJS as well.
Yeah, I'm pretty much done with using grunt or gulp for builds. You can get away usually with just using the "scripts" feature of npm package.json. http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/ For conditional builds, I know webpack has support for it, but I haven't heard of anyone using CPP to process their JS files. 
To be fair, they announced it in the beta releases already :)
hey, thanks for posting this. I'm editing this publication on Medium (although I didn't write the article). I wanted to let you know that I'll be posting 1 article / week on a programming topic (not necessarily JS-related), you can subscribe to the blog here: https://medium.com/unexpected-token Next two articles will be: - How to make Meteor webapps communicate together - Predictably debuggable: node.js domains This is an initiative coming from eFounders, a startup studio hiring extraordinary CTOs to build startups (9, we've built VC-backed companies so far). If you wanna know more, you can visit our website http://efounders.co/ or ask me here. Cheers
The main reason I started moving away from for loops was the needless complexity that it brought to the simple task of iterating through an array. You're right, functionally there is no difference, but the reduced complexity cuts down on errors. For example, .map takes care of creating a new array, completing the iteration through the loop and populating your new array with your return values. To do that with a loop has more parts than just the loop itself: var myArray = [1, 2, 3, 4]; var loopArray = []; for(var i = 0; i &lt; a.length; i++){ var value = a[i]; value++; loopArray.push(value); } vs. var mapArray = myArray.map(function(value){ return value++; }); The map method compared to the loop has way less breaking points. Also, if you have to nest loops to iterate through arrays with nested objects that have other nested arrays, etc. it becomes unreadable rather quickly vs. the functional approach: array.forEach(function(firstVal){ firstVal.property.forEach(function(secondVal){ secondVal.otherProperty[0].forEach(function(thirdVal){ //etc. }); }); }); To me that's a lot easier to read and write than nesting a bunch of loops all with differently name iterators and conditions. This also has the added benefit of functional scoping. With block scoping not having full browser support yet, you'll have to worry about your variable names within each loop block.
Naive example is: node suck less when you need a lot of realtime stuff(chats, analytics etc), php due to its maturity suck less when you need some CRUD app. That's why for me I don't think so that node and php are the same tools for the same job.
Practice practice practice. The more you practice writing vanilla JS the more clear and fast it becomes. Strictly on the client side many people require frameworks and libraries because they can't be bothered to learn the DOM API. I wrote a small guide to make the DOM easier to understand: http://prettydiff.com/guide/unrelated_dom.xhtml If you need practice with the DOM specifically then write a GUI: http://mailmarkup.org/xyz/ I have found in my own experience that a functional and imperative style of code results in substantially smaller overhead in the code, which means faster authoring and less debugging without implication to performance or extensibility. Most developers find an imperative coding style frustrating though, which can be a challenge in group or team settings. If you make good use of closure in your JS and otherwise focus on interfaces that are semantic and accessible you will identify the rough spots over time and gradually refine your code into a style that works best for you.
You're saying you can't see why block scoping might be considered more preferable? 
I work in C#, PHP, JS, and Java right now. I can't tell you how often I forget the syntax for a foreach loop whenever I context switch.
maybe with .animate() http://api.jquery.com/animate/ Or by toggle a class who have a CSS3 animation.
You're defining the function `lockALL()` as a local variable inside an anonymous function, so it's not visible at global scope and therefore `javascript:lockALL()` should be resulting in an undefined reference error in the console. You really shouldn't be using `javascript:` URLs. Attach a click event handler function to the element. This also eliminates the need for `lockALL` to be a globally defined symbol. [Example](http://codepen.io/anon/pen/vEVKMG?editors=101). 
I think page.js is an interesting choice. Is there a reason why didn't you go with react-router and after building this, would you still recommend page.js?
I have been developing JS about as long. I finally got annoyed with all the stuff I still didn't know, so I made a long list and addressed those items one by one over the course of a few months. Read about them, then tried to apply them. This blog ended up being the biggest help http://javascriptissexy.com/ The author is really good at explaining.
What? No it doesn't. Can you show an example?
[react-router isn't compatible with React 0.13 yet](https://github.com/rackt/react-router/issues/638), but I'm sure it will be soon. 
Why not test if HelloWorld exists first ?
Using that command, Meteor packages the project into an optimized phonegap container, with the ability to build a binary for iOS and Android. As far as I've read, their optimizations should make it feel faster than what people have come to expect from phone gap apps, but not having done so myself (yet), I was curious if OP had any thoughts on his experience.
Yes. 
Ahhh I see what you mean. By structure, I was referring to directory structure, since Meteor lets you organize your code any way you want (save a few conventions). I'll check out Meteor-phaser.
I wish you could use type annotation instead of the Java way of muddying your function declaration for typing...
Thanks! bower list -o is exactly what I'm looking for. It compares installed versions to the expected ones in bower.json. Now if only it [returned an exit code of 1 if one of the components was failing](https://github.com/bower/bower/issues/1734).
That's strange... I can't find anything in the jQuery source for that error message. "well-formed" usually refers to XML. It seems that your JSON is being parsed as XML... can you verify that the .json file being loaded has the correct Content-Type HTTP header in the response... or try the [overrideMimeType() method](http://api.jquery.com/jQuery.ajax/)
Thanks for the details! Everyone's comments have gone a long way to improving me as a programmer. I greatly appreciate it. 
And this was my main concern with the current state of FP in JS. It seems to require a ton of libraries to get it properly setup, although ramda seems to be among the better solutions. The extra details you added were awesome by the way. Looks like I have some more research to perform. Thanks! 
Which is good. Competition makes things better.
Ramda's got good things in the works with transducers too... the pull requests are getting merged in as we speak.
I posted about it ages ago and the #1 complaint was "there isn't any documentation". I wrote a ton of docs @ http://cha0s.github.io/shrub though there is of course more that can be done! Since that first release I have built a fun application with Shrub: http://reddichat.com/ which you can come check out and chat if you'd like :3
If you're in a browser, you could open de developer console, go to the network tab, look into the `dictionary.json` request and see if the response you're receiving is what you expect. In fact, your console can probably show you the JSON response parsed if it does indeed parse correctly.
Where's the code for the function?
This rabbit hole keeps getting deeper and deeper. I'll mark this on things to read up on as well. I need to use reduce map and filter more often so their purpose is more cemented in my mind before I move on to this. Thanks for the info good sir. 
The Guild Claims on the bottom of this page are stuck in an endless "Loading..." state. Something ain't working right... http://gw2w2w.com/en/blackgate
Pretty much yes. The code becomes more clearer and predictable as compared to function scoping where the programmer has to keep in mind on all the variables used in the function. *Edit: But I'm pretty sure let is just a sugar syntax for function scoping too* *Edit2: Seems babel adds _ in front of the variable or changes the variable with let. Not sure if this is exactly what's happening on ES6 though*
&gt; I want to know why some people think block scope is preferable. I even drew you a diagram. Why do you think function scope is preferable over file scope? Why do you think file scope is preferable over making everything global? It's always the same reason. It's more local and less global. The lifetime of each variable is shorter and they exist for fewer lines of code. Naturally, conflicts are less likely.
I suppose that's probably the underlying problem, rooted in my not really properly understanding JSON and the way it's meant to be used - it's not on a server; it's a local file, meant to be used by a local HTML/js document - and so of course the network tab doesn't show it at all. Oops. That said, overriding the MIME type worked.
 function someGlobal(data) { // do stuff with json object in variable 'data' } .ajax({ //stuff success: function(data) { someGlobal(data); } ); Alternatively - you can just pass the global function as the parameter to success .ajax({ //stuff success: someGlobal });
&gt; that particular error It's the same deal the other way around. Imagine you need a new variable in an outer block and you didn't notice that the name was already used in an inner block. Anyhow, even if you notice the error, you still need to find a different name. You already used "path" for a path. What now? "path2"? Yuck.
wow, .eval() that returns a promise! I'm going to have to try this out!
May i suggest comparing the layout and content of say the jquery documentation with your own? It's extremely unapproachable as an outsider with zero knowledge about your framework.
Strong mode looks like a good idea overall. It will be nice to be able to write faster JavaScript for the compilers that support it, and it would still work on those that don't.
Doesn't work in Firefox :(
Sorry but honestly I like to help but your code is totally unreadable the way it is formatted (at least on mobile)
Please edit the description to use 4 spaces before each line of code. This will format it.
I am not good at explaining but you should read http://javascriptissexy.com/javascript-apply-call-and-bind-methods-are-essential-for-javascript-professionals/ and http://javascript.info/tutorial/binding or http://blog.bigbinary.com/2011/08/18/understanding-bind-and-bindall-in-backbone.html But basically: # What is the difference between call and apply anyway? They both call the function? The main difference between call and apply is that apply accepts an array of arguments. Should you have a function like: function mixColor(color1, color2) You can call it like mixColor.apply(undefined, colors) mixColor.call(undefined, colors[0], colors[1]) While still allowing for mixColor(red, green) instead of mixColor([red, green]) There are also situations you might use it for variable length arguments, etc. # But that was not my real question, when the heck do you want to apply scope, why not pass in data??? Imagine this situation: var person = { name dateOfBirth function notifyBBQReady() ... function BBQReady() ... } and you have a function which calls: somelibrary.cookburgers().done(person.BBQReady) when changeName is called from the promise, it will not have the "this" argument being person. If you use data like you suggested when I ask for "this.name" or call this.notifyBBQReady() it does not work as the "this" is not pointed at the person. If I passed "person" in as data I have to always use "person.name" and "person.notifyBBQReady()" and I can never call "person.BBQReady()" from within the object without using it differently from a regular method on the object. So you can do something like: somelibrary.cookburgers().done(function() {person.BBQReady.apply(this, arguments)}) and the proper scope will be contained. You have also likely seen it used in examples like this: ParentClass.prototype.somemethod.apply(this, arguments) This is how folks say to call the parent class method, etc. In short, imagine this: function dosomething(callback) { .... callback() } quitButton { function successstatus() { this.$el.css('color', 'green'); } } dosomething(quitButton .successstatus) Will not work correctly but: dosomething(function() { quitbutton.successstatus.call(quitbutton) }) will and dosomething(quitbutton.successstatus.bind(quitbutton)) also will In shorter: In javascript, any time you call a method on an object without the actual object as the context you get into trouble..but javascript being used as an OO language you often want a proper "this" instead of passing data around to every call you make. 
What fiasco? The one where they said they were making some breaking changes in 2.0, and they they couldn't provide an upgrade path at the time because angular 2.0 was not completed yet? That same one where, last week, at ngConf, they gave a huge number of details on the upgrade path and promised to be more clear in the future? The same one where they said the Angular 2.0 router would support Angular 1.x components so you didn't have to upgrade your entire app at once? Oh right, the completely manufactured "fiasco" by people who don't even use Angular or were just trolling for page views? Yeah... 
&gt; The same would happen with globals. Ergo, globals are fine! No... the scope is not even close to the same. Globals are/can be changed and updated by anyone, anywhere, at any time. Function level scope requires redefining the function to modify the variable. The only way to modify a variable in a function is two write it into the function.
Babel just preserves the semantics. It doesn't matter if that variable exists outside its block if it isn't accessed. The compiler won't let you access a variable outside its block. Dart2JS works the same. It renames the variables to avoid collisions in function-scope-land.
I had a lot of Loading... when I visited on my phone (3G at the moment, in the office) and after waiting a minute or so everything seemed to show up.
I've been developing for the better part of 30 years. I've used every type of scoping (From an old TRS-80 BASIC only global to COBOL Mainframes to Python LEGB to C# with block scope) and I don't believe function scoping is a big deal. If you have a problem with functional scope, you are making your functions too complex.
&gt; If you have a problem with functional scope "This stuff isn't hard. It's just annoying." But let's go back to the original statement. Do you *prefer* function scope over block scope? If so, why?
If the new stage didn't just flash into being after the previous was wiped away, I could believe that each transition was a train tunnel.
I never said I prefer it. I said it's literally never been a problem for me. It doesn't matter to me. I don't use `i` outside my for loops, and I don't purposefully hoist variables to use outside local blocks so I never run into problems with functional scope.
Picking your own technologies doesn't mean rebuilding everything from scratch for every project. It's trivial to create a boilerplate of tools that you use over and over again. The point is that it's yours, built for your needs, using tech that you've vetted personally and that you can extend your own way. You're not wasting time trying to figure out how to make someone else's choices do what you need. (And no, this is not NIH, you're still using other people's libraries) 
I've used Ramda before when I was going through a FP seminar, and I loved it a lot. thank you for all the resources, I have some hardcore reading to do this weekend. Ever since I have learned about FP, I have fallen in love with it but I am still in the process of being able to properly articulate why it's an improvement. These resources should help me towards that goal. Much appreciated good sir! This subreddit has proven to be much friendlier than I expected towards this end.
The chat site breaks the back button FYI
Hi /u/ftomassetti, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
This is a great example of how to showcase your own work on /r/javascript: * repo link * list of libs used with links * opinion of libs used * call for feedback Thanks!
have you tried using CSS transition? for example: transition: width 2s; 
Why it uses Promise/callback interface? Why not just return calculated result synchronously?
I like that!
First off, you can't animate the display property. You can animate opacity if you want, but that's up to you. If [your supported browsers handle the transition property](http://caniuse.com/#search=transition), this is very easy to do that way. /* CSS */ #middlehead { margin-left: 70em; width: 1.2em; transition: width 0.33s; } header { transition: margin-left 0.33s; margin-left: 70em; } header.middlehead-hover { margin-left: 55em; } #dividend_count_up { display: none; } #middlehead:hover { margin-left: 55em; width: 17em; } #dividend_count_up.middlehead-hover { display: block; } // JavaScript $("#middlehead").mouseover(function() { $("header, #dividend_count_up").addClass('middlehead-hover') }).mouseout(function() { $("header, #dividend_count_up").removeClass('middlehead-hover') }); If you can't use transitions, or need fallback behavior, jQuery.animate can manage it as well. $('#middlehead').mouseover(function() { $("#dividend_count_up").css('display','block'); $("#middlehead").animate({'width':'17em'}, 333); $("header").animate({'margin-left':'55em'}, 333); }).mouseout(function() { $("#dividend_count_up").css('display','none'); $("#middlehead").animate({'width':'1.2em'}, 333); $("header").animate({'margin-left':'70em'}, 333); }); *In general*, CSS transitions are going to be faster/smoother than jquery.animate. There's other JavaScript animation systems out there that are closer in speed. In practice it may not matter. Personally I've found CSS-based transitions easier to reason about / work with in some use cases.
Pretty cool! Might want to check out using D3, or one of the libraries built atop it, to generate your own charts -- it's both fun and a good thing to know.
And when something already suits your needs? Your entire argument is do it my way (your way) or do nothing at all. That is completely ridiculous and down right stupid. I, and many others, have found tools that suit us that we did not have to invest hundreds of hours (at the least) in the front end because someone else thankfully did that for us. You want to write your own boilerplates for each use case? Go for it. I'll leverage that time saved providing users with a better experience and researching my product to provide my clients a better return. Good luck to you in your ways.
cool, nice work! 
That's a great suggestion, thanks! There are things in the works for running sets of expressions over the same context, but not yet the reverse. Will definitely chew on this!
It's because you are redirecting to /home at /, so when you hit back, it goes /home to / and then / redirects to home again. Nothing to do with angular.
Yep, there's absolutely no need for jQuery. CSS is not only sufficient, it'll also do the job better.
Wow, objects man. OBJECTS! I've dreamed and thought in objects since childhood lol What a joy to finally get to work with these tree orientation data sets! I love the method you taught me of creating objects with multiple values and then using other dynamically pulled values to trigger values of an object by...... you get it. This is awesome, thank you. I still get mixed up between objects and arrays and their notation but I've made huge strides. Thank you.
This sounds amazing and I installed both but couldn't get either to work. I put my script in and set it to load on the right page, when the page loaded I'd get the tapermonkey console log output but nothing would happen in the DOM. I tried looking around for solutions but I couldn't even figure out which problem I should be solving.
Yes, the main thing is that the code is posted. Or, if you were the author, you could comment about how you wrote it, what libs you used, etc. The main thing is that submissions that are only the end-result need some supporting information. Please feel free to repost, and you can still post the link like you did, just add a comment with a link to the source or whatever. Thank you! edit: [here's a good example](http://www.reddit.com/r/javascript/comments/2yn5ww/i_made_a_thing_react_013_immutablejs_and_es6_via/)
When using userscript you have to forget about window.onload() and $.ready(). Maybe that is the problem (they never trigger)
&gt; Would you want even finer scope? Would statement-level scope offer you any advantage? How's that supposed to work? &gt; With folks so excited for block-level scope, it must offer some significant, tangible, advantage, right? What is it? You can declare your variables on first use like everyone does with Java, C#, Dart, and so forth. Some people like to pretend that they have block scope with ES3/5, but they have to keep track of all variables or use a linter which checks this. However, this doesn't seem to work very well since I see JS code with redeclared variables all the time. Declaring all variables at the very top of the innermost function is evidentially the more robust way to deal with function scope's shortcomings. let callbacks = []; for (let i = 0; i &lt; 3; i++) { callbacks.push(() =&gt; i); } console.log(callbacks[0]()); // 0 instead of 3, i doesn't exist But feel free to continue to use var. I don't actually care what you do.
The reason it triggers an error is simply because: function poll(cb) { // &lt;-- I expect 'cb' (a function) as an argument cb = cb || function() {}; // We can set the "default" value for this argument. So if not given, set to an empty callback function to supress errors. if ( !queue.length ) { cb(); // &lt;- And if you do not give poll() this argument I will spit out an error here return; } ... } I think your code looks just fine. The only thing I can't get my head around is why you add the stylesheet with JavaScript when you can simply use: &lt;style type="text/css"&gt; .YourCss { goes: here; } &lt;/style&gt; In this case it does not actually matter how it looks, it's just a small script. If others are working on it I'd suggest adding some comments or something to explain **how** it works. Other than that it's not much one can do when using jQuery. It can get pretty "ugly", for example: $productPageProcessing.find("span:icontains('Size')").parents().eq(2).find('.productAttributeValue div').html(); It was a good experience though ? ;)
Give your product title h2 a class name. &lt;div id="ProductDetails"&gt; &lt;div class="BlockContent"&gt; &lt;h2 class="ProductName"&gt;Product name&lt;/h2&gt; &lt;h2&gt;Some other thing&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;
There are a couple of ways you can do this... A. Check to see if HelloWorld is defined for the current scope: if (this.HelloWorld &amp;&amp; 'function' == typeof HelloWorld) { HelloWorld(); } B. Wrap the call in a try..catch block; try { HelloWorld(); } catch (e) { // Handle an error you sort of expect if (e instanceof ReferenceError) { // Do some alternative } else { // Just because you shouldn't swallow errors you don't // know how to handle. throw e; } } 
did you really mention php? lol. More resilient? Well I'd take Node's crashing on error any day over PHP's lame method of execution. Python is the same way as node, so I am really not sure why you mentioned it and why people are upvoting you.
&gt; php due to its maturity suck less when you need some CRUD app yeah, the language which standard library can't even get a normalized method names after being used in production for 20 years. Sucks less. The bullshit is strong with this one.
Very much +1, I wound up needing something very similar to this in Go, and ended up writing an expression evaluator in the same [vein](https://github.com/Knetic/govaluate). I can't upvote safe evaluators enough in any language.
&gt; You're in the minority. Yes. Which is why I asked what made it useful. The answer is apparently "nothing". &gt; you also said that type coercion is super awesome. Yes, for good reason. It's why virtually every language includes type coercion. From Javascript to C, developers have been enjoying the benefits for decades. It's only recently that we've started seeing complaints about it. Though I suspect it's just normal 'language war' nonsense reduced to absurdity. I'd challenge you to find a language without type coercion. I can think of two off-hand, but only one in common use. Interestingly enough, its lack of type coercion actually makes it a bit frustrating to use, though it has a *very* good reason for not doing so.
&gt; The answer is apparently "nothing". The answer was locality. Variables exist for fewer lines of code. All the lines &gt; the lines of one file &gt; the lines of one function &gt; the lines of one block. Anyhow, I totally agree. If you ignore all downsides, there are no downsides. How very convenient! ;D
If the element you want to select is an h1, then change your selector to h1....
Amazing experience. Truly an awesome learning experience. I certainly won't forget this as it's pretty much my first time working with somewhat complex JS. Thank you for helping. lol the javascript injected style is kind of a goof at this point. I was originally going to end up putting all of my JS widgets (almost a dozen distinct features at this point) into one concise JS file. I think this would be faster in general, as I understand, no? On some pages I end up appending like 5 style sheets to the head. Is this bad performance wise? Also, I can't figure out how you figured out this .post method data retraction magic... var args = {action:"add", w: "getProductAttributeDetails", product_id:670}; //args.attribute[260] = 188; $.post("/remote.php", args, function(response) { console.log(Object.getOwnPropertyNames(response)); }); Particularly I am trying to figure it out to retrieve some basic product info, specifically "categories." I also found this product.js: $.getJSON( '/remote.php?w=GetVariationOptions&amp;productId=' + productId + '&amp;options=' + optionIds, function(data) { // were options returned? if (data.hasOptions) { But after days of trying to figure out some pattern from what you did, I still have no idea how to make it work. Also i noticed that here, w=GetVariationOptions, so there are other "methods" of W other than I found this sweet functionality: Object.getOwnPropertyNames(response) But it doesn't help as I end up getting nothing or null. Where I know we have "success" and "details" as methods, I can properly write the function to return those. But I can't figure out how you crafted it to be useful. Do you know if it's possible to retrieve all public info about a product, or at least just the categories, via this same $.post method? I found [BigCommerce's documentation for PHP, Python and Ruby](https://developer.bigcommerce.com/api/stores/v2/products) (PS: I am going to start learning to be able to write some apps for BC and other platforms, thanks for reading my life story :P ) and it gives instructions and method and attribute names, etc for their API, but I have no idea if this can be applied to the JS method, and upon trying some things, I've made pretty much 0 progress.
Is there some sort of practical application for this? I must be missing something.
That's quite a comprehensive list! Definitely going to try some tomorrow. 
Well aren't you a ray of sunshine.
I'm curious why you manually implement shouldComponentUpdate vs using PureRenderMixin?
Embarrassing as this is, I made the rookie mistake of not googling the name before I took it. Despite the acronym standing for practically the same thing, this was not inspired or influenced by Apache JEXL at all. Under the hood, it actually bears more resemblance to [jsep](http://jsep.from.so) than JEXL.
Ah, some how I glossed over you using ES6 classes vs React.createClass. Thanks for the explanation! 
Hey, thanks for checking it out. :) Yep it certainly adds complexity. I hope there is some other cases where that complexity is less than the current alternative i.e. where you are swapping arg values or validating all the parameters of a config object. Not for use in your average web project that's for sure. But I hope other libraries could leverage this. I wrote it because I started working on another library and I got to the stage where I was fudging all the arguments around and type checking at the start of my public function bodies. And I was like, screw it, lets add overloading. 
Nice use of labels!
Hi, thanks mate. Anything specifically that you don't like? The code itself or the design? This was just about entirely in my brain 24 hours ago - so I accept that the idea/execution is immature and could and may well go in an entirely different direction. Or if you think my code sucks, that's fine :P
you'll get an upvote but only because you went into the danger zone.
Try taking a look at FRHTTP. It encourages small functions and is designed around code reuse. Best of all it can work with express. (disclaimer: I'm the author of saidd package) 
He uh... Is good at pushing the boundaries of the language http://www.2ality.com/2011/12/fake-operator-overloading.html?m=1:p pretty sure that's him anyway. He's got some great stuff out there 
Lana. Lana. LANAAAAA.
Check out RequireJS. You can asynchronously load some JS with a callback.
not much choice here, want to use ES6? if you do it now, you'll have to use a transpiler and stick to it because I can guarantee you no transpiler implements all ES6 features exactly like the spec says it should. So your "ES6 now" code will be stuck into transpilling for ever, at least in the browser,or you will break the web,in 1,2,3,4,5 years... 
Danger zooone!
I was curious what it would take to write an `isNumber` or `isNumeric` function. So far it seems like a loose equality check with the result of `parseFloat()` is a pretty good indicator if the value is numeric: function isNumeric(value) { return parseFloat(value) == value; } function assertTrue(value) { if (true !== value) console.error("Expected " + value + " to be true."); } function assertFalse(value) { if (false !== value) console.error("Expected " + value + " to be false."); } [1, '1', 0, '0', 0.123, '0.123', -1, '-1', 1/7, Math.PI, Infinity, -Infinity].forEach(function(numeric) { assertTrue(isNumeric(numeric)); }); ['foo', '', '1foo', null, false, true, undefined, NaN, new Date(), {}, {foo: 'bar'}, [], ['anything'], /regex/, function() {}].forEach(function(notNumeric) { assertFalse(isNumeric(notNumeric)); }); 
Any solution that results in the expected behavior is fine by me, but if I were asked this in an interview I'd want to include some kind of unit tests: function fizzbuzz(value) { if (value % 15 == 0) { return 'fizzbuzz'; } else if (value % 3 == 0) { return 'fizz'; } else if (value % 5 == 0) { return 'buzz'; } return value; } function assertEquals(expected, actual) { if (expected !== actual) { console.error("Expected " + actual + " to equal " + expected); } } [15, 30, 45, 60].forEach(function(value) { assertEquals('fizzbuzz', fizzbuzz(value)); }); [3, 6, 9, 12, 18, 21, 24, 27, 33].forEach(function(value) { assertEquals('fizz', fizzbuzz(value)); }); [5, 10, 20, 25, 35, 40].forEach(function(value) { assertEquals('buzz', fizzbuzz(value)); }); [1, 2, 4, 7, 8, 11].forEach(function(value) { assertEquals(value, fizzbuzz(value)); }); for (i = 1; i &lt;= 100; i++) { console.log(fizzbuzz(i)); } 
Meh - lemme know if you want some more to add! Unless you want to keep it short - then I'd have some to recommend removing :) I'd say it's 80% there 
firebase already did that.. didn't they?
Kara Ericsson from open table has an amazing talk about this and the way they do it. Can't find it on mobile but look for it on ngconf videos 
&gt; no transpiler implements all ES6 features exactly like the spec says it should The Traceur and Babel teams appear quite serious about maintaining spec compatibility. FWIW, Babel's class transformer was completely restructured to generate inherently slower code in the interests of matching recent spec updates around super and class method enumerability. With such efforts on the parts of transpiler writers, one would hope any future code modifications would be minimal.
This is interesting. I've been looking for a good system that will allow some data entry people to apply transformations to data in a CSV file (loaded into the browser) before ingesting it into a db. 
I totally agree with you about Angular, but this is the opposite case. I suppose my philosophy is that modules should to as small in scope as they can be, but *without* needing the user to ever write boilerplate. Because if a user has to write something every time they use a library, then it can and should be integrated into the module's core. 
While style guide being used to write the code in post as well, post adds new notion of always using directives (as components) instead of wiring controller to template in ui-router state and what it will take to convert that code to Angular 2.0 syntax when its available
That's no news, regardless of all caps. Also, I'm not sure if they want to aid JavaScript development or enable the NSA to steal our data with more ease.
Or you could use a testing framework that mimics the DOM, like Jest.
In the react example you should NOT set the state property directly (this.state.firstName = "bad code") but simply do a setState in 1 call, also there is no point in putting something computed in the state : this.state.firstName = this.setState({ firstName: this.refs.firstName.getDOMNode().value, lastName: this.refs.firstName.getDOMNode().value}); And in the render : Full name: {this.state.firstName + " " + this.state.lastName}
Nice idea but I can't help but feel a simple Docblock comment above the function definition would suffice to explain what args could be handled. Sorry if I'm being stupid and missing something :)
Simplified version of the React example which doesn't store derived state and doesn't require manually extracting data per-field: http://jsfiddle.net/k5d6jhhb/3/
Would be more interesting if it included nested lists.
&gt; Am I right in saying that this means you can create unit tests in node completely without the view layer? This was what really drew me to Flux when I started playing around with it. You can test the Actions/Action creators and the Stores parts completely independently from the UI, and again independently from each other. The UI (in the best case) should only be firing these Actions. That last part, unfortunately, is sometimes hard to do when you use react components that aren't really built with Flux in mind. Edit: also, a lot of prebuilt Flux frameworks come with their own pre-mocked Dispatchers and Stores, so you can use them out of the box.
In some cases, there are reasons to do that. If your are a service provider, e.g. for mail, not being indexed is practically a requirement. If you are actually delivering an app that does stuff with JS, that's no problem either. Even though archive.org can't do your backup for you, JS interaction is what your product is about. Here's the big "but": BUT if you are just displaying public content, if you cannot do it in an interoperable, accessible way, better don't try to do it at all.
Nobody is forcing you to use ES6 **RIGHT NOW**!! From an application and product perspective there is nothing limiting your capabilities in ES5.
&gt;Ember.JS introduced "{{}}" syntax It's a Handlebars specific syntax. Ember is just making use of it. 
I tend to only write javascript when I have too (I have a basic grasp of AngularJS) so thats an interesting comparison. What ARE they thinking with angular 2.0 though? I want a framework that makes my life easier, not one that exponentionally increases the amount of code I have to write to perform simple basic tasks! Aurelia.JS looks nice though.
Regarding the difference between User() and new User(), ES6 classes are invulnerable to this error. So there's that. Personally, I like how using functions *feels*. Not really sure why. Just feels more "right" in JavaScript to me. That said, with ES6, React, and Angular, it feels like we're moving towards more, not less, use of the new keyword. I probably won't try to fight against that.
My bliggest complaint about the new keyword is that it's a complicated mess trying to call `.apply` on a constructor function. Off the top of my head I think it was this Ctor.apply(Object.create(Ctor.prototype), [my, array, of, arguments]); And I forget if this does something bad to instanceOf. But the jresig trick of protecting a constructor from misuse doesn't scale well with this. While it's nice to have classes in typescript, I more often than not have static factory methods to go along with a class to give myself flexibility in creating objects.
Hah!
Oh, you might be right.
Come along if you'd like to learn how to build beautiful user interfaces using one of JavaScript's most popular libraries! It's going to be a great evening :D
sadly ES6 classes fairly explicitly don't allow you to do this, also for extends you can't do much better then the [node.js one](https://github.com/isaacs/inherits) (link is to version that was pulled out and made to work with older browsers).
I just removed the duplicated part. Thanks !
Because it feels more functional and rightly so. I tend to avoid `new` if I can too. 
I'm pretty sure that's not how actual code using Angular 2 is going to do it.
Just look at it from the other direction. If you need a loop counter, why should that loop counter exist for the whole function? Inside that loop you create a Button instance, configure it, and add it to some container. Why should that button variable exist outside of that loop? In a branch, you create a temporary variable for swapping two items inside an array. Why should that temporary variable exist outside that particular branch? If you actually need those variables in the block above, you can just declare them one block above. &gt; It's why I asked if statement-level scope would be preferable No, you did that because you thought it would be funny.
&gt; Consider using it for your next library. Consider using ES6 classes for your next library or framework.
Thanks ! I just replace from the bad lines, where this.state is directly set, to calling setState().
I've been using VueJS in my most recent project. I'm glad to see it included and I agree with the OP's comments. It's awesome, especially for small projects.
&gt; If you need a loop counter, why should that loop counter exist for the whole function? Yes, I understand that. The question is: "how does that advantage the developer." You asked "Why should that temporary variable exist outside that particular branch?" I say "why not" and "what difference does that make?" It has no impact on the developer, surely, and no impact on the function. It's completely irrelevant. &gt; No, you did that because you thought it would be funny. I think that makes my point quite nicely. If the justification is that finer-scope is always preferable, then it stands to reason that "statement-level scope" would be preferable to "block-level scope". (I could even use the same argument to justify the 'importance' of statement level scope, after all.) It's silly, of course, but the argument was silly in the first place. My contention, further illustrated by that point, is that there is a point where finer scope offers you no benefits. Equally, I don't see any actual benefits to block-level scope, just as you don't see any advantage to "statement-level scope". That's not to say that block-level scope is harmful, on the contrary, it's merely unnecessary. With all the excitement surrounding it here, I expected some significant advantage. I expected to see some need that block-level scope fulfills. From the responses I'm getting here, it seems people what it for some nebulous philosophical reasons or because they *believe* that it's important without knowing why.
Yeah I did think of that, but it requires adding 1 in four places, which didn't seem very elegant.
Aurelia.JS makes me cringe looking at their use of periods in html tags. 
So maybe I'm just missing something, but I don't see react actively harming the 'open web' as the author keeps harping. It is using open standards to build it, and it is all written in javascript. It's not like DRM in the browser.
I don't know where you get this information from, but I think that's not true. The new structure comes from ES6 and typescript, people should at least get familiar with ES6. The changes to the change detection are in a lot of ways an improvement to angular 1, sure you need to write a little bit more code, but the developer has a lot more control and getting rid of the unpredictable digest cycles made angular significantly faster.
Yea good point. How about change the first `i` to `++i`?
While I agree with the sentiment, I feel the article is a little disingenuous. Last I looked, web components worked but certainly weren't production ready (unless your target is high end PCs using Chrome). The polyfills were large, slow, and flakey. That has quite possibly changed in the last couple months though. There's also certainly room for both web standards and workarounds. For better or for worse, I don't think the web would be where it is if weren't for people breaking it.
I agree. 'new', along with constructor functions, are without a doubt, one of the bad parts. I suspect they were only added to make it look more like Java. I also avoid using 'new' as much as possible. 
&gt; I say "why not" That doesn't answer my question. If function scope would be preferable, there should be at least one reason. http://en.wikipedia.org/wiki/Principle_of_least_privilege Ever heard of that? This is similar. &gt; It has no impact on the developer, surely, and no impact on the function. "Variables exist for fewer lines of code. All the lines &gt; the lines of one file &gt; the lines of one function &gt; the lines of one block." Block scope is a lot more convenient. If you're familiar with a block-scoped language, you should have experienced that firsthand. If you need some variable, you just create it. It won't affect a variable with the same name in any of the blocks above. That's why "create on first use" works fine. I really don't see how that's a "nebulous philosophical reason". It's a very practical reason. Need to iterate over 3 items? Just use 'i'. This will even work inside another loop which also uses 'i'. You only have to use another name for that counter if you want to access the outer one, too. At any given time, there are fewer variables floating around and you only have to mind those you're actually using in this block. It's a much simpler mental model. That's why every modern language does it like this. If you still don't understand this then I'm sorry. I'm giving up.
He's suggestion is to use Web Components, but support for that is extremely limited, and the polyfills are a small clusterfuck. Our company still has to support IE8. With React+Babel+Webpack, we can write modular JS using (most of) the features of ES6 and still support our paying customers.
I don't know if I agree with this article. Sure in theory it is great if everyone works on the same thing and develops it further. But at some point you are stuck. Every new idea is bad because that's not the way we do things. I actually like that there are multiple solutions to the same problems and that they push each other. I also like the constant change in this space, but I guess that has something to do with me not working a full time job in this field.
&gt; If function scope would be preferable, there should be at least one reason. I'm not advocating one over the other. I'm saying that it's irrelevant. &gt; Variables exist for fewer lines of code. All the lines &gt; the lines of one file &gt; the lines of one function &gt; the lines of one block. So you do think that statement-level scope is a good idea! Variables exist for fewer lines of code. All the lines &gt; the lines of one file &gt; the lines of one function &gt; the lines of one block &gt; a single-line statement. &gt; Need to iterate over 3 items? Just use 'i'. This will even work inside another loop which also uses 'i'. Actually, that's a reason why block-level scope is a bad thing. Don't do that. You're here to tell me what advantages it offers. &gt; At any given time, there are fewer variables floating around and you only have to mind those you're actually using in this block. Well, that's not actually true. See, the block has access to variables declared outside the block. You gain nothing there. &gt; That's why every modern language does it like this. Some languages have block scope, many others do not. It's also not a justification for block scope. It undoubtedly fails to answer my question: "How does block-scope benefit developers?" 
&gt; React's design is bad. I could give you a lot of specifics‚Äîseparation of concerns, coupling views with models... https://www.youtube.com/watch?v=x7cQ3mrcKaY &gt; the focus on needless optimizations... This has nothing to do with the design of React. Optimization is a concept that transcends any given library or framework, and a focus on it is a project / business level decision. Also, Convince my customers or our devs who do benchmark testing that these optimizations are needless. This stuff works fast and it works today. &gt; the importance of supporting open standards. This also has nothing to do with the design of React. That's an ideal, and I can care about that in the open source work I do in my spare time. Supporting web components isn't going to help my business meet its needs right now. Facebook has proven to us that React works well at large scale right now, and supports a wide range of browsers that (believe it or not) people in the real world really do use. This article seems like a lot of dogma and idealism without a ton of substance to me, quite frankly. I doubt strongly that the author has experience with a non-trivial React application. Had they, I think they would have expressed certain thoughts a little differently. Statements like this: &gt; The solution to the problems on the Web is never, ever going to be to tightly couple presentation, behavior, and data. Your Web apps will ultimately become unmaintainable hair balls of unreadable code. Everything in my own experience, and the experience of other people I know using React (especially with the Flux pattern) in production says that this is nothing more than a baseless assertion. That said, everyone is certainly entitled to their opinion, and so this comment is more or less just filled with my own.
This is what I get (my node version is: v0.10.31 on OS X) &gt; requested 9 &gt; requested 8 &gt; requested 7 &gt; requested 6 &gt; requested 5 &gt; requested 4 &gt; requested 3 &gt; requested 2 &gt; requested 1 &gt; requested 0 &gt; 9 #status# 200 &gt; 8 #status# 200 &gt; 6 #status# 200 &gt; 5 #status# 200 &gt; 7 #status# 200
You are missing ExtJS!
Agreed. So many of these articles are one of: * "You're using ___ wrong." * "___ is terrible." * "Why aren't you using ____ right now?" etc. etc.
I'm definitely going to look into Aurelia now. It looks so clean and simple compared to the rest. 
Here's a better version for React.js: http://jsfiddle.net/k5d6jhhb/7/ IMHO React reads much more linear, making sense from top to bottom. It doesn't require your thoughts to travel back and forth to understand what the code is doing.
Starts here: https://www.youtube.com/watch?v=AbunztfV5vU&amp;list=PLOETEcp3DkCoNnlhE-7fovYvqwVPrRiY7&amp;t=583
&gt; Yes, I invented "statement" scope to point out the problem with that argument. Nah. You just tried to be cute and I pretended you said something meaningful. &gt; No one seems to know. Yes, as I said, if you ignore the downsides of function scope, there are indeed no downsides. Ignorance is convenient like that. I'm not really sure why you're so fixated on this outcome, but if that's what you want I can't really change it, can I? &gt; But you don't finish that. How does that obvious feature offer you an advantage? If they cease to be, I don't have to remember them. It's a much simpler mental model. You don't have to take the things which don't exist anymore into consideration. That's the same advantage as function scope has over file scope. It provides a simpler mental model where you have to remember less crap. Declaring variables on first use is super convenient and with block scope there are no downsides to this.
My thoughts exactly. Calls to support an "open standard" were met with CanIUse saying: "[not really](http://caniuse.com/#search=components)," with Firefox out and out saying "[no, at least not until we see a better spec](https://hacks.mozilla.org/2014/12/mozilla-and-web-components/)."
This looks nice, but doesn't work for me.
And that's the best part of the web: the ecosystem is continuously evolving, trying and mixing things
Honestly the author have some points in this article. If you don't see them then I suggest you to take a step back look at Angular hystory and compare it with React. Obviously you can do a lot of things with react. That doesn't mean that the philosophy is correct, as, you might want to do a lot of things with assembler too. Things you can do is nothing. Performance are only important now: that performance issues you have now will disappear in two years. The important point is how maintainable a project is? How scalable in terms of team member a project is? How backed a framework is. That means you will need to wait at least a couple of years to see is React is an interesting framework. To see if it was good enough. In the meantime React is a well though giant PoC, nothing more. Just to be clear I think of angular on the same level. They are patch needed to allows web standards to form and mature. It is a similar phenomenon as Sping vs CDI in the java world: JEE is inflexible, let's build a framework that solve the problem. This framework is great! Hey let's insert the framework features in the new standard. The new standard is definitely better as it is supported by every one without dependency hells of any sort. It's so simple and we, as developers, engineers and architects need to reflect deeply on this: as take shortcuts and working around are useful practices as far as you are aware of what one is doing. 
Yeah I didn't understand where he was going with that. My guess would be that react's features were built into a library/framework and not the browser itself.
I can't image doing anything graphical without a graphical context. The annoyances of css/html kinda make me want to do everything in a canvas sometimes (a-la original autocad).
I get the part about Microsoft more now, they don't support HTML Templates in IE. I think this is what Web Components use based on other comments. But can anyone tell me how far along these HTML Templates or Web Components are in the standardization process?
I should probably mention I'm really, really new to doing anything besides static webpages, haha. I think the article teaches a lot, and is still good. But the game doesn't work for me. I don't know enough to understand why.
Sure. - [gulp-plato](https://github.com/sindresorhus/gulp-plato) is depreciated - [gulp-requirejs](https://github.com/robinthrift/gulp-requirejs) hasn't been updated in a year - all the dependencies are out of date. I'd call it dead - (and requirejs too..) - [gulp-browserify](https://github.com/deepak1556/gulp-browserify) says this in bold letters on the page: **NOTE: THIS PLUGIN IS NO LONGER MAINTAINED , checkout the recipes by gulp team for reference on using browserify with gulp.** - it was blacklisted one year ago (almost to the day) - [gulp-removelogs](https://github.com/hemanth/gulp-removelogs) is also depreciated I haven't tried all the links yets - those are just what I know off the top of my head as depreciated. I'd recommend going through them all and deleting unwanted modules and switching to the modern equivalents if they offer. There are a lot of good ones on the list I use on the reg too, so I felt like sharing a few extra as well - - [https://www.npmjs.com/package/gulp-html-tag-include](https://www.npmjs.com/package/gulp-html-tag-include) - this one is a GEM - stumbled upon it by accident - but maybe one of my favorites - [gulp-ext](https://www.npmjs.com/package/gulp-ext) - can't live without it :) - [gulp-livereload](https://github.com/vohof/gulp-livereload) - Probably to browser-sync - I've never used browser-sync (it looks cool) - but i've used livereload for over a year - and it's fantastic - [gulp-postcss](https://www.npmjs.com/package/gulp-postcss) - this ecosystem is growing fast and insanely customizable - (the autoprefixer library you mention is just one subset of the postcss world) - [gulp-tap](https://www.npmjs.com/package/gulp-tap) - SO.. I end with gulp tap. This library is what you want to use when you want to do whatever the hell you want. I've actually built entire build files with gulp-tap replicating the functionality of every plugin I've used in gulp. It's meant for custom builds - or if you're impatient waiting for the gulp-plugin to keep up to date with the underlying library (they could be out of town, who knows?). Gulp-tap gives you simple, easy, access, to whatever the hell you want to do with this library. If the plugin works, use it. But know this - 90% of plugins are 10-20 lines of code - they're easy to write. The underlying libraries do all the work. Gulp-tap takes away the middle man. Also - if you use browserify, don't forget [https://www.npmjs.com/package/vinyl-source-stream](https://www.npmjs.com/package/vinyl-source-stream) and [vinyl-buffer](https://www.npmjs.com/package/vinyl-buffer). I wouldn't call them plugins - but they're necessary for using browserify at the moment. Also, if you want to host your own lib on a private NPM - check out [sinopia](https://github.com/rlidwka/sinopia) - please don't pollute the global NPM namespace with a gulp-library (i see so many) - i hope it helps! NAMASTE **Edit: spelling and clarification:** by *gulp-library* - I specifically meant gulp-collection of plugins - I love gulp plugins - but I prefer the plugin collections to stay on github / private repos :)
Oh sure, I have the newest version of Firefox. My only plugins are Evernote Clearly, Evernote and Lastpass. The arrows keys work, and I can move Link around but when I move another screen the image stays the same. The pathing changes because I can walk around different areas of the screen but the actual image is the same. The Tile counter does change correctly. [edit] the version is 36.0.1
Hey guys, I wrote the article and code. Have you tried running it in Chrome? It was really only built with Chrome in mind. If you guys have other questions, I'd be more than happy to answer them!
I completely agree. Best part of using immutable data is that changes the way your views manipulate the data. Since they can't manipulate the data and the changes comes from the top, they are just visual representations of the store. If you like immutable.js API you should try https://github.com/arqex/freezer It is much simpler and lightweight.
I'm glad you included Ractive. I have been using it for 6 months now and really enjoy it.
Usually that means that jQuery is not loaded yet.
Personally I believe there is space for both. There's definitely an argument to be made over which style (trad. forum layouts vs. subreddits vs. feeds) is *more efficient*, but what it really boils down to is how frictionless we can get people discussing. Some examples of friction? * Requiring real names * Requiring registration * Hard to continue discussion past first couple of posts (Facebook comments are awful because of this) * Posts drop off after a predetermined amount of time I don't think forum software is a terrible UX style at all. It goes back to how predecessors of forums used to work (that is, **bulletin boards**): You'd pin a message onto a board, someone would pin a reply. If a topic branches, there's space for both discussions, or if you want to keep discussion linear, you can always fork a topic. Forums give you that ability, but Reddit does not. Just some food for thought.
&gt; Yes, as I said, if you ignore the downsides of function scope, there are indeed no downsides. Ignorance is convenient like that. Well, out with it then. What problem with function scope is solved by block scope? &gt; If they cease to be, I don't have to remember them. It's a much simpler mental model. You don't have to take the things which don't exist anymore into consideration. Nonsense. You've never had to take those things in to consideration. If I've got a loop at the top of my function, I sure as hell don't worry about the sentinel even a single line after. &gt; with block scope there are no downsides to this. No one said there were downsides. I'm looking for an actual upside! Anything, really, to justify the complaints about not having block scope, and the excitement surrounding it. I'm not buying the "mental model" argument. Something concrete, please. An actual tangible benefit. How about a common problem solved by block scope? 
&gt; Can we please put Science back into Computer Science? It was never there. CS is not science in the sense you're using it. It's only science in the "study of" sense. Really, neither actual science nor CS are part of this discussion. The article does not address a computer science related topic. &gt; another post based on feelings and opinions Just like your comment here! You do exactly what you're complaining he did -- making assertions "based on feelings and opinions". While React has almost nothing to do with the post, your immediate *react*ion is to defend your favorite bloated framework and dismiss the entire article. As i said before, the article has almost nothing to say about React. That bit is click-bait. The rest of the article, however, is worth a read, and is surprisingly insightful.
Awesome, thank you!
I'd like to disagree with your definition of 'nothing wrong', considering his compare function doesn't return anything at all.
I think it's cool toot reload my React components in webpack, but I don't consider this the most important feature. If this is your only gripe with reflux it must be pretty good. So far I've enjoyed working with it. I only find it a bit strange that a store can only ever trigger one kind of event. 
Very opinionated article... in my opinion. Frameworks are nothing but a way to entice devs? Microsoft "..looks like a lost wildebeest, wandering the Saharan plains of failed products."? "Meanwhile, Web components are now available in Chrome and Firefox"? :)
try this - https://docs.angularjs.org/guide/unit-testing and this - https://quickleft.com/blog/angularjs-unit-testing-for-real-though/ Remember that the more time you send on writing your test infrastructure and eliminating duplicate code for tests, the faster it will be for you to write more unit tests. Investing the time in doing this will save you alot of time in the long run
Just a heads up, instead of hosting all of your projects for your website in the one repo, you can make separate repos for each project and if you want a route on your github site for that project then you just need to create a gh-pages branch. https://help.github.com/articles/user-organization-and-project-pages/#project-pages
&gt; or if you want to keep discussion linear, you can always fork a topic. Forums give you that ability, but Reddit does not. Could you expand on this? I've seen how people use forums and such and all I can say is, it's a representative of FB comments discussion. Obviously FB makes it harder because they pin your identity to every single post you will ever make but it's similar to the old fashioned forums because it's harder to run a topic down. It's OK if you're all on the same page but it relies on everyone working together at the same time. I say x^0, you chime in with x^1 (even if you're late) and if someone wants to expand on my point, they come in with x^01 and your friend pushes it with x^11. We can all participate without throwing someone off the track. We can easily go to x^0...n before we even get to x^1 (your comment in this case). Old school forums are so much harder to keep track of this. I'm not saying it's bad but for typical forum discussions, it's harder to really have a good discussion with a lot of people contributing. I can't expand on x^01 when someone else is talking about x^32 . It pulls you out of the discussion. The best way I can compare it is with normal human discussions. We rarely jump between topics. We want to feel like it's only been 2 minutes when we've already spent 30 minutes discussing something. That's why I feel like reddit is such a time killer. I can go down a rabbit hole for so long before I even realise what's happening. 
I suggest you take a look at native promises. http://www.html5rocks.com/en/tutorials/es6/promises/?redirect_from_locale=de
Thanks for the shoutout! We (the NodeBB team) used to have a *huge* file containing all of our routes, and our inspiration for cleaning all that up was Ghost's router file, which is quite nice to read through. 
Are you using the twilio npm module? I'm not understanding what the issue you are running into is. If you want to put the function that calls twilio in a separate file you just so module.exports = function () ... and then you can require() it using a relative path. If you want to be able to require it directly as you do twilio it needs to be in a node_modules directory with its own package . json file and then you can just do require('mymodule'). Sorry if that doesn't help, I'm not entirely sure what you need. 
Have you ever wanted a Perl-like ellipses or Python-like pass statement to mark function as todo for later in a C-based language? Roger Poon proposes an idea.
You should try out [jest](https://facebook.github.io/jest/) which bundles a whole bunch of testing tools together including jsdom.
I can move with arrows but B/A/Start and keyboard mashing have no effect.
Very cool and ambitious. I had a similar idea except I went a console generation behind and wanted to convert E.T. for Atari into JS on Canvas and using Web Audio API for sound. I'm working on it really slowly. I'm going to key an eye on your progress cause Zelda is my favorite series (and I'm also a front-end dev that also made myself learn canvas). Can't wait to see more!
Wonder if somebody will use this to create an implementation of an existing language like lisp.
Nice write up, thanks for sharing.
Both grunt-ts and gulp-typescript support incremental building, so you shouldn't have to compile the entire project everytime, but regenerate the js files that change. That in combination with webpack which also supports incremental builds, speeds things up drastically. One thing to point out, I stuck with webpack instead of browserify because I couldn't find a way for browserify to read in the TypeScript source map files. Webpack has source-map-loader, which can. And I would just turn off the TypeScript compiler in WebStorm. Use a build system with watches. You still get the benefit of IntelliSense.
love that design site
Hi /u/lukedary, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Just because there are a few minor bumps on a way doesn't mean you cannot use it, or that it is harmful. Yes, there is room for improvements in developer consoles for all browsers. No, that doesn't mean that we need to chase novices away from something that works most of the time.
Well said dude! I don't know of many sites that are blank when js is disabled. progressive enhancement is the important thing here. 
That's correct, collapsing all was not on my requirements list when I wrote treejo. I'll think about adding it though.
I've written treejo.js for a work project to navigate through a tree with almost 130000 nodes. jumping to arbitrary locations works very well. You don't want to "open all" on such a big tree though. treejo opens &lt;n&gt; nodes and ask for a confirmation to continue in order to not blow your browser up. (&lt;n&gt; is configurable, default: 30) ps: the name treejo comes from [Dany Trejo (wikipadia)](https://en.wikipedia.org/wiki/Danny_Trejo) [Picture](http://theindiespiritualist.com/wp-content/uploads/2010/10/tumblr_l219wh2Xoq1qzp6iio1_500.jpg)
...or graceful degradation. Whatever you choose, make sure your stuff works as intended.
Some tips: * Put as much as possible into services * Avoid relying too much on $scope/$rootScope/etc * Your controller logic should just be 'glue between the view and the service' - there should be very little logic in there * Abstract away $http in your services Lately, I've been tending to do a 'module per service', angular.module('someFeature.service',[]).factory('someFeature', function() { }); Then, typically the first test I write is along the lines of // pseduocode describe('some feature') var someFeature; beforeEach(module('someFeature.service')) beforeEach(function() { someFeature = getService('myFeature') }) // I have a helper function to get a service it('should exist',function() { expect(someFeature).to.be.an('object'); expect(someFeature.function).to.be.a('function') }) Just a bit of a sanity test of - does the test run, can I create an instance of the module. Can also help narrow down on issues where angular blows up on the client side 'cant create instance of X module due to Y ... long error/stack trace' - as you have tests to see 'can I create this module?' TBH - I haven't put much effort into unit testing my controllers - I push pretty much everything into services, and then test those. At times the controller might just be using a 'core' service that is meant to be used across the application. Other times, if there is logic specific to that controller/view/whatever, I'll make a service to support it - and the JS file for that service will live next to the controller/component that it's for. 
Although generators and yield works well, currently with es6 you need to wrap the generator in some form of wrapper to get the async functionality, normally co or something similar. I'm under the impression async functions will handle this automatically. var x = co.wrap(function* () { return yield Promise.resolve(true); }) is equivalent to async function x() { return await Promise.resolve(true); } 
`co` is indeed nice. Link: https://github.com/tj/co
I have found these source of exercises with solutions. http://www.w3resource.com/javascript-exercises/
I just wrote a blog post about this! http://dchao.co/2015/03/09/writing-karma-unit-tests/ My blog post assumes that you've written Karma unit tests before, so if you're just getting started for the first time, you should read this first: http://www.ng-newsletter.com/advent2013/#!/day/19
memory?...
&gt;depends on jquery only That's a pretty hefty requirement.
This was posted yesterday too. It's an uninformed article with regards to what React actually is. "React's design is bad. I could give you a lot of specifics‚Äîseparation of concerns, coupling views with models, the focus on needless optimizations, the importance of supporting open standards‚Äîbut I'm going to tell you a story, instead." It's hard to say which concerns that aren't separated the author refers to, but I've not found this to be any issue. Also not sure what's meant by coupling views and models, but a common use of React is as a view layer only, so there is no coupling to the model. I'd say an optimization is only ever needless if I, as a user of the tool, have to be concerned with it. I don't see people complaining about the React team optimizing DOM updates when they don't have to care about them but just get improved performance. Finally, I'm not quite sure how a cross-platform, open source javascript tool fails to support open standards. Web components may be great and all, but there's no also no reason why they're incompatible with React: https://www.youtube.com/watch?v=g0TD0efcwVg It doesn't follow that just because facebook has a skilled team that they can just fix all the problems related to DOM rendering. Even if they could, there are several browser vendors that would have to incorporate those fixes. There's nothing wrong with doing the best you can with the tools at hand at any given time.
That's ace dude! Thanks for sharing! 
yeah but i also could have used jquery-ui widget factory to solve the stateful plugin problem (options per tree instance on a single page). So I am kind of proud that it only needs jquery. 2 months ago my javascript skills consisted of copy&amp;pasting what the search engine returned.
OK so it's for people who have experience in other languages, but it explains what a variable is?
This could be a good way to give non-devs the power to consume data from various APIs. Google Apps Scripts would allow a dev to set this up one time, and then allow the non-dev to filter / search data in Google Spreadsheets.
This is pretty much exactly what we're using it for. This is made easier with the CORS API we made available early last year, which is really changing how we're writing code at Sprintly.
Right. My point is that you already seem to be using immutable-js http://facebook.github.io/react/docs/advanced-performance.html#immutable-js-to-the-rescue Which should( theoretically )solve the issue that you are mentioning. 
Hey thanks for posting this! I am starting on a project next week that we are using es6 for and a friend of mine actually sent me [these](http://www.2ality.com/2015/02/using-es6-today-minsk.html) videos that you made. They are super informative!
&gt; Immutable data structures provides you a cheap and less verbose way to track changes on objects, which is all we need to implement shouldComponentUpdate. Therefore, if we model props and state attributes using the abstractions provided by immutable-js we'll be able to use PureRenderMixin and get a nice boost in perf. render() always runs, unless you tell specifically it not to React doesn't check if the data changed, it only checks to see if the DOM *should* change. If you want to prevent render() from being called based on data, you have to implement shouldComponentUpdate() yourself or use the PureRenderMixin. A lot of my shouldComponentUpdate's could be replaced by using PureRenderMixin, but ES6 classes don't support Mixins, and I liked being explicit about what should trigger a render.
&gt; A lot of my shouldComponentUpdate's could be replaced by using PureRenderMixin, but ES6 classes don't support Mixins Create a baseclass with shouldComponentUpdate: function(nextProps, nextState) { return shallowCompare(this, nextProps, nextState); } and extend from that ? &gt;I liked being explicit about what should trigger a render. Ok, that makes sense. Thank you for responding to my questions patiently. I am really confused by lot of react stuff :|&gt;
Angular 1 components will work in Angular 2. Not sure where this FUD is coming from. If there are breaking changes you are able to upgrade at your own pace. 
Keep in mind that most/all of those characters will be expressed as surrogate pairs in JS strings, so splitting on the empty string will split those characters into the individual code units of the surrogate pair, which is probably not what you want. You might want to write a short split function that puts the pairs back together, then use the fixed characters for your processing.
I have done some more research on this and it looks like Chrome just might have what you need :) I never actually knew about this, and will definately make use of it! https://developer.chrome.com/devtools/docs/authoring-development-workflow#snippets
Ooh, that looks useful! First thing that comes into my mind is to create some sort of really small automated testing snippet for really small projects. Or maybe a snippet that prints the current state of pretty much everything? Or a always-on-hand XSS / validation testing tool?
http://chariotsolutions.com/blog/post/angularjs-2-0-bold-new-step-typed-js-es-6-without-concerns/ &gt; changes being made to the core Angular architecture will break every Angular application. See this InfoQ article for details, which include removal of controllers, current directive definition syntax, $scope, and more.
You're citing an article pre-ngconf. At ngconf a lot more information was provided that cleared up the FUD. 
Looks great and runs very well
"They're also bad for the entire software industry. For new applications, please, for the love of all things open, use Web components instead." Why do people make these absolute statements and really feel that they hold weight in the industry.
the article is neither about node nor js
Yea, had a lot of fun with that library lately. Easy to use and great effects. 
Yeah, the getters and setters were on the chopping block, but I didn't know about that CSS method. Thanks!
I'm not sure that's something I can look into. I don't really have any idea what that entails but I can get googling. Thanks for reaching out. Any ideas on how to do that?
hmm, i see the library has a DOM Mutation Observer, suppose i want to do for me a userscript that when i open facebook and scroll down, the page is loading and if there is a div block whit a word then hide that div? is it possible? 
Hi /u/justinabrahms, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `sprint.ly`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [sprint.ly](/search?q=%28and+site%3A%27sprint.ly%27+author%3A%27justinabrahms%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|3|75%
Integrated both of your points of feedback. :)
I flipping love javascript without it my website would be only a shadow of what it currently is
JavaScript is a beautiful language (at least a subset is), and es6 helps a ton. Its also a great compile target so I never feel tied to it. I will say that the DOM is an abomination but node js with generators is an efficient and productive server side framework for sure.
&gt; Small set of syntax. Too many languages try to pack features into the language, and result in a mess (Perl, Python, Ruby, C++, etc). You haven't learned ES6 yet, have you? ES6 is a rather complicated language. ES7 will add even more language features.
Thanks you so much you have no idea how big of a help this is. Total/commission %/fee and Total(including commission) are suppose to be buttons (based on my assignment) and pressing the button should make the answer appear in the text box next to it. 
Well that's stupid. Nobody does it that way. Whatever. Guess have to revert to the old copy of the fiddle.
Ok thanks, side note, do you think a function in the script would be useful?
Being able to update the content of your page without having to reload the page is a game changer. When I first learned Javascript (2011 or so) I didn't take it too seriously until I came across AJAX (PHP is my main language) and I realized how powerful it could be when paired up with server-side functionality. And now apparently you can do that server-side functionality with Javascript so I've started burying my head in a *MEAN Web Development* book to try to catch up with the industry.
No offense but this is javascript, it's going to be nothing but functions left and right.
Its just I feel like this so simple and I'm having a hard time with it.
Now you can join Livecoding.tv which is a specialized platform for coders, you can stream and interact with viewers from all around the world via live chat feature. The best thing is that we are specialized for programming/coding...
well it gets harder, javascript does but this looks like a bit much for a beginner exercise.
Thanks lol, is there a way I can make the labels into buttons giving the different reults
I believe Node.js will become more popular. This allows JavaScript to be used on the server side as well as in the browser. And JavaScript offers powerful ways of using functions and object prototyping. As a Java programmer it takes a bit of new learning for me to be able program in JavaScript efficiently, but it's quite fun. Here is what Douglas Crockford has said about JavaScript compared with traditional object-oriented languages: &gt;This language is all about objects; it‚Äôs an object oriented language. I‚Äôll try to demonstrate to you that it is more object oriented than Java. For a long time, a lot of the opinion about this language was that it‚Äôs not object oriented, it‚Äôs object based, it‚Äôs deficient. It turns out it‚Äôs actually a superior language. &gt; &gt;In this language, an object is a dynamic collection of properties. This is quite different than in most of the other object oriented languages in which an object is an instance of a class, where a class has some state and behavior. Objects in this system are much more dynamic. -- http://cek.io/blog/2014/07/21/intro-to-javascript-crockford/
I agree, post ES5 versions make the language more complex. However, I would still say the language is small and focused compared to languages like ruby and java. 
This should get you going: https://developer.chrome.com/devtools/docs/javascript-debugging The built-in debugger for Chrome is amazing to say the least.
Because I'm a web developer. I don't get a choice.
Not true my friend. You have countless x-to-js compilers To choose from. 
Yeahh,.. that's not worth the effort. If I want to debug in the browser I'd have to find extensions that even approach the level of the built in JS debug tools.
Most browsers (Firefox, Chrome, IE 11) already support source maps.
Fair enough. Why dont you just return false on all clicks and then handle them yourself? 
not yet. ;)
Ok I did what you mentioned and finished the rest but nothing is working. http://jsfiddle.net/L6pe4bw7/25/
However,hopefully, I'm on the right track of getting closer to finishing with that attempt.
Firefox has a nice set of tools as well: https://developer.mozilla.org/en-US/docs/Tools 
Thank you for your time and thoughts, I guess I'll just have to write the function. Cheers!
I'm curious as to why you made this a jQuery plugin when you really don't make much use of jQuery? It would take very little effort to make this stand-alone.
I'll agree that there's a lot of needless clutter in ES6 and above. I'm a big believer in that old maxim: "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away." I was hoping that strict mode would allow JS to *shrink* without breaking the web. I was sadly disappointed. It's not as bad as many other languages, but it's getting a bit too messy for my comfort.
&gt;Does that look like something sensible to you? That's not particularly messy. There's not any reason to use `call`, but i'm guessing you were trying for the most obscure code you could think of. `call` and `apply` are features of making functions first-class. I hope you're not in the camp that's still bitter about losing popular support for `with` as a keyword. &gt;The first 3 chapters of the manual (TOC), "Introduction", "Basic Concepts", and "The Language", are only about 10k words in total. That's a compact language. "Sparsely documented" != "compact language". Lua has plenty of inane syntax and features that make it illegible at scale. You need to make macro functions just to *define classes*. Is JS the epitome of a compact language? Surely not. Does ES&gt;5 make it more needlessly complex? Probably. But compared to anything else with any notable adoption its core makes a lot more sense - and it does it without many features at all.
&gt; To that moment I thought about debugging but my idea was that there isn't any debugger because there technically can't be What would be the technical reason preventing a debugger from existing? Didn't follow you there...
When writing and compiling code in IDE, it's one things. When writing code here and launching it there it's another thing. This fact just confused me. By the way, I am not too much in process of compilation and all, so my thoughts about this may sound silly. And it's not so much about it looked to me technically impossible. It's more about "why browser should have ability to do that?"
thanks so, much again I'm just having that problem of converting it out of the jsFiddle into my editor.
This would be shorter by 3 bytes: for(i=0;i++&lt;100;console.log(i%5?f||i:f+'Buzz'))f=i%3?'':'Fizz' (62 bytes)
This is what you want. http://stackoverflow.com/questions/737022/how-do-i-disable-right-click-on-my-web-page Essentially, handle all clicks. If the button pressed is the right mouse button, bail.
/u/klaaax is spouting nonsense. Dart 1.9 will be released soon. It's the biggest +0.1 release since 1.0. Comes with things like async/await/yield/async\*/sync\*, much faster regexp, nicer isolates, and so forth. Lots of good stuff. Traceur is used by Angular 2. They have a single TS codebase which is compiled to JS and Dart.
This is based on [another library](https://github.com/bvaughn/jasmine-promise-matchers) of mine for testing Angular promises. Thought I'd post it here in case it saved anyone else some trouble when it came to writing Jasmine tests involving Promises. :)
Among all the languages I know (JS, PHP, Objective-C, Haskell, a bit of Python, Rust as a beginner) I would say I love JS the most. It's surely inconsistent sometime and a bit strange for the people who come from more 'formal' languages, but it's free as hell. Basically you can write JS in whatever style you want to. This might be a no-no for some people who love rules, but for some others, like me, it's lovable. I love its object model. ES6 class is actually just a syntax sugar for the current prototypal one. And I don't think I will use class oftenly, I like to compose objects myself. One more thing I think is attractive, JS is growing very quickly, new things come out everyday. Like, I just learnt last week that ES7 will have async function, which is a syntax sugar for generator. Nice! Andddd.... I don't know why many people hate JS so much. 
Angular 2 is moving to typescript,so no traceur isn't used by Angular 2 anymore.
Have you done any performance testing? IIRC in many cases simply filling a 1x1 area with `fillRect` is a lot faster, but if you're doing a lot of single-pixel changes at once this might be a better approach. Just a suggestion, for the sake of presenting the example, I think the `_` function just clutters it up.
&gt; You have countless x-to-js compilers To choose from Exactly... we're stuck with it.
Hi @TMiguelT Here is my opinion (cause i just learn a bit about Flux - not Reflux). 1: you're right about what "updateList" does, why we pass the list as the callback because in the "View", "Store" has no idea which data gonna be used, but "View" does, so we pass all the list data we have and let "View" decides what it wants ( it means that the view will query for the data it needs in the list). But i prefer we just emit the store changed signal, the views which listens to that signal will go to Store and query by itself for the data that it needs. You know, either will work. 2: about the "getInitialState" stuffs, i think it's just what is the first time data, what you wanna display at the first time. Let say you can query the cache data to show to the user while fetching the data from some APIs. Hope it helps you.
Fresh from ng-conf: http://i.imgur.com/upcrFbi.png Traceur is a central piece of their build process. They are compiling to Dart. Do you think Microsoft's TS compiler does that?
It's been the language that's proven to be the easiest for me to go from conceptualizing complex logic or systems (I realize this is all relative but whatever) and "how can I do that" into being able to implement it. I never went to school for computer science, and never took a course on how to do things in a proper manner. I willed myself into learning how to program out of both necessity and a desire to be capable of building things on the web and server. I toyed with PHP with and Ruby in the past, but JS is what I've come to enjoy the most. The first thing I did was create a complex real time mobile analytics system using a mixture of express/socketstream, websockets, and mongodb. The client side consisted of a very early version of the ractivejs.org library and jquery. It's a mess under the hood I'm certain, but it works. I've also created little single purpose API micro services, a single page e-commerce site, a lead generation landing page system, twilio based services, and various other little tools and web sites along the way. So I feel like I can make anything with it. If I can't right away give me enough time and google and I will no doubt be able to. Whether the code I write is the best way to do it, the "right way" to do it, or the easiest way to do it is another matter all together but is mostly inconsequential to me since I can eventually get it done. The next thing I want to wrap my head around fully are client side web components. It makes the most sense to my brain whereas things like Angular/Ember etc. don't mesh with my way of thinking or feel like too much boilerplate. There's plenty of constructs within the language that I don't fully get yet or even utilize, but it doesn't stop me from stringing together a couple of functions or libraries to get what I need done and working. I think that's a blessing to me, or a curse to the language in the eyes of purists, but in the end is a testament to the power of the language. The sheer amount of libraries, guides, and help that exist out there in the ether of the internet enables anyone to get cool stuff done if they're willing to research it and use a bit of trial and error to reach their desired effect. That's why I dig JS :)
Most people seem to be quite happy with classes + mixins. Whenever Crockford talks about classes, he pretends that mixins (etc) don't exist and that everyone has to deal with massive hierarchies. He also like to pretend that tooling doesn't exist. Take whatever he says with a grain of salt.
Just use qTip2 instead of implementing your own tooltips. 
I don't know how old those Crockford quotes I posted are. He may have changed some views along with JavaScript getting updated. I myself am used to the traditional class-based programming. What I find interesting with Crockford's explanation is that JavaScript can be used without using the concept of classes at all! So I have started investigating how efficient the programming in JavaScript can be done when using only object-based inheritance, without using the `new` operator. Of course when using JS frameworks etc then the `new`keyword often has to be used, but it seems to me so far that the code can become very simple and powerful by using pure object-based prototyping. Here is a simple example without using the `new` operator: http://www.reddit.com/r/javascript/comments/2y3x14/cleaner_javascript_object_inheritance_example/
&gt; Just a suggestion, for the sake of presenting the example, I think the _ function just clutters it up. That's to make the practical use as simple and convenient as possible. The actual example code is only: var canvas = _(Canvas, {id:'test-canvas'}); canvas.beginPaint(); for (var y = 0; y &lt; canvas.height; y++) { for (var x = 0; x &lt; canvas.width; x++) { canvas.setPixel(x, y, x, y, Math.floor((x * y) / 255)); } } canvas.endPaint();
I agree with your philosophy about sending a changed event without data, and I think the Reflux.connect will probably automatically update the View when the store calls `trigger`. But if you can send a general `trigger` event for a store, why does the React mixin allow you to specify a property to watch? [`Reflux.connect(todoListStore,"list")`](https://github.com/spoike/refluxjs-todo/blob/master/js/components.jsx.js#L173) 
I don't understand why some people think the DOM is an abomination. I have no issues with it other than it can be slow to manipulate at times. Is it because people can't figure it out? No one in my company has a problem understanding it so what's the issue?
Where are the numbers supporting your claim? All I see is words.
Even though it makes a lot of sense I didn't expect it..
Shouldn't if (!window.localStorage || !window.sessionStorage) Be if (!window.localStorage &amp;&amp; !window.sessionStorage)
Yea, I discovered that this morning. Now it's completely amazing. I missed this tool for two months!
You can get a tiny bit more speed by doing the set pixel different.... http://jsfiddle.net/50Lhr6k6/2/
This same thing bit us somewhat last year. Fortunately we did catch it during QA. &gt; so Safari simply says that localStorage isn't available IMHO, there should've been some way in the API to *actually* say that. What Safari does is act casual just as if it was available and then throw an exception when you try to use it. It would have been preferable to have a way to test availability from the start.
Depend on proper credentials 
but wait there's more, in chrome packaged apps simply trying to access local storage throws an uncatchable error, hence why the pouchdb has local storage test looks like exports.hasLocalStorage = function () { if (isChromeApp()) { return false; } try { return localStorage; } catch (e) { return false; } }; function isChromeApp() { return (typeof chrome !== "undefined" &amp;&amp; typeof chrome.storage !== "undefined" &amp;&amp; typeof chrome.storage.local !== "undefined"); }
Yeah, I get a kick out of the .NET guys at work who can only think in terms of what Microsoft has given them... Web forms, ASP MVC... It's like they can't come up with a process without having the language rewritten to support it.
The point is though that this boilerplate may be different for different projects. It would be implemented for one project then reused if there were any further projects done that had the same requirements. There's nothing about this modularity which means you'd have to reimplement the same thing for each and every project.
* Omnipresent - practically every computer on *earth* has at least one Javascript interpreter on it somewhere, and most computers are shipped with them now. * Small, concise language - unlike some other languages the core language is pretty lean. * Flexible language design - first-class functions, open objects, and its prototypical inheritance is so open and powerful that if you don't like it you can simply and trivially *write your own class system* in it and use that instead. Try getting that offer in C, Java or Python. Javascript doesn't have an opinion on how you should write code - it's so permissive it's positively *slutty*. * Acceptable and concise "standard" libraries/APIs - whether it's the browser, node.js or whatever other system it's embedded in, the APIs available are usually pretty small and well-factored, unlike - say - the sprawling, redundant mess of Java's standard libraries. * Ludicrously flexible programming experience - it's not quite a Lisp (and metaprogramming is trickier), but it's arguably closer to one than it is to a C or a Java. Gives you enough rope to hang yourself and any three other guys nearby, but also enough to do some really cool things that are difficult, verbose or simply impossible in some other languages. * Weakly and dynamically typed. Much more of a personal preference on this point, but while strong typing has benefits (especially on huge codebases), I much prefer working in weak/dynamic typing when I'm coding for fun. I can't even remember the last time I experienced a type-related bug, and working in something strict like Java just feels like 30% coding and 70% scrabbling through the docs or Stack Overflow trying to work out the quickest or most efficient way of converting an ArrayListThingy into an OrderedSetDoohickeyCollection.
Let's talk again when source maps support watches and variable inspection. Until then they're near-useless for serious debugging.
I was actually wishing that Chrome and Firefox did this. I'm writing html5 games and I'm using localStorage for save games, naturally. I'd like to be able to test whether localStorage is persistent and if not, tell the users that their games will not be saved.
ECMAScript is the actual language standard. ES6 is the newest version of that standard and includes a lot of new language features. I've not heard the term JavaScript 2.0 but what you're hearing is probably in reference to this. 
Honestly? Because I had never made one before. Are there any best practices about making a plugin that works as both a jQuery and native module?
You're using only one `&amp;` right? `npm run task-jade &amp; npm run task-server`
Historically, the DOM API was created before you could do your example. Initially, there were things in your example that weren't needed cause they couldn't be used anyway. So I disagree that "for most of its existence was absolutely abysmal". What is so hard about anything? Is it cause people don't want to have to type a few extra lines or because they don't want to have to read and understand the API? The impression often given is the DOM is such a horrible thing you don't want to look at it, yet, we code in it every day and don't think twice about it. I'd bet far too many new people are scared of it now but it's no different than coding in any language and writing any program in some other API or library. I just don't get it.
It helps to distinguish: * ECMAScript: the name of the standard and the language specification. The name ‚ÄúJavaScript‚Äù couldn‚Äôt be used officially, because Sun (now Oracle) has a trademark, which is only licensed to Mozilla. Versions of the standard include: ECMAScript 5 (the current version), ECMAScript 6 (also called ECMAScript 2015, work in progress, ratified by mid 2015). * JavaScript: Colloquially ‚Äì the language. Officially ‚Äì one implementation of the ECMAScript standard (i.e., Mozilla‚Äôs). For a long time, Mozilla used the version numbers JavaScript 1.7, 1.8 etc. But they have been deprecated in favor of ECMAScript 5 etc.
Yep, here is my console [output](http://imgur.com/x15rCyG) after: npm run build
I like the approach. It is an elegant solution (the api mimicks that of drawing paths) to a common problem (using fillRect to draw pixels is slow). I'd like to see a few different scenarios comparing fillRect vs your solution. Especially where the break-even occurs would be interesting to know. Basically, this is a form of double buffering, a general technique to speed up rendering. There might be other ways to do it. For instance, I thought drawing to canvas that is not attached to the DOM, or hidden, would be faster than when it is visible. If so, it would be interesting how that compares as well. As it is however, your solution is a nice technique that is easily applied and just as easily removed if it doesn't deliver any speedup in a particular scenario. Thanks for sharing!
you are setting the onkeyup handler on the &lt;input&gt;. That means that the &lt;input&gt; must be active (focussed) for this to work. Try adding the onkeyup event handler to the body instead.
Just curious, what is the standard method for hashing in Node applications? I assume it's a function which is used all the time. Is the existing implementation slow(er) compared to this one?
Node has a [Crypto API](https://nodejs.org/api/crypto.html), which supports SHA-256 among many others.
Node exposes the [crypto](https://nodejs.org/api/crypto.html) module which is basically a wrapper for OpenSSL. This means all of node's crypto happens in native code land rather than in javascript land and therefore should always be faster than any pure js implementation.
I've stopped using GPL lately after bukkit went tits-up for exactly what you pointed out. I second this op.
&gt;When I say the Dom is an abomination I don't mean the api is unbearable I think that is what most people think when they say that and more people say that cause that's what they're led to think.
Seems like most browsers support the Web Cryptography API (at least partially): http://caniuse.com/#feat=cryptography Even IE11. As usual, not supported in earlier IE versions. Here is an example of SHA-256 with the webcrypto api: window.crypto.subtle.digest({name: "SHA-256"}, new Uint8Array([0x01, 0x02])).then(function (hash) { console.log("SHA-256:"); console.log(new Uint8Array(hash)); }); Source: http://jsfiddle.net/dwa5hn0m/ EDIT: Hmm... Only works in Firefox. My SHA-256 (polyfill version) works in all browsers. The Web Cryptography API will be great when it has become standard and fully supported. Until then I will use my implementation. And IE10 and older will probably remain being used by some people for some years.
Try: https://jsfiddle.net/dwa5hn0m/ with chrome.
I'm not sure what you're saying 'nope' to but my company does full-stack end-to-end builds so, yes, we do server work. We are always suspicious of things like angular and react, code or libraries or scripts that generates code, when we know how it all works and those things are a 'been there, done that' for us. 
Oh, https instead of http. Interesting. Still doesn't work in IE11 though.
I was saying "nope" as in that the common view you were suggesting is not what I meant when I said the Dom is an abomination. I have worked with and without many frameworks and there are certainly cases where Dom mutations are minimal or performance is critical where it makes sense to go without a framework. React (and others) are not designed for mostly static sites but rather dynamically loaded and generated web apps and in that situation it can save tons of time debugging the spaghetti code that is required to handle all of the mutations these apps require. Any tool can be overkill for a situation certainly not disagreeing with that, but for large scale web-apps react is an awesome tool.
Yes that was my attempt to close menu when clicked outside the dropdown menu. 
I haven't noticed a problem with breakpoints in Chrome or Firefox. I checked and found this open bug: https://code.google.com/p/chromium/issues/detail?id=459499 I don't know if it's related to your problem.
&gt;That line is commonly used to turn the arguments pseudo array (or similar pseudo arrays) into an actual array. If you ever need to use `arguments` for anything other than passing them through unmodified, you're almost certainly doing it wrong. I've never seen a use case for that. &gt;QSA, for example, also returns a pseudo array. Typically something like this is used Or you could just loop over it normally, spare the unnecessary allocations and context indirection. var nodes = document.querySelectorAll('selector'); var node; for(var i = 0; i &lt; nodes.length; i++) { node = nodes[i]; } While QSA has crippling drawbacks from other selector engines, the few times i've used it I've never had to go through shenanigans like you describe. And if you're *really* so desperate to use it that way, then this all goes back to one of my points above - *libraries*. QSA not working the way you want? Go find something that does. I like Sizzle, you might like to write a wrapper around QSA. &gt;Speaking of "you have to ___ just to ___", there was no motherfucking import in JavaScript prior to ES6. And thank god for that, because it would almost certainly not look like `import` today. It wasn't until recently that anyone actually started taking require's seriously and diving in the problem. We'd probably end up with some mess like Ruby runtime dependency hell or some permutation of the GAC if `import` was defined in the 90's. There still isn't, by the way. Nobody supports it. You can use something like Require, or just alias your modules yourself so that there's no namespace pollution or dependency chains preventing you from minifying serverside.
Thank you for the detailed reply, and for not just giving me all the code! :) I have the javascript working okay now, using this: http://jsfiddle.net/tgs7px4f/5/ I went and cut out everything that seemed unnecessary, and now the tooltip is almost always appearing where I want it to be. _____ (...a little while later...) Here is what I have now. It doesn't run yet because I want to get the if statements working to make sure the image doesn't go off the page: http://jsfiddle.net/tgs7px4f/11/ What I need is how to find the user's window's width... I believe this is $(window).width()? Then I need to find the height of the image. This varies so I need to assign it to a variable and use something (probably a separate function) to find the image height... Then the width of the image is always 366px, so that's nice. How can I go about determining image height? I have to run out real quick but I'll update below if I find it. _____ **Edit:** To determine image's height, I needed to assign a class to the image, so I added class="popimg". Then I simply use the class selector and height function to retrieve the height: var imageHeight = $(".popimg").height(); For the if statements, I decided it would be best to flip the tooltip so that if it will go off the top of the page, instead the tooltip will go down and to the right (instead of up to the right). This way I avoid flickering should the image go off the top AND the right. // Find bounds of current window, and if... // Tooltip goes off right side: if ((imageX + imageWidth) &gt; $(window).width()) { //Move tooltip left so it meets edge: imageX = $(window).width() - imageWidth; } // Tooltip goes off top if (imageY &lt; 0) { //Move tooltip down so it meets top: imageY = e.clientY + 10; } I also updated the original distances to give some extra leeway for when the tooltips go off the page. This way there's no chance the cursor ends up on top of the image AND the tooltip text (causes flickering). Updated code: http://jsfiddle.net/tgs7px4f/13/
Is there any reason you're doing `getImageData` on each frame? Why not just call `createImageData` once at the beginning, hold on to the `ImageData` object it returns, and keep recycling it? It's been a while since I worked with canvas, so I could be wrong here, but I suspect this could give you a boost in terms of both not having to keep getting the ImageData object anew each time, as well as GC. This assumes you're purely doing pixel manipulation, not drawing any paths or text. One other thing you could maybe do is keep min/max coords for all pixels set between each `beginPaint` and `endPaint`, and only paint the dirty region. E.g. if you do two set pixels, one at (5,7) and one at (9,4), you only need to repaint the rect. at (5,4), (9,4), (5,7), (9,7). Depending on use, this may or may not be more performant than just repainting the entire canvas each time.
Hashing and hash tables are barely related.
When the canvas has already been drawn on then setPixel() still works, because the beginPaint() copies the canvas content and keeps the image data. When endPaint() is called then the content is stored back including with all the pixels set by setPixel(). Even though both beginPaint() and endPaint() are fairly slow, it's ok when setting a lot of pixels since setPixel() is very fast. As you wrote keeping the same image data only works when only doing pixel manipulation. I assume that both setImageData and getImageData use bit blit operations and keeping track of a dirty region will slow down setPixel(). The benefit of only redrawing the needed area is likely much less than the extra slowing down of setPixel() it would result in.
Exactly, this is the best way to approach it IMO. Of course the implementation may vary but the philosophy behind it is great.
I bet you could just build a little test yourself pretty easily - write something and immediate try to read it?
I use es6 every day. Just use a tool like babel and get to work! Once all your supported browsers fully implement the es6 spec, you can stop using the transpiler.
&gt; grunt-template-jasmine-requirejs After looking briefly at it, it seems to pile all script files with `&lt;script src="..."&gt;&lt;/script&gt;` before loading require. Ups! You can do much better with RequireJS... but it will work tough. ;)
Since you are using JQuery, you're looking for [$.when](http://api.jquery.com/jquery.when)
Could you expand on the scaling bit?
Because javascript is like that chill pal of yours who doesn't care you have a comma after the last item in your array. arr = ["best", "friend", "forever",];
Yeah safari went too far down the "privacy" path IMO. Chrome (and ff) do it much nicer, its like its own session which is wiped after close and just a couple other small things (open last tab disabled, history capped to 10, etc).
See. There's one of them there people I was talking about. And he has his facts and background all mixed up. And, worse, he has 20/20 hindsight. Maybe worse, he thinks he could have done better than the computer scientists who put it together in the first place. Liam Quin didn't know shit I say! And neither did Chris Wilson or any of those guys at Netscape, Sun, Microsoft and IBM. Why he would have even made a better C! 
This might not be what you're asking, but you could do something like this: function createGreeting(username) { return `Greetings, ${username}!`; } This way at runtime you could use your template string like so: `createGreeting('brian')` I don't believe it's possible to read a vanilla string and convert it to a template string though.
Ah windows. Windows doesn't support &amp; syntax for running processes in the background. However, you can write a little command `parsh` or something that will just call `spawn()` on each of its arguments: #!/usr/bin/env node var exec = require('child_process').exec; process.argv.slice(2).forEach(function (cmd) { var ps = exec(cmd); ps.stdout.pipe(process.stdout); ps.stderr.pipe(process.stderr); }); then in your package.json you can do: { "scripts": { "zzz-a": "whatever", "zzz-b": "beep boop", "zzz": "node parsh.js 'npm run zzz-a' 'npm run zzz-b'" } } not quite as terse as with bash, but windows is annoying like that. You might also need to use `\"` instead of `'` since windows quotes arguments strangely.
I'm so happy people down voted this. I'm not a proponent of x-to-js compilers. Yay javascript! However, they are a thing and people use them. 
Does a do-while offer any advantage over statement; while(condition) { statement; } ?
There is always the option to use eval and friends: function t(s) { return new Function('data', 'return `'+ s + '`'); } var template = t("hello ${data.subject}"); console.log(template({subject: 'world'})); // hello world Note: This can execute arbitrary code.
Im interested
Node was the first time I could do tcp connections while feeling I really understand what's going on. Most languages feel like they're asking me to buy into their way of thinking while JS is like, "wanna do this thing? Well get on it!" I know it's not the best attitude to writing good code but sometimes we have to understand solving problems comes before standards. 
&gt; IMHO IME &gt; IMO Don't dismiss the benefits of good tooling without having experienced it firsthand.
I could have said in my experience. I tend to go with IMHO because it's really the same thing.
Most on your list are relatively brand new. Don't say it's not a good option when we've been doing without them for decades. While you may read of people who *claim* they use them here on reddit, I'd bet you'd be hard pressed to find anyone in real life who does.
No, having an opinion does not require any personal experience. E.g. many people have some opinion on "gay marriage", but that doesn't mean that they are gay or married. So, what have you done with TypeScript? Have you used it to write a somewhat larger application with two or more developers?
I spent the first 7 years of my career writing C++. The next 7, I spent doing C# and the last 1+ I've spent doing JavaScript. I can't remember the last time I wrote a Do..While but I'd guess it was in my C++ days.
&gt; Most on your list are relatively brand new. Mh? GWT is from 2006. Closure stuff 2009. Dart 2011. TypeScript 2012. &gt; Don't say it's not a good option when we've been doing without them for decades. JS is about 20 years old, but no one wrote big applications in it. That started about 10 years ago. "Coincidentally", GTW appeared shortly thereafter. &gt; While you may read of people who claim they use them here on reddit, I'd bet you'd be hard pressed to find anyone in real life who does. Source: You. Do you think Reddit is some small community? It had 150 *million* uniques last month. The people here are the people from the real world. Anyhow, I'm a real person. I write most of my code in Dart. I also know people who primarily use TypeScript, JavaScript, C#, or even PHP.
&gt; So straight people's opinions on gay marriage don't matter? That's an odd way to interpret what I said. The point was that having an opinion and having *gained* some experience isn't the same thing. "having an opinion does not require any personal experience" Looks pretty clear to me. &gt; You're an idiot, I'm done talking to you. That wasn't a very subtle way to dodge my question. So, you actually haven't used TypeScript for anything, huh?
That's not an advantage, that's just what it does. When you find yourself in a situation where you need to run the code once regardless of the test condition, you use a do-while. The equivalent of a do-while loop using just a while loop is this: {code to run at least once} while(condition) { {same code to run at least once} } There's your repeated code. And now, if you want to change the code within the while loop, you have to make the same exact change outside the loop or else you're going to have strange bugs. There's your maintainability.
I tend to not use while or for loops in JS anymore. I just stick to lodash's each, map etc. The advantage being the loop scoped variables.
in defense of loop scoped variables, with es6 `let` you can define block scoped variables. Of course using babeljs to transpile. Standard for loops are also much faster than the each/map methods http://jsperf.com/foreach-vs-loop
Can you see how the do..while loop eliminates repetition in the following example? foo(); while(bar){ foo(); } // vs. do { foo(); } while (bar); Granted, this is not an overly common pattern, but a do..while loop absolutely can and does eliminate repetition in code (thus increasing maintainability) when at the appropriate time.
I'm learning Meteor as part of a side project. Where do I go?
The Swift documentation has a very nice example. The syntax is pretty close to JavaScript and other C-like languages. Starting reading at the "While Loops" section: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID124
I've sent you guys a message. Anybody can of course directly add to Skype **drawplanet**, and it's where all of the devs are in a Skype group. And I can add anybody who's curious or interested to the design &amp; development section on the [[forum]](http://drawplanet.net/forum) which has a lot of documentation about the project.
Sure, sure. But eval is a little risky.
Create a list from the keys of your map. Sort it using a custom sort function that compares them by their respective values.
I think you'll need to convert the date into an array, then call its `sort` method. You could use a `for... in` loop or `Object.keys` to produce the array of words and counts from the stats object.
Could you provide some pseudo code too? I'm a bit of a beginner and would greatly appreciate it :) UPDATE: I see that a function can be passed into array.sort that it will use instead! Thanks!!!
Here's an example of how to easily sort a hash by keys: var sorted = Object.keys(hash) .sort(function(a,b) { return +b - +a }) .map(function(k) { return hash[k] }); If you need the key in your sorted list, you can change the map to: .map(function(k) { return { key: k, value: hash[k] });
Not natively. But with lodash you could do something like: _(stat).pairs().sortBy(1).value()
Most importantly, there isn't any point in doing this anyways. If you can dump some strings somewhere, you can as well generate some code. // generated part let strings = { 'page %0 of %1'(...a) {return `Seite ${a[0]} von ${a[1]}`} }; // in your app console.log(strings['page %0 of %1'](5, 7)); // Seite 5 von 7
What I have isn't really a hash but a key value pair where key is what I want to print (a string) but is ordered by the value (an integer).
 var running = true; do { var foo = fs.readFileSync("myFile"); for (var i in foo) { console.log(i+": "+foo[i]); if (foo[i] === "b")) running = false; } } while (running); That's a contrived example where you want to run a slightly large bit of code more than once. It prints all the characters and their position in the file at least once, and if the file doesn't contain the character "b", it prints the characters continuously until the file is finally changed to contain the character "b". I don't know of a reason you'd want to do that, but it's an example of wanting something to be done at least once. Using a while loop instead, it becomes this, which is clearly a lot worse: var running = true; var foo = fs.readFileSync("myFile"); for (var i in foo) { console.log(i+": "+foo[i]); if (foo[i] === "b")) running = false; } while (running) { var foo = fs.readFileSync("myFile"); for (var i in foo) { console.log(i+": "+foo[i]); if (foo[i] === "b")) running = false; } } Of course, you could put that in a function, but it's a so small and specialized piece of code that there isn't really any benefit to putting it in a function except for not using `do while`.
Thanks, you are right, the GPL makes it tricky when wanting to use the library in a proprietary application. While this philosophy (gnu.org/philosophy/why-not-lgpl.html) makes sense, I believe there is a philosophy that supersedes this. My philosophy is that quality, secure crypto should be available for everyone so that they can be free of surveillance. Whether it's in a proprietary or open source application, that is not important. Obviously it is better if the application using the library is fully open source because then it's reviewable and less likely to contain backdoors, but I'm not opposed to anyone using the library if they need it. I think MIT License may be the best fit, so I have released v1.0.2 under that.
It's under MIT License now.
So... are we having a polite, constructive discussion, or are we just being obnoxious pricks to each other? Because your entire comment didn't really contain one single substantive argument or refutation. All I said was that the querying mechanism was primitive and the element-creation functionality was verbose and long-winded, and you didn't actually refute that - you merely implied that you'd have to be some sort of super-genius to recognise it before around 2013, when those same "computer scientists who put it together" finally came up with `document.querySelectorAll`. The thing is, half the people in the web development community have been bitching about how crappy and underpowered the DOM API is for a *decade* or more at this point. John Resig wrote jQuery - whose CSS-based element-selector functionality was a clear and obvious improvement over manual looping-and-conditionals - in 2006, *seven years* before `document.querySelectorAll` made it into the DOM spec... and lots of JS developers at the time were writing their own because the DOM API was so unnecessarily fiddly to use that it wasn't hard to improve upon it. Hell, I was there at the time - I even did it myself! Oh, and querySelectorAll was directly inspired by jQuery's $() function, so it turns out that yes, all those javascript developers scratching their own itches because the DOM API didn't adequately fulfil their needs *were indeed* years ahead of the W3C's spec-writers the whole time. The thing is, people have been bitching about the DOM API for *years*, and the W3C are notoriously slow and not necessarily very good at defining standards. What do you think happened to XHTML 2.x? And why did all the major browser manufacturers abandon the W3C to form the WHATWG? And why is the WHATWG now in charge of defining the future of HTML? It's because for years now the W3C has *sucked balls* at defining standards - they're slow, ponderous, excessively deliberative and typically over-engineer the living shit out of everything, to the point that they bungled the future of HTML so badly that the community started *flat-out ignoring them*, [formed their own working group](https://wiki.whatwg.org/wiki/FAQ#What_is_the_WHATWG.3F), developed what became known as HTML5 and [relegated the W3C to a back-seat, largely administrative role](https://wiki.whatwg.org/wiki/FAQ#WHATWG_and_the_W3C_HTML_WG). The DOM API itself is fine for building trees of nodes and representing documents and hierarchical, semi-structured data - no argument there. However, the querying and modification functionality it offered was (and in may cases still is) absolutely atomic, in the sense of the barest, most primitive operations required in order to make it realistically functional. It took a couple of versions to even get `getElementById`, and we only got `querySelector` two years ago... seven years after substantially the same functionality was already in widespread use in an extremely popular JS library... and we *still* don't really have any convenience functions for quickly and easily defining new HTML elements. There's no 20/20 hindsight here, and no armchair quarterbacking. I've been building websites since 1995, and I've been involved in the web-design and web-dev scenes the whole time. People have been bitching about the DOM API for *years*, and the JS community has been years ahead of the W3C spec-writers in terms of functionality and ease-of-use libraries for nearly a decade now.
Nice library. What's with the name though
`do..while` is definitely not bad practice. I don‚Äôt write about them, but FWIW I use them in production code. I don‚Äôt write about them, because they aren‚Äôt *interesting*, in the sense that they don‚Äôt lead to thinking about deeper things, or thinking about other things in a new way. But that doesn‚Äôt mean they aren‚Äôt useful. I am not anybody‚Äôs style arbiter, but if it means anything, I don‚Äôt use them for iterating over collections of things. I‚Äôll always reach for `map` or `reduce` or `forEach` or `for()` first. If you see me write that, it‚Äôs a rare place where I‚Äôve done a performance optimization and making it fast is more important than making it readable. But from time to time there‚Äôs a repetitive thing with a stopping condition that isn‚Äôt about iteration, and it needs to be done at least once, and `do...while` is the right tool for that job. So getting back to the top, I think `do..while` as a substitute for mapping, reducing, or ‚Äúeaching‚Äù over a collection is questionable if you don‚Äôt have a very good performance reason to consider, but otherwise it‚Äôs fine.
forgive my ignorance, but what does DRY mean in this context?
Move the first position generation to the first line inside the do while-loop, and remove the second generation. 
Don't Repeat Yourself
Not that you should always do it, but a lot of times I do find it nice to make a function to make things more self-documenting. But honestly these days I find it more rare to use a looping construct directly anyway vs map, filter, each, etc using underscore/lodash..
So DRY is a programming principle that stands for "Don't Repeat Yourself". It's become a verb because of the word "dry". So here, when I say a do-while is DRYer, I'm saying that that a do-while loop adheres to the DRY principle better by not repeating code.
`sed 's/a verb/an adjective/'`
That is true. You can always offload the heavy work to web workers, or use setTimeouts ever so often in the while loop to allow the event loop to continue
I believe we used [this](https://github.com/DaftMonk/generator-angular-fullstack) in a recent project. Was super easy. 
I'm not that familiar with yo, would this actually collect all the packages required for MEAN and install them as necessary, or would it just generate the boilerplate code used for creating a MEAN project and assume that I have the MEAN stack already installed?
For some reason I was having a serious brain fart trying to determine its part of speech. It's so obvious now it's embarrassing. XD
Yes, then you can add/update/delete them as you like. You can also use the flag --skip-install when initially setting it up so you can review everything before it runs npm install &amp;&amp; bower install
Thanks, I'll check this out
Awesome! Thank you very much, I'll look into using this.
I use do-while's in JS a but unconventionally. You can break out of them, so I'll do stuff like this: var result = null; do { if(thing) { result = doStuff(); break; } doSomethjng(); if(other) { break; } result = defaultStuff(); } while(false); return result; The idea is that you can have a chain of tests and changes before getting to a result. This is a nice way to get around throwing errors in your code. 
Haha, yeah... it's a complicated situation, but I definitely am keeping my ear to the ground.
Gladly! You need to start working from home for a company that appreciates you
I'm guessing you don't support IE (slightly older versions of which fail if you have trailing commas).
Confirmed. Just tested it out on Codepen http://codepen.io/anon/pen/yyQYOM
Most of the places I see do..while being used involve user input or UI manipulation of some kind. Because these are almost always blocking operations, I find that setInterval (or something else that doesn't block the event loop) is generally in order instead. For other cases, I often only want to execute half (some part) of the loop under one set of conditions, so while(true) and an if statement is the only available construct anyway.
You're right, a `for` loop can likewise be just as dangerous. And, since I got the functional religion learning Ruby years ago, I don't write as many of those loops as I used to, either; `x.each()` and `x.map()` get me a long way. But even so, the `for` loop usually contains everything you need to finish the whole thing, all in one clause. In a `while` loop, I often write the loop finishing clause separately, e.g. `while (someQuality){` // do some other code // conditionally change someQuality, // or maybe break // and maybe get confused :-) `}` Not to say 'you shouldn't write these', but more to say 'Don't be a dumbass like me, and be careful when you do write them'. 
Now, does this turn to rce...
okay thanks!
Here: https://jsfiddle.net/c2quhdad/3/ Your problem with the angle was that it was in degrees, but needed to be in radians for the math to work. You were also over-thinking it with all that quadrant stuff. You are doing quite a bit wrong... Mixing jquery and native DOM methods, lots of global variables... your findAngle method is also 'returning' its value by setting a global rather than using the return keyword.
Awesome trick, this is actually working. 
How to crash any tab in any browser: for(;;);
On Safari 7.0.3 OS X and it does not work.