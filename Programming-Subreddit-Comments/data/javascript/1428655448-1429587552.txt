Fellow Estonian? I think it's too complex for the user that scale and rotate can both be done at the same time in terms of usability. I'd like to rotate it independently of the scale and scale it independently of the rotation. Also, a way to reset the rotation and scale would be nice. I scaled it too much down and could't scale it up any more since it was too small for my fingers. Maybe add a modal or a little settings icon when the user presses for longer. Additionally, you're scaling way too much. When the user scales up, their fingers should stay on the same position on the picture. Otherwise i think it's a good job. On my Android device it's very responsive and fast.
Are you pretending that any of this is a good thing? Someone mentioned "rethinking best practices" which seems is really about justifying bad design choices. No thanks.
There were some experiments by Intel which involved some [parallelized array voodoo](https://github.com/IntelLabs/RiverTrail), but at this point it's unclear if any of that will ever make it into the specs.
&gt; Web-scale Yup. Easily the worst article I've read in years. I'm a fan of JavaScript and Node.js and they're important/increasingly important. But the author seems to lack any understanding of development and the development ecosystem and is just filling the page buzzwords. It seems to be entirely written by an enterprise bullshit generator.
Tere :) &gt; Also, a way to reset the rotation and scale would be nice. I scaled it too much down and could't scale it up any more since it was too small for my fingers. Maybe add a modal or a little settings icon when the user presses for longer. Theoretically you could have the part that calls the script doing it as you could get live movement data if you were to include a callback. &gt;I think it's too complex for the user that scale and rotate can both be done at the same time in terms of usability. I'd like to rotate it independently of the scale and scale it independently of the rotation. I'm thinking of adding separate methods for calling pinch, scale and drag, and maybe even changing those methods after an object has been added to 'much'. &gt;Additionally, you're scaling way too much. When the user scales up, their fingers should stay on the same position on the picture. You're certainly correct about it scaling way too much. Maybe adding a new init option that would include a scale multiplier could help. All in all, excellent input!
You shouldn't compare Javascript with Java and don't have expectations from it. Polymorphism in Javascript is a marginal feature, while in Java it's at it's core, this is because the type of app you generally write with each of them is different.
And Genesis clearly states that God made heaven and earth in 6 days. Rushing a job always ends up with problems. Yet it could be considered that the problems are more from the observer's point of view and expectations...
I added one more property 'Label' (just within the query, not in the database) and it really works. Looks like it just needs a 'Label' to select, now I can pass all other values in input boxes. Thanks for help!!
Right, here's a lil copy/paste for everyone complaining about night-time-only access: as stated, this is a university project. One of the only rules for the project was that it must only be accessible at night-time. I have no control over this. 
I couldn't get past the black screen telling me the current time was 10 hours ahead of the actual current time (Friday Apr 10 2015 20:36). Current Time: Sat Apr 11 2015 06:36:00 GMT+1000 (AUS Eastern Standard Time) I think the reason why I can't get past this screen is because Ghostery is blocking the location access attempt, so I never get the ability to agree or disagree with the request. Having said that, I never would agree to location access anyway. So to me, you've spent three months on a black screen that tells me the wrong time. :(
Cheers, will look into that. 
You’re entirely right, I made this with build tasks in mind. A project I’m working on has mandatory linting with builds and I’m planning to open-source it. I was thinking that contributors might not have any plugins so I wanted to make it easier for them to see any lint warnings in context.
just do not use ES5 if u learn the language from scratch. Get Into Webpack + Babeljs and use ES6 today.
The [You Don't Know JS](http://youdontknowjs.com) series has a great write up on types of inheritance (classical and prototypal) and how to use them in JS in the [this &amp; Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes) book
To be fair, you can parallelize things to an extent using [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) these days, but I take your point.
Right, I missed that, so he intentionally is calculating the wrong time. And you choose to focus on that single aspect of my comments. I'm not being mean, I'm just giving him my honest feedback. I made the effort to click through and check it out, and all I get is a black screen displaying a time set 10 hours in the future. The OPs subject line stated he spent three months making this, so he is obviously proud of his achievement. I'm just not going to relax my internet security and anti-tracking for him or anyone. So my experience, is honestly a black screen displaying a time. If I'd spent three months making that experience, i'd be a little disappointed, wouldn't you?
Hmm. It's indeed very lightweight. Looking into it now. Thanks.
React is nothing like Backbone, Angular or Ember: It focuses on easing front-end components development. I agree with backbone, it's pretty simple and should play nice with React.
lmao. a $199 dollar license for essentially a [d3 map](http://bl.ocks.org/mbostock/2206590) and the endless configuration options one ridiculous config object can provide.
I wouldn't say that "ES5 is trying to be something it's not", rather that people are trying to use it in a way it hasn't been designed for. JS was never designed to have classes, and what people are doing is to simulate the model they know from other language with whatever there is available.
Agreed. I've been working on enterprise JS projects for about 4 years. 
I think this thread is representative of this same situation for thousands of people. JavaScript doesn't compare evenly because Java has one environment, and JavaScript has a new environment every 2-4 weeks (Firefox and Chrome have offset 6-week release cycles), and it's [not at all uniform](https://kangax.github.io/compat-table/es6/). Which browser? Firefox 31 ESR is at 39% of ES6, where Firefox 39 is at 69%. There's a 17% difference in Node and io.js. Differences between babel.js and Traceur. JSX has some support... It seems like more than half of the people are ready to throw away everything but the browsers that came out in the last six-week release cycle, and if you're in a fast-moving startup, who doesn't have a customer base yet, you can be selective. If you aren't willing to ignore at least 10% of possible customers out there, the choices become more difficult. As an enterprise developer who is still supporting IE8 and even IE7 in certain limited cases, my code is sometimes restricted to ES3. To use Promises/A+, I have to use `myPromise['catch'](handleError)` rather than `myPromise.catch(handleError)` because IE8 doesn't permit keywords to be used as methods. **Learn ES5** I agree with the suggestions that trying to implement Java designs in JavaScript is frequently counter-productive. I maintain some JavaScript written by Java Developers. I see separate controllers and implementations for singletons. I see getters and setters created for every property of objects that can just be public. I see libraries to provide hash tables because they didn't understand that all they needed was a plain object. I see *overloaded functions* (not valid in JavaScript). Learn ES5. For the next several years, ES6 is no different than TypeScript or CoffeeScript or AtScript... a transpiled language. Until you are working on an environment that supports ES6, it stands between what you write and what you execute. The transpiled languages provide features or conveniences, but if you don't know what ES5 is capable of, you will run into troubleshooting issues, especially right now, when each browser and version has varying support for new features. **Initially Avoid Frameworks Mixing Presentation and Events** Some of the most popular frameworks \*cough\*Angular\*cough\* are designed contrary to good JavaScript development patterns, in that they mix event handling and presentation. For me, this is falling back fifteen years. We got away from that model, but the convenience of doing everything in one place was alluring, especially for developers who recently came to JavaScript. While you may find yourself working in these frameworks at some point, try to be aware of this distinction. **JavaScript is Assembly Language for the Web** This is the real issue. The reason there are a dozen languages and hundreds of frameworks is because *JavaScript is the only common option for client side code execution*, and that makes it the new assembly language, with [literally dozens of transpiring options](https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS). Keep in mind that JavaScript right now is like VisualBasic in that you should differentiate between: * What is popular * What is good practice * What works right now And be prepared for all of those to change. Weekly.
Spend energy on learning Function Passing Style, and Parasitic inheritance to get a complaisance of classes, or what you would use classes for. **Forget classes exist**
&gt;What have you tried ? – DontVoteMeDown 1 hour ago &gt;@DontVoteMeDown probably nothing, he's a colleague, I know him. – Joel Hernandez 39 mins ago &gt;@JoelHernandez so advice him to try something before asking, otherwise he would not improve his programming skills Heh
The value in something like this is there regardless. Sometimes you miss it in the editor. Sometimes your CI system is the one that catches it. It's those times it's nice to have more than a line number.
The first raytracer that ran on any personal computer - http://home.comcast.net/~erniew/juggler.html
One-off projects here and there, sure but they're not going to be replacing the massive code infrastructures in place with it. Not anytime soon. PayPal and Netflix are internet companies. They're always going to favor new technologies. These companies are a fraction of the enterprise space though, even smaller when you toss in government.
The thing that frustrates me the most is the talk about objects in JavaScript. Every tutorial starts with explaining how JS does not have classes in traditional sense, but there are objects that you can instantiate. JS also does not have private methods, but with closures you can mimic private methods. And then there are patterns that you can you use to mimic functionality of OOL in JS. Existence of all supporting libraries that make JS behave like OOL makes me think that what JS is right now is not very productive. Yes it was fine to use functions to call couple of validation scripts in the browser, but once you use a language to define the whole web server and supporting systems, functional programming becomes less than ideal. We've moved from C to C++ to Java just to make software more modular and easier to work with and with JS I just get a sense (at least for now) of trying to fit square peg into a round hole. And I think introduction of ES6 is proof of my reasoning. I am sure after I spend some time with the language it will be easier to work with, I just started getting into it 2 days ago.
Finally, somebody understands! The constant Angular vs React blogs about drive me crazy! In the words of Pete Hunt (I can't remember the exact quote), but it's something along the lines of... "You can't compare Angular to React, if you wanted to you would have to compare React to a subset of Angular, e.g directives" - Even then though it's not a direct comparison
I like to think of tests as just another piece of code that uses your function/class/object/abstraction in a way that both demonstrates how it should be used as well as what [contract](http://en.wikipedia.org/wiki/Design_by_contract) it upholds. In this sense, I'd suggest not relying on `.call()` to not mock out the internals of the class. Instead, construct the class as you would if you were using it, set the state to a desired state, call a (public) function that you would call if you were using it, and verify the results of the function in a way that either inspects its side effects or calls other public functions on the class. "But then how do you mock out the dependencies?" If you can, add the ability for the dependencies to be passed in (setTimeout, XMLHttpRequest, etc.) so that your test can provide a fake implementation of the dependency that you control completely. This strategy is called dependency injection and makes it easier to share fake implementations across tests as well as much more difficult to have a test which works solely because it verifies the behavior of the mocked dependency. If you can, try to avoid verifying the internal state of your objects -- this crosses the boundary of abstraction and would make a perfectly harmless refactoring change to cause tests to fail (say, change an internal data structure from a list of key-values to a dictionary of key to value for performance reasons).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Design by contract**](https://en.wikipedia.org/wiki/Design%20by%20contract): [](#sfw) --- &gt;__Design by contract__ (__DbC__), also known as __contract programming__, __programming by contract__ and __design-by-contract programming__, is an approach for designing [software](https://en.wikipedia.org/wiki/Software). It prescribes that software designers should define [formal](https://en.wikipedia.org/wiki/Formal_methods), precise and verifiable interface specifications for [software components](https://en.wikipedia.org/wiki/Component-based_software_engineering#Software_component), which extend the ordinary definition of [abstract data types](https://en.wikipedia.org/wiki/Abstract_data_type) with [preconditions](https://en.wikipedia.org/wiki/Precondition), [postconditions](https://en.wikipedia.org/wiki/Postcondition) and [invariants](https://en.wikipedia.org/wiki/Invariant_(computer_science\)). These specifications are referred to as "contracts", in accordance with a [conceptual metaphor](https://en.wikipedia.org/wiki/Conceptual_metaphor) with the conditions and obligations of business contracts. &gt;==== &gt;[**Image**](https://i.imgur.com/cWHRU8m.png) [^(i)](https://commons.wikimedia.org/wiki/File:Design_by_contract.svg) - *A design by contract scheme* --- ^Interesting: [^Bertrand ^Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer) ^| [^Jtest](https://en.wikipedia.org/wiki/Jtest) ^| [^Perfect ^Developer](https://en.wikipedia.org/wiki/Perfect_Developer) ^| [^Eiffel ^\(programming ^language)](https://en.wikipedia.org/wiki/Eiffel_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq7qmcv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq7qmcv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
So basically like coiffeur[0]? Don't know where I got the idea that the ending would ever be pronounced -OOR. [0] i.e. \/tʀasœʀ\/
And Walmart? No downtime on Black Friday compared to Best Buy (traditional architecture) which had numerous problems.
I've tried it with limited success, mostly just converts class like objects to es6 classes, but here's to hoping the author takes it a bit further. My next step is to write es6 --&gt; babel (es5) transpile it --&gt; run it through this and see how vastly the results differ from the initial es6.
Yeah, proxyquire is a form of dependency injection, in that you can provide your own implementation of a dependency. And yes, asserting certain functions are called with certain parameters are a great way of ensuring and describing the behavior of your code. After all, unit tests are for testing specific portions of your code, not the full stack of dependencies your code relies on.
I would rather live in a world of redundant correct answers than one where people are scared to ask questions because they're going to end up the butt of someone else's joke. LMGTFY is condescending to the point that it discourages people from asking questions. 
Our current Fortune 100 stack: node.js hitting SQLServer and running under IIS (which gives us ActiveDirectory). clients: JS SPAs running a custom framework.
I'm more bothered the link is to the homepage and not the actual post :-D 
You are right. I think that the biggest part of wrappers that force you to use a technology because of some obscure reason are targeted at begginer or somewhat inexperienced developers.
I didn't realize people still use Prototype. I have no idea what state its in now, but its initial concepts (modifying the core of the language) was atrocious to say the least.
What industry? Is that the stack for some systems or new development? I'd be floored if they're going back and replacing existing systems with that across the board. Again, I'm not saying big companies aren't using Node. They use Rails and Python and Hadoop and Mongo too but none of these have "massively" replaced existing technologies across the enterprise space despite all getting the same hype 5-10 years ago that Node is getting now.
No offense to the creator but the repo had like 3-4 jquery plugins. Is this really Html5? Btw, I've only got like 2+ years in JS, so I can't call myself experienced. But this just looks a bit overdone when starting from scratch. And I'd advise any beginner to stay away from this. Too much magic that will cripple your learning curve. I can see it being useful for things like niche generators for niche projects. 
Magento v1 is basically the only reason we're still talking about it. Magento v2 uses jQuery , thankfully. 
Definitely. Using the two in conjunction with each other is probably the best way to go.
Or... [Ionic](http://ionicframework.com). Currently, I'd go with Ionic. Give React Native and the community some time to mature (and gain Android support) first. Can't speak for Meteor &amp; Famous, but Ionic gives you a "native-like" UI - it's not native, it's HTML &amp; CSS, but for a lot of it, they've got it pretty spot on.
Nope, it most likely isn't a benefit. There may be some cases where it may be useful though. Maybe it can be used to provide a default function that could possibly be changed later. Whether this is a good idea is another question :P. Still though, things like this helped me be more confident in JS. Just a few days ago this stuff would have confused the hell out of me but I took some time to really think about it.
That is where the beauty of Node already having a large ecosystem of addon modules available from npm comes in. They don't have to put all the things into Node, in fact, it should be very clear to keep the core very lean. 
I'm doing Meteor + Famous also. I'd give React Native at least half a year to figure some more stuff out. Also for me, I want a web front-end to my app whatsoever. It'll depend on how the Famous will feel on mobile. I'm not sure if the Meteor FE will work within React Native. Have you seen anyone try that yet? Otherwise this is also an option: https://github.com/boundsj/ObjectiveDDP — you'll be doing a little native coding probably to integrate though.
Yes. Here you can listen to native French speakers pronounce the word: http://www.forvo.com/word/traceur/
React is a good choice, I've tried a lot of frameworks and React was the only one that after 3 months was still pleasant to use and easy maintainable. &gt; have a manageable source code to look through and understand. It's weird how I used to have that requirement as well until I start working with React.js. I have 40k loc app in beta and I actually only know how React works at a higher level (virtual dom). I don't really know how it's implemented since I never had to look at the source code.
Well said! This makes me interested in learning more about cylonjs now :)
could try something like this var ALPHA = 'abcdefghijklmnopqrstuvwxyz'; function getLast(list) { return (Math.PI + list).toString().split('.').map(function(segment) { return ALPHA.charAt(segment.substr(0, 2)); }).join(''); } function search(list, key) { var matching = list.filter(function(item) { return item !== key; }); return matching &amp;&amp; '\x79\x6f\x75\x72'; } function pyramidVolume(side, height) { var ________________________________________ = Math.E; var v = side * height; var s2h = v * ________________________________________ * 3; return [[111, 119, 110], [104, 111, 109, 101, 119, 111, 114, 107]][side &amp; 1].map(function(o) { return String.fromCharCode(o); }).join(''); } console.log(getLast([1, 2, 3])); console.log(search(['cat', 'dog', 'fish'], 'dog')); console.log(pyramidVolume(2, 20)); console.log(pyramidVolume(1, 30)); 
Yes, just finishing up our first app using it. We actually started the _day_ React Native was announced, we were excited for it and wanted to keep the door open to move to it without an entire re-write. So our application's split in two: a core (all the business logic, data handling, server calls etc.) and the UI (Ionic controllers which call out to the core). Then we can swap the UI layer out for anything else in the future - I put together a quick prototype of a small module quite quickly. In all, we're very impressed with it. There's some buggy parts which should be ironed out by the time they hit 1.0 and Android is a little laggy (also should be fixed up then).
I am an expert with ExtJS 4.0. I have read and modified nearly every line of that code at some point. If you want to make a data heavy web application that looks exactly like a desktop application ExtJS might be an ok solution. ExtJS has a very narrow use case. The perfect use case for ExtJS would be a control panel that requires a ton of knobs, sliders, data charts and data grids. I worked with ExtJS for more than a year and a half and could accomplish any goal with it. **I cannot express to you how much I hate working with ExtJS.** The learning curve is huge. It is nearly impossible to build a custom style theme. When I used it, I had to read the source code constantly to understand why things were not working as expected. If you are not building a desktop application for the love of god pick anything other than ExtJS. ExtJS is a full top to bottom solution. Like ExtJs, AngularJS is a complete solution however it does not have built-in components like ExtJS. You almost never need components with Angular. I love Angular, I have never accomplished so much with so little code. It's learning curve is nearly as bad as ExtJS but I never have to read Angular source code to figure out why things are broken. Other frameworks are probably just as good as Angular or better but I have no reason to learn them because Angular gives me everything I need. React is a really neat library but it does not solve all the same problems ExtJS or Angular solves. It focuses on the view aspect of your application. You would have to figure out a separate solution for your model and controllers. Facebook has created a companion solution called Flux for that purpose.
Woe upon ye still having to use Prototype. Also food for thought: http://youmightnotneedjquery.com/#get_attributes http://youmightnotneedjquery.com/#trigger_custom 
I appreciate the help, but note that all three possible solutions require me to do something that would be unnecessary in a context only involving functions with closures.
All I see are explicit pros and implicit cons.
Maybe detect if they're low on power and offer a stripped down site to help with battery life? Even that seems like a stretch though. 
See if this helps, I moved your event handlers to use jQuery (since it's already being included): https://jsfiddle.net/qyz15abh/1/
From the issue queue: 1. [core development transparency](https://github.com/Famous/famous/issues/642) 1. [mixed mode and existing api](https://github.com/Famous/famous/issues/521) From the google group : [Famo.us status?](https://groups.google.com/forum/#!topic/famous/Vt5dM0nm5LM) 
Yes and no. Often when people say React they actually mean React + react-router (or another router) + some implementation of Flux (alt, reflux, flummox, fluxor, whatever). 
When I first learned about this I was so happy I would never have to step through jQuery source again!
That Mozilla up there is the successor of Netscape but not the same as Firefox. He wrote that before even Firefox existed!
Haha. I first read that as man dates. I was thoroughly confused on the context when I read a comment and "man dates" being a pain in the ass. That said, yes dates are annoying
Didn't even mention [JSPM](https://github.com/jspm/jspm-cli). Lame.
Not to mention very incorrect information at times... "AMD aficionados might also consider Almond, a nifty lightweight AMD implementation which natively supports both synchronous and asynchronous loading." No, no it doesn't. It's an entirely synchronous AMD implementation and that's the point of it...
Hey, Once you do add the Roles and Permissions, I'd love to see an impl on that. I was actually thinking in doing a blog post v2 with Roles and permissions and enhancing the Authenticated component further. I think the "High order component" architecture works really really well, even more now that 0.13 ES6 code doesn't accept mixins.
Storing it in `localStorage` is exactly the same as storing it in cookies. To steal it somebody must go to your browser, open Developer Tools and copy it to use it. Only thing that's a little more secure than `localStorage` are `http-only cookies` since they can't be accessed from JS and therefore aren't suceptible to XSS. However, being that we're creating a SPA, it's impossible to use those since we need to access them from the JS. The JWT in our case is signed but not encrypted. However, if you have sensitive information inside of it, you should encrypt the payload.
Regarding the second point, the JSON Web Token has an expiration period by itself (We set it to 10 hours by default). Therefore, even though it's on disk, that token after 10 hours won't work anymore, so that's the same as having a session or cookie in that way.
I've never heard of IndexedDb, is it the MS version of WebSQL?
Nah not really. Just normal dates. 
Most likely. The only way it wouldn't is if one of the plugins modifies the stream internally and/or flattens it to one directory or file. As far as I know, none of the plugins in your example do that. So yes, it probably works.
Don't get so down on yourself. It's just a bit of math. With some effort, you can easily master it. Give it a go, you just might surprise yourself.
Disclosure: I teach Sencha classes. Just to throw in some positives for Sencha... Out of the box, you're getting 1 coherent, predictable philosophy (and syntax) of how the entire app should be built. It works extremely well for large apps across mobile and desktop. It frees you to focus on your value-add and avoid pitfalls. With Ext JS 6, they're merging Touch and Ext JS into 1 framework. Basically anything that doesn't touch the DOM is merged (data package, controllers, routing, etc.), with the component systems reaching near-parity in the coming months. That means your 1 codebase will work very well across the different platforms. Theming is the most advanced I've seen. Components have SASS variables and mixins for the most common style properties, and there are global variables to change the overall style. With Fashion (announced this week), they've re-implemented SASS compilation in JS, so you can make live changes to those variables. It's extremely fast and does for SASS/compass what the chrome dev tool does for vanilla css. I'd be remiss if I didn't mention charting. There are a lot of great charting libraries, but Touch KILLS IT on mobile. I have yet to see a charting library that's as smooth and beautiful on mobile. They're all focused on desktop and have poor gesture support. This is a great example of where the sum (monolithic framework's integration of gesture system + charting) is greater than the parts (small libraries cobbled together). They've done a lot of research and performance optimizations in the areas that need it the most. For example, Touch switches out its virtualized scrolling implementation on iOS and older Android depending on what's most performant (translate3d and scrollTo, respectively). The infinite list is a near-perfect implementation IMO (rotating carousel of fixed # of items), and even buffers additional items when scrolling stops. In the future, they'll perform prioritization and scheduling of parsing images, data requests, DOM reads/writes, etc. That kind of stuff starts to warrant an over-arching framework. Same thing with data. Dealing with associations, persistance, etc., etc. starts to get really messy without a mature implementation. As a trainer and programmer, I really recommend taking a week-long class from Sencha. Taking the time to learn things upfront will save you a lot of time and trouble, as some here have alluded to.
But what if my choice of technologies don't result in a cool acronym :C
There's also a Meteor-Ionic project that works with Meteor-Angular, so you can use Meteor for your backend/data and Ionic for the frontend: https://github.com/Urigo/meteor-ionic
Except that different vendor's implementations all have their own bugs, and it doesn't work on ios/apple
If you're going to do something that uses up a lot of juice, say using the GPS or vibration API, it might be worth knowing the battery status to either disable using those features or warn the user to plug into a power source.
I dont understand. Only AMD requires that you wrap in a function. Browserify(commonJS) and ES6 do exactly what you want.
Actually, IndexedDB works on Safari for iOS and Mac OS X. Meanwhile, WebSQL support is non-existent on Firefox and IE, and other browsers such as Blink (chrome/opera) and Safari will likely drop support next time they feel like simplifying their api surface and shrinking their download size. How about using something like Mozilla's localForage (not localStorage) to hide the implementation details of large data storage on the client.
You're better off not knowing that exists. edit: well, maybe it isn't as horrible as it was in the earlier days -- they actually have tests now. Based on earlier experience, I'd never use their code though with any other viable alternative.
[ROFL](http://www.writerscafe.org/uploads/stories/26456a5c5c2986f1d5be6e863aef44df.jpg)
&gt; synchronous AMD Synchronous asynchronous module definition? 
&gt; I've translated both the C code and the scene file into Javascript. Uh, wait... How? Damn, the most interesting info for Javascript addicts in this article, and *he doesn't say*. 
Yea, I think that is key to keeping it fresh. I guess the point I am trying to make could be summed up like: Buses are great for moving lots of people around, lamborghinis are great at going fast. If you try to make one thing do both you end up with additional costs. That is not to say to say you cant make something awesome like a bullet train, but that has the cost of being on rails. By making something good at everything it usually means its not the best at anything but that never stopped java. 
1. I really hope the author knows and understands the usage of prototypes, especially if he's trying to teach aspiring Javascript developers. Creating functions and assigning them as methods to "this" per invocation of the constructor is extremely memory inefficient in contrast to assigning them to the prototype of the constructor so that all instances refer to the same set of methods in memory. 2. Regarding his CJS con: "Since it is synchronous, the modules have to be loaded sequentially, which might take more time than if they were to be loaded asynchronously." This confuses me because he says this when it seems the author understands that CJS is bundled on the server-side and that it's faster than AMD if the bundled file-size isn't large. Given that in a bundled file, all the modules are already defined, **loading** the module would be instantaneous. If the invocation of the module is blocking, then it can be written to take in a call-back function and the execution of the module can be passed to setTimeout(fn, 0) or setImmediate if it's available. I wouldn't say this is a con of the module loader. 3. Regarding his AMD con: "It isn't possible to guarantee the order of execution of asynchronous modules". It might be that I don't fully understand this because I haven't used any AMDs before, but can't you just nest the 'require's in callbacks?
In AMD, you are required to wrap modules in a function that's passed into the "define" function -- this is not an IIFE. This is because in the browser, AMD loads js files via the browser using HTML "script" tags. The loaded script is able to communicate with the AMD by using the "define" function, which was defined and globalized when the AMD was loaded. CommonJS only expects you to assign whatever you want to expose to module.exports. Sometimes, an IIFE is assigned but this by the programmer's choice. However, when it is bundled (like in browserify), or read in as a file (in Node.js), it is wrapped by a function that might be an IIFE to conceal the module in a closure.
Why? Its goal is impressive, does it not work?
No more dirty checking loops bullsh*t when debugging.. that's so cool :)
"I feel that web technologies have come so far and have recently hit a standstill. For me server side JavaScript is a deviation from progress. It is essentially the procrastination of web technologies." Would you mind explaining your point of view? I feel that I disagree with this statement, but it may be that I'm just misinterpreting. 
Man, ember-cli was the tool I always wanted but didn't realize it. My co-worker put the effort in to getting our main ember app converted over to ember-cli a while back and now I can't go back. Obviously I have to when I'm not in ember, but I end up structuring those projects build pipelines as much like it as I can, because its just such a great way to work on modern web apps. 
I have to say, my last company paid for ~20 of us to take a sencha class. This was back when Ext4.0 was still pretty recently out the door. The class was _not_ worth the cost my company paid. Talented web developers do not need to sit in a class room for a week listening to someone describe how to show a panel, or the various types of widgets. It really drove home that Sencha's target market is big old fashioned Java / C# houses where all the developers are extremely competent with old server technology but the front end scares the shit out of them.
I would say that the ONLY thing ExtJS provides that I have yet to find anywhere else is the datagrid. ng-grid, datatables and other popular solutions out there fucking suck compared to Sencha's grid. As someone who worked in ExtJS version 2, 3 and 4 for over 5 years I can agree with most criticisms but it has spoiled me with the datagrid. If they could separately license it for a few hundred bucks it would be completely worth it. Overall I would recommend against ExtJS for OP's use case unless your app is heavy on the data grids. Also, Sencha's recently licensing is even more expensive, removing the single developer option. So it costs even more money than ever unless your app is 100% open source (including the back end code).
Yes. AMD infers to the fact that you separate your dependencies: Array, from your module: callback. However, if you have all the dependencies bundled, there are no scripts being injected and thus no asynchronous operation. Synchronous AMD makes sense if you think of AMD as an acronym for a format, and not something that always has to be async.
this is a long and old post now but I have been away. My point is if they don't know the language don't hire them or put them on js jobs. I'm not referring to people just learning programming or not working as professionals. That's a completely different context than dedicated front end teams which are common these days.
The performance boost comes out of the box, whereas with CJS you have to find the fastest optimizer and generate source maps every-single-time you rebuild. Assuming of course you want to actually be able to debug your code.
The issue is more than just nesting require callbacks. Many developers miss the point of explicit dependencies (myself included for a long while). If you don't fully articulate the dependencies of a module and they are only occasionally fulfilled due to async resolution, you will end up with race conditions. This is hardly a fault of AMD though and race conditions can exist in various parts of your application if you don't design it well. I suppose this is just bringing it to attention that if you aren't careful this is a potential side effect.
In spirit I think we probably agree on this point. I'm just saying that as a matter of practicality, with a language where the fundamentals are as inconsistent and/or theoretically unsound as they are in JavaScript (see the infamous "WAT" presentation, among numerous other examples), I wouldn't honestly expect *anyone* to get every tiny detail and edge case right. That includes professionals who have been producing solid, working code for many years, and even people who have worked on the language spec/standard for that matter. Of course I would expect a skilled professional to have a good knowledge of their tools. However, I would also expect them to code defensively to avoid edge cases rather than relying on them, if for no other reason than looking out for whoever has to read or maintain that code later. [Edit: I a word.]
Yeah, this article is seriously bad. Lots of grammar mistakes and outright falsities. 
I was just showing Defender to my buddy last week. Being a fan of Keith's CSS3D work I'm happy to hear this :)
Am I blind or does this not mention ES6/ES7, babel etc at all?
Oh, I'm sure you [can make it work](http://lebron.technology/)
&gt; sun microsystems Why do I suddenly feel skeptic about this site?
Yes. And the live url update is done with the history-api
Thanks. I'll look into it.
There's nothing wrong with that. If people are just starting out it's better to learn the basics than have to run a preprocessor before they even see any results.
[What circle?](http://i.imgur.com/Mq38Eo3.jpg)
Hi /u/utuxia, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Very impressive work
Sencha is shit and not worth the pain the in the ass. Just learn HTML.
Hey folks! I'm @gnuwilliam, and I have created this website, over 2 years ago... it was just an idea intended to help people starting with JavaScript, and help experienced developers to find good references. Yes, the site has many grammar errors, and probably a lot of mistakes related to the subject, but that's life. I haven't done it all by myself, there's a lot of contributors and people that I trust making changes to the page as well. I'm a brazilian guy, so my english is not the best, of course, since it isn't my native language, but I did my best to make it less worse. :) For all of you, complaining about the information in the website, thank you for your concern! That's important, and I appreciate it. I would love to hear from you what can be improved, and, if possible, would love to have you making contributions on github! I'm not very active there anymore, but there are other people taking care of it, and I still care about it. It helped a lot of people, and taking all the feedback that I got, I can say that most of them were positive, and that's what kept me motivated to continue investing time on the idea. As for the title, well... it might have been a mistake calling it 'the right way', but yeah, that's the title. I just want to say that, besides it saying it is 'the right way', there's no 'right way' to do JavaScript, nor programming, and I'm very aware of that in my almost 10 years of software engineering career. Ah, and we also describe that in the website &gt;Despite the name, this guide doesn't necessarily mean "the only way" to do JavaScript. See ya around!
Then you will need to create a separate element to be dragged, and call `.draggable()` on it. You might even want to make a function to generate them for you, something like: function makeDraggableElement() { var $element = $(document.createElement('div')); $element.css({ ... }); $element.draggable(); return $element; }
What I like about TypeScript is that it's typed. What I dislike is that it promotes class-based object model. Yes you can still do OOP the prototypal way (the real JS way), but TypeScript favors the other way. That's just not as sexy.
I've tried to put a function around the element, but i wont work .. Can you see the issue? https://jsfiddle.net/rFHd6/35/
If I was starting out with javascript today, I would definitely want to know about major changes happening to the language. Nothing wrong with learning &lt;=5.1, but it at least deserves a footnote. 
Honestly, heavy use of Ajax for a lot of small things is what makes the difference between a website users hate and one they love in my opinion. Great observation. Forcing reloads is typically cumbersome for the user. When they aren't there you typically don't even think about it. The site just zips along and feels much more fluid. Requires a lot of extra thought the first few times you do it but it's so worth it. 
I wasn't saying his choice was completely insane. I'm just saying, for the purpose of teaching, I think good coding practice should be followed, which is your "choice 2". Sorry if that wasn't clear. Reason being, if aspiring JS developers are blindly following example code, the example code better be following OO convention so they don't pick up bad habits. I'm only saying this because this is a mistake I've been making due to bad example code. There is no right answer but surely you must have an opinion on how it could've been better in this context? I don't think its necessary that it's explained but it might be helpful. If it's not following convention, I think there should be an explanation why it's not (eg. your speculation of whether the name and breed should be private). p.s. kind of silly to expect privacy in Javascript or any interpreted language. I might understand if it's an API, where an undocumented and private method is at risk of being accidentally used, but hiding properties and methods are two different topics. I'd say the least you can do is protect the property so that it's not configurable, enumerable, or writable. That said, a trade off to further conceal properties for the purpose of privacy, in exchange for a higher memory consumption and slower speed, is a bad trade-off to me.
Thought you guys would be interested.
Definitely cool, but the fact that it only binds at the end of the constructor seems like it'd be a pain. There was a gist going around last week for a "@bound" method decorator and it seems like this would do better as something like that. I can't seem to find the link now, but it would be along the lines of: export function boundClass(constructor) { Reflect.ownKeys(constructor.prototype).forEach(key =&gt; { // Ignore special case constructor method if (key === 'constructor') return; var descriptor = Object.getOwnPropertyDescriptor(constructor.prototype, key); // Only methods need binding if (typeof descriptor.value === 'function') { Object.defineProperty(constructor.prototype, key, boundMethod(descriptor)); } }); } export function boundMethod(descriptor){ let fn = descriptor.value; let prop = Symbol('bound function ' + (fn.name || 'unknown')); descriptor.value = null; descriptor.get = function(){ return this[prop] || (this[prop] = fn.bind(this)); }; return descriptor; } So the act of accessing the function via the getter would ensure that it was bound.
&gt; The performance boost comes out of the box Really? r.js + almond is not what I would call "out of the box" nor is it simple to setup. Making the jump from dev to prod is a huge headache in requirejs IMO, whereas browserify you have to compile every run. Having said that once it is all set up it's really easy to use. I have found browserify to be easier to use "out of the box."
The last recipe is quite a clever use of Promises. I've had to do similar asynchronous processing on a list and have always relied on a recursive solution, but I really like the idea of building up a promise chain of work items.
Maybe this? https://jsfiddle.net/rFHd6/37/
The versioning was rebooted (or the name depending on how you look at it): https://github.com/bitovi/legacy-steal/releases
Why not [rectangle.io](http://rectangle.io) ?
Duly noted
If you know 0 Javascript, you're in over your head here. You're going to want to [use the imgur.com API](https://api.imgur.com/endpoints/image#image-upload) (which luckily supports cross-origin requests), but you probably won't find a library that suits your needs exactly. Your best bet is to hire someone for cheap.
The big one is that Flow, like F# and ML has global type inference (I.e. compiler can infer function argument types) while C#, and most other languages only infer types locally within function body.
Technically, when you know JS, you already know every framework. Not a big secret, thou. Reading through documentation is fairly enough and choice depends on your project goals. Another problem what's really pisses me off ("Stop whining" part), is when a new framework releases/updates, all over across the internet articles with similar titles appear: "Stop using Angular", "Why I don't use React anymore?", "10 thing why you shouldn't use Backbone", "My family almost got killed when I started to use Underscore". No, seriously. Every time I'm trying to use Angular in my projects/work, I hear something like this: "Have you heard that Angular doesn't work when JavaScript disabled in browser?". Ugh.
Browsers don't support modules _yet_. Modules help code organization and reusability but they don't play well with HTTP 1.1 due to the overhead of sending each request. They do play well with HTTP 2 because that protocol was designed to better support the scenario of loading many small files rather than one large file.
This is true, but it will still be pretty slow with multiple layers of imports (and a bit slower with even a single layer). The perf characteristics will be pretty similar to CSS imports I think, so you'll still need to either use meta preloads, or a preprocessor (something like browserify, but as you said for http2).
http2 has the ability to push content to the client so combine this with the way es6 modules are designed to be statically analysed means that the server can push ALL the dependencies of a module to the client when the request it.
 Parse.User.logIn(username, password, { // If the username and password matches var query = new Parse.Query(Parse.User); query.equalTo("role", 1); //finding the role number query.find({ success: function(user) { alert('Welcome!'); }, // If there is an error error: function(user, error) { console.log(error); } }); This section has some syntax errors. You're trying to do something between { }, but that will not work since it's an object. Shouldn't it be more like this: Parse.User.logIn(username, password, { success: function(user) { alert('Welcome!'); }, error: function(user, error) { console.log(error); } }); Ref: https://parse.com/docs/js_guide#users-login
Hey thank you for the reply, however what im trying to achieve is to query the user object first to see whether or not they have a role number of 1 as this means they are a Admin, so they can access the webpage (not created that yet) so i have just done a simple welcome message instead. So essentially if the role number is one for that user then it should show that alert message
&gt; but in reality they just concatenate all your files and convert the require calls (and also imports in ES6) into a function that looks up the correct module. Not necessarily. You could use something like AMD + require.js to async load modules. People have been doing that for quite a while (way before Browserify and Webpack ever were a "thing"). As far as I know you will be able to do that with ES6 modules as well. &gt; So the browser never gets to see the import syntax at all, so it's completely pointless. Wh.. what? Why would it be pointless? Modules give you: - Better good code organisation (no globals, explicit dependencies) - Enables clean dependency injection (very nice to have for testing) Those are — in my mind — enough benefits to warrant this feature. There are probably others as well. I honestly don't know how you would build a mid to large app *without* modules. Just attach classes to some global app namespace? That'd be kind of ugly. When you're in a team and have to put out things that work and keep working, having modules and being able to test things in a sensible manner is very nice — if not crucial.
Then you need to make some changes. I don't know this library, but I assume you would have to do something like this (basically split it up into two steps): function checkAccess(username, cb) { // You will probably have to use "username" above somehow in this query var query = new Parse.Query(Parse.User); query.equalTo("role", 1); query.find({ success: function(user) { cb(true); // isAdmin = true }, error: function(user, error) { cb(false); // isAdmin = false } }); } $('.form-signin').on('submit', function(e) { var data = $(this).serializeArray(), username = data[0].value, password = data[1].value; // First check the user role checkAccess(username, function(isAdmin) { if ( !isAdmin ) { alert("Sorry, you're not allowed to do this"); return; } // Then proceed with the login Parse.User.logIn(username, password, { success: function(user) { alert('Welcome!'); }, error: function(user, error) { console.log(error); } }); }); });
No no I'm not criticizing the concept of modules at all, rather I'm wondering about why we need *ES6* modules when they don't make sense *without* a transpiler or another server environment.
It would be nice if the developer didn't have to worry about what js files were needed for each page, and could just send a main file with imports and it would grab all of the files. But that's a was off. Plus, I'm starting to become a typescript fan, and may never use it.
The difference would be that you would explicitly define the dependencies of each file. Which would be a lot cleaner than having a flat structure with the script tags.
This is great thanks. I really didn't like the fact I was returning a new class as meant when debugging it had the wrong class name. This solves the problem and enables it to be used on classes or methods. Perfect! So this is what I have now. export function bound(...args) { if (args.length === 1) { return boundClass(...args); } else { return boundMethod(...args); } } /** * Use boundMethod to bind all methods on the constructor.prototype */ function boundClass(constructor) { // (Using reflect to get all keys including symbols) Reflect.ownKeys(constructor.prototype).forEach(key =&gt; { // Ignore special case constructor method if (key === 'constructor') return; var descriptor = Object.getOwnPropertyDescriptor(constructor.prototype, key); // Only methods need binding if (typeof descriptor.value === 'function') { Object.defineProperty(constructor.prototype, key, boundMethod(constructor, key, descriptor)); } }); return constructor; } /** * Return a decriptor removing the value and returning a getter * The getter will return a .bind version of the function * and memoize the result against a symbol on the instance */ function boundMethod(constructor, key, descriptor) { let _key; let fn = descriptor.value; if (typeof fn !== 'function') { throw new Error('Only methods may be @bound, received: ' + typeof fn); } if (typeof key === 'string') { // Add the key to the symbol name for easier debugging _key = Symbol('@bound method: ' + key); } else if (typeof key === 'symbol') { // A symbol cannot be coerced to a string _key = Symbol('@bound method: (symbol)'); } else { throw new Error('Unexpected key type: ' + typeof key); } return { configurable: true, get () { if (! this.hasOwnProperty(_key)) { this[_key] = fn.bind(this); } return this[_key]; } }; } 
In my opinion: Standardisation (as compared to today's AMD, commonJS, requireJS...) and not having to build assets in development.
I think it should be noted that TypeScript's lead designer was the lead designer for C#. I think it's fairly to say that it's inspired by C#, even if it's different.
The point of requirejs, commonjs, es6 imports, etc. is that all of these module systems can be used to compile clean modularized development code into a single file for the browser. Eventually browsers will support the ES6 standard and you won't even need to compile/transpile ES6 to ES5. You are confusing a standards spec with browser availability. The spec does nothing until someone implements the spec in a browser.
This is a big one, reconciling the many module standards. 
Agreed, that's an even cleaner solution.
Not sure why you got downvoted, it's a good question. The main benefit is having a dependency graph, and moving dependency declarations from the html layer to the script layer.
xkcd link in 3... 2... 1...
but this is one to rule them all
You can't move the mouse in JavaScript. You can only read its position and get notified of mouse events (down/up/move/...) What you could do is hide the cursor with CSS and move a fake cursor div with JavaScript, but you would have to move the div back to the mouse position which will be complicated (what if the mouse is moving? what if it leaves the window? ...?) What are you actually trying to do?
Not only is this quite old, it is also very wrong. I don't know where to start...
What about something like this: mouseclick, left, 200, 400, 1, 0
Hey gravity, can you give me another 50 bucks? Awesome, you're the best, buddy.
[black hole lending](https://www.youtube.com/watch?v=-DT7bX-B1Mg)
Even better would be to combine it with service workers, which can tell the servers what modules you already have cached, and then the server can push only the modules you are missing. The way we think of servers today, as simple stateless file servers, will change in the next few years. It won't be long until we all use dependency servers that understand the entire module dependency structure of your website/webapp, not just for js but for css and html (web components) too. 
There are some nice benefits of having a static module structure. This was a design goal for es6 modules. Please read this if you haven't, especially 4.2: http://www.2ality.com/2014/09/es6-modules-final.html?m=1
Is it a game or something? If it's HTML, you could just find the element and trigger a click event, a la: var clickEvent = jQuery.Event("click"); clickEvent.ctrlKey = true; $('.some-button').trigger(clickEvent);
It's not fun making sure script tags appear in the right order, though.
Wicked cool. Very impressive how fast and responsive the demo runs.
[Quick and dirty prototype](http://jsbin.com/royade/1/edit?html,js,output) that might help you get started. Comments on your thoughts: * I don't think D3 is the right choice, [Snap.svg](http://snapsvg.io/) will give you a lower level API to work with SVG elements. * SVG importing is also implemented in Snap.svg. * Don't think there's a real difference in Google's vs Adobe's approaches. You can draw any figure with `path`, but with `circle` you can only draw circles. Different levels of abstractions and Adobe built tools that understand you at a higher level so they know you are drawing not just any shape, but specifically a circle for example.
"Push" really means "Suggest". For a rough example: The server says, "Visitors who requested `about.html` also want `jQuery.js`, `lodash.js`, `mySuperFramework-0.2.4.js`, and `about-actions.js`." The client can then check its own cache, discover it has all but the last one, and request just it.
http://stackoverflow.com/questions/66837/when-is-a-cdata-section-necessary-within-a-script-tag
Having a single declarative way to handle dependencies is a lot better than having dozens of imperative hacks. Also, browsers will support this. This will be very handy for development. Having this built into the language will improve interoperability, it will improve the tooling, and, since it's declarative, you can start to take care of dependencies before you've executed anything. You see, actually getting to the point where you start to execute the code does take a moment. Declarations can bypass all of that. As soon as you see an import declaration, you can put it in the queue. This happens way before you've built the AST and compiled the code.
CDATA won't let you write `&lt;/script&gt;` in an inline script. Also, that's for XHTML, not HTML5.
Can't you just do something like this: &lt;script&gt; console.log('begin'); var x = 'foo&lt;\/script&gt;bar'; console.log('end', x); &lt;/script&gt;
I would imagine they take a snapshot of the way the page would look based on device/screen width and track mouse movement/clicks, probably have some sanity checking with mouseover events, and then replay the movements over a rendering of the page
Yes, and `'&lt;/scr' + 'ipt&gt;'`, and `'&lt;/scr ipt&gt;'.replace(' ', '')`, and any other workaround. I just thought it was interesting that there actually is a way to write the actual character sequence, not something that evaluates to it, and that the way to do so is completely unexpected (to me at least).
Not sure. What you've written is dsp : t -&gt; Math.sin(t*tau*(220 + Math.sin(t * tau * 3))) but I think that should be right.
Hmm, I may have misunderstood how it works then. I thought the file was sent to the client no matter what, to reduce RTT. Do you have somewhere with more information about push? Most of the articles I've found have been too high level, and I haven't had the opportunity to look into the spec yet. 
Assuming you add the SVG on to a page -- i.e., just include it as a DOM element -- then within javascript, you can retrieve and manipulate the elements similar to how you could do with normal HTML elements. i.e. rejig their position and attach drag handlers. It gets a bit tricky because each element here is actually a few paths, i.e. the text and border around an element are separate elements. In fact, this would make it damn near impossible for the drag thing -- what I would do is drop SVG for the button-like things and just make them divs with borders -- that makes it a bit easier to drag as one component. You can randomize the positions of all elements relatively easily and if you keep track of their finished position - the solution button could just iterate through all the elements and reset to their final position. The hardest part of this is the dragging/dropping just because the dragging API is so atrocious. You can probably find a library or use jQuery UI for that. But again, dragging multiple elements as one will be very tricky.
If there's a 'getting started' equivalent for React + SailsJS, I'd love to see it.
I heard it in an episode of Security Now, and now I'm looking for that same information.
That's true but I'd still prefer the backslash way, consider this case: &lt;script&gt; console.log('begin'); &lt;!--&lt;script console.log('middle'); var x = 'foo&lt;/script&gt;bar'; var y = 'foo&lt;/script&gt;bar'; console.log('end1', x); console.log('end2', y); &lt;/script&gt; You would need to do the following to get it to work: &lt;script&gt; console.log('begin'); &lt;!--&lt;script console.log('middle'); var x = 'foo&lt;/script&gt;bar'; &lt;!--&lt;script var y = 'foo&lt;/script&gt;bar'; console.log('end1', x); console.log('end2', y); &lt;/script&gt; 
Does heavy use of Ajax equate to a bad site?
[`PUSH_PROMISE`](http://http2.github.io/http2-spec/#PUSH_PROMISE) The server tells the client it's *going to send something* and the client can send an `RST_STREAM` response with the stream ID, to let the server know it does not want it. Push Promise which is only good for cacheable content, so it makes sense that the server can also simply push additional resources without advanced notice.
I'd take a look at lodash. It's doing a lot of interesting things that aren't really browser related, just pure JS.
need, please add support for keyboard arrows or awsd for those of us on the PC, clicking with the mouse is a bit of a pain for such a game where the keyboard would help.
What version of JS are you trying to learn? ES5, ES5 with promises, ES6, ES7? Node.js with co/mz and generators? Some places are actually pretty serious about CoffeeScript. Are you learning React? Then you'll need to know JSX. I don't believe there is a single correct way to do it. If I were starting out I would learn trendy things like ES6, promises. But you could go and learn one way and then find yourself on a team that is religious about a totally different way. I would say survey as many different popular projects as you can. But you aren't really going to learn anything without making your own modules and applications. 
This is only interoperable among browsers that follow the HTML5 parser (and only since Simon got this magic in in ~2010). Some older browsers may exhibit similar behaviour by virtue of reparsing the input when it ends in a script element (and avoiding reparsing was a stated goal of the HTML5 parser).
You don't wanna study a big sprawling library like JQuery. Someone asked this recently and /u/SubStack suggested to look at an npm module called uniq.
Async Mouse Events
Popular packages tend to be old and evolved over a long period of time for very unusual particular reasons. Popular libraries also tend to have obscene amounts of scope creep and incidental complexity. It's much better to study smaller, lesser known packages with fewer complicating factors and simpler interfaces.
&gt; I really think that you'd be doing yourself a disservice by trying to wrap this too deeply up in angular. I agree. It feels like Angular simply wasn't made to serve this type of purpose. &gt; Mapping is an incredibly complex domain, much of which can have next to nothing to do with the DOM. Clickable elements could even be baked directly into the image files from the server. I agree. I was thinking more in terms of SVG.
I used to work at the consulting side of mapbox (developmentseed), and we used backbone for a lot of our map oriented sites. Interestingly : A lot of our sites seemed to end up with clicks on the map modifying the url, which would kick off the backbone router and transform the state needed to render things. IE: if you send someone a link to a page with one of the pointers highlighted, it would need to be highlighted when the other user opened it.
Yeah I don't think the use case for jQuery is similar to anything a regular dev would write. They're going for more speed as the library is used everywhere so probably they resort to weird hacks and code repetition for a slight edge in performance.
!!! This could be what I'm looking for! My question is--can it produce popovers similar to what I see on FourSquare? Those have lots of content, images, etc.
http://underscorejs.org/ http://underscorejs.org/docs/underscore.html
Also, the [annotated source](http://underscorejs.org/docs/underscore.html) is well done.
This is a fairly standard convention. The square brackets indicate something that is optional. So, when they write "function [name]() {}" they mean that you can omit the name if desired. You can write "function foobar() {}" or just "function() {}". The nested version is just saying you can provide as many arguments as you'd like.
Things in brackets are optional. For example, foo[, bar] ...means either "foo" or "foo, bar", i.e. the second thing is optional and may be omitted. The comma is included in the bracket because "foo," doesn't make any sense; the comma can only be there if "bar" is also there. These nest, so: foo[, bar[, baz]] ...means "foo", or "foo, bar", or "foo, bar, baz", i.e. the second and third items are optional, but if the third is given the second must be given as well, i.e. "foo, baz" is not valid. Contrast that to: foo[, bar][, baz] ...which means "foo", or "foo, bar", or "foo, baz", or "foo, bar, baz" are all valid. It's really just simple text substitution. And it's not particular to MDN or JavaScript, you see this in technical documentation of all kinds, e.g. the Python documentation uses this same notation, as does the Ruby documentation, the PHP documentation, etc. It's just one of those things. 
I don't know of anything, maybe somebody else does.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Backus–Naur Form**](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur%20Form): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __BNF__ (__Backus Normal Form__ or __Backus–Naur Form__) is one of the two main [notation techniques](https://en.wikipedia.org/wiki/Metasyntax) for [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar), often used to describe the [syntax](https://en.wikipedia.org/wiki/Syntax_(programming_languages\)) of [languages](https://en.wikipedia.org/wiki/Formal_language#Programming_languages) used in computing, such as computer [programming languages](https://en.wikipedia.org/wiki/Programming_language), [document formats](https://en.wikipedia.org/wiki/Document_format), [instruction sets](https://en.wikipedia.org/wiki/Instruction_set) and [communication protocols](https://en.wikipedia.org/wiki/Communication_protocol); the other main technique for writing context-free grammars is the [van Wijngaarden form](https://en.wikipedia.org/wiki/Van_Wijngaarden_grammar). They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory. &gt; --- ^Interesting: [^Extended ^Backus–Naur ^Form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form) ^| [^Augmented ^Backus–Naur ^Form](https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_Form) ^| [^Molecular ^Query ^Language](https://en.wikipedia.org/wiki/Molecular_Query_Language) ^| [^John ^Backus](https://en.wikipedia.org/wiki/John_Backus) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqafdpb) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqafdpb)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Works great on mobile. Cool idea! Nice work. 
The point is that browsers will eventually support modules natively (=no more transpilation). Transpilation simply allows you to try out future language features in current browsers.
Hi /u/10_6, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
And they aren't actually block comments, but line comments, and both `&lt;!--` and `--&gt;` work. So, if you want to write example output in comments, you could do this: 10 + 5; --&gt; 15
Do you have some suggestions?
Bump?
I thought of that too, but then reasoned like this. Sin(x) gives always gives a value from -1 to 1 regardless of x. Therefore hz1 + sin(t, hz2) should be a sine of the frequency hz1 +/- 1. But apparently that is not correct unless I've encountered some floating point problem.
Anything by https://marijnhaverbeke.nl/.
It's interesting that they added imul and fround just to make JS a better compile target. I really hope we'll see SIMD support soon.
https://github.com/getify/You-Dont-Know-JS is a nice book series to really learn JS.
Do you expect to work with JS as a profession? Remember that almost all existing code today is written in ES5. I'm not saying you shouldn't learn ES6 but if I had to start again today, I'd start with ES5 and then work on ES6 afterwards. JS is a small language that, while it has its quirks, is a quite small language that you can learn in a weekend with a premium tutorial site and a couple of small projects. Then move on to ES6. Much of it overlaps anyway. If JS is just a hobby for now, I wouldn't mind starting out with ES6 and Babel though, as shizzleberry suggests.
There is a function parseInt(string) That will convert strings to integers.
Actually it is right - &lt;!-- is valid single comment start in ECMAScript spec.
This does sound correct: export function dsp(t) { var vib = Math.sin(t * tau * 6) * Math.pow(2, 10/12); return Math.sin(t * tau * 440 + vib); } This is a phase shift. What I did before might be something else, I don't understand it.
Why remove them at all? They don't fire unless the console is open, right? And they represent a trivial amount of space compared to projects that heavily utilize them for debugging (and, in turn, would be thinking about removing them). They can also be very useful for remote debugging (via logmein or whatever) if you've got a particularly quirky problem than can't otherwise be recreated in your dev environment.
In Python, but same issue: http://stackoverflow.com/questions/28185219/generating-vibrato-sine-wave Phase issues are non-intuitive and have bitten us all at one point or another :) Edit: Note that the code in that example uses 16-bit signed integers for samples, whereas wavepot/WebAudio uses floating point.
You dont want your users to see the logging statements if they open up the console even though its a remote possiblity. But you also might need to debug a production bug on a client's website with minified js files. At that time its better to have some way where from console.log statements you can do some basic debugging 
Because you should never declare variables inside a loop.
Interesting, this appears to be the same approach I took with bringing true function level parallelism to javascript by exploiting web workers. Data is split into multiple pieces, each thread does the same operation on a subset of the data, the data is then aggregated back together. Out of curiosity does SIMD in this context make use of multiple threads or is this just exploiting instruction level parallelism while maintaining javascripts single threaded nature? The reason I ask is for legacy devices that do not support web workers I am simulating threads by making use of setTimeOut which in practice seems to also allow me to take advantage of the instruction level parallelism in modern cpu's, as it makes the operations async and does not block the dom while they operate. https://github.com/austinksmith/WebHamsters
hey thanks!!! Seems as great books
This is not a Github repo, a book that I used to read called Build Your Own AngularJS by Tero Parviainen [github](https://github.com/teropa). It's a good book to learn more practical javascript tip tricks and good code. I like the book very much. just thought of sharing. give it a look [link to book page](http://teropa.info/build-your-own-angular). *bonus for me is, this book teaches me javascript testing :D . i am xgh developer before, but still kept the essence*
https://es5.github.io/#x15.4.4.19 - look at 8b) - hasProperty is used to ensure that the property is set. As x-skeww said, use fill() before map() to make sure it works.
Or use something like [pimterry/loglevel](https://github.com/pimterry/loglevel) and a config like.. App.config.logLevel = 'debug'; log.setLevel(App.config.logLevel); log.error('weee'); log.debug('oh noooo'); 
Since I have to support IE in a number of versions I've beaten it into my head to never use console.log. I have a wrapper for it that first checks to see if logging is enabled and then also verifies that the console exists before making the call. The body of said function looks a bit like so: var _log = function (obj) { if(m_debug === true &amp;&amp; window["console"] !== undefined){ console.log(obj); } } This avoids all the IE issues with the console and allows me to enable/disable the logging at run time/build time. 
It's not a big jump, if you know the language. It's a huge jump if you don't. And then you have all the problems with working out what's broken when the code that is running is not the code that was written.
I personally wouldn't use ES6 transpile for anything that's a serious application. It would make debugging a nightmare. I'd rather just re-write later once browser adoption is better. By then I'm sure some best practices will come out too for ES6. Edit: I stand corrected. My own ignorance of sourcemaps. TIL debugging ES6 is actually excellent with source maps!
so not a recording... more of a reenactment
Have you ever heard of the library "q"? It has some amazing functionality for handling sync promises, you can funnel the promises into an array and then wait for the array to be settled. Returns an array of promise elements with a results value, you can loop to ensure success if needed. 
Because you might be supporting IE8, and if the dev tools aren't open Console is null.
thanks will try to study this
As another poster mentioned you can get Array.prototype.fill() from the ES6 polyfill, which is a super handy function for doing just what you wanted in the original post.
No problem. The link from JonDum should be a great source. I think it's easier to get up to speed with video tutorials and signed up for the ones at tutsplus. They have quite a bit of courses on vanilla JS and you get a clear path as a beginner that you won't get with random tutorials scattered around the web. Don't know about ES6 though. You can usually watch the first couple of episodes per tutorial for free to see if you like their style.
&gt; It would make debugging a nightmare. It really doesn't. ES6 'isms' all have direct corollaries in ES5. It takes barely any time at all to recognize the patterns, and development is back to being the same as it was before. Source Maps are also a thing, and they work very well. Projects like Ember.js have moved to complete ES6 support by bringing the babel transpiler into ember-cli by default. The flexibility that the module system alone gives you is worth it, not to mention bound functions and the polyfill functions.
That is very likely – SIMD.js seems to be making good progress: https://github.com/tc39/ecma262
One of the reasons why I would recommend using lodash: _.range(26).map(function(index) { return String.fromCharCode(65 + index); })
Thank you very much. I appreciate the help.
Thank you for the reply. It is appreciated.
Careful with .fill() unless you're using a transpiler. It's not a stable ES6 spec (edit: technically stable, but not well supported). Only Firefox has out-of-the-box support. Even Chrome has it hidden behind a flag.
I see so this is more programming for the vector units themselves where as the approach I used was more for general purpose computations, do you know if the polyfill is supported within web worker threads? Doing SIMD instructions and multithreading together could reach some pretty insane speedups. 
actually the latest draft is [RC4, April 3](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts) but that doesn't change your point
With ES6, you could also use `Array.from` which ignores "holes": Array.from(new Array(26), (_, i) =&gt; String.fromCharCode(65 + i)); Doesn't seem to be faster than the fill/map combination in Firefox though, which is kind of strange. My impression was the extra iteration using `fill` would have been slower... http://jsperf.com/generate-alphabet-array
There are very simple shims you can add to address this though
Speaking from experience, you couldn't be more wrong. ES6 code transpiles to clean and easy to read ES5, as none of the 'features' are particularly complicated, just annoying. For example, arrow functions just create a temporary local variable _this and use that within the function. I use Babel for both node.js and front-end 'serious' applications with no issues. Only makes my code cleaner. Also forgot to mention that Chrome Dev Tools has native support for sourcemaps.
and when ajax activates again on site without changing url ? 
Yes.
Hmm... Firefox gives me. &lt; Array.from("abcdefghijklmnopqrstuvwxyz"); &gt; Array [ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", 16 more… ]
That's good general advice, though for this task I'd feel dirty doing all of that when you only need: for (var index = 0, chars = []; index &lt; 26; index++) { chars.push(String.fromCharCode(65 + index)); }
I meant that you can write: [..."abcdefghijklmnopqrstuvwxyz"] Instead of: Array.from("abcdefghijklmnopqrstuvwxyz") https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
Why would you do this in the first place?? The only reason to use 'new Array(N)' is to force low-level optimizations in modern JS engines (btw, this is only more efficient than .push() if you have less than a few thousand objects). .map() makes a new array instead of changing the original. Why would you create an array of 26 items just to make another array of 26 items and then GC the first array? As a final note, you're generally better off avoiding the native map function because it is an order of magnitude slower than trampolining a for loop (like ramda or lodash does behind the scenes). R.mapIndexed(function (x, i, l) { return i; }, new Array(26)) or the lodash equivalent won't have this problem because the object is assigned to a variable name first.
Another map solution would be OpenLayers (openlayers.org) What's cool about this product is you can choose to use GoogleMaps as the map server in the beginning. Then if you feel you need to operate your own map server you can transition it. They've got some tutorials that show you how to do it either way you choose. BTW, OpenLayers is what flightaware.com uses. Disclaimer: Haven't looked at using this with Angular, but the API is what you'd expect from a typical JavaScript library.
That's pretty cool, i'll check it out, thanks!
ES5 flavor: var a = [], i; for (i = 0; i &lt; 26; i++) { a.push(String.fromCharCode(65 + i)); }
Or this: var arr = []; while (arr.length &lt; 26) { arr.push(String.fromCharCode(65 + arr.length)); }
Isn't it better to allocate all of an array's space up front if you know how big it's going to be rather than allocating additional space piece-wise like this? Or does it not matter for JS's sparse arrays?
Really? I'd feel the other way around. The map() function describes the intent of the statement much clearer. My first thought seeing your version was that you were cheating by leaving out the chars declaration, until I noticed it was hidden in the for-initialization. Also, both don't exactly do the same thing; the map version is a single statement returning the requested array, whereas the for version stores that same array in a temporary variable and can thus only use it in a follow-up statement. Simply put, I would not use the manual for loop unless it was part of some performance critical code.
Actually Emmet is written in pure JavaScript so it's already all you are asking for. Please see: http://emmet.io/download/ &amp; https://github.com/emmetio/emmet
&gt; The map() function describes the intent of the statement much clearer. I think that's arguable -- it certainly does if you come from a functional background, but I know quite a few front-end devs that have zero experience with functional programming, and would grok the `for()` much more readily. &gt; My first thought seeing your version was that you were cheating by leaving out the chars declaration, until I noticed it was hidden in the for-initialization. That's a simple implementation detail that could have been declared on the preceding line... &gt; Also, both don't exactly do the same thing; the map version is a single statement returning the requested array, whereas the for version stores that same array in a temporary variable and can thus only use it in a follow-up statement. That's hair-splitting to me, and I think it's hard to make an argument that one is unequivocally better for the general use-case. In your version, sure you can do more without an additional statement, but really, what's the problem with an additional statement? I think cramming too many operations into a single statement is poor for readability, maintainability, and it certainly can hamper debugging at times. And as a counterpoint, most of the time I'd rather have an additional statement than an additional function invocation. But yeah, I was mainly just offering an alternative for this extremely simply use-case, and as I alluded to, it definitely depends on what you're doing. If all you need is an array of letters, I'd favor mine; whereas if you were needing to a couple more operations, then using `map()` might be a better fit.
4:03.2| 4:00.01| 3:53.77 ---|---|---- 2012| 2013| 2014 Essentially plot the above on a line graph/chart, with the y-axis scale in a mm:ss format. The problem was that the chart couldn't accept the data in mm:ss format. It could only accept the data in integers, so for example, 4 minutes and 7 seconds would have to be entered as 247, rather than the ideal 4:07. This would mean the chart y-axis would be a scale of integers in the 200s, rather than 4:00 etc. I've actually managed to solve 90% of the issue by using the scaleLabel: in the [global charts config](http://www.chartjs.org/docs/#getting-started-global-chart-configuration), by entering the data as seconds, but manipulating the y-axis to display in mm:ss format, like this: scaleLabel:"&lt;%= (Math.floor(Number(value)/60)).toFixed(0) + ':' + ((Number((value)/60)-((Math.floor(Number(value)/60))))*60).toFixed(0)%&gt;" The only remaining issue is that it displays &lt;10 seconds as one number (i.e. 4 mins 5 seconds would display as 4:5 instead of 4:05). 
new array? what is this 1998?
yeah. a string can be anything. i don't understand what you're trying to do besides confuse people or state the obvious. Its like saying "look, you can use PHP in your script tags!!!" then showing us: console.log('&lt;?php echo "this is php"; ?&gt;');
I never encountered a case where I had to use the `new Array()` rather than the literal version `[]`. The reason I used it here was just because it was shorter to write than declaring a new function with a loop inside. Maybe in some libraries where performance is very important it makes sense to pre-alocate arrays. Eg: a matrix for example.
Haha yeah I usually use the literal version too but this was just shorter to write than a function with a loop inside.
Yup. This was my first guess too but it turned out to be the undeclared value issue mentioned in the StackOverflow thread.
If you intend to work in the field either now or any time within the next few years, you _must_ know ES5. And as a bonus, everything you learn in ES5 will still be true when you get to ES6.
We've been building a lot of reusable UI components in Angular and have been looking for a good way to share these across the organization. This coupled with our own NPM registry should do the trick. 
One of our concerns is about the stability of React. It is relatively new, and not yet at version 1.0. Is this a concern of yours?
Total guess, but you could use the WebRTC api to do this, at least in chrome, but it seems like a huge privacy issue to me.
wow, what a coincidence, just saw a pluralsight course with him today
Neat experiment, yes - that is certainly revealing.
This is what I'm trying to do, any ideas on how this would fit within the chart.js scaleLabel: &lt;%= value %&gt; system?
Browsers will eventually implement ES6 and will continue to support ES3 and ES5 forever. As a result that is ABSOLUTELY NO hurry to rush towards ES6. In all the new features offered by ES6 only a select few are actually new capabilities not achievable in ES5.
If you're using jQuery, just use the .done method and call your named function.
The problem is more that JS doesn't have a great standard library for functional programming. But all you need to do is pull in something like [Ramda](http://ramdajs.com/), and then you can do ``` R.range(0,26).map(x =&gt; String.fromCharCode(65+x)) ``` or ``` R.range(0,26).map(R.compose(String.fromCharCode, R.add(65))) ``` FP is worth doing in JS, but not without a bit of help.
&gt; What's wrong with this? for (var arr = new Array(26), i = 0; i &lt; arr.length; i++) { arr[i] = String.fromCharCode(65 + i); } It uses '**for**'.
A string can be anything *in JavaScript*. But when you embed JavaScript in HTML, your JS can't contain "&lt;/script" (normally) or else the HTML interpreter will think you've exited the script block and won't even pass anything that follows to the JS interpreter. As I said in the original post, try saving my first code block as a .html file. It won't work.
But it's not coffeescript ...
I changed it to the javascript method using == and it still causes nothing to show up in the table.
Thanks a lot! Works like a charm!
for loops are bad because the syntax of for is arcanely designed. You have a paranthesis with three sections, where it isn't intuitively obvious what to put in each section. It is easy to make mistakes if you aren't intimitely familiar with the syntax. for loops are foot guns. It is only a matter of time before you hurt yourself.
Is "this.selectableRecords[i].partNumber" a string? or an object? Do you need to convert it to a string first? What does "nothing to show up in the table" mean? Does that mean your code breaks the output or just that you don't see the change in your output? If your code is still running but you can get the change you want, test it with something that you know will work, like using the loop variable "i", example: if(i == 10) { // do something obvious here }
It was on a pet-project and it was just a quick way to solve a problem no need to get aggressive. In any case, there are no unnecessary iterations anyway, data structures is arguable.
`new Array(5)` is the same as `var arr = []; arr.length = 5`. You set the length, but there are no real items in the array. Methods that just use the length property actually work here. But methods like map/forEach that iterate over the actual items won't do anything.
What programmer isn't intimately familiar with the syntax of a for loop? That's Programming 101. I can think of a dozen different concepts that I run across in any typical day that are way more complicated than a for loop. Avoiding for loops because some people might not understand them is aiming for a common denominator so low that it only plausibly includes people who aren't programmers at all. Someone who doesn't even understand a for loop certainly isn't going to understand any of the rest of the program, unless said program is completely trivial.
it's monday
It wasn't meant aggressively :) I used to collect hacks like that like I had to live off them, but it's been my experience that writing a few extra lines of code can make the result not only faster but more understandable. `Array.apply` unnecessarily iterates over `Array(26)`, and `Array(26)` creates a new `Array` that's never used except to read its length. And sure it's all arguably beneficial for a single execution over such a small range; the benefit, I believe, is in making a habit of choosing an explicit and imperative approach, which adds up over all the times it's written into a program and all the times each of those pieces of code is executed.
As always, you shouldn't be adding this kind of thing to your code until after you've profiled your app, and tested the optimization to ensure it actually helps (across multiple browsers). That said, the short version is that modern JS JITs can use "var x = new Array(myLen);" to help ensure a 'real' array is used (if all the data inside is the same type). That's the short version (google if you want the rest of the answer). Generally, it is best to avoid the Array constructor (and other primitive constructors) because their argument overloading has some oddities. 
Considering that pretty much everything in ES5.1 has a polyfill for ES3, I would recommend learning ES5.1 (most of the differences are library functions anyway).
Thanks, this looks to address my questions and it looks at the coffeescript functionality I was talking about.
It's actually much more likely that someone would be using a transputer without a polyfill. Emberjs for example is using babel to transpile es6 by default, but isn't including the polyfill. I face palmed pretty hard when I realized that. Then when I complained to my co workers, they asked "what's a polyfill?" So I think it's probably a more common situation than I would have guessed.
Using the `.apply()` method "iterates" over the passed parameters to put each one into an array, and then you run `.map()` against it.
Interesting. I tried `[1,1,,,1]` with the same result. There appears to be a distinction between `undefined` and *unassigned*, which can be coerced to `undefined`? I need to read some specs. :(
I win at jsgolf: var alphaArray = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''); fromCharCode(), map(), fill(), Object.keys(), stop the insanity. Split a string, be done, move on.
Is this a joke? &gt; SQL Interface &gt; The spec for accessing model data from HTML using SQL. ... What?
My thoughts too.
Maybe, maybe not. We already know declarative languages designed to access data from structured data files: - XPath, XQuery, used in XSLT to transform XML into anything you like; - CSS selectors, used in CSS to style specific HTML elements in specific circumstances; - more? Granted, at the moment XSLT still requires a processor, and I don't remember whether web browsers can do that independently, but it certainly isn't outside the realm of possibilities.
range()/map() is easier to write and maintain, less error-prone, involves less state, and it's easier to compose with other operations. :) Most of the time, you don't need `for` loops.
I second this.
I haven't really used native yet, or done any app development with React yet; but I use React for work. It's real nice; I second this. It's ^really ^^fun. 
I went for KendoUI+AngularJS+BootStrap+some cordova plugin with a REST server running on Jersey. At least you get lot there's a lot of support right at the beggining with these framework. Yet, I'll tend to agree that that ember might be a better suit for a ruby setup.
The relevant concept here is ["elisions"](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array-initializer). `new Array(3);` is equivalent to `[,,,]`, not `[undefined, undefined, undefined]`.
[Meteor](https://www.meteor.com) integrates with [Cordova](https://cordova.apache.org/) seamlessly. In fact, it's been the most painless process I've ever used. After developing your app you simply run two commands and your app is now packaged in ios or android, just like that. Literally, that's it. I've answered how to do this on reddit and stack overflow recently, for more in-depth explanation on compiling to native with meteor check [that out](http://stackoverflow.com/questions/28727648/meteor-cordova-production/29380907#29380907). For more resources, just try out the meteor tutorial on their site or you can check out [discover meteor](https://www.discovermeteor.com/) which was hugely helpful for me. ---------------- Or if you're just looking at how to compile a static website into an app, use [phonegap build](https://build.phonegap.com/).
Yep. 'Twas just a bit of /s
What do you mean by "declared"?
feel free to stop by /r/reactnative Android support is out soon!
As /u/my_new_account's has already said, splitting an string of characters 'A...Z' is the shortest solution to the problem. But just describing it as "jsgolf", is under selling it. Not only is it the shortest code, it's also the fastest, least error prone and a lot easier to understand what it's doing at a glance compared to any map solution. 
I second this. Using Ionic and NgCordova maybe the best option at the moment. I'm watching react native too but it needs to go further. 
"A" to "Z" is just is just an example but if you need to do this for larger ranges (like my case) it stops being a possibility.
Could I use this with a Node.js website?
&gt; I win at jsgolf Spread is shorter: [...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'] By the way, "String.fromCharCode(65 + i)" was just used as a placeholder. The goal isn't actually to create an A-Z array. It's about using some function to populate an array. Dart, for example, has the `List.generate` constructor for that: var a = new List.generate(26, (i) =&gt; new String.fromCharCode(65 + i));
&gt; splitting an string of characters 'A...Z' is the shortest solution to the problem. The goal isn't actually to create an A-Z array though. That's just what the arbitrarily chosen placeholder function happens to do. The real goal is to populate an array with some function.
Well done, but remember the point of OP's example was to point out a gotcha with map(), their example was there just there for demonstration purposes ;)
I wouldn't say avoid Angular at all costs. Angular certainly *can* have perf problems, but that's not to say that it *will* have perf problems. The tool is only as smart as its utilizer. Is it easy to have problems with Angular? Sure. It's easy to have perf problems with Ember, React, and Backbone too.
How would you build in functionality with NFC?
Thanks for the detailed response. I didn't know what I was talking about in regards to the loop copying over static properties of the constructor function. In regards to the pre-ES5 object creation mechanism, I found what I assume to be the rough implementation of Object.Create as described [here](http://stackoverflow.com/questions/2766057/what-is-happening-in-crockfords-object-creation-technique) `Object.create = function (o) { function F() {} F.prototype = o; return new F(); };` Which looks similar to Ctor. I still don't really get what's going on here. `function Ctor() { this.constructor = child; } Ctor.prototype = parent.prototype; child.prototype = new Ctor(); child.__super__ = parent.prototype;` I noticed child.prototype = new Parent() isn't used anywhere. Don't you want to do this so that you can get a copy of all the properties of the Parent class? I don't get what `this.constructor = child` means. Isn't this.constructor Ctor itself? Edit: Wait a minute. Doing `Ctor.prototype = parent.prototype` then using `child.prototype = new Ctor()` would do accomplish that, but without the constructor function variables, just the prototype variables. Using `__super__.constructor.apply(this, arguments);` would call parent.prototype.constructor which is the parent constructor function itself, thereby getting the constructor function (per instance) variables. So I don't quite get why it's being done this way, but it's something. So I think understand everything now except for `function Ctor() { this.constructor = child; }`.
Haven't worked with NFC myself, but googling "Cordova NFC" shows a few promising plugins
I have not had many good experiences with KendoUI. Telerik is hit or miss.
&gt; This is mostly what you'd get by doing it directly, but with a level of indirection through Ctor, precisely so you can put there those "static"/own properties of the Parent. How does using Ctor enable to copy the parent's (static) properties to the child? If you don't go past the loop, it already seems to do this (without Ctor being used at all).
I would recommend Ionic Framework, it was seamless when I used it recently.
What he said. The fact that the items in `new Array(26)` don't exist doesn't matter, `.apply` is still reading them then storing the `undefined` return values.
Right. Now that I'm testing it, I see that you don't even need the extends function at all for the example that they have set up. You just have to change some __super__'s. For example: ` superClass.prototype.move.call(this, 5);`. I still don't get what the Ctor stuff is doing. Do you know of an example when that would be important?
Being that you are a ruby on rails developer, you'll probably be most comfortable using the [RhoMobile]( http://rhomobile.com) framework. The framework builds native apps for Android and iOS using web development skills, much like phone gap but with ruby in a very rails-like environment. Thanks to acquisitions and corporate idiocy concerning the handling of the product, very few people have heard of it but, it's actually a great native app development tool. Give it a try, I think you might like it.
That seems ... odd. If you reverse the order of the tests is the same function still fastest? (That is, could it be that the order in which the tests execute has some bearing on the result?)
Does it have a UI framework though? For me the most painful bit is dealing with the web view.
Forcing websites to pay for third party SSL certificates seems like a bad idea. And the website owners need to pay attention to their certificate renewals every year or so. A pain in the neck for smaller websites.
it was the only mature javascript library in the days of magento 1 development.
I would confidently bet on "Because it's mine" as the most likely reason.
They all sort of have different "flavors", but here are some that I've either trialed or used thus far: [Lynda](http://www.lynda.com/JavaScript-training-tutorials/244-0.html) [TeamTreehouse](http://teamtreehouse.com/tracks/front-end-web-development) [TutsPlus](http://code.tutsplus.com/categories/javascript/courses) [Pluralsight](http://www.pluralsight.com/search/?searchTerm=javascript) [Code School](https://www.codeschool.com/paths/javascript) 
Mozilla's working on a free SSL certificate system, called [Let's Encrypt](https://letsencrypt.org/). It has some software component and one of it's [features](https://letsencrypt.org/howitworks/) is that it will keep track of when your certificate is going to expire and automatically renew it.
You can use [Meteoric](http://meteoric.github.io) which takes the UI parts (CSS + animations) from Ionic and the database-centric real-time approach Meteor provides. 
I love this www.codewars.com
You have to write a bower component, see http://briantford.com/blog/angular-bower
There's a big difference between one guy saying, "I would like to propose ..." and "Mozilla start[s] drafting plans ..." 
thanks, Ethoxyethaan. I can tell this is going to be good, because it's over my head right now. I'm looking forward to using it :)
Ctor sets up the inheritance chain without running the super class's constructor on the prototype. Classic JS inheritance was handled with: Parent = function(){} Child = function(){} Child.prototype = new Parent() This made the Child's prototype an instance of the Parent class inherently giving it all of the methods of the parent. And, for the most part, this worked great. However, now consider something like this: Parent = function(){ Parent.instanceCount++; } Parent.instanceCount = 0; Child = function(){} Child.prototype = new Parent() What happens here is that, simply by setting up inheritance, you've affected the state of the Parent class - its static `instanceCount` member was incremented because an instance of Parent was created, only it wasn't the kind of instance you'd be using in practice, rather one simply used for the case of setting up inheritance - not the kind of instance you want affecting that count. Ctor doubles as `new Parent()` only without the contents of `Parent()`. It a kind of clone of a function class without the function body, or a custom body in the case of including the constructor fix. This "cloning" is done through the assignment of the prototype. As far as the child prototype is concerned, it is an instance of a Parent because the prototype conected to the `new Ctor()` instance is the Parent's prototype. Inheritance is set up, the body of the Parent constructor is ignored, and all is good in the world.
http://github.com/sytac/ng-pack
Worth pointing out that everyone I know that has built Cordova apps says that the overall product you get is pretty mediocre. It "works", but its nowhere near a native app, and a lot of people aren't happy with it. If your goal is truly a mobile website (like you said), sure go for it, if its actually more like an app, you probably won't be super pleased in the end.
I didn't get a red envelope about this, sorry. This isn't my library, I'm just a fan of the concept. I'm not sure if it's doing this or not, to be honest.
&gt; Titanium Studio Did they release their highly anticipated Titanium SDK with Ti.Next? 
I hesitantly agree, as someone that's made a few hybrid mobile apps. _However_, the ionic team has been doing god only knows what, because each update it starts performing more and more amazing, to the point that unless I've messed up my code performance that it's rapidly approaching the point of performing and looking like a native app.
Why meteor though? Honest question, I haven't used it.
How do you do when you have to deal with some logics, variables, etc ? 
I have another html6 proposal: whole company web infrastructure should made itself just after entering few tags like this: &lt;landing page/&gt;&lt;marketing page/&gt;&lt;eshop/&gt;&lt;blog/&gt; Chrome 78 of Firefox 67 AI engine then analyzes deep databanks to find out what the company is selling/manufacturing, sets the right prices for products, builds a cloud database, deploys and voila, big web app is done. It is awesome, I hope they standartize it soon. Just think of how much money companies could save on IT salaries.
You use JavaScript in the browser. Possibly with a framework like AngularJS.
Why not make this a weekly thread on /r/javascript (can be set up with /u/AutoModerator)? Top comments would be prompts.
Nice work. Have you ever used koa.js? its from the same guys as express and uses some es6 features.
Thanks, I did not know that older IE versions have problems with console.log.
Hmm I suspected this answer, yeah a front framework can be a good solution (it depends of the project obviously) :)
Yes I tried Koa a very little but to be honest I wasn't very comfortable with es6 at this moment. Maybe I should give another try :)
IMO, Javascript MVC frameworks are great but when it comes to learning in and outs of Javascript, I feel it's better to do it with a project and that too without using a MVC framework. I will probably want to jump to MVC frameworks when I feel I have enough experience with the language itself.
I already some know Git though. I use it quite often but not at the level I would call myself a expert. Starting with Nodejs sounds like a good idea, perhaps I will try to publish a simple node module.
No worries, few people I know are experts at git. Just the basics will be fine for most people. Just wanted to be sure you knew about it because, as you probably already know, it will save you again and again and again. :) A node module is great to start out with. Especially since you get to learn how they work and can fix stuff in open source projects.
It's too bad that you can only share private modules with paid users. That really hampers the usefulness.
I agree with khoker, its for you and other developers as well. console.log statements or their wrappers should be in the code and can be easily switched off or on either by a query param or a window.DEBUG variable But for clean, and by clean production web apps console logger statements should be invisible
This library looks interesting, will try it in my next project.
yeah, i use it in a few projects works good.
This does a good job of explaining it: https://docs.google.com/document/pub?id=1GWTMLjqQsQS45FWwqNG9ztQTdGF48hQYpjQHR_d1WsI And the associated hacker news thread: https://news.ycombinator.com/item?id=4531088
The console doesn't exist until you open the IE dev tools first (per IE instance/session). Once the object is created the scripts won't have any issues but you don't want to have your users hitting F12 just to use your page. 
AJAX is not as complicated as people make it out. The biggest challenge is understanding the nature of events and asynchronous responses. Setting up cross-browser AJAX (including support for IE8) var xhr = (typeof XMLHttpRequest === "function" || typeof XMLHttpRequest === "object") ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"); The above line of code creates a new XMLHttpRequest (xhr) object. The most commonly used methods are `open` and `send`. The `open` method defines details about the transfer such as: the HTTP transfer type, address, sync or async. The `send` method actually fires the transmission. xhr.open("GET", "proxy.php?x=" + fileName, true); xhr.send(); As the transmission state changes a property named `readyState` is updated by events behind the scenes (native code). Most people typically just wait for the `readyState` to report a value of `4`, which means complete. The change to the `readyState` property is asynchronous, but there exists an event called `onreadystatechange`. The `onreadystatechange` event fires every time the value of `readyState` changes. Assign a function to the `onreadystatechange` event (this is your event handler) and in this function is all logic to test for the value of `readyState`, http response code, and allow actions that occur only after the transmission is complete. I recommend assigning your event handler to the `onreadystatechange` event before the `send` method executes. Here is some example code: https://github.com/prettydiff/prettydiff/blob/master/api/dom.js#L1863-1904 This is your basic, but complete, crash course to do almost anything in AJAX cross browser. For more information read the instruction manual: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest?redirectlocale=en-US&amp;redirectslug=DOM%2FXMLHttpRequest The next level of awesomeness is preparing and creating dynamic responses for AJAX traffic on the distant end (server).
many thanks for the explanation already looking at the github repo.
I wanted to create this...but that is all right. It belongs to everyone now.
Don't worry, you're doing it the right way by learning the fundamentals first. I wish I did that back then. Definitely wait with the MVC frameworks. JS is a rather small language. You can get pretty far in just a weekend with the fundamentals. And you'll have a much better understanding of what the frameworks are doing when you get to them later. :)
It's on the info page. &gt; Give read access or read-write access for those packages to any other paid user You linked to npm Enterprise, which is different. 
Quite true, and you have another +1 on that experience. Then again right answer for the particular question, but it _is_ worth pointing out as you say. For a rock solid app your best bet is native at present. I know a lot of devs who create Swift apps (iOS still has better revenue), and hires an Android team to port the app once the money comes in. Maybe I'm an idealist, I'm just waiting for that killer hybrid framework. Really crossing my fingers on React Native.
I already used it and I like it :) but it needs to take a moment to understand how it works and how to deal correctly with him. 
For reference, talking about [Crosswalk](http://blog.ionic.io/crosswalk-comes-to-ionic/) in Ionic targeting Android 4.0-4.3, which packages a recent Chromium alongside your app so the underlying webview used isn't the Android default (that gnarly old "internet" app), but Chrome. 4.4+ actually does this be default, so not needed. 4.0- isn't supported TMK. 
Hi /u/GaborNagy, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `risingstack.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.risingstack.com](/search?q=%28and+site%3A%27blog.risingstack.com%27+author%3A%27GaborNagy%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|6|75%
Was the cookie set with `HttpOnly`? If so, the cookie will only be available to the browser (and not to JS) as a security measure. Read more: * [Protecting Your Cookies: HttpOnly](http://blog.codinghorror.com/protecting-your-cookies-httponly/) * [OWASP: HttpOnly](https://www.owasp.org/index.php/HttpOnly) 
Aren't there properties in the parent constructor that you want to inherit?
Javascript is fast. Unbelievably, mind bendingly, blisteringly fast. DOM manipulation is slow. Incredibly, mind numbingly, agonizingly slow. Don't confuse the two! Don't manipulate the DOM interspersed in your JS algorithms. Don't keep your data on the DOM. If you HAVE to interact with the DOM, take your element off the page first. Manipulate it in the ether. Then put it back on. If you do this without using async callbacks (timers, ajax, etc.), it won't flicker the page.
Yea, it takes a while. Basically, it's Rails on Node.js and it's built the way you just did. 
i hate these stupid fucking presumptuous titles
Interesting read. Regarding the second item (exceptions), it has been a solved problem for some time, if you are willing to say goodbye to the legacy callback style. Using promises+generators (or async/await if you don't mind a transpiler) exceptions are no longer an enemy.
You're commenting wrong.
most browsers will limit you to 6 concurrent requests and queue up the rest. what I'm trying to figure out, is if it's better to rely on what the browser is doing, rather than implement my own queue.
I'm actually validating account credentials when a user logs in. With no control over the API, I must loop through all the accounts a user might have and validate that the credentials for these accounts are valid. A user may have 30, maybe more (heck, could be a 100). There will be progress shown to the user about the work being done. what I'm concerned about more, is browser performance. Is it worth my time rolling my own queuing system, or are the major browsers pretty good at doing this themselves?
What title would you have used?
&gt; The solution is generally to modify the API to allow larger requests to be made If only life were so easy :(
that's fine for loading resources, but it is not a solution for AJAX requests to APIs that do not support CORS as you'll run into the Same Origin Policy restrictions.
This is handled by calling super in the subclass constructor. It calls the superclass constructor function on the instance being created by subclass constructor so that setup in the superclass constructor can be applied directly to that instance. With that I can provide another example to demonstrate the dangers of `Child.prototype = new Parent()`. Consider the following: Parent = function(){ this.value = 3; } Child = function(){} Child.prototype = new Parent(); var c = new Child(); console.log(c.value); // -&gt; 3 c.value = 5; console.log(c.value); // -&gt; 5 console.log(Child.prototype.value); // -&gt; 3 Notice that there is no use of any kind of super here, but we're able to access the value property for the `c` Child instance because its set up as a value in the prototype. Just like a method call, we can pull the value of the member variable from the inherited prototype without any problems. When the value is set on the instance, its assigned to the instance directly and not assigned to the prototype so other instances can continue to inherit initial values like this until they're given their own specific values. This falls apart when you're dealing with more complex data such as objects or arrays (non-primitives). A variation of the previous example with an array: Parent = function(){ this.value = []; } Child = function(){} Child.prototype = new Parent(); var c = new Child(); console.log(c.value[0]); // -&gt; undefined c.value.push('a'); console.log(c.value[0]); // -&gt; 'a' var c2 = new Child(); console.log(c2.value[0]); // -&gt; 'a' console.log(Child.prototype.value); // -&gt; ['a'] Now because value is an array and when working with an instance of Child the array can be mutated without being redefined, changes are being made to the inherited version of the array stored on the prototype and not one specific to the instance itself. Other instances, like `c2`, also inherit that same value and see the changes made earlier. Instead, what you want is the Parent constructor to be called every time the Child constructor is called so that the definition of those variables are created for each instance and not shared across many Parent = function(){ this.value = []; } Child = function(){ super(); } // sets value for this instance ...
Speed goes C++, C#/Java, Javascript, Python/Ruby/PHP/etc. Yes, Javascript is actually faster than Python and its cousins. There is nothing you will ever do in Javascript that will slow it down even the slightest. Your code will either run instantaneously, or take forever because of a bug. And you will very quickly know which case it is. 
Hackerrank is also used by some big companies for their initial screening of the interview process. Good place to start.
Right, thanks for the help. What is the point of prototype = new Parent() anyways? It seems to be a lot different than anything classical. I'm not sure what it's intended use is supposed to be. 
That wouldn't be static templating then. What kind of templating are you doing if you just return a static html file? That was the point I was trying to get across originally. I would even say static templating is an oxymoron...although you could generate your static html files ahead of time if your data doesn't update very often. Regardless, client side rendering should only be used in situations where it is required, which I would argue is only in real web applications. Normal content-based websites don't need it, and it would actually hurt in the long run.
It's because Javascript has had 2 orders of magnitude more engineering effort put into optimizing it than the others have. You don't fuck with Microsoft and win easily.
&gt; There is nothing you will ever do in Javascript that will slow it down even the slightest. There are actually quite a number of things, mostly those that prevent optimization. Do a google search for JavaScript deoptimization (or the inverse); an example list is here: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers It's interesting to note that a great many of these articles are focused on Chrome's V8 engine; perhaps they're all rehashes of each other. Either way, you can most definitely slow down JS using perfectly valid features, such as get / set methods, mucking around with `arguments` etc. 
I believe it's human nature. When someone spends a lot of time and resources choosing a "winner", they defend it and do anything they can to justify their decision. Same thing is rampant when discussing cars or video game consoles or _insert 5000 other similarities_. 
Is it possible to compare Javascript speed to the equivalent C++ speed from n years ago? Like 'todays js is as fast as C++ was in 1998'. 
To live edit the actual server side nodejs app, not currently. 
The *why* question for meteor is a confusing one for most and I'll try to break it down for you. Before I do, though, you have to understand that working your own way is your own way, nothing wrong with that, so make your own choices. Meteor is a fullstack environment which makes it different from Angular or React or Backbone or Knockout or Ember or whatever framework du jour is out there. Each of those handles its own arena, and does so well, but none handle the entire arena which so far as I know, Meteor is the only thing that handles truly everything in one. So let's talk about that in the context of the only true competitor to Meteor which is MEAN. The MEAN stack bundles inside of it node.js, express, angular and mongo. Meteor bundles each of those as well, with iron-router replacing express and blaze replacing angular (blaze is actually more like react in this context). Meteor doesn't stop there though. It also bundles things into it like sockets.io, underscore.js, etc. which are usually things you would add on later in the MEAN stack. Oh, and also has its own version of things like react/angular built in as well. Still not done. Meteor also acts as a task manager, so it can replace things like grunt or gulp. Meaning you can minify images, compile and concatenate LESS/Sass, deploy databases, etc. It does all of this automatically as well. So start up times in Meteor are just ridiculously fast and even more developer friendly. Then, in the context of a packaged mobile app for the app store or google play, it's seriously only two commands to have your bundle compiled and ready to distribute via cordova. Seriously, **two commands.** Not only that, but out of the box allows for hot code reloads. Which if meteor isn't the only framework providing that to us, it's certainly one of the first. So in a nutshell Meteor does everything and thus saves tons of time in development. The drawback? Maybe accessibility, some people don't like mongodb, and some say it's resource heavy (though I've not noticed that in my deployments). Hope that answers it for you.
Something that didn't make me sound like a cunt?
Could you create a server-side proxy to fire off all those requests, and collate the results back to your page? A single request as the browser is concerned, and the 30 parallel requests are hidden away.
I don't think I've seen such a concise clarification before. Amazing how much you got out of those 47 words. Thanks. :)
You can switch to Gulp if you feel like it. 
&gt;What kind of templating are you doing if you just return a static html file? Every kind, e.g. the templating is done on the client-side. Another commonly used term (mentioned in another comment) is [JavaScript templating](http://en.wikipedia.org/wiki/JavaScript_templating), although client-side templating seems like the best term now that I think about it. &gt;I would even say static templating is an oxymoron...although you could generate your static html files ahead of time if your data doesn't update very often. It's not an oxymoron, it's a good design pattern. Static html files have nothing to do with not having data being updated often. One benefit of static html templating is that if your data updates often, the architecture of the application naturally supports that use case just as it supports the use case of only updating it once. If server-side templating is done (using a classic approach with e.g. jade templating like the boilerplate does), then you need to effectively implement the same logic twice: first using jade and then using JavaScript templating. If you use client-side templating from the beginning, then it's trivial to refactor something which is only updated once to being updated in real-time continuously without any page loads. Of course there are also patterns to mix server-side and client-side templating transparently to the developer. In any case, the default pattern I'm using is client-side templating, and I advocate such a default for a boilerplate. &gt;Regardless, client side rendering should only be used in situations where it is required, which I would argue is only in real web applications. Normal content-based websites don't need it, and it would actually hurt in the long run. Yeah, my context was definitely web applications, not simple websites. Simple websites probably won't need an MVC with express either, so arguably the context of the boilerplate is in web applications.
That sounds awesome, but I think the depracation should begin only after Let's Encrypt has fully arrived.
Oh, ok. Cool. Both Gulp and Broccoli are a lot better.
Give me an actual example. 
Optimizing Modern Web Applications.
I agree, that is a much better title. Maybe it would be more helpful to suggest that to the author instead of writing condescending comments on reddit. 
I'm sure your response was in good faith, but my point is going over your head. You're talking about client-side templating, not 'static templating', which is not a real term. Google it and see for yourself. I am well aware of what it is and why it would be used.
I am relatively passionate about the framework I wrote. It's designed for very large, modular applications, lacks SEO, has automatic routing, and is probably best suited for corporate intranet data visualizations and dashboards (for which it was designed). It wouldn't work well for public sites (it requires modern non-IE browsers) and SEO would be an issue, and it won't work with an isomorphic setup like React. It's really designed for rapid extensibility and for making sure large teams can build things out without impacting one another... I think too many people see a single framework as THE solution -- whereas most frameworks have a definite set of limitations and best use cases. I think many authors of said frameworks are somewhat to blame as many of them fail to really articulate a solid associated use case. Some obvious exceptions would be things like Phasor (for games) or Meteor (for full-stack realtime). 
Do you have a similar post with the benefits of node as to why it was a good tech choice in the beginning? Or what the pros have been over the two years?
Have you ever watched religious debates? (not Java vs C# vs etc, but Catholicism vs Calvinism vs Lutheranism). In those cases you have people that truely believe ETERNITY is at stake...not just developer time and customer money. Really, I haven't seen anything come close to intensity of that. (note: I've been developing for 20 years...I'm no newbe to the debates that have gone on). People get worked up and irate, but most of the time we can still go out have drink a beer together once we are done.
+1
The "If you're doing XYZ, then you are doing it wrong" or "you think you know XYZ, you don't shit" type headlines are everywhere now. It's condescending and does not lend any kind of credibility. At least not with me. A headline is the first interaction you are going to have with your reader. Best not to insult them right off the bat. The article is pretty darn good, I think, so why do crap like that?
Unfortunately, when your average developer asks how does python vs javascript performance compare they generally are meaning CPython not PyPy 
True, but I think it's important to show the big picture in this sort of language performance comparison. There's someone posting a lot in this particular discussion, and notwithstanding the upvotes they're getting, most of what they're posting is either years out of date or just complete rubbish.
Someone may be able to correct me, but IIRC browsers can only make 4 concurrent http requests at a time.
That doesn't sound good, but your question isn't detailed enough to know what's going on. Why are you making 30 AJAX requests? General recommendation...batch them into one AJAX call, pull it apart at the server and handle each job individually, sending the results back to the client one by one or in a batch. You can batch using JSON. This batch would instruct the server to do two different jobs with one AJAX call: { getUser: "John", updateUserName: {"Jeff", "Jeffrey"} } At the server... function getUser() { (...) } function updateUserName(newName) { (...) } The server also needs a function that pulls apart the batch. You can convert the JSON string back into an object at the server and iterate each item in the array, firing the matching (and qualified) server function for that command. It's kind of a rudimentary solution but I hope that helps.
Look at practically any console game you've ever played. There's a reason it's used in game, high performance light-weight C interface.
In that kind of usage, it's not a real world app, it's essentially a configuration language for code written in C. EDIT: [Here](http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=lua&amp;lang2=v8) are some more interesting benchmarks.
Wow these comments...gotta say, pretty negative!
Don't forget deprecate, *but still support for the next 15 years.*
Well IMO it's Assembler, C, C++ -&gt; Your list, but yes. &gt; There is nothing you will ever do in Javascript that will slow it down even the slightest. This isn't accurate. I have apps that compute polygon intersections and on a desktop it's quick, but a mobile/tablet will hang for a while. Your audience platform/browser is a huge factor. 
Actually, if you read the license, it clearly states that this thing belongs to nobody but itself. Skynet confirmed
Welcome to digg 3.0, where titles are about bait, not content.
If you were to write a render engine from scratch, how would you approach layout recalc?
Spider monkey (the engine in Firefox), nitro/squirrel fish (the main engine in safari) and chakra (the engine in IE) all use simple JITs for first execution with an interpreter only for bailouts. JavaScriptCore is really the only engine that still uses an interpreter to kick start the JIT. And its only used in "stock" WebKit/webcore and in embedded web views in iOS. 
Off-topic: I have access to Elliott's book (the one in the right side of the page). Is it worth reading?
:) yeah, performance will probably not be a selling point of this... the goal is really to have a smart solution for internationalization when a proper solution isn't available. My specific case is a Shopify store, did you ever know that they don't provide i18n support at all for their sites? The horror, specially coming from a Canadian company... oh well
Calling those who use querySelector() "Raw metal people" is hilarious. 
Use your chrome dev tools debugger and step through it. Google how to use it... you'll never go back :)
Exactly. Idiots think using React and whatever means you never touch the DOM but React, and anything else, DOES including **everyone** who needs to do manipulation of elements! Eventually **everything must** touch the DOM.
Seems like you might want to use https://github.com/caolan/async#parallellimittasks-limit-callback
Do your own homework and if you get stuck ask for help _then_
/u/senocular is right. The ending condition in the for loop is never reached because next() doesn't allow pos to be any more than one less than length. 
/u/crcn clearly understands what React and other libraries are doing, which is buffering manipulations to as few DOM touches as possible. &gt; This is a simple benchmark demonstrating how expensive it is to access the DOM directly. Doing something simple as reading "element.childNodes" adds a significant amount of overhead to browser-based apps. &gt; Template libraries such as Glimmer, React, and Paperclip implement a sorta virtual DOM that abstracts DOM manipulations for you so that nodes are touched as little as possible. The primary difference between React, and other libraries is that React uses a virtual representation of the DOM in javascript, and applies diffs from that virtual DOM to real nodes (the slow stuff). Glimmer, and Paperclip on the other hand take raw HTML and compile it to an immutable DOM template which gets cloned whenever it's needed in a view. Since templates in Glimmer and Paperclip are immutable, all optimizations happen at compile time - no diffing, just changing the dynamic elements it needs to with the fewest DOM manipulations possible. He's not an idiot, his jspref test is just not comparing apples with apples. A closer comparison would be comparing custom baked DOM manipulation buffering logic with those offered in React and other libraries. Then it just comes down to a test of buffering technique.
Im really having trouble with the first question in that I cant seem to get the program to recognize that no numbers have been input. 
Your question is worthless, realize that. You're not asking anything other than "do my work for me". If you want an answer, then learn how to ask questions. Like, I don't know, SHOW WHAT YOU ACTUALLY HAVE DONE
I don't think it's limited to UI developers. There is just as much aggression in developers defending their language or platform of choice. We developers are just petty angsty children in room full of toys :)
 &lt;html&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; Alright this is question #1. I really have very little knowledge of what I'm doing here because I don't get my books explanation and got a lot of this from java-script help links. var username; var anyNum = false; var index; var BR = "&lt;br /&gt;"; var ES = "";= username = prompt("Please enter your username: ", ES); while (username.length &lt; 8) { document.write("Your username must be at least 8 characters long." + BR); username = prompt("Please enter your username: ", ES); } charAny = username.substr(0, 1); while (!isLetter(charAny)) { document.write("The first character of your username must be a letter." + BR); username = prompt("Please enter your username: ", ES); } for (index = 1; index &lt; username.length; index++) { charAny = username.substr(index, 1); if (isNumeric(charAny)) { anyNum = true; } } while (anyNum !== true) { document.write("Your username must include at least 1 digit." + BR); username = prompt("Please enter your username: ", ES); } document.write("Thank you! Your new username is: " + username); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
Thanks for the link
http://en.wikipedia.org/wiki/Silicon_Valley_%28TV_series%29
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Silicon Valley (TV series)**](https://en.wikipedia.org/wiki/Silicon%20Valley%20%28TV%20series%29): [](#sfw) --- &gt; &gt;___Silicon Valley___ is an American television [sitcom](https://en.wikipedia.org/wiki/Sitcom) created by [Mike Judge](https://en.wikipedia.org/wiki/Mike_Judge), [John Altschuler](https://en.wikipedia.org/wiki/John_Altschuler) and Dave Krinsky. The series focuses on six young men who found a startup company in [Silicon Valley](https://en.wikipedia.org/wiki/Silicon_Valley). The series premiered on April 6, 2014, on [HBO](https://en.wikipedia.org/wiki/HBO). The first season consisted of eight episodes. HBO renewed the series for a second season, which premiered on April 12, 2015. On April 13, 2015, HBO renewed *Silicon Valley* for a third season. &gt;==== &gt;[**Image**](https://i.imgur.com/vAajIqb.png) [^(i)](https://en.wikipedia.org/wiki/File:Silicon_valley_title.png) --- ^Interesting: [^Silicon ^Valley](https://en.wikipedia.org/wiki/Silicon_Valley) ^| [^GWU ^Recess](https://en.wikipedia.org/wiki/GWU_Recess) ^| [^Porscha ^Coleman](https://en.wikipedia.org/wiki/Porscha_Coleman) ^| [^Hampshire ^College](https://en.wikipedia.org/wiki/Hampshire_College) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqctxg5) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqctxg5)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
While technically faster than Python for most benchmarks. You must remember that any decent library will do anything that is particularly performance dependent in C with Python gluing it all together. Think numpy. It's a large part of the reason why it is used so much in scientific computing. Where speed is often important. So in your typical program it probably is slower than JS, but in a performance dependent program it is probably not too far off c/c++ and ahead of Java.
As opposed to a virtual dom (plain JavaScript objects). Eventually you have to touch the dom, but this shows you have to keep that to a minimum. The way I'm reading the benchmark (on Android) it's almost 300x slower.
Seriously I avoided AJAX for a while and would just use PHP cURL to do the dirty work. So glad I finally bit the bullet and learned it. It took like... 20 minutes to get a pretty good working knowledge of basic get/post.
Lua certainly is a popular scripting language for games. However, consoles generally don't allow JIT. The same is true for smart phones. Only Android allows it. Games generally use that tiny much slower interpreter. Anyhow, for high-level scripting, performance isn't that important. All of the heavy lifting is done by native code. E.g. path finding isn't something you'd do on the scripting side.
The only useful thing is requests that timeout, which saves you from making a timeout promise and racing it work the request.
Sure, for a real application with no limitations a complete i18n solution like that makes much more sense! The goal of dom-i18n is just to achieve some sort of multilingual support for situations where you have big limitations in place, like working with a CMS and you have no control of server side (i18next depends on a resource json file). It can also be a good fit for quick prototypes, you can just throw all your translations into a static html file and have functional language switching :)
That bloody color hurts my eyes.
I'm so popular
&gt; However I really don't see the net benefit in making it mandatory for any/all websites on the net. This plan isn't suggesting that though. It's only suggesting a *deprecation* of unencrypted HTTP. It's suggesting that *new features* be made HTTPS-only (with some developer-friendly caveats for things like localhost). It's suggesting a *long, slow and very careful transition* away from unencrypted HTTP. It's very well aware that many legacy sites cannot or will not migrate to HTTPS. I agree with some of your points, but this is no reason to panic. At this point it's still an early draft of an idea. The major benefits are around privacy, and making it harder to spy on or modify what's travelling over the network. We get MITM'd continually every single day. It's well known that mobile carriers re-compress images and scripts as they pass through their proxies. We can only tell because they aren't very good at it, frequently breaking things! Who knows what else they're looking at or changing? Meanwhile many ISPs, wifi hotspots, etc inject extra "content" (ads usually) into the web as it passes through their network. Again, they can see and modify the contents of everything that travels over their network - unless it's encrypted. Something like the Great Firewall of China modifying important news stories to better reflect what the government wants the people to hear is not beyond the realms of imagination. HTTPS makes all of that either impossible or a few orders of magnitude harder. If nothing else I'd prefer it if my ISP was unable to inject extra advertising or fuck around with javascript!
already scared to use it.
Doesn't work with touch screen on Chrome/Linux
And apparently rich, wanna be best friends?
I used to get passionate about frameworks. These days I only get passionate about module patterns in JS. I am okay with everyone using a framework of their choice. As long as I can take their script and load it in a sane manner in my app. So I will never be okay with is people writing AMD modules or without any module pattern at all on the frontend, just exporting globals. Use commonJS/ES6 or GTFO.
Most of the time, when you love a certain framework, you won't voluntarily accepts a job, where they would shove it's competitor down your throat. So those DAYS of lost time is saved just by interviewing.
Excellent first effort. I will be starring this. 
Nice work, Axel! Will give it a whirl. Edit: works nicely on androids built in browser.
The draggable placeholders are about 1000 pixels higher than my mouse cursor on firefox 36 / OSX
The link to the polyfill should go here: https://www.npmjs.com/package/whatwg-fetch
&gt; coming from a the point of view where an ISP or other third party is actively inspecting and modifying content as it delivers it to me, I'm intrigued to know what use cases are perfectly good enough? I can certainly see your point that *sometimes* a third party being able to cache/re-broadcast or otherwise interfere with your requested data is undesirable, but there are other situations where it might be useful or even required. For example - as I previously mentioned - network-level caching (a.k.a "not having to wait for a whole minute to learn whether *Zombie Flesh Eaters 3* got one or two stars on IMDB, or whether the local train is running on time on a mobile device") is a Good Thing that's wiped out by HTTPS. Similarly, if machine translation improves then services like network-level translation services that could live-translate web traffic from one language to another (eliminating geographical/linguistic balkanisation of online communities) would be a really interesting possibility, but it would be hard or impossible if all those online resources relied upon a secure connection between the server and the end-user's web browser... and instead you'd end up with massive duplication of effort as every user re-translates (or more likely, re-posts the same data to an API, which re-translated it and re-sent it back to them) on their own machine. Likewise the ability to compress or manipulate data to better conform to the capabilities of different devices - compressing and streamlining complex data from third-parties so as to better fit it into restricted/specialised clients, or to fit content designed for fat broadband connections and low latencies down narrower or laggier pipes (say, to current 2G mobile devices in developing countries, or in the future space-based or interplanetary network links). The ability to automatically cache, manipulate, transform and re-broadcast data from third parties at a network level *can* be used for evil, but it's also a really useful capability to have for a whole range of use-cases, and while we should guard against its misuse I think we *eliminate* it at our peril. Basically, while any unencrypted information *may* be modified by hostile entities, for a huge swathe of all the information on the internet this is *completely unimportant* - either because there's effectively zero chance they would ever bother, or because the information itself is sufficiently trivial and unimportant that modifying it would afford the entity no discernible benefit, and the user consuming it no discernible disadvantage. Lock your front door and your garage, sure, but relatively few people bother to lock their front garden gate or front porch because it's an additional PITA, limits their freedom (eg, to have a package delivered when you aren't home without leaving it in the open) and there's just no need for it. &gt; I agree HTTPS is more complex to set up and maintain - but better tools can (and no-doubt will) help to improve that in time. That's a fair point, but as you note that complaint is (hopefully!) more of a short-term issue. More serious IMO is that it eliminates a whole class of useful and potentially important network-level services - it's almost like throwing away half the benefits of a packet-switched network in favour of moving back more in the direction of circuit-switching again.
Doesn't work across sites/tabs/browsers.
You can return a function that captures the scope of the parent function - if that's what you are asking. function createAdder ( increment ) { return function ( base ) { return base + increment; } } var addFive = createAdder( 5 ); var result = addFive( 10 ); // result = 15; result = addFive( result ); // result = 20 Using the fact that functions are first class citizens in JavaScript allows you to composite functions within other functions. Doug Crockfords lectures may help. https://m.youtube.com/watch?v=DwYPG6vreJg&amp;feature=youtu.be 
&gt; I think many authors of said frameworks are somewhat to blame as many of them fail to really articulate a solid associated use case. This is a very good point. Most of them do it, but they do it so vaguely that you only understand what they mean *after* you've learned the framework. Like an honest list of pros and cons; what's possible and what would be very time consuming to bolt-on. And as you said: the best supported usage scenario.
One solution is to capture the return value of B() in a variable. Then you can perform whatever logic you need with that variable, including halting the execution of A() if the variable's value is false. function A() { var result = B(); if (result === false) { console.log("halting execution of A()"); return false; } // continue execution of A() here return true; } Another solution would be to make the call to B() the condition of an if-else statement. The statements in the if block would be the code that continues the execution of A(), and the statements in the else block would be the code that halts the execution of A(). function A() { if (B()) { // continue execution of A() return true; } else { console.log("halting execution of A()"); return false; } }
I know, I'm telling you it's bad documentation. I'm a professional, I've used many open source libraries. Most of them have bad documentation, but people will be more likely to use your tool if you have good documentation. I find myself more often than not having to dig through source code to learn how to use something. I shouldn't have to do that as a user, your tool should be a level of abstraction for me to make my life easier. I can go write my own drag and drop library if I feel like learning how your tool works.
A professional does not complaint about this kind of thing. If you have been using open source for a few years, you should be used to digging through code. Digging through spaghetti code would be something to complaint about, but that is another story.
I'm not sure what you mean when you say "associated logic such as clamping or conversion." Can you explain more?
Well, calmping as in a particular var needs to stay within a given range, e.g. a min speed and a max speed, you could check the speed every update and make sure it falls within those values or you can have a function in object.defineproperty check that when and only when the speed variable is changed, thus eliminating some of the constant checks. Another one would be a bound angle variable, whereas you'd like it to remain within 360, so x % 360, but what's the point of the check if it's not being changed? I made an example of what I'm asking about here: http://jsfiddle.net/4y8qhmdw/1/ I think the code will make it clearer than trying to explain it. And thanks for taking the time, I'm relatively new to all of this.
Nope, it doesn't. As soon as you re-insert your modified element into the DOM, it dirties the whole tree (well, technically the tree up to the nearest [layout boundary](http://wilsonpage.co.uk/introducing-layout-boundaries/)), which will force the same layout/repaint computation that would've happened if you had modified the elements in-place. It does eliminate the possibility of repeated modification/query/modification thrashing, but it does this by having queries give wrong answers, since any computations obviously won't reflect modifications that have been made to elements that have been removed from the DOM. (And the act of removing them itself dirties the DOM, so your first query afterwards will be slow.)
&gt; I would consider myself a higher level Javascript developer &gt; I've only heard the term [closures] recently Sorry, but those are extreme contradictions. You might be proficient at JS, and _entirely_ self taught, but the term is on _so many_ articles about JS that the fact that you hadn't heard of it makes me sincerely question your experience. &gt; examples Anything where a function accesses variables defined outside of it. function multiply( a ){ return function( b ){ return a * b; } } var times10 = multiply( 10 ); You're also expected to know things like why this doesn't work: for( var i=0; i&lt;10; i++ ){ setTimeout( function(){ console.log( i ); }, i*10 ); }
If you have been writing anything using the [javascript module pattern](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html) you have been using closures. That's the most obvious example off the top of my head. Pretty much every library I have seen is loaded with closures, and understanding the scope and internal variable assignments is key to understanding the code. If you have been writing javascript for some time I'm sure you have been using closures without realizing it.
You should just read [what a closure is](http://en.wikipedia.org/wiki/Closure_%28computer_programming%29)
If B is outside of your control (different domain) that is a very different issue. You'll probably have to wrap B within possibly an iframe or something similar and have js with maybe settimeout to refresh the iframe to B.something. If B is within your domain then you can use myNewWindow = window.open() and manipulate the myNewWindow variable.
[Got a logo for 'em](http://thestockmasters.com/files/images/story-images/rad-movie.jpg)
B is another domain. I get error when I directly link 'B.something'. That does not happen when I first go into B, then click the link. I want that coded so that users don't get the errors.
B is another domain. I get error when I directly link 'B.something'. That does not happen when I first go into B, then click the link. I want that coded so that users don't get the errors.
You could have the next method return `null` when `currPos == listSize-1`. Then you can iterate using `while(list.next())`.
You should be careful with try/catch blocks, they might generate a lot of overhead. Since you obviously want to render some html depending on whether the user is authorized or not, why don't you just return the html you want to render (so the html of the error page when the user isn't autorized and the html of your page when the user is authorized)? Then you can feed the result into your `createHtmlOutput` (which should really be `createHTMLOutput`) without having to break all the things.
That's exactly what I thought. I'm happy to pay the 7, but if my co-worker needs to work on the project, I don't want to have to pay 7 bucks so he can run npm install.
that's just clown shoes.. holy shit
This is just an experiment and there are obviously better options out there for a large application. I'm just curious what people think.
It says they're adding support for organizations soon, but also says in the meantime you can just create a user for your organization. Are there downsides to you and your coworkers using: npm install @our_company/package
&gt; Sorry, but those are extreme contradictions I'm going to have to extremely disagree with you here. I've been programming javascript for many years, I would consider myself pretty damn decent, but I stopped doing web development about a year ago. I never once heard the term back when I was learning and I only ran into it occasionally towards the end of my web dev career. Maybe the term has always been around, but it definitely didn't used to be half as common as it is now. I guess I should also add that I used closures all the time, and have been doing so since my very early days of learning js, it's just not something that I ever knew a term for, I just did it.
My thinking is that the hiring party does not want JavaScript developers who are strictly limited to the OOP model. It has a sort of feel of writing Java in JavaScript even if everything is done correctly according to the JavaScript way. At the last job they were using the Backbone framework, which is very OOP. Many of the UI developers could not live without it and those who understood the JavaScript scope model could not stand it. One former Java developer, who is one of their stronger UI developers, described it as feeling very much like writing Java. Even though ES6 opens use of classes and block scope the need for understanding closures and the scope model will become far more important than in ES5. Block scope in ES6, activated by keyword `let`, will continue to follow the lexical scope model and not the OOP model. To get some kind of understanding of lexical scope I wrote a tool to show scope depth in color: * tool - http://prettydiff.com/?jsscope&amp;m=beautify * informational guide - http://prettydiff.com/guide/closure_with_jsscope.xhtml Tonight I will release an update that provides support for `let` with additional instruction: https://github.com/prettydiff/prettydiff/issues/52
There's a demo.html that shows how it's used. If you know how innerHTML works, you'll know how this works. I think the only caveat I should add to the README is that, like React, it requires a single top level element to be passed.
~~And that's just for one module, right? Given a moderately complex app with 10 modules, you're looking at almost $2k...~~ However, to play devil's advocate for a minute: if you have a team of 26, then ~$2k/yr most likely won't be much of a problem for your budget -- if your org has has 26 devs, then the entire org will likely be in the 100's, and at that scale, $2k probably won't even cover a company outing. Also, I'd wager that $2k is going to be a lot cheaper than buying and maintaining the infrastructure yourself (once you factor in all the man-hours and such). edit: so I missed the point that it's $7/unlimited modules, but that just reinforces my point that this isn't so bad economically (at an organizational level). edit2: I'm dense.
&gt; $7/month charge for unlimited private modules
Well, you'll have no pay another $7 for your company's account. But $7 is nothing. I don't think there are any other issues. I'd do it like that. But what I don't understand yet is how do you issue something like "deploy keys". Let's say you have a build, CI, or deploy server that pulls your code, installs everything and does something with it. Wouldn't such a server need its own credentials? i.e. how would you use something like Travis CI with private npm modules?
Missed that, thanks. Edited my comment.
It does, although it doesn't support versioning on repos. My current private-module solution is to use `npm pack` to create a .tgz and then upload that to my own website and not share the URL.
lol good solution. it does support versions I think, by using tags. http://stackoverflow.com/a/14188105/1603521
One can extend to assume knowledge of the event loop: for( var i=0; i&lt;10; i++ ){ setTimeout( function(){ console.log( i++ ); }, 0 ); } 
You could do it that way, but you lose the ability to use semver dependencies. Of course, that's also true with doing it my way. My problem is that I don't exactly want to include passwords in my package.json, and there doesn't appear to be any way to use SSH keys there (correct me if I'm wrong please).
Might be a nice framework, but it's hard to justify releasing a JS framework in 2015 without embrasing either CommonJS or ES2015 modules. Seeing the global variable Application in the todo example code makes you think it's at least a couple of years old.
The massively overhyped npmjs company turns out to be another attempt at rent-seeking for what should be a public service? Color me unsurprised. But I guess those San Fran salaries don't come cheap.
I'll probably just keep using GitHub. It already has organizations, and the authentication part is easier when deploying (put an app-specific password in .netrc for a user created just for cloning on deploy). On the semver support front, I shrink wrap everything, anyway, since many packages have broken semver at one point or another or accidentally introduced breaking changes. 
Not sure what you're trying to say or what XML has to do with what I was saying.
Using it in production to serve packages in our custom `@mycompany` [scope](https://docs.npmjs.com/misc/scope). We configured `npm` to get our private scoped packages from sinopia and the rest from the standard npm servers. It works great. It's simple with no database or other dependencies to setup, but it has a lot of enterprise-y features (ssl, ldap auth plugin, etc).
retro!
I'm confused... I already deploy my heroku app with git push origin master
Logic is something that is relatively easy to pick up on. I would hesitate to call anyone a higher level JS developer without understanding of closures--they open up a whole new world. I expect you've probably used them before, but can you drill down and tell me what a closure's scope looks like--without second guessing yourself? As a self-taught developer (I was too) you should look up every unfamiliar word in an article. No one is there to tell you what you don't know, and so you need to figure it out yourself. Asking here was a great idea, too. This ebook is a great resource: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
That's... really not that much money for a team of that size. If you're paying 26 people full time salaries, what's an extra $2,304 / yr?
Man, I don't know what company you work for, but I get interviewed based on pure technical skill, not knowing a specific framework. Also, most of the time, the framework and product, and sometimes whole business platform, changes with little notice. If I quit every time we switched frameworks, I'd have triple the number of jobs by now.
FRP means?
When you say you're using it in production, what exactly do you mean? I plan on using it here to share UI components across the org and allow us to leverage Browserify in our dev and CI environments. Doesn't your CI just deploy artifacts to prod? 
Ugh, not my day!
That page is hideous. Also, I really have no interest in mirroring all of npm.
Asking questions about scope and coercion is really trendy right now in JavaScript interviews because it's one of the things that a lot of people new to JS don't understand, be they self taught or coming from another language. It's really annoying, I had three different people ask me the exact same question about hoisting during an interview gauntlet recently.
I honestly don't understand how you could write half decent javascript that actually did something besides jquery DOM crap....without understanding closures...it's kind of important...we ask interviewees about it, even for intern positions. I would not qualify you as a 'high level JavaScript developer', sorry. 
I personally spend a bit more than that on weed every month. If your company can't afford it, I have to ask, are they paying you in gum?
Use jQuery and Ajax. I'm mobile but if you want some help feel free to Pm me. Sorry I'm not even going to attempt this on my phone lol
You're a professional. This title means that you're paid to write documentation and maintain your code. If, instead of being paid, you needed to take time away from your friends and loved ones to cater to the whims of anonymous, entitled Internet users, I wonder what your priorities would look like.
I agree, I wasn't saying that the concept of closures are JS only but this is a thread about JS in the javascript sub :)
Unless the origin repo is on your web server, there is probably a git hook that listens for that and pushes them to the web server
How do you think the first example works? Walk it through, line by line, and compare it to your second example. p.s. In your second example, you have two tags in your HTML with the same ID.
You never assign divData.value just the innerHTML. 
Nope, too high level. Ignore posting the form for right now. Just focus on the two JS functions. What does each line do specifically?
 Example 1: var cnt=0; //set cnt to 0 function CountFun(){ //create the function cnt=parseInt(cnt)+parseInt(1); //not entirely sure var divData=document.getElementById("showCount"); //put the div into a variable divData.value=cnt;//assign cnt into the div document.getElementById("JustShow").innerHTML= cnt //assign cnt to the ID JustShow } Example 2: document.onclick = function() { //create function clicks++; //increase clicks var divData=document.getElementById("showCount"); //get the div divData.innerHTML="Your Score ("+clicks+")";//put this message in the div }; From this, I believe I missing the //assign cnt to the ID JustShow in my second function?
[fiddle](http://jsfiddle.net/j3dbLt8v/) for anyone that wants to see it. 194.209 kb compressed... yikes. Pretty cool though.
Like this? function doGet(e) { return checkForAdmin() || HtmlService.createHtmlOutput("HI THERE"); } If `checkForAdmin` returns a [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) value (or doesn't return anything), `goGet` will return the result of `createHtmlOutput`. Otherwise, it will return whatever `checkForAdmin` returned.
Are you looking for something in particular? The code you posted was plenty to identify the problem. I don't see how any more code would add anything.
Ok ok, I promise I'll get my var together. This is really the only JS code I was using. The HTML/CSS is fairly straight forward. It works when I try it in codepen but when I try it on Chrome, Firefox or IE the new li element only displays for a split second.
Ha yeah, the filesize mainly comes from the htmlparser. It's a bit much, but once gzipped down you're looking at like 90kb. That's not so bad (not great either). Definitely a place for improvement. Edit: BTW thanks for the fiddle!
Sorry I meant your original function you had. You are reusing the same ID for both the div and the hidden input inside your form (named clicks but with an ID showCount). You need to give the hidden input a different ID and then set the .value on that hidden input to be cnt in your javascript. Currently you are sending a 0 to your PHP script as the value is not being updated.
Ahhhhh, I see and that fully makes sense. So now I have this function: document.onclick = function() { cnt++; var divData=document.getElementById("showCount"); divData.innerHTML="Your Score ("+cnt+")";//this part has been edited divData.value=cnt; }; With this form: &lt;div id="showCount"&gt;&lt;/div&gt; &lt;form action="submitClicks.php" id="form" method="post"&gt; &lt;input type="hidden" id="showCount" name="cnt" value="0" /&gt; &lt;input type="submit" value="Submit Clicks" /&gt; &lt;/form&gt; When I click the page I get the correct count in showCount div. However, when I submit the clicks and echo the variable in PHP it is 0 constantly. So the value must not be getting posted. Why is strange as the hidden input field has the id showCount and name cnt, which matches the function.
I thought maybe you forgot to put **type="button"** on the button, because then it behaves as a submit button inside a form, and if you don't put **action** attribute on the form, the page will refresh. But if you say that happens even if the button is outside the form, I don't know. From your code it is impossible to tell because that code is pretty valid. Could you somehow upload the whole page somewhere so I can see what actually happens? Otherwise, you would have to debug it yourself with chrome dev tools somehow. Put a breakpoint on the button click event and go step by step to see what happens...
I have no idea why I can't simply get this to work, especially with all these replies. I'll show where I am at now: var cnt=0; document.onclick = function() { cnt++; var divData=document.getElementById("showCount"); divData.value=cnt; divData.innerHTML="Your Score ("+cnt+")";//this part has been edited document.getElementById("JustShow").innerHTML= cnt; }; &lt;div id="JustShow"&gt;&lt;/div&gt; &lt;form action="submitClicks.php" id="form" method="post"&gt; &lt;input type="hidden" id="showCount" name="cnt" value="0" /&gt; &lt;input type="submit" value="Submit Clicks" /&gt; &lt;/form&gt; So cnt starts at 0. The function runs when the user clicks. cnt increases. var divData=document.getElementById("showCount"); This stores the element showCount in the variable divData. divData.value=cnt; We then change the value of the hidden input here by setting the value to cnt which is being increased with each click. The final two lines of the function are simply just displaying the counter. So in theory this all looks fine to me (thanks to explanations here) but in practice, it still wont work.
To everyone saying he's not professional because he's never heard the term: you can use something and understand why something works without knowing exactly how it works out or what its name is. I guarantee everyone in here does this. I think you're fine, OP.
The fourth line in your onclick function does nothing. Or, at least, nothing helpful. The string `"Your Score ("+cnt+")"` should be assigned to the innerHTML attribute of the #JustShow tag if you want it to be displayed. I'll echo what /u/psy-borg is saying: Things look good. It's probably something between the form and the PHP that's weird now. Could we see the relevant PHP? You can use the development tools in whatever browser you're using to watch the form being submitted. That'll help to narrow down where things are going wrong.
What exactly does this do that `git push origin master` doesn't..?
Oh yeah, I've been there before. 
This is why I recommend avoiding do-all libraries and frameworks. They tend to get used appropriately. Your recommendation is a particularly egregious example of using a large do-all library inappropriately. Even if the user wanted to avoid a page refresh, he'd be far better-off either writing the few lines necessary or just copying one of many short functions to supply that functionality, should he be so inexperienced.
You also have [Artifactory](http://www.jfrog.com/artifactory/) and [Nexus](http://www.sonatype.org/nexus/) as options. The main advantage is that they can host other kinds of packages too, like Bower (in beta for Artifactory), RubyGems, NuGet, etc.
Love it.
Wow, that's awesome! I didn't know about either. Thanks!
I'm on mobile right now, so won't be able to give you detailed examples, but you should look into localStorage. Essentially you can just say localStorage.setItem("key_name", "value") Then localStorage.getItem("key_name")
Speed and efficiency of editing and manipulating text. #VimMasterRace Edit: Just to spread a little viral Vim love, if someone reading this is not on board the Vim train, I recommend this beautiful anti-Vim blog post, entitled "I hate Vim. There, I said it.": https://plus.google.com/102145263152706652064/posts/VjXWRRwQrcv But make sure you read the comments until the end, when said blogger (to his credit) posts: "Since I wrote this post - over a year ago - I have actually fallen in love with Vim. I know, I know... I ranted pretty hard against it. It took me a long time to get comfortable with it, but now that I am I can't imagine using another editor. I am more efficient than I've ever been and editing text is actually fun! I drank the Kool-Aid, and now I am a believer. :-) "
I'm looking into Sinopia.
 class Dog { constructor(name) { this.name; } } Am I missing something? Shouldn't you be assigning a value to this.name?
They could probably make a fortune this way. Some services pay $1 per install, don't ask me how I know. 
Yeah I'd like to hear the answer to this as well. Unless each parameter is assigned to this in the constructor 
You can use SSH keys on private repos, the same way you would use one on the command line. On several projects I have private dependencies set up in package.json like: "dependencies": { "my-private-lib": "git+ssh://git@github.com/username/my-private-lib#1.0.3" } As long as your SSH key (or your build box's SSH key) is authenticated in your private repo it'll work just fine.
Where have you been working as a front-end? Closures are basic knowledge for anyone that considers themselves a front-end developer...
wow this is amazing work, thank you very much.. yes I have questions if you don't mind The plus icon changes back after refresh, how can I fix this?
The fact that this makes html/cuss/JavaScript a single entry reveals a very weird bias that's not very connected with reality.
Those 3 languages are used in combination more than the others, so to us, it made sense to bundle them up together, why you think we shouldn't?
performance and response time are big ones indeed
Ha! I replied in dupe thread... Here's a few reasons: JavaScript is not dependent on the browser. CSS, CSS syntax, and CSS patterns are used in lots of places. Many of the other languages on that list have common CSS abstractions. All three of those can be viewed as targets of other languages to compile to, rather than languages to write. Most modern language allow for some ML, like XAML, XML etc.
If I'm not mistaken, this is some new ES6 syntactic sugar, in a number of places (like your above example or saying something like `return {name}`) you don't have to repeat yourself when assigning a variable to a property of the same name, so `return {name}` de-sugars to `return {name: name}` and your above example de-sugars to `this.name = name`;
Appears to just be a typo AFAICT. Haven't seen anything on the mailing list about it in my perusals, and adding such implicit behaviour appears contrary to the maximally-minimal classes philosophy for es6. EDIT: One more thing to consider is how this would work with getters/setters.
I see, we'll take that into consideration for our next survey, which will be more focused on technical aspects of specific languages.
If your origin remote is hosted on github, `git push origin master` simply pushes your updated changes to your remote repository. Apps can listen for Github's webhooks and then begin an automated deploy process every time you push to your master branch.
You actually setup heroku as a second remote and deploy with git push heroku master 
Glad I was able to help :) You already know how to get the properties from the button elements' data attributes, then you can just do something like this http://jsfiddle.net/hhcsz5cr/9/
Some sources: [under syntax - object literal extensions, it looks like it's already supported by the newest few versions of FF and Chrome](http://kangax.github.io/compat-table/es6/) [also here](http://wiki.ecmascript.org/doku.php?id=harmony:object_initialiser_shorthand)
It's a typo; you can test it out here: https://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=function%20fo(bame)%7B%0A%20%20this.bame%0A%7D
The question : Will people switch to this or keep using __proto__ ?
To counter this, every Sencha class has a survey at the end and the vast majority of devs give it high marks and believe it saved them a significant amount of time. We could design the course at any level - even above your level - but we have 1 classroom full of devs with anywhere between &lt; 6 months to 40+ years general programming experience, and 0 to 20 years frontend experience. Try to design materials that satisfy everyone - it's hard.
Another example of Sencha tech is fastbook... https://youtu.be/59RTzD3Q8tE?t=3m20s Higher FPS on mobile than the native app. Over 2 years old and still an amazing technical demo. Techniques explained here: https://www.youtube.com/watch?v=T0NO5rSCfHY Those who say "just use HTML" fundamentally do not understand the performance situation on mobile. You need a framework to achieve the highest performance, and generating and decorating HTML from JavaScript is the best current approach IMO.
You can use it already with Babel or Traceur, and JavaScript engines are supporting more and more ES6 features every day.
Ah, no. Laravel doesn't quite work like that. The key in how Laravel implements middleware, is that things don't return back. Mainly because you don't call them directly. You have to think of that middleware as a series of filters; middleware are not controllers, they do not perform actions in the way controllers do. You register those filters and they either redirect the response or allow it to continue (signalling the next filter, if any are left, should be executed). Then there's Laravel itself orchestrating what to do with a redirect if you signal one and selecting the next "filter" if not. This is a pretty common structure, and many frameworks do a similar thing. Java Servlet API has Filters, for example. Also, it's important to notice that no, from a middleware you don't return a rendered page, you just redirect the response. Then Laravel will decide for that redirection what it has to do (which may or may not be rendering a page). Also, notice that Filters / Middleware should not be called directly from controllers. The filters are executed _before_ and decide whether or not the request can proceed. Then if it's all ok, a controller will handle it, but you don't call the middleware _from_ the controller.
I like your optimism!
The problem is with the browser trying to jump to that element ID when you are setting window.location.hash; the scroll works fine but then it does the jump in your callback. One workaround would be to utilize history.pushState as demonstrated here in this [JSFiddle](https://jsfiddle.net/gupyuonp/). Take a look at this [StackOverflow](http://stackoverflow.com/questions/3870057/how-can-i-update-window-location-hash-without-jumping-the-document) thread that discusses your problem in detail.
This was a trip down memory lane for me, thanks for sharing!
Another problem is that we're now coupled to the fact that a certain name is a constructor function: `new User()`. I'm still glad they added this new syntax, though. It was a pain in the ass before, and everybody had their own class system (a class library in every pot!). Each developer had their own conventions and it caused a great deal of confusion. ES6 classes are also a massive help in terms of performance optimization. I prefer functions and closures, but it's true that classes are a lot easier to optimize.
About the performance optimization though; classes are only easier for the VMs to optimize if classes were sealed. And Google is trying to push this with their SaneScript/SoundScript thing, but since classes are currently just sugar for prototypes, they're not easier for VMs to optimize. The argument that putting functions on the prototype instead of duplicating them on every object for performance/memory is only true if you make *a lot* of those objects. Most objects in most applications tend not to have *a lot* of instances that share the same structure.
Actually, when I refer to the performance optimizations afforded by classes, I am primarily referring to the fact that the VM (V8 in particular) creates hidden classes behind the scenes which heavily optimizes property access. The increased flexibility and power you get by using functions usually does outweigh the benefits of improved performance with classes, but it does happen to make a massive difference in the work I do on a day-to-day basis. Which is why I'm glad it's now built-in.
Hi /u/Akalyron, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
It creates hidden classes for regular objects as well though, there's no special case for prototypes. Since both objects and prototypes can change at any time, they have to add guards to invalidate the world if the objects/prototypes change. If objects/prototypes were sealed, they wouldn't need those guards.
It is true that the VM creates hidden classes for objects as well, but it is much more fraught. If you have a constructor: function Point(x, y) { this.x = x; this.y = y; } Then all instances of Point are guaranteed to have the same hidden class, so long as no properties are added onto an instance after-the-fact. As an added bonus, the VM doesn't have to recalculate the hidden class for every invocation of `new Point()`. If however, you have something like this: let point = {}; point.x = 1; point.y = 2; Then it will not have a hidden class at all. A hidden class is created only if you define all properties in an object literal or a constructor function. Here it is treated as an associative array. These will create different hidden classes because property order matters: let point1 = { x: 1, y: 2 }; let point2 = { y: 2, x: 1 }; Now you say you could just return an object literal from a function that helps guarantee property order. `function point(x, y) { return { x, y }; }`. But later on you need a different point. Perhaps a `3dpoint` with a `z` property. How do you do that without making your code polymorphic? Well, you could duplicate everything from the `point` function and manually create a new object literal in the `3dpoint` function. This works okay for a little while, even though it's still less efficient than using classes. Or you could use Lodash's `_.assign` or modify a `point` instance manually in the `3dpoint` function. Seems good until you realize this has likely silently invalidated every function that uses `point` instances and probably turned them into polymorphic, rather than monomorphic, functions. The new instances will have either no or only part of their properties placed onto the hidden class. This sort of thing is really difficult to track down. It is possible to introduce such an issue with classes, too, but much more difficult. And if you do then you can easily fix it. You could even use TypeScript to validate this for you. Again, it's *generally* not a big deal, but I work on projects which require very high performance, and the aforementioned issues were fixed after switching to classes. Things could have changed since then or will change - and I really hope they do.
Thanks for telling me that, I'll go through the rules.
So have you ever hear about our lord and saviour `Animal.prototype`? Literally everything you just typed can and is done thoroughly through function constructor's `prototype` property. var animal = {brain: true}; var Dog = function(){this.legs = 4}; Dog.prototype = animal; var Collie = function(){}; Collie.prototype = new Dog(); var wolfie = new Collie(); wolfie.name = "Woolfie"; Collie.prototype.temperament = "Friendly"; Dog.prototype.bark = function(){return "Woof"} wolfie.bark() //'Woof' `Object.create` is harder to work with when you're creating lots of instances. With a simple prototype in the constructor fn, you can quickly know which object is inheriting from what prototype. The only instance where I think you'd need to use `Object.create` is to construct a quick singleton but even then you can just use Object literals.
I can understand why that might be tricky to implement. Some constructor functions need to act like normal functions at certain instances - but it should be up to the devs to decide. 
The two are functionally equivalent in this instance but the utilised syntax is clearly very different. It's not just a case of 'substitute `new`'. I find the `Object.create` option easier to read, plus it's shorter, plus configuring properties is more convenient if you need that functionality (on the down side runnning code during object construction is less convenient). Most importantly though I find less chance that I'll make a mistake with `Object.create` (eg. missing `new`or directly referencing an object instead of its prototype). `Object.create` was introduced to the spec for a reason. 
I always wondered why you can't just use fat arrows for methods etc. like you can in Dart. class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } get fullName () { return `${this.firstName} ${this.lastName}`; } } Same in Dart: class Person { var firstName, lastName; Person(this.firstName, this.lastName); get fullName =&gt; '$firstName $lastName'; } Being able to use "() {...}" and "() =&gt; *statement*;" interchangeably is very convenient. Maybe they'll change this in ES7. As far as I can tell there shouldn't be any ambiguities.
Not that I believe this to be the case in ES6, but it's not a big deal at all. Other languages, such as Smalltalk, return `this` (`self` in Smalltalk vocab) as default unless something else is explicitly returned, and it works really well. edit: For clarity, I think returning whatever comes from the last statement is not quite the same, though there are uses, such as in lambdas for example, but I do subscribe to the idea that `void` is a "mistake" in a similar vein to how `null` is a mistake. 
If you only support evergreen browsers, you'll be able to use all of ES6 by the end of the year. In the meantime, and for as long as you need it, there is Babel and Traceur.
I stated earlier that it's hard to work with it when you're creating several instances. We rely on the prototype prop for inheritance which makes it harder to use Object.create when creating several instances. I might as well use literal notation. In node env it is even harder to use it because now I have to carry my variables with me. In other words, abstractions become harder when working in higher order libraries. Using the new keyword is pretty clear to me what is going on. If I'm worried about checking in every single constructor fn then I just go with "use strict". It looks tempting to use Object.create but the higher you go the more expensive it becomes. It's not that it's bad to use it or that it's wrong but it's pointless when you're not a beginner. 
Aren't there issues with doing it this way? I thought the proper way to do it would be how typescript or coffeescript have it implemented, which it like: var __extends = this.__extends || function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() { this.constructor = d; } __.prototype = b.prototype; d.prototype = new __(); }; var Labrador = (function (_super) { __extends(Labrador, _super); function Labrador(name) { _super.call(this, name); } Labrador.prototype.bark = function () { super.bark.call(this); console.log("woof!"); }; Labrador.prototype.playWithKids = function () { console.log("playing with kids! wuf! wuf!"); }; return Labrador; })(Dog); var leo = new Labrador("Leo"); leo.bark(); EDIT: I don't know how to format code like you are. :S
Doing Constructor.prototype = { prop1 : function () {} [, ...]] } Looks a lot nicer imo.
I don't understand what you're getting at. Can you provide an example? var dog = {legs: 4} var wolfie = Object.create(dog) var barkie = Object.create(dog) console.log(Object.getPrototypeOf(wolfie) === dog) dog.hasTail = true console.log(barkie.hasTail) Perhaps you're talking about constructor functions and closures?
No issues that I'm aware of. Four spaces in front of each line formats code.
I'm guessing the author writes a lot of coffeescript in which `return` statements aren't necessary. The language inherits the idea from ruby where the last statement in a function _is_ the return value. I personally hate it. Doing things explicitly might not be _necessary_ but it makes things clearer.
I don't think you have a thorough understanding of the prototype inheritance. Object.create in its simplest form isn't any different from what I just wrote. For foobar examples, it's harder to convince anyone of its hindrances. But when you work with large scale libraries you start to notice how much extra work you have to do. It makes it harder to abstract the logic within your components. When Object.create was introduced it was the result of the same reason the class thing was introduced in ES6. It's all syntactic sugar more than anything. I'm not I follow where closures come into this. 
Well... they aren't. Nor are they in other languages. `new` is available for a reason. If you can't be bothered to type four extra characters because the language doesn't conform to what you think it should do then the problem isn't the language.
I'm on mobile so I can't link properly to an earlier comment in the thread I made with a diagram explaining how JS prototype is laid out. When you bring coffee script and typescript as your proof, I'm left to wonder why we are even arguing. They are both fine. They work, they ship, so no one will get crucified. However in my experience, we should be willing to be wrong and not hold onto our beliefs without context. Object.create is expensive and redundant when you are familiar with the prototype chain. If you're writing a large app, it gets harder to debug and expensive to factorize. I'm not referring to some compiled tool you use, I'm talking about actual raw JS. Please learn basics before using some compiled tool. Cheaper in the long run. EDIT: Proof for you unbelievers - https://jsperf.com/object-create-vs-crockford-vs-jorge-vs-constructor/26 - http://jsperf.com/prototype-vs-object-create-perf - https://jsperf.com/obj-create-vs-new/4 - http://jsperf.com/object-create-vs-constructor-function So my point stands: LEARN JS PROTOTYPES BEFORE ANYTHING ELSE! **Classic, getting downvoted after providing proof**
I just tested it and object.create seems to allow you to add methods to the parent class afterwards that also show up in the child class (but not vice versa). Using prototype = new and then adding to the parent class doesn't seem to reflect what you add to the child classes. How so you know it's more expensive? It sounds like using new is more expensive but I'm not sure. 
For the jQuery skeptics, I really want to make a non-jQuery version of a plugin I contribute to, but I just haven't got around to it yet. Here is the link: https://github.com/jQueryKeyframes/jQuery.Keyframes Also check out the other plugins including support for [spritesheets](https://github.com/jQueryKeyframes/Keyframes.Spritesheet) and [more advanced paths](https://github.com/jQueryKeyframes/Keyframes.Pathfinder) like bezier curves. On the jsfiddle, if you look inside the head element of the jsfiddle output frame, you will see an ungodly amount of style elements and css. The browser actually handles this like a boss, rendering many circles and rotations without a hitch. Canvas is cool, but I love that I can do this without it. **TL;DR dynamically generating keyframes gives some real power to mundane elements**
 I added this to my CSS and it actually broke it in Chrome... :( 
&gt; when you work with large scale libraries you start to notice how much extra work you have to do I'm just looking for an example showing why this is.
This is totally broken on Firefox.
http://www.reddit.com/r/javascript/comments/32qolz/oop_in_the_age_of_es6/cqe9kkb Have a field day with it, lol!
Yep, that's exactly why I use it. It transpiles down to the same thing, but the actual source is much cleaner. 
When we talk "work" here, we're talking developer effort right? That's what I'm talking about. All that comment includes is a bunch of simple (largely poorly written) performance tests. I've got no doubt that the "manual" (aka .prototype, constructor functions, and new) way of doing things results in faster to execute code but the reason that Crockford among others advocated for Object.create for so long is that it improves *developer* performance (particularly non-expert developer performance). Want to benchmark ES6 classes via babel against using the old .prototype, constructor functions, and new approach? I don't think anyone will be surprised to find that ES6 classes don't win the race. Lots of developers are already using them though, and many more continue to start.
I am a little jealous....
It was working before damn it. Sorry about that. It seems to work in IE which means firefox is the only browser it's failing on. I'm noticing that more and more lately. I need to set up a test suite.
This has been and will continue to be a huge "flaw" with the JS dev community as a whole. Not CS in particular, but the fact that JS has _such_ a low barrier to entry you have people that form opinions based on one specific framework, tangent, etc. A fairly low percentage of "JS Devs" would qualify as even entry-level in my book. Not that a low barrier of entry is a _bad_ thing, but arrogance coupled with ignorance is.
The four characters aren't the problem, the lack of uniformity is: JSON.parse(serializedUsers).map(createUser); JSON.parse(serializedUsers).map(User); // vs. JSON.parse(serializedUsers).map(createUser); JSON.parse(serializedUsers).map(userData =&gt; new User(userData)); The fact that you *sometimes* need `new` and sometimes don't is kind of awkward. Especially given that some of the built-ins basically require you *not* to use `new`, e.g. `String(someData)` does something more sensible than `new String(someData)`.
What about private/protected methods? It will be supported in ES6 classes?
I disagree with this. TC39 has been reacting to what the _community has already developed_, and the direction that other frameworks have already gone. I agree that classes are not the correct way to go about most things in JS, but as long as everyone's doing it anyway, I like that it's now a part of the language.
Unfortunately, no. The new ES6 classes is basically just syntactic sugar that wraps ordinary prototypical inheritance that you can do with ES5.
Nobody should be using `__proto__` outside of node.js, at least not in frameworks or anything else that needs IE back-support.
It's always been valid. So is `function * genny(){}` I personally _slightly_ dislike `function *genny(){}` as it looks like a pointer to me.
&gt; I don't think anyone will be surprised to find that ES6 classes don't win the race. They why on earth do we keep adding syntactic sugar to things that aren't performant in order to cater to the lowest common denominator? I pointed out way earlier in the argument that it's not wrong but it cripples you to think you know how things work. It's only useful for developer performance **IF** you already understand the basic prototype concepts (which at this point it's clear you didn't have before this flame war). It's the same argument that you find people learning jQuery^TM before actually learning how the DOM works. Do you want that guy deployed to work on your site with Coffeescript in hand? If you can't even differentiate between `Object.create` vs `new` and how to optimize those, how can you say you understand JS OOP? How can you use a tool if you don't understand why it was invented in the first place? &gt; All that comment includes is a bunch of simple (largely poorly written) performance tests. Also, this made me laugh more than I'd admit. You are criticizing code that is elementary to say the least. If `FooBar` examples are terribly written, then we should probably create a new language. PS: I'll give you gold if you write a jsperf (that I can't optimize) proving that `Object.create` is faster.
Yeah, I know I'm going to see it a lot more, doesn't mean I have to like it. I rallied against it several years ago, and was out-voted. *shrugs* _everything_ else in JS is done via keywords. Having one random symbol is... odd
True, I was refering to prototype-based programming as a whole !
I'm glad you know. I'm concerned there'll be a whole new bunch of JavaScript coders who only write in ES*x* - all the transpiling where necessary being done automatically so they never see it - who will be convinced that JS is a classic OOP language and continue to conflate it with Java just as has been done for the last 20 years *sigh*. Thus they'll think it is a subset (like VBScript and VB, even though that's not true either) to advance their argument that it sucks because some feature that is in Java isn't available...
&gt;Power is what you need when you want to write a short script which showcases how clever you are. However, when you want to write a larger program in a team, you'll need structure and standardization more than anything else. I think this is something people often miss. Why not both? I don't mind JS having classes. I know an argument can be made that JS shouldn't be expanded to a huge monster of a programming language. On the other hand, the beauty of JS is that you can implement pretty much any pattern you want. Since tons of people implement a more classical OOP pattern, it *does* make sense to make that easier, as long as it is still built on top of the the fundamentals of JS. I think both are important but for different things: - Power is important for those who make frameworks, components and modules that will be used as a basis for actual products. - Tooling, readability and fixed sets of constructs are important for teams who actually implement products using the frameworks mentioned above. JS is currently more focused on the first but I think it's heading towards better support for the latter which is, in my opinion, a good idea.
Yeah, like... this is how heroku is designed to work already... I don't see the benefit.
Yes, I agree. Wrote that as a response to another comment.
&gt; A hidden class is created only if you define all properties in an object literal or a constructor function. Here it is treated as an associative array. Note this depends on implementation. I don't know about others, but Carakan definitely still used classes for such things. I'd be surprised if others always used hash tables in such cases, because it's a large performance penalty in the common case.
This was... a surprisingly informative and beautiful presentation. Like, really. Especially considering I expected something along the lines of *"83 jQuery plugins that will blow your mind!"* :)
This is beautiful.
Incidentally, that's the latest, Lua 5.3.0, which made some quite fundamental changes -- *[integers (64-bit by default), official support for 32-bit numbers…](http://www.lua.org/manual/5.3/readme.html#changes )* The programs were optimized years ago for a different version (and then there's LuaJIT). 
A term I made up. To use this your logic goes into middleware and the plugin handles the final response. I just wasn't sure what to call it. 
I guess React with Flux will be here to stay for a while. Angular is even more popular but the route to 2.0 seems... like I'd wait if I were starting over. If you don't like huge MV* frameworks, I'd perhaps take a look at Mithril.js. It's still MVC but it seems a lot smaller and more along the lines of vanilla JS, providing just the basics. Haven't used it yet but check it out. Get into testing if you're not doing so yet. It will soon be vital for developers to know how to do proper testing. Regarding underscore, I actually like ramda.js a lot now. It can be quite confusing in the beginning but it becomes easier to compose functions once you get going. You can pretty much just create your own toolbelt of composed functions for your specific app. Also, they promise to *never modify the input* like a lot of other libraries do. It's extremely nice to know that code won't modify variables back up the chain and the flow of data becomes easier to follow. In practice, it will start working a bit like immutability. It's hard to get around MV* frameworks today because you'll almost always end up with something along those lines unless the page is quite simple. It also makes it easier for other developers to follow if they have to some day.
Hi /u/ceorackcity, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Why is there a hidden Twitter link under the play button? I can't even tap on the play button
Looks awesome. Great slides.
I hate the ternary operator. I dunno why, I just hate it and its stupid syntax.
This broke for me on mobile iOS iAlien viewer on the slide with babel and traceur transpiling.
Inheritance and state is the root of all evil. Functional programming is the way to go. Classes are only good on the macro level for gluing structure.
Yeah i actually had sublime setup to use 2 spaces, I must have forgot to reset that when I migrated machines. No harm though next release the indentation will be fine. 
It would probably help us a lot if you described what kind of sites you program. Do you use JS to spice up websites, creating a little animation here and there and perhaps popups? Do you do single page apps? How large is the JS part of the projects you work on? Do you work in teams? I ask because while MV* will certainly lock you in a bit, they can be very, very helpful - if not vital - for larger projects and/or single page apps.
Tap the page to advance the animation.
I have personally never liked jQuery. If I need convenient shortcuts I am happier just aliasing the vanilla DOM methods.
Like many ancient religions it may take wiping out an entire generation to move on past jQuery.
 Object.create = null; *walks off whistling nonchalantly* Bonus points for extending Object.prototype while you're there...
I see a nearly identical post to this maybe once a month here. The wording is similar enough in each of these that it could be mistaken for copy/paste. Maybe the mods could create a sticky for these kinds of posts. --- As far as making code work just run in a webpage in a brower, or download Node.js or io.js and run it from the command line. What you do next is form a challenging and ambitious idea and then struggle to achieve it. You become a stronger developer through practice. My first big personal project was to write a XML/HTML/JSTL parser. It took me about a year and a half to get right. A couple of years later I wrote a JavaScript parser in JavaScript that was maybe twice as powerful, but I did it in half the time. A little bit later I wrote a CSS micro-parser in about 2-3 weeks. Each time I completed one of these I would look back on the former ones and realize where my strengths and failures are. Its just practice.
This one is another form of cancer called sharethis (hits l.sharethis.com) and blocking the dns doesn't work, just prevents the callback to their site. I posted in /r/chrome on how to disable clipboard events since the instructions there only work for firefox
I'm using Ghostery and it's blocking both Tynt and Sharethis. Maybe try that until you find a working solution for Chrome.
I've looked through the code now... What's the secret sauce to adding HMR to an existing webpack project? * plugins: [ new webpack.HotModuleReplacementPlugin() ] * watch: true? * use ES6? Anything else you need to do? Nothing else stood out to be as being different from a non-HMR project.
Turn of your computer! Smash your phone!!! RUN AND HIDE IN THE MOUNTAINS!!! REPENT! THE END IS NIGH!!! /s Personally, I haven't had this issue... I use HttpSwitchboard (Chrome) and seem to miss a lot of crap :)
Beautiful! But where sould be jQuery?
You can do live coding on Codepen. http://codepen.io/pen/
Duh. It's also nice to provide more detail than that, too
But you didn't. You just said the same thing mooogs said, but again.
You might want to learn JavaScript first. Have you learned absolutely nothing in that "course"? Do you know how to determine if two rectangles overlap?
same here
How does this compare to something like [Ionic](http://ionicframework.com/)?
&gt;Upgrading from 1.x to 2.x is also a big unknown at this time. &gt;So I could see it being yet another rewrite in a couple years, which seems a bit ludicrous. &gt;This, to me means we'd essentially be hitting production with a deprecated framework. I don't consider myself a javascript framework guru, but yeah... This seems logical enough. I was all set to embrace Angular for big projects and then the whole Angular 2.0 fiasco popped up. Plus, I ran across a webpage (and dammit if I can't find it) where someone wrote an app using just jQuery. He then improved it by adding knockout. He then rewrote it in Angular, and then again in Ember. He ran a lot of tests on his code and gathered statistics on complexity of the code, readability, speed of code execution, etc. He concluded that jQuery and knockout were 'better'. It ran faster and the code was less convoluted. (And I am pissed I can't find the article... I've looked all over and can't seem to find it.) Anyway, it sort of reinforced that 'simple is better'. So if you are looking for code longevity, you may want to look at that approach. The other problem - as 50 javascript devs what framework is better, and you'll get 50 different answers. Its somewhat maddening. Another thing I've noticed lately is many people seem to really like ReactJS. Apparently the performance is outstanding, its backed by Facebook (and I'm kind of meh about that company, but apparently their tech is pretty solid). From what I understand there are a couple of shims to accommodate IE8 and they work well. I hope that helps. EDIT: I'm in 'enterprise land'. If I had to do what you are doing, I'd push for a jQuery/knockout solution. My reason would be that they have been around awhile and are proven, and have excellent performance. Enterprise land tends to favor 'simpler' and 'proven' when it comes to tech. I'd also push for ReactJS because of performance and... well... the technology is backed and used by Facebook... so... it should be able to handle a lot. But of course I'd have to really look at the project specs and try to analyze the various frameworks and find a good fit based on what the project actually does. 
In my class, the instructors don't actually teach JavaScript, all they do is just give you some examples of what JavaScript does, for example we learned 'var', 'getElementById', and similar stuff but that's all they teach and they expect us to do the projects perfectly. For previous projects, I had to depend on Google every step of the way. I'm probably just going to watch some beginner tutorials of javascript on youtube just to get a feel of it. 
Check the "Get Started" section in the side bar: http://www.reddit.com/r/LearnJavascript
To expand on this, use `background-position` to offset the sprite. No need for two elements, just the background and the position.
I guess I don't understand the problem. Are you running into it a lot?
how did I not know about this? holy crap thank you 
If you're interested and excited about the future of Dojo, come over and join us at http://www.reddit.com/r/dojo
If you don't want to use background position for some reason then: * parent container should be position: relative * child container with your two "layers" should be position: absolute * your "layers" should use top/left/bottom/right + z-layer to put them where you want them
I didn't expect to fix it but I actually did. Basically firefox being pedantic about standards, or me not being pedantic enough, one or the other: http://jsfiddle.net/krazyjakee/N652c/
Thanks
You want a module system. Currently there are three module syntaxes: 1. CommonJS 2. AMD (Asynchronous Module Definition) 3. UMD (Universal Module Definition) If the project is not gigantic, I would use CommonJS. You can't load it in a browser this way though as browsers don't understand anything about modules. I would then suggest you use Webpack to bundle into a single file.
I'd personally go with using CommonJS and browserify. For a jump start, I recommend the [browserify-handbook](https://github.com/substack/browserify-handbook).
skitch920 pretty much answered it, I just wanted to add to say that you could also just load in more files and assume they will be read in sequence. You can also declare variables globally, on the window object (the window object contains your DOM). Don't forget that your document has one DOM, and all scripts loaded onto the same document share that DOM. ~~Another technique that might come in handy is to create an object as namespace. You can then declare your variables as a property of that namespace object, and also refer to the namespace in all script files: var NS = NS || {};~~ But yeah, like skitch920 suggested, having a dependency loader like requireJS is your best option. 
With webpack, you can use the following two module formats: * CommonJS (e.g. installed via the npm package manager) * AMD (e.g. installed via the Bower package manager) For your own modules, you have the additional option of using ES6, including the ES6 module format, via [babel-loader](https://babeljs.io/docs/using-babel/#webpack) (a plugin that transpiles from ES6 to ES5, via Babel).
1.3 dropped support for IE8.
Practice makes perfect :) One thing I found _super_ helpful was force myself to do "whiteboard" style coding on my own. That means: 1) Assign an objective "FizzBuzz, files all files recursively in a directory and find the duplicates, a command line argument parser", etc. 2) Without reading any documentation, googling at all, write the code. 3) Do not execute the code _at all_ until you're "finished". Once you're "finished" _don't let yourself edit the code again_. 4) Repeat until you can bust out simple puzzles off the top of your head This tactic I've found also really really helps me get better at a new language or framework. Forces you to confront the parts you dont actually know, and solidify the parts you do actually know. When you're standing in front of a whiteboard, you'll feel natural and ready to go (assuming you've practiced in this way enough).
Also `overflow:hidden` on the parent.
So, you can create a whole bunch of javascript files, each containing script pieces you want to test. Make sure they are complete enough to be on their own. In the head section (or where ever your code is) of the HTML, just do like below......you can comment out the html line so the script isn't "imported" as example below &lt;head&gt; &lt;script src="/files/tutorial/browser/script/rabbits.js"&gt;&lt;/script&gt; &lt;!-- This section is commented out --&gt; &lt;!-- &lt;script src="/files/tutorial/browser/script/bears.js"&gt;&lt;/script&gt; --&gt; &lt;!-- This section is commented out --&gt; &lt;/head&gt;
Stress used to be a huge issue for me. It wasn't until a friend of mine told me that I'm also interviewing them that I began to feel comfortable in an interview setting. Remember, you're also there to find out if they're a good fit for you! They're interviewing you because they're already interested in you ;) They want to know that you have a solid understanding of yourself, your strengths AND weaknesses. They don't want to hear some BS about how you can do all this stuff if you can't, they want to know what tasks you'd be able to do for them, and what a good starting place for you would be. That's why they have white board coding, they just want to know you can code. And if they ask you something you don't know the answer to, just say so! I was once in an interview where after every answer I gave, they shot a more difficult one my way. Eventually I had no idea what they were asking so I just said, "I'm not familiar with that." I actually got the job, and found out later that they'd have kept asking me questions till they knew I was BSing them. They're smart people, developers. Be humble, but be confident about what you can do. They appreciate that in a field with so many egoistic minds. And don't be afraid to ask them questions. Make sure anything you're curious about, you leave with some information. It sucks to walk blindly into a position. Even ask to walk around and talk to the devs if you want. They're all just people there to help.
Developers that need a class system in javascript are the reason why I don't like the class syntax sugar. They haven't really learned prototype, they just know how to make JavaScript sorta act like it has classes. Those are the people who are going to get screwed with the new class syntax sugar. Because now "JavaScript has classes". I've seen several tutorials on ES6 that claim JavaScript uses classes now. They don't realize that it's just sugar over prototype.
Add 4 spaces before each line of code, then it will be formatted.
&gt; Can you explain why the polyfill[1] for Object.create on MDN is the way it is? What's wrong with it? Without the argument check, it's just var Temp = function() {}; Temp.prototype = prototype; var result = new Temp(); Temp.prototype = null; return result; bwaxxlo's code is: var Collie = function(){}; // var Temp = function() {}; Collie.prototype = new Dog(); // Temp.prototype = prototype; var wolfie = new Collie(); // var result = new Temp(); 
&gt; I have a hard time white board coding Bring a sleeping laptop that's already got your preferred editor running. When they want to whiteboard, ask if you can use your laptop. I've yet to have an interviewer say no, they know the process sucks. If they do say no, then you're probably better off not working there.
Event streams are for thinking about multiple asynchronous events as a collection. Then you can do things like map a function over those values, or merge two streams together. So maybe if you wanted to call your service multiple times, you can could create a stream of service call values and then manipulate that stream into something else. But whether it would be helpful to use frp or not would depend on what you're trying to do with this code.
Looks awesome.
Keeps breaking for me (on latest OS X with latest Chrome) after a few slides with: Uncaught Error: Assert failed: No more than 1024 pending puts are allowed on a single channel. Consider using a windowed buffer. (&lt; (.-length puts) impl/MAX-QUEUE-SIZE)
I didn't check the JS console, but same OS+Browser combo, and it kept breaking for me (had to keep reloading every couple of slides to get it to work).
that was just the time unit missing ? That's Firefox being pedantic for sure.
Press F12 in your browser. It will open the Developer Tools. The console is in there, along with a lot of other tools you may find useful :)
To some of us, jQuery is like the Voyager 1, having left the solar system in 2012.
Your advice is years out of date
It's 2015 and we have Babel. Who still cares about CoffeeScript?
What /u/nexd said: &gt; ask questions in addition to answering them Especially this, very useful when you want to sidestep idiotic questions gracefully. Sometimes they're just fishing for topics, so if you can guide them to something you'd like to talk about they'll usually be grateful for it.
Mithril is really just a virtual dom implementation + router + some frameworky conventions. Personally, I think none of these are all that great in Mithril, so before you decide to use it, check out the other options. For virtual dom, here's a list of alternatives: http://vdom-benchmark.github.io/vdom-benchmark/
It was supposed to be simple, not up to date. Let's be fair, it is a simple method. Just tried to be constructive and add something to the discussion, by giving the dude another option. Skitch already answered the question, honestly didn't think giving some more basic concepts would hurt.
That is a good documentation of achieving a rather beautiful solution though trial and error.
Arrays are generally fine. The big problem was that "pointsMap" wasn't a map. Things would have been more obvious if the name "pointLabels" would have been used. Apparently, "pointLabels" is a list of labels. There is no surprise there.
I can't use F12, I have a Chromebook.
It's nice, however, when I have to animate something I preffer GSAP
&gt; ES6 classes are just syntax sugar over prototypes. If/else, for, while, do-while, and switch/case are just syntactic sugar for JZ/JNZ (conditional jump op-codes). Having an actual language construct for classes does change some things significantly. It's not just "sugar". It clearly communicates your intent in a declarative manner.
An odd thought: if this is combined with es6 promises and the individual result of each thread operation is an invoked promise will it force each thread to stay alive?
You don't want the threads to stay alive, it will actually hurt performance the library was built with a working thread pool and only allocates 25% more threads than your logical core count. In the case where someone invokes a function for say.. 250 threads and your machine can run up to 4 at any time, those 4 threads will remain active and be repurposed until all 250 have been processed. In other words..there is no need to keep your threads alive as it will negatively impact performance in cases where they are not needed. 
How does one interpret it?
The top of the horizontal bars are the left most or top most point in that area and the bottom the right most point. The vertical bars represent distances. I added two elements to represent the offset that is relative to the parent element.
Do a course on Code Academy: http://www.codecademy.com/ Read some best practices guides when you're going to start writing code: https://developers.google.com/speed/articles/optimizing-javascript Look at additional resources: http://jstherightway.org/#getting-started Books and guids: http://jsbooks.revolunet.com/
Dojo 2 has been in the planning for a long time. I'll be glad to see it arrive, but can't help but feel that Dojo has completely missed the boat with how slow new versions have rolled out. *edit* Also, typescript? Barf. 
Your list contains Aurelia, which is a framework competing with Angular (among others,) which you don't want to depend on. Are you OK depending on Aurelia?
Have you used duo-test to test your code? That's one of the things I haven't done yet. 
In my language, the second example would look like this: const pointsMap = ['Love-All','Fifteen-All','Thirty-All'] const callTie = (points) -&gt; pointsMap[points] ? 'Deuce' Or, since I don't really like the pointsMap removed from the only function that requires it merely for anticipated performance reasons, you can use a closure: const callTie = do -&gt; const map = ['Love-All','Fifteen-All','Thirty-All'] return (points) -&gt; map[points] ? 'Deuce' The truth though, is in a good browser like Chrome, there is almost no difference in speed in any of the above vs just using an array inline declaration: const callTie = (points) -&gt; ['Love-All','Fifteen-All','Thirty-All'][points] ? 'Deuce' You can verify the performance here: http://jsperf.com/array-literal-index
Imho, #1 most important thing is pick a project you can get excited about and make it. Applied learning is way better than learning for learning's sake or even all these new (cool) gameified versions are learning. As far as learning some things about javascript, I make everyone who comes into my lab do this one : http://jhusain.github.io/learnrx/ the page kinda sucks, and even if you don't care about rx.js (which I don't) everything you learn about map and filter will be useful across many domains.
How about a whole app with a certain routes, controller, services inside of it? Like a Payment gateway app but it AngularJS.. 
\*ES2015 Great. Now let's see what's coming up in ES2016...
ES6 (ES2015) is backwards-compatible with ES5 and earlier. Nothing will be outdated. Some of Crockford's boilerplate for prototypal inheritance won't be useful any more, but it won't become incorrect.
&gt; CommonJS modules are simpler and less intrusive than RequireJS. Yes, that's well said. I dunno why people keep messing with that damn thing, it's such a pain in the ass to use. I use browserify, though, not webpack
I have to admit I'm not an expert on Browserify. Can you have it split up your bundles so you can load part of them asynchronously when you need them?
David Walsh thinks block scope is confusing, which is a pretty clear indicator that he has very little experience with other languages. And Crockford doesn't value tooling at all. In fact, he's downright dismissive. Crockford also believes that classes automatically equal complex hierarchies, which kinda sounds like he never heard of traits and mixins. Crockford certainly does has some good ideas and some of his observations are totally spot on, but he's also very biased and he also seems to say a bunch of things just for the sake of being quotable. Anyhow, my priorities are quite different. I view tooling as *the* most important thing.
Hi folks, I just wanted to thank you for all the responses, they are extremely helpful and informative. Thanks so much! 
There are ton of great talks online from conferences like [JSConf](https://www.youtube.com/user/jsconfeu), and meetups like [JS.LA](https://vimeo.com/jsla).
Thanks for providing the simple answer. In my opinion simple and out of date answers are good for beginners since it takes away the abstraction and gives a better sense of what is happening. Started out initially trying to learn rails, but was unable to understand how a connected with b since so much of the framework is automated. So what I did was went back learned C and C++ then PHP then ruby and now it makes it much easier to understand rails and other more high level languages. I'll use your method of putting my switch variable in the Window for now. Thanks
You are right about that. I tend to find a stack that is completely independent of frameworks like aurelia, mitril or riot. Nevertheless, they might have good approaches and parts to learn from and which can be adapted for a lightweight micro solution.
There you have it, with webpack, it is straightforward :-)
thanks for reporting, will track the problem here: https://github.com/shaunlebron/solar-system-of-js/issues/14
page.js looks really great. very promising for a small router component.
I just hate how webpack gets so much attention whilst an arguably better project like JSPM is left with few hipsters. I guess the name JSPM is probably not as self explaining as 'webpack'. It mean Javascript package manager if you wondered.
RequireJS should be outlawed.
I'll check it out.
@tebriel, Have you actually used TypeScript recently? Your response was my initial response over a year ago, but basically it gives us 4 valuable things: * Types (less errors in our code) * Interfaces * Easy module export to ES2015, CJS, and AMD * Support for ES2015 features (which you could also get from something like babeljs) As an end user, you can use TypeScript, or you can use your module format of choice. We have intentionally taken our time on Dojo 2, as we really wanted to wait for our enterprise users to finally get to a point where IE8 isn't that important to them any more. There's really no such thing as missing the boat in open source, you just need to create something that is powerful and flexible, and people can choose to use it and contribute or not.
Just started using JSPM + SystemJS and it's awesome! Loading CJS, AMD, or ES6 with equal ease is pretty sweet.
very nice. do you plan to create more visual references like this?
That's a babel thing. I encounter the same stuff when I'm working on the back-end with Babel hook.
You're welcome, glad to be of help. For someone that is already familiar with other programming languages, I would highly recommend the following book: http://shop.oreilly.com/product/0636920025832.do (Learning JavaScript Design Patterns). It's a superb and short book that teaches you some advanced but fundamental techniques. You'll be up and running after a few minutes of reading, enjoying the JavaScript ride a lot more.
It was a vast improvement to the original switch statement. I would probably put the Array in an outside definition instead of redefining it on every call; I know that modern engines will optimize your version so that it makes no difference, but I have the habit of supporting older clients.
Can you provide more detail / examples of how to use this? It looks very useful once you know how to apply it.
&gt; dynamic loading I think you mean asynchronous loading.
I usually do as well or put it in a closure. Chrome optimized it well, but Firefox does not yet. 
Do you mean like this: http://pastebin.com/kRdNhHwA
ES6 classes are literally syntactic sugar, according to the authors.
You have to piece meal it all together. jQuery and Knockout are libraries, not frameworks. Knockout gives you two-way data binding. jQuery gives you a x-browser abstraction for events, DOM manipulation, ajax and animation (high level overview, of course).
The article specifically states the audiences goal of making the code more explicit, which is the opposite of what your solution does, no? &gt;The valid arguments raised were that the explicitness of the `switch` gets lost in an implicit use of arrays, they are zero-indexed and therefore implicitly do the same as the switch, but it’s not “visible” as well as in the code before. From there we started discussing how much the source code shall rely on language specific constructs. Shall a piece of domain knowledge, here the mapping of 0 points to ‘Love’ and 1 to ‘Fifteen’ and so on, be hidden behind an implicit construct that actually does the same and allows for less code, but also reveals the intention less good?
Fine but it doesn't change my point that this term is overused and doesn't really mean anything.
Yeah, I do agree.
What do you get when you console.log (div)? That's where I would start debugging. Also, you commented out the div so the getElementById method shouldn't be returning anything right now.
You are appending most your elements directly to the body tag. If you want them nested correctly as in the commented out example code, you need to append each element to the element you want to put it inside. [This fiddle](http://jsfiddle.net/te99zn47/) should get you on your way. 
Great solution, and very cool looking game! Best of luck :)
 if(tdRef.style.backgroundColor="pink") You are assigning pink, which yields a truthy value. Try if(tdRef.style.backgroundColor === "pink")
Pfft, nobody calls it ES2015
I don't see what the problem is with server side includes. It's all done on the server before the HTML/JavaScript is sent to the browser. All the SEs will see is the content as you send it, and it will index it quite as well as if it were static HTML/JS.
Sure, feel free to use CSS from that Bin as you see fit. And yep, you'd need to modify the transform matrix directly for the mouse to work correctly. Haven't had the time to look through your code, but if you haven't found it already, Snap.svg has [`Matrix.translate`](http://snapsvg.io/docs/#Matrix.translate) that might help with that.
Tags, branches or paths (if I'm not mistaken): // js example var reactive = require('component/reactive@0.14.x'); var tip = require('component/tip@master'); var shortcuts = require('yields/shortcuts@0.0.1:/index.js');
There's much more to the overhead than just the file size, you know. 
Can you explain what you mean in more detail? 
ES Vista
I really like the premise of this site, as it touches on a subject that isn't covered much here, and for which there's always multiple, competing solutions, and it can be confusing and intimidating trying to decide which approach to use. I've seen junior devs try to manipulate data and end with 100's of LoC, when in reality a couple of well-placed library methods -- or sometimes, simply using new ES5 methods -- would have yielded a drastically cleaner result. So I definitely think there's a need for some good education in this area. With that said, I have a few criticisms of the site, that I hope will be seen as constructive... The _Getting Started_ section details that both D3 and lodash will be utilized; great! D3 is all about playing with data, as-is lodash, so it's a perfect fit. However, the shortcoming that I see is that some examples are handled in D3, and some in lodash, and then some in native JS. It would be awesome, IMHO, if the solutions provided included all 3 approaches for each problem, so that one could compare them side-by-side. There is also a lot of data-processing that's done where D3 (and/or lodash) isn't being used, and so the examples that show how to do it only with those libs are going to be useless for some people. Likewise, lodash has some really elegant features that were often not even mentioned when the D3 or native solution was given. On that same token, some mention of logarithmic complexity is probably warranted, though I didn't come across any as I was scanning the pages (so, sorry if I missed that). Logarithmic complexity isn't normally that big of a deal for most front-end tasks, since the datasets typically aren't that large, but when dealing with larger datasets then choosing the correct algorithms can make or break your application.
I'd argue it's more that `r.js` is the pain in the ass. On a related note, /u/tbranyen recently posted: [Thinking about an AMD v2 spec/impl](http://www.reddit.com/r/javascript/comments/2zdcef/thinking_about_an_amd_v2_specimpl/), although I haven't kept up with the conversation (maybe Tim can chime in), I plan to follow what happens as I do think there's some good ideas there. 
ES One
I wonder how long it'll take from this being finalized to TCO being a feature you can rely on across implementations.
*ES6 I'm going to sound like a jerk but I don't care. We shouldn't be encouraging that terrible ES[year] idea. I don't care if it came from the ECMAScript committee. It will be years until ES6 is ready to be used without a transpiler. It's a nonsense idea.
For single page applications it might well be worth it if it shortens development
I really like it, especially when I got rid of "that" and started using more relevant naming instead. function Point (x, y) { var point = Object.create; point.draw = function () {...}; return point; } Variables are private by default also :D
Can i do async module loading with commonjs?
I put off learning CommonJS and Browserify for the longest time. Holy crap, what a bad move on my part. Life is so much simpler now.
From the wiki page: &gt; ECME-262 6h Edition, The 2015 ECMAScript Language Specification Wait, what's ECM*E*? What's the *6h* edition... the 6 hour edition they threw together? 
I assume final *draft* means it still isn't quite an official spec. So how long will it likely be until it is?
Final draft of the spec. First draft of the wiki.
ActionScript. It was awesome and terrifying and now...I haven't used it in years.
It's official when it's approved by the Ecma General Assembly in June. But there will only be minor editorial changes between now and then.
Really interesting, thank you for the detailed reply. I recall now that one of my older programmer friends said that he learned programming High School with punch cards, so it seems likely it was with Fortran. 
I have just realized how hard it is to read, sorry. So the diagram shows the meaning of different APIs to query the size and position of elements. For example, Element client left/top blue bar (That refers to the the properties clientLeft and clientTop of elements) goes through border and scroll green bars, that means it is equal to the size of borders plus scroll bars. This API is supposed to show a position, looking at the diagram you can see that it is the position of where the padding starts and it is relative to where the border starts. Another example is Element offset left/right. This API shows the position of the current element relative to its parent. Looking at the diagram you can see that the position of the current element is actually where the border of the current element starts and it is relative to the position of the parent element including the margin, but excluding the space that is not visible due to the use of the element own scroll bars. I realize that the API actually uses the space not visible so I will fix that. And the function getBoudningRect() starts in the viewport that means that the coordinates are relative to the viewport, not the document.
Thanks. I will look that up. There is one mistake in the diagram, so I think I will add that when I fix that mistake.
PHP has seen even more drastic changes in its lifetime. PHP 5.0 completely overhauled the entire class system, and every version since then has come with significant additions to the language, as well as deprecation and removal of a lot of really bad warts. The next version, PHP7, has something like 30 new syntax features.
C# hasn't seen quite the changes that JavaScript is experiencing but still, C# 1.1 is almost completely unreadable if you're used to C# 5.0
Hey @kenman. I had a conversation with the Dojo team, James Burke, and John Hann. We just shot the shit about the current module landscape and thoughts we had on AMD. I'd like to work with them on some of the ideas, such as building on the Loader spec to load AMD. I'm still experimenting with a new AMD implementation that fully supports node_modules and has less complex configuration. Instead of building a total replacement for R.js as I originally intended, I'm currently maintaining deamdify for Browserify and I intend on making it support a majority of the use cases that R.js fulfilled. I really wish users like @_somanyguns would stop conflating module formats with optimizers and runtimes. It makes the conversations so much more confusing when we aren't even talking about the same things.
Here is the corrected version. http://imgur.com/TuVWQR7
What is a possible use case where creating a module and adding that as a dependency wouldn't suffice?
Yeah, I suppose I was just being lazy. I didn't want to have to isolate syntax changes as I was reading.
There's nothing wrong with using backbone today. Still an excellent lightweight framework.
yall took long enough to catch up to AS3, shit. At least dart took a real crack at evolving an already good language. As well as haxe. I'm in no way speaking of the flash player or air runtimes, they are crap. But as3 was a good language, and the languages that had existed for the longest time which inspired as3 (JS being one of them), I can't get around why it's 2015 and they're only now submitting a draft of a language which finally looks truly modern(mostly). If JS is to be the one true web language, it's evolving at a snails pace. I think what's been done with the web is incredible, especial things like Google closure. The state and direction of closure are indicative of googles position: they're not swearing by JS as the end all be all, but rather accommodating the lowest common denominator, which is noble. The question is, will the web be stifled if innovative and creative developers are deprived of serious languages and tools? JS was chosen by the browsers due to its lowest barrier of entry and ubiquity, not out of superiority. When will the language(s) of the web truly start to adopt modern features, and at a pace that browsers aren't waiting around to fully adopt?
Let's say my app is a payment interface where a user can send payments and receive... I'm thinking of in order to use our app they can embed our interface by directives like this: &lt;myapp-payment-interface&gt; and this interface will have some routes like: #/myapp/page1 #/myapp/page2 #/myapp/page3 and so on.. I like your idea regarding configuration hooks , I don't know if this is right but I'm thinking of this: &lt;myapp-payment-interface authentication-code="1234567" more-configuration=""/&gt;
The only reason there is so much hype about the upcoming changes in JavaScript is because they are so long in coming. With any other language the maintainers can just release a new compiler/interpreter and whoever wants to use it can use it. JavaScript's development however is slowed down by the need to get buy-in from all the major browsers. JavaScript is probably ten years behind languages of similar vintage due to the fragmentation caused by the browser wars and then IE's monopoly.
What exactly makes it a bad choice apart from age?
Maybe it's going so slow because js has been so widely adopted. I can imagine that they're a little bit scared to move quickly, since getting it wrong would be disastrous. Not really a good excuse, but it might be factoring in to the snails pace.
And if you don't specify which you want to use?
From what I've heard/read, React only replaces the view component and can be integrated with Backbone views anyway. Meanwhile Angular's two way binding and opinionated framework becomes a performance bottleneck as apps grow. If you plan on getting to a stage where every bit of performance and weight matters (which it does for 90% of what I do) then Backbone is a good choice. It's more like a good engine than a horse and buggy. It's up to you to build the best car to suit your purpose. Despite what the Fast and the Furious teaches, it's a lot more work to turn a Civic into a Lamborghini than to create a Lamborghini around a V12. 
You probably want to look into a task runner like Grunt (http://gruntjs.com/) or Gulp (http://gulpjs.com/). Both of these systems have great ecosystems and you should be able to achieve some basic concatenation with plugins like grunt-contrib-concat (https://github.com/gruntjs/grunt-contrib-concat) or gulp-concat (https://github.com/wearefractal/gulp-concat). Once you've got concatenation working, you can start thinking about things like minification with Uglify (https://github.com/gruntjs/grunt-contrib-uglify; https://github.com/terinjokes/gulp-uglify)
Perfect! I'm off to read some documentation - Thanks for pointing me in the right direction :)
I believe it will grab the latest published version.
If you're just getting started with grunt, and want a good example of a project, you should take a look at yeoman.io and use one of their generators to start with a base project using grunt and bower. Apart from concat and uglify, you could also think about using a module loader like requirejs, allowing you to flesh out your javascript in dozens of files (and your own folder structure), then stitching them together with requirejs. (there's also a couple of generators with requireJS for yeoman). Then as wildly said, you can simply concat and minify all those files together.
Earlier [discussion](http://www.reddit.com/r/programming/comments/2zmygn/paul_irish_has_published_his_new_insights_on_web/)
I wouldn't recommend Grunt because it is slower than Gulp due to files that are temporarily stored on the filesystem. In addition to Gulp there is also [Brunch](http://brunch.io/) which is worth a look.
If ES4 hadn't died on the table, we'd have saved a few years, yes. AS3 was of course the first attempt at an ES4 implementation, as the spec was shaping up at the time. The snail pace is, or at least was somewhat deliberate. ES4 was thought to be too radical too fast, so we got a "good parts" ES5 spec instead, and ES6 is resurrecting a bunch of ES4 elements, with hopefully the rest coming in ES7. Still, the push for transpilers and things like asm.js makes one wonder if this took perhaps too long and encouraged the growth of an ecosystem of things that run on top of javascript engine, but aren't written in javascript. 
Hey thanks, good to know will try this out later when I get home:)
I don't know.. I compare my typescript code with my AS3 code, and if I squint just barely, it quickly becomes hard to tell which is which. The biggest chunk of ES4 that's missing in ES6 is the explicit typing, but there's a proposal for it in ES7. The other differences are fairly minor (module vs package/namespace, for of vs for each in, implicit method binding to their instances, and a few more things.)
To implement this you'd have to create your own template file and assign it to your posts. So this would require a bit of HTML knowledge (and a tiny amount of PHP). http://codex.wordpress.org/Page_Templates http://codex.wordpress.org/Using_Javascript ----- You can also have a look at the plugin gallery and see if you find a YouTube or Twitch gallery of sorts. Example: https://wordpress.org/plugins/youtube-channel-gallery/
/u/syklenaut's is good advice. But if I understood OP correctly, it's a bit to soon for some of those points. I'm understanding that /u/ftpjko is still alone and a team is still in the future not the present. With that in mind... - given you're relying on a particular framework, just try to follow that framework's conventions and style. Whenever you don't, document it, the how and the why. The same goes for tools. Use standard, well known tools and avoid the typical sloppy ill-just-throw-a-simple-handmade-script. - in general, document as much as you can but specially any fundamental structures, models or architecture you do. Again the how and the why. - document, again, any peculiar details. Here documenting the why is particularly important. - offer to help interviewing candidates and look for ones who know the framework and it's general conventions and style. This works if you follow the first point. - try to find at least one who really knows the framework and is willing to go hand in hand with you through a deep review of what you already have. You need to find the right person and you will need to be humble and accept your code may need that help. - you may consider not hiring everyone at once. - follow syklenaut's advice on using source control right now if you aren't already. Right now using pull requests doesn't make much sense if you're alone, but do take some time to learn and establish a process flow, using branches per issue/task, releases if necessary, etc, and when the team comes do teach everyone the process. - if possible, try to get the company to pay for some short courses on stuff you feel particularly weak. Architecture? Team management. _Soft skills_. Whatever.
&gt; Read up on Kanban, Agile development, and Scrum. There was an article, just last week about how Google engineers rejected all three of those years ago.
Thanks so far, I've already searched for a fitting PlugIn but nearly no one let me embed a whole YouTube channel. And I want to embed more than one in one site in the same &lt;div&gt; or &lt;iframe&gt; (which isn't used anymore, or?!). So I did a little workaround and just copy pasted the last function in the .js file to embed a second channel, but it's kinda random which channel is shown first in the carousel and it seems that they don't order themselves like: Ahh X uploaded a video at 1. April, Y uploaded one at 2. April, X uploaded one at 3. April - in this order... it's more like: X uploaded videos at 1. and 3. April and down under is the video from Y who uploaded a video at the 2. April. I hope you know what I mean. But thanks! I'm trying right now to configure the JS/CSS/HTML things like I like it... it was kinda messy to implement jQuery for me... and to change the height of the embedded player in the &lt;div&gt; thing... it's not like "let's increase the number after "height: " ... in the css file" xD. (I think the "at" is wrong... xD)
The source code links under examples don't seem to work on Alien Blue, iPhone 6. They just keep opening new windows to the demo page.
Yea exactly, that's what I want :-)! Would be very awesome if you could help me :D. What is more actual than iframes? Is there a newer iframe thing? So I just have to replace the iframe command with something else? But let me guess, it's not that easy :D?!
Elaborate?
TRUE.
Just because Google rejects something doesn't mean it's a bad idea. It just means it wouldn't work well for them. 
Have you looked at [less](http://lesscss.org/)?
Do not work with grunt. It is nice but gulp is much simpler, uses plain javascript for describing tasks and the idea of piping them is very understandable. Also, grunt is slow compared to gulp.
He's asking about javascript workflow automation.
To get channel data from Twitch you need an API key (I think. They are free but requires registration on their site). It works in basically the same way as YouTube.
Possibly, but Less still does all that he is asking for.
Would you be able to share a link?
True, hadn't thought of that. I leave this here anyways, just in case one day OP feels interested in another way of splitting files.
On Twitch I just want to embed the streams and chats and they have a embed link for these things. I think that I don't need the API key... but... maybe for listing/sort purposes?! Like "the one with the most viewer at first" or something like that... I dunno :D.
ActionScript is still a beautiful language and way ahead of it's time. Just unfortunate that it was built on top of Flash which is slowly dying to HTML5.
You can use [ui-router](https://github.com/angular-ui/ui-router). Also, there is nothing stopping you from using an [iframe](http://www.w3schools.com/tags/tag_iframe.asp).
I don't want to be a wet blanket, but due to your lack of team experience there's no guarantee you'll be the leader just because you have been at the company longer and have more domain knowledge. More likely is someone new with team lead experience who will rely heavily on your knowledge (until they are up to speed) in order to impart that to the rest of the team. From them you can pick up how team leadership works and, if the lead is good, they hand you the reins on occasion in order that you can lead. They can then help you to do this without it seeming that they are taking back control. Good team leaders want anybody in the team to be able to lead if necessary, so it helps them (and your career progression) if you can do it. But you can't just jump in a lead role, Grasshopper. You're assuming responsibility for everyone's output as well as steering them to be able to do the same. A lot of replies are focused on coding practices (use source control, modularise, etc.) and few are about the people involved. This is the wrong way round.
Yep, it'll probably be added in the next version!
Here is an updated version of the script that supports multiple channels :) https://jsfiddle.net/NmvA9/7716/
http://jsfiddle.net/j3dbLt8v/7/ updated to use latest min
Awesome 
This is an interesting history of one of the most common js libs out there. The naming history is interesting, since if it was originally jSelect, that makes sense since nowadays most of its use has been replaced by `document.querySelector()`. I'm not sure what the future of jQuery will be, since so much of what we used to need it is now available in vanilla js, or handled by a more popular lib that doesn't come with quite so many features that are no longer needed. Most projects would be able to get by forgoing jQuery and just saying `var $ = document.querySelectorAll.bind(document);` instead. jQuery animations used to be the hallmark of a really slick UI, but now most of that should live in CSS transitions/animations (especially if you want them on mobile devices), and js should simply toggle classes. Even things like jQuery.each are handled either by `Array.prototype.forEach`, or use another lib like `_.each()`. I still like jQuery for how it manages XHRs, but even that's nowhere near the headache it was just a few years ago. Whatever its future, I love reading about the past of projects that eventually become huge to the point of nigh-ubiquity like jQuery. We can see that no matter how big it became, he still made many of the same mistakes we all do when we're just figuring out something new. Whether it's some bizarre attachment to a confusing but fashionable code style (his 'no unnecessary { }' style), or for some reason using an inappropriate licence for the project, there are plenty of times I've made those same missteps myself. Sometimes I get so worried about doing something the wrong way early on, it completely paralyzes my efforts, when really we should all do our best but not worry too much about making things perfect. Most of our progress comes from understanding the failures in the last thing we tried, and using that to make our next project better.
Lol... it's that easy? Is it possible that it plays one video after another?! So it could play the big video and after it finishes, automatically the next one in the sidebar loads...?
But... thanks :D! Totally forgot to say thanks for your help ^^. Really awesome :)!
Hey thanks this was exactly one of the things I wasn't aware of! explains why it was not working as I intended:)
One thing that might help the most, if you are going to be working with a team, is going back and reading code you have not touched for &gt;6 months to a year. See how easy it is to figure out, and think of how you could improve that. The point here is that other people are going to be coming in with even less knowledge of the code than that. The point is to try and simulate how it will be for someone else to work with your code.
I've used both ember and react w/ flux extensively, and I know where you're coming from on this. In my experience, I find models in ember work quite nicely when you're mapping everything from a backend that's also MVC, e.g. your ember app is just sitting on an open socket to a Rails application, and exchanging JSON using the basic CRUD in your Rails controller. Where I'm really liking flux is for how the 'stores' system works when I'm exchanging data from multiple sources. I'd just written something last week that uses a PHP-based CMS, a Google Fusion Table, and EventBrite. My initial attempt used a more traditional MVC, and it turned into a complicated mess pretty fast. The Flux loop (dispatcher -&gt; store -&gt; view -&gt; action) keeps things surprisingly organized.
Read [Learning JavaScript Design Patterns](http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/), pick a few design patterns you really like and keep with them. Create a document of best practices for your team to follow, to make sure everyone is on the same page. Readable code is more important than performance (unless performance actually becomes a real issue). Using Git and pull requests will be important. Do code reviews often. Make sure you have time to refactor code at the end of projects. Your code is probably bad, and you'll need to be willing to take criticism on how to improve it. There is nothing wrong with bad code as long as you're willing to learn from it and make it better. Its a part of the learning process.
Looks like the same talk that he has done the past year at different venues.
As mentioned by everyone else, avoid Grunt, use Gulp. Gulp does everything Grunt can do better and faster, with less code. On top of that you should probably be using a proper module format, preferably CommonJS. You can build it with browserify or webpack.
With proper English sentences and formatted code too! Can we sidebar this post for future people to refer to when posting questions here?
Read more books
&gt; RapydScript is a pre-compiler for JavaScript, similar to CoffeeScript, but with cleaner, more readable syntax. Cleaner than CoffeeScript; which has garbage syntax in the first place. All of the features this introduces are already implemented in ES6. No offense to the creator, but this seems completely redundant. It isn't even clear if RapydScript supports some of the newer ES6 features: enhanced object literals, template strings, dstructuring, generators, etc. Just for fun, here's the code in ES6: class Popup { constructor(containerId) { this.$popup = $('#' + containerId).addClass('pop-up').mouseout(() =&gt; { this.hide(); } this._$darkbg = $('#dark-bg') } show() { this._$darkbg.show(); this.$popup.show(); } hide() { this._$darkbg.hide(); this.$popup.hide(); } } let msg = new Popup('my-popup') msg.show() vs class Popup: def __init__(self, containterId): self.$popup = $('#' + containerId).addClass('pop-up').mouseout(def(): self.hide() ) self._$darkbg = $('#dark-bg') def show(self): self._$darkbg.show() self.$popup.show() def hide(self): self._$darkbg.hide() self.$popup.hide() msg = Popup('my-popup') msg.show()
Just curious: why did you ditch typescript? It's not that hard to set up at all, and after all that's something you do only once. We use it for all our projects and i cant imagine maintaining code without it.
I think you're a little confused, or just trying to sound like you're right to impress the internet. Syncronous loading is a thing. Asynchronous loading is another thing. And dynamic loading is also another thing. You could have synchronous dynamic loading. You could also have asynchronous dynamic loading. You cloud also load your entire codebase synchronously or asynchronously in a single concatenated file, as many people do. Go ahead and try to redefine facts to fit your argument, but you're still wrong, and what I said is not irrelevant unless you're suggesting it's better to be ignorant.
&gt; I considered Typescript but gave up instantly when I saw what a pain in the ass would be working with Angular and other frameworks Not sure I understand this, especially since the DefinitelyType repository has type definitions for Angular already: https://github.com/borisyankov/DefinitelyTyped/tree/master/angularjs
Yeah, that's very respectable. I'm just saying that if he can't confidently lead the team there's nothing wrong with admitting it and hiring someone who can.
I really wish they had added the optional typing of AS3. Instead... we get generators and 'classes' to better hide the prototype basis of the language...
I have been using node-sass happily. I don't use compass though. Obviously you can get this to work easily with a task runner like grunt or gulp
I don't know if there are any particular issues with ES6 transpiling, as I'm using typescript. I have noticed a few things that are probably common across languages. 1. Fiddliness generating map files - sometimes they just dont generate right for whatever reason 2. Chrome sometimes fucks up variable names in minified code 3. No good way to switch between generated js and the original language ES6 also has a large runtime library, although it is optional you have to be aware of it and what you can use.
Did not know about npm version! Nice tips. This is great. 
I wonder when people will stop referencing the old 6to5 name whenever they mention Babel, I've been tracking users ever since we did the rename and most of them have starting using it after the name change. ~2000/day in early February to ~13,000/day currently
Absolutely. I use it every day at work, and larger companies are definitely using it too, including facebook and airbnb (judging by their new [style guide](https://github.com/airbnb/javascript/tree/es6). [Babel](https://babeljs.io/) is a great transpiler and whatever build system you use it will plug into it probably seamlessly. We haven't had any difficulties. ES6 and React play together very nicely - Babel will also transpile your React .jsx files by default, so you can use it as a drop-in replacement for that, and then also get the benefits of everything else Babel supports. The most recent version of React (0.13) supports the ES6 class syntax for creating components, and, from the [announcement](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html): "Our eventual goal is for ES6 classes to replace React.createClass completely" though that's obviously a long ways off. So clearly the React team has ES6 support in mind. As for debugging, it's not really any different than the problems people already have, and the solutions are the same. It's worth noting that even without ES6 you'll still be trans/compiling/minifying/uglifying/concatentating your javascript anyway. We use source maps and they usually work pretty well, and you'll want to use them regardless of whether you're using ES6 or not. So, yes, people are definitely using ES6, and it's completely doable and completely worth it. The arrow functions alone are enough motivation, at least for me.
Classes get a hell of a lot better in ES7 and every major framework is already basing things of them. @classDecorator() class Foo { prop = 1; @methodDecorator() constructor(...args) { super(...args) } } There's a ton of stuff in ES6 and even more in ES7. For debugging in the browser sourcemaps keep getting better and better, but a neat trick I've learned is to blacklist features already supported in the browser you are using and only transpile them all in production. Note: Be careful doing this with Firefox and Chrome as they still have some bugs with certain features, we'll be working in Babel to fix this problem.
Babel's transpiling is pretty clean, and source maps are supported in most browsers. Debugging ES6 so far has been a little easier, since Babel can provide detailed error messages [like this](https://twitter.com/mattdesl/status/586898932665573376) on syntax errors and other problems. I don't care much for classes either, here's a few things I've been using a lot: - destructuring - fat arrow - const / let - spread operator - template strings You end up with some extremely terse code that tends to be faster to write and easier to maintain. [Example](http://imgur.com/rqDLoGS).
Oh I wasn't calling typescript ES6 I was just using it to point out some issues with transpiling that might be universal. 
Sure, as I [mentioned earlier in the thread](http://www.reddit.com/r/javascript/comments/332v73/is_anyone_using_es6_in_a_large_project_hows_it/cqh2igc) there's also a trick I've learned: With Babel you can selectively disable certain transforms that you don't need in the browser you are working in. ie. if you are working in the latest Firefox you could disable the spread operator or object literal extensions. This means you can work with the native implementation when developing and transpile everything when in production (to support every browser). Right now it kinda sucks that you need to manually do all of this (and you have to be careful about buggy implementations) but we already have ideas on how to improve this greatly.
Hi - first of all relax, it sounds like you are doing pretty good for a one man show on the front end! Also, you don't have to have all the answers. Hire someone smarter than you if you can - or with more javascript experience. Go over the design with them - ask for input. Identify places where you need to refactor the code - maybe somewhere that's a thorn in your side now, or in a place where you will need to make a lot of future changes. Then work with the new person(s) to come up with the new design. They will help! Get them invested. Then write unit tests if you can, and start refactoring. I say "if you can" since you may need to break things up first. Make sure to do code reviews so you can learn from each other. They sound tedious, but are a wonderful way to stay connected. Working in a team is really rewarding (IMHO). Also make sure to setup good communication - use something like Slack to stay connected. For me, it just doesn't get better than being on a small team and working together to be productive. Best of luck to you!
Yes indeed, but also not my point.
&gt;No, code doesn't documents itself. No, code comments ARE NOT a documentation. No, unit tests are not a replacement to a good documentation. I couldn't disagree with this more. Manual documentation is out of date before your change ever hits production. The best thing you can do is put documentation into your build process. Generate docs for classes, methods, tests, everything. Keep it concise, but do it for everything. Javadoc (or whatever your language equivalent) is cheaper to implement and generally more useful than tech writing. Making API contracts (for any code) explicit and documented *in the code* is more useful to everyone than any kind of Confluence or Wiki docs could be.
Hehe. I hear you... But others gave great advice and I didn't have much to add except that OP should probably be looking for someone who has more of a software engineering background (and would more appropriately be hired to be his boss).
read about kanban, scrum, and agile. Keep what you think fits and ditch the rest. Get a copy of [Knights of the Tele-Roundtable](http://smile.amazon.com/Knights-Tele-Round-Table-Millennium-Executive-Especially/dp/0446518794). It's kitchy but it's a outlines a pretty good framework for building teams from a personal perspective. It's about how to establish yourself as a leader. You work for your team, not the other way around. Always try to think what you can do now that your team will need in a couple of weeks. Herding cats is a very apt analogy. Expect chaos but be the guy that never looses his head when things are sliding sideways. Always step up to protect your team. And I guess, finally, beware of senior developers that say that things can't be done.
&gt; Right now, to include es6 code, you have to make sure to register babel and tell it to transpile npm modules, which can be a little slow. If using browserify, registering babel (and therefore transpiling all npm modules) isn't necessary as long as the module being required declares the transform in its package.json E.g. "browserify": { "transform": [ [ "babelify" ], ] }, note to ephasize: this needs to be in the package.json of the module *being required*, not your app's package.json
As someone who has worked as a front end developer on multiple teams, from startups to larger organizations I can recommend this: 1. Judging from your level of scrutiny and thoughtfulness of the codebase, I'm not too worried about how you will do as a lead. Continue to advocate for code quality and maturity in the framework. I like the idea of a javascript style guide for a team of 2 or more developers, because it encourages a shared vision amongst all. If you don't know where to start here, you can fork airbnbs' style guide, which is pretty sane https://github.com/airbnb/javascript 2. You may be fatigued by working alone and having to solve so many of the problems without an outside perspective. Make sure you have a strong role in hiring and look for candidates that have proven experience building large scale apps using design patterns and inheritance. 3. There is a gulp plugin for babeljs. Babeljs will allow you to compile ES6 code into ES5. This will allow you some ES6 goodies like class syntax that may make building a clear inheritance model easier. Good luck and be kind to yourself! The fact that you have the anxiety that you have just means you want to do well! 
I find that with some modules too, while others it's been easier. I can't decide whether it's something to do with what the module is or just luck. But /r/javascript is usually a good place to post it, if you haven't tried that yet?
I'm using it in a mid-sized backbone project, its going well. Babel is really good and very easy to include in my build process (browserify, gulp). The main thing that has troubled me so gsf is when and where to use arrow functions. Backbone messes with `this` for your convenience anyway, and sometimes using arrow functions in conjunction with extended backbone view functions can cause unexpected results, so in many cases where my gut told me arrow functions would be appropriate I've gone back to regular anons. Ultimately I think I'm going to be using classes a bit more for this sort of thing. `let` is also good, works nicely and reduced my vars-at-the-top. The import/export syntax is considerably nicer to write than node's standard syntax. No problems compiling or using with third party modules either. I would highly recommend just sticking it into a project and using it a bit at a time as an experiment to start with.
Thanks :) glad it was helpful to you!
Oh man, you're using all my favourite technologies. Koa, React, Browserify, ES6... I'm very jealous.
Just addressing the first item. Of course you will still be reading / debugging old style code in libs, even if you won't be writing much.
It doesn't matter; you will need to use a transpiler anyway.
And here I was, still using http://m.reddit.com
tbh I'm not sure lazy loading images is that good an idea. You might want to lazy load HTML and JS, especially in a single page app, because the browser will wait for all of it to be loaded before it displays the page. But images, afaik, don't block the page from being displayed. And I think the normal browser behaviour is better because it means the images are more likely to be already loaded by the time you scroll down to the section with the image.
Wow, that code looks really clean indeed. I didn't know that `const` could be used to define functions (only just getting into ES6 from ES5 in past few days). Can you explain the `a=1` in the second function's arguments? and what is the `...` in the return array?
For reference, here's the ES6 spec on arrow functions and arguments: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-arrow-function-definitions-runtime-semantics-evaluation
Here's where the arrow functions and arguments issue was filed for TypeScript: https://github.com/Microsoft/TypeScript/issues/1609 Mentioned in the discussion: Firefox and Chrome/V8 were also implementing the spec incorrectly.
The TypeScript compiler now flags arguments inside an arrow function as an error (in TS 1.5 alpha): var f = () =&gt; arguments; &gt; Error:(1, 15) TS2496: The 'arguments' object cannot be referenced in an arrow function. Consider using a standard function expression. The compiler error might be relaxed in the future: https://github.com/Microsoft/TypeScript/issues/2665#issuecomment-90822024 https://github.com/Microsoft/TypeScript/issues/2430
I used to use lazyload for a replacement to pagination almost all the time. But after a load of research using a/b tests etc i am 100% sure that using pagination is getting my user to the appropriate content faster. Simply because pages get page cached and they know on what page their content could be. Now there are good use cases for lazyloads, like TMiguelT says. But other then that i am far against using lazyloads. Unless you're pinterest, in where its part of the experience.
If you want all the work done for you, you'll have to pay for it.
&gt; I'm not evil [but I want to steal this book] Please don't ask for advice on how to do things that you already know are potentially/likely illegal.
Maybe you could take the oppurtunity to learn a bit of JavaScript here and do it yourself ? ;) I-m busy all day, so I won't be able to help you out here.
Maybe, but I guess in that case (an image gallery) I might not even have the image elements on the page until they scroll down, at which point I'd use a framework or jQuery to add them. Which will have the same effect because they're not loaded up front but it means you won't have a weird page of non-loaded images like this library would probably produce. And I suspect as people have said that google might have trouble adding those images to image search without a src attribute.
I can mainly recommend [MDN's drawing shapes](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes) as well as [MDN's using images](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images) which have great tutorials / examples. If you're having any specific problems with these examples feel free to let me know.
Yeah, *bundle-sfx* is the whole package. I always read it as "bundle with *special effects*". Your ideal bundle does sound like what *bundle* does right now, but you'd still need System.js on the page. Anyway, http2 is imminent, then bundling will be unnecessary in most cases and ES6 imports really get to shine.
This is my code: http://pastebin.com/GSQ5DYba and all i got is a circle with no background.. Can you see why this is happening? 
&lt;3 Paul Irish
Yeah, that's true. I'm not very experienced in extensions, but if jspm doesn't cut it for that use case, Browserify or Webpack with a Babel transform/loader is still great.
The a=1 is a default value for that argument. So if you call rgba('#fff') the alpha value is still set to 1. If you passed it rgba('#fff',. 5) the alpha would now be .5 Mobile response, excuse the formatting 
Indeed, although I *also* pull in several modules I don't have control over, (for example, koa-router), and forking them to include browserify or creating a pr for all of the modules *and* all of their dependencies becomes cumbersome pretty quickly.
Just curious, any reason to use this over [gl-matrix](https://github.com/toji/gl-matrix)?
1GB of images??? What is this? 
That's not possible, unless every image was on another sub domain, all modern browsers will only send 6 or so parallel requests per domain. So at most you will have 6 requests at a time. Plus at least chrome will defer loading images outside the viewport until it thinks they might be in the viewport soon. (On really pic heavy websites) and the browsers heuristics are going to be a lot better than this js libraries will be.
An application that is uses by people to quickly identify participants and other info in research videos. I take pics from the videos using python and ffmpeg.
You can easily adjust pipelining values in the browser to increase or decrease the max simultaneous requests. Iirc Firefox is set to 8 requests. And after building a few of theses apps there is no optimization in browsers meant to handle pages with 1Gb of images in HTML. Servers are not meant to be hit with that many non cacheable images either (most images are only seen by 2-3 users once each). Oh and all our images have to go through framework routing to enforce permissions, then we stream. Back bytes. This gives every images a unique url. For us this is only minor overhead but certainly not as fast as using nginx and static files. Try building a site with 9k images, 3k table rows, and a bunch of filtering and sorting on those rows and see how well a browser handles it with out some lazy loading. :-) Also, our largest single page is 22k rows, 66k jpgs. This one page would request several GB of images. 9k images is close to the average case for us. Even if the browser was allowed to make only 6 requests at time, it would take 11k batches of requests to fetch all images on page load. Garbage performance for UX. Finally, I use a 1px Grey gif as a placeholder and a container for the image boundries. The browser then has a lot less redraws due to no changes in layout and the one px gif is not only cacheable but only DL once by the browser. 
I would love to, but with out the images its pointless and all the data is research so we would need to make sure you filled out the right paper work, were in IRB compliance etc. I could share the source to the projects but they would be of no use w/ out also knowing the appropriate tables, relationships and supporting metadata. Mainly this all could be automated away if our video quality was good enough to run actual face detection and other automatic stuff. Currently we only use opencv to see if we are confident that there is a face like object in the video frame to capture better snapshots. We end up taking between 0-9 images usually but due to some bugs my boss introduced we both lost images and gained extras for some of these trips. When people talk about big data we tend to chuckle in our office. This doesn't even compare to how much data we have from in vehicle sensors. 
Your usage of smiles and what seems to be an arrogant attitude makes you sound, well, like a mean arrogant individual. That may be why you are getting down voted, in addition to having a serious funky usage case.
Meh no big deal :-) Our environment is what it is. 
I don't think it's fair to fault Angular when engineers don't use directives, don't write unit tests, or stuff everything into controllers. How could a framework ever enforce best practices? The real problem is just bad developers. Regardless of framework (or a lack thereof), they won't write in a modular fashion, won't write tests, and will stuff everything into one file. However, if you want to write modular and well-tested code, you can do so with Angular (and most other frameworks). Our Angular project is very modular and well-tested. Our controllers are small and our directives are composable. Sure, you can write bad code in Angular, but the same is true for React/Ember/jQuery/vanilla. How would you prevent this when the JS language itself allows you to shoot yourself in the foot?
I read all your posts just now since this sounds like an incredibly interesting project from both the technical and UX side! &gt; And after building a few of theses apps there is no optimization in browsers meant to handle pages with 1Gb of images in HTML This stood out to me though - wouldn't rendering these in a canvas viewport make more sense? Oh and also, from another post you wrote *"There's just no way to reduce the volume of data we have to process so the best we can do is make the UX not suck."* I'm always skeptical when someone says there's no way to do something; you might get some real benefit (without breaking the bank) from an exploratory ethnographic study of the the problem domain - while it doesn't always throw up direct solutions to the "no way" problems, it *can* frame the problem differently leading to some eureka moments. If you ever do a write up of what you're working on I'm sure it would be fascinating to read!
You're a very new redditor and this is your first comment? Hummmm... Welcome I guess! Ionic is actually one of the few on my list that doesn't produce native components... I feel that can affect performance, right?
React Native is really cool. I've tried Appcelerator Titanium and NativeScript before, but still prefer React Native: the community is vibrant and you get productive very quickly if you already know React. The end result on iOS is pretty good for a js app.
I'd be glad to pm you more info and some privacy safe screen caps and talk about it more and see what you have in mind! 
If it can help you, I'm not a new user :-) And I would vote for Ionic too. IMO It's one of the best I've tried so far, and I have an app in production with this tool. Pros : - NgCordova works really great with Ionic and let you use almost all native components. - angularjs is really cool to use. - the UI changes following the device you are using. - they are in active development. - The CLI is awesome. - really great communauty CONS : - if you don't know anything about angularjs, you'll have to learn it. - sometimes it's really slow on Android devices. - still in RC Not many CONS I admit, but I love this Framework so... 
&gt; NgCordova works really great with Ionic and let you use almost all native components. But not *UI* component, right?
Crosswalk is interesting, indeed! But it doesn't work on iOS as far is I know. So you can't simply target Chromium, you have to make sure your code works well on both Chromium and WebKit, am I right?
So it sounds you're horrible at both UI and problem solving.
Thanks a lot!
There's already an alternator. `counter%2` or, `counter&amp;1`
Well websockes is not needed persay but it could be used to tell the server when to send it more images based on changes to the specified viewport. However this is not functionally different from ajax requests (assuming I am understanding you.) node.js/oi.js could both be used here for sure. However to add context, this app was built in 2011/2012 and on top of Groovy/Grails (managerial decision). So at the time Node was hardly a major player, the JVM does ascyn io just fine as is (if we really needed it). On top of that Node.js database support anemic till a year or two ago. IBM did release a driver in late 2012, but node was not even on my radar at that time and a MSSQL driver was still a year away. As for websockets, they were brand new, and as I said not really needed because this app is not "real time." The images really don't spend much time in memory at all, only enough to read the bytes off disk and return them to the client making the http request. A little overhead is spent on the authorization checking credentials of the user requesting the image so none of the participant images can be accessed with out logging in first and also having the right group permissions. The problem really just boils down to "How do we efficiently identify participants in thousands of images that are stored at location x, protected by permission scheme abc, and stored in an XML column (again at the time no one was storing JSON in a DB and XPath queries already worked) in the DB2" with a lot of other minute details at play. 
This is great news. Right not I am supporting down to ie9 because the site requires canvas but I'll be keeping a close eye on my sites to see when I can let it go. 
whoa, cool.
spell check your logo...
[imgured for truth](http://imgur.com/YSXJDFj)
Hey, maybe he's going for an open source pun with "src".
&gt;I have a sack of potatoes if you are ever looking to upgrade your hardware! ;) You can find VTTIs address on our website lol &gt;That is dire. You *might* get some success by using some of the simpler ML routines in opencv to recognise the states of driver present/not to register change overs but yes, doing anything with low quality video is often an exercise in frustration. So currently we do this just to try and figure out if we take a snap shot of the video, how sure are we there is a driver in the frame and more or less looking in the direction of the camera. This of course fails all the time with such low quality video, glasses, sunglasses, hats, bright light, low light etc. As you can imagine. It does do a good enough job that taking ~9 images per video (three towards the beginning, three towards middle and three towards end) doesn't end up in too many manual reviews of the actual video files. &gt; Back when I was playing with face-recognition and opencv (tracking individuals within focus groups) I had to move to HD video to get any semblance of consistency and even then it was far too frequent that some random event would end up with the software tracking the potted plant in the corner of the room. Another constraint is the the cost of storage in the car units. We use laptop SSD for video and much of the data and some SD cards for some other data. Additionally there are multiple cameras. We use a mixed video feed to save space hence such a small pixle count for the cabin video. Yeah, and we can't upgrade to HD until SSD cost comes down some more :-/ But hey I get to solve some interesting efficiency/ux issues. Additionally there is a lot of auto flagging of events, car crashes, lane swereves, hard stops etc. However we still have to identify the driver before that data is possibly usable. Fun stuff indeed :-) 
Not really. I'm just trying to solve this bug. And I'm also wondering how such an error could be published... :/
I once read a post from a guy on hackernews (wish I could find it) who said he solved a problem where routing in his app was slow (due to using with express or an express-like datastructure where routes had to be iterated over) to building a DFA from route definitions which made route matching much faster. Using array literals for paths reminded me of that. Very clever indeed.
I'd be curious to hear more. I don't use express, but I have a hard time imagining a scenario where routing would be the bottleneck (especially in what's effectively the default URL router for Node).
Cool! Thanks
They used a node module that used to be called node-webkit at the time http://nwjs.io/
&gt; I'd prefere not to have to code the UI for each platform! I have never built a mobile app. But don't all the mobile operating systems have different guidelines regarding design and interaction? Doesn't that mean you'd have to build one for each platform anyway? Or at least a version of it?
We're using Traceur to transpile ES6 for a large project at work and it's going really well. The new ES6 syntax is great and you miss it once you have to go back to ES5 syntax for some things. For people wondering about debugging, it's still really easy to debug the transpiled code, there is some extra stuff around your code usually but nothing that makes it hard to figure out what's going on. I'm constantly using the debugger in Chrome with no issues. I think it's really valuable to learn ES6 and use it in any greenfield projects because it's the future of JS.
Something about the repetitive use of the phrase "Unix Tool" worries me.
I'm a FreeBSD nut. We &lt;3 Unix.
Yes, and only iOS is supported at the moment. You have to anyway, because of os specificities.
Talking about array methods and not mentioning `lodash`? 
Angular Mobile: http://mobileangularui.com/
I saw an awesome session by Mathias Buus Madsen at JSConf EU last year on how they did the streaming of torrents with Node, valled 'Javascript... Torrents... and Mad Science!'. Not really an answer on how they did the Window app, but still pretty cool :). You might want to check it out at https://www.youtube.com/watch?v=BTCsSwCpGP8
Best way to learn Javascript is to read code - https://github.com/mozilla/BrowserQuest
Some frameworks offer widgets that translate to native components... So you use, let's say a single "FooToolbar", and what is generated at the end is different and native for each platform. But I have never built a mobile app either, and I'm not sure if this "single widget to native widgets" approach is the best one. Maybe the best solution is the Xamarin (without Xamarin.Forms) / React Native one, which seems to be to share the business logic, but code one UI for each platform. In fact, this is one of my main question : what will be the "winning" mobile development methods? Which ones are the more future proof? I know it's really hard to guess right now, but I'm sure there are developers out there, with experience in the mobile world, who may have a good intuition/feeling about this.
Well last time I checked `browser-sync`, it didn't work. And even now I can see the still open issue dated Aug 6, 2014: https://github.com/BrowserSync/browser-sync/issues/217 Which raises the question how serious your problems with it could be, and how long it would take to be resolved... A valid choice (if you can easily use it that is) but with 25MB of code to download for `browser-sync`, simpler alternatives (with only 7BM of node modules in total) can also be interesting. It might be more powerful but sometimes you just want a simple thing that does what you need. - Why Gulp? Because it is more established, supported by broader community, and has more customisation power. 
I guess this is too specific for a general _tutorial_, that's why you can't find it. Here's some stuff that you may find interesting: - [Browser Quest](http://browserquest.mozilla.org/) has its [code on Github](https://github.com/mozilla/BrowserQuest) and while ther isn't much explanation around, the code is "easy enough" to understand that at least a couple of forks have been created. Note that it's very _light_ in the RPG side of things... more like an action-JRPG sort of thing. - [RPG.js](http://rpgjs.com/) is an engine. It has tutorials... for its own engine, naturally. This is where you'll find most stuff: it's more common to find a particular (J)RPG engine and then tutorials on it, than generic tutorials on how to make your own engine. [This one](http://www.binpress.com/tutorial/create-a-mobile-rpg-for-beginners/1) uses LimeJS, for example. - Another way you can go, is simply look for tutorials on creating RPGs, without the "JavaScript part". Like [this one](http://gamedevelopment.tutsplus.com/articles/how-to-build-a-jrpg-a-primer-for-game-developers--gamedev-6676), for example, and simply translate the ideas. The ideas will be mostly similar. - Finally, a while ago, there was [this](http://www.reddit.com/comments/2dcaxz/_/) on this same subreddit. Read the comments there to see how things stand, but also follow /u/robobeau's links to read his experience. It might be interesting.
So I have downloaded and tried it again and ... as before ... it doesn't reload the page. Need I say more? :) Have you made it work for you?
→ npm install 80cents npm WARN package.json http@0.0.0 http is also the name of a node core module. npm WARN package.json http@0.0.0 No description npm WARN package.json http@0.0.0 No repository field. npm WARN package.json http@0.0.0 No README data Not so good :(
Spot on! Exactly how Angular source code is done.
I have much respect for people who have to work with JS in the EE-world with a programming language that lacks any kind of structure. Modularity is a huge problem in general and I hope we will see a lot more use of standard ES6 modules in the future. In general, I hear a lot of people talk about reusable modules but very few seem to actually reuse them in practice, unless reusing them is at such a convenient level as e.g. NPM. Especially in the front-end, it simply becomes too much of a hassle to implement a component from one system in another, since quite often you don't need the exact same thing. Considering how fast it is to create components in Angular/React/etc, it's often easier to just write another "reusable component" that will only be used once. I think convenience is king when it comes to getting people to reuse components in practice and it seems like this is also the focus of the article. On a side note: as someone who also deals with financial data and transactions, it makes me cringe to see MongoDB in the stack. Financial data is one of the things you simply *must not mess up under any circumstances*. MongoDB is quite convenient and easy to use but it comes at the cost of being far from ACID compliant, not supporting transactions, storing the data in memory before *actually inserting* and back in the days even *defaulting to silent insert failures*. I love MongoDB but financial data is one of the few use cases where it absolutely does not fit in my opinion. Now, I don't know about this specific implementation and of course you might have the safeguards needed to deal with these problems but I really think people should think twice before using MongoDB for something like this. 
FreeBSD is Unix-like not Unix.
I'm fine thanks.
Thank you... I wasn't expecting a full answer... just a few pointers. 
Similar to PhantomJS? http://phantomjs.org/
If a linter can spot it, it's not a real issue. Also, if you use `let` and declare your variables on first use, those problems pretty much disappear automatically anyways. Having that many declarations in one spot is caused by function-scope-specific conventions.
I agree. I think the only downsides to using multiple `vars` are additional typing, and a larger file size. The latter is immediately countered by using a minifier, which will reduce the declarations into a single statement. To the former, I say stop whinging. You think you're saving time by writing less, but you'll spend an equivalent amount of time fixing errant commas.
[Inkscape](https://inkscape.org/en/) can save drawings as HTML files, containing javascript to draw your shapes on the canvas. This maybe useful to you. **edit** 'grammared' it up more.
A linter is a life saver I agree, although it may or may not catch my favourite single var blunder: semicolon-instead-of-a comma-in-the-middle-of-the-list bug. Coding with `let` and `const` is great and the era of `var` is drawing to a close, at least for me anyway. 
&gt; [A linter] may or may not catch my favourite single var blunder: semicolon-instead-of-a comma-in-the-middle-of-the-list bug. With JSHint and this line: var a, b; c; Warning: * Expected an assignment or function call and instead saw an expression. One undefined variable: * c Two unused variables: * a * b So... yea, you should see some squiggly lines in your editor. :)
I don't know if its because of chrome, but I found out the picture you are using cannot be downsized by the canvas (canvas must be exact or higher dimensions). Or else it will be a plain white canvas 
Mmm... I don't see any _resizing_ in your code. Anyway, [this](http://i.imgur.com/Uw9120G.png) is a capture of the fiddle's result in Chrome. The image is bigger than the canvas. It shows ok, no problem. I'm not sure I understand what your problem is, but that code you posted is doing what it is supposed to.
Books are pretty challenging to write. It can take a long time and when targeting content in the tech industry, your content can become out of date very quickly. I've helped edit a few tech books, and It's always a time consuming process to make sure everything works and is right. But it's also something you're constantly doing as the book is being written, and it's easy for edits to be made without you knowing introducing bugs or errors into examples and sample code. You're often working with other people who are also reviewing the author's work and who knows what suggestions are going in and how. It's easy to mess up. And the closer you get to time of release the less enthusiasm you have to double and triple check things because after reading the same thing over again so many times you start to get burnt out a bit. You get this feeling that you've already spent this much time on it, it's got to be right now, right? This assuming you even have the time for it. And who knows how much help this author had. If there are a lot of errors probably not too much, or there was just not enough time to do a thorough review. Why bother if the book will be out of date or replaced by the next best thing in 3 months?
&gt; You have to piece meal it all together. Yes. Despite this, the author of that damn article I can't find thought it was a better solution with cleaner, leaner, easier to maintain code. He found it had better performance too. Plus he felt the code base of those two were more 'stable' than other options. And of course, he (and I) could be totally wrong on this. In theory it makes sense, but... I don't have any practical, real-world, substantial projects to compare.
Since you support onhashchange (IE8 compatible), why not list that as a feature? (silly as that sounds, there are still several devs, me included, that have to support IE8 -- healthcare/wellness, financial, etc). You may want to start testing in it too, since you already test down to IE9. Just a suggestion. Thanks for the lib, will be trying it out along with others for inclusion in our stack.
i'd submit you add ampersandjs to that list. it's quite flexible in being able to mix/match the various responsibilities/layers with near any lib you want.
&gt; gem install ..... nope.
Looks neat. A bit of feedback. Only supports img tags, would be nice if it supported any element with background-image as well. Seems to loop through every image on the page 60 times per second and doesn't optimize well for images that a) don't have the data attribute or b) were already loaded. In either of these cases, it should be trivial enough to remove them from the list. I'm not sure how much of a benefit having a 'live' list is for most people. Maybe you already tuned for performance and decided against it. Getting a weird sense of deja vu from this. (Found out why: https://www.reddit.com/r/javascript/comments/333xka/a_new_lazy_load_to_improve_your_website/)
Bind!
Why did you commit even the node_modules folder?
A collection of possible solutions can be found here: https://gist.github.com/branneman/8048520
If I disable JavaScript, it doesn't show any images. Like every other lazy image loading, you script is far too lazy. It's like those website that start with &lt;body style="display:none"&gt; and only show it with JavaScript enabled. Pointless.
I would be interested if there is a way to use *any* lazy loader without js. It is my understanding that if you have an img src set to an image the browser will fetch the file and no amount of coding can prevent this. Therefore lazy load scripts get around this by adding the src destination at runtime. I have been looking for a while for a way to implement something like this with a no-js fallback, but I dont think its possible
This is a real annoyance when using Gulp or Grunt, since it slows down simple tasks which are part of a file with many dependencies. Since all the dependencies have to be loaded before the task can start you really notice how long it takes node to get started. 
Instead of doing the removal + scroll position hacking, maybe you can just replace the removed elements with empty placeholders which take up the same space as the elements they replaced? That way you wouldn't have to hack the scroll position at all. I haven't tried this, but I expect it would work...
Welcome to 2015. Don't want to run Javascript? That is perfectly fine. However, until a new standardized language comes out with widespread support, complaints like yours are akin to people complaining their car doesn't start without an engine.
This would be really nice as a custom element: `&lt;lazy-img src="foo.jpg"&gt;`
This is true, and very possibly worth doing. But it's worth baring in mind this will only work for browsers that have JS explicitly turned off, but these days the majority of cases where JS doesn't load is due to network errors. 
Okay yea, well :D. Do you think a "bit of JS" is enough knowledge? I don't want to invest a couple of years to realize this xD.
There are some pretty deep problems in your `runSort` function. It looks like you're trying to do something very fishy: var sortCells = new Array(); for (var i = 0; i &lt; sortTable.rows.length - 2; i++) { var sortCell = sortTable.rows[i].cells[sortIndex]; var celltxt = sortCell.textContent; var regx = /(\,|\$)/g; celltxt.replace(regx, ""); addProps(sortCells[i], celltxt, sortTable.rows[i]); sortCells.push(i); } Where, `addProps` is: function addProps(object, text, tableRow) { object = { value: text, row: tableRow } return object; } This will most certainly not work. You: 1. create an _empty_ `sortCells` array 2. for each `sortTable.rows` get the content of a certain cell 3. try to call `addProps` with `sortCells[i]`, which is `null` 4. in `addProps` try to assign a new object to ahem `object` 5. finally, you push into `sortCells` the index `i` for some reason, so you basically are just generating an array `[0, 1, 2, ...]` and nothing more. Now, it looks like you're trying to use `sortCells[i]` as if it was some kind of reference and pass it to a function to fill the position in the array pointed to by that reference. But, first, there is no reference. You have only created an _empty_ array: `var sortCells = new Array();`. Trying to get `sortCells[i]` will get you the value at that index, which will be `null` because the array is empty. Now, you could think that you might actually go and initialize that array position first, something like... for (var i = 0; i &lt; sortTable.rows.length - 2; i++) { var sortCell = sortTable.rows[i].cells[sortIndex]; // etc sortCells[i] = {}; addProps(sortCells[i], celltxt, sortTable.rows[i]); } But that still wouldn't solve your problem. Why? Because `sortCells[i]` will never get you a reference you can pass to `addProps`. `sortCells[i]` will actually get you a reference to the object `{}` at that position, but not "the i-th position of the array". So, when inside `addProps` you try to assign a new object to `object` you're _not_ assigning it to `sortCells[i]`. Try this in your console: var a = [{b:1}, {b:2}, {b:3}, {b:4}]; function assign(o) { o = { c: 7}; } assign(a[2]); console.log(a); `a` remains unchanged and `a[2]` is still `{b:3}`. Anyway, as `addProps` doesn't seem to be used anywhere else, what you should do is inline that operation. Alternatively, you could change that to something like: function addProps(arr, index, text, tableRow) { arr[index] = { value: text, row: tableRow }; } But it looks like a particularly unnecessary thing to do. At least in this case: var sortCells = new Array(); for (var i = 0; i &lt; sortTable.rows.length - 2; i++) { var sortCell = sortTable.rows[i].cells[sortIndex]; var celltxt = sortCell.textContent; var regx = /(\,|\$)/g; celltxt.replace(regx, ""); sortCells[i] = { value: celltxt, row: sortTable.rows[i]}; } Now, with all this, you will get your sorted `sortCells` but still, as you pointed out, the final loop is not adding the rows in the correct place. What you want to do is `sortBody.appendChild(sortCells[i].row);`. Now, the order is always done numerically because `sortType` is a `&lt;col&gt;` DOM element and `sortCol.asort`is always `undefined`. `sortCol.asort` is always `undefined` because you're not setting that anywhere. So I guess what you wanted to do is something along the lines of `if (sortType.className == 'asort')`. Now, if you try, you will notice something _funny_ with the headers. You're actually including those in the `sortCells` array, so they'll jump around just like any other row when you order alphanumerically. You need to _not_ include that row in the order and always keep it first. Also, the Ascending/Descending selection is not working. I'll leave these easier problems to you, ok? Ah, yes, [this JSFiddle](http://jsfiddle.net/xv73mvfy/) is the current status (plus maybe some `console.log` here or there). You may make it easier to ask for this kind of help with a working example, better than a static, non-runnable gist.
I'm not sure I really get your question. Can you elaborate, and give us some context?
 &lt;a href="#"&gt;&lt;input type="text" value="foo" /&gt;&lt;input type="text" value="bar" /&gt;&lt;/a&gt; ? Not great markup, could be misinterpreted by one browser or another, or have some quirks blocking proper use. A click event on some block element rather than an anchor tag might suit better, or a delegated event on the parents. 
when a promise is resolved, def.resolve('kittens') it's callbacks are sent that paramater(s). So, def.done(function(param) { //param is kittens })
I don't use abstractions to be faster than raw DOM calls. I use abstractions to write code that is less fragile, i.e. easier to change without breaking it. That's almost always far more important. Sure, if I ever hit a situation where my abstraction isn't "fast enough", and that one piece happens to be very stable so I'm unlikely to need to change it, I'll rewrite that one piece to bypass the framework. But that basically never happens.
JSFiddle just blew my mind. Thanks very much! And also obviously for all the explanation/suggestions. So far, I've changed the start value of i in the for loops which stopped the header rows from moving when the columns are sorted. Still trying to figure out exactly what I'll need to adjust in the setupTable() function that won't break the rest of the function but also makes sortHead a legit node much in the same way as the adjusted runSort function.
In a single hyper-specific use case you were able to optimize code to perform better than an abstraction. Abstractions are abstractions for a reason... On a side note, either I've missed some JS lessons, or this guy has a weird coding style, but I've never seen such a crazy use of function context in my life. https://github.com/WebReflection/dbmonster/blob/master/index.html map is invoked with a function as the context, which then returns a function, but also invokes the context function, and then updateInfo is invoked with the context being an array of functions...gah
could probably *gasp* split out different tasks into different files?
I think the correct answer is standard paging then. If a user is scrolling so many articles (DOM elements) that they are crashing the browser, then you have to ask yourself what benefit is the infinite scrolling really providing? What if I accidentaly hit the back button or lose my place somehow, how do I find the same article again? If a user is scrolling a lot, they probably aren't reading the entire articles, is it prudent to show the whole thing and not just a snippet that takes you to another page? I personally find it hard to believe that keeping empty divs that preserve the height of the article would cause any kind of memory issues or crashing until you reach 1000+ elements. Pages regularly have thousands of DOM elements. As for the links you cited: 1) They solved the issue in the thread, 2) 10mb memory limit should be more than enough for empty DOM elements, 3) same as 2)
Positive, the source is right here: https://github.com/WebReflection/dbmonster/blob/master/data.js It's craziness.
Wow, that is some bizarre code right there.
Yeah. I poked around after I commented, and made an edit. I don't even know what's going on. Part of me wants to figure out how that map craziness actually works, but most of me can't be arsed. I deal with enough nonsense at work.
I actually found Andrea's code quite fun. Convoluted? Sure. I wouldn't say weird, but certainly not straightforward. I'd say the code is playful and fun. Maybe even silly, but in a good, fun way. Leaving that aside, saying he's presenting a "single hyper-specific use case" is very unfair. What he is doing is replicating exactly the [example proposed by others for benchmarking](http://blog.nparashuram.com/2015/03/performance-comparison-on-javascript.html). Not only, but the only real limitation to the technique he presents is that only the content of DOM nodes really needs to be changed. No changes to the DOM structure itself are needed (if you don't want to). And this, also, comes from the proposed benchmark; it is not something he has chosen, just something he takes advantage of. In any case, I don't think he is arguing in favour of dumping all frameworks/abstractions and just using the DOM API directly. _Au contraire_. What he is pointing at is frameworks competing for mindless benchmarks and people who try to fanatically pretend this or that framework is better because it does this or that particular benchmark faster. I'd guess the whole point of the article is: &gt; Every framework was born to solve a very specific problem ... have you asked yourself if that is really the same problem you have and the one you need to solve? Or in other words: Use the right tool for each job.
I read that as a reaction to a lot of the more fanboy-ish React boosterism. I've seen tons of hyperventilating about the virtual DOM which is either comparing it to some dreadnaught-weight abstraction library or something like naive `innerHTML` rewriting in a loop. Once you compare it to something which avoid repeated unnecessary updates, the overhead of maintaining the virtual DOM and having to diff it becomes obvious. (This is not to say that React is bad but simply that the reason to use it is because it makes your code easier to maintain, not treating it like magic speed tape)
I would say the code is straight up bad. He/she is using function context instead of partial function application and local variables. Turns something that is really simple into something needlessly hard to follow. Not clever, playful, or fun in any way. It's also ironic to find so many comments in the code, and yet they all explain trivial aspects of it. // create the row tr = rootNode.appendChild(create('tr')), Where as this comically short, yet confusing function, probably shouldn't exist. // recycled function for all updates function updateInfo(info, i) { this[i](info); } All the comments in the world won't help your code when it's impossible to follow because 'this' is some undocumented, unnamed, magic variable that changes in every single function on a whim. I also understand how the benchmark is supposed to work. It's purpose is to compare abstractions against each other, to ensure that no abstraction is abnormally slow relative to another, and provides a good user experience. In this context the benchmark is definitely useful, the post itself tries to argue something nobody claimed.
 var tr = table.insertRow(); var td = tr.insertCell();
But that doesn't address the duplication, does it?
is there a way to use this library without refactoring all my HTML templates?
well, it doesn't if you consider having the same import in two different files "duplication". assuming you use something like make that calls/requires different files when the target is listed, should address the perf hit mentioned above.
I don't think anyone claimed that was "production-grade code" at all (but it's also not impossible to follow). 
Funnily enough, how I learn every new bit of code is by creating a character generator. Not sure why it helps, and it's probably just me, but for some reason the context makes it easier to understand syntax and structure. I suppose it's a given that I'm a huge nerd too. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**FreeBSD**](https://en.wikipedia.org/wiki/FreeBSD): [](#sfw) --- &gt;__FreeBSD__ is a [free](https://en.wikipedia.org/wiki/Free_software) [Unix-like](https://en.wikipedia.org/wiki/Unix-like) [operating system](https://en.wikipedia.org/wiki/Operating_system) descended from [Research Unix](https://en.wikipedia.org/wiki/Research_Unix) via the [Berkeley Software Distribution](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution) (BSD). Although for legal reasons FreeBSD cannot use the Unix [trademark](https://en.wikipedia.org/wiki/Trademark), it is a direct descendant of BSD, which was historically also called "BSD Unix" or "Berkeley Unix". The first version of FreeBSD was released in 1993, and today FreeBSD is the most widely used [open-source](https://en.wikipedia.org/wiki/Open_source_software) BSD distribution, accounting for more than three-quarters of all installed systems running open-source BSD derivatives. &gt;==== &gt;[**Image**](https://i.imgur.com/SaBfD3L.png) [^(i)](https://commons.wikimedia.org/wiki/File:FreeBSD_10_Bootloader.png) --- ^Interesting: [^FreeBSD ^Foundation](https://en.wikipedia.org/wiki/FreeBSD_Foundation) ^| [^FreeBSD ^Ports](https://en.wikipedia.org/wiki/FreeBSD_Ports) ^| [^FreeBSD ^Documentation ^License](https://en.wikipedia.org/wiki/FreeBSD_Documentation_License) ^| [^FreeBSD ^jail](https://en.wikipedia.org/wiki/FreeBSD_jail) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqj0smx) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqj0smx)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I'm so sick of the no script snobs running their mouths. GUESS WHAT---I DISREGARD YOU GUYS LIKE I DISREGARD INTERNET EXPLORER 8 AND THE SPANISH LANGUAGE (there are actually more people in need of Spanish support than ie8 support)
I would use promises for this. I think that promises give better encapsulation and testability. For example, with promises you don't need to create a mock event bus for testing; and task functions do not need to specialized for a specific slot in a task chain. For a general solution for running promise-based tasks in series, you can use `promise-series` or something similar. Edited to fix a typo.
That article is 3 years old and out of date. As of jQuery 1.8, deferred.then returns a new promise. http://api.jquery.com/deferred.then/ If you're already using jQuery in your project, you may as well use their promise library, if not, I'd suggest checking out Q. 
Well it's two somewhat different schools of thought. There are some who avoid promises like the plague and only get forced into using them. Personally I think that a promise based design pattern is superior to pub/sub. To give a specific answer, anything that is asynchronous you can easily use promises and probably should use promises. For instance, bootstrapping an application upon reload, I use promises to make sure that everything is bootstrapped before the user can interact with the page. 
Yep for sure. Otherwise if you want you could specifically create a new promise to use instead of depending on the one $.Deferred chain creates. 
also building enterprise spas... dom is not slow. name your tools?
Throwing errors inside jQuery promise chains are dodgy and apparently on their way to being fixed, but depending on what your doing, they're still a viable promise option. And who doesn't love wondering why their errors aren't being caught anyway? 
Yeah I got it figured out, ended up using a Js Library called SoundManager2 to create the sounds and then used jQuery to trigger. Thank you!
&gt; ...seems kind of crazy to be wrapping all optional objects with an array... Agreed. &gt; ...seems like you would want to be able to differentiate an empty array, which could indicate that the data has been configured but there is zero data, and null, which could indicate that things have just not been setup yet... Agreed. I would strongly object to using an array to store a single item in any code I remotely cared about. It is much less intuitive, and using an empty array still doesn't completely avoid the need to check for nulls. In your example, even if you intend for 'latestCustomer' to be set to an empty array when there's no data, relying on it never being null increases the likelihood of errors caused by null values in the future. Besides that, checking for null seems much simpler to understand and maintain that using a forEach loop to access a single property just because it could be null.
DOM isn't slow. Share some code or example cases?
Recruiters are never in the know. I've learned to live with that. 
I honestly didn't read the article, and by the comments in the thread, there seems to be confusion among people who think the DOM === Javascript. ok. Javascript = extremely fast. Most people would be incredibly surprised at how fast it is. the DOM = an old outdated way for browsers to interpret nodes from HTML markup. Basically...we should not still be require to use it. Side note: The reason browsers/companies do not want anything else besides the DOM to be used...security, and the ability to mirror native apps..which directly competes with their app stores that they get a cut of. Our front end consists of React js for all views, our own implementation of flux for our data layer, sass, everything is using a websocket, so realtime.. server side rendering with schema and meta data injected, literally, every possible way to get the quickest possible speed. We were never able to beat or even replicate the speed using 100% native JS without some use of a 'virtual DOM'...basically...it only updates the nodes that need it and does it in batches...which is the most important part. We've created editable budgets/chart of accounts with often times more than 3-5k rows with sometimes even 10 columns...we've tried doing it native, it was a disaster. With React/flux/etc. we have it going incredibly fast....but it is still not native....know why? the DOM. It is the single, one hold back of the whole f'ing web. Wait....I jsut checked css....it still sucks, so the DOM is not alone. 
Thanks for this. I checked with strace and am pretty sure based on the timestamps for the stat64/open calls that a large number of incorrect files are being opened in turn, and this is making `require` unnecessarily slow. There's not much to be done about the need to have V8 allocate memory for everything loaded by the app models. I suggested an optimization to `require` that should help speed up the load time for everyone.
&gt; 700 milliseconds to require a model file, and that file's dependencies If those dependencies have synchronous side effects, that would contribute to the total time.
&gt; Even if you intend for 'latestCustomer' to be set to an empty array when there's no data, relying on it never being null increases the likelihood of errors caused by null values in the future. Although, it would be possible for the value to still be null, in that situation, it would be a problem with the API, not the Javascript. The benefit I see in working with arrays, is that you can make the assumption that you will always be working with arrays (provided the API is working correctly), and eliminate accidental "cannot read property 'x' of null". Before you get to that point, the implementer will be forced to iterate, which will mean either 1) nothing is iterated or 2) one or more is iterated. I can't just can't help thinking, "Why not"? In the null/object situation, you have a set of two possibilities that you have to take into account. In a numeric context, null would mean you have nothing, and object would mean you have one thing... And I think to myself... You have 0 or 1 things... why not represent that with an array? You can capture the idea of nothing, as well as a single object (as well as more if you need to), and then handle both with the same control structure like forEach, reduce, some, etc... But with null/object you have to do an if/else branching structure - Which is fine, but it seems to me like it lends itself to more accidental errors. As a side note, in the context of Angularjs, it also simplifies templating based on the data, because you do an ng-repeat on the array - if it's empty, nothing will show - if there is something there, then it will show. &lt;span ng-repeat="customer in customers"&gt;{{customer.name}}&lt;/span&gt; But I guess that's beside the point. That's more of a tangential benefit - I wouldn't advocate designing APIs a certain way so you can use some particular framework or library. I guess it's more intuitive for me to work with the idea of sets, as opposed to the idea of two states that need to be handled with if/else.
The DOM is slow when you need to use synchronous layout. I know this is a no no, particularly because it is slow, but sometimes it is necessary (or at least, I am not clever enough to think of another way). A current use case I have is that I need to add some text to a pretty long page and then scroll the page so that it is in view. I'm using getBoundingRect to find where to scroll to. This call alone often takes 5 to 10 ms. If there is a better way, I'd love to be proven wrong.
That is a pretty weak example. React always creates and destroys nodes, which is very heavy, even when it is more convenient slap a display:none on them.
I got a recruiter email recently about "creating the legacy code". They really do say the darndest things. 
There are two in my town that I'm willing to talk to. Good forbid they ever move or retire.
Yet, it is faster than manipulating the DOM in any other way for many changes. Also, it is not a matter of just showing and hiding in a SPA. There can be ALOT of things going on... also, the declarative nature of React is a bigger reason on why to use it, but that's another discussion outside of this thread...which still makes no sense to me...anybody who has made a REAL spa that needs many features and fluidness will tell you...the DOM. is. slow. there is no arguing, no abstraction that these people are doing to make it slow, it just is. period. end of discussion. There literally isn't any argument, in an complicated spa, for which you could make that the DOM is fast.... also..achen2345, that is wrong, are you familiar with document.fragment...or even if you built a large block of html and just set it inside with innerHTML..it is not heavy, in fact is is the best possible way for DOM efficiency. I promise you, if you built a dynamic page..no wait, I challenge you, build something that needs to be dynamic using your...'display: none's and fast DOm methods...' and I will build the same thing, and at the very least double your performance, more than likely it will be a factor of 6 or 7. And yes, the test should be something along the lines a li that does something that we will repeat 1,000 times, then 10,000 times, then 100,000 rows. You will see how badly your methods will lose. trust me...myself and many many other people have tried EVERYTHING. the DOM is the DOM and it's shit. 
That sounds like an epic worthy quest.
document.getElementById("red") returns a dom element, which is a truthy value. Therefore the first code block is executed. Try this instead, function colorFunction(color) { document.getElementById('test').style.color = color; } &lt;button id="red" style="background-color:red" type="button" onclick="colorFunction('red')"&gt;&lt;font color="white"&gt;Red Text&lt;/font&gt;&lt;/button&gt; Edit: autocorrect can't code
Technically, I do create the legacy code -- for the next guy.
Yea, I'm pretty sure I've used that jquery plugin before
Okay so lets try to go through this one step of a time. The way it is now, you call the colorFunction. The first if statement finds the element with the id 'red', and if it exists sets the color of the 'test' element, the important bit here is that it does this if the 'red' element exists. I can only assume that what you actually want is to do something based on what element was clicked. To determine this you can pass the element that was clicked as a parameter by changing the onclick parameter to 'colorFunction(this);', in this case 'this' refers to the element, you can then in the 'colorFunction' for example check if the id attribute of the first parameter matches 'red'.
It will never get updated, it will never be maintained. ##legacy: a djvirgen production...
[@recruiterbro!](https://twitter.com/recruiterbro) from real live recrutier emails.