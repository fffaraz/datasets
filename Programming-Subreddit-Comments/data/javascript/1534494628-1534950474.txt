I'll only add one thing to the discussion. If you feel the repos you have on github don't represent your skill, you can do a number of things. You can simply remove them, store them elsewhere, maybe on a different account or service or just locally. You can spend a bit of time, not a lot, just a little, on one or two of them; clean up the worse parts, write a nice readme, maybe some tests... It shouldn't take much and you can give it a much better _appearance_. You then pin those, one or two, to make them visible on your profile before the rest. If you don't want to spend time on some repo, don't want it to look bad, but also don't want to move it somewhere else, you should at least add a small readme with a visible warning as first thing explaining the project status (it can even be something as simple as saying that this is just an experiment / exercise / abandoned idea / whatever; you don't need much). *tl;dr*: you can at least *say* some old, unfinished code is just that, and that you're aware of its status.
You can build perfectly good projects without version control. Writing good code has absolutely zero links with version control. VC has existed since the early 1980's, but not all of the systems have been good. Before SVN, branching wasn't accepted. A common method of VC, if you want to call it that, was adding increasing numbers to the end of the filenames (e.g. myfile.ext.001, myfile.ext.002, etc). Networking wasn't available for many generations and sharing disks with code on was common. Mention VSS and someone will probably say "Welcome to Hell". Does that mean that the code written in those times was bad? Absolutely not. Many of them are foundational projects that have powered the innovation we see today. "But it's 2018", you might argue. Again, I strongly recommend version control, and in every company worth it's contracts and the people that work for it, VC will be enforced with no way around it since deployments are often handled from the code on a repo. Personal projects, there's often a lot less riding on them and as you may be the only developer on it, sometimes even using github purely as file hosting (i.e. no branching, just committing straight to master) might not be worth it especially for really small projects.
I can still see numbers of commits on private repos (but not the name of the repo), but it could the people I'm viewing having it configured to show those. My own profile shows that even when I'm not logged in.
Looks very clean. :) But: &gt; "scripts": { "build": "./node_modules/.bin/webpack", "watch": "./node_modules/.bin/webpack -w" } Why not just "scripts": { "build": "webpack", "watch": "webpack -w" },
Should be as simple as swapping out `ts-loader` with `babel-loader` and removing all the TypeScript specific stuff. You need to transpile anyways if you want to use JSX.
They don’t think it be like it is but it do.
Most ISPs use dynamic, changing, IP addresses because that is easier/cheaper for them to manage. They fetch them out of a pool. Here are some things to look for: * request a static IP (most ISPs won't facilitate) * set up a dynamic dns service * use a cheap VPS with a dedicated IP address * use something like ngrok for localhost tunneling 
You're right. It's mostly just outlining features with no actual opinion on them
Why would you answer that if you are interviewing for an Angular position?
This is probably too specific to my area/country and perwonal situation, but lately interviews don't seem to go too well. Or... no, they do go well; they just don't produce an interesting offer (or one at all). I've been interviewing for some senior positions but I'm interested in technical or mostly technical positions. Maybe a leading or expert role, but clearly not a managerial role. Anyway... The interviews are pretty common, the usual stuff. Some things I've noticed is too frequently is thet even though it's supposedly for a senior position, they ask stuff that's too basic, which explains why, when they notice, they end up telling me I would get bored easily in that position and so they discard me. Too many ask for too much in the ad and then it turns out they only need someone with maybe a couple of years experience and some specific knowledge. Other times it ends more abruptly when they realize my age. Not that I'm _old_, but well, you know this start-up mentality where everyone must be super-young and being older than the boss makes them feel weird or something. Or maybe they just think that I'm going to ask for too much compensation or whatever. “We feel like you wouldn't fit with our culture”, or some similar comment. Other times it's me thinking that a platform for farts as a service or tinder for squirrels or a generic ad/tracking/analytics blockchain based/big data/machine learning buzzword filled but common-sense emptied idea is not something I want to be involved in. Oh... But anyway, you're asking about the technical part of the interview and not my boring ramblings xD That's actually pretty standard. It hasn't changed that much. General programming questions. Possibly related to software design or architecture. A couple of more specific things about JavaScript or sometimes about some particular pattern or approach or problem. Typical things; `this`, promises, prototypes, “functional programming” if they are fancy guys, maybe some stuff on something new on ES6+. Stuff about testing, though it rarely goes beyond asking if I do it and some very general questions. Questions on specific tools/libraries/frameworks are not always present but they are not rare either. They, at least, ask if you know X or have worked with Y, and sometimes ask about some fairly typical amd known shortcoming or common problem on Z and how it's solved. For more specific things, they usually resort to some coding exercise (which I personally limit to a hard maximum of two hours, much less if possible). All in all, senior position interviews don't usually need _very_ hard technical questions. Mostly it's about “talking the talk” but being able to convey that you can indeed “walk the walk”. In some sense this _looks_ easier but is actually harder, because it's (usually) more difficult to bs your way through. If you don't have it, _it shows_. On the other hand, when they do ask hard technical questions it's generally a good sign. Because it tells you they either _have_ interesting problems to be solved, which is good, or they don't but think they do, which is bad.
That’s a different story - there was no mention about angular position interview.
I download it this morning, and I can say this is a great, and useful extension. It will definitely replace GitHunt in my daily usages.
let me try once again :P ``` const portfolio = JSON.parse(localStorage.getItem('myPortfolio')); const newPortfolio = [...(portfolio || []).filter(coin =&gt; coin.coinName !== newCoin.coinName), newCoin]; localStorage.setItem('myPortfolio', JSON.stringify(portfolio)); ````
Are you able to come with a case where it helps having a useful code better (for example more readable) ?
You can definitely know how to code in 3 months. I have seen it numerous times with my own eyes. What you can't do in three months is becoming a software engineer, which is where you analogy works. So we do agree in some sense.
hum im not getting that... maybe not
&gt; Why? a) we neither have the time nor desire to write and support our own framework b) most of our programmers aren't senior devs so we want to provide them with a relatively safe, relatively simple, relatively foolproof well proven framework c) we want our actual senior devs to be busy doing other things rather than worrying about re-inventing the framework/wheel.
Noop. &gt; Due to the limitations of ES5, Proxies cannot be transpiled or polyfilled. See support in various JavaScript engines. https://old.babeljs.io/learn-es2015/#proxies
Can you define “product interview”? I’m not familiar with that. 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set have a look at the usages
I agree with the other fella. These are not tips, and they are definitely not pro tips. It is good clickbait though.
``` cars.discount = 20 cars.discount //20 cars.d //20 ```
If you have a thorough understanding of the fundamentals, what would you expect a teacher to help you with? I think you need to give incredibly clear goals here if you want any bites, not mentioning how I agree with /u/jetsamrover in terms of the price and quality. So I just read that you want help with: * Complex functions * app development * react * API's especially * utilization of libraries beyond my scope. I'll give you my advice for free: * Never make complex functions, they are hard to write, test, and maintain. If you have a function over 5 lines, it's probably too complex. Find smaller units of work for a function to do. * I'm guessing app development could mean how to use node/npm, OR webpack/parcel/gulp/etc., or some modern fancy framework. You'll need to be way more specific on what you want information on. * React is just javascript with sugar. Check out [https://reactjs.org/docs/react-without-jsx.html](https://reactjs.org/docs/react-without-jsx.html) before any other tutorials. jsx looks all fancy with it's tags, and maybe even looks easier, but it's more complicated to set up, and not an essential thing. * apis....are you asking how to request data in an app? Sounds like you want to learn about [fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) or some library like [axios](https://github.com/axios/axios). * what are libraries beyond your scope? Every javascript library is just javascript. Most good libraries add documentation. Now, go onto [meetup.com](https://meetup.com) and look for local tech meetups. Don't go around there asking someone to teach you javascript for $50, but instead, go there to learn and meet other developers. They'll be able to help you find good tutorials, resources, and may help you learn some new stuff.
I like the concept but "apple Music" : poo: 
Well... I'm from Russia and here we don't have Spotify... So, that's the only option for me
Maybe plain old YouTube? Lots of songs on it
Well, it doesn't have an API for audio playback and Apple MusicKit is far more advanced than YouTube Data API
I also feel portfolios and github repos are mostly appropriate for assessing junior devs, and there is a point at which looses basically all value. I just don't apply to senior roles that ask for them. I stick by that assessment even in the face of the hiring landscape which disproves it, because I know what a senior webdev is, and they, quite frankly, don't. Gimme a resume and 45 minutes to talk shop, and can tell the difference. If they cannot, that's a red flag.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Aren't we just meant to be using componentDidUpdate for this now? Surely the problem is having a lifecycle event for the new props, not being able to get the old props?
Don’t pay attention. Apple Music is a great service.
I never wanted the IT job in the first place, it was just easy to get because I know computers, networking, and programming. The interview process took all of about 2 seconds and I was hired. I've been programming since I was about 8 years old and that's pretty much the only thing I've ever wanted. I grew up in a poor family where college was never an option. Yes, I did one year with the FAFSA program, but my parents refused to help me with the second year because they saw it as THEIR credit being borrowed, not the opportunities I'd be able to do or the job I'd be able to get to pay it back. While I won't say it's impossible to find a software developer job without a degree, I can tell you it is extremely difficult unless you make a decent portfolio. I've just always been drawn to projects I can't exactly show to a recruiter. Hope that explains it well enough.
Hey look at that, it's a medium article which a picture of a macbook that takes up the entire screen. So original. Think different, people.
“I wish I had known to just use typescript” (Jk, but no jk)
I haven't gone through all the text below your post yet but I saw your response last night and it was clear enough that I wanted to try anyways. I've upvoted you because IT WORKS! :) Perfectly. So far at least, the way I'm trying to use it. So thank you kindly! That's not to discredit some of the improvements suggest below you. I'll have to check those out over the weekend. But if anyone else out there is looking for a solution to this kind of issue, I at least want it on record that this method works despite the downvotes. I'll make an update to this post after trying the improvements too. This was such great help folks, thanks everyone for chiming in!
OP here. I am actually very happy with Flow. It has some quirks but I really like that it's just a static type checker on top of JavaScript instead of a whole new language with a new compiler. I can still use Babel and other tools, and I am not locked in to a new ecosystem at all. I've heard that TypeScript can be quite slow but Flow is really fast for me too. I also think that Flow's type inference is much better than TypeScript's and so it requires a lot less manual annotating which is great for me. TypeScript also looks cool and it has some features that I'd like to see in Flow (e.e.g, variadic generic functions - https://github.com/facebook/flow/issues/1251). I'll definitely try it some day!
Thanks for the vote in confidence! I'm amazed at the downvotes when asking for an explaination! Haha. But yes, the replies are important when advancing in your development, but also unnecessary in some cases. Not every project needs to follow the guidelines and overcomplicate itself just so it fits the standard model, sometimes it's about making it work in the first place. Refactoring is a thing for a reason. Happy coding :)
There is a strong 'why?' in this example, with how you use x, that taints the question. If you had to do that, sure, then the brackets enable it. What you really want is a third variable.
I’ll try it out when Spotify api gets integrated. Nice idea though. 
Thanks for comment! :) Yes, you are right, we should use componentDidUpdate if we can. We shouldn't cache old props if we really don't need to do this. As I said in README file: &gt;Previous props are saved in component local state. Before using this lib, make sure your really want to. Maybe there is better way. Please read: &gt; &gt;[react blog - you probably dont need derived state](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html) &gt; &gt;[react blog - updating state based on props](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props) &gt; &gt;[react docs - getDerivedStateFromProps](https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops) &gt; &gt;[react blog - 16.4 bugfix for getDerivedStateFromProps](https://reactjs.org/blog/2018/05/23/react-v-16-4.html#bugfix-for-getderivedstatefromprops) My inspiration was: class EmailInput extends Component { state = { email: this.props.defaultEmail, prevPropsUserID: this.props.userID }; static getDerivedStateFromProps(props, state) { // Any time the current user changes, // Reset any parts of state that are tied to that user. // In this simple example, that's just the email. if (props.userID !== state.prevPropsUserID) { return { prevPropsUserID: props.userID, email: props.defaultEmail }; } return null; } // ... } source: [https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html) Right now I am working at old project that uses depricated componentWillReceiveProps a lot, and I am trying to remove all this depricated methotds. Sometimes when I can (when there are some simple sideeffects based on previous props), I move code to componentDidUpdate - this is easy. But sometimes, when we use previous props heavily, it is much simpler to save needed previous props in state, than making component fully controlled or fully uncontrolled with key (as sugested in [react blog - you probably dont need derived state](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html) article), because SomeComponent is used a lot in different use cases in whole project. Does it sound reasonably?
I'm from Russia and we don't have Spotify here, so I won't be able to integrate it. Sorry :(
It's a super set, not a new language.
Hi /u/GeorgeNetOSS, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Thanks for your understanding.
This is an excellent answer. &gt;For me senior devs are hires that don't need fundementals training and will be able to start being productive once they understand the "stack". And this an excellent quote! 
I read the article and found it to be clickbait. As I mentioned in another comment (that you down-voted): the author never mentioned vue, and only links to their own resources. The article doesn't invite conversation, it says "figure it out yourself".
I can’t imagine anyone actually genuinely upvoted this post either! I’d guess that OP has multiple accounts
I think most linting default settings warn against this which kind of speaks for itself. I'd lean towards bad practice and avoiding it unless you have a good reason to do it.
You can build projects without a VC. From a company hiring perspective, if you are anything but straight out of college no internships then not having any VC is a huge red flag as far as team development.
For capitalize (008), what about the following solution? const capitalize = (str) =&gt; str.split(' ').map(word =&gt; word[0].toUpperCase() + word.slice(1)).join(' ') 
PRs welcome!
&gt; TypeScript (as in actually writing TypeScript, not using ts-check) is very much a language, albeit a language without a runtime or interpreter which is rather sad. Why is it"sad" if a language doesn't have a runtime/interpreter?
Stephen Grider is (in my opinion) the best development teacher out there. The likes of Stephen, Wes Bos, and Max Shwarzmueller need to be supported by the community by purchasing their courses. This course from which you lifted all of the content ( [The Coding Interview Bootcamp: Algorithms + Data Structure](https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/learn/v4/overview) ) for 'your' repo is rarely more than $15. Support great educators by purchasing the courses and telling friends about them.
Read about REST API.
Makes me wonder how the check did they not notice such an issue with performance.
Any advice on how to do this or links? I'd like to be able to make customised snippets appear, such as a single keystroke for an immediately executed async function.
&gt; YAML is a superset of JSON TIL BRB changing all of our YAML configs to also be compliant with JSON. &gt;:)
Thanks for the heads up :)
It's sad because then it's not much more than a spec. Without a reference implementation at the least it's just so many symbols on the metaphorical page and the language is hampered in what it can do by the complete lack of control over the runtime environment. People don't realize this or talk about this enough, which leads newbies to static/stronger type systems to believe that their code is type safe just because tsc has stopped complaining. tsc doesn't emit any runtime type checks at all, so you *still* actually have to check that that supposed string is in fact a string if you really want to be safe, especially as a library author. And most of the language's features are stripped away in the compiling step, so you can never have things like reified generics. 
If there's a compiler then there's more than a spec. Also, if I write a library and people misuse it because they bypass/ignore the compiler that's on them, not me. This is true in C, Java, TS or any other statically typed language you can name.
Fascinating work! And definitely consider hosting the final contents on a GitHub Page so that people can see your code in action without downloading the repo.
Uh - that's really not how that works. In languages that actually have a runtime/interpreter/other reference implementation you can't just "bypass/ignore" the compiler or type system. C is a poor example because C has a notoriously weak type system, but in pretty much any language with a strong type system the developer doesn't actually have to implement runtime type checks like `if (typeof x === 'string')` or `if (foo instanceof Foo)` (unless you've been casting things), because unlike TypeScript the type system isn't erased at runtime (for varying values of "not erased" - Java for instance will erase type parameters from generic types but keep pretty much everything else, but C# and most other languages with generics don't). &gt; that's on them, not me Not only is this remarkably selfish (considering that not everybody writes TypeScript), in the first place literally nobody was passing blame.
Great write up! one more thing worth mentioning : Check out flow-typed repository and get available definitions for your dependencies. 
Also it isn't "remarkably selfish" to not dynamically check types in a statically typed language. That would be redundant and inefficient.
You should probably read up on the difference between static typing and strong typing, because you don't seem to have them entirely straight.
Enlighten me. What is "strong" typing?
I've had a few live tests where the interviewers were terrible - if you weren't starting off with the "best" solution, it wouldn't go well. The worst one for me was live code for parsing some git sha stuff, where the company flew me in cross country the morning of. I needed a few minutes to understand it and I'm going through the code just getting a feel for what exactly I was being asked to do... it just didn't go well. So your point of assessing skills live stands on that, I agree there. But, all of the take homes I've done went really well, and then in the in-person, there were still some live exercises but there was much less pressure, since it was more about thought process than actual code. I like giving interviewees take homes as well - it sometimes takes me a couple of hours mulling on something and refactoring and tests, etc... if I see that stuff from a take-home, that tells me more than only a live-fire exercise.
He told us in the article, they tested everything with a more powerful processor than their target user would have access too without thinking about it. 
The JVM doesn't run Java, it runs bytecode. The JVM knows literally nothing about Java the language. That's why Java had to be compiled to bytecode before it's run.
Does the JVM execute Java or bytecode?
That's another point - not every developer has professional/commercial experience. There's a lot of passionate people out there who either didn't want or couldn't afford to go to university (at £9000 per year in the UK, I can understand why) and who haven't been given the chance to move up to gain commercial experience. Plenty of passion is lost in businesses that don't connect with their employees properly. People who would otherwise modernize and even revolutionize their businesses tools if given the chance are overlooked. I proved what I could do to my previous employer. Instead of paying me the same as I was already earning and letting me do what I excel at, they chose not to benefit. The same applied to the 2 previous businesses I worked for as well. Finding ways of improving efficiency and actually providing a solution for those problems, I got overlooked for coding roles for 4 years because of "no commercial experience", despite the fact I'd actually built things that businesses found value in. As far as I know, some of those tools are still being used to this day. I got hired because not only did the recruiter really pitch me to the employer (and vice-versa), but because of what I showed I could do in a live-coding interview. All without any significant github repo's (i.e. a single repo with a single JS file containing 2 utility functions) and "no commercial experience". I've seen a few other recruits join us who also don't have knowledge levels that are typically expected for the projects we work on, but they've got the passion to learn and that fire to prove what they can do. **TLDR**: Passionate people may not have commercial experience, github or even more than a basic knowledge of one or more aspects of the job, but give them a break and you're less likely to find them jumping ship (not to mention they're probably not going to be upping their salary expectations because they know they lack commercial experience).
Why are JS interviews still about algorithms and data structures? Aren't these all things we'd just use wikipedia or stack overflow, as they're solved problems?
I spotted a typo, under 001 -reversestring reverse('apple') === 'leppa'; 
GraphQL
It's not about Java or bytecode, dear, which would be clear to you if you actually read the articles I linked or took two seconds to Google it yourself A runtime contains the implementation of the features of a language that are available at runtime, and has nothing to do with whether the program is source code, an intermediate representation, or machine code. At the very least this would include the execution model and any built-in functions/variables. Even C has [crt0](https://en.wikipedia.org/wiki/Crt0), which is inserted into every executable the typical C compiler produces. Managed languages like Java will also have things like the garbage collector as part of the runtime - in fact, the JVM is an application virtual machine, otherwise known as - you guessed it - a *managed runtime environment*. Look, there's no shame in not knowing a lot about programming language design or execution. Not everyone needs to know this stuff and most devs are very successful without having to ever think about them. But spouting incorrect info and then doubling down on it when you're clearly ignorant of the terms involved is a rather ugly look.
So it's sad that Typescript has to compile to JS before it can be run in Node or in the browser, but it *isn't* sad that Java has to be compiled to bytecode before it can be run on the JVM, and it also isn't sad that C must be compiled to assembly before it is run. Do I have that all correct?
They're a direct representation of ability to solve problems using logic and code. You can memorize familiarity with data structures, but you can't memorize the solution to every missing line or algorithm on the planet. Developing this skill translates invaluably to almost any aspect of programming, and it's this core ability which employers are most interested in.
But they also directly favor recent CS graduates. 
Lol you're _still_ not getting it even after I broke it down to you. It had nothing whatsoever to do with the compilation target (or even lack thereof - Ruby, Python and other languages whose reference implementations are interpreters all have runtimes). TypeScript does not have a runtime, which as I've explained to you is an implementation of a language's features that are available during execution - everything from the execution model to the garbage collector to fancier stuff like accessing the type parameter of a parameterized type and so on - and has 0, zilch and nada to do with the fact that it compiles to JS (on the contrary, Elm for instance which also compiles to JS _[has an actual runtime](https://elmprogramming.com/elm-runtime.html)_). Node itself _is a freaking runtime_ (by way of V8). How are you not understanding this? This is sad because it means that as it's currently used it's nothing more than JS and is just as weakly typed as JS since it depends on JS's runtime alone, which effectively cripples its type system (again, see the Swift vs TypeScript example I linked), when it can be so much more (again, see Elm).
TypeScript is only more difficult if you don't use webpack/rollup/browserify. There's very little difference between using flow or typescript from a tooling standpoint. If you use one of those tools, then just add the TS plugin and it runs before your existing set of plugins (I.e. Just before babel). The difference with flow is that flow you add a babel plugin instead of a built tool plugin. At my last company we even found that in 99% of cases, we didn't even need babel any more, as the TS compiler can target specific ES versions. The only thing one of our engineers wanted babel for was for polyfilling a few standard classes on IE11 (which typescript won't do), but considering it was a specific polyfill for a no longer updated browser, we just added a polyfill package.. --------- Typescript can be used a static typechecker as well. It's a superset of JavaScript. Which means you can change the extension to .ts and that's all you need (provided you don't have "no implicit any" turned on). Heck there's even an "allow js" option if you want to make it easier to migrate an existing code base. Based on your criticisms, to me it sounds like you haven't really looked into typescript or really tried it...
So is Typescript just a big waste of time; an is everyone who is using it just fooling themselves? Is Anders Hejlsberg just a con man?
You can literally just pass a JSON file to a YAML 1.2 and above standard parser and get completely valid output.
Thanks for letting us know. I'm downvoting this blatant theft.
That’s totally valid. IME the first round of technical screenings should be remote, though, and if they really expect you to optimize in your first attempt, that’s kind of crazy too.
But instead of quizzing on known problems and algorithms, they could come up with something that directly influences the job or directly tests skills they'd need.
I agree. Passionate people are a trait id list in my top 3 things I look for especially in UI devs. Id rather have the extremely passionate about his work and ux and results than the guy who knows the runtime of all datastructures majority of which wouldnt be used in the real world development of even modern SPAs. Especially since the latter guy tends to get stuck on algorithmic optimizations that make zero sense to practically worry about. Some roles might need that guy but 99% of jobs dont
This 100%. Built in support for VSCode is top notch, much more community packages/types, easier to find help for issues on SO. Am on a project using Flow atm, and we're in the middle of converting to TS because it runs so much smoother from our experience. The built in Flow packages for VSCode always seem to have problems for us too, and there are quite a bit of undocumented types.
&gt; If you don't implement runtime checks yourself TypeScript can't be anything more than a static type checker TS isn't supposed to be anything more than a static type checker. That's, you know, what it is. Do you think that isn't useful? It sounds like you think that isn't useful.
Absolutely agreed. When I was giving interviews full time, I would try to do both - first verify basic language familiarity, then a mix of algorithm and real-world questions that related to the position directly. I wouldn't usually bring in data structures unless it was to explore some specific potential gap after noticing a red flag (e.g. someone treats a function like an object, stop the show and look at their understanding of object assignment in the language). I guess I'm ok with it either way, though. It's easier to just study fundamentals and plan on learning after you get the offer than it is to study less universal areas which might change for every position.
I think the difference that filleduchaos is trying to get to is that Typescript doesn't add any code into the compiled javascript that assists with stronger typing at runtime, whereas Java et al - add this functionality into the bytecode and/or the runtime that parses the final code is type aware. If you use babel as an example - it adds in the regeneratorRuntime to handle async/await functionality, and then rewrites the code to use that runtime instead. It would be the equivalent of typescript wrapping all function calls and definitions that it couldn't determine statically, at runtime or catching/throwing exceptions, but it doesn't, its not meant to be a heavy runtime.
&gt; TS isn't supposed to be anything more than a static type checker Amazing how its website is served at typescriptlang.org, not typescripttypechecker.org &gt; Do you think that isn't useful? It sounds like you think that isn't useful. It's almost like, again, you should drop the silly victim complex and realize that you can point out something's shortcomings without categorically dismissing them as "not useful"
&gt; Built in support for VSCode is top notch This is the key argument. Flow is a truly excellent piece of software, and I prefer the Flow philosophy compared to TypeScript. It's a shame the IDE experience is so limited in comparison. If Facebook could spare more resources for the official VSCode/Atom plugins then it would become a very compelling prospect.
You need a web server to handle these types of requests. Apache will have no clue what to do with these (as far as I know). Do you have any experience with NodeJS at all? You would need to use something like that to manually process and handle these files.
&gt; [with Flow] I can still use Babel and other tools, and I am not locked in to a new ecosystem at all Babel v7 supports TypeScript (*). Previous version of Babel did not because nobody took the time to code it, not because TypeScript is flawed and Flow is not. If TypeScript is a new ecosystem, so is Flow. Generally speaking I think the confusion comes from the file names: .ts instead of .js =&gt; it's just a convention. It's like naming JSX files with .js instead of .jsx. Personally I prefer when it's explicit. (*) Demo app here: https://github.com/tkrotoff/MarvelHeroes
It's isn't a shortcoming when something doesn't do what it wasn't designed to do, *especially* when that was an explicit design decision, as it was in Typescript's case. So, feel free to fork tsc and have it insert run time type checks for everything. Let us know when you settle on a generic runtime behavior that covers all error cases gracefully.
I don't see how Flow's type inference is better nowadays. In the past, sure.
React Sticky Table - A component which beautifully implements tables seamlessly in React. [https://github.com/samrith-s/react-sticky-table](https://github.com/samrith-s/react-sticky-table)
And it's still completely my prerogative to think and still a completely valid opinion to hold that not having a runtime is a shortcoming in a language. At this point there's really nothing else to say. You probably still should look up what things like "runtime" actually mean before making bold assertions about them. Understanding how programming languages work tends to make for a better developer. 
I'm just want share some basic javascript function 
I'll get right on that!
I imagine some people will still be put off because the babel transform is not necessarily the reference implementation. There's always a chance that it might get less love than the standalone compiler, after all, and FWIW I imagine that if it had been the default from the start, far fewer teams would be using Flow. Once Babel 7 is out and major libraries / tools support it (there's issues with Storybook, for instance) I could definitely see myself being happy using TS with a very webpacky / babely project though.
You just joined Reddit today and you've made two posts, both of which are spam. Not a great way to start.
please guide me i'm new on reddit
Reddit isn't an advertising, self-promotion, or blogging platform. It's a community, and you should spend time observing the community standards before participating. Don't just come in and make posts to try to promote a blog, or article, or whatever you were trying to do.
Thanks for the guidance 
Tutoring can be quite valuable
https://code.visualstudio.com/docs/editor/userdefinedsnippets I use this for a lot of my scaffolding
This is a joke right, like https://github.com/marmelab/universal.css?utm_source=designernews
Not only are they spam, they also are of such immensely low quality and cover *elementary fundamentals* that under no circumstances justify a blog post. This material is way too basic, even at very beginner level.
if a recent CS grad can solve this stuff better than you, then you are less qualified than a CS grad
&gt; something that directly influences the job ...like knowledge of algorithms? i only looked at the first few, but they're all map/reduce/filter problems, just know basic functional programming
Like /u/elprophet mentioned, I believe TS preceded babel. Or at the very least TS preceded babel in its current form. Also having their own compiler grants them the power to make the fabled single build tool (which makes typescript easier to learn and adopt). For backend you can 100% just run a tsc over your code and then deploy it (that was our build chain at my last company for our lambda apis). Front end ofc needs bundling as well, but there's no reason typescript can't do that in the future. I don't see what you're saying about typescript being a language and flow not being one. From what I've seen of the flow docs; they are the same thing, just typescript is more feature rich. You can treat either as simple type annotations, or you can go ham and dig deep into either language's generic systems. If you haven't looked at typescript 3.0, I would highly recommend it. Specifically with that version they made the error messages very helpful. I introduced it at my last company on it and we spent the last 18 months using it, the code base now exceeds several hundred thousands of lines of code.
function statements are subject to hoisting while expressions are not. if (true) { ageFinder(); try { ageFind(); } catch(e) { console.error(e); } } function ageFinder(yearBirth){ return 2018 - yearBirth; } var ageFind = function (yearBirth) { return 2018 - yearBirth; }
Less qualified see solving the sieve of eratosthenes, sure. That's what happens when one person has encountered a problem and it's best solution more recently than you.
Beside the hoisting, in practice they are the same. Some people may prefer function expressions especially when using [ES6 arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions): `var ageFind = yearBirth =&gt; return 2018 - yearBirth;`.
As a bootcamp "grad" **AND** someone who works with a consultancy, I think your experience was far more indicative of consultancy than it was of bootcampers. I can go into why I believe that but I figure I'll spare you some long-winded and likely boring explanation of my experience with both. I'm a little torn as far as you seeming to write off individuals who entered the professional development world via bootcamp as well as bootcamps themselves. I've loved my professional life since getting into development and I think that would be true for many individuals who'd never previously considered programming a realistic option. Suffice to say, I love the notion that software development could dramatically improve someone's life, and of course bootcamps can -- when done right -- facilitate that. On the other hand, that "when done right" qualifier is a doozy in this case, as many people have mentioned on this post. I think even the better programs haven't quite figured it out yet and when they do, it's not sustained over time. I like to imagine that over the next few years we'll see more instances like Columbia University, where you have a respected academic institution with a refined approach to education getting into the bootcamp game. I think for the most part, though, if you're either hard working or really enjoy it, even a fairly shitty bootcamp experience is worthwhile.
It's only bad practice if the folks who are managing the same code base with you don't expect it, or the reason you're using it isn't obvious. So if you \*have\* to use it, be sure to leave your reasons why in a comment directly above it, and when you use it, use it consistently.
They are overpriced but often it proves to be worth it. I was tempted to say "most of the time" but I think that would maybe be a bit presumptuous to suggest. In my case it paid off significantly more than I'd hoped it would but both then and now the price seems on the verge of "hard to justify". I think most people who do them are like me in that we need a touch more than we can get online. The most badass developers I know are self taught and it doesn't surprise me at this point. I think I'm not a person that can simply be told how to do something and it sticks, I need to understand why something works or why we're choosing to do something the way we are, which is just to say I needed the opportunity to ask countless questions. All that in mind, I totally agree that if you're a person who can push through the frustrating and overwhelming parts, the resources accessible even for free on the web are incredible and will get you to where you need to be.
Whoa, let me slow you down in one place. I did one of those two, had a great experience, and have a had a ton of success since (that's all good and well -- not why I'm slowing you down). Regardless of whether or not it's in general worth it, given how expensive they are and how fantastic so many online materials are, when I was there their "relationships" were **wildly** overblown. In fact, I'd go as far as to say I didn't witness any business relationships, period. I'm sure someone got a job via a connection through the school and I just didn't see it, but I can't recall anyone even being recommended for a role through them. I've definitely advised friends since that as long as they're willing to immerse themselves in the development world afterward they can definitely go on to have a great time, but not to go in expecting the "career teams" in bootcamps to handle business for them.
I struggle to find a compelling reason why I would use flow over Typescript. 
I've had 5 friends go through Hack Reactor because they just needed something to pay their college loans. They all ended up falling in love with code :). Money is a good starting motivator, but its never the reason why people stay.
Oh I don't disagree at all. But people succeed all the time when they're willing to hustle and work towards something, I think what I was trying to get at was the notion that a lot of people, perhaps, feel that if they can sit through 3 months of code classes they'll immediately have a series of high paying jobs clamoring for them. PS - Love that all your friends became addicted lol I definitely push people feeling like there's a good chance that'll happen to them
I did. I stopped at the first typo in the first sentence of the first paragraph.
Access to hardware? Like, how do you interact with a scanner or sensor from a progressive web app?
Performance.
The point that he seems to be trying to make is that the JRE doesn't run Java code directly, but instead runs the compiled bytecode, and the browser, or node, runs the compiled code of TS. So if you count the JRE as the Java runtime, which you should, then TS also has a runtime, which is the browser or node. You're conflating the strength of the type system in the language with the concept of a runtime. If you use a TS library with TS, You have to follow the type system. Your example uses 'any' which is part of the type system. That this exists is a fair complaint but note that you can also cast things to incorrect types resulting in runtime errors in many other languages. The problem comes in when you use a compiled TS library from JS, but that's because you're intentionally stepping outside of the TS language. There's no parallel to that in Java
Lack of discovery from app stores, PWA technologies still take time to learn (I wouldn't say Service Workers were really easy to learn or felt comfortable to maintain), no spot on the smartphone home screen (user has to pin), smooth out of the box UI APIs, native integration (e.g., homescreen notifications, badges, permissions).
I have explained multiple times in this thread why that point is completely irrelevant (a language's runtime has literally nothing to do with its compile target - even C has a runtime), so it would be nice if I didn't have to repeat all that here. The whole point is that TS doesn't have a runtime (unlike *many* other compile to JS targets, like Elm or even flow). It relies entirely on JS' runtime, which just leaves you right where you started with a dynamic and weak type system (at runtime, at the least). 
In my experience, it simply just runs much smoother.
OP here, sorry I turned down the opinions. Hard to balance the genuine critique without becoming a downer. This is only my second real post on this blog and I will take care to have the title better reflect the content. 
Ok, fair point on the runtime. I wasn't thinking about that and you're obviously correct. The type issue though isn't really because of that. Like, if you write valid TS (and are not casting) you _don't_ need explicit run time type checks, even though there is no type system. You can create runtime type errors with bad casting in many languages, and the explicit typechecks are only needed in TS because it can be used from JS, which is an exceptional use case.
I think the biggest problem is that customers aren't used to using PWA's (I don't know about US, but in my country they are not). Chrome does good thing with directly asking user if he wants to pin the app to home screen, but other browsers don't do that and I am not sure if it is enough. Also PWA is still just a website and it has performance limitations. Also I think the touch input is not 100% solved on web. When you want to for example swipe from left to open side menu, some websites can do it but it is not so precise and smooth as in native apps. BUT: If you want to code mobile app and you only know HTML, CSS and JS. Or you want to code app for let's say for internal use in company and you don't have resources to push it through app stores or make iOS and Android versions of that app and so on... PWA's are really handy. So yes... PWA's has their limitations and I don't think they will take over native apps any time soon, but it doesn't mean it's bad or useless technology. Hope that makes sense :-)
touch events on the web are abysmal
Sounds similar to what Flow's daemon does, with the babel transform just stripping the type annotations.
I tried flow a few months ago before giving up and coming to TypeScript, but the thing I like about using flow is that there isn't a compile step. So you have the freedom to comment out a piece of code or not get your types quite right if you just want to test an idea without having to put the right interfaces in place or having to conform to a type. If the idea worked then you can go back and get the types down. If Flow got more love from Facebook and was integrated better with VS Code I could see myself switching back.
I call bullshit. I have several PWAs that run faster than their native app. The biggest, and seemingly impossible to overcome hurdle, is device integration. There are many features which are still missing, and that consumers regularly use. List of capabilities for PWA: [https://whatwebcando.today/](https://whatwebcando.today/)
Flow doesn't flow?
Ah okay interesting. I still think for the purposes of interop with other tooling a babel transform is vastly preferable, but it looks like one exists that's almost ready for production use anyway. Understandable it didn't naturally develop that way if babel was a mere twinkle in seb's eye at the time.
True, but it's and edge case. 99.99% of mobile apps don't interact with external hardware.
I want to chime in with how bummed i was with apple when I tried doing a PWA of something recently that required WebRTC for front facing cam. Apple implemented WebRTC great in mobile safari but totally neglected UIWebViews so webcam on the iphone doesn't work in iOS FF, iOS chrome, social app in-app browsers, and lastly PWAs. 
\&gt; ...not if you build other abstractions that better suit your needs. The part where you build those abstractions **is** where you are working from a lower level of abstraction...
idk either and I use Flow every day. I guess it's easier to integrate with an existing project
Another great related point is exactly that, PWAs still are viewed as less trusted than apps by the mainstream end user. 
99.99% of retail and market mobile apps don't, but many enterprise and line of business mobile applications do. For example, think of point of sale, warehousing, medical tracking, document management and many lab/analytical applications, as well as IoT and other edge connected or embedded devices.
Also iOS still doesn't prompt to pin like android does, if i'm not mistaken. So if you bake in logic to have some banner with instructions show up for the user, you have to be super hacky to get that same banner not open up when the user is viewing the site in PWA form.
You're right, but I'm finding more and more web apps with great touch support recently - therefore I'm convinced that it's definitely *possible* given that enough effort is put into it. I bet there'll be more libraries to improve on this soon.
I've built a PWA, the answer is a simple one: Apple
&gt;Lack of discovery from app stores Deploy the app store too then? No need to put all your eggs in one basket. I think there are webpack plugins that take a lot of the pain out of setting up / maintaining service workers. Have some experience with offline-plugin, it seemed quite nice.
Exactly. And now Babel can parse and strip TS annotations. And `tsc --noEmit` invokes TS as a typechecker without compilation. And TS's `checkJs` option can typecheck JS annotated with comments, for projects that cannot have a compile step for whatever reason. So TS can function as "just a typechecker" if you want. On the other hand, if you're like a lot of us and want to get your work done quickly and easily, TS is a one-stop-shop for language intelligence and transpilation. Locally `npm install` the version you want and VSCode will pick it up for both roles. Plus, TS's semantic analysis is implemented in JS, so it's easily consumable by other tools in the JS ecosystem. And custom transformers can use semantic type information for code emit, which isn't possible via Babel. (parsing type annotations !== understanding them, unless you want to reimplement semantic analysis)
&gt; Sure, but you can break Java (in its runtime) by casting too. And get runtime type errors or pass things as types they aren't. First of all Java has a weaker type system than most strongly-typed languages (which, again, I've mentioned - implementing generics through type erasure, etc). Even at that you can't blindly cast things and get away at _both_ compile and runtime the way you can with TypeScript/JS. Yes, in the Java equivalent of the example I gave, you can cast `"whatever"` to type `Object`, but 1) `foo` still will not accept it unless you explicitly cast it as an `ArrayList&lt;String&gt;`; 2) even though javac's static type checking is not advanced enough to guarantee type safety in that situation, it _still_ detects the unchecked casts and informs you of them at compile time; 3) the Java runtime still recognizes and throws the ClassCastException _at the point of the cast_ during execution without the developer writing any sort of explicit check. On all three points TypeScript (and JavaScript) simply swallow whatever you bullshit it with, and given the weakness of JS's type system this can lead to confusing exceptions further down the execution path (or even more confusingly, _no_ exception when what was passed is vaguely in the shape of the expected input but still fucks up your application state) &gt; If you compile TS, and then run it (in the JS runtime) you will not get these types of errors **unless you cast**. And people cast, and cast a lot, so I'm not sure what this is supposed to show. The whole point is that it's a failing of the type system to be unable to catch that sort of dangerous casting behaviour at both compile and run time. As mentioned, Java will at least force you to cast it back at compile time. Swift takes it a step further and forces you to explicitly specify not just a cast, but a downcast. Both will still refuse to make an illegal cast at run time. &gt; if you are developing only a TS app, or a library to be used only in TS Given the fact that the language does not have a runtime or reference implementation and its lack of popularity compared to the language it compiles to, there's pretty much no such thing as a library to be used only in TS. Even with "TS only" apps, any non-trivial application is _still_ going to need the developer to write runtime checks. For example, by design/necessity Express' `req.body` property is of type `any`. You can literally just pass it to anything and/or call whatever properties or even methods you want on it and the TypeScript compiler will not make a single peep.
Having dipped in and out of Flow over the last year or so we've just introduced it at the beginning of a major project and it's been excellent so far. Much more stable with far better editor support than it had just 12onths ago. 🙂 I like TypeScript but I currently prefer Flow as it's significantly easier to just drop into a codebase with a single Babel plugin and that's it. TypeScript is a little more involved (not saying it's complicated, it isn't). And if we want to move away from flow in future it's pretty easy as you don't need to buy into it in a big way like you do with TypeScript. I don't care what people use though. I just ❤️ that people have been taking type safety so seriously in the JS world for a couple of years now 😁 I hear the Babel author is also doing work in this space so it'll be interesting to see what he comes up with. The main problem right now is JS has 2 really good options for types and OP mentions not all libraries implement both or even one of them. It's improving but still annoying 😋
Somehow I'm doubtful of that. It already took them long enough to add proper WebRTC support to mobile Safari. Apple just really sucks at some things (like making browsers).
Babel 7 has native TypeScript support
Let the browsers handle GC and move on...unless you see that your scripts are consuming large resources over time. Specifics on how to approach ‘memory hog’ issues will really depend on the code/library/environment being used.
Oh right on thanks!
The general principle is you should only keep references to objects if you still need them. Once you no longer need them, you want to break the reference (i.e. set pointer to null) to them so they can be garbage collected. You gave a couple of good examples of when you should no longer keep references to objects. But it's impossible to enumerate all reasons because they will depend on the specifics of the code you are working on.
Hmm, I disagree with you. A large portion of apps available use some type of DRM and that shit requires all types of hardware stuff that you don't have access to with a Web app. I personally love writing Web apps but I feel like a Web app also lacks the look and feel of a native app
To be pedantic; *garbage collection* in itself is an automatic process, occurring only when the browser feels it necessary (e.g. at an interval, or if it immediately needs to free memory). It is not something you implement yourself, per se. But I understand what you are asking; *WHEN and HOW should I make my objects and resources eligible for garbage collection?* I'm not confident enough to fully answer this myself, but these may be of help: * https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/ * https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec * https://developers.google.com/web/tools/chrome-devtools/memory-problems/ * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management (very technical) &gt; Also is there a way to test the effect of doing collection well or bad ? As described in some of those links, one tool you can use is the "Performance" profiler. [You can start a recording, and then use the parts of your app that you want to measure the memory usage of, whilst recording](https://streamable.com/btrea). In the example I linked, [it turns out there is a memory leak](https://i.imgur.com/5KVBU1V.jpg) (oops). The number of nodes and JS heap memory usage is trending upwards, even after garbage collection events. This is one way to tell that objects are not properly being dereferenced, released, or deleted.
Does he get to have opinions anymore? I thought he was deemed double plus ungood.
Service workers don't work on iOS
Using react, I've found touch events to be on par with native, personally. Would definitely like some elaboration, if possible. 
&gt;&gt; Sure, but you can break Java (in its runtime) by casting too. And get runtime type errors or pass things as types they aren't. &gt; &gt;First of all Java has a weaker type system than most strongly-typed languages (which, again, I've mentioned - implementing generics through type erasure, etc). Even at that you can't blindly cast things and get away at _both_ compile and runtime the way you can with TypeScript/JS. Ok, but you often can with C, another language with a runtime. TS behaves the way it does because it's designed to be a superset of JS, which is the same reason it doesn't have a runtime. A language allowing loose typing behavior can happen with or without a runtime, and TS allowing it is a design decision the same as not having a runtime, not a consequence of it. I'm just saying complain about it's design and stop conflating that with the presence of absence of a runtime. &gt;&gt; If you compile TS, and then run it (in the JS runtime) you will not get these types of errors **unless you cast**. &gt;And people cast, and cast a lot, so I'm not sure what this is supposed to show. The whole point is that it's a failing of the type system to be unable to catch that sort of dangerous casting behaviour at both compile and run time. A failure of the _type system_, which could be remedied at compile time, still no runtime needed. I agree. 
Socket connections
I call bullshit on this. Show me a PWA that actually runs faster then a mobile app. There’s no way around it, running a browser and interacting with the DOM has huge overhead in both memory and CPU. 
The main app I work on is an PWA. There are quite a few things they're missing: - Access to various sensors and networks there aren't web APIs for (SMS, bluetooth etc) - Good control of what the back button does. You don't think about it much, but on mobile back buttons strictly go 'back' in your navigation flow, where as in native apps they sometimes go 'up' instead. It makes app navigation quite poor compared to native a lot of the time - Full use of disk space. Chrome only allows one domain to use 5% of free disk space at any given time, you can't ask for more, and if you go it will just delete your shit. This is fine if you're making a TODO list or something, but not fine if you're trying to make something that may use lots of data, like a photo app or something. - Good app management. This is a bit better now on Android because they can be installed, not just on your desktop, but in the main app drawer. You still can't "uninstall" them though (ie remove their disk usage) or manage them in an obvious transparent way - Older android phones don't support them - Do they work on iOS yet? Last time I checked they don't (we don't support iOS so I haven't looked into it for awhile) These problems are large enough that we don't actually ship as a PWA. We ship on Android as an app on the play store, which is a thin wrapper around a custom build of chromium (seriously) with the 5% space limits hacked out that loads our app's URL. This lets us both use as much space as we like, and also access native sensors / whatever via a JS bridge.
Holding out for that ambient light support.
Typescript is more like C, C++ or Rust even. Types are lost when compiled, so if you opt out of the type system or do unsafe things then weird stuff can happen at runtime. JS is still "safer" than those, but debugging unexpected run-time coercions isn't fun. C# and Java will always catch type errors and be able to describe what happened at runtime even if you down-cast to Object or whatever. This includes array bounds checks. Typescript (and Flow) are great but you have to be as strict as possible to reap the benefits and be aware of where the holes are (eg. parsing forms, JSON, DB rows.)
Making apps that feel truly native. You can definitely approximate native UI in web apps, but it will always feel off. An example on iOS is the transition between screens, the animation of the navigation bar and the slight sliding of the previous screen just feel right and provides subtle context to the user about their position in the application.
Secure storage. 
Availability of type definitions for JS libraries. It's a monumental task that MS fully committed to.
&gt; Ok, but you often can with C, another language with a runtime. And like I've mentioned, C has a notoriously weak type system. It _would_ be very great if I _didn't_ have to repeat widely available information that I've already stated. &gt; TS behaves the way it does because it's designed to be a superset of JS, which is the same reason it doesn't have a runtime. Even Flow has a runtime so this point is moot. Being a superset has literally no bearing on whether or not a language can have a runtime - Objective-C for instance is a superset of C and has its own runtime. &gt; A language allowing loose typing behavior can happen with or without a runtime The presence of a runtime to functionally implement a language's type system is one of the major ways of achieving type safety (especially when the permitted semantics are far too broad and the compiler is far, _far_ from sophisticated enough to statically prove correctness), so no, the two are not orthogonal. Especially here, where the runtime that it does depend on has a notoriously weak type system, making the whole venture rather like building a mansion on a one-inch foundation. Also, again, pretty much no (higher level) language does not have a runtime. Again, even C has one. So again, I am not sure what this defense of TypeScript's lack of a runtime is for. &gt; A failure of the type system, which could be remedied at compile time, still no runtime needed. A type system is part of a language and does not only exist at compile time. In addition, I don't have much faith in the ability or willingness of people who refuse to implement a runtime because it would be 'too complex' and 'out of scope' to implement a JS-targeting compiler that even approaches guaranteeing provable correctness as much as, say, the GHC does.
The bigger question is who in the hell is still using DOM instead of Service Workers... Isn't DOM 20 years old at this point? If you wanted to have a solid argument, perhaps you should reference the technologies that are being used by PWAs? 
&gt; TS doesn't have a runtime (unlike [...] Flow) Flow does not have a runtime. There is a project not affiliated with Facebook (and obviously not part of Flow) attempting to implement a runtime: https://github.com/codemix/flow-runtime The same exists for TypeScript (not affiliated with Microsoft and obviously not part of TypeScript): - https://github.com/fabiandev/ts-runtime - https://github.com/gcanti/io-ts
Please explain how background tasks replace the UI of your application.
Every business on the world needs a simple, professional website to advertise their offerings, and the basic skills you learn with JS will get you an entry level position at a web firm that makes these websites.
I wasn't commenting on the officialness (or not) of the runtime. flow-runtime is *actually* a runtime - you write perfectly normal Flow-annotated code and the runtime (along with its assertions) are inserted by the compiler (via a Babel plugin). io-ts requires the developer to use a library in their application source code. There is a difference between a library and a runtime, much like there is a difference between importing and using a library that gives you async and await HOFs you can apply and Babel inserting a regeneratorRuntime during transpilation to handle the async/await keywords. ts-runtime is literally based on flow-runtime (which *again* illustrates the whole point of it not having its own runtime), is an experimental package with lots of missing features, and requires you to change your workflow (use its CLI rather than tsc). 
Not in production yet, but hopefully soon. My company uses Vue, react, angular and has a ton of olde legacy apps in jQuery or plain Jane, with a bunch of tools and component sets in each. I've been for the last month or so working to complete a set using stencil to generate a cross platform set, that can be used everywhere, and stop us from recreating the wagon every time something new comes along. There's definitely a few gotchas, but generally easy to figure out, the API is totally nice, and if you're not using react things just work, relatively There's a bit of extra stuff for react, but overall im impressed so far
There's actually no built in Flow package for VSCode. It's a 3rd party extension but its development seems quite stagnant. The reality is that Facebook isn't putting any effort into editor and IDE support for Flow outside of its own Nuclide for Atom package. So if you want to use Flow, use Nuclide instead of VSCode.
Fuck it, global everything
Being able to use a language with a type system, decent performance, sane operational semantics, and a standard that isn't expanding faster than the observable universe.
This in combination with background execution/access to hardware (like GPS) is a big challenge. My startup is currently investigating PWA's instead of building full native apps. We're struggling to identify a means of reliable accessing the GPS with the same quality that you'd get in a native app.
There’s definitely a trade-off. If you want to truly build the best experience for your users, you can’t beat native apps because of these kinds of details. We also found that certain UI like interacting with charts will never “feel” right on web apps, partly due to performance. In the process of making an app that had lots of charting, we tried web and React Native, before giving up and going full native to get the feel right. 
Typescript can help with some of this
&gt;Even with "TS only" apps, any non-trivial application is still going to need the developer to write runtime checks. For example, by design/necessity Express' req.body property is of type any. This is true no matter what language you use. There are no static guarantees when making web requests, obviously. Now, that doesn't mean I can't write a Typescript module that has this function: `export function reverse(input: string) {` `return input ? input.split("").reverse().join() : null;` `}` And share it with people. Notice I'm not checking if `input` is a string at runtime. If you aren't using Typescript and you use my module, you might call this function with a number or something by mistake, and your app probably won't work. That's *your* problem.
&gt; This is true no matter what language you use. There are no static guarantees when making web requests, obviously. Of course there are no static guarantees, which is why many languages have an actual runtime that implements runtime checking of correctness that cannot be proved at compile time, by requiring you to explicitly cast it to the type you want and throwing an exception at the point of the cast if it cannot actually be safely cast at run time. Then again this is the JS sub so I don't know why I expect people here to be familiar with how languages with strong static type systems work. 
Safari is the new IE
An easier install process. I can't speak for android but on iOS you have to click More -&gt; Add to Homescreen. Frankly that's too much to ask of many users. They need to be listable in App Stores, and let the developer add a banner from the web app that allows for a 1-click install
Good point on the DRM. What feels different about a good PWA versus native? Seems like PWAs can do loading screens, app icons, offline behavior, and of course all without browser chrome. My guess would be the main things that show a difference would be 1. performance, for those that disregard it in development, and 2. The choice to abandon the iOS or Android design conventions like standard navigations. Is this what you mean?
Remember when Steve Jobs didn’t want to allow third party apps because he thought web apps would suffice? Geez.
Isn’t mobile safari like one of the first mobile web browsers to support service workers. 
We don't get to pick the web view type for home screen web apps. 
You're right in that there's no prompt yet, but it's easy to detect it loading as a PWA on Safari because they set navigator.standalone to true. 
Probably some kind of JavaScript programming job!
What do you think a C compiler is doing? It's compiling code into a format that doesn't enforce types at runtime because it would be wrong for a language to mandate the performance hit. So they enforce types at compile-time, and programmers add runtime checks where appropriate. There's no interpreter in sight because that would be missing the point. TS emits declaration files specifically for library authors. Types can be enforced at compile-time for consumers of your library. If consumers don't use the declarations, or otherwise misuse your API, that's their fault. It's naive to think that all libraries implement runtime checks for all inputs and outputs, nor that they should. VSCode makes this automatic, so consumers don't need to jump through hoops.
Kindly actually read the rest of the thread, thank you. A whole metric fuckton of languages have runtimes which contain a type system implementation, which y'all would probably know if you actually ever used them or took an hour of your life to learn about program execution.
Supplying users a web app bundled with a custom build of a browser is the most 2018 thing I've ever heard.
Firefox supports it already.
C++ has RTTI, and both C++ and Rust have far stronger and less fragile type systems than TypeScript. 
I built an app for our Zebra handheld scanners that works fine. Most scanners work just input the barcode and hit enter or not so you just check interprets if e.key === 'Enter'
Y'all need links.
I don't think this is all that unique. We evaluated [crosswalk](https://crosswalk-project.org) 4 years ago for just this purpose, and it looks like they've only matured since then. 
I've never tried to use it, so I could be completely wrong, but if the scanner or sensor was connected via USB couldn't you use the [WebUSB](https://developers.google.com/web/updates/2016/03/access-usb-devices-on-the-web) api. It looks like it is currently only supported in Chrome, but it seems like browsers are starting to take steps to make it possible.
It's only really an issue if you have a "leak". Which is to say you are continuously adding new garbage which is never getting collected. Sooner or later it will be too much and things will slow down. Otherwise, don't worry about it.
That's what the book is telling me though? This is Murach's Javascript and DOM scripting book telling me this. What am I supposed to put instead? 
Pffft what are you talking about?? 
Looks like you need to be error checking the value of ‘sub’ and ‘tax’ rather than ‘subtotal’ and ‘taxrate’
I don't know much about developing mobile apps so I don't know how to measure a native apps speed, but I think a good case study for comparing a PWA with a lot of consideration put into it to a native experience is Pinterest. They've created two articles on the experience of making their web app as performant as their native app and it seems to have come out well: https://medium.com/dev-channel/a-pinterest-progressive-web-app-performance-case-study-3bd6ed2e6154 https://medium.com/@Pinterest_Engineering/a-one-year-pwa-retrospective-f4a2f4129e05 After a brief skim of the article I couldn't find a direct comparison between the two. But the tone of the article suggests that you get a very similar experience in terms of performance and features between the two. 
It's meant to.
That's fine, but I was thinking 2D scanners or sensors that need to take periodic samples that don't map to a traditional input field very well.
Its definitely something to do with the error checking. It doesn't work without it. If I take it out and leave the code in the else statement (without actually having the else statement there of course), I go to type a number and it outputs NaN. I don't understand what's wrong here, if its a number it outputs Nan and if I add the error checking again, it prints the alert regardless of whether its a number greater than zero or not even a number at all.
Push Notifications on ios, which will never happen. But really they not designed as a replacement and while they can do a lot, it really depends on what you wish to achieve with it that would determine pwa v native. Pwa will never replace a native app, just certain cases you may not need a native app.
Does work on ios, only owing to massive pressure from big name developers in the community, but as they are colossal cocks, push notifications don't work.
Erm,... Those work...
Public perception of an app vs a website.
No, the last by a long shot, they only got support with ios 11.3
Reeeeeally depends. Would you consider yourself a web designer, web developer, or software engineer? If you don't know the answer yet, that's ok, but think about whether you want to be doing visual/HTML/CSS work (web design), more heavy JavaScript (web developer), or if this is a first step in a journey to mastery of several languages and a deeper knowledge of systems/architecture/infrastructure (software engineer). The kind of work you'll be doing down each path varies widely, as does the competition for positions. The size of the company matters a LOT too - the smaller the company, the more varied your responsibilities are; the bigger the company, the more specialized you can become. At a small company, you'll learn a little about a lot of things, have a lot of pressure to get stuff out the door quickly, have longer hours, but will end up with a very broad and flexible skillset which can lead down many paths; you take more of a risk when you sign up with a small company, but the financial upside is much larger if they take off. At a larger company, you'll have a much deeper knowledge about a much narrower area, (they'll generally bring you on for a specific role), you'll have less pressure but less of an overall impact, and generally more opportunity to learn from experienced engineers and a mature codebase; you'll have more job security but also generally not as much potential financial upside. My point here is there's no one 'kind' of job that this path will present you. There are tradeoffs for everything (much like writing code) and the best kind of job for you depends on your technical interests, what kind of work/life balance you prefer, how much you value things like job security and experienced mentorship, and how big of a impact you want to have. My advice? If you can answer all these questions easily, you already know what to look for; if not, find a position at a small place where you can do a little bit of a lot of things and use that time to think about how you want to progress and what you enjoy.
Does it work if you move the script tag in your html up to after the opening body tag?
You can get a web design job after this. But you need to learn at last one framework of CSS like **Bootstrap**.
That might be true for Ionic or Cordova, but if you make a PWA with something like react or wrap wkwebview yourself, performance is almost indistinguishable from native. 
Yup. My hobby is visualization of large networks (graphs) in the browser. Unfortunately, CPU intensive algorithms in javascript (even with asm.js) are much, much slower than multithreaded C++ code written with basic knowledge of OpenMP
Are you asking for console.log(this); ?
What about \[this\]([https://www.reddit.com/r/javascript/comments/94mqj0/i\_built\_apple\_music\_using\_reactjs\_redux\_and/](https://www.reddit.com/r/javascript/comments/94mqj0/i_built_apple_music_using_reactjs_redux_and/))? We are so close, extremely close. Most users wouldn't even notice the small differences here.
We have a custom react script that you can use to boot up a new web extension project. https://github.com/Windscribe/react-scripts-ws-webextension docs are thin right now, but we'll make a statement once we feel its ready to go. it works quite well now though
You can do whatever you like, and remember there is no end of code programming, also you can do java based on JavaScript
Now make a list that native apps can do. PWAs are missing native SDK. Proponents of PWAs have zero understanding how many and how polished APIs e. g. UIKit offers. 
Lack of good performance... I have actually came from Android development to Web, because I thought that Android will be dead... However new features coming to Android, like new custom animation layouts, better architecture of app will further utilize performance of native apps. So maybe I will go back fully to Android :D it seems that web will not be able to replicate native apps performance anyway.
Try it on phone.. then you will see
Can you explain that a little more? How is Android app storage secure? You can easily encrypt SQlite. 
&gt; ts-runtime [...] is an experimental package with lots of missing features And flow-runtime hasn't seen a single commit for 6 months. Please don't mislead readers into thinking "Flow has a runtime". The correct sentence is "There is an unmaintained thirdparty project that implements one".
Hello, may i check with you what is my lecturer asking for ? can give one solutions as an example ? Thank you Task: Provide 3 unique implementations of the following function. Input: n - any integer from 0 to Number.MAX_SAFE_INTEGER. Output: return - summation to n, i.e. sum_to_n(5) === 1 + 2 + 3 + 4 + 5 === 15. var sum_to_n = function(n) { // your code here }; 
Listen, I'm going to be honest with you. Most of these guys are already in the field, and they will tell you that you can get in easily and it's all sunshine and flowers. You may find yourself in my shoes someday. I'll give you my experience as a jaded entry - mid level developer. The junior level web development field is absolutely FLOODED with junior devs right now, hoping to get in on the web-dev "gold rush". They have been pumping them out of bootcamps, online tutorials, you name it. So you end up like me, working an unpaid internship while balancing two jobs because you weren't up to the cut. I've been developing JS for almost two years now. React, JQuery, Plain JS with the DOM, TypeScript, you name it; and I've used it at some point or another. It just isn't enough these days. I've considered giving up and changing field, because my meagre unskilled worker pay + unpaid internship are not paying the bills, and I'm getting desperate. Hopeful interviews and trigger happy recruiters will promise you the world, and give nothing in return. I'd advise you to go into C++ or something, JavaScript is a no man's land for juniors in 2018+. Good Luck.
I definitely recommend having something more polished before sharing. At least change the README from create-react-app's. 💁‍♂️
Maby, or maybe I've just never tried a good PWA. Maby I wouldn't even notice that is a PWA
hehe of course.. if you want to try it out though ``` npx create-react-app app --react-scripts react-scripts-ws-webextension cd app yarn start ```
A lot of engines will infer the ability for the code to touch an object. Yes it helps them clean up faster, but engines can do some amazing things.
You'll be pleased to know we were ahead of our time and have been doing it for awhile :P We actually use the Crosswalk lib that /u/adameepoo mentioned (I wanted to keep my explanation simple). We specifically contributed a PR to them that allows you to pass through a parameter to the chromium instance you start where you can disable the limit.
You can't access SQLite through the web (WebSQL is a dead technology). If you are a native app you can store data in any way you like, including encrypting it before you write it to disk.
Oh ok! That makes sense.
It was removed because of tracking concerns - might reappear as a media query with a lot less detail (ie bright dim etc rather than 34lux)
Only Websockets which are completely different
* Manually be able to prompt the install banner. * Be able to show a native save file dialog. Not downloading stuff in the pre-defined folder. * Better storage support for offline-first PWAs * More control over the back button * Animations still feel not so smooth
Normally I'd agree but the op specifically mentioned event subscriptions which is definitely one of the times when you should make sure to clear your references. That isn't technically garbage collecting but it's allowing the garbage collector to do it's job.
I like how files pop up like boxes in the file drop area after uploading. In addition to drag and drop this furthers the users sense of being able to do direct manipulation. The documentation is good too. The only thing I think is missing, is preview of pdf files.
&gt; local storage Hadn't considered that but it's a good idea, thanks.
You're welcome!
Oh shit we have VR support in FireFox? TIL
What's the fucking point of this comment? Go stir shit somewhere else, we got work to do here
Safari has always been shit, it was pretty much IE's retarded twin brother from the get-go.
&gt; JavaScript is a no man's land for juniors in 2018+. well said. True by me personal experience. Almost everyone is hiring mid to senior. 
I don't understand what you're asking. If you want to lay things out in a grid, aren't you looking for advice on CSS, not Javascript? Do you need advice on adding some HTML to your output in order to make CSS layout possible? Please explain some more.
Create it as a module. Import and call it where you need it?
Keyboard layout depends on the keyboard app, but the locale of the webapp/site can be different
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [technion/erlvulnscan/.../**cache.erl#L39** (master → 8d109c4)](https://github.com/technion/erlvulnscan/blob/8d109c49c8ecf331a4a859296e9fafd57aa458cd/src/cache.erl#L39) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e4ep77u.)
 Hello everybody who read it :) Recently I created my first open source project. It isn't something innovative or kind of. Just pure javascript slider, created with purpose of sharpening my skills. At this moment I have no contributors or at least someone who report about any issues. So I want to ask somebody look at my code and write here if there's any issues or if you see some way of improve this one. You can look at my code here: [https://github.com/IvanGrimes/slippery](https://github.com/IvanGrimes/slippery) I'll be glad and thankful if you'll spend a few minutes to review it.
I just published my first npm module: a draggable datepicker [npm](https://www.npmjs.com/package/vue-draggable-cal)) Since it is my first attempt, any feedback / tips are more than welcomed !
Well no shit they're all libraries
Adding TypeScript to the mix with projects over 30k stars: Microsoft/vscode (57.4k) angular/angular (39.6k) Microsoft/TypeScript (38.0k) ionic-team/ionic (35.1k) (Disclaimer: GitHub stars are not a useful metric for selecting software)
Oh, well that's what I get for just repeating what that website which someone linked reported. I knew better than that. Haha
I counted quite a few that weren’t. FreeCodeCamp? NodeJS? Create-React-App?
6 stars might be fine depending on the project or people behind it. On the flip side, a lot of stars doesn't necessarily mean the library is popular now, only that it was at some point. So in either case, almost any other metric seems more important to me.
Hey, I'm a fellow beginner so I can't really review your code and provide insightful comments but it looks like you put work into it! After a quick glance, a couple thoughts came to mind: 1. It would be pretty sweet to have a working demo to play with and help visualize the code (at least for beginners like myself)! 2. Your `slippery.js` file is pretty long and you can find yourself scrolling back and forth a lot to find what's what. I would personally try to split the code into smaller chunks or try to group the methods with their dependencies. But again, I might simply lack the proper practice! Looking forward to reading what others have to say about it! 
Maybe it isn't the language itself, it's the framework it runs in. Namely, a single threaded UI or an async server in node. That requires some type of async event handling like most UI frameworks. Some of them just queue events that are then dispatched in some way. Like in Win32 where events are just id's , typically handled by a switch statement. Where as JavaScript dispatches functions. It would be possible to structure a program to have all callbacks call into a switch type event dispatcher or something else that unified the event handling. Other systems register handlers for events and a built-in dispatcher routes them. On the one hand JavaScript callbacks give less structure but are more powerful. And it's possible to write non-UI code that is completely synchronous in node, avoiding callbacks. 
The main javascript process acts as a thread of its own, rather than a complete self contained program. As a thread, expecting to communicate with other threads, it has its own "task pipe" roughly speaking allowing other threads to synchronize with it. At the same time, those other threads already exist. These together are at the heart of why asynchronous coding seems like a javascript thing, I think. You just gravitate towards it as a coder. In most other languages, your code is not running on the current iteration loop of a thread, but it is the thread, the entire program. If you need some synchronization, you implement it, and hence, when you need to wait for things to finish, how you do it is up to you. At the same time, whether those other things run on separate threads or not is up to you or whoever developed them. When it comes to IO, the synchronization back, is also on you. How you want to do it, is on you, and explicit. In javascript, the synchronization back mechanism is already present with a particular approach, and hence influences the rest of the code that a programmer writes.
Thank you for review :) I added demo [**https://github.com/IvanGrimes/slippery#demo**](https://github.com/IvanGrimes/slippery#demo) Also I will split my `slippery.js`
Clojure makes extensive use of callbacks. In Perl, Python, Lua callbacks are also commonly used. The classical Windows API, typically used with C, C++, asm, and many other languages is very heavily based around passing callbacks. Also, Un*x's Xlib uses callbacks to set up handling events, in a way quite similar to what the DOM event API does.
Yes it would! But engines optimize internally and do use a contiguous representation. If, however, you create holes then that optimization doesn’t work and they have to switch back to the unoptimized representation.
What the social media aspect of coding doesnt make you want to use these in all your projects?
Hi /u/virusxd521, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/AhmedBenAmmar, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Also look at PreactJs which is 3kb compressed 
No. Npm is written in JavaScript.
I mean, you shouldn’t expect any job. But if you do, it’s the ones you apply to. We can’t really answer your questions, there’s a millions companies that use JavaScript and they’re all different. 
You need to install Node.js to use NPM on the command line, but you can use NPM (once installed) outside of Node.js projects. For example, we have NPM packages inside our ASP.NET Core projects at work, but we don't have any Node applications we deploy.
Fair point. Apart from JS they're one of those techniques - a bit like recursion - which I knew about and used occasionally; but when they were used they were generally precisely the solution needed. AS OP says, JS is a bit unusual, although I've never done much coding in the functional languages.
sweet! I also use puppeteer under the hood. Their API pretty sweet. But I wanted something even more dev friendly and there is nothing more friendly then REST!😂 
In JavaScript you pass a reference to the function.
C is the only language I can think of right now that doesn’t have them. Even C++ got them last decade.
IIRC Mithril has been around for years, its hype train just never arrived.
Source?
Hello everybody who read it :) Recently I created my first open source project. It isn't something innovative or kind of. Just pure javascript slider, created with purpose of sharpening my skills. At this moment I have no contributors or at least someone who report about any issues. So I want to ask somebody look at my code and write here if there's any issues or if you see some way of improve this one. You can look at my code here: [***https://github.com/IvanGrimes/slippery***](https://github.com/IvanGrimes/slippery) Demo: [**https://github.com/IvanGrimes/slippery#demo**](https://github.com/IvanGrimes/slippery#demo) I'll be glad and thankful if you'll spend a few minutes to review it.
Popularity and ease of finding developers in your area. Long term speculation is another. It is most definitely a business decision. Your team also has to agree so it is a bit of preference. I tried my hardest to use and like angular and I just couldn’t. I was able to be productive within minutes with react and vue. But react is more popular in my area and has wider adoption overall so it’s a safer bet for my boss to choose react. 
I like how they conveniently don't mention Preact in their comparisons
Aye, sorry, I know that's how it works underneath, bad wording on my part
JS frameworks have three birth dates: the announcement Medium post, the 1.0.1 medium post, and the hype train post
You have to consider the environment you are building in. Is it going to be compatible with your team's existing toolsets and workflow? How hard would the developers need to adjust? You can also build small prototypes if you have the bandwidth using the different frameworks. You also have to take into account the business needs. Will this framework still be supported 5 years from now? So for big projects and businesses the decision to choose a framework does not take just hours, It could even take months. 
I use it if I'm adding a new feature to something. That way you can be sure your test actually fails before you add the feature, and passes after you do (so it's not just a fluke). If I'm starting a new project, TDD has always hindered me more than helped. It's a lot of overhead for not a lot of payoff IMO. I have found it much more beneficial to start imagining and writing out how I would like to use the library/app (e.g. start writing out some somewhat-pseudo-code for how you intend to use it). This helps to think through the different scenarios you need to cover and guides the overall architecture. You can even go as far as starting to write out the actual documentation for it
Mithril has been around for about 4 years I think
Now that is a name I haven't see in a while.
TDD is cool and super useful. BDD driving TDD is where the magic lies for me. Collaboration with non technical people, using ubiquitous language and covering scenarios that matter makes it worthwhile. 
I propose we stop the JS circlejerk.
Looks easy for simple pages, update hell for large ones.
It's true that it's possible to create a really performant PWA, but I think it's also true that it's much easier to mess up performance compared to a native app. In part because the performance of a native app is generally better than something running on a browser, but also because the performance of the native UI libraries like UIKit is almost solved for the programmer.
Mandatory? It's never mandatory. Do you mean the benefits?
Having a hard time fully understanding this, it's a hackathon to make oss for a cause, and there's some pseudo currency as prizes?
So that website is within jerk #2 (1-indexed). So are you also within jerk #2 or are you opposing jerk #2? I can't tell. 
The last one is easy: hello world shouldn’t be the standard for judging a tool. 
Mithril had all of those years ago 
i mean in which cases it can be unnecessary and in which is beneficial . I guess it depends on size of your current project. And if so what exactly you should be tested - the state of your application, the store?
There were some pretty big apps using mithril, e.g. the guild wars 2 marketplace and lichess.org I built some relatively complex apps with Mithril in my previous jobs and I've seen a lot of React apps due to nature of my current job, and IMHO maintainability is more a function of developer competence than what framework they use
Yeah, I think writing testable code is a skill to be trained, and it may be more helpful for newer devs to start out with TDD to strengthen/enforce that. I didn't mean that I don't write tests while I'm building something, just that I don't directly use tests to lead my progress. I also have definitely seen the ugly aftermath of tests being neglected
An example of Mithril.js is a open source forum software called flarum.org .
Or to put it in another light: if all you need is "hello world", then you don't need a framework for it. Not *everything* needs to be an SPA, and that's fine. 
As far as I understand they have access to whatever the browser can access, which is pretty much everything, and at least the chrome and opera browsers on android internally manage permissions, so Facebook can have gps but not twitter. Your pwa should be able to request say gps and be granted based on its source url. There definitely will be limitations over native but really its up to the team, business and project managers to dictate that, if you building something that pairs with a Bluetooth dongle, well then shit, a pwa probably not for you, if you however you building something to list sporting events, then sure that can work as the most you would really need is gps and maybe push notifications, if the later not being capable on ios is not a deal breaker go for it, otherwise maybe consider react native or native script if pure notice is not an option. The benefit to pwas is the single code base for "all" platforms, both Firefox and chrome have or will realest support to save a pwa to a desktop machine, Microsoft has allowed a bundled form of pwa to be published in the w10 store android is all happy go lucky for them, it's just ios that need to be dicks about it, but every technology comes with its pros and cons.
I think some aspects of tdd are mandatory while others are more for personal taste. I think it’s mandatory that your code runs in a test before it ever runs in the application, but I don’t think that test first or using the tests to drive development is mandatory. Different people think about problems different ways, and trying to drive the code with tests can be a hinderance more than a help (at least it was for me). I’ve found that test driven is most beneficial for bug fixes. Reproduce the bug in a test first, then write the code. For newer elements I generally prefer to write the tests as I’m starting to get a better idea of how I want things structured. Sometimes I will write a test or two to help me organize my thoughts or run the code so I can poke at it during runtime. The bottom line is you should always be writing tests with your code, and you should never answer “does this code work?” by running the application and manually testing it.
v2.0 will be Adamant 
I'm within the *there is nothing wrong with new frameworks appearing.* People always complain about JavaScript Fatigue. I can understand that this is frightening for a newcomer who has to do a little bit of research, but that's it. If you are scared that the framework you are going to use isn't around anymore in a few years, just use one of the big three and this won't be a problem. *But what if the one I chose stops being developed in a few years or isn't one of the big three anymore and it's popularity suddenly declines?* Then you are left with a stable and proven framework and innumerable amount of third party packages, how horrible! *Back in the days it was just jQuery and we were happy!* ...and YUI, Prototype, Dojo.
Hello, I think you could use of things like [scroll-behavior](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior) and in incoming Chrome 69 something like [this](https://developers.google.com/web/updates/2018/07/css-scroll-snap) will land ;) 
Hello, fellow JavaScriptians! I'm working on javascript validator [&lt;link&gt;](https://github.com/krnik/valid-js). I'm wantto provide tool that will allow you to: - define your own types - nest schemas freely - validate quickly - validate almost everything :) In the future I plan to add `access-control` feature but I don't know how it will work yet. The reason I started this project is to create one tool for validation and access-control (I needed one for REST API and I couldn't find any). Feel free to criticize as it will let me to take another view on this project :)
&gt;My 0.02$: * Manually be able to prompt the install banner. That's somewhat possible. The browser decides whether you're allowed to show the banner at all, but if the browser decides that a banner is appropriate (which imo is necessary, the notification requests are annoying enough already...), you can manually prompt it when it fits into the flow of your app (at least in Chrome). Chrome sends an event before showing the banner, you can then call ```preventDefault()``` and instead manually show the banner when you think the time is right. [More info](https://developers.google.com/web/fundamentals/app-install-banners/)
How does something like this compare to OnsenUI?
How many years till mounts, sparkles, and wings?
I couldn't agree more. I write unit tests based on acceptance criteria. They are essentially testing the contracts that dictate what code I've needed to write. I won't sit and write tests for every conceivable input or a bunch of contrived inputs that the functions will never be presented with without massive breakages elsewhere as well.
Guess I'll have to get my Mining level up before the release. 
Don't forget about [RiotJS](https://riot.js.org/) being the same thing as well lol. 
If you're looking for perf while keeping React likeness, I'd actually look at either Inferno (author now works a Facebook) or Nerv (based off of ivi, better React 16 compat, backed by a major chinese tech company)
Sometimes you want a library for some nice forms or other widgets/mini-apps on otherwise static pages. In which case it's nice to know you can use something like Mithril which comes in at 8K gzipped, which is a fraction of the size of jQuery.
I’m going to guess “lack of personal experience”, “inability to read documentation” rank pretty high, as it’s a component-based framework in a similar vein as React. Nothing about Mithril makes updating one’s codebase difficult.
well its the default setup from puppeteer then I think - No. But if puppeteer support it - it can be added to the configuration.
Definitely not API changes... it's been pretty stable since the v1 release.
I’ll take a stab: - the ‘this’ keyword can be confusing - var is function scoped (hurray for ES6) - A number of type coersions are quite surprising - coersion plus floating point rules get especially odd (but please stop blaming JS for FP behavior) - Programmers must consider both null and undefined - Prototypical inheritance runs counter to many expectations from other languages, and defining classes has had historically awkward syntax - Convenient polymorphism is often stifled by not being able to extend prototypes without risking breaking all other code. - The standard library is weak, and omits/overly shields developers from data structures. We get a lot of utility libraries from this fact. - Callback hell - many will always be resistant to dynamic typing Modern JS helps, and there’s a lot of ways around some of these particular challenges. I still like JS (though it’s not my favorite language), but these are a number of gripes I have or have heard.
JS started as a language designed to work in web browsers and still is the only language for that. That forces certain things that don’t make sense from the perspective of anyone who is using a general purpose language. The bad parts in my opinion are these: 1- how things relate to one another or can be referenced from one another. For example when you say this.props.bind(this) it can be very confusing what “this” refers too. In other languages, you put the variables that are shared between scopes into higher scopes, but JS makes difficult sometimes to put variables in the global scope, requiring you to reference unrelated scopes in a sense. It is all confusing. 2- it can fails silently. for example, if you mistype a variable name in your code, other languages would immediately through an error alerting you to your typo. Instead JavaScript will pass undefined as the new value and you end up banging your head as for why your are not seeing the result you expect 3- Coercion was designed to allow JS not to be finicky when the you pass 1 or “1”. But that can cause unexpected error that are difficult to discover as again the program will execute correctly using the incorrect data 4- it executes as a single thread, it is fast, but don’t inherently benefit from todays multicore processors. So if I start an express server on a multicore machine, it will use the one core. Unless I separately configure the cluster module to run several instances of express. This can be tricky to understand especially when you would think promises would do that inherently 5- there is a lot of fake structures in it, just as syntactic sugar to make it look similar to other languages. Such as the class keyword but then you are not getting what you would expect from a class 6- the libraries are very fragmented, it is designed that way so that you can make your application only as big as it needs to be when sending it in a webpage. But this tendency transfers to even node apps where t wouldn’t make sense. For example express doesn’t have a built in session manager, react doesn’t have a global state liberary etc. so I have to install 5 or 6 modules and figure out how to make them fit together to get the functionality that you would naturally get in one library in python or go 
I love it, because I think it's awesome that you have a tested piece of code, that whenever you plug in to the actual code, everything works as intended. It's also great for documentation for newcomers on your project, and also gives confidence when adding features or doing massive refactoring. Also about comments I've seen about "it slows down when doing something new" that is true, here's a graph that shows you the difference over time: [https://cdn-images-1.medium.com/max/2000/1\*L7bd2tPHsB0sXdbEI78i\_Q.png](https://cdn-images-1.medium.com/max/2000/1*L7bd2tPHsB0sXdbEI78i_Q.png) (left is no test, just code - right is TDD). Also, it's perfectly fine to write some code to explore what would need to be done, if you're not familiar with a part of the application or an algorithm to start with the tests, but once you have that, you can delete everything of that prototype and rewrite it (I've also seen some people just comment out code instead of deleting &amp; rewriting saying that it would be wasted time - I think that works too, although it could misguide you a bit). It was not easy for me to first do TDD, so don't be hard on yourself if you stray away from it from time to time, but try to be disciplend, as it's a great tool to have.
Can I ask what your back end skill sets are like, and what area you’re in? Hasn’t been my experience. 
How is it RESTful?
Hi /u/linuxguy18, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Straight to the point, step by step, clear and concise. i learned something new today, thank you
I used to personally struggle with JS as well, even as someone who knew Python and C++ beforehnad. I then took this guy's course on it and was able to get more familiar with the way people use certain functional techniques. It's free and I recommend giving it a shot: https://javascript30.com You might not even need to go through the whole thing to pick up the basics behind using it. I personally like to learn a new language by trying to build a personal project with it rather than just following a tutorial. For example, you could learn more about JS by trying to have a personal website where you use JS to populate dropdowns, fetch data from and API, etc. Hope this helps in some way. 
You could start a sidequest, e.g. UI Design, and come back to coding later. This might change your approach. 
What would it look like if it were not a RESTful API? What you described is just... HTTP.
well... REST is http based that the idea. How would you describe REST then? 
Writing tests while your developing is extremely useful for developing or checking results, especially if your application takes 5 minutes to spin up with a debugger attached.
How Do I make the minimum be user defined instead of the constant zero?
I would describe it as a series of requests that each return the client's new state, with the responses describing ways to get to the next state. How would you describe it that isn't just using HTTP as specified?
Put algorithms on the backburner for now and focus on building useful stuff. Use the Javascript you already know. Maybe build a calculator or a small game like tictactoe or if you want something more webbased you could also consume some sort of api like TMDB or youtube or reddit and make a small web app out of it. The most important advice i can give you though is: NEVER give up. As long as you stick to your plan and keep on trying you are not failing. And remember, if it is hard it is worth learning. And if you are having a hard time you are learning. Stay focused! Good luck :)
well yeah in general you right but because its not an “app” and it doesn’t has a state you correct. Yet - this is the closest description for that kind of service imo. 
I'm not very good at design so don't know if this would work but it's something I could think about
&gt;a hard time fully understanding this, it's Yes, the hackathon to make good OSS. Also we help the best developers to promote their projects for the sake of OSS monetisation!
I'm still holding off till we get v3.0 Rune. 
Instead of "RESTful API", why not just call it an "HTTP service"? No need to attach inapplicable buzzwords just to fit it. And yes, this is the hill I will die on.
Okay, lets simplify the problem a little bit, first on the server side making sure your sockets work. var https_app=express(); var https=require('https').createServer(website_ssl_options,https_app).listen(443); var https_io=require(dir.npm+'/socket.io')(https); var io=https_io.of('/dataIO'); io.on('test',function(o,c){ c('test success'); }); now client side in the html &lt;script src="/socket.io/socket.io.js" type="text/javascript"&gt;&lt;/script&gt; client side in the javascript var socket=io('/dataIO'); socket.emit('test',{},function(res){ alert('res'); //should be 'test success' });
Never mandatory, useful when designing an API and want to experiment with the design before implementing. Another use case is when you know the input and output of whatever you're designing beforehand. Biggest thing to know is that no style of testing is foolproof or will guarantee fewer bugs. Keep your tests fast and running automatically as you make code changes, regardless of approach. 
As the ecosystem evolves, it is a higher climb for most libraries to take on React and Vue. In the Vue world, their ecosystem is getting really flexible and well supported. vue-loader lets you use a bunch of css libraries, template languages, subsets of javascript etc without any config at all. vue-cli just came out with an impressive new toolchain. ([https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb](https://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb)) This is why i like vue, they have a highly flexible and complete (optional) ecosystem maintained by the core team, which makes maintenance really easy, and you don't have to cherry pick your own cocktail of libraries to setup a full ecosystem for your app, and make sure your cocktail stays up to par. Some would say a complete ecosystem is a downside, but remember I did mention it is optional. In the React world, Recently Framer announced Framer X, a new design tool that really takes on Sketch and the likes, with proper export to React. You can also import your own React components and use them live in their code editor. ([https://framer.com/x](https://framer.com/x)) Not too familiar with Angular, so I'll let someone else fill that one in.
There are no good or bad parts. There are parts more suited for a particular task than another. Everything in he has its place and, when used judiciously will improve your code. It is just a set of tools. There are no "good and bad cutlery" or "good and bad power tools". Except splice and slice having such similar names. Fuck that thing.
- Not a language thing per se, but vendors and NPM - No proper constants - Everything being encoded as double precision floating point numbers (BigInts are coming though) - Related to the above, an frankly insane approach to type coercion
Oh don't get me wrong. I understand there's muscle behind Vue and React-based offerings. What I'm saying is that this was also the case for Angular 1 and before that, jQuery. If you've been around long enough, you'll know that there was a time when using anything other than jQuery was inconceivable, precisely because of the enormous ecosystem around it. But alas, something else came along, everyone moved on, and now all of that work hash essentially gone to the trash bin. Meanwhile, select2 is still around and perfectly usable from React, Polymer and that-proprietary-framework-your-boss-wrote-two-years-ago. The argument about cocktail of libraries is interesting because "pick-and-choose" is supposed to a _strong_ point for React. And FWIW, as soon as you're doing non-trivial amounts of formatting (e.g. dates and currency), you're back in cocktail land and (again to my point) not a lot of people are doing much about that.
Design is just a different perspective on development. Coding without code, map (diverge), reduce (converge). https://designsprintkit.withgoogle.com/methods/ The method google have researched is called double diamond, you'll find some good info online about that. You create ideas, select, create new ideas based on the selection etc. Then there's the highest level perspective, why you're building what you're building. Check this book: http://www.whencoffeeandkalecompete.com/ Easy absorbable graphic design principles: https://www.vignelli.com/canon.pdf UX/psychology: https://lawsofux.com/ Design knowledge is scattered around different disciplines, and web/app design/development is just a new field that adds a dynamic dimension to it. Addionally you could look into videography and camera setups, and get inspired by that for animations and transitions. Design isn't art, you're building for an audience, not only for yourself. And if you're dealing with audiences, you're dealing with commonalities, and those are discoverable. Software design can be so deep, that it will never be boring. If you get stuck you can branch out into another related field and come back with a much different perspective and foundation skills.
I think it's easy to dismiss things with a blanket statement like this, but think of it in this way - Take a complex, long but very well documented library (say react) - Are you really able to understand how it works from start to end? TLDR: Readable code = Great to know what exactly is happening in this function. Code walkthrough = Great to know what is happening in the whole application (in a particular case). Let me explain: Inline docs are there for broad-based documentation. If you go through a file with good code (+ maybe good doctrings), you know exactly what all things those methods/classes can do. But it gives you no context about : 1. how exactly it is working in the bigger context of the application 2. When is it called, who is it called by, with what parameters, how is the output used by some other part of code, etc. Or are you suggestion better documentation on code flows?
When I start a new project I don't starting writing tests right away because the structure of what I really want ends up changing way to often. After I'm happy with the initial structure and layers of complexity start to set in is when I start to write my unit tests. At this point it forces me to ensure I am in fact writing testable code. This is also the stage where I find many bad habits I still have and writing the tests helps me unlearn those bad habits. After the initial unit tests are done they are used as a refactor tool when things REALLY start to get complex and help catch errors and bugs that would otherwise haunt me later. Unit tests are also great code documentation for the next dev that has to touch your code. 
I'm suggesting other thecniques that doesn't require that much documentation. For example, a good design based in compostable isolated components means you don't have to thing about the bigger picture until you are ready, so to speak. Good tests and a extensive storybook per component is enough to understand the API of the component. I have only required live debugging for very specific parts of the app, usually algorithms to operate on a complex data structure, but that is contained to a class or even a function. The relationship between components is usually both obvious to follow, and irrelevant unless you are dealing with that specific component. There will be parts where this is harder to achieve, but 90% of the app should fit the description above.
In line 5 is a range input. It's min and max attributes are used for the corresponding values in the slider.
I've been thinking about doing TDD and any testing really, but using TypeScript I'm not quite sure I see the big need for testing at a. I want to use it though, I just haven't been convinced to spend the time in it I'm sure I'm missing something in my understanding. 
Hey, how are reactjs job opportunities where you live? And what a junior react dev should know? Thanks.
Hi, I feel your pain, been there several years ago when I started learning. There is good news and bad, good news it will click in, bad news its like learning a guitar and takes years to get good. I will at least give you one thing my teachers simply never did, this is how a callback function works, you use them so that when your doing something heavy, nothing else happens until the function fires back saying 'i am done now'. Example: var some_random_callback_function=function(option,callback){ callback('I am done doing a super huge operation'); }; I pass in a value of {} which is just an empty object, this represents the 'options' part of the above function the second part 'function(result){}' represents the callback some_random_callback_function({},function(result){ //result will be a string with 'I am done doing a super huge operation' });
You definitely can't run puppeteer on client side and CORS would force you to proxy regardless through a server, but if you are worried about IP blocking like you mentioned in the other post, and you are not going to be hitting very specific custom pages with the requests, you could set up some basic request caching on your back end node app, to make sure a client can't spam the actual endpoint with requests. Down side will be that you will get old data depending on how you set up your caching (Ex: 1-2 minute old cached result from your scraping previous scraping)
I think of React as a framework-du-jour. It's easy to pick up React if you've used Mithril and vice versa and FWIW Vue and Angular aren't that far off either. What people often say they like about Mithril is how it helps them master JS proper, whereas with React, newbies often are confused by what is actual JS and what isn't.
I find a small project for new hires that introduces them to our system and the type of work they’ll be doing. Part of this is being paired with someone who is working with or familiar with that space so that they have someone who can answer questions and help guide them.
I'm picking up a project that others have worked on, and I can tell you there's nothing worse than a set of bad tests. It has been impossible to refactor things because tests that SHOULD fail do not because they were either not checking the right thing or they were written wrong.
In line 41 the range value is calculated. You could simply add a fixed number to that, which should work (but be careful, I'm not sure how that will interact with max).
Tried that too buddy, Been trying the whole day!!
Making a Calculator or a To Do app is a good way to learn JS. Learns by doing. Don't focus too much on the algoruthms
Having weak types is probably the worst thing about it. Coercing some silly mistake into a garbage result isn't helpful. Dynamic is fine. Weak isn't. Function scope was also really annoying, but ES6 fixed that with let and const. Monkey-patching is also problematic. Any moron can mess with the built-ins and break your code. I'm also not a fan of doing named parameters via destructuring, because the syntax is hideous and the default values aren't restricted to "compile time" constants. Allowing arbitrarily complex expressions is completely unnecessary and also problematic for tooling and documentation. But that's a very unpopular opinion on this sub for some reason.
Using typescript is not even close to actually testing something properly 
All the time.
I figure. I think I just need to find some better examples or practical applications of testing than I've been seeing. Thanks for your input. 
I started to use https://choo.io for a couple of projects. It's not just cute, it's also really nice and dynamic :) A similar approach anyway.
Well that’s not TDD, and not good agile either.
No. it's not TDD. I'm curious as to why you don't think it's agile. 
I vote for v3.0 to be Cobalt.
1. telling a team how to work, I.e. not to write tests is not very agile 2. not writing unit tests is not very agile 3. having a separate quality sprint is no very agile You should write the unit tests as you go and every sprint should end in production quality code.
Is tree shaking supported for angular version?
I do not use type checker because the tooling out there is too restrictive for my taste. I am talking about TypeScript especially. I came from C++/C# to Js, not to code like with C# again. I like how JS is flexible as fuck and so permissive. It reminds me of Ruby. It's so easy to do meta-programming that way, which is mostly what I do. I however like VSCode's intellisense for hooking up JSdoc comments and inferring types with plain JS files. The ability to preview the methods of an object is maybe the only benefit I am after from type checkers. I will maybe try Flow in the future as I heard it's not as restrictive as TS but I do not really like TS. It feels too much C++/C# to me. 
I wouldn't say it's ever *mandatory* but it is really helpful when you get stuck and don't know how to proceed. It can be intimidating to have to implement something either when you're just not functioning as well as you usually do that day, or you have no idea how to break down a feature into manageable parts. For me, TDD didn't really "click" until I started using it to get over those humps when I was stuck. I wrote about this in more detail here, and if you're new to TDD it might help make it seem more approachable: [Tried TDD and didn’t realize the benefits? Try it the next time you get writer’s block](https://www.coreycleary.me/tried-tdd-and-didnt-realize-the-benefits-try-it-the-next-time-you-get-writers-block/)
What I did was try them all (still trying them) and just choosing one by how useful they are to me.
I agree, I've been using TS and feel that it's too time consuming and has little pragmatic value. Like I'd rather just see my code fail to compile on it's own without all the hyper-restrictive "safeguards" it has.
Man, I wish Riot had a bigger community and more dedicated maintainers (or that I had time to actively contribute to it). It's still one of my favorite frameworks, but it's just not viable for large teams and codebases. Tool and community support are unfortunately severely lacking with it. We tried to commit to it on my team, but ended up switching for those reasons
Unit tests might not seem important if you're working on a small application and/or as a single developer where you have the entire application process stored in your own head. But consider if you walked away from that application for 6 months and worked on several others during that time. When you finally do go back to your first application you will not remember it all so fondly, and these tests will be a live saver as you start wanting to continue developing that application. It is also critical to have tests when working on large applications with multiple developers or teams of developers where you don't know what most of the code is actually doing because you haven't written it. You need to be confident that other people's code is working as expected just as much as they expect yours to be working. And if you ever need to refactor any code, especially code you didn't write, you want to be confident your changes haven't broken code elsewhere.
Just a note that if you already have the source code, you aren't reverse engineering it. You are just searching.
I also usually pull one person to be "get us to production person" That person works a kanban board to get QA, Stage, and production up while the team is working on the product. This is another "agile" rule I break. It works out really well, because there are no surprises that push our releases back. 
For sure! Thanks again for sharing your perspective.
I just put in https://reddit.com/ and it said "sorry, I can't find it".
TDD is about the behavior and the public API of the code. I think people have added on too many rules to what TDD is.
I've only just started using TypeScript and so am probably ignorant in regards to a lot of it's features/use cases, but I've used it to create a couple of smaller React projects and set TS to `"defaultSeverity": "warning"` during development. This means I need to create my types etc., but it won't throw each time when something's amis, and it will allow me to temporarily ignore typings to get a component working quickly, and then act as a reminder to fix any issues later. It seems like the best of both worlds. I can see it as not being totally necessary on solo/smaller projects, but on the flip-side I can see it being almost essential for large apps. The self documenting nature described in another comment is also extremely useful for me in terms of getting familiar with a new codebase.
Full disclosure: I work at [StackShare](https://StackShare.io) . This is exactly what we're trying to help with. Currently, we give you some basic stats about each framework (or whatever dev tool you're comparing) like GitHub stars, forks, how often it's being discussed on Reddit/HN, etc. We also show you which companies are using the tool in their stack, as well as some user-generated content on what people like, dislike, and how they're using it. We're always open to suggestions on how to improve this experience as well, so if you think there's something missing, please let me know!
I am definitely going to take this on board. I keep putting pressure on myself to do all the things I read that I need to do to get a job rather than doing it to enjoy it. I think that could be the big thing for me. Whenever I get stuck, I move onto the next thing. I need to find something I enjoy making and go with it.
It depends on your domain. I find TDD poorly suited for front end development. On the other hand, when I do service work, TDD is a huge help. With services you know what your input will be and what you expect to return. That's where TDD shines. 
Looking at it a bit more broadly, callbacks are a subset of [continuation-passing style](https://en.m.wikipedia.org/wiki/Continuation-passing_style) which was first described in the 1970s. Many compilers, especially for functional languages, translate code to CPS under the hood.
Non-Mobile link: https://en.wikipedia.org/wiki/Continuation-passing_style *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^205724
TDD can be great when say, I was developing Angular apps and I would be given tickets of new functionality or UI and I would write test cases for that functionality, ensure that I was testing to meet the criteria of the ticket, then implement the functionality so that when I was done I knew it and that I had satisfied the work I had set to complete. Then I could run the rest of the tests to have confidence I didn’t break anything in the process. It worked quite well and we really were able to move fast while doing that. Less time spent building the wrong thing.
You take the best, duh.
Have you tried The Programmers Hangout on Discord? Theres also onFocus on discord 
It's down at the moment: [https://i.imgur.com/667yhni.png](https://i.imgur.com/667yhni.png)
Thank you. Maybe I'll try and build a sports one.
I second that motion. Calling it RESTful when it doesn't have a state is just adding the buzzword. 
That’s just HATEOAS. It’s an aspect of rest, but it’s not rest itself. 
HTTP service, sure rolls of the tongue huh 
It sounds like you’re just doing test-first development and not actually doing TDD. The core difference is with test-first development you tend to have an idea for how you’re going to accomplish what you need, and with TDD you don’t even think about architectural decisions. IMO this is the hardest part of TDD, but it’s also where you get some of the most important benefits. Elsewhere in this thread I saw someone suggest TDD paired with BDD. The reason why this is beneficial is because you’re essentially writing tests from the outside in and BDD tests force you to start with a problem and not with a solution. I don’t necessarily think BDD is mandatory, but it’s a good tool that can help. 
[removed]
Volume slider memes in r/programminghumor
Here's a sneak peek of /r/programminghumor using the [top posts](https://np.reddit.com/r/programminghumor/top/?sort=top&amp;t=year) of the year! \#1: [Click here to go to r/ProgrammerHumor](https://youtu.be/dQw4w9WgXcQ) | [40 comments](https://np.reddit.com/r/programminghumor/comments/7hkfwg/click_here_to_go_to_rprogrammerhumor/) \#2: [She said she works in IT and was looking for a gentleman...](https://imgur.com/bXAZCKV) | [7 comments](https://np.reddit.com/r/programminghumor/comments/7vq07a/she_said_she_works_in_it_and_was_looking_for_a/) \#3: [Best StackOverflow response to a solution I have ever found](https://i.redd.it/x5kvq9ns2jn01.png) | [0 comments](https://np.reddit.com/r/programminghumor/comments/86lbm4/best_stackoverflow_response_to_a_solution_i_have/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
I think it's best to choose a term based on whether its definition fits rather than how good it sounds. Don't you?
Nope. I've made changes to the code(you can see these in my response to /u/Natryn 's comment) and now I'm even more confused.
Yes. 
I've made a similar program that adds two numbers inputted by the user and its based on the code from this video: https://www.youtube.com/watch?v=e57ReoUn6kM&amp;t=452s (skip to 7:32 for the code). I've made changes and this is now the output: http://www.ezimba.com/work/180819C/ezimba18977669671700.png And here are the changes I made to the JS file: http://www.ezimba.com/work/180819C/ezimba18977691297400.png Dunno why it calculates the sales tax with so many decimal places, and why the grand total isn't calculated at all, or why it prints the element of the object.
stupid bot
Sigh, another shrill, cold, boring business man. It's built for fun, and could be used for a few different things in fun apps if you put your imagination to work.
 &gt;Also about comments I've seen about "it slows down when doing something new" I agree with your comment and also wanted to emphasize this bit. Anytime I hear developers complain that TDD slows them down, or that paired programming slows them down, I try to make them understand that **that's the point**. Writing code is not a keyboarding sport, and developers shouldn't get paid based on the number of lines of code they generate. They get paid to solve problems. Coding does not solve problems, it records the solution to a problem that someone already figured out. Solving a single business problem can often be done by one person fairly well. Fitting that solution in with all the other solutions takes team of people. The more problems a program is responsible for the more complex a program becomes, even a very well written one. A team with a good TDD discipline forces the developers *to slow down and think through the problem repeatedly*. A well coded solution that took 2 weeks is more valuable than the easy solution that took 3 days and then had to be hotfixed in production twice because a something got overlooked.
Write an app with sails.js, decent documentation, mvc, orm, templating for front end, node all in one package.
Using a string tag, like you are, is the best way to handle this I’m aware of. I’ve used the [dedent](https://github.com/dmnd/dedent) package in a few projects, and from a quick glance it is more or less the same as your preformatted package, so your solution is fine.
It's a great project as someone's first open source project(by the way, this is my first reddit comment too) , reminding me that, when I was a front-end beginner, I wanted to do the same thing like this, pity, I didn't insist on it, however, you did it. I've read your project and its source code(structures is similar to [swiper.js](https://github.com/nolimits4web/swiper) in some way, I guess you might refer to some of it but it's reasonable), here are just several advice which may be helpful: 1. Put the demo in GIF form on the README, telling potential user what features this project has in most direct way 2. Use latest stable technology to write and maintain your codes, using es6(and es6+), webpack, typescript for example. I benefits a lot from these technology(recently, I have been writing a canvas library [Draw](https://github.com/Terry-Su/Draw) used in company by using typescript, typescript helps a lot).
Strictly backend devs seem to take to angular2+ well through it's use of typescript and observable pattern. I like angular, it isn't as hip or cool with the kids as react or vue, but it can do anything that they can, and doesn't make you worry about your stack so much. That being said, I don't know any great angular courses or tutorials off hand, and Google's docs are kinda shitty, whereas I could recommend a bunch of react series and Facebook's documentation of react is top notch. 
The animations are likely css3. They'll always be smoother than js animations.
So, I'm gonna give you a bit of advice that a lot of people here might disagree with. If you want to be able to write professional JS, regardless of what task you're given, study algorithms. This applies even if it seems really hard, and isn't related to a project you are excited about. In most college-level Comp Sci programs, the algorithms course is absolutely hated by freshmen, because it requires you to break down problems in ways that the human brain doesn't usually consider. At my school, people almost universally failed their algorithms homework assignments for the first quarter of the course, because their brains hadn't rewired yet. Until you solve enough problems with specific tools like recursion or breadth-first search, it's really hard to identify how to abstract a problem into the right simplified view, and which problems are best solved with which tools. This doesn't mean memorizing how to write Djikstra's algorithm or a Splay Tree, but it does mean being able to recognize when you are looking at a problem that is really an abstraction of a "shortest path" problem, or a slight modification of binary search, and it does mean being able to rebuild some of the basic algorithms in your head, when needed. The other benefit is internalizing an understanding of how to measure the comparative performance of algorithms. After all, it's no good writing an algorithm to solve a problem, if it will take 37 years to run. I rarely write the exact data structures or algorithms that I learned in my algorithms class, but I write things based on the same core concepts every day.
r/https://npmjs.org/package/common-tags
Honestly js is such a saturated market maybe if it doesnt click with you you move on to another language. Try SQL ... just being great at that will get you a job in almost any us market. 
I write tests when I'm waiting for QA to respond with feedback. I try to have 100% tested content, but only if I have the "downtime" to work on it. It's great for Fridays after lunch. Can't ruin anything, seems productive, not a lot of brainpower used, great way to end the week. I think sometimes when I'm writing a test for a piece of code it gives me a chance to review if it's the most efficient way of preforming that task as well. So that helps also
Thanks. That makes a lot of sense for ui based applications because the output in the end is html/jsx which is declarative and easy to see from debugger. But how will it help for transient things? For eg. make a api call, calculate something more based on response, put it in redux, which passes it to props of some components. Or a plain javascript library where the output can be just a number, but the steps necessary to obtain it are many.
yeah I restart it thanks. There is still somethings that makes it crash sometimes - im working on it (:
you don’t actually need www so idk whats happened there lol 
Right, that sounds good to get someone up to speed. And giving a new related project, helps them learn the processes without learning the complexity of the existing thing. But at some point you'll surely need to introduce them to the existing codebase, right? What happens then? How do you explain the flow of that code? Are documentations enough for this? Yes, everyone will have different questions - even for the existing project. But what I have felt is that usually you'd still need to show them the common flows and answer the doubts.
Really nice.
Hi /u/Tomer-Aberbach, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Check out CSX by CodeSmith. Go to local meetups with react and JS developers. Start working through challenges on your own without any assistance. Once you finally finish a tough challenge on your own it is such a satisfying experience and keep at it. Grit is what makes you a good developer. 
I use JSDoc comments for type information. I use VSCode as my editor and have it set to check my JavaScript with TypeScript. I use the user setting: "javascript.implicitProjectConfig.checkJs": true. This tells VSCode to check the JavaScript with TypeScript. Because I use JSDoc to document my types, it works out perfect. No need to TypeScript typing--clean JavaScript with the same type safety without a build step. It also provides fantastic intellisense for my JavaScript, as well as code completion, symbol renaming, refactoring, improper type use, param info, type casting and code peek, etc., just like with TypeScript. So basically plain Jane JavaScript with static typing type safety.
I have never seen a useful test in Javascript that wasn't there for the sake of it. I am now accepting downvotes.
Umm, why would your code fail on compile by itself? Say, if you do \`\[\].randomStuff()\` will your code fail on build without typescript?
Right so I will write the animations in Css and add and remove classes through the DOM depending on where on the user is? I think I can do this! Thanks alot 🤗
Awesome! Had no idea this existed. Thanks for the heads up.
This is great. I knew there had to be a multi-line template literal library out there, somewhere!
Npm is built on node hence the dependency. But once you've installed npm and node the packages do not need node to execute in the browser. Caveat, some do but most don't. 
I’ve been using Mithril for over a year now and I left both Vue and React behind after implementing it into an internal application. I noticed just how much of an overkill React and Vue were for most applications I was developing. I look back at some older projects in production I have using Vue and its just fucking embarrassing with all these dependencies and bloat for something I could of done using Mithril and a bit of Vanilla in a day, a quarter of the size and 4x the speed. Mithril has been vigorously thought through and will suffice quite well unless you’ve got a team of 300+ developers. It’s a very intelligent and powerful framework, regardless of your apps complexity it will handle almost anything and being able to write HyperScript is a fuck more productive than JSX. I can only say good things about this framework, the community behind it and the core team. 10/10 
This is great! Thank you
That's how I've implemented it. Is mobile Chrome on par with Chrome 68 yet?
Thank you for inspiring comment :) It is true sometime I am referring to swiper.js. Also thanks for your helpful advices. But I am using rollupjs, because read some articles where is said that rollupjs fits better for libraries than webpack.
DRM to prevent theft.
Theft of what?
App being copied without effort? Such as a game? Or offline ML processing, where you have a dataset that is your competitive advantage? I don't want someone to copy my app without doing the research all over again. If I put the effort and risk to make the app, I would like to make a profit off it for a long time. My definition of theft includes Ctrl + C and Ctrl + V. Just because you make copying easier on the web does not mean R&amp;D and risk costs are eliminated. Tell me one FOSS consumer app that was a unique idea. All of them are copycats. Proprietary applications create an incentive to experiment and take risk because you might make a profit. 
Doesn’t work for me. Says “one moment please” then that disappears but no link appears.
what link you put in? 
https://www.fusionofideas.com
But there is no back end portion built in to my knowledge. You still need Express or something with a web server right?
of course! I thought maybe the server went down but nope - and other links works. That’s strange but hey - stranger things happened in programming lmao 
so I cant see why its not found the site (could be because of the why they load it or something) anyway - after some change I did , I created a bug that break my app when it cant find a site - this is why it didn’t showed you a msg about it. Anyway it should be fine now. You wont see this site - but you see a msg about it! lmao
Yes. Angular is just a frontend framework
If the component renders, it has to evaluate its render function. I don't think there's any way to prevent a specific component constructor call within that render function.
Yes, basically. Here's my use case: I have a form with inline error messaging. Whenever the user fails to enter either their username or password, an error message appears beneath that field. The problem is that the error is rendering cumulatively for every time it occurs. So, if I'm a user and I repeatedly attempt to submit the form without entering, say, my password, beneath the password field will be an error message reading "Password is required" for *each* time they've attempt to submit the form without entering a password. 
Looks like something in its own right? From a glance it doesn’t appear to be Angular or Vue related at all. 
It sounds like the problem is in MyComponent (or whatever your equivalent is).
your probably right. I guess i will just get to know this framework then :)
I'm sorry. The guy doing this works with JS and I'm just a computer illiterate investor. I don't want to get duped. Basically we have an app and site with it's own tech. Imagine it was at the scale or similar to uber. Since his site and apps were built with tech in mind we have no user traction. All money was spent on build. Now we want to launch a global version and attract other investors, but if we want users American customers and investors might be wary of signing up to a company that's registered in south Africa and we need new user traction in America. So we want to relaunch apps and site under a new name. He is saying it will cost a lot of money. I'm not sure why. I'm assuming all one had to do is copy or point servers and databases etc from point a to point b. 
these two are seperate, how javascript works as a language and how the dom works fro how js works, kyle simpson is a good source. he has free books online and has multiple video lectures on frontend masters i have never found a good source for learning the dom, i would go to devdocs.io and read the dom documentation there, carefully. You can also find a few channels on youtube that have decent dom coverage, if you search for the right terms you will find some
Well its 20k lines that jump around all over the place. Pretty hard to track with ur eyes 
Without more information, there could be a few reasons why this would cost more... 1. More users = more traffic = more or better machines. 2. If your application is similar to Uber and has a lot of user interaction that you want to perform well, you want your servers to be located close to your users. Setting up servers close to your users means more machines. Maybe your dev is hosting things in SA on the cheap and hosting in NA is way more expensive. Now I don’t know of any technical reason you couldn’t host in SA but point an American domain at a machine in SA, but in addition to potential performance issues, anyone with technical skill could perform a WHOIS query in your domain and see who it was registered to and where, but also see where it points and could find out it was hosted in SA - not sure if that would be an issue to you. So aside from all of these infrastructure related reasons, it could just be a poorly developed app and making it work with a new domain might be a serious problem somehow. Or maybe you’re also talking about a complete rebranding of your product? There are far too many unknowns here.
Please tell me what you need to know and I'll do my best to explain. Yes it's a rebranding. No we dont have users. It's just a supposedly well built app with a great backend of tech. I can't have users signing up to a SA site in USA. Most likely won't work. Secondly, explain in your own terms how this would happen. Break it down for me please. 
so if i learn this framework, i will be able to pick up vue and react?
'Not worrying about your stack' in this context means you don't have to make other decisions around things like what model/state container library to use.
I would suggest you ask your dev for an itemized cost breakdown. If it’s all in development time, then something shady might be going on. If it’s in rebranding design time, that’s not improbable. If you literally only care about the domain the user sees in the browser address bar and not where the data is physically located, then there should be no dev time and like 10 bucks for the domain. But even if it’s all in dev time: If the application works with sensitive data it may have additional privacy requirements and regulations or even need to be stored in the country of the users, which could be another reason for more servers. If you are talking about working with the UK or anywhere in the EU instead of the US, they may need to do development work to meet the requirements of the [GDPR](https://en.m.wikipedia.org/wiki/General_Data_Protection_Regulation). If you work with health care data, in the US you would need to be compliant with [HIPPA](https://en.m.wikipedia.org/wiki/Health_Insurance_Portability_and_Accountability_Act). I might be overthinking it.
Non-Mobile link: https://en.wikipedia.org/wiki/General_Data_Protection_Regulation *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^205819
I assume you’re talking about mobile apps. There is no cost associated with hosting mobile apps, although you would need to deploy a new version pointing at the new domain name with the new branding, so I can’t think of many reasons that should be an issue. Another conflating issue might be if you want to maintain two code bases for both your website and mobile applications. If you want to rebrand the app and deploy a second copy and keep the old one as well, you have two choices: every time you fix a bug or add a feature you have to do it twice, which can lead to more bugs and inconsistencies between sites/apps. *Or* there is significant rework required to make the same code base work with multiple brands your site and mobile app.
&gt;If you understand what `this` is, and how `.apply()`, `.bind()` and `.call()` are used, and what closures are, well you're miles ahead of many developers I already work with Given these are considered elementary knowledge, which would be assessed during a recruitment interview, this raises the question : how did the many developers you are working with even made it through the interview ? 
if you test it now - it should be fine without www. Let me know otherwise (:
You could always try actual Vue. If you want pre-built components, there’s a library for it called Vuetify. 
Can you define "going nowhere" ?
Personally no. I just don't encounter many situations where an asynchronous task failure can't be handled better with a useful error. 
All languages have abusable parts. JavaScript might have more than most but that doesn't mean you should flat out refuse to use destructuring. It just means you should use it responsibly.
MDN is a great source for learning the DOM.
I'm tempted to give this a try. Looks like it's bringing the best bits from a number of key tech I love. 
How is `MyComponent` rendering "My component's output"?
https://masstagger.com/user/MYHEADHEARST
morally ambiguous websites will get morally ambiguous requests lol
A decent error message is going to tell you more than a stack trace _except_ when the error comes from outside code. I don't think the fact that is asynchronous should be a major issue unless you aren't handing those errors gracefully
That's a thing of beauty! Nice work.
If you are just starting out and looking to get into JS, I would say you really don’t need to download WAMP. Most JS frameworks like React, or Angular will run off of Node.Js so download that. If you download Node, you can then use that as your live server for most of your JS testing/projects. Also, most JS frameworks like the ones mentioned before will give you a shortcut to starting up the server and running your app like `ng serve` in angular. 
Possibly, could you fake a code snippet of the final product? That would help.
If generic runtime errors like “Cannot read property of undefined“ you try to find the root cause from stacktrace
Everyone is concerned with that components render function, but this may be happening in the patent component. Any arrays of components being rendered? Fishy stuff like this happens with arrays of components with bad/missing key= props.
When I use react I set the state with a showError and when it changes to true it shows the error. It’s the same component in those cases. Are you evaluating something else not in state that is mounting a new instance of your component each time? In which case you need to work out how to unmount when there is no error.
[link to library](https://github.com/sagiavinash/with-stacktrace/blob/master/README.md) . I want to improve it to support more asynchronous ways like callbacks etc. want to know how developers can benefit from it before implementing it
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sagiavinash/with-stacktrace/.../**README.md** (master → 194b77d)](https://github.com/sagiavinash/with-stacktrace/blob/194b77d9da3fb8405eac40966775c244838f05a0/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e4gmsd5.)
Of course you do. Things like NGRX, NGNS etc. There's tons of those.
The problem is obviously not someCondition &amp;&amp; &lt;MyComponent /&gt; } The problem lies higher up in your code. Could you show us how your using this exactly? 
You should probably be more specific about what you are trying to do
If you're just getting started, you don't need to download anything. JavaScript runs in the browser. PHP needs to be installed but then runs on your computer.
Glad to help
Maybe as a dev dependency for debugging. I would not check it in to my production code.
wamp/mamp, php, apache, worpress are all bundled together, they represent a away to get started with back end/server side code. as for a simple web server there are many options, serve from npm or simpleHTTPserver from python are very common, there are also ruby servers ive seen people use. Many different versions of doing the same thing, which is running a simple localhost server to get around browser restrictions
Totally agree on this, UWP is a really good idea. React Native and NativeScript has started to bridge that gap a bit, but not nearly as nice, still requires quite a bit of configuration.
&gt; that doesn't mean you should flat out refuse to use destructuring I don't nor did I recommend doing that. https://old.reddit.com/r/learnjavascript/comments/98diwl/destructuring_why_set_2_variables_at_once/e4ge2i1/?context=0 See the last example there? That's what I was talking about. I would have preferred if they'd chosen dedicated syntax for doing that. Other languages do this better.
I'd highly recommend giving it a shot. I've been using it for a rest endpoint and it's been a real pleasure to work with. At the very least I'd recommend reading through the [overview](https://docs.nestjs.com/first-steps) section in the doc. It covers the main features of the framework (:
I'd highly recommend giving it a shot. I've been using it for a rest endpoint and it's been a real pleasure to work with. At the very least I'd recommend reading through the [__overview__](https://docs.nestjs.com/first-steps) section in the doc. It covers the main features of the framework
Board game scoring? 
This looks fantastic. Nice work!
Thanks Buddy! you have a sample I can try and see how it works? 
I changed my job two times and both of them was React.js spesific in terms of front-end development. There are lots of react opportunity in my country, and then angular follows it. A react.js junior must know react api (which is really small) redux integration and of course how the web works. When you get the core concept, its easy to adapt all technologies.
You need to install Nodejs, and in the video he install packages with npm command line For example you install a package npm install jquery In the root folder be create a folder called nodes_modules into this folder o project jquery Take a look, into a Nodejs course basic you will find in YouTube It's important you know how node work and the importance of the package.json file. https://www.w3schools.com/nodejs/ 
Mandatory? More like purgatory.
Hi /u/amotz1, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
You dont need to do anything.
Does this work for offline apps, or does it require internet access to do on the fly translations? (Are the translations done in advance and stored with the build?)
At what point does the #1 most in demand web technology multiple years running go from being “for hip and cool kids” to “current industry standard”? React has been dominant since 2015.
This was written this month but is using Adonis 3 when 4 has been out for a year now. V5 is under development. 
&gt; Such as the class keyword but then you are not getting what you would expect from a class Kind of depends on what you are expecting from a class though. Classes are different in different languages.
“- Bug fixes and improvements” lol At least the app tells me I can’t use it now haha. Maybe it would be a fun exercise to work on this edge case if you’re ever bored. Nothing like a good deep dive through code to get the blood flowing ;)
tbh it pushed me to write some test units to the app so only good things from this link lol
Not sure why snarky fanboy comment was necessary. There is no dominance, there is choice.
Boy, you sure got upset!
Reactiflux. It’s more generic than react.
I never before used Babel. Is there any advantages to use another dependency ?
Wow - Brilliant job on both the library, and this Well written walk-through!
That's just a dev dependency. The code that gets shipped is already transpiled into older/more compatible js. It might add a little bit of extra size so that's the only disadvantage for the user. On the flip side you get to write JavaScript of today/tomorrow depending on what you decide to use. And since you'll be using build tools you might add more cool things while you're at it.
RX.js(Reactive Extensions) wasn't designed for angular it was designed as the mathematical dual of IEnumberable&lt;T&gt; which is a (extremely popular)C# API for dealing with collections. So yes, it's worth it. You can use RX to make some tasks that were traditionally hard trivial. 
SSR?
Been rewriting an old system in NestJS, TypeORM, and Angular and it's going well. Took time to get familiar with typeorm and nest, but I think as a whole they work together quite well
Honestly starting out download atom sub lime or vs code then you can run it in the browser 
He wasn't saying that it replaces a college degree, he was saying that the indicators you get from an activate GH are similar to those a college degree provides. Basically, its a good sign if a candidate has one, but not fatal if they don't. And yes, I have had several interviews where an awesome GitHub profile has been one of the deciding factors – interviewees coming out of bootcamps and/or those that don't have degrees can show me that they can actually code via their GH and make up for their lack of job experience or degree that way. \&gt; Github quality is definitely overrated I have no idea what you mean by this. If someone can show you that they can create well-crafted projects or have the skill to contribute to open source projects used by other engineers, you'd be a fool to ignore this indicator and are probably missing out on some quality hires.
It's over-rated because it's typically not an indicator of anything. There's a higher chance that a gh profile will be a detriment to your overall application than being helpful in my experience
Most likely I'll do that. But I need more knowledge to make quality package.
Looks like a very cool library and a great writeup to boot!
Reading your replies gives me the vibe that you maybe shouldn't be writing frameworks at your current level of expertise. Maybe as an excercise - but then there are more fruitful endeavors for teaching yourself I think.
An empty GitHub is not an indicator of anything, positive or negative. A full one tells me about a user's coding style/quality/skill and where their CS interests lay – all of which is valuable information which helps form an opinion as to whether or not I want them on my team. If you think your GH profile will be a detriment to your application, don't include it. That doesn't mean that interviewers should ignore it/the signals it provides when applicants provide it to us. 
Personally, I write tests when I'm dealing with a complex piece of functionality, I don't feel I fully understand. The tests makes sure that fixing one edge-case, doesn't break the one I fixed previously. I can't attest to the usefulness of maintaining a test-suit. Although, for all I know, they might indeed be very useful for some types of applications. IT is full of people who's primary talent lays in throwing around buzzwords, but who are otherwise grossly incompetent, and may not know even the very basics.
This. React doesn’t work like the way OP is making me think they thinks it works
&gt; So why not take a step further and make your form vibrate when the user inserts invalid username, or when an error message appears... It even can be more fun when your vibration theme is GO GO Power Rangers. Oh hell no
If the intention is to make it for public use I agree, but there's a no harm in creating one for personal use to solve specific problems. The original question of 'what should I add' seems a bit unproductive though. I would build something solely using your framework and then when you have a problem you need to solve, add something to the framework to do that
 exports.delete_rating = (req, res, next) =&gt; { const id = req.params.ratingId const currentUserId = req.userData.userId try { const result = await ratingsDatabase.delete_rating(id, currentUserId) res.status(200).json(result) } catch (err) { res.status(500).json({error: err}) } }
Thank you sir. How may I buy you a coffee?
Basically, you want to replace `.then` with `await`, something like this: // delete a rating exports.delete_rating = async (req, res, next) =&gt; { const id = req.params.ratingId const currentUserId = req.userData.userId try { const result = await ratingsDatabase.delete_rating(id, currentUserId) res.status(200).json(result) } catch (err) { res.status(500).json({error: err}) } } Btw. `.json({error: err})` will just return `error` as an empty object, instead you want to delegate the error serializing to the error handler: } catch (err) { return next(err) } This is a good error handler that returns json: https://github.com/expressjs/api-error-handler
I think we got off on the wrong page or you are taking what I said as gospel or Im telling people to not look at GH profiles. To each their own as far as interview style and approach but anecdotally GH profiles have never influenced my decision in a positive light to date, not in regards to a final hire. In fact, I've had anyone in any panel that I've been on say something like...yea that interview was terrible but they have great react code in their GH lets hire him...
Agreed. Also, looking at what's in his readme so far, it looks more like a jQuery like utility library than a proper framework. 
Yes, it is server side rendered.
That's a good tip. I will check that out. At work we just dropped migrating to TypeScript for some complicated reason. But this seems like a good compromise. Everyone on the team uses VSCode, so this should be easy.
That’s a PHP app not JavaScript
the function that has an `await` needs an `async` identifer in front of it exports.delete_rating = async (req, res, next) =&gt; { instead of handling a response in a `then` function, you `await` it and treat it like a blocking function call. and instead of having a `catch`, you wrap the whole thing in a `try/ctach` try { let result = await ratingsDatabase.delete_rating(id, currentUserId); res.status(200).json(result); return result; // it's best practice to return promises } catch (error) { res.status(500).json({error}); } 
You must know from experience 
I made an Node cli app that lets you automate shitposting on Instagram. The \`Instabot\` cli will let you: * Repost memes directly from Reddit onto Instagram * Post custom Instagram posts { image, caption } from the cli * Automate following users from your suggested users list [https://www.npmjs.com/package/instabotjs](https://www.npmjs.com/package/instabotjs) [https://github.com/fermidirak/instabotjs](https://github.com/fermidirak/instabotjs)
Depends what your needs are. I've done a couple sites with SailsJS with a view templating I engine. But currently the company I work at I'm building a multi-tier app with Sequelize as an ORM (to manage and generate migrations, seeds, and as an ORM), ExpressJS for the backend with GraphQL on top of it to manage requests with a standard schema, and React frontend. Jest for testing. Might have forgotten small stuff in there but those are the major hitters. 
That it gives redditors something to talk about online and keeps them off the streets.
[removed]
Does it auto hydrate SPAs or is it only server?
ty
I have not used NextJS but this is fully SSR out the box. NextJs introduces some restraints. I understand that it simplifies SSR but it forces you to change how you work and write code in your React projects. For example, the need for a pages directory or even the way you handle simple things like linking or implement other existing libraries. SSR isn't that difficult to achieve manually and if you think about it... any app written with NextJS is going to heavily dependant on it (which isn't ideal long term). I don't think there is any thing wrong with doing either but personally it isn't my preference. Please see the YouTube tutorial which I linked to on the README section for a better explanation of how it works.
Why not just stick with promises? Async/await is just a sugar for people who are scared of functional programming anyway. 
It just makes it easier to maintain. Even promises can get into a nested callback-hell-like situation, and try/catch is a much more natural exception handling mechanism than promise.catch or whatever it is.
Async await ARE promises. It doesn't replace promises. It replaces `then`. It also isn't about functional vs OOP.
Liking easy to read code is me being scared of functional programming? Also, maybe do some research first before you start shit posting. You obviously have no idea what async/await is. 
You don’t know what you’re talking about. Stay in school, kid.
I didn’t say async/await didn’t return a promise. I said it’s a sugar over promises for people who are scared of functional programming. Both things are true. If you stick with this programming thing, you’ll probably learn that, eventually.
You think that because you’re not familiar or comfortable with functional programming. Async/await adds a ton of noise to your code. If you’re encountering “callback hell” with promises, it’s a sure sign that you’re doing something wrong.
I’m not sure if that is the case, about being scared of functional programming. When you are working on any type of corporate code base most of the time there are other devs cough offshore that have no clue what’s up. I would be more than happy to see async await used over an async piece of code and then a sync piece of code being used right after from the lack of knowledge of incompetent devs. Plus why are you being so harsh on this guy, it’s a dev community, let’s help each other not degrade
Maybe consider Yarn.
You're a cocky shit, you're asserting opinions as facts, and jumping to conclusions with very incomplete information. Grade D.
Hi, sorry for being vague. The grid itself is not the problem, that I can figure out with some CSS as you said. But what I need is some comparison in Javascript(I guess???) which will check for the class's ID variable, and for example: If ID == 1, I will just print out that instance of the class.
Yep i actually added that feature and i mentioned it briefly in the blog post
I just mean that &lt;div id="1"&gt; isn’t going to work because it’s against the rules. You’ll want &lt;div id="item_1"&gt; instead. 
Why am I being so harsh? Because he's a fucking clueless twat who's going around telling people that they don't know what they're doing and need to do research when he literally has no fucking idea what he's talking about. That also happens to be about 90 percent of this subreddit. And you realize that you're completely backing my point that async/await is a useless sugar for people who are afraid of functional programming, right? And, yes, I agree. "Scared" isn't always the right word. "Stupid" is often more apt. So, to try it again, async/await is a useless sugar over promises for fucking idiots who don't know how to program. Better? Want to help people out? Maybe spend your time working on those incompetents that your company hires rather than coming to the defense of losers who like to run their clueless mouths on reddit? 
Pretty cool idea!
You know what also is important when hiring? Working well with others. 
The problem is that vanilla and declarative views doesn't mix or match well. Hair stands up even thinking of having to animate raw dom nodes with refs and queryselectors, jquery/gsap added on top. What's even more troubling, that vanilla is actually the thing that's short lived and tied to the web alone, whereas a specific lib is cross platform and can be used anywhere: web, vr, desktops, etc. For instance, i'm the author of a popular react animation lib ([react-spring](https://github.com/drcmda/react-spring)). Now you can take this and animate anything, [for instance your shell](https://twitter.com/0xca0a/status/1000513216672403456), or mobile apps. And this is the brave new world, v=fn(state) is probably more of a standard than any vanilla web spec ever set out to be.
Why are those the only two options
Great article! I'm of the mindset that every front-end should have i18n (whether it's translating on the front end or using a server-assisted service) as in many cases today, it's not too difficult to add. Especially in the case of JS, most if not all major frameworks have libraries to enable translation and locale detection. For anyone who's in need of an actual translation service, I've used https://poeditor.com/ on a few projects (which includes ai-powered translation if you don't have the financials to support humans - free credits let you test if it's ideal for you and buying more is relatively cheap).
Vue CLI 3 bugged for anyone else? My (Chrome) Vue DevTools show roughly 1/3 of the time, usually it's just empty with no content and I have to reload the page a few times, which results in losing my stored data and edited forms. I've never had this problem with Vue CLI 2, however I'm always using the newest stuff in order to keep up.
Why are you being such a dick about it?
FCC will give you a nice basics 
Love that haha!
W3schools
[removed]
Go straight to the "You Don't Know Javascrip" series from Kyle Simpson https://github.com/getify/You-Dont-Know-JS. Heavy read but very complete and will make you know the language with it's pros and cons.
I recommend to check paid video courses on Udemy for beginners. You can google an actual coupon for the price $9.99.
Try JavaScript.info
I really like the one by Colt Steele. Highly recommend 
&gt; why not just stick with promised
What about Vue and angular as lighter alternatives to react?
There is only one way to really learn JS or any other tech you want to get skilled in: 1. Get familiar with the basics - Go through a book, “You Don't Know Javascript” is a good one. - Your goal is to know the building blocks of JS. - You must be able to understand code and read it. - You must know how to write simple stuff. - Write up every example in the book and tinker with it. Reading is not enough. This will give you a feel about stuff, and occasionally you will find something you would have missed just reading through it. 2. Start doing some personal projects - Start with small stuff, then go for more challenging problems. - Trying to solve problems will give you a real world experience with the language and you will start to encounter holes in your understanding. - Learn from you mistakes. 3. Read up on community posts and articles - People go in deep on certain topics that you will probably ask yourself what is the best approach with. - Find them and learn from them. - Find resources for articles and regularly scan for interesting topics. - At first you should be reading everything you get your hands on. You will start to notice patters in the thinking of the authors and start to adopt that. This is good because you will develop an understanding of good coding principles and values. Depending on what you want to do with JS you should investigate and learn frameworks and libs that would help you accomplish stuff faster and easier. But don’t start with them. Learn the language and try to solve problems for yourself. This way you will develop your skills and really learn to code. As you can see I haven’t told you what to learn but how. When you got forward enough with reading, learning, coding you will be able to make your own decisions about what libraries, frameworks, coding practices and approaches. Good luck and don’t give up, the road is long and hand, but well worth it. 
If it only needs to be run once, make it a module that exports the value, then you can just import the response in components that care about it. 
StackOverflow
Welcome to programming related subreddits! If you can't prove your (self-presumed) superiority in an obnoxious way, these aren't for you.
w3schools is ok for beginners
www.javascript30.com
lots of free courses on youtube
Javascript. Understanding the weird parts.
Yep, this. Wes Bos, the course creator, also shares a lot of tips on Twitter.
Please keep in mind: Learning JavaScript != Learning programming You can absolutely learn JS in 30 days. There's however no way to learn programming 30 days. I'm getting paid for programming since about 10 years and only recently started calling myself "good". My point is: when it comes to learning programming itself, look beyond articles for JS.
Yup, I used to use TypeScript, but now I just set VSCode to directly check my JavaScript. I write ES6 and run it through Babel. Nice thing is you get all the benefits of TypeScript while coding, intellisense, etc. One thing you do have to do is occasional type casting. In JSDoc that kinda of funny. For example, say you have some code that gets a DOM node and you want to add an attribute. With types you can't because type Node and type Element are different interfaces. Type casting is the solution. In JSDoc is it more verbose than TypeScript and friends: /** * Function to add a class to a node. * @param {Node} node * @param {string} className * @return {Node} node */ function addClass(node, className) { // JSDoc type cast from Node to Element: /** @type {Element} */(node).setAttribute(className) return node } You can use @typedef to define custom types, and you can import types from es6 modules for reuse: /** * Function to turn a vnode into a DOM node. * @typedef {import('./node').VNode} VNode * @param {VNode} vnode * @return {Node} node */ function createElement(vnode) { // Do stuff here to convert vnode to DOM node... const node = vnode return node } Here's information about turning on type checking for JavaScript: https://code.visualstudio.com/docs/languages/javascript#_type-checking And more detail information about using JSDoc for type information: https://github.com/Microsoft/TypeScript/wiki/JavaScript-Language-Service-in-Visual-Studio#JsDoc And this link for currently support JSDoc type features: https://github.com/Microsoft/TypeScript/wiki/JsDoc-support-in-JavaScript 
I recently signed up on SitePoint for $9 per month. Must say I really enjoy their courses, ebooks and articles and they have a lot of resources for Javascript. If you don't like it, you can cancel any time. They are cheaper than most other online course sites out there like Egghead and I find it very helpful to go through their courses and ebooks instead of trying to figure everything out from raw JS docs. the docs are great once you've had a bit of an intro to JS and for $9 per month, I think it's a bargain!
As you can see there are countless resources to start, just stick with one and don't look back. The question you ask is no doubt a loaded question, and there isn't a one all be all answer. Start somewhere and most importantly have fun. 
Aaaahhh, good ol' copy/paste driven development!
Is there another development way?!
And his podcast Syntax.fm, is a great source of knowledge.
One of the very best resources I've found about learning basic JavaScript properly is Code Maven: [http://www.crunchzilla.com/code-maven](http://www.crunchzilla.com/code-maven) It starts out with fundamental programming concepts and ends up, at the end, teaching things like draw loops and physics simulation for video games. I use this tool to teach my students. If you want another good bottom-up way to learn JavaScript, I also recommend ["JavaScript For Kids" by Nick Morgan](https://nostarch.com/javascriptforkids), published by No Starch Press. By its title it seems like a kid's book, but it's perhaps the best book I've found to teach any age level programming the \*proper\* way with JavaScript. These two things are well-scaffolded, so you'll learn important concepts as you go, and won't have to muddle through online resources. Once you have them under your belt, you can easily move on to ES6 related stuff (which is the bleeding edge of JavaScript today) and it will make sense. :-)
If u like videos my favorites are derek banas, traversy media, the net ninja and thenewboston, all on youtube, some of the content might be older but still very good.
No way is this a good resource for beginners. He just shows you the code basically, without much explanation. 
Sign up for [Treehouse](https://teamtreehouse.com/) tutorials. I followed these on the bus to an old job for 6 months and then got a job as a junior dev :D
https://www.codecademy.com it's my favorite place to send people who are not familiar with programming and want to learn JavaScript. 
This is a great place to start... And after you get familiar, there's a great course in udemy: understanding the weird parts (i think that's the name)
The thing I like about this series is that you actually build interesting things. Even if you don't understand every single line of code from the get-go, seeing that it's possible to build useful and interesting things without a ton of code in JS can be really motivational.
Did you take a look at GraphQL?
http://eloquentjavascript.net/
This takes you from being bored using console log, to building interactive apps. Even beginners will pick up tips. 
Hi /u/_gnx, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `wanago.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [wanago.io](/search?q=%28and+site%3Awanago.io+author%3A_gnx+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|33|92%
What kind of server is it? That’s so vague. 
[The Modern JavaScript Bootcamp (2018)](https://www.udemy.com/modern-javascript/) by Andrew Mead on Udemy is a fantastic course. [Free Code Camp](https://learn.freecodecamp.org/)'s projects and challenges are an excellent resource too. Good luck on your programming journey! Code every day, and never give up.
The web will be piped directly into our neurons. No need for keyboard, mice or 3D goggles. Google and FB will track all of our thoughts and will make buy stuff we don't need.
Not everyone learns well from books. I followed this advice and lost interest over and over. I’ve still never finished it, but I’d give anything to go back in time and get myself on codeschool and udemy. 
All the good resources have already been mentioned, just wanted to add that from my experience, learning new languages always worked best when I had a specific problem in mind, that the new skill set would help to solve. 
Maybe the [Notifiation API](https://caniuse.com/#feat=notifications) is what you're looking for? (combined with a XHR that checks your server on regular basis)
I agree he even states that you need to know basic JS before starting. Definitely a good course to come back to after someone has the basics under their belt. &gt; Beginner to Intermediate developers and designers who want to become comfortable with both JavaScript fundamentals and working in the DOM without a library. You should already know some JavaScript to start - This isn't a JavaScript 101 course. We learn by application - encountering many new situations while talking about the hows, the whys and the whats that we use to solve them.
https://www.ashot.org/links.php I've been gathering some online resources to learn things like programming, cyber security, and machine learning. Not sure if they will help you the same way they did for me but here it is.
Practical Javascript by Gordon Zhu - [https://watchandcode.com/](https://watchandcode.com/) Hands down one of the best JavaScript beginner resource out there. He explains things in a very easy to understand way and the concepts are not strictly for JavaScript but also for programming in general. One thing that I appreciate most from his free course is when he introduced the use of the Debugger, that one certainly takes you up a notch in debugging your code once you are able to utilize it properly. There's also a premium course that you can take after the first course, I haven't taken the premium one, though I'm certain that the free one will definitely get you going on the right path. Other resources/course that I'd suggest are: \- [The Complete JavaScript Course](https://www.udemy.com/the-complete-javascript-course/) by Jonas Schmedtmann - $10 Udemy course for basic to advanced JavaScript (includes coding challenges, dev resources, and simple to advanced real world projects) \- [MDN](https://developer.mozilla.org/bm/docs/Web/JavaScript) \- Mozilla Developer Network - You could learn a lot from here specially when you're trying to understand specific concepts like how a "function" syntax works, how you can loop through an array using the standard "for-loop" or by using array methods like "forEach" or "map", etc. Really, refer to this one often when you're googling for a something native in JavaScript or the Web in general (HTML/CSS)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://developer.mozilla.org/bm/docs/Web/JavaScript) - Previous text "MDN" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
https://flatironschool.com/programs/online-intro-javascript-free-course/ Very easy to consume and read. Just finished it a week ago.
have you considered searching the internet ? surfing the web is very popular these days
Seems like a wrong approach to your problem. Maybe restart the server automatically if it crashes?
I recommend the js course by Jonas Schmedtmann on Udemy. Very in depth and long with practical examples and codealongs. Been extremely useful to me.
Signing up to Codewars/a similar site may help. Look through the top level 8/7 Kata and have a go. Use it in combination with MDN to look through helpful methods. It'll help you to both get used to reading documentation, as well as implementing some JavaScript. Don't worry about revealing answers too much when starting out - it's useful to see just how a certain task can be overcome. Just be wary of the top answers - they're often abstracted to the point of not being good production code (they just look neat).
If it's a heavy read for beginners wouldn't it be better if OP started with FreeCodeCamp exercises and once he has beginner stuff under his belt move on to YDKJS? It's what I did.
Check out Kyle Simpson's courses on Frontend Masters [https://frontendmasters.com/courses/](https://frontendmasters.com/courses/) For me, video courses are easier for me to learn from than programming books. 
try this code: ``` if (learningJavascript === true) { goTo('/r/learnjavascript') } ```
Just out of curiosity -- what exactly was said prior to the comment deletion? Are you one of the original maintainers of uWS?
Sure, everything dealing with time in javascript uses the Date() object, however there is also moment.js which is popular for just these sorts of things. so, var time={start:new Date(),end:new Date()}; time.end.setHours(time.start.getHours()+1); if(new Date()&gt;time.end){ //houston we have liftoff }
I know I've been through it but you'll need to practice on problems or at least puzzles like the ones in codewars.com to really grasp the concepts because simply going through the code examples (watch and type as they are) won't make them *click*.
If you go through the first three certifications on Freecodecamp, you'll know a fair amount about JavaScript 
Which software or library are you using? XPath is usually used with XML but it seems that version 3.1 also provides some sort of support for JSON.
The code looks nice and clear! However... &gt; Another issue is that there’s a bit of inconsistency between serialization and deserialization, so this could also be dealt with. This is not "a bit of inconsistency" but it's complete broken: `arrayToCSV` adds quotes around values but `CSVToArray` doesn't handle them. The code like this shouldn't to used to teach anyone.
Not even once.
What happened in reality is that most of the community feedback we got was that usually CSV is stored without quotations because that's what most things output. On the other hand, most developers want to store CSV with quotations, so there's that. In all honesty, I'd love for someone to touch up on the snippets and add this functionality behind a flag, but I have extremely limited time to do it lately. Maybe soon...
Would `//versions[scope/asset_type="URL"]` work for you?
TBH if I was asked to store CSV with javascript that would set off a lot of alarm bells, especially if this is in a browser. This is a code smell, CSV in JS is almost certainly using the wrong tools for most jobs. Just off the top of my head - there's serious performance concerns here (serialization to CSV is simple enough, but even once you deserialize into a giant array of arrays you still have to deserialize into a model. And at that, CSV still has an implicit ordinal-position based schema; this makes your transformation code fragile and hard to maintain. No, really, listen to everyone telling you to stick with JSON here. Leave CSV where it belongs - in the spreadsheets and ETL software.
I understand. However serialization/deserialization should never modify the content and thus it's not suitable for persisting data. When teaching these topics it's important to provide accurate code or at least be clear about the shortcomings.
"We need to focus on solutions that are delivered at the scale of the problem, not stroking our egos" This is a correct overall line of thinking, but people really do respond a lot better to work that is clean, neat, and presented effectively. Sure, you don't need to create a new mega-app SPA just for someone's spreadsheet app that needs updating, but if you take some time to put a little polish and shine on it it will pay off better for you. Also, you may be able to turn that sort of monkey work into a much more enjoyable request to make that small-scale utility into a more formal app.
I think this post is a little to small for a good answer. Give us a bit more information, and show us what you already tried yourself. Tip: use moment.js when you use time in javascript. 
" CSV is stored without quotations because that's what most things output" That's an excellent method to collect exceptions when your user is in another country that uses commas where you use periods.
I absolutely agree. Just don't forget to let your users see your progress. You need a tight feedback loop.
Honestly I despise CSV. I also despise a lot of other things. But oftentimes you have to work with tech you hate because that's what the underlying system outputs and you have no access to its code...
I can imagine a dating app having a lot of relational data. Some form of SQL DB might be more manageable in the long run 
I would say medium size, I'm using mongooseDB.
The app Solo Learn has a JavaScript course that is pretty good for beginners. 
Then I would recommend that you build a transformation service layer between that system and your javascript app. Have that service return and accept JSON, and leave the details of the CSV data encapsulated there. For that matter, take what you've done here and write a library that converts CSV to JSON based on a schema config.
Show users your progress in iterative stages when stable, yes. If I've learned anything it's that end users should not see the sausage being made, they lack the capacity to imagine what it *will* be eventually, and will readily base their opinions on the final product on the state of the demos and betas.
I like the particlesjs library better.
There are a lot of differences but the underlaying principals are the same. Check the upgrade guide and you'll be fine. Moving from generators to async/await is a big difference and reason alone to upgrade. You would update your article to reflect the changes in under and hour, I would wager.
Well, I do not know much about your template, I apologise if my answer is too far removed, but how I do it. I would start with the form as a common javascript JSON object. var form={ vin:'',make:'',model:'',year:0,color:'' }; Then there is the part where each piece of the form is filled out $('&lt;input[data=vin]&gt;').on('click keyup copy paste change cut',function(e){ form.vin=this.val(); }); The rest would look similar-ish. At the end instead once the user hits the button you do not submit a form object, you submit just a regular JSON obj representing the form. Now if you want immediate notification I would recommend a websocket. This way you can broadcast the event from that users action to yourself monitoring it at the admin end, or recording it in a log etc. $('&lt;div class=submit button&gt;').on('click',function(e){ e.preventDefault();//so they don't go click crazy socket.emit('form submission',{form:form},function(err,res){ if(res){ //everything is good } }); }); Now on your server side you can broadcast that event back to yourself socket.on('form submit',function(option,callback){ //find your socket which you made unique by //attaching some form of ID tag... io.sockets.forEach(function(socket){ if(socket.id==='I AM THE CHOSEN ONE OBEY ME!'){ socket.emit('form submit',{form:form}); //no need for a callback } }); }); The best part about that is that you can have them submit the form, and you do not need to reload the page unless you want to, which gives a better smoother dynamic user experience.
No need for a coupon, every course they have is perpetually on sale.
Learn oop the javascript way. Think in events. Feel the lambdas. Use let and const, be aware of scopes. Know the difference between statement and expression. 
Thank you all...
Looks nice. Reminds me of Swagger from what I’ve used.
so what does cligen offer over OpenAPI? https://en.wikipedia.org/wiki/OpenAPI_Specification
If you want to have some semblance of privacy, you could store a hash of {your user id} + {their user id}. Then you could quickly check if the entry already exists without storing the explicit user.
Because clickbait and nuance are mutually exclusive. 
Wish they would spend this much time fixing the vue router bugs and Android issues.
Most managers assume the term "full stack developer" means someone who is not tied to a specific programming language. Most developers know that the term "full stack developer" is just marketing wank nonsense to get their resumes through HR filters.
For personal projects and quick spin-up time, I use Parcel. it works much better out of the box than webpack and has built-in configuration for typescript, sass, and react hot reloading.
Thanks, that looks promising. Would you recommend it also for a medium size react project? (This is step 1 in a project moving from an old Angular 1 code base to React.)
Sure. The only reason I mentioned personal projects is because it is inherently less configurable (more of a batteries included mentality) and if you need to do something outside of the scope of Parcel, it can be a bit more tricky, as Webpack gives you the ability to change and configure everything. 
Yeah, in another project ejecting from create-react-app is what introduced me not-so-favorably to Webpack.
Render props are pretty powerful, I use them to store things that don't make sense to store in Redux. Things like cookies, localStorage, and query strings mapped to object literals. I thought render props would replace or obviate my connected components, and it doesn't quite yet.
No it's a little more involved. Here's the source at "src/application/shared/preformatted.js": module.exports = function preformatted(template, ...expressions) { const text = buildStringWithExpressionsFromTemplate(template, expressions); const lines = text.split("\n"); if (!isMultilined(lines)) return text; return standardizeIndentationByFirstLine(lines); }; function buildStringWithExpressionsFromTemplate(template, expressions) { return template.reduce(function(accumulator, part, i) { return accumulator + expressions[i - 1] + part; }); } function isMultilined(lines) { return lines.length &gt; 1; } function standardizeIndentationByFirstLine(lines) { const firstLine = lines[1]; const firstLineIndentLevel = getIndexOfFirstNonWhiteSpaceCharacter(firstLine); const linesLessExcessIndent = removeExcessIndent(lines, firstLineIndentLevel); return combineLinesByNewLineAndTrim(linesLessExcessIndent); } function removeExcessIndent(lines, firstLineIndentLevel) { return lines.map(function(line) { let firstCharIndex = getIndexOfFirstNonWhiteSpaceCharacter(line); let lineIndentLevel = firstLineIndentLevel; if (firstCharIndex &lt; firstLineIndentLevel) { lineIndentLevel = firstCharIndex; } return line.slice(lineIndentLevel); }); } function combineLinesByNewLineAndTrim(linesLessExcessIndent) { return linesLessExcessIndent .reduce(function(accumulator, line) { let newText = accumulator + line + "\n"; return newText; }, "") .trim(); } function getIndexOfFirstNonWhiteSpaceCharacter(text) { let indexOfFirstNonWhiteSpaceCharacter; for (let i = 0; i &lt; text.length; i += 1) { if (!isWhiteSpaceCharacter(text[i])) { indexOfFirstNonWhiteSpaceCharacter = i; break; } } return indexOfFirstNonWhiteSpaceCharacter || 0; function isWhiteSpaceCharacter(character) { return character === " " || character === "\n"; } }
Yeah. And it won't make them type either. 
Okay thank you
&gt;JavaScript.info Click: [https://javascript.info/](https://javascript.info/)
People pay Google much more to have their links listed
Webpack will be around for a while. The newer solutions like Parcel aren't suited to most enterprise projects because of the lack of configurability.
Yes, MVC is good. Angular 1 did not do MVC, but yet called what they did MVC, and so now people think MVC = angular 1 = bad, which is not necessarily true
I was actually just recently looking into typescript a little bit, it looks to me like typescript is a good replacement for babel (if of course you want to use typescript) but even in their tutorials they still mention integration with webpack. So while babel may be on it's way out, webpack still looks to be fairly relevant. 
Render Props is just the API for a reusable component. There have been implementations of redux's connect as a render prop
Nothing is going to "topple" webpack for a while. Once you start having projects that demand more advanced features, custom plugins, etc. Especially at an enterprise level where you might have dozens or even hundreds of projects using webpack, you realise just how much of a complete solution webpack really is. What you probably want is something that is easier to use.
Really hope you see this because I was in your same boat when I started Practical Javascript by Gordon Zhu on [Watchandcode.com](https://Watchandcode.com). Great tutorial where you will learn the basics really well in a project-based video series.
MVC is bad because we know it from practice on backend and last 500 years of software development not Angular 1...
You won't be able to call `obj.property1();` since you added that property to your Class function directly. In the 2nd line, you want to do this instead: `Class.prototype.property1 = function (){ }` Notice how now we're adding it to the prototype.
Lately, webpack has become easier to configure and I feel its still relevant. I tried rollup i an a relativly small project that had vue, Babel and used node builtins, but I found it slower than webpack. (AFAIK rollup is still in development)
I honestly hated Webpack when I had to use it. It made me think "the internet used to be so easy, what happened?"
[Your new life begins today.](https://www.youtube.com/watch?v=JxAXlJEmNMg)
Everyone who has climbed the webpack mountain has had a similar experience. I recently made this project: [webpack-by-example](https://github.com/jmptr/webpack-by-example), to demonstrate building a webpack config iteratively. It might be helpful if you're the type who learns by reading code.
Exactly. When it comes to performance tuning webpack is still where it's at for me.
But he's not totally wrong. Customer needs can evolve, but it doesn't mean that the underlying solution needs to increase in complexity. Compare software engineering in the 1960s to now... it's orders of magnitude easier now. But the Web dev ecosystem from 10 years ago to now is way more complex and difficult. It doesn't need to be that way...
2nd freecodecamp, that’s how I learned 
I really recommend to you this book [http://shop.oreilly.com/product/9780596805531.do](http://shop.oreilly.com/product/9780596805531.do)
Same browser, same language, different needs. 10 years ago was 2008. The iPhone 3G had just come out; mobile web was barebones. When it was done, it was done on a separate subdomain. Webpages also had less overall interaction as a whole. We didn't have ubiquitous use of things like video streaming and sockets for real-time data transfer. Now, most traffic is from mobile devices, and it lives in the same codebase as the tablet and desktop versions. It's not as if people dream up things like transpilation just to make life harder. That's a consequence of there not being any centralization, with browser manufacturers able to adhere to the spec as loosely or as tightly as they wish, and on their own schedule. 2008 was the peak of jQuery, which while capable of writing a modern web application, is far from ideal. Modern front-end development now uses more standardized software patterns such as MVVM.
&gt; It's not as if people dream up things like transpilation just to make life harder. That's a consequence of there not being any centralization, with browser manufacturers able to adhere to the spec as loosely or as tightly as they wish, and on their own schedule. Exactly. And you've thereby answered your [own question](https://www.reddit.com/r/javascript/comments/98wfob/is_webpack_still_a_thing/e4jf04s/). What happened is that customer needs did evolve. But what also happened was that there was no concomitant evolution in terms of browser/ecosystem standardization. That would have of course had pluses and minuses... but on the plus side would have been radically simpler development.
It seems to be dynamic. So if you change the configuration you don't need to generate your client again: it simply adapt. In other words it's a library and not a generator. Honestly code generators are often limited and not as useful as they promise.
To me is a good approach. I've been doing that for years now and it works like a charm. Especially for front end workflows in complex environment it is a charm. You start moching the API as it should be directly on the dev server. Then you can simply adapt the configuration to follow real API development in dev environment. The you can configure small differences between dev, QA, prod. Moching the next version. Run different versions in parallel. Basically you can do whatever you need without having to wait other people implementations.
That situation is inevitable. A centralization effort would be doomed to fail, and there's no other way to force cooperation like that. If anything, the current way of doing things is the best we could do with what we have.
i really want to love webpack, it does some cool stuff, but i cant see exclusively using it. after converting a test project (react) over to work with webpack, i found i was still getting smaller file sizes from my gulp setup i've been running (and iterating on over time), was not keeping track of build times though, was only focusing on output. webpacks readability has definitely improved since v1 though, so i'm not counting it out, just keeping an eye in it.
I'm copying this down chears all
Question is a JS ecosystem in a nutshell.
I use w3 a great deal as a reference when I need to do something I've not done in a while, always written at an appropriate level, which helps when you need to get things done. 
oh lawd
The resources are great but hands on is greaterer. Remember to actually make stuff and not just blindly follow the tutorials.
I'm guessing what jalapina means is that he/she is using mongoDB and adding mongoose on top for its ORM functionality (which I've done before).
my balls
Have a look at this library: [http://matthew.wagerfield.com/flat-surface-shader/](http://matthew.wagerfield.com/flat-surface-shader/) Github page: [https://github.com/wagerfield/flat-surface-shader](https://github.com/wagerfield/flat-surface-shader)
You need to know a bit of ThreeJS/WebGL – basically that looks like it could be a PlaneGeometry with noise in a vertex shader displacing the vertices, and then some lights applied to the scene. Some suggested reading on the subject... \- \[Shader Intro\]([https://github.com/Jam3/jam3-lesson-webgl-shader-intro](https://github.com/Jam3/jam3-lesson-webgl-shader-intro)) \- \[ThreeJS Shader\]([https://github.com/Jam3/jam3-lesson-webgl-shader-threejs](https://github.com/Jam3/jam3-lesson-webgl-shader-threejs)) \- \[The Book of Shaders\]([https://thebookofshaders.com/](https://thebookofshaders.com/))
Not sure if this will fix it but you could try calling `closePath` *before* any stroke or fill commands. Your code for some reason didn't format correctly (try using Markdown?) so I can't test it. :) 
What’s up with the sudden influx of twelve year olds acting like they’re hot shit programmers on this subreddit tonight?
Not to nitpick but I would say es2018 is the bleeding edge of javascript. Es2015 (es6) came out 3 years ago.
You are correct that the Vue CLI is built around webpack. Projects created by Vue CLI, however, allow you to configure almost every aspect of the tooling. So no need or even ability to eject.
To be fair, I meant to stick a “+” on the end of “ES6” to indicate “and everything since” but my phone’s keyboard ate it. Mea culpa. :-) My intention was to express that it was ES6 that began major syntax adoptions that changed the *relatively* stable face of vanilla JavaScript (outside of additional libraries), and that pre-ES6 remains JavaScript’s “core”. One should ideally learn that core on a fundamental level before jumping into, say, asynchronous iteration. :-)
Word
Word
Even if you skim, this will save you quite a bit of time down the road
I hear [Vanilla JS](http://vanilla-js.com) is pretty great
Webpack is definitely still going strong IMHO, but if OP wants to keep an eye on some new kid on the block, there's always Parcel.
Specifically to the question of tracing JavaScript that causes a request, Chrome's debugger can break on XHR requests. You might struggle to piece the request back depending on abstraction.
Preact is pretty small.
The ‘Array.prototype’ methods are pretty core essentials. Learn them. Love them. 😜
unistore and preact
Yes. You can learn js on the job. 
Hyperapp and Svelte are probably the smallest. They're about as small as front end libraries get.
Sounds like a no-brainer, right? Forget them operating systems. Learn some JavaScript.
right, and so have i. but mongo is used at an extremely high rate for beginner tutorials and bootcamps. at this scalr, no project is realistically going to see any performance penalty from a suboptimal implementation, s the creator is better off doing it however they think of. not only would they avoid premature optimization but it's a much better learning exercise than having someone hand you the right answer
What you're looking for is /r/learnjava
Thanks lol
Still waiting for either a webpack or babel plugin for arbitrary function inlining and CTFE. Those two would do wonders for optimization.
forEach doesn’t really have “its own” parameters like you’re thinking. Its parameter *is* the callback function. That function is called with 2 parameters (the item and the index) “for each”(heh) item in the array. It might be easier to think about if you see how forEach might be implemented: Array.forEach = function(callback) { for (var i = 0; i &lt; this.length; i++) { callback(this[i], i); } } That’s semi pseudo code typed on mobile, but should hopefully help you reason about what’s happening. 
Well, first of all you should learn to google.
Sheesh, tough crowd. More curious if those bullet points require lots of time or can be covered in a google session
Nah, just a few minutes on YouTube and you'll be fine.
Gracias
Yup I agree with what you said
&gt;Company is looking for someone who knows: “Java Forget it. You already lost.
Okay so if I add it to the prototype that will be for the Obejcts which are going to be created or for that Class?
I should go fuck myself then huh?
At the risk of being a jerk, I want to point out that browsers api while still have lots of little quirks are still much better than what it was 10 years ago. I recently wrote a small app that'll only run on latest versions of safari, chrome and Firefox and I didn't even need babel, aync await and all that jazz worked right out of the box. Maybe I'm biased but I think the front end environment has experienced growth so much faster than before (just a few years ago fetch still wasn't a thing in safari, or css wasn't a thing anywhere). Javascript itself has changed so much and Webassembly is also right at the corner now.
First 3 hours are on Youtube, definitely recommend at least watching that. 
js(javascript) is not the same as java
It's definitely still a thing. Prediction, though: whoever gets webassembly right (probably Webpack, but parcel has a hat in the ring) will come out on top in the medium-to-long term. Since Webpack has said that WASM is a first-class citizen going forward, there's a good chance Webpack will stay dominant.
Ohhhh so all those bullet points are for java not JavaScript?
Totally agree with what everyone else is saying. I dived straight in learning CMSes to build sites quickly for clients (drupal/wordpress) but now I've learned Vanilla JS as well as React and Vue at the University of Youtube and through some pretty good courses at Udemy/CodeAcademy. Everyone finds there own route to suit them but there's a massive community online who are generous and helpful to support you as ya go.
Yup, 100%. you'll have to forgive the rest of us, it's a regular occurrence for JavaScript to be confused with Java. 
Parcel. It’s amazing. 
It blows my mind that it's simply assumed that webpack must be getting replaced for something shinier.
If you need quick PoCs, use Parcel. But webpack has so much more support. So I would stick with it. Plus, if you actually plan out your configuration, it doesn't have to be a nightmare. But some people think Parcel could eventually compete with webpack.
&gt; Nah, just a few minutes on YouTube and you'll be fine. Read: You're screwed
Trends changes and in computer they change faster. I strongly believe in adaptability. What is buzzing now can be completly outdated in a month. Understand what you are doing in priority. Languages/framework are not the most important. If you understand what you are doing, they will be super easy to learn anyway.
So true, but so much of it seems unnecessary to me. I still use *gasp* jQuery once in a while. You know what (other than causing my coworkers to mock me) it works just fine. The app works, the code is easy to maintain if written with an ounce of care, and it doesn’t require a bunch of setup and prerequisites. Sometimes it feels like people spend more time “tweaking their tools” than actually building stuff. For some people, it’s all they do. They never actually build anything. They just sit there all day tweaking their tools. Then they scoff at you for using “old” technology even though you -ya know- actually built and shipped a working product. It gets old after a while. 
I upgraded our project from Webpack 3 to Webpack 4, and the first tentative was a dud. The first webpack 4 release was all buggy and poorly documented. Second tentative (I think in May?) worked pretty well. A lot of configuration options were no longer needed, some plugins were now core functionalities. So smaller, simpler configuration, and much, much faster build times (about 20% faster IIRC). The migration script was easy enough to follow, and helped a lot. So yes, parcel is the one the cool kids are eyeing, but if you're looking to replace grunt with a battlefield tested product, go with Webpack 4. Replace the grunt tasks with yarn scripts. Webpack 4 requires node 8, it might be an issue depending how old your existing codebase is.
Was just listening to Frontend happy hour and heard about this. The one guy spoke very highly of it and was actually working with the creator to create a new version. 
Lol thanks
`pnpm`? Oh crap I don't wanna go down that rabbithole...
Sort of. Conceptually, yes. Every instance you create from `new Class()` will have that property (not technically, but read on), but it won't be a copy. JS has a thing called prototypal inheritance. When you access a property on an object, JS will see if that object has the property you're asking for. If it doesn't, it'll see if it's prototype has that and use that instead. It'll do that until it gets to the end of the prototype chain, at which case, if it doesn't find the property, you'll get back `undefined`. So in this case, when you say `var obj = new Class()`, and you try to call the `property1` method, JS will be like, "Does obj have it? No, so I'll go to its prototype (Class, in our case), and it does have it, so it'll use that. Here's a contrived example using animals: // Here's our class, it takes two arguments, type and sound function Animal(type, sound) { this.type = type; this.sound = sound; } // Here we add a method to Animal's prototype. Every instance you // create from Animal will be able to use this method. Animal.prototype.whatAmI = function() { console.log(`I am a ${this.type} and I say ${this.sound}`); }; // We make a dog, its type is 'dog' and its sound is 'woof' var dog = new Animal('dog', 'woof'); // We can call whatAmI, even though it doesn't technically live on // the dog object. dog.whatAmI(); // "I am a dog and I say woof" // Let's look at what properties actually live on dog. As you can see, // dog only has two properties, 'type' and 'sound'. If you're curious why // these live on the object itself, just ask :-) Object.getOwnPropertyNames(dog); // ["type", "sound"] // Now let's look at what properties live on dog's prototype. Look at // that, 'whatAmI' lives on the prototype! I wouldn't worry about what constructor // is for now, but I recommend looking into it once you understand all this. Object.getOwnPropertyNames(Object.getPrototypeOf(dog)); // ["constructor", "whatAmI"] 
like https://github.com/facebook/prepack?
Actually, yes. I just took a quick run with the REPL, and it performs some optimizations that I wrote a (inefficient) babel plugin for. Thanks for that! Definitely intend on adding it to my build process.
Be careful tying yourself to a language/framework. They change yearly.
I've worked for years with both Javascript and C#. The languages have very distinct flavours, and will require separate study. That said, spend your effort on .NET and figuring out the strangeness of Javascript later is my vote. Javascript is a unique animal. 
Thanks a tonne you've been so generous but dumb me still isn't fully getting the difference between Class.property1 and Class.prototype.property1, So in your example the __proto__ attribute points to Animal right?, So in my case if I do obj.__proto__ = Class, then obj.property1 as well as Class.property1 is possible right? And if this is possible why doesn't obj.__proto__ is defaultly set to Class?
Bad title. Good article. The only part that is actually JS specific is the part about frameworks and such. Everything f else applies to any software project. 
Even *the* de facto functional language uses a sugary construct similar to async/await. Look at some Haskell `do` notation and see if you notice the similarities.
Ah the wonderful world of JavaScript development. 
This cleared everything and I'm glad it was this big, I seriously don't mean to bug you but one last thing, why does it make sense to set Class's prototype to the newly created object's prototype, semantically the Object should be able to access the Class's static methods too right?
I'm done thank you so much for everything :)
✌️
Agree. And also the framework parts could be arranged to fit any project
Thanks, this fixed it! I drew the first line then the arc and the second line and so on and it worked. But I didn't do this on the bottom layer. If possible, could you explain why that one works like that?
I think [stimulus](https://stimulusjs.org) would be the right solution for you
Use babel-preset-env and browserslist to setup transpilation and polyfills for a configurable list of browsers you want to support.
I have updated my answer with the problem I faced with Swagger/OAS.
I have updated my answer with the problem I faced with Swagger/OAS.
I have updated my answer with the problem I faced with Swagger/OAS.
Yes, this is another advantage of the library.
Have you taken a look at [Vue](https://vuejs.org/)?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://vuejs.org/) - Previous text "Vue" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
About the whole no magic strings thing... I'm working on a two legacy codebases, Node and PHP, where every single string is a variable. There are literally hundreds of them per file. It doesn't make understanding what is going on any easier. I don't like magic strings all over the place, but at some point using variables like that gets a little ridiculous. Once, I even found a case of var VAR_TRUE = true; I know that isn't a string, but it does illustrate just how far overboard the previous dev went. I don't know, maybe this is just indicative a larger problem.
Moment.js is a great library but also a large one. If you just need some calculations I'd rather write some methods based on Date by myself (plus testing).
Last time i checked it didn't have externals (eg. a way to tell it not to bundle react itself) which it some of basic requirements for me I recommend fusebox which also does TS and everything else out of the box with minimal config... But webpack still rules for me
Webpack makes everyone sad, but does the best job. 
While you might find a project by asking it here, I think the best way to get involved in open source projects is by creating your own projects. This can be for fun, work, school, ... (Bonus points if your own project is also open source) Write projects that you can use or you find fun to do, so that you stay motivated to build and refactor it. Use other libraries in your projects (eg. React, and other react component libraries). You'll soon encounter issues with the libraries you use. This could be bugs, features you find missing, etc. Contribute to those projects by fixing the bug or adding the feature you need. This way of working has 2 advantages: - You stay motivated to work on your projects because you benefit from them in some way. - Since you already used the library as a user, you know their API and getting into the codebase to fix a bug or to add a feature should be easier than if you just enter the project at random.
Hyperapp is so good that Polymer copied it.
It is a very inefficient implementation as, on Codepen, an `time out` appears quickly. But it has few nice feature: - I think it is a good show off functional and es6 JavaScript, - It is quite DRY, - Big Perlin's algorithm steps are emphasized, - It is really easy to edit it for 2D. What do you think of it? PS. I did not achieved to map final values in [0;1] but, I think, in [-1;1].
I wholeheartedly agree with this. The contents of a string can be much better comment than an actual comment r a variable's name. This applies especially to exceptions in various sanity checks/validations (which even in typed languages usually don't get their own exception type). Also, if you need to use substitutions, having the string inline is much more readable, especially if you can use interpolated string instead. To be honest, I refrain from introducing variables even for numeric constants in many cases. var yearlyWage = monthlyWage * 12 Is just more readable than var yearlyWage = monthlyWage * numMonthsInYear It is obviously very context dependent, so use your best judgment. And please don't declare stuff on top of their scope. We are not in the 80s anymore. Declare things as close to their usage as possible, in general.
I needed a list of colors to use in a chart that wouldn't look terrible on the project I'm working on so wrote a tiny little app that could take an input color and generate a list of ROYGBIV colors keyed to have the same saturation and lightness. https://theirongiant.github.io/Huey Hopefully, might be of use to someone else.
Preact is 3-4kb, and it is far more powerful than knockout. You'll also move from troublesome string templating and MVC controllers into functional views and functional programming, which is beneficial to say the least. From thereon you can easily move up later on.
Parcel is awesome. And I would say that it can work pretty well on big projects, but it depends on what you are used to. Witch parcel you can still configure all the modules that it uses, you just don’t have to configure the bundled itself. However there might be some functionality missing, but it is making big steps towards the right direction. I’m currently using it for a mid sized project, and I don’t miss webpack at all. My recommendation is, try it. Since you don’t have to configure anything it’ll be easy. If in the future you see that you need more flexibility, the you can always switch to webpack, all you have to do is ‘yarn remove parcel-bundler’ and most of the time you’ll be fine. Maybe small changes to the code but nothing complex.
thanks i know it is supposed to be easier but there are a few things i find confusing.. which functions should be marked async... what you can return from an async function... cancelling future code.. and of course the biggie.. error handling
Honestly speaking JS is not the best language to learn for beginner. Mostly because it is asynchronous language. I would take Python instead. There are many good resources and books about Python + most of the knowledge could be applied to JS without any significant relearning. 
Agreed, but I do think a lot of them are especially problematic in JS. Things like how code is arranged in files is more important because of the browser environment, same with the state. Making things obvious and fighting nesting are both more important in JS because it's loosely typed and functional. IMO it's much easier to make overly clever code in JS.
But what if you want to change the value of true in the future?
Why? Do you have multline table-like variable layout in your code or some similarly justifable reason?
Very carefully. 
This demonstrates how a lot of these principals are more of an art than a science. I once had someone try to simplify an if clause as follows: If clause1 || clause2 To If clause1_or_clause2 It is fine to encapsulate the logic, but finding a name that encompases a new theme should be given a little time. Thank god for code reviews.
I appreciate the irony in your question. Shininess has been the order of the day for the past eight (?) years or so. For a while, the "churn" was for legit technical reasons. Then it got increasingly social, hipster, confusing, wasteful. Personally, I believe that Webpack *should* be *the* thing. By choosing not to support an alternative, you're doing your small part in reducing hipsterism, etc. If Webpack were slow-moving (vanilla JS for a while) or utterly unfit for its typical uses (Angular 1), supporting an alternative would be a great idea. We were well-justified in choosing jQuery over vanilla until around 2012 and choosing Vue over Angular 1 in 2016. But Webpack is not slow-moving, and it is not unfit. It's getting better by the day, and as /u/twomousepads mentioned, its shortcomings -- like its unfriendly configuration -- are being addressed both by dependent tools, and by Webpack itself. Use it, embrace it, and encourage others to do their part. Dream of a day where ironic posts on /r/javascript are a distant memory.
To me the issue is not so much the configuration as that for Webpack 4 there is a lot of packages that breaks with Webpack, so you spend a lot of time triing to fix that obscure error with the package that you need. I guess my issue and frustration is more with the different interactions between dependencies. At work we used it for a small project and that was a mistake, it took more time to configure than for the project itself. I guess as it's been said, is ok for big projects but it adds a lot of overhead for small ones. Usually I work on React, CreateReactApp helps a lot but the version out there has Webpack 3 and if you want to benefit from all the new sweet features of webpack 4 you need to get your hands dirty.
I get what you're saying but I never understood the intense focus on a framework adding 200kb to a page load (and only if it's not already cached)... A single image or ad on any page you visit is going to easily be 8 times that, at least. 
I've tried alot of different coding schools online (Team Treehouse, Code School, Codecademy, etc) and I like Udemy the best. I would recommend against sites that give you an in-browser editor. Udemy courses always guide you along with local setup on your system then you follow along with the professor, as they type, during each lesson. If you run into snags, you either have to re-watch the previous video or 2 to see where you went wrong (solidifies your learning better) or Google your specific problem, which is also a good way to learn and how all programmers troubleshoot problems nowadays, anyways. Courses are usually cheap ($10 - $20) and on sale. Honestly I've never seen a full priced course; I think it's part of their marketing scheme. If you stick to the highest rated/most reviewed courses, they're a really good way to learn any web development stuff, imo. Added bonus is it's not subscription-based, so if you get a really long, thorough 80-hour course, you probably won't finish it in a single month unless you're focusing solely on that, in which case, I still think it's better. Just my 2 cents. I'm no coding guru just know it's been a huge asset to me in my programming journey (I'm a Javascript/front-end/full-stack dev). 
Certainly not a great way to learn coding concepts and a language, from scratch (what I assume the downvotes are from), but still one of the most crucial tools in any programmers toolkit. 
10 things You wont believe about JavaScript!
It might have something to do with the winding order of the polygon. Say you draw a circle in clockwise order, and then a smaller circle within that in counter-clockwise order, Canvas2D will interpret that as a "hole" in your shape and you will end up with a donut. Maybe the small pie shape at the bottom looks the same regardless of the winding order of each edge in the polygon, which is why it turned out looking normal.
I think it depends on the nature of the string. For example, redux uses magic strings for actions. It is way more efficient to put them in a constants file for two reasons. The first is that mistyping a variable will cause an import error or hard crash while a string will silently fail. The second is that sharing a reference to a string reduces allocations which improves performance.
I would think the V8 compiler is smart enough to group string literals together and allocate only once.
A developer wrote a React component: you will never guess the incredible things that happened to his codebase next!
TIL that 23 years is almost a decade.
What's the job? It's very possible that this is one of those 'Nice to know but not required' criteria and just being honest about your knowledge may be the better option (with enough to say to prove you're capable of learning it)
[removed]
GitHub: https://github.com/dislick/m-conv
`var VAR_TRUE = !true;`
Based on what i read now, ReasonML seems like a subset of javascript. It has omitted some icky features of javascript, but then it has some others like the questionable within-block variable shadowing.
&gt;If your code goes beyond 120 characters to the right, beyond 500 lines downwards While generally I agree we shouldnt have too much code shoved into a single line like: ``` Mything.doThis.ThenDoThat.ThenDoTheOtherThing.ThenCallYourMom.YoureLateForDinner. ``` This hard line length rule doesn't work well for some function calls that have LONG variable names that are nested 3 deep from the start. (which is the starting point for many C# functions: you nest in namespace, class and then your method body is at least 3 indents deep) 
There is a class hiding in you functions: WageCalculator, or Employee with YearlyWage methods (properties if you're using C#) The unfortunate side of JavaScript is that while OO does exist, most devs are used to writing everything using ES5 syntax and object literals. (mostly because the ES5 object syntax is terrible..and no one really knows what `this` is) 
Hi /u/r1zzu, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
Hi /u/The_Numbertaker, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/amdforlive, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Oh, ok!
The YDKJS books are great! This however is amazing! What really makes this course different is that he not only teaches you the basic, but **the way to think**. So awesome
Hi /u/merott-, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/MuhammadMoiz, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/GoonGamja, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Can you please be more specific as to why? I will not be commercially benefiting from the website that I'm promoting, so I'm trying to understand what happened.
 mv module.js trump/module.js
const
Not entirely. Classes allow you to group similar functionality or encapsulate concrete programming concepts. I'm not advocating for AbstractClassImplFactoryImpl; however, for large, complex projects, if you do use a class it will be dramatically easier to grow and maintain. 
Actually, multiple devs here do that. They also use typeof foo != undefined and never use the identity operator, only equality. Also I see this sometimes: var foo = undefined;
&gt; Separate your sex life from your programming life Can I not just keep my wife *AND* webpack?
Thanks for the explanation, and I apologise.
Or use `react-scripts@next`, which is a beta version for CRA 2.0 that includes Webpack 4. Not sure exactly what the plans are for releasing 2.0 final, but I would guess that part of it is waiting on Babel 7 to go final, and Henry Zhu just said he was intending to do that this week.
Absolutely do. Learning about OS design will give you a solid understanding of a great deal of computational theory applied to practical problems. It may not be directly applicable to being a web developer but it's certain to pay dividends over your career. The algorithmic problems inherent in designing an OS crop up time and time again in any programmers career, and although they may not be in the same guise when they do knowing how they've been solved for already will place you miles ahead of your competition. If there's a class in Compiler Design I'd have no hesitation in recommending that too. Between the two you'd be exceptionally well equipped without wasting time on the abstract theoretical stuff CS courses tend to entail.
How does this stack up to [faker](https://github.com/marak/Faker.js/)? Aside from very, very minor "ergonomic" "improvements" (`dice` and `coin`, for example) I'm not seeing any differences, really. 
Thank you, OP was banned.
It's not full java until you have a WageCalculatorFactory class.
 if ( (someExpression == true) === VAR_TRUE )
Yes, I am aware of that. It is useful when you are working with third party stable APIs. You generate your code (mocked or not once) and from that you will add your integration code. Your API will not change anymore. But there is also the case where you want to continiously experiment with a ever changing API. In that case the dynamic library approach is more flexible as you don't need to regenerate every time. It's still feasible but honestly I would not like it. Another point is in case you need to integrate multiple APIs by different team members. With the code generation approach you will end with multiple generated code and every team member will implement everything their own way. With the library approach the interface will be the same as only the configuration will change. From an architectural point of view IMHO it is still the preferred approach. I hope this clarify my POV.
Sweet! Thanks, actually I saw that out there but I wasn't sure what was about. I will give it a try!
I currently am doing the opposite (my current role is Javascript so I'm spending time and effort into that), but really enjoyed my time coding in C#. Any recommendations on a learning path to best marry the two? I dove straight into [ASP.NET](https://ASP.NET) MVC, but I think I may have missed the whole [ASP.NET](https://ASP.NET) part first and was very lost...
Sorry but I don't get the point. Every commit isn't meant to be related with the former nor the next. This is something you wouldn't see in a company or use it in a team. Getting the idea, I'd write a JSON key value to point the required commits and extract the information like now. It would be even better
I saw in one of the comments that the source of your question is that your team is migrating an app from Angular to React. If you're worried about the headache of trying to determine everything you might need/want \*and\* figuring out how to set those things up, I'd recommend having a look at [react-boilerplate](https://github.com/react-boilerplate/react-boilerplate). Perhaps you've already glanced at it but if not, it's a pretty well thought out, respected, and badass boilerplate for applications planned for true production. You can glance at what they opted for as far as Webpack or just see if that boilerplate works as a start for your transition and worry more about understanding all the other Webpack and non-Webpack tooling they chose.
Thank you for that recommendation. We are using create-react-app to much success in another project. But that one isn't suitable as it's geared towards a single-page app. For this new project, we are just going to be using React gingerly for a few things, versus making everything a SPA. Is react-boilerplate also good for this use case? Or is it like create-react-app where it assumes you are going fullbore SPA?
webpack is still a thing. But there are options now. One of them is parcel, which does most of the things webpack does but with less config (or even zero config most of the time) it's worth checking out if you haven't already. I wrote something about (what's the difference between Parcel and webpack)[http://blog.jakoblind.no/parcel-webpack/]
For these parts you can place [GTI] tag and this specific commit will be ignored during markdown rendering Nevertheless this tool has some specific use case and not intended to be used in teams when you build a product. Valid use-case - education. I've acted as a javascript/react mentor for the past 4 years and found that every manual/presentation I write contains some mistakes, because you can't handle everything when you focused on writing manual itself, not the code. This tools make you focus on building stuff incrementally. One more point: you can show newcomers the whole process of creation, not just final result and general idea
The end result looks great! Even if the tool is a little cumbersome to use, I think it's worth it since it couples with git as an organized way of making a tutorial. For existing code you can rewrite the history I guess.
Yeah I'd say so. CRA is fantastic but IMO it's really best when you're really just ready to start cooking on your app. If you're planning any kind of React app to have serious considerations for performance, SEO, lots of complexity, etc. I'd say default to react-boilerplate (again, just one man's opinion). As for avoiding the SPA approach, I think it would accomplish your needs. As server-side rendering, code splitting, all that good stuff have become major hot topics, react-boilerplate has gone to great lengths to include the right tooling for those jobs. Similarly, all that stuff should afford you the flexibility to split up your app into a more traditional approach than a modern SPA without having to spend a million years figuring out your Webpack bundling and how your server is going to manage what might end up amount to disparate react apps.
I have tried Parcel and my experience is that it's easier to configure and also faster. I even got some bundle size optimizations out of the box that I had spent days to configure in webpack. [I wrote about what's the difference between parcel and webpack](http://blog.jakoblind.no/parcel-webpack/). I agree that webpack is a bit cumbersome to configure. I made an [online visual tool to create a webpack config](https://webpack.jakoblind.no/). Maybe you find that one useful.
It can be seeded to provide repeatable results. Last time I checked faker could not do this.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
https://github.com/marak/Faker.js/#setting-a-randomness-seed
good bot
&gt;And please don't declare stuff on top of their scope. We are not in the 80s anymore. Declare things as close to their usage as possible, in general. I'm mostly on board with this, but I also think that your individual files should be short enough that you can declare things at the top, and see at a glance what's going on. If you're now on line 500 of a file and hunting for stuff at the top, something needs to be chopped out and imported.
Find something that will turn a site's updates into an RSS feed. Then find something that checks an RSS feed and sends updates to SMS. Maybe something like https://zapier.com/apps/rss/integrations/sms .
There was some problem with it, I believe that this seed is shared between all instances of faker, which makes it hard to use. Ah, I remembered. I used faker to generate a lot of coherent data for mock API, so I wanted to use ID of resources to generate reproducable datasets. And it is impossible with current implementation. Here is a link for an issue - https://github.com/Marak/faker.js/issues/318
Hello fellow javascripter! A fine day for discussion is upon us, bloody bright blue day with birds in the sky here it is. Alright lets get down to some code shall we? :D code ------ //see here we say there is going to be a variable passed //in called callback, this will be important in the next part var function_with_callback=function(callback){ callback('even if I just did a billion things, I am now done all of them'); }; how to use? ------------- //in the same way as we //passed the callback variable //this function we are jamming into the () part of it represents //that variable, so the function part IS the callback variable function_with_callback(function(result){ //result will be //'even if I just did a billion things, I am now done all of them' }); It is like a bloody mobius strip isn't it? You get used to it. :) 
With mongodb?
Excellent post. Much of this advice actually applies to projects beyond JS.
Exactly. I've been working on a repo to get to the final result, rebasing and splitting commints into smaller ones later. Works for me, should work for others 😉
Let me know if you'll face some difficulties or need more features (if you actually gona use it 😉)
This should never be exposed to untrusted inputs since it uses `eval` under the hood. [algebra/f.js](https://github.com/arguiot/TheoremJS/blob/3739201b81b4f466e2c80ae48f22f4b5485bb6e9/src/includes/functions/math/algebra/f.js#L12-L16): core: x =&gt; { let regex = new RegExp(v) let newStr = func.replace(regex, `(${x})`) return eval(newStr).toFixed(14) } Compare that to [Mathjs](https://www.npmjs.com/package/mathjs) which manages to evaluate arithmetic expressions without using \`eval\`. ["Security risks"](http://mathjs.org/docs/expressions/security.html) says &gt;The parser actively prevents access to JavaScripts internal `eval` and `new Function` which are the main cause of security attacks. Mathjs versions 4 and newer does not use JavaScript’s eval under the hood. Version 3 and older did use eval for the compile step. This is not directly a security issue but results in a larger possible attack surface.
Will do, I definitely plan to try it out. It's very taxing to write code and then immediately afterwards restate what I did in English
It is difficult to talk about the whole system during one interview but show you understand that frontend part affects backend design. When you have doubts just ask interviewer. I'd say that showing awareness of mutual influence of frontend and backend is a good sign.
Hi /u/erickthemeeknerd, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
I think this is not possible =/
Also the state management point. 
What an excellent idea. Definitely going to try this out on the next talk I give. 
Sorry i didn't came back since the outage Thank you all for your answers! I'm gonna to give some attention to Preact and Hyperapp, it seems great and event better, fairly easy to use I must say that coming from an Angular background, this kind architecture is way more easy to understand than the Angular lifecycle. 
&gt;unistore and preact That look really great thank you
thanks for the link!
Thanks guys! It all worked out
You should look for the documentation for a better answer, but from what I can remember, the back button goes back to page 1 by default. You can add a callback to the back button to make it do other things, tho, like exiting the app.
Nice, that's kind of what I want. So the back button is tied into *window.location* changes by default?
This isn't really a unit, conceptually speaking; it does a bunch of unrelated things. What you're doing is an integration test, and honestly, given what the code is conceptually, the test is mostly fine. You should have unit tests for each individual unit, i.e. `PasswordSecurityService.secure`, `UserGateway.create`, `EmailService. sendRegistrationEmail` If you're concerned about boilerplateyness of wiring up a bazillion services together every time, you should consider looking into dependency injection systems.
Yes. It works like the back button on a browser.
FYI, it is against IMDB's conduct of use to scrape its site. Fortunately they do seem to provide some sort of API/interface into their data. https://www.imdb.com/interfaces/
Great, thanks!
After some years in the software engineering world I tend to think in concepts instead of concrete technologies. Once you have understood OOP, you can apply OOP concepts in different languages, and you can asses technologies. If you have learned functional programming, you can use the concepts with different languages. If you have understood race conditions (like you learn in an operating system class), you can think about them no matter what technology is used. I think, you've got the point ... ;-)
ReasonML is basically OCaml given a C style syntax so it is more palatable to JavaScript developers. It is a very different language to JavaScript, however, it does give you access to the standard JS methods. So you could end up writing 'functional JS' if you went that route.
^^ this As someone who has interviewed people for a while, I can tell you that interviewers agonise about this stuff just as much as interviewees - are our questions too hard? too easy? easy to understand? do they confuse the hell out of the interviewee and just make them nervous? etc Remember, more often than not we interview people _hoping they are going to be good enough to hire_ - because if they aren't than we have to do it AGAIN... we'd rather not. So feel free to ask questions, clarification, discuss the question themselves, etc, everything that can help give the interviewer the feeling that if they hire you it's going to be alright
If you want all the Marvel characters... :) https://github.com/mattdesl/marvel-characters
Thanks! Actually I find that tool pretty useful and interesting, I wondered multiple times why no one did it before. Are you gonna add more packages to it?
You can use the \`&lt;input type="file"&gt;\` element to accomplish this. What have you tried so far that is confusing you?
wait...wait...wait. how new is this? anyone have this running in a production app?
This has been around for ages. I've been using it in production for years. Read the docs sometimes guys lol, this is a standard documented API. 
you aren't wrong (rtfm). :doh: 
Like what?
Yeah I've been using this in production for a couple years now
um, this actually is css, not javascript
&gt; this is a standard documented API Its in draft form currently: https://www.w3.org/TR/cssom-view-1/ So "standard" is a little bit of a stretch (in that its current form has not been formally standardized). The MDN page for [MediaQueryList](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList) tags this as "This is an experimental technology" as well, so its understandable why this wouldn't necessarily be in widespread use.
Explains why it isn’t more widely known
Seems to work as expected &lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt; @media (min-width: 400px) { body { background-color: green; } } @media (max-width: 399px) { body { background-color: red; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hiya&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;
the browser compatibility is very similar to CSS media queries
You should probably actually read the linked article and look at its examples. If you still think you're right, I sincerely hope you are not a professional web developer.
It might be worth pointing out that [Deno](https://github.com/denoland/deno), created by Ryan Dahl the original creature of node.js, is basically a TS runtime
That's nice 
Is your argument that this is what was linked in the article or is it just that you wanted to assert that the article is about css and then use some css you wrote as definitive proof?
Except that this isn't necessarily about styling the page. You can run different conditional branching, loops, JSON queries to the server, etc. based on the results of the window width. Just because you personally would use it to make style changes doesn't make it inherently CSS. By that logic, Javascript is just FORTRAN, because they both have "if" statements.
It's a lot easier to install the `fs-extra` module which returns promises. Then instead of using callbacks you can just do, eg: const fs = require('fs-extra') const data = await fs.readFile(filename, {encoding: 'utf8'}) If you want to loop over async actions you can't use forEach, use `for of` instead. for (filename of filenames) { const data = await fs.readFile(filename, {encoding: 'utf8'}) } Or all at once (faster): const datas = await Promise.all( filenames.map(filename =&gt; fs.readFile(filename, {encoding: 'utf8'})) ) 
wtf it exists 
[@media's latest tweet](https://i.imgur.com/vc7sTJb.jpg) [@media on Twitter](https://twitter.com/media) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
No. You said to try it in css, so I did, and it works, because it is css. Afterwards, the reddit rage squad came to tell me that it hopes I'm not a programmer, because this js interface to css is useful in js. 
It's not necessary to upload the file to the server for processing (unless you need to for some reason). &amp;#x200B; You can load up a JSON object that the user specifies like this: &amp;#x200B; `&lt;input id="file-input" type="file"&gt;` `&lt;script&gt;` `const fileInput = document.getElementById('file-input')` `fileInput.addEventListener('change', event =&gt; {` `const file = event.target.files[0]` `const fileReader = new FileReader()` `fileReader.onload = () =&gt; {` `const json = JSON.parse(fileReader.result)` `}` `fileReader.readAsText(file)` `})` `&lt;/script&gt;`
Uh, it won't work, which is precisely my point: Media queries in JavaScript are not CSS, just as JavaScript is not FORTRAN despite sharing a few basic similarities. I'm not even sure what you're arguing at this point.
Except, of course, media queries as defined in css work here If you are not sure what my point is, it seems weird that you keep saying that I'm wrong Have a nice day 
Bad bot
Thank you, tsteuwer, for voting on twinkiac. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Mind blown. 
&gt; const datas = await Promise.all( &gt; filenames.map(filename =&gt; fs.readFile(filename, {encoding: 'utf8'})) &gt; ) Thanks for this, but I am still unclear of how to incorporate it into my example above. What is `filenames` and what is `datas` referencing in this scenario? I tried doing this, but I believe still having an async issue as `cardsData` is still returning `[]` outside of the `vcardParser.parseFile()`: const files = fs.readdirSync(vcardPath); for (let file in files) { vcardParser.parseFile(`${vcardPath}/${files[file]}`, function (err, json) { if (err) return console.log(err); cardsData.push(json); }); };
Vevo.com used it.
Hmm, setting media queries for a hidden div, and then checking it's CSS attributes to find out which media query is applied? 
No I said put it in a css file. It being the JavaScript code in the linked article.
This isn't a function so much as a workflow.
Unit test the individual parts, don't unit test the `create` function. It has a bunch of side effects.
Clumsily using `SetInterval` to track `window.innerwidth` to notify JS of the corresponding CSS media query and sloppily try to fasten JS and CSS together, and more I probably shouldn't admit lol. Self-taught, program recreationally
It was just an example of how to use async/await. I'm not familiar with vcardParser but I guess it is callback based. I'd write a promise-based wrapper for that: function parseVcard(filename) { return new Promise((res, rej) =&gt; { vcardParser.parseFile(filename, (err, json) =&gt; { if (err) { rej(json) } else { res(err) } }) }) } Now you simplify to: const files = await fs.readdir(vcardPath, {encoding: 'utf8'}) // better than using sync methods const cardsData = await Promise.all(files.map(parseVcard)) Remember you'll need to use `const fs = require('fs-extra')` instead of the built-in `fs` module.
Yep - we use this to detect breakpoints that are tied to various functionality we only support in certain views.
Don’t be obtuse. 
Oh wow. This is excellent. 
The same is true of any API. You can't guarantee that any API will never become deprecated or obsolete. You just have to ask yourself if it's likely. To me it seems very likely that this API will work as-is for the next few years at least, and if I had any genuine concerns I would use a polyfill. 
Couldn't have explained it better myself
I mean.. Neat.. I guess? For those weird times you want a button to launch a modal instead of a menu? Im pretty sure this is Microsoft's doing as a means to provide app functionality for multiple devices that run on JS as an engine instead of C#
Responsive design?
Responsign. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Responsive design?'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Thank you for that. That helps but the total and current gets me. As an example, would that be (total) 1 + (current) 2 and then the result, 3, being the total + (current) 3 etc?
One thing that tripped me up was the anonymous function passed to `reduce`. IE, we could also do this: let arr = [1,2,3,4,5,6,7,8,9,10]; let incrementer = ( total, current ) =&gt; total + current; let decrementer = ( total, current ) =&gt; total - current; arr.reduce(incrementer, 0); // 55 arr.reduce(decrementer, 0); // -55 
\`reduce\` is a function which takes an array and operator and puts that operator between elements of array. So for example if you have array \`\[a,b,c,d,e\]\` and an operator \`+\`, reduce gives you \`a+b+c+d+e\`.
You might hide things in a menu on a small screen or add cascading chevrons.
Question whatever you want, but the fact is I've been benefiting from this API for years already and will continue to benefit from it for years to come. I don't know what else to tell you. 
You're on the right track. In my example of `arr.reduce( ( total, current ) =&gt; total + current, 0)`, internally it would look like this : iteration | *total* | *current* | *return value* ---|---|---|--- 0 | 0 | 1 | 1 1 | 1 | 2 | 3 2 | 3 | 3 | 6 3 | 6 | 4 | 10 4 | 10 | 5 | 15 5 | 15 | 6 | 21 6 | 21 | 7 | 28 7 | 28 | 8 | 36 8 | 36 | 9 | 45 
You can do whatever you want. It's just a matter of understanding what potential risk you allow your customer or client to take without knowing.
For the arrow function,I can show you the same function with different form. function addTen(a) { return a+10} const addTen=(a)=&gt;{return a+10} const addTen=a=&gt;{return a+10} const addTen=a=&gt; a+10 __________________ function isFail(score){ return {score,fail: score&lt;60}; } //isFail(50) output&gt;&gt;&gt; {score:50,fail:true} //isFail(70) output&gt;&gt;&gt; {score:70,fail:false} const isFail=score=&gt;{return {score,fail: score&lt;60}}; const isFail=score=&gt; ({score,fail: score&lt;60});
Removing features on small screens? 
I used it a year and a half ago on a production site. The site is no longer live though. Browser support back then sufficed for that project.
And I understand that. But when this has been working as expected for years already and has full support on caniuse, I'm suggesting that in this particular case the risk is very much worth it, because it's an extremely useful API. 
CSS in an inline block is the same as CSS in an external file, other than timing issues 
I think the easiest way to explain reduce is to look through each iteration to see what values are what. We'll start with an easy one, finding the sum of all of the numbers in an array. ```Javascript let array = [1, 2, 3, 4, 5] let sum = array.reduce((a, b) =&gt; a + b) ``` or if you're not familiar with arrow functions: ```Javascript let array = [1, 2, 3, 4, 5] let sum = array.reduce(function(a, b){ return a + b }) // sum will now be 15 ``` Let's start by first saying that reduce, similar to map, filter, forEach, etc loops through (or iterates) all items of an array. The way it works is whichever value you return from each iteration becomes the next 'a' value. Let's go through each iteration and see what is what. ``` Iteration 1: **a** = 1 // first value in the array **b** = 2 // second value in the array return 3 // a + b 3 now becomes the next **a** value for the next iteration Iteration 2: **a** = 3 // returned value from above **b** = 3 // third value in the array return 6 // a + b 6 now becomes the next **a** value Iteration 3: **a** = 6 // returned value from above **b** = 4 // fourth value in the array return 10 // a + b 10 now becomes the next **a** value Iteration 4: **a** = 10 // return value from above **b** = 5 // fifth value in the array return 15 // a + b ``` Since we have reached the end of the array, 15 is the last result and is therefore returned into our **sum** variable. This works great if all of the values in the array are of the same type (all numbers for example). However, sometimes we have more complicated lists that we still need to get a value from. This is where the second parameter for the reduce function comes in (*note: not the second parameter for the callback function that we pass into the reduce function*). Let's see another similar example, but this time we will have objects stored instead of numbers. ```Javascript let array = [ {value: 1}, {value: 2}, {value: 3}, {value: 4}, {value: 5} ] let sum = array.reduce(function(a, b){ return a.value + b.value }) // this won't work! ``` There's an issue here. It will work for the first iteration because both **a** and **b** are objects (the first two values of the array). However, since the value for the *next* iteration (and all following iterations) will be the returned value from previous iterations, the types will be completely different. We will be returning a number into the next iteration when we're looking for an object (if **a** is a number, **a.value** will give you undefined). One way to fix this is to do a check in the function to see if the type is correct...like so ```Javascript let sum = array.reduce(function(a, b){ if (typeof a === 'number') { return a + b.value // this would be a result passed in from a previous iteration } else { return a.value + b.value // this will be the first iteration only } }) ``` Instead of needing to do a check like that (especially for more complicated things - eek!), reduce allows us to specify what we want our very first **a** value to be. It essentially allows us to inject a value into the beginning of an array so we don't need to do a check for only the first value. ```Javascript let sum = array.reduce(function(a, b){ return a + b.value }, 0) // this "0" now becomes our very first **a** value and **b** will be the *first* item in the array ``` Hope this helps! Once you really start to understand it, you see the real power behind using reduce.
I think the easiest way to explain reduce is to look through each iteration to see what values are what. We'll start with an easy one, finding the sum of all of the numbers in an array. let array = [1, 2, 3, 4, 5] let sum = array.reduce((a, b) =&gt; a + b) or if you're not familiar with arrow functions: let array = [1, 2, 3, 4, 5] let sum = array.reduce(function(a, b){ return a + b }) // sum will now be 15 Let's start by first saying that reduce, similar to map, filter, forEach, etc loops through (or iterates) all items of an array. The way it works is whichever value you return from each iteration becomes the next 'a' value. Let's go through each iteration and see what is what. ``` Iteration 1: **a** = 1 // first value in the array **b** = 2 // second value in the array return 3 // a + b 3 now becomes the next **a** value for the next iteration Iteration 2: **a** = 3 // returned value from above **b** = 3 // third value in the array return 6 // a + b 6 now becomes the next **a** value Iteration 3: **a** = 6 // returned value from above **b** = 4 // fourth value in the array return 10 // a + b 10 now becomes the next **a** value Iteration 4: **a** = 10 // return value from above **b** = 5 // fifth value in the array return 15 // a + b ``` Since we have reached the end of the array, 15 is the last result and is therefore returned into our **sum** variable. This works great if all of the values in the array are of the same type (all numbers for example). However, sometimes we have more complicated lists that we still need to get a value from. This is where the second parameter for the reduce function comes in (*note: not the second parameter for the callback function that we pass into the reduce function*). Let's see another similar example, but this time we will have objects stored instead of numbers. let array = [ {value: 1}, {value: 2}, {value: 3}, {value: 4}, {value: 5} ] let sum = array.reduce(function(a, b){ return a.value + b.value }) // this won't work! There's an issue here. It will work for the first iteration because both **a** and **b** are objects (the first two values of the array). However, since the value for the *next* iteration (and all following iterations) will be the returned value from previous iterations, the types will be completely different. We will be returning a number into the next iteration when we're looking for an object (if **a** is a number, **a.value** will give you undefined). One way to fix this is to do a check in the function to see if the type is correct...like so let sum = array.reduce(function(a, b){ if (typeof a === 'number') { return a + b.value // this would be a result passed in from a previous iteration } else { return a.value + b.value // this will be the first iteration only } }) Instead of needing to do a check like that (especially for more complicated things - eek!), reduce allows us to specify what we want our very first **a** value to be. It essentially allows us to inject a value into the beginning of an array so we don't need to do a check for only the first value. let sum = array.reduce(function(a, b){ return a + b.value }, 0) // this "0" now becomes our very first **a** value and **b** will be the *first* item in the array Hope this helps! Once you really start to understand it, you see the real power behind using reduce.
And you don't have to reduce into a "single item", often times you will see reduce be used to transform an object into an array (and vice versa) ``` const obj = { a: 'apple', b: 'bear', c: 'cat' }; const arr = Object.keys(obj).reduce((acc, key) =&gt; [ ...acc, // "acc" stands for "accumulator" and idiomatically is often used as the first argument { [key]: obj[key] } ], []); // =&gt; [ { a: 'apple' }, { b: 'bear' }, { c: 'cat' } ] ``` Another useful application is to combine `.filter` and `.map` into a single function ``` const data = [{ n: 1 }, { n: 3 }, { n: 4 }, { n: 6 }]; let evenNumbers = data.map(({ n }) =&gt; n).filter(n =&gt; n % 2 === 0); // =&gt; [4, 6] // using reduce is more efficient here since we only loop through data once evenNumbers = data.reduce((acc, { n }) =&gt; { return n &amp; 2 === 0 ? [...acc, n] : acc; }, []); // =&gt; [4, 6] ```
Why not just check window width? Why isn’t this an event?
&gt; `var VAR_TRUE = true;` How would that ever pass code review?
You can use [https://github.com/jhnns/rewire](rewire) to mock your DI at transpile time. I agree with /u/lhorie though, this isn't a unit test per se
Reduce is one of a number of _iterators_, Array methods which call a function an each element in an array. Map is probably the simplest iterator, and if you can understand that, you are halfway to understanding reduce. ## Map Map transforms each element in an array, and returns a new array with the transformed elements: [1, 2, 3].map(function(n) { return n * 2; }); // [2, 4, 6] [1, 2, 3].map(n =&gt; n * 2); // [2, 4, 6] ## Sum Rather than returning an array, _reduce_ uses an "accumulator". This is just a fancy word for "any damn value you please. The classic example is a sum: [1, 2, 3].reduce(function(acc, n) { return acc + n; }, 0); // 6 [1, 2, 3].reduce((acc, n) =&gt; acc + n, 0); // 6 So this reduce calculates our sum in four steps. We could write it out manually like this: var acc = 0; acc = acc + 1; // 1 acc = acc + 2; // 3 acc = acc + 3; // 6 Notice we provided a starting value for the accumulator (`0`). In this case we can skip it. This will result in the first element of the array becoming the starting value for the accumulator, and our function will only be called on the latter two elements: [1, 2, 3].reduce(function(acc, n) { return acc + n; }); // 6 [1, 2, 3].reduce((acc, n) =&gt; acc + n); // 6 // Or written out: // var acc = 1; // acc = acc + 2; // acc = acc + 3; ## More advanced reducing Reduce is the most "manual" of the various iterators. You have to do more leg-work yourself. This also means reduce is more versatile. For example, we could replicate our map from earlier using reduce: [1, 2, 3].reduce(function(acc, n) { return acc.concat(n * 2); }, []); [1, 2, 3].reduce((acc, n) =&gt; acc.concat(n * 2), []); // [2, 4, 6] // Written out: // var acc = []; // acc = acc.concat(1 * 2); // acc = acc.concat(2 * 2); // acc = acc.concat(3 * 2); Obviously this is silly. Map is easier to read and write. But hopefully it gives you an idea of what can be done with reduce besides just summing numbers. Another fairly simple but common way I find myself using reduce is to count the elements in an array: ['a', 'b', 'b', 'c'].reduce(function(acc, n) { acc[n] = acc[n] ? acc[n] + 1 : 1; return acc; }, {}); // { a: 1, b: 2, c: 1 } ## Arrow functions Don't be intimidated by arrow functions. They are awesome. An arrow function with curly braces is basically identical to a regular function: const sum = (x, y) =&gt; { return x + y; }; // Written out as a function: // const sum = function(x, y) { // return x + y; // }; If your arrow function is a one-liner and you omit the curlies, you can also omit the return statement. This isn't dark magic, it is just implied that the arrow will return the results of the one line if there are no curly braces: const sum = (x, y) =&gt; x + y; If you have only one parameter, you can also omit the parens if you like: const square = n =&gt; n * n; // Written out as a function: // const square = function(n) { // return n * n; // }; This is all just syntactic sugar. The only actual technical difference between an arrow function and the equivalent traditional function is that arrow functions have no `this` or `arguments`. So if you need `this`, use a `function`, otherwise just use `=&gt;`. 
What’s a good use case for this?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/Functional-Light-JS/.../**#reduce** (master → 13a3bda)](https://github.com/getify/Functional-Light-JS/blob/13a3bdafb4edb83207db76212312472aab20d06a/manuscript/ch9.md/#reduce) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e4m5ota.)
Ho boy. I imagine you've found the window resize event useful these days?
How are scroll events related to this? Just curious, I genuinely don't understand.
Few things match the high of removing unnecessary code for me.
Pretty useful when using jsx or so! Always use css as the primary solution though! 
Mithril.js You can’t go wrong.
Media queries can be used for much more than window width. With regard to it being an event, it is. window.matchMedia returns a MediaQueyList object that includes addListener and removeListener methods. The listeners are fired when the matches state of the media query changes. As your listener is only invoked when the relevant threshold is crossed this technique is much more efficient than using a resize event which will fire constantly during resizing. https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener#Examples
This is not part of ECMAScript, this belongs to browser APIs. 
Nah, just catch it at runtime
Scroll events? Do you mean window resize events?
Can’t you get everything you get from css media queries, in JS, by listening to window resize events and doing a bit of math?
You are an idiot. 
Generally, a reduce is just a clean way to convert a collection into something else, often a single value, without affecting the outside world directly. This is slightly different than a forEach, which is purely for looping, and map, which is for converting one collection into another collection. First, rewrite a simple reduce function without arrow functions. Then you can come to grips with what it does. Then, write your own reduce function that takes a callback and an initial value. Once you do that, you will understand how it works since you made one.
Definitely have used them. Check guildwars2.com/path-of-fire
This is what I've done and it works quite nicely. I knew about matchMedia but it is annoying to manage 2 sets of the same card -- one is scss and the other in js
My eyes are bleeding when I see typos in function names.
Promises are just sugar. Functions are sugar. C is just sugar. Assembly is just sugar.
Yes, but now you don't have to
This is absolutely golden for React/Vue etc. You can render one component on desktop and one on mobile for example.
Very neat, last thing I used a while back for this was jRespond (https://github.com/ten1seven/jRespond)
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
It's not a function :-P
Did you read the article? And try it in a js script? It's really fun to use!
Can anyone answer why this would be better than using window.innerWidth? Because I've been using window.innerWidth to check if I should render a mobile version of React component and it did its job without problem (that I know of).
How is it different from window.innerWidth? https://developer.mozilla.org/fr/docs/Web/API/Window/innerWidth
Dude it’s a new feature so you can’t have been aware of it for that long 
It’s a new feature so you couldn’t have used it if you knew about it 
Media queries can do more than just detect the screen size; it can tell if the screen is in landscape or portrait, the screen's pixel density, the color bit depth, whether the device's input method allows the user to hover over stuff (as opposed to a touch screen, where you're either not interacting with the screen at all or clicking on something), the light level from the device's light sensor, how precise the user's pointing device is (if any), whether there's a speech synthesizer, whether the page is being printed, etc.
what??
Jesus Christ. 
I would like around the documentation sites for things like this. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce Basically reduce allows you to iterate over each item in an array and for each item choose to perform some operation against/on it, then return that result into an accumulator object if you want to. I often use reduce to transform objects into arrays and vice-versa, often mixed with some sort of a transformation and/or filter. For example, if I receive an array, but I know I'm going to need to search it a bunch for certain key values, I'll use reduce to create an object keyed on the value I need to look for, hence reducing my array traversals to one.
yes!! please put more elektronshit on my desktop!
They have little in common. You might be able to solve your problem with innerWidth. But some problems can be based on that users can resize the window or change the viewport orientation. This is generally handled with media queries in css, but you might want to handle this dynamically in JS as well.
There’s a consensus in the UX community that less information should be displayed on smaller devices. You seem to only consider the separation of concerns ”codewise” in your statement but this thinking is no longer the norm on the web. I would probably mainly use this to prevent rendering of features that are not feasible for the viewport.
[Imgur](https://i.imgur.com/OP518e7.png) What's wrong with downloading the images you want, and using the default UI to change it? OS X and Windows both have these options and it's possible linux desktop systems do too. Hell, you could built a shell script that gets a random image (I'm assuming unsplash has an API) when you press a key combination and saves it to a wallpaper cycle folder.
Sure, a shell script is neat and pretty easy to implement(maybe less than 5 lines of code). Your approach makes more sense for developer users and they are 1% of all. My designer friends would not like a thing running inside a black hole.
I write js everyday so electron is pretty straight forward and the out-of-box tool for me to build an desktop app. What’s your point? 
If you are using React, `componentDidUpdate` will be called multiple times when your component re-renders. So your code will be adding multiple event listeners when the re-renders are triggered while your `this.isConditionFulfilled()` is `true`. &amp;#x200B; Try changing your `componentDidUpdate` as below, componentDidUpdate() { window.removeEventListener('beforeunload', this.handleBeforeUnload); if (this.isConditionFulfilled()) { window.addEventListener('beforeunload', this.handleBeforeUnload); } } The above code makes sure that there is only one event listener bound.
I have to admit Parcel has take a huge chunk of my tooling lately. Though that said I always kinda hated Webpack and never really used it. 
As the spec reveals you can dynamically react to media queries similar to what you can do in css. These two props literally have nothing in common. You might be able to solve the same problem with either however
Chrome on Android is ? then MediaQueryList has 9. eh?!?
Well the issue is that Electron has terrible dependency management and every application spawns its own Chrome instance so I guess he's annoyed by that
There’s definitely a way to detect when the page has stopped resizing. Also, debounce.
Debounce, baby.
A powerful project that is ready to change the world.
Could you elaborate on what is a unit test and what is an integration test? I would have considered this a unit test since I am only testing a single method. I don't care what PasswordSecurityService, UserGateway, or EmailService are doing. All I care about is that I am sending the correct data to them. 
Reduce is used for concatenation (turning many things into one thing using a single operation). Instead of `a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e` you can do `[a,b,c,d,e].reduce( (combined, bool) =&gt; (combined &amp;&amp; bool))`. This can be used for any forms of concatenation including mathematical operations (a + b + c ) or even object bundling // obj[a] = a, obj[b] = b, obj[c] = b [a,b,c].reduce((obj, item) =&gt; { obj[item] = item; return obj; }, {})
addEventListener won't duplicate handlers if called multiple times with the same signature. window.addEventListener('beforeunload', this.handleBeforeUnload); window.addEventListener('beforeunload', this.handleBeforeUnload); window.addEventListener('beforeunload', this.handleBeforeUnload); // ^ handleBeforeUnload only added once
You can also use CSS properties and read them from script. For example, set the z-index of the &lt;body&gt; to 1 for desktop, 2 for tablet, 3 for mobile using media queries. Then if your JS needs to know the current media query, just check the z-index style prop of the body tag. `function getMediaQuery(){` 
Memory cost? Cpu cost? That’s not even a concern for me as I have hundreds of tabs in my chrome anytime and they work well for years. It’s ok I do understand why people hate it. Thank you for your idea, I’ll put it in consideration. :)
hmm I would say rendering different component sets for mobile/desktop ?
I don't see why it wouldn't be working. While the behavior has slightly changed with the arrow syntax - it creating an instance member with an arrow function rather than a shared method - its value should not be altered during the lifetime of your instance and should continue to work within removeEventListener. http://jsfiddle.net/6nms0f5d/
I also have no issues, only when the application goes nuts when indexing node\_modules or something like that. Btw.: Rotating trending pictures might be neat as well :)
Neat!
Typescript should be verifying that you are sending data in the right format. Beyond that, what is "correct" data? Answer that and you'll have your answer.
The Mac command key is called the meta key in the API. You can check for that and a bunch of other modifiers the user might use to try to open a new window like so: if (e.button == 0 &amp;&amp; !(e.metaKey || e.shiftKey || e.ctrlKey)) e.preventDefault();
You're right! My bad. Was thinking that `this.handleBeforeUnload` is an anonymous function. &amp;#x200B; [https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Multiple\_identical\_event\_listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Multiple_identical_event_listeners)
That's if you want to dynamically download them. The manual download method and default UI is still available. It's not that it's a bad idea of project, but that it seems like a duplication of efforts for something already available natively to some extent.
does it help to make an equivalent iterative loop to show you how `reduce` works? you mentioned es6 fat arrow functions being confusing, i've written this using a function declaration" const arr = [1,2,3,4,5,6,7,8,9,10]; const sum = arr.reduce(function (total, current) { return total + current }); let total = 0; for (let i = 0; i &lt; arr.length; i++) { let current = arr[i]; total = total + current; } const iterativeSum = total; console.log(sum, iterativeSum, sum === iterativeSum); // 55, 55, true 
How did I miss this?
&gt;As mentioned earlier, the amount of cases for boolean variables is 2^n. For our isRaining function with 4 variables, we would have a total of 16 cases. A loop size of around 64 will **most likely** cover all cases. For regular numbers in JavaScript, the amount of loops is much higher. (emphasis mine). why will 64 cover most cases though? did i miss something that explains this? is this rule of thumb or is this mathematically derived?
The correct data is just the data that was sent to the function [PasswordSecurity.secure](https://PasswordSecurity.secure) should receive the password that was passed to create EmailService.sendRegistrationEmail should receive the email that was passed to create UserGateway.create is an exception though since it receives the the userDto, with the secured password. This one isn't as clear but the secured password is just a value returned by a mock function. I'm not testing any functionality outside of the UserService.create function. 
Thank you I appreciate your help thus far, but I am not following. I have tried wrapping like you said, and even using the simplified versions, but nothing appears to be working. I am currently getting `TypeError: this.parseVcard is not a function` here is the file in whole: "use strict"; const NodeHelper = require("node_helper"); const fs = require("fs-extra"); const vcardparser = require('vcardparser'); const vcardPath = '/contacts/card/'; module.exports = NodeHelper.create({ // Subclass start method. start: function () { this.started = false; this.loadVcards(); console.log("Starting helper: " + this.name); }, socketNotificationReceived: function (notification, payload) { if (notification === "ADD_CALENDAR") { this.loadVcards(); } }, loadVcards: function () { let cards = []; let cardsData = []; fs.readdir(vcardPath, function (err, files) { if (err) throw err; files.forEach( (file) =&gt; { this.parseVcard(file); }); }); }, parseVcard: function (file) { return new Promise((res, rej) =&gt; { vcardParser.parseFile(file, (err, json) =&gt; { if (err) { rej(err) } else { res(json) return cardsData.push(json); console.log(cardsData); } }) }) } }); 
There's basically no logic in your create function to test. Consider instead writing unit tests for the services instead, they're the ones that are doing the heavy lifting. I personally don't write unit tests for anything except pure functions.
Hi! A month ago I posted about a JS tool for browser image classification: https://www.reddit.com/r/javascript/comments/92228h/i_created_a_tool_for_training_image/ I wrote the linked article as a deep dive into some of the internal considerations, like setting up your data pipeline, loading the pretrained model, and tuning the last layer. 
Good question. I've written *most likely* in italics, because there is a chance that not every case will be tested. I picked this number just by multiplying the amount of cases by 4, which I deemed sufficient without much more thought. If my probability is on point, there is a 98% chance that we will test all cases; 1 - (15/16)^(64) = 0.983. (15/16)^(64) is the probability of **not** seeing a particular case.
Dude was bored, wanted to sharpen his skills and built a neat side project. Give some chill. Best way I've found to learn shit is by duplicating shit that's natively available.
while (true) is an infinite loop, that's what causing the crash 
&gt;exports.delete\_rating = async (req, res, next) =&gt; { &gt; &gt;const id = req.params.ratingId &gt; &gt;const currentUserId = req.userData.userId &gt; &gt; &gt; &gt;try { &gt; &gt;const result = ratingsDatabase.delete\_rating(id, currentUserId); &gt; &gt;res.status(200).json(result) &gt; &gt;} catch(err) { &gt; &gt;res.status(500).json({error: err}) &gt; &gt;} &gt; &gt;} &amp;#x200B;
Call the function inside the function again, in other words, use recursion. Declare the function and call again inside the function block. I am on mobile, cant write it now. While true causes and infinite loop, dont ever do that :)
You're introducing logic into unit tests and obfuscating the error messages generated by them by using some of the libraries you provided. I'm not sure I would be happy about a test approach that uses more logic than the pure basics.
Gotta test them tests too.
Most of my other services are basically just wrappers on external libraries. EmailService is a wrapper around Nodemailer. UserGateway is a wrapper around a TypeORM Repository. PasswordSecurityService doesn't even have much logic, it prehashes the password using crypto then secures it using bcrypt. I'm building a rest api so most of what I'm doing is taking data from the user, validating it, and saving it to a db, then retrieving it at a later time; with a couple additional services like email and password security. If I only write unit tests for pure functions then only a tiny fraction of my code base would have unit tests.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
If most of your code is just wrapping external libraries, wouldn't that be expected? You shouldn't be writing tests for other people's code... 
for(var obj in response['items']) { Logger.log(obj); } 
These objects are all in an array. So you should be able to loop through and pull out each objects property at the corresponding array index. A simple example as below: `for(var i = 0; i &lt; array.length; i++) {` `console.log(array[i].distance}` `// property = array[i].distance //` `}` Where 'array' is a placeholder for the array name in your query
Exactly, which is why Property based testing could probably also be labelled as bad/unreasonably complex tests.