Hey, this is really great work! I like how the games smoothness, intuitive controls, nice animations and neat graphics. Works great on Nexus 5! I also tested it on my desktops, working smoothly on Arch Linux and Xubuntu using both Chrome-Stable and Firefox. Keep up the good work. I wished, my projects would end up high quality as this. Also, nice animation after winning a game, reminds me on the good old windows solitaire. Looking forward for more games. I will undoubtly kill much time with this :)
Common misconception about the size comparison. Minified Angular is actually smaller than Backbone if you consider the fact that Backbone requires Underscore.js, and for most applications you will also need to include something like JQuery, or at least Zepto. Angular works right out of the box, and is only 35K or so. No JQuery necessary, because you get JQueryLite for free. 
Yeah I'm working on a customer project that displays and table which needs to support 100x100 and it's a struggle 
Cheapest way I can think of is to make use of window.location.search, which gives you everything after and including the '?' in a URL. i.e. The window.location.search of http://www.reddit.com/r/javascript/comments/2fbif3/random_page_generator/?2,0 is "?2,0". The idea would be that on page load, you'd parse this information into an array with something like the following. var answered = window.location.search.replace('?', '').split(','); The value of answered above would be ['2', '0'] Let's say now you have an array defining all your questions and correct answers, like so: var questions_answers = [ {id: '0', question: 'Is the phrase "Hello world!", grammatically correct? ', choices: ['Yes', 'No'], answer: 'No' }, {id: '1', question: 'What is 1 + 3?', choices: ['2', '4', '5', '-2'], answer: '4' }, {id: '2', question: 'Is Tribuadore awesome?', choices: ['Yes', 'No'], answer: 'Yes' }, {id: '3', question: 'What do you call a shape with three sides?', choices: ['Square', 'Circle', 'Triangle', 'Rectangle'], answer: 'Triangle' } ]; You can now iterate the questions_answers array and remove entries who's id is in answered, like so: var i = questions_answers.length; while(i--) { if (questions_answers[i].id in answered) { questions_answers.splice(i, 1); } } Running with the example, entries with ids '2' and '0' would have been removed and questions_answers would now only contain questions that have not previously been asked. [ {id: '1', question: 'What is 1 + 3?', choices: ['2', '4', '5', '-2'], answer: '4' }, {id: '3', question: 'What do you call a shape with three sides?', choices: ['Square', 'Circle', 'Triangle', 'Rectangle'], answer: 'Triangle' } ] You can then use the remaining length of questions_answers to determine if there are still unanswered questions with: questions_answers.length &gt; 0 And if there are, pick one at random with: var question = question_answers[~~(Math.random() * question_answers.length)]; When the users input = question.answer, you'd push the answered questions id onto the answered array and reload the page passing an updated search value in the new URL as follows. answered.push(question.id); window.location.href = window.location.origin + window.location.pathname + '?' + answered.join(','); 
And with React — http://www.google.com/trends/explore#q=angular.js%2C%20backbone.js%2C%20ember.js%2C%20knockout.js%2C%20react.js&amp;cmpt=q
Hey - just came across this. Thank you so much for your efforts.
This is fantastic. I've a client that wants ftp access on their website for their own clients to pass off documents that they store on a local windows server. Something like this would rock.
Depends on how complicated your site/app is. For simple things, and if you're only dealing with modern browsers, then you may be able to do away with jQuery entirely. For more advanced things, or for where cross-browser compatibility is important, still use jQuery.
Do you have some figures on the threshold beyond which you see significant performance degradation?
Lol, well having started web development in the mid 90s (yay Perl CGI) I've been through a shitload of changes. We'll see where this all takes us.
If you are supporting IE10+ and recent FF and Chrome only, then you could get away with not using jQuery. The book "DOM Enlightenment" at O'Reilly isn't too bad if you want to transition away from jQuery towards plain DOM. http://shop.oreilly.com/product/0636920027690.do 
Yes. After 10 years, my company still does not use, and has no need for, jQuery and we do all the animation and page manipulation that you see on most web sites. jQuery is just a javascript library written in javascript. To say one uses it so you don't have to do that work is just lazy. Once you do it, you don't have to continue with it.
Both have their valid uses. If you want fast results and save development time, use jQuery as much as is reasonable. Once you need performance (e.g. inside event handlers or async operations), switch to vanilla JS.
It's been kind of jank to get set up. The installer doesn't create the proper folders that npm needs (leading to the NOENT errors) so I've had to create them myself and it seems to work fine after that.
Context: I've worked with TypeScript at my company for around 5 months now. It has helped keep our codebase saner, but the more I use it, the more I run up against its deficiencies. And they don't have as much to do with a lack of features as a Java/C#-ish approach that seems to have informed the development of TypeScript. Unfortunately, this makes it a poor match for how JS is often written (and how I want to write it), meaning that TS is not the 'Typed JavaScript' that I really want to see. What would be nice is some tool that just adds type annotations to plain JS, perhaps in special comments à la JSDoc, and then can analyze them. Something like [clojure.core.typed](https://github.com/clojure/core.typed). Not only would this be easy for JS devs, but it would integrate nicely with existing codebases. Currently, it seems that to get type checking, you have to switch to a different language and compile to JS. 
This presumes someone is using jQuery in such a way that it affects performance. Most people aren't looping $() a million times. They call it a few times here and there. Benchmarks like this one (http://jsperf.com/vanilla-js-ftw-jquery-vs-js) are running tests that call $() tens of thousands of times. Who does that in a real application? It's a complete red herring. jQuery is perfect under normal usage (the vast majority of cases). The super rare site that needs to look up tens of thousands of elements should probably use vanilla JS. Everyone else can use jQuery and be secure in the knowledge that they didn't make a bad decision.
TBH depends on what you want to do with the selector. If you need to wrap it around a jQuery function after selecting it, then you'll really need to keep using the $. Other than that you are free to use whatever feels more confortable. Whenever I use jQuery for a project, I will keep selecting nodes with the $ just to keep things within the same "pattern" I guess.
You can achiev the same result chaining the promises within the return of the promise. Honestly I find q.all more fancy overall. But the chaining it's a valid option still.
thanks! awaiting ep 3
You could maybe use a simple data-dropdown for each of the first options inside the dropdown, and add a listener for a change on the first dropdown. Once the user selects the first option, you populate the second dropdown with the data-dropdown from the selected option.
The dude asked, and I provided a link to a resource. Also the site is *you might not need jquery*, not *you definitely don't need jquery*.
There is a vanilla js function with syntax similar to jquery selectors: it is document.querySelectorAll() Or document.querySelector() About the rest, try to use jquery only if you really need it. It's hard to decide properly what "really" means: for me it's when 1. Heavy use of custom events or ajax. jquery makes these two very easy and straightforward, and in a large code base is way more readable. 2. Compatibility with older browsers. But most of the times this is not really an issue (at least for me).
Google's Closure compiler supports type annotations inside JSDoc comments. https://developers.google.com/closure/compiler/docs/js-for-compiler I don't know if the type system there is much better. 
&gt; What would be nice is some tool that just adds type annotations to plain JS, perhaps in special comments à la JSDoc, and then can analyze them. [Closure compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler) does exactly this. At least in theory. In practice, I don't think I've ever managed to get a type error, so I'm a little dubious about its efficacy.
It's sufficient to run a rather complex/high-end query (:visible) inside an event that fires more than once, e.g. scrolling to affect performance negatively. But you are right, in most cases of "normal usage", you can safely use jQuery without a second thought.
Does it have any kind of IDE support? 
jQuery offers a lot more functionality than simply selecting an element. You'll receive a jQuery object that allows finding, filtering and mapping over child elements rather than a simple reference to a DOM object. In the end jQuery is "just" a cross-browser wrapper for several JavaScript APIs with a lot of convenience functions. If you only need one JavaScript function to insert some text into a DOM element, you won't need jQuery. 
Haha, looks like we both had the same idea. Since you're already aware of closure compiler, though, I guess I'm not sure what you're asking.
Autocomplete
Your kind of argument is why web site page averages have gone over the 2MB mark.
Now I'm even more confused. Edit: I got it now. I'm slow. I was thinking phone autocomplete, not IDE autocomplete.
but the return wont fire until after the first promise, where as q.all will fire them at same time so their is less delay
That was initial plan, however that first drop-down will have variable information as well. The schools and courses offered will likely be updated weekly.
I am fundamentally against TypeScript because Microsoft is pushing it.
For vim there's ~~nerdcommenter~~*. Type `/**` above a function, hit tab, and it will generate a very basic stubbed out annotation for you. Basically just this: /** * [description] */ function foo(bar, baz, qux){return quux;} It may be possible to do more with it, but I haven't played around with it too much. For sublime text, DocBlockr does this much better: /** * [foo description] * @param {[type]} bar [description] * @param {[type]} baz [description] * @param {[type]} qux [description] * @return {[type]} [description] */ function foo(bar, baz, qux){return quux;} Other than that, I'm not sure. Edit: It's not nerdcommenter generating the annotation. ~~It may be vim-javascript-syntax or vim-javascript.~~ It's Ultisnips. 
And...? 
That's why computers need bigger, faster processors with more memory and faster networks cause people like you don't take the time to learn how stuff works but blindly follow what you're told to do. We would have never made it to the moon today cause there was no framework for that.
If you want to change the URL to be a breadcrumb, how do you expect for people to share the link? I'm not sure of your use case, but I doubt what you're trying to do is a good idea.
Looks like something they copied from dynamicdrive 12 years ago.
Do you just never use libraries then because it might have features you don't use every time?
That site is about building libraries...
You've picked the most simple example. `document.getElementById()` has existed forever and there's basically no cross-browser compatibility issue there. But consider something like `$('.foo li')`. `document.querySelectorAll()` can handle that directly and works on *most* browsers, but not IE &lt; 8. Do you care about IE6 and IE7? If you do, there's no simple replacement, but jQuery has your back (at least on the 1.x branch.) If you don't, then you might not need jQuery. The differences start to become more and more apparent the more features you use. Have you ever tried to do AJAX/XHR by hand in a way that works across all browsers, even old ones? It's not fun. There is not going to be a simple straightforward replacement that's just a little more typing for everything. 
Just to clarify you would like to parse all the H1's on the page and create a breadcrumb that looks something like this? H1 &gt; H1 &gt; H1
Great reply. Also remember that when jQuery was first released, there was no document.querySelector. To select by classname required looping through the DOM, which is how classname selection in jQuery was first written (same code, hidden by a nice interface). As time went on and as browser vendors created better ways to access elements, the underpinnings of jQuery were rewritten to take advantage, meaning that just by upgrading jQuery, your selector code would be automatically improved. 
uwotm8?
pretty much every complaint he had in typescript is solved with the closure compiler. 
I get type errors the whole time. What is your compilation mode. It needs to be set to advanced.
I have been using TypeScript for almost a year now. It definitely has its faults and benefits. On the whole, if you're looking for static typing in JavaScript then TypeScript is a no-brainer. There are other typing systems for JS that all serve similar purposes. IMHO the best way to effectively manage large enterprise JavaScript applications is by using a type system. I enjoyed reading your post, and I have a couple comments/questions: **Union types** FWIW, they are in the works (https://github.com/Microsoft/TypeScript/issues/14), but that doesn't necessarily help right now... **Higher-kinded types** I've struggled with this issue a lot, I'm hoping for better support in the future. **Failure to Model JS values** I haven't noticed too many problems with this, although it definitely can be difficult depending upon how you write your JavaScript. Could your example for a `tuple` be modeled as follows? interface MyTuple extends Array&lt;any&gt; { 0: string; 1: number; 2: HTMLElement; } **Faulty type system** I wholeheartedly agree with you on this, I wish there was some warning for when a type could be null. **No type aliases** I'm not sure what you mean here, the following code works (compiles) for me: interface Url extends String { } interface Set&lt;T&gt; { add(item: T): boolean; clear(): void; contains(item: T): boolean; } enum Suits { HEARTS, SPADES, DIAMONDS, CLUBS } interface Card { value: number; img: Url; suit: Suits; } interface Deck extends Set&lt;Card&gt; { } var deck: Deck; deck.add({ value: 2, img: '', suit: Suits.HEARTS }); **Classes** Classes are going to exist in ES6, and TypeScript adds pseudo-support for them now. I understand your concern over `this`. That being said, if you know JavaScript, then it's no more confusing to use `this` in a class.
I use intelliJ and the support is great, not jvm language great but great for js.
Quite the detailed article. Thanks!
From the article: &gt; It seems to be trying to turn JS into C# while ignoring the drawbacks and limitations of that approach. And your comment: &gt; [...] a Java/C#-ish approach that seems to have informed the development of TypeScript Not sure if you're aware, but for better or worse, this is [no accident](http://en.wikipedia.org/wiki/TypeScript): &gt; Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on development of TypeScript. 
I enjoyed this link more: http://blog.humphd.org/introducing-makedrive/. Great, and exciting, idea. Thanks for clueing me into it!
Gotcha. I guess I gave up on advanced optimization because it looked like it wasn't going to work with the code browserify was producing. But now I see that closure compiler supports commonjs, so I'm going to have to revisit that.
Thank you very much. I've been looking to get into node.js and it looks like this is my cue. Keep 'em coming!
This was an issue with the code browserify itself was generating. `require`, `module`, etc. I just tried making an`externs.js` file just to declare those variables. It worked, but that's starting to feel like I'm working for my tools, and not the other way around.
I'm sorry, but in real life you will never (want to) use this.
Sorry, but who exactly said that? &gt;"You can replace $(whatever) with document.querySelectorAll(whatever)!" Anyone who expects the JQuery API to match exactly the DOM API is delusional. However, I would say that for the vast majority of use cases, it's trivial to easy to transform your calls to use querySelectorAll correctly.
I was able to type letters into it in the demo...
I don't think browserify does any async loading. Anyway, all I'm using it for is to bundle up a project that I've been developing as a series of discrete modules, so I end up with a single build.js file that I can put in a script tag and not have to worry about manual dependency management. That may just be how the --standalone option works, though. I wasn't having any luck with it earlier, but I'll look into CC again. 
What makes this a library? Its a single function.
Why would you not just use: &lt;input type="number"&gt;
It also occurs to me, CC probably won't do some of the other dependency management stuff I have browserify doing anyway.
I'm sorry but there are much better ways to handle that. First of all you could just use ng-pattern="(\-){0,1}\d*(\.\d*){0,1}" Secondly, if you require ngModel, why not use ngModelCtrl.$validators instead of watch?
Why are you asking here?
q.all() fires then both on resolve and reject of promises you pass into it, i.e. You will get q.all() fired when all of requests are finished but not necessarily successfully. Edit: I'm so much wrong
First, you can reference the image and use it with CSS rules. http://webdesign.tutsplus.com/articles/css-sprite-sheets-best-practices-tools-and-helpful-applications--webdesign-8340 If you need the sprites as individual assets, there are a number of tools like Texturepacker or GIMP or Photoshop that both pack and split images with various degrees of sophistication and automation.
This only goes back to 8/7 because the [previous run](http://www.reddit.com/r/r_javascript_stats/comments/2d3gln/subreddit_stats_javascript_posts_from_20140626_to/) included up to 8/6.
Could someone explain it differently? I got kind of confused reading it
You can't possibly disagree with all 5. Elaborate for the OP?
You got this all mixed up. JS and jQuery access the same DOM. Nobody who knows their shit ever says "vanilla DOM". JS is just a programming language that is able to interact with **THE** DOM. jQuery is a library that drastically changes the way you would write this code. Thus there's the "jQuery way" to go about accomplishing something in JS and the "vanilla" way, which means doing it without any design patterns or help from other libraries might push on you.
[Standard Markdown](http://standardmarkdown.com) [fixed]
This has been desperately needed for so long. Every Markdown package seems to have its own quirks and conventions.
Is {method,other} pseudo code or some strange es6 syntax?
Since this is probably pretty abstract, let me show you an example of creating a 2D vector "class" in this style. function createVector(x, y) { var coords = { x: x, y: y }; function scale(factor) { coords.x *= factor; coords.y *= factor; } function addVector(anotherVector) { coords.x += anotherVector.getX(); coords.y += anotherVector.getY(); } function getX() { return coords.x } function getY() { return coords.y } return { getX: getX, getY: getY, scale: scale, addVector: addVector }; } Notice how in this example, the `coords` is completely private. No one calling `createVector` and getting a vector back can directly modify it. The `coords` object remains the source of truth for the vector, but it can only be modified or read by the outside world through the functions exposed.
One nitpick: &gt;Classes are going to exist in ES6... [Not](http://www.joezimjs.com/javascript/javascript-prototypal-inheritance-and-what-es6-classes-have-to-say-about-it/) [really](http://www.frontendjournal.com/javascript-es6-learn-important-features-in-a-few-minutes/), [no](http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/). ES6's "class" support is really just syntactic sugar. Under the covers, it's all still prototypes.
The first few lines are ES6 destructuring assignments. The return line includes an ES6 enhancement to object literals that desugars to `{method: method, other: other}`.
I'm pretty sure the new part he was referring to was the ES6 syntax, which is certainly new :)
how does that work with minification?
Great, assuming your minifier understands the new syntax. I don't think anything about this form is bad for minifiers, and in fact if you can target ES6, minifiers can automatically transform `{foo: foo}` into `{foo}`.
Are you talking about the argument passed to `Object.freeze`? In ES6 object literals where the key and value are repeated can be condensed. `{method: method, other: other}` can be written as `{method, other}`. The other uses are destructuring assignment. `let {member} = ...` is the same as `let {member: member} = ...` which is saying declare a local variable named `member` and initialize it with the `member` attribute of whatever is on the right hand side of the assignment operator. For example: function foo() { return { foo: 12, bar: 42 } } let { bar } = foo(); console.log(bar); // =&gt; 42 But they don't have to have the same name: let { oldname: newname } = { oldname: 'abc' } console.log(newname); // =&gt; abc 
This is all fine and dandy for only a few instances, but the advantage with using `new` and prototypes is the memory footprint. Every instance of your class has a copy of each of its functions in memory (**edit:** closures also take up memory, btw). This is why languages that have real classes store a *single* copy of each instance method in memory. Prototypes do a somewhat similar thing.
Thank goodness for this standard. Edit: Mea culpa. It's a specification "called standard", but "isn't a standard specification"
I vaguely recall some conclusion that creating classes as closures this way did not perform nearly as well as traditional constructors and prototypes, so I did a quick check. In my data set of me (Chrome, Safari, and Firefox on a Mac) it looks like in Firefox and Safari the traditional constructor and prototype classes significantly outperform closure classes, but on Chrome while object creation was slightly faster than closure creation, use of the closure style objects was faster. Though if the numbers are to be believed, Chrome seriously underperforms both Firefox and Safari, to the extent that I am doubting whether my benchmark is valid. Check for yourself at http://jsperf.com/methodvsclosure
If you are creating hundreds of thousands of objects on a regular basis, then this might be an optimization you should think about. But there's no way this has any discernible effect on the vast, vast majority of JavaScript applications running in a browser. 
Please see my reply above. The vast majority of time spent in a browser will be doing DOM manipulation. There is no way in hell this will have any kind of impact on the performance of a web application.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 785 times, representing 2.4294% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_ck8kffy)
Hopefully by now the JS engines are all optimized to not duplicate the function body, but only the function object and the closure context. That is, the data that differs between instances of these closure classes should be roughly the same size as the object returned from the constructor.
Apples to oranges. If my JS is just doing DOM manipulation then how I declare my classes also doesn't matter much. But there are types of web applications (or other JS apps) where DOM manipulation is minimal and JS performance does matter. If we're going to take the time to debate this level of detail in how JS objects are constructed, then I think the relative performance should be part of the debate. Another difference is it's kind of a pain to debug closure objects. I know, you can just stick the 'coords' into the objects during development to provide a reference, but that's still not quite as convenient as traditional objects.
Relevant: http://blog.vjeux.com/2013/javascript/jsx-e4x-the-good-parts.html
He's showing how ES6 destructuring assignments can be a substitute for multiple inheritance or mixins with private variables. **Destructuring explained** Say spec is an object: {member: 42, foo: "test"} The destructuring assignment: let {member} = spec; Initializes the `member` variable to 42: console.log(member); // 42 Short for: var member = spec['member']; [More examples!](http://fitzgeraldnick.com/weblog/50/) **What he's doing** Now if each constructor is passing back an object: {method1: ..., method2: ..., other: otherConstructor } When he calls: {other} = other_constructor(spec) This is assigning the variable `other` to invocation of `other_constructors` on the `spec` object, giving you access to all applicable methods provided by the other constructor. You could reference those by calling: other.foo() He even says you could do: {otherA} = other_constructorA(spec) {otherB} = other_constructorB(spec) You could then choose to expose methods of A or B in the return return Object.freeze({ other: ..., foo: otherA.foo, bar: otherB.bar }) Also Object.freeze({ method, other }) Is ES6 short hand for: Object.freeze({ method: method, other: other }) **Why?** This is nice because you can no longer tamper with anything a constructor gives you.
This is the correct answer.
Downvoters explain
[Jasmine](http://jasmine.github.io/) is pretty nice, from my own experience. I've also heard good things about [QUnit](http://qunitjs.com/) and [Mocha](http://visionmedia.github.io/mocha/), but I haven't used them personally.
It's not a standard. It's a fork called "Standard".
I would just use [tape](https://www.npmjs.org/package/tape) since it's small, runs in the browser and in node, doesn't rely on globals or "magic", integrates easily with continuous integration and github hooks, etc. See [here](http://www.macwright.org/2014/03/11/tape-is-cool.html). As for the test suite itself, you should probably look at other engines/libraries that deal with geometry to see if you can use the same tests. 
I want _ to mean underline, darnit.
Ok, wow
It's fair to say that people generally don't underline on the web, but it would be nice if it were *possible*. HTML does provide the ability to underline, and the syntax for italics is unnecessarily overloaded to use both asterisks and underscores.
Can you please elaborate? Isn't the aim to be a standard specification for markdown to solve fragmentation? I don't understand the semantic difference.
"It's good to be educated and capable of making your own decisions, but I'll go ahead and tell you what you should do." Congratulations, you are exhibiting exactly the attitude you are complaining about.
&gt; If I then change an instance method on that object at runtime, I change every other object in memory that shares the prototype. This is incorrect.
And you obviously don't use a mobile browser!
I downvoted, not becasue it's tasteless, but because it's unfunny.
Not sure if sarcastic or not. Docx and markdown have very little in common
Well, it's just a bunch of guys who decided to do a fork of Markdown. They did it in private and without any input by John Gruber (its inventor) or the community. This didn't go through a standardization process and their spec also isn't finalized yet. Also, by calling their fork "standard" they claim ownership, which they don't actually have. https://news.ycombinator.com/item?id=8264733
Wow. Thank you. That's a lot of information. I need to re-assess my position, if I have one at all.
I laughed. I like how it took 9 commits.
A high profile bunch of guys who put in a lot of work. Who wrote a language spec and compatibility tests. You're right of course that it's not an official standard and not yet finalized. Gruber has specifically refused to (or allow others to) make an official markdown language spec, so some pretty major users of markdown (like reddit and stackexchange) decided to try and make a standard. I don't really see that as worthy of scorn, even if it's not perfect it's a step in the right direction. It's a fork called standard, which is also quite importantly attempting to actually create a standard.
&gt; it's just a bunch of guys Well, not quite. They're big names. They carry some weight. Jeff Atwood alone makes this whole thing seem much more legit to me. &gt; They did it in private and without any input by John Gruber (its inventor) or the community. That part's true. Oh, so conflicted. We need even more programming celebrities to weigh in on this. I need to know why Richard Stallman probably thinks this is a bad idea.
&gt; Well, not quite. They're big names. Doesn't grand them magical standardization powers though.
A quick glance at [the spec](http://jgm.github.io/stmd/spec.html) says that quirk lives on (see the section titled "simple emphasis"). Sorry.
&gt; A high profile bunch of guys who put in a lot of work. Who wrote a language spec and compatibility tests. And there is nothing wrong with that. However, they did this in private, they didn't tell anyone about it (e.g. the W3 Markdown Community), they didn't involve John Gruber, and yet they claim ownership. I'm all for standardizing Markdown, but this is a terrible way to do it.
Oh but it does. Much as we hate to admit it, there are no "standards police" that run around telling people to stop acting like an authority (unless of course they claimed it was an actual standard, like IEEE or something). All they need is a spec and for enough people to line up behind them.
The point was that this isn't a standard. It might become one at some point. Right now it's only a fork called "Standard" (with a capital 'S').
Goddamnit Crockford!
In a ton of industries (publishing in particular, I believe) things are still done by forwarding word files around in the editing and proofreading stages.
&gt; standards don't necessarily have to come about by democratic process Certainly not. Standardization needs a spec. Where that spec came from isn't relevant. However, when you try to standardize something that already exists in the wild, you really shouldn't be secretive about it. Trying to unify something is very different from inventing something. &gt; Even if it's unofficial Since they effectively claimed ownership, most people won't be able to tell. They will just assume that this is *the* standard of Markdown. (Case in point, this is already happening on Reddit and Twitter.)
The tech that goes into web components is pretty awesome - the big three are custom elements, templates, and the Shadow DOM. I feel like the Shadow DOM is the most difficult to wrap your head around. Polymer, I had a few objections about: * The polyfills are freaking enormous. * The application framework, like Angular, relies on a _lot_ of declarative behaviour, which to me implies that at some point I'm going to end up in a wrestling match with the DSL and I'm probably going to lose. * The application framework does some very weird tricks to stuff the entire dev lifecycle into a web components paradigm, such as representing JSON requests as elements in-page. I feel like custom elements solve a specific set of development problems, and that is not among them.
While Gruber's markdown was a great idea, thanks to the lack of a proper spec you now often have to read the formatting help for every other site to know what flavor of markdown they are using. Markdown was an idea, nothing else. Yes, they should have at least said they were working on it. Yes, *maybe* they could have, partly, opened up to community contributions. Yes, a formal grammar would be really nice and hopefully one will arrive ([Though right now people are not even sure what to define a grammar with\^\^](http://talk.standardmarkdown.com/t/standard-markdown-formal-grammar/46/12)). But Gruber showed no interest in a spec. There was a need for one and now we got one that hopefully becomes the de-facto standard.
&gt; Yeah but [Markdown] doesn't really exist in the wild. I like how you wrote that in Markdown. Markdown parsers do of course exist and people also do write Markdown. &gt;rather than confuse the matter further by introducing democratic process. Being open doesn't necessarily mean that it has to be democratic. They did it in private without telling anyone. Two years of complete silence.
I can confirm that jasmine is also easy to work with.
I read more about this. Apparently the original markdown is actually considered "abandonware" at this point. They sent him multiple emails asking for input and clarification but he actually didn't respond to any of them. After almost 11 months they stopped trying. He's alive though! He's doing stuff on twitter! All he needs to do is issue a simple statement: I'm ending support for Markdown. And then we'd know for sure, and people would stop bugging him. But no, he wants the world to continue believing that he owns the brand, and that it's a finished product, and that all decisions are final. He just refuses to put any more time into maintaining it or helping others. It's very childish. And I hope this effort succeeds and people forget about his crappy perl implementation.
&gt; I like how you wrote that in Markdown. I didn't. You must have a plugin or something that's doing that. I wrote the word "it". &gt; Being open doesn't necessarily mean that it has to be democratic. No but it is making an implicit promise to the public. And it sets up expectations. And it puts pressure on. And most importantly it shifts it from casual email threads between colleagues to press release format. I think for most of the parties involved this was a tiny side-project and not some intensive think-tank operation. And don't even get me started on [how much time they wasted waiting for replies from the original author](http://www.leancrew.com/all-this/2010/10/thoughts-on-markdown/). &gt; They did it in private without telling anyone It sounds like such a conspiracy when you say it like that. "Hey I know, we'll develop a standard! And we won't tell anyone until it's done! Muah hah hah!" I dunno. I figure if they wrote something the seems to represent what most people think Markdown looks like, then that's a damn good start. I don't care if it's in private so long as it captures the spirit of Markdown's original goals. And in what little I've seen of the standard, it looks like that's what they did. &gt; Two years of complete silence Longer if you read the article I linked to above. 
I put it to you sir that the broad concept of Classes and Objects in the context of software development does *not* depend on the behaviour of the system when methods are monkey patched at runtime. In other words, just because something different happens when you change an instance method at runtime compared to other languages, doesn't disqualify ES6 or Javascript's classes from basically being classes. Also, in Java if you were to change an instance method at runtime then you certainly would change the behaviour of that method for all instances because instances don't have methods in Java. Classes are where methods are stored in memory. Instances here are no more or less independent in memory than in JS. 
&gt; I didn't. You must have a plugin or something that's doing that. I wrote the word "it". I replaced your "it" with "Markdown" and marked this editorial change with angular brackets. Your comment was written in Markdown. Just like any other comment on Reddit.
I like Mocha + Chai, it easily extensible and offers much more than Jasmine. Also I would recommend [Test'em](https://github.com/airportyh/testem) to run the tests in multiple environments simultaneously.
Okay, thank you, I've looked at it and it looks like it'll work.
Both are terrible.
Whilst you should know vanilla Javascript, you would be daft to not use a library such as jQuery which gives you a standard API to non-standard behaviour in different browsers on different devices. As time passes, the browsers get better at implementing features the same way but as new features get added there are still some incompatibilities. Why try to figure this out yourself when jQuery does it for you. Keep your shackles. In fact add more shackles (maybe a JS framework with CSS classes to handle responsive layout, or a JS frameworks which implements a declarative way of coding etc.). Maybe start using LESS or SASS and maybe some coffeescript. 
No, you don't have to cut them out. You can just draw a particular area of some picture. Having one picture which contains multiple images is the whole point. Over the net, loading a dozen tiny files is a lot more expensive than loading one larger file. Texture switches also aren't free. However, there is a limit to that. You probably shouldn't go beyond 4096x4096 yet.
oninput validation + auto-correction/filtering has been tried already, and found to be an anti-pattern. You inevitably create situations where the user feels like he's fighting the page, or where you aren't providing feedback. A much better approach is to visually mark a field as valid or invalid, alongside a reason. It's also much easier to implement thoroughly.
Ok, let me give it a shot. Consider Dropbox - it's a backup service on the cloud, which syncs data to your file system. You add something locally it updates on the server; and also syncs across your devices. Now consider another service very similar; except instead of syncing to your local file system, it syncs to your browser localDB. That's MakeDrive. What's the point? The point is it is now available for any browser application to make use of this data; but the data itself belongs to the user, who can choose to sync her local Makedrive DB with a MakeDriver server of her choice (either 3rd party or self-hosted). And then she gets this data across devices. And it's available offline. Of course this assumes that the user has choice, which might take some time to actually happen - but it's this possibility that makes this exciting!
No real figures, just a noticeable performance drop, mainly in IE I see some lag in draws etc. I think this is due to the number of watches. I remember seeing a post on the max number of watches before you see issues I think it was in the area of 500. Due to the nature of my application there could be in the range of 10000 watches. However new features like bind once can help combat this. 
Can you show any examples (from 2010 onward) where memory is an issue, or has any noticeable effect in real world examples when using functions?
The benefits of using functions/closures instead prototypes outweighs the cons for 99% of apps. Only in the most extreme, outlier cases of real world apps will prototypical inheritance show a noticeable difference (in relation to human perception)
And half the battle with a standard is having the platform to tell people to line up behind you at all, which they've already got.
Although the previous one was just a waste of everyone's time.
Except this is the only "standard", no one else has actually come out with one, just random implementations.
Why? He never really had control over it in the first place. Honestly, he's just being a cunt about the whole thing.
&gt; ES6's "class" support is really just syntactic sugar. No, it's not "just" syntactic sugar, because this will actually change some things. Beginners won't have to evaluate dozens of libraries for this, interoperability will be higher, and, most importantly, your tools will understand it, too. It's a very important addition. &gt;Under the covers, it's all still prototypes. Heh. Under the covers, actual classes are being used. V8 uses/creates so-called "hidden classes" for performance reasons. It has been doing that for a few years. http://mrale.ph/blog/2013/08/14/hidden-classes-vs-jsperf.html If you use E6's classes, your code will of course also match the pattern and V8 will create hidden classes for it. But yea, it's of course true that the behavior can be replicated with JavaScript's prototypes. However, an engine is free to do whatever it wants under the hood.
I see that the problem/side-effect of jQuery is that it hides too much of javascript and how to use it correctly. All the quirks are hidden, and as a JS developer you simply must know theese things. Its far too easy to grab jquery and throw somekind of unmaintainable mess together and leave the mess to the next developer. IE is a decent browser nowadays, and if you can skip the older version support, you really may not need jQuery. Finally jQuery is useless in the server environment, so you still haveto learn some vanilla if you plan on doing nodejs dev.
If XKCD got one cent for each karma this link has generated he would be richer than Bill Gates. People even post it when somebody creates a new framework or library and act like it's applicable to those as well, just boggles my mind.
Put a backslash in front of it (\\\_). Or format it as code, for example by putting backticks around it (\`\_\`)
original .jsx format/docs http://www.virtualsecrets.com/adobe-photoshop-jsx-web-server.html
Dammit Isaacs!!!!
Agreed. 
And it's still not as good as RST for formatting documents. This could have been an oppturnity to add tables and other missing basics to MD.
&gt; The JSX syntax is similar to the E4X Specification (ECMA-357). E4X is a deprecated specification with deep reaching semantic meaning. JSX partially overlaps with a tiny subset of the E4X syntax. However, JSX has no relation to the E4X specification. from the article you are commenting on
Docx files are actually zips of XML, so the difference between markdown (which outputs formatted HTML) and docx (which is the formatted view of the underlying XML) isn't so big.
Markdown has simple tables, and I expect now that the big users of markdown are behind one spec we'll see some new things get added as it evolves.
What benefits? (Serious question, you assert the benefits outweigh the cons but so far there's been no discussion of benefits and their value for typical apps.)
[**+Sean McBeth**](https://plus.google.com/100282968888030008096) [_2014-09-04T03:03:30.012Z_](https://plus.google.com/100282968888030008096/posts/3AhpwdtMR34) &gt; &gt;It's late, so the full write-up will have to wait until tomorrow. Mostly, I was just happy to get Node working on my DreamHost VPS. But anywho... &gt; &gt;Here is a small scene, made in Blender, exported via Collada, running via WebGL in the browser thanks to Three.js. &gt; &gt;[http://www.seanmcbeth.com:8080/demo.html](http://www.seanmcbeth.com:8080/demo.html) &gt; &gt;Some bonus features: &gt; &gt;0) If you open a browsing session on your PC as well as your smartphone, you can choose your own secret key and enter it in both browsers, at which point any keyboard, mouse, or gamepad input you use on your PC will be proxied to your smartphone [1]. &gt; &gt;1) You can choose stereo rendering with barrel distortion for use with Google Cardboard, &gt; &gt;2) Or choose red/cyan anaglyph rendering for use with glasses on any type of display, &gt; &gt;3) Or just skip it all and run around the really crappy landscape, viewing it with obsolete 2D display technology. &gt; &gt;Wouldn't have to do the input proxying if the browser vendors would just implement HTML5 Gamepad API for the mobile version of their browsers already. But whatevs. It's also kind very laggy over the internet [2], so please don't complain about it making you sick. I know already. I have a bucket sitting next to my desk. &gt; &gt;However, the basis of this should be perfectly usable to slap together VR demos, served locally over WiFi, that should work well to pitch investors/family members of your burning need to buy an Oculus Rift DK2 or Samsung Gear VR and Galaxy Note 4 to go with it. &gt; &gt;Oh yeah, you'll see a "fork me on Github" tab that will eventually disappear before you can have a chance to click on it. It goes here: [https://github.com/capnmidnight/VR/](https://github.com/capnmidnight/VR/) Like I said, still some splinters on this guy. &gt; &gt;[1] Note that this is extremely hacked together right now and picking a stupid key like "12345" or something equally asinine will have a high likelihood of colliding with someone else who has failed to be thoughtful in their secret key selection process. &gt; &gt;[2] This is straight-up prototype work here, complete with rough edges and pointy corners still in need of filing down. 
~~&lt;u&gt; is deprecated as of HTML 5.~~ ~~So HTML no longer provides a way to underline, but CSS does.~~
That's the genius of it! All that needs to happen for it to become the standard is for enough people to believe it is. And when a bunch of high-profile people make something and call it Standard, it gets people to believe in it. So it will probably work. Was it a dick move to do this without Gruber? While the answer to this is irrelevant to the ultimate question, "is this what everyone is going to be using soon?", I believe it was not. Gruber was doing literally nothing with Markdown except resist attempts to disambiguate or standardize it. 
&gt; All that needs to happen for it to become the standard is for enough people to believe it is. *De facto*, anyhow. An actual standard has to meet some other requirements.
That's like saying that both car and a bicycle are made of metal so they are quite similar. Markdown has very limited feature set compared to docx
That... doesn't solve anything. The point Keith is making is that `_text_` ought to render to `&lt;u&gt;text&lt;/u&gt;` (or `&lt;span style="text-decoration: underline;"&gt;text&lt;span&gt;`, or similar), not that you can't type underscores in Markdown documents without them being interpreted as formatting characters.
&gt; real world makes this a (practically) impossible request. No, I have no real world examples, and truth be told, I wouldn't even know how to give you a memory perf comparison. Here's a speed comparison (this is my first jsperf I've ever written, so forgive me if there are glaring issues): http://jsperf.com/prototype-vs-closure-classes Though I recognize the invalidity of such a test -- who's creating millions of objects at a time? Very few people. If your argument is there wouldn't be any noticeable difference in most real world applications, my answer is you're probably right. I obviously see a huge benefit of having *actually* private variables, and not having to worry about `this`.
Isn't this frowned upon? var name = val , name = val 
Which simple table spec are you talking about? Tables are not a part of core MD. Any implementation of tables for MD are specific to that implemtation and not shared across the spec. Again this is one reason why RST is better.
Jackass, asshole, bully, idiot, fool, tyrant, martinet, ... There are so many opprobrious words to choose from. Let's avoid those that associate female genitalia with ugly behaviour.
Comma first has always bothered me but I can rationally explain why it makes sense. The standard for javascript is spaces over tabs and I've generally seen 2 spaces preferred over 4 spaces. That being said if you notice the comma is indented two spaces with a single space after, much like if this were a single line. Also commas first are supposed to reduce errors involving adding, removing or rearranging the variables order. Regardless I think this syntax is ugly. whats worse are people who put the comma on the same indentation level as `var`
where are your code samples genius? 
Awesome! I love this podcast! I wonder if they'll ever manage to get Crockford on the show.. They've pretty much gotten all the other huge names already 
I'm an hour in and Brendan is giving a most fascinating "inside baseball" account of the history of Javascript and the browser and the political forces that went into shaping it. To think that we almost got stuck with the bloated ES4... **Update** He also covers history up to now, including the 2nd browser war, the ES4 episode with the then Macromedia (now Adobe), the terrible Netscape 6 and the almost accidental origin of the Mozilla browser and later Firefox. Talking about the current state of JS and web a ton of different things have been mentioned: SIMD, Enscripten, macros in JS, JS as a compiler target (langs like Elm), TypeScript and optional typing in JS, WebGL, internet of things, relation to native apps, and more. A great listen. Heaps of stuff in there. The hosts couldn't get a word in. :-) 
"The standard for javascript is spaces over tabs" - citation needed.
This is false. The u tag was deprecated in HTML 4 but un-deprecated in HTML 5: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u
You're right, I got my information wrong. My bad. 
Well, there isn't a standard (many people says spaces, stackoverflow answer says do whatever you want and have VCS apply standards[http://stackoverflow.com/questions/211795/are-there-any-coding-standards-for-javascript], jquery says tabs). However, node.js standard says 2 space indentation which is probably what OP is referring to. http://nodeguide.com/style.html#tabs-vs-spaces
Looks like you're right! I've gotten too used to a table-containing-flavor! Hopefully Standard will add tables to their spec.
Thanks for the explanation makes sense now!
so.... it("some test", function(done) { // async stuff, trigger events, blahblah done(); // Assert that the async events worked }); Like so?
http://i.imgur.com/sP94YXP.jpg
&gt;VIM, Emacs may be extensible (via unknown languages) Unknown? VimL is the [16th most popular language on Github](http://jaxbot.me/articles/github-most-popular-languages), above Haskell, Clojure, Lua, and other popular languages. But Vim can also be extended with Python, Ruby, and Lua, all very popular. Emacs Lisp was the most popular Lisp on Github until it was recently taken over by Clojure. &gt;Atom has a package manager built-in and it is extensible via javascript/coffeescript. What you imagine from a modern text editor. Emacs has a package manager built-in. &gt;You are still un-impressed by this features? Press cmd+shift+p to explore all the editor features, you don’t have to remember all the shortcuts! Cool, good feature, sounds like Emacs' `M-x`.
Considering that in modern JS, especially Node's runtime, trailing commas are supported, it's basically a troll now to use comma-first. Unless you honestly like how it looks, in which case more power to you, but I won't be contributing. Edit: Editing.
So nobody can criticize anything without being good at what they criticize?
Wow, this was incredible. It blows me away how organic the process of language design really is, with tons of breakthroughs, fuck ups and everything in between.
I just think its unfair to put someone down without something to back up your claims.
He doesn't need to backup his claims with his own stuff. They didn't say they were better, they said both were terrible. That is backed up by the content that is criticized. 
Everybody left out one of the important concern, that it produces an immutable. So it is forces you to think in functions not in states.
&gt; I'm curious if anyone else has implemented the Flux architecture in real-world scenarios? Pretty self explanatory really.
This is correct... with the caveat that it is a semantic tag in HTML5, and therefore there is no guarantee that it means "with a line under it," which would be presentation information.
&gt;With that logic then anybody can say "you're shit sucks" Well, yeah. Do I need to be a professional director with several awards under my belt to know that "Battleship" was a bad movie? Do I need to be an English professor to know your grammar is horrible? The answer to both is "no." Anybody can criticize something without being an expert. For them to claim they could do better work than someone they would need some sort of proof. Your logic is deeply flawed and you should reevaluate your view.
Hah, sounds like the [Sufficiently smart compiler](http://c2.com/cgi/wiki?SufficientlySmartCompiler), keep hoping.
Sorry that was lost on me :P http://i.imgur.com/O3rdGbO.jpg
Yes, it is really quite interesting especially in the case of JS because it involves so many big companies with conflicting interests who generally don't like each other very much but still see the need to cooperate to some degree. 
It's _really_ on the nose, but I think the heavy-handed metaphor makes it easier for someone to follow an otherwise complicated and abstract concept. Callbacks have always confused me a little bit, so I found this useful, too.
Anybody can say that. Don't like a movie? It's OK, you don't need to prove you can make a better one.
[The One True Styleguide](http://nodeguide.com/style.html#variable-declarations) says yes.
&gt; If not polymer then what would you suggest? Without the polyfills I'd have to wait until each browser standardizes. Depends what you're trying to achieve - you can just use the polyfills on their own without the application framework. You can also select which polyfills to use, as the dependencies between them are reasonably well-documented.
Thanks. I was the one who down voted myself last night (op), just because I felt like I wasn't adding any new substantial content to the forum. 
What's frustrating is that (coming from lua) this is the first way I thought to do object constructors. But I thought that the idiomatic style advocated by people that were super-experienced with js (notably Crockford) was probably better in some way I wasn't aware of yet, so I learned their way (and all of the silly complications that entails).
It's definitely subjective :) I prefer functional style programming, browserify commonjs modules, lots of mapping and filtering (no forloops, even though i know they're there under the hood), lots of objects with functions that return values, etc. etc. My programming style relies heavily on closures, and I understand how they work. Prototypical inheritance adds an additional layer of complexity, because I must be aware of a different subset of rules and boilerplate that slows down my coding process, and limits my 'mental' potential. So, it's definitely my programming style that determine the benefits. But if after building my app, I noticed performance issues, and I could trace them to not using prototypes, then I would rewrite the codebase as is necessary. In the past, I would focus way too much on performance that didn't have an impact on the end user. 
Just a note for whoever reported this -- it's kind of in a gray area, since it's not actually a meme. I was originally going to remove it, but decided to leave it on account that it's generated some relevant and thoughtful discourse.
We are referring to code samples, not movies that anyone can judge. Anybody can say 'this movie was bad.. i didnt like it', sure thats your opinion. you cant just say 'this is horrible!' referring code without backing it up or being at least constructive. What would be a better option since you're so wise to judge in this fashion? Code isn't opinion, good code is fact. There IS a difference. Agree with me or not. the reddit hivemind has already downvoted my first post.
It wasn't the "reddit hivemind" that caused your comment to be downvoted. It was the rudeness.
I'm not sure, but I could imagine that e.g. stuff like D3 and other types of gfx stuff could become a problem. Look at some of these: [https://github.com/mbostock/d3/wiki/Gallery](https://github.com/mbostock/d3/wiki/Gallery) For most people it simply doesn't matter at all.
Ok, thanks a lot man, that really does help me grasp what's going on here, but it also poses another dilemma, what if I silence the change event? http://fiddle.jshell.net/adowgail/p5y5985k/5/ How would this be tested now? And again, thanks for your example. For many of my tests that I have to refactor, that will work. edit: well, I feel inferior. Looking at the code of Backbone.Events, it appears backbone events are synchronous. The callbacks may not be, but the order of those callbacks are guaranteed. This will simplify my life considerably.
Yeah better steal the project from the author and call it a standard then.
&gt; It's a specification "called standard", but "isn't a standard specification" well that clears it right up
I don't really have an answer but as an Angular dev, I have a couple of questions: 1. How many other people are also working on your code base? I know you feel locked down sometimes but it can be a good thing if several other people suddenly try to start reinventing the wheel all the time. Frameworks are a double-edged sword in this regard, I guess. 2. Ampersand sounds really cool. It sounds like a Node-approach to front-end development? I really love node because they get modules right. Modularity and maintainability is just so much better than frontend js.
&gt; Eh, as a full-time Vim user and developer I still couldn't be bothered to learn VimL well enough that I can write VimL without a reference open. Alright, but that's kind of irrelevant: it doesn't mean VimL is "unknown". &gt;This is a godsend in my opinion, but I do somewhat feel like that support is "tacked on", probably because it was, but at least in my experience Python really doesn't feel at all like a first class citizen. You're right, I agree. They are tacked on and they aren't first class citizens: you still need a little VimL to interface with Vim. But for complicated stuff most people find it much better than doing it all in pure VimL. &gt;Plus pathogen is pretty much a de-facto standard in Vim. True, I almost mentioned Pathogen and Vundle but the author specifically wrote "built-in", so I didn't. &gt;EDIT: I don't know if pathogen's features are comparable to Emacs and Atom's though. They aren't. Pathogen is a "path manager", not a plugin manager (like Vundle or Neobundle). Pathogen suffices for a lot of Vim users I think because Vim itself encourages minimalism, and it doesn't need large packages. Emacs and Atom's are "true" package managers, more like apt/pacman/yum on GNU/Linux than Pathogen. You search for packages using the editor's interface and the editor will download/install/update/remove (i.e., "manage") them for you. All in all, I'm not sure the author of this article has really explored Vim or Emacs. I think he's more concerned with using a "modern" editor with a "modern" (read: hip) language.
Exactly. Good luck getting Atlassian to fix their implementation in JIRA.
I wonder what the modern JavaScript JIT's make of these individual closures. Not only in memory but also in ability to compile to optimised code. Anyway, I'd like to see some numbers on the amount of objects you need to have for this to become noticeable.
&gt; I obviously see a huge benefit of having actually private variables, and not having to worry about this. I enjoy TypeScript a lot for this reason. The `class` syntax and arrow lamda's (like ES6) cover the `this` problem while keeping the benefits of the original constructor+prototype pattern (eg: speed/memory). And the compiler checks `public` and `private` access. Of course in the compiled JS code the private variables are not actually in-accessible (like in Java) but that's not the point: as the access checking is done at compile time and thus catches the bugs (and the syntax also works as documentation).
It took me a while to wrap my head around it, but yes, it's a new ES6 syntax. http://globaldev.co.uk/2013/10/es6-part-3/ The '{method}' part is a destructuring *template*. The values on the right-hand-side that line up with the identifiers within the left-hand-side are values assigned to new scoped variables with the names from the left. A less confusing example: var temp = {foo: 123, bar: 456}; let {foo,bar} = temp; Is equivalent to: var temp = {foo: 123, bar: 456}; var foo = temp.foo; var bar = temp.bar; 
SO BRAVE
The problem there is actually a lack of a module system.
I'm not an expert at Javascript and any help by the Javascript community to make this even simpler and cleaner would be greatly appreciated. 
It might help to understand the underlying patterns, e.g. MVC, MVVM, etc... Really makes the differences between frameworks clearer, and puts things into perspective. [Checkout Yehuda Katz' talk on it](https://www.youtube.com/watch?v=s1dhXamEAKQ)
snake_case Easiest to read. Also, there's evidence, cited all in Joe Celko's SQL Style book - an interesting read.
Pretty cool! I've been looking for an easy scraper for a project I'm working on. 1 coffee /u/changetip
/u/fcambus, mvg210 wants to send you a Bitcoin tip for 1 coffee (3.070 mBTC/$1.50). Follow me to **[collect it](https://www.changetip.com/collect/37934).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
You can't steal something that's [free](http://daringfireball.net/projects/markdown/license). Especially something free that the author has openly abandoned. Gruber has ignored all calls to better define Markdown. Markdown was originally published in 2004. Atwood himself posted an ["open letter" of sorts](http://blog.codinghorror.com/responsible-open-source-code-parenting/) about it in 2009 and Gruber has still left Markdown the way it was when he originally published it 10 years ago. Markdown Standard is, effectively, a fork of Markdown that fully complies with the Markdown license. Gruber was given 10 years to improve or work on the Markdown spec, and he chose not to - which is fine, but that doesn't mean that no one else should be allowed to collaboratively work on a more modern spec.
1. Currently it's only me that's working on the codebase. (Although previously worked on a codebase with 2/3 other developers and didn't feel any easier about it) 2. Yeh, I think that's what I like about it, I'm a big fan of Node (Obviously, if it's the right tool for the job)
 jQuery.props['ill-relevant'] = 'irrelevant';
I understand the patterns mostly (obviously being self taught means I didn't have the luxury of having a source to probe with questions). Good video though.
My own experience with jasmine has been nothing but horrors, especially with how the inherently asynchronous nature of javascript was treated as an afterthought and all the magic globals. Getting that to work in node and the browser is even more of a slog.
Ha! I get you, but classical OOP vs functional style is not even apples to oranges, it's more like apples to orangutans. :-)
Does it scrape dynamic content or would you need to use a headless browser?
I made a sprite sheet tool that supports removing sprites from a texture atlas or sprite sheet. It is web based and completely client side: http://www.leshylabs.com/apps/sstool/ Here is a video with some examples of what it does: http://youtu.be/X67qLM8WcvE If you have a sprite sheet or texture atlas that you would like to remove sprites from you can: 1. Drag and drop the sprite sheet image file on to the page. 2. Load a sprite map. There are a few supported formats that you can drop on the page, including the JSON format from TexturePacker. More details are in the docs. If you don't have a compatible sprite map you can try pressing the "Remap" button to auto-detect sprites. This will work as long as there is some padding between them. If the sprites are arranged in a perfect grid, then you also have the option of the "Grid Remap" button, which will divide the image into a grid of sprites. 3. Once sprites are seen by the program as separate entities, click on a sprite you want to remove, then press the "Delete" button. Repeat this until all sprites you want to remove are gone. 4. In the "Sprite Sheet" section, press the "Save" button to download the new image. 
&gt; The problem with javascript is that everybody seems to want to reinvent hot water. The strength of Javascript is that it doesn't force any particular methodology on the programmer. At the same time, it can cleanly support different methodologies like functional and object oriented programming. &gt; It's called encapsulating behaviors: which is a pillar of object oriented programming. Encapsulation of behavior is very important. Current approaches in OOP for encapsulation fall short. It is one of the reasons why we have hundreds of frameworks with tens of thousands of objects with hundreds of thousands of methods: each method having a unique specialized interface (method signature). What MOP is able to provide is industry wide domain agnostic *standardization* of interface to all encapsulated behavior.
nope. 
so first off, Object.create exists: function msg(behavior, data) { var msg = Object.create(behavior); msg.data = data; return data; }; var newMessage = msg ({val:4}) newMessage.go; // returns 4 newMessage.asNum; // returns 4 newMessage.asStr; // returns "4" second though that is isn't very 'javascripty' I suspect the idea is to try to recreate the way c# doesn't have properties and everything is a method. I wouldn't really want to do this in my code because not only does it hide side effects and the effect would totally break for async code, but also the only way to get the advantages of this (such as being able to dump the code in a key value store) would likely involve lots of stringification and eval (also known as SHIT TO AVOID AT ALL COST). 
That's the number of times it was referenced, not how many upvotes all of those references received in total.
Yeah. :( At least we got "a lisp in C's clothing" instead of Java.
This looks really exiting, can't wait to try it out. I wish there was a walkthrough building a simple app, just showing off all the areas, the documentation is great though. 
AFAIK, tan 90 is like 1/0. It should be either NaN, or undefined in JS. Though when I enter 1/0 in the console, I get Infinity in Firefox, so yeah, it's inconsistent.
If I had to guess, it's because `Math.PI / 2` is a floating point approximation to the mathematical quantity π/2. And the tan of the approximation is just a large number, not Infinity (or `NaN`).
I don't think they are the same in practice. JS will always evaluate 1/0 as `Infinity` because JS implements IEEE 754 arithmetic - it should never be `undefined`
&gt; AFAIK, tan 90 is like 1/0. It should be either NaN, or undefined in JS. &gt; 1/0 Infinity &gt; 1/-0 -Infinity
The spec allows this. Trig functions aren't required to return the same values across implementations. http://www.ecma-international.org/ecma-262/5.1/#sec-15.8.2 &gt;The behaviour of the functions acos, asin, atan, atan2, cos, exp, log, pow, sin, sqrt, and tan is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values, these functions are intended to compute approximations to the results of familiar mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.
&gt; Until other people need to read your "methodology" Structured programming, object-oriented programming and functional programming are all well known and accepted industry standards. I think the fact Javascript is able to cleanly support all of this is a testament to the language itself. There are tradeoffs to creating languages and one of them is how much power you want to give to the programmer. Strongly typed languages like Java try to make it harder for a programmer to hang themselves. Languages like Ruby and C give programmers a lot of flexibility with added risk. Javascript just happens to be a language that has a lot of flexibility. &gt; No current approaches work,it's called writing functions. IT spends tens of billions of dollars every year maintaining bad software frameworks. You see Javascript's flexibility as concerning in that "the problem with javascript is that everybody seems to want to reinvent hot water". We see similar issues with the flexibility of having unlimited functional signatures as a huge drawback to the software industry. Every time we add a new signature to our framework's public interface, we further complicate the communication mechanisms between parts of that framework. To us "the problem with specialized functional signatures is that everybody wants to reinvent inner-process communication." 
He means mathematically I think. 
It's because it's John Gruber and his fanbase are made up of obsessive Apple fans who will jump at any chance to accuse anyone of "stealing" from Apple. This "backlash" has nothing to do with open source, or the open source community. This has everything to do with Gruber's fanbase being butthurt for no good reason.
Lost me at "Javascript is a beautiful language". It's a fun language and I enjoy using it, but I don't think I've ever heard anyone accuse it of being "beautiful".
This is only for the Console demo: https://github.com/asvd/jailed/blob/master/demos/web/console/plugin.js#L20 By default if you create the plugin, it will run in the worker's scope with "full" access to importScripts, manual messaging with the application and so on. The API available to the Worker is designed to be secure, and that is what Jailed is relying on. (The reason why I hid those properties in the demo is in that the Console is some kind of virtual environment for a user to evaluate custom JS on the fly. In this sence, the methods available to the worker are not related to the purpose of that application)
Hey man, I think I understand what you're asking, but you're request is a little over the place. I think this is a great example of going back to the board and deciding what this site needs to do and where/what do you want to improve. If you want to just improve the look and feel, then there is a good chance that you don't need to write a back-end at all (node). That is some basic CSS/JS/HTML that could use improving, and is within reason to accomplish. If you need to rewrite the whole thing, then you're trying to stomach something that is pretty vast given limited experience. It's doable, but you're going to have invest some serious time into doing it. If you go down this road, you need to find what this site needs to do *exactly* and get some clear scope on what you're building. Once you have that then you can proceed with evaluating frameworks/software. This is a great learning experience if you're to go on further with development. If that's not your case, I'd advice on potentially picking a different project as you're going to have to spend some significant time doing this.
Getting started is always the trickiest bit. I'm not sure about mentors -- maybe there is some local web shops you could get into contact with and see if they'd be willing to help? For the client to server thing, you typically use ajax.... your client side uses javascript to reference a url on the server, and the server side responds to those requests with either data or some kind of status.... on the client side you then do something with that data (i.e. show it on the screen in a list) or show some kind of message (record added successfully) In node, I'm not sure what you are using -- but for quick projects I usually whip out express. You can serve a directory as static for the client stuff and set up different routers to handle different requests like serving and modifying data. You need to identify what the web web site needs to do that warrants this -- you'll usually have a database of sorts that keeps all the information and the routes in node are a way for the client-side page to interact and perform CRUD (Create, read, update and delete) operations.... but, if it's all static content without anything dynamic, you really don't need any of that. In most cases, google is your best bet. It's of the utmost importance to read the docs. If they aren't clear, I'll usually google it and see if I can find some usage examples out in the wild -- slowly/surely I'll build myself a working knowledge base of how the darn thing works.
I do want to go further, my goal is freelance web dev, because I want to make web games (see, I will have at least some crossover) but web dev who makes games on the side sounds like way less stress about the actual making of the games. I really don't want to do this project at all, I just want to do something that I want to do anyway before I graduate, and in this case it is make a decent website.
A lot of what you're looking to accomplish with this pattern is better expressed via closures, 1st class functions, and the functional programming style. To recreate your example: function partiallyApply(fn, val1) { return function(val2) { return fn(val1, val2); } } function encloseValue(value) { return function() { return value; } } function formFieldGet(idFn) { return $(idFn()).val(); } function formFieldSet(idFn, valFn) { $(idFn()).val(valFn()); } function add(leftFn, rightFn) { return left()+right(); } var leftValue = encloseValue('#left'); var rightValue = encloseValue('#right'); var resultValue = encloseValue('#result'); var leftGet = partiallyApply(formFieldGet, leftValue); var rightGet = partiallyApply(formFieldGet, rightValue); var adder = partiallyApply(partiallyApply(add, leftGet), rightGet); var setter = partiallyApply(partiallyApply(formFieldSet, resultValue), adder); // At this point, everything is a pure function with no side effects. setter(); I haven't tested this code so there may be a bug in there somewhere.
Ok but in order to use React.addons.TestUtils you must have a DOM. Running tests against the VDOM has some advantages: - simple: it's only javascript, so you don't need a real DOM - node: without a real DOM you can run tests in Node.js without a headless browser - speed: manipulating only js objects and arrays is faster then writing and inspecting the DOM - state control: you can directly inject a state in the component instead of simulating events 
Got the go-ahead to release this little library at work. :)
where would one find a "local web shop"? I live in the middle of nowhere where there isn't much of anything at all. I'm trying to learn socket.io right now (whenever I actually finish my stupid homework and see if I have the energy to do that.) but I have used express a little. I don't even know what ajax even really is. I just have tried to learn nodejs because I know I'm not forced to use a different templating language like it looked like I had to for django, and I know javascript better than python.
There is also renderComponentToString: http://facebook.github.io/react/docs/top-level-api.html#react.rendercomponenttostring Doesn't require a real DOM, designed to be used on the server.
Its missing a lot of features.
Hmm yea I dunno... maybe a local college or something? You can also try your hand at finding someone online to mentor you but your mileage may vary -- I would think such a thing works better in person. I mean I'm helping you now but there's no guarantee I'll be around when you need me. --- Geez man, gotta learn to walk before you can run. Socket allows you to send information back and forth between client and server -- traditionally HTTP traffic is a one-way street. This uses something called websockets -- which basically allows for bi-directional information flow. I don't know too much about it but I think the general use cases are for online games and messaging apps --things where you have multiple clients and need to send out a message to all of them. Think of a messaging app or something you type something in and press 'return' and automagically the same message pops up on a friend's computer. If websockets isn't found on the user agent, sockets will fall back on polling using ajax -- which is basically check this site every xxx milliseconds and if there's a change hurray we have a message. --- here is a stupidly simple ajax example that I haven't even tested : server : var express = require('express') var app = express(); app.use('/', express.static(process.cwd() + '/client/')) app.use('/hello', function(req, res) { return res.json({ 'message': 'hello world!'}); }) client/index.htm : $.getJSON('/hello) .fail(function(err){ console.log('aww snap! %o', err); }) .done(function(data) { console.log('message: %o', data); }) But imagine the '/hello' router connects to a database and instead of just saying 'hello' it collects a bunch of records in an array and sends that over ... and the index.htm instead of just console.logging the results, it iterates over the data and generates HTML &amp; appends it. This is, in a nutshell, ajax.... you can also do more like send a series of fields to the server and there are different "verbs" you can use to flesh out a REST api (http has a series of "verbs" to describe what you're doing... GET/POST are the most common -- there's also PUT, DELETE... and a few others you may not use within a REST context)
nasty thing about motivation, if you fail it becomes harder to succeed, and if you succeed it is still pretty hard to get it easier to succeed.
Who needs motivation when you have perseverance?
I finished the puzzle and nothing happened :(
Not quite; rails-assets just allows you to drop javascript files into your asset pipeline, while a gem that bridges to gulp / browserify allows you to do more complex asset management such as building up an NPM-style dependency tree, building map files, and [more](http://gulpjs.com/plugins/).
Needs a win condition! Also hovering over the happy face makes it appear depressed?
AngularJS can process directives in comments. Maybe you can look at how they did it. I know there's poor support for old IE
There were calls to standardize it for years and Gruber dismissed every single one of them. Pretty sure they expected him to dismiss this one too, and only contacted him as a professional courtesy. Aside from the Markdown name, the project doesn't need Gruber. 
in JS comments? I'd have to research that, never saw that before and I've been using angular here and there. The thing is - I know the theory of how to do it, with something that parses the JS code into a syntax tree, but it's kind of hard and I would like to avoid that. I don't need browser support at all, these will run on the server in node.
Correct me if I'm wrong, but this sounds to me like your thinking goes 1. Programming projects are always an absolute mess and wind up getting too complicated. 2. Too much effort is spent trying to communicate business rules to the developers, when it would be better if the business people could just do that stuff themselves, but they can't code. 3. It would be much better if the developers could focus on building a DSL for the project, then business people could be trained to write things for themselves but they would be stopped from screwing up the project because we wouldn't give them too much power in the DSL. 4. If the DSL was generic enough and had a consistent syntax then we could even make some sort of GUI editor where people could go in an build stuff by wiring together high level abstractions. Then if they needed to they could make their own high level abstractions by composing lower level ones. 5. We could make this DSL work in any language, so the "business logic" that is coded could run on the back end or it could run on the front end in javascript. 6. It would be great if we didn't have to write a parser and an interpreter for this language, so lets try and figure out a way to make it work in the native languages by just having people build an abstract syntax tree with built-in data structures. Does this sound about right? 
Yup! I'm guessing the readme needs a bit of a work to make that more clear. I'll give it a quick edit.
Thanks! I'll try to write up a walkthrough but it really depends on what type of app you want to make.
The first cell I revealed was a mine. That doesn't happen on Microsoft Minesweeper, because it generates the minefield on the first click.
In my opinion it would be a better idea to start learning more traditional web development languages and workflows before you start with more cutting edge technology. The reason is that you then have a greater understanding of how other websites really work instead of a very specialized and context specific knowledge. being able to work with the basics will widen your oppurtunity to find a job and gain professional experience. That being said, it's nowhere near less fun and exciting, because you'll still learn a lot of new things and expand your skills to create the things you want. What I would do is start with a PHP book, then move on to a MySQL book. And finally a Javascript book or two. Another path you could take is to delve into ASP.NET, and then a ASP.NET MVC book, topping it off with some frontend HTML5 books made for some Microsoft certificate. Once you've got a good base, for how to model and use databases, how to interact with the data inside it, and then use that data to create apps, you have a very solid foundation to learn all the new technologies that you want to learn about. Node.js + socket.io is too specialised and will not be a strong foundation. you can not make every project a nodejs + socket.io one because many clients you will work for will be looking for something else. I can't stress enough how important it is for your own personal development to have a strong foundation. And last but not least, if you don't want to or feel you can't read big books, consider that this will be the most valuable skill you will ever learn in life to excel and grow, and be able to follow your ambitions and dreams. Reading books can be learned, and you do it by starting to read. (generic piece of advice) Go out and buy some books, and dont give up until you've learned something from them. It doesn't matter what you learn or how long it took you, ten years down the line it will not matter how you started, but the fact that you did start is all that matters.
It's impossible to win, at least on mobile :(
I've only really looked at Ampersand (not built anything yet) so I can't comment on it too much. I like React too, but only had a short play with it, it's amazingly quick for big datasets (100k+ rows on the page)
What in particular bothers you about it? I wrote this a long while back but I'm always looking to improve. 
You're right! I'll need to go back and add that.
Thanks for noticing. I'll make a note to adjust that.
So what the fuck are you asking for exactly
First hint: you are adding a lot of HTML snippets; it is usually faster to compose the HTML as string first and then put it into the DOM. Also for (i in ...) is a bad idea without hadOwnProperty; since tb_clients seems to be an Array rather than an object, you should go for a normal for (var i=0; i &lt; tb_clients.length; i++) loop. The "Add to Cart" problem can probably be fixed by adding function(evt) { ...; evt.preventDefault(); } to the event handler.
Ugh, that's painful to look at and interact with. Can you at least throw everything together in a jsfiddle to make it easier for people to work with?
here is a plunkr with some small fixes for the problems you mentioned. http://plnkr.co/edit/PyTfGUrDgrGz0PqJz3sw?p=preview The main problems for what you mentioned were (are... but this should get you started) * You are using a submit button on a form with multiple 'operations'... a submit will always 'refresh the page' (unless you specify another target, but that's besides the point here). A submit is a page load. It seems to me this is not your intent. * You saw too many results because you weren't filtering them. You added them all regardless of quantity. I added a check to see if quantity &gt; 0. good luck. 
Upvote for promoting education. Not that you have to go to university or anything but really, sometimes you need to sit down and just read. Alternatively, I can recommend some of the premium sites that you have to pay for. I've used tutsplus extensively and you save endless amounts of time by having dedicated courses that cover everything, instead of looking at random articles around the web. "But that costs money!" Yes, but if you can't find the $15 a month for this, you should go do something else. It's hard to find a hobby that costs less than this and if you plan to work professionally, it's a drop in the bucket. And definitely learn the basics. I don't even think Node should be used to serve HTML. It's much more suited for an API in combination with a SPA, built on Angular, Backbone or something like it. But I'd never know this if it wasn't because of my experience with PHP, .Net etc.
Probably I was not clear. I'd like that React natively exposed the virtual dom of a component so that I can easily unit test my components without messing around with the real dom. Since it is not so, I wrote a function that does it, thinking that it would be useful. 
Clicking on numbers.
[Finally video from presentation is available!](https://www.youtube.com/watch?v=LaxbdIyBkL0)
why not remoteStorage? 
Did you even read my comment? Fuck kid you're dumb as shit and apparently can't read. You're brashness and close mindedness is going to hurt your career. 
Not sure what you imply under "full sandboxing".. The library simplifies the interraction with a worker (or with a subprocess in case of Node.js). But as I explained, the library relies on that a worker is secure by its design. If it will be made insecure in the future, I cannot do anything with that.
If the "Add to Cart" button is your problem, then changing its type from submit to button might fix your problem.
I work for one of the largest and competitive corporations in my country and make quite a bit of cash. I'm sorry but your so fucking brash and closed minded you're just going to stagnate and hold onto your misunderstandings. How do es $.ajax fuck with the DOM at all? I bet you didn't even read my post. I challenge you to quote even just one point I made in my explanation and argue against it cause your response seems like you disregarded my post and just continued on some petty misleaded rant.
I understand your fucking point. All you do us repeat it and plug your ears without refuting mine. At least I have the satisfaction you're probably some struggling dipshit freelancer or overly brash and incapable college student. Good luck kid.
Grow up.
It only has AngularJS and bootstrap.css as dependencies...
Exactly. That's also one factor in me looking to move; It's not exactly easy to swap out certain components that would benefit from React if using Angular since you then need to make Angular aware of anything going on outside of it by using `$scope.$apply()`
[A quick example of varicoloured elements.](http://michaelvandeweerd.com/test.varicolour.html)
[Goddammit](http://imgur.com/YqiRoHg). It was a choice between that one and the 4 below it. No way to know which one had the bomb.
I've got a free course on Udemy that prepares you for game programming in HTML5. https://www.udemy.com/free-prep-for-html5-game-development/#/ The first example is a point-and-click adventure in HTML and CSS (no JavaScript needed.) The free course also provides enough JavaScript to do basic text-based input and output as you'd use in a text adventure, but it does not cover string parsing (the core technology used in text-based adventures.) Still, I think you'll enjoy the course. If you like it, I have a follow-on course that teaches 2D arcade gaming with a free custom game engine. Best to you...
You don't need to comment every single statement. // append the LINK element to the head of the document document.head.appendChild(link); That's counterproductive.
If there's something specific that you're having trouble with you could try asking. 
I'd rather have too much comments than too little.
Where's the changelog :O
Not really anything specific. The author just seems to like to jump to unnecessarily complex examples with higher order functions, and the mathematical functions were completely OTT.
He's still whining. It'll change to something that doesn't use the word Markdown... and will hopefully slowly steamroll Markdown out of existence. Can't believe someone would be such an asshole about such a large effort on an open-sourced project. He's been acting like a petulant child about it all day. 
It leads to clutter and just repeats what the line below it already says in very clear English. :) 
A long time ago, I read on minesweeper.info that the board is actually filled with mines before you click. And then if your first click is on a mine, that mine is secretly moved to the upper-left corner, or the first empty space to the right of that. And here's the article where a guy ran a debugger to prove it: [http://www.techuser.net/mineclick.html](http://www.techuser.net/mineclick.html) 
This is what i want to learn next, a new paradigm in programming not another boring js framework.
But then again, people just come up with stuff like [bindonce](https://github.com/Pasvaz/bindonce) to solve the problem. It works pretty well.
Personally, I try to have just the right amount.
Node is awesome. Dependency management done right. Semver done right. Automation done right with Grunt, Gulp etc. Tons of testing options, even live, automated testing with Grunt. Use it with git and you get the feeling that JS can suddenly be maintained over long periods of time without the slightest hassle. I so hope we will have the same for frontend devs at some point.
As in http://remotestorage.io/ ? Because you don't have to trust some third party provider with your data.
Yes. You don't have to. You can run your own remoteStorage server and every app that uses remoteStorage stores your data on your server. But I agree, the use cases are a little bit different. 
http://mienfield.com
&gt;Actually, the MOP started out with C#. C# has properties (attributes with scope) I think this is a reference to those properties compiling down to SomeProperty_get() and SomeProperty_set(val). 
Hm, I see. You're right about different use cases. Considering we get the benefit of potentially keeping all interaction client side without the need of a specialized server. https://github.com/remotestorage/remotestorage-server/tree/master/lib it's an interesting idea, but I'm not a fan of the fact that you need server side code for what is mostly a client side problem. I won't dismiss it for future use though, I'll have to give the rfcs a read!
Exactly, it's looking for all those functions but if it can't find it, then it defines a fallback and uses that one :)
It's possible to override the default colours in a custom stylesheet using "!important". Even though the class is called "yellow" doesn't necessarily mean that the text colour should also be yellow. I give an example of how to override a colour [here](https://github.com/michaelvandeweerd/varicolour.js#how-to-make-it-work).
I wasn't aware of that, so thank you for pointing that out! I will change that soon.
I think it's personal taste on what it the right amount, but now that you've pointed it out I might revise mine. Thank you for your comments!
Word. What did you do this for? Just fun?
Ya. Computed properties are syntactical sugar. But even SomeProperty_get() and SomeProperty_set(val) syntactical sugar that then compile down to stack pointer offsets and finally what are they then? 0's and 1's with no meanings to us. It is the abstractions we use as programmers that matters as it decides how we as programmers approach solving problems.
This is really helpful. Thank you! I'm going to go over this closely. 
Cool man. I've really been wanting to finally get around to learning github and put some fun stuff on there. Zero time in the day, but once I finish my current freelance job I will probably do what you are doing. 
In other languages, using || and &amp;&amp; yields either true or false. In JavaScript, with its odd concept of truthy and falsy, it doesn't just result in any kind of truthy or false, it results in the truthy or falsy value which was responsible for that result. &gt; 0 || NaN NaN &gt; 0 &amp;&amp; NaN 0 If the first one is falsy, the second value is examined if || was used. If &amp;&amp; was used, the second one doesn't matter either way ("short circuit logic"). Some more examples: &gt; 0 || 5 5 &gt; 2 || 5 2 &gt; 2 &amp;&amp; 3 3 &gt; 2 &amp;&amp; 0 0 So, your rAF example basically means, use the official one... failing that (=it's undefined), use the webkit one... failing that, use the moz one... failing that, use this crappy setTimeout-based polyfill.
Kinda cringeworthy when no one laughs at the pushup guy. Otherwise, helpful presentation, thanks.
1,2,3 - Usage as a DSL for business people is one possibility. People still need to know how to program (critical thinking) but they don't need to code. A majority of coding against frameworks is preparing data required to push into parameterized sub-routines the result of which is used in a parameterized sub-routine. If you design your framework to move the abstractions of inner process communication to the DSL itself, you no longer hard code inner process communication within the language. 4 - is just an emergent aspect. In MOP, we are just hooking up instances of parts (messages/objects/mechanisms/functions/etc.) when we program. We can now come up with a lot of different ways for people to program. We are no longer limited to coding though we can still do that. We can create different visual representations of a program based on the domain expertise of the user. A mathematician could see math symbols, a child maybe something different. 6 is also true. There is no parser, no interpreter and really no "run-time" engine. In fact, even in a strongly typed language like C#, you can build programs, while they are running natively (so no performance loss because the interpreter is not running). You are essentially programming a data structure and, just like a data structure, you can insert and remove elements anywhere during runtime. You can inject behavior anywhere in a program while it is running (add observers).
If you want, you can invoke your final composition in any primitive you like. As a string (asStr), a number (asNum) or whatever. go is just a generic "run it as you see fit". We could just have easily encapsulated the generic go and invoke it with (). I didn't think about that. Thank you. &gt; everything is inheriting from the same prototype? You don't have to inherit from the same prototype as I mentioned. // Using custom Prototyes for FormFieldSet, Add, // FormFieldGet instead of the shared msg Prototype FormFieldSet ({ id: "result", val: Add ({ left: FormFieldGet ({ id:"left" }), right: FormFieldGet ({ id:"right" }), }), })(); // bypassed go based on your suggestion What is important is that you keep the interface of prototypes the same (the benefit). &gt; Are callbacks even possible with this model? Yes. &gt; Does this approach work in a scalable way with single threaded architecture? This is a good point. One of the reasons for the approach is to allow for easy scaling in multi-threaded environments. You copy and invoke the same object in multiple threads and you don't have to worry about synchronization (a majority of the time) or re-entrance. I'm not sure if there is any advantage in a single threaded architecture for execution speed. Thank you very much for your feedback. 
Yes, but most people getting into JavaScript are just trying to get something done (this almost by definition excludes server side work). If your goal is to master JS then, sure, learn how to live without jQuery. If you're just trying to get something done for a small site (vast majority of the use cases here), jQuery will save a lot of time and trouble.
If everyone who is homeless learns JavaScript, then everyone who codes in JavaScript will be homeless.
http://dailyjs.com/2014/09/05/cross-storage/
artscow.com
Well by that logic, "if homeless learn JS, you can't be homeless", you've created a paradox.
You need to check your logic. 
I can't answer your question, sorry. But trying to get the "best stack" for your next app can prevent you from getting a good enough one, and most importantly, getting your app done. They're probably both good enough. Pick one. You can choose criteria like documentation, popularity, or even the fact that you may know XYZ app written using one of these technologies. I've used AngularJS, and from what I hear, the alternative you've mentioned is also good enough. It's probably the case you can throw a coin to decide which one to [initially] use. Later you can try another one, and with time you'll be able to make your own judgement, which is the one that matters most by the way.
React is absolutely perfect for nested components!
And yet another person completely misunderstanding the causes, implications, and solutions for homelessness. It's not as simple as just having a usable skill - most people who are homeless *have* skills. People should really do their homework before trying to start charities to solve social problems with half-baked solutions. Otherwise you're just taking money away that could be better used on *working* solutions. Not-invented-here syndrome is even more of a problem in the nonprofit-charity world than it is in programming.
While this seems cooler than the blink tag, it's in the same category.
I did, but got 'Can't read property logic of Undefined' o.O
I tend to agree. Delayed or animated text in reality doesn't really ever help readability... It's detrimental to it. I could see it used in cinematic-like cases, however, where it's part of a very specific and stylized presentation, but not for 98% of the web use cases out there.
Have you ever read his blog? This is par for the course for Gruber.
Heh. 'Fuzzy programming'. Considering your information and the names of the functions, I would guess that this example is used for browser compatibility. The first function returns valid in IE, the second for Chrome or other browsers using Webkit, and the third for Mozilla.
I used to play minesweeper by clicking on all the non mines and it would automatically flag everything else when there were only however many unclicked cells left (depends on difficulty). I don't think yours has that feature.
The minesweeper.js file seems to have a lot of jquery that creates elements and sets the style. That can be moved into your css file. When you create the element, set the class to something and reuse the class instead of setting style on a element by element basis.
This video :(
OMG, had a table that could grow to 200 rows and when it got that big, completely locked the browser 4-5 seconds at a time. No easy fix either. Fuckin angular
Moslty-unrelated question: what's the point of the (function(){ return ____ })() in this code? I know what it does in general (prevents polluting the global scope) but that doesn't seem relevant here. Is it doing anything?
What if every website started playing background music and had animated sing-a-longs on the bottom of the page?
It's encapsulating it within an anonymous function and the last () means it will be executed and assigned to "window.requestAnimFrame", otherwise instead of a value, that variable would hold a function and you would need to call it like so window.requestAnimFrame()
Congrats :)
You should look into [ndarray](https://www.npmjs.org/package/ndarray). It has a really [huge ecosystem](https://github.com/mikolalysenko/ndarray/wiki/ndarray-module-list#core-module) and is great for 2D structures. 
I guess that would depend on what kind of message or capabilities the website was trying to portray. That scenario certainly wouldn't fit the majority of use-cases that website owners subscribe to.
What a weird little post. Well shit, I'll try. Look into a technology called `Browserify` for modularizing your code. Look into Bower. *Definitely learn Git and GitHub.* Make sure to full understand `prototypal inheritance` such that you can effectively optimize your code. Look into other JavaScript libraries and how they're made.
Take a look here: https://docs.angularjs.org/guide/animations Angular's got a lot of services built in for animations, but they may not be what you want. There may be some 3rd party options for backbone / React, but I'm not sure what they would be. React and Angular both handle nested views pretty well; Backbone is actually a pretty poor choice for nested views by itself, though React will be taking over for most of that anyway if you combine the two. 
Works for me in Chrome! var origPD = jQuery.Event.prototype.preventDefault jQuery.Event.prototype.preventDefault = function() {alert('hey'); origPD.bind(this)([].slice.call(arguments)); } jQuery.Event.prototype.preventDefault() //alerts 'hey' (Gotta make sure to bind the real preventDefault to the event object and pass along the arguments ) Actually this isn't quite right because the arguments will be passed as an array to the real preventDefault. So there should be an apply in there somewhere. But you get the idea.
Are you calling me weird? Just kidding, but seriously thanks for your help and I will definitely look into these things. 
From [Paul Irish's blog](http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/#comment-1042803366), where he replied to someone wondering why he didn't just ditch the IIFE: &gt; When rAF debuted this lead to an illegal invocation. Not sure about now.
Start with a self invoking function: var my_library = (function(){ var private_variable; function private_method(){}; var library = {}; library.public_property; library.public_method = function(){ var temp_variable = private_variable; private_method(); } return library; })(); Now `my_library` will be an object that will have the method `public_method()` which can optionally invoke any private variables or methods that you referenced. You can imagine you might have an `initialize(height, width, div)` function which takes a height, width and some div, creates a canvas in that div and returns its context. Maybe it has a function which takes an object with certain properties and uses those properties to decide how to draw it on the canvas a few times a second, perhaps using a private `draw(object)` method.
Check out the following article: http://checkman.io/blog/creating-a-javascript-library/ It's very handy. The author of the article recently made the library [PleaseJS](http://www.checkman.io/please/).
Meh, It is kinda normal to not laugh at Paul Lewis's jokes.
I LOVE HIS JOKES
Will do. Thanks for the reply!
That's up to you. Most 'modules' or 'libraries' package everything into one object.
The 2 "Other" tests are IE 11. I don't know why jsperf won't recognize it, it was getting the default IE11 UA string.
This *really* does not need an alert every time I lose. I know I lost, I don't need to dismiss an alert window every time.
Try knockout for a day.
Removed. I was working on the win/lose conditions since I hadn't really defined those very well.
If you're interested in seeing what a moderately complex React application looks like, you can look at the code of what I've been building for the last 3 weeks: https://github.com/onefinestay/django-mediacat It's essentially a media library for use with Django projects, that lets you create and manage crops, all the usual stuff. It's not complete yet, so there's no demo to speak of, but I could put together a video of it in action when I'm back at work on Monday. Key things you might be interested in: - Front-end is 100% React components - UI state is handled using Fluxxor (an implementation of Flux) and Immutable-JS - AJAX is handled using superagent. - No jQuery, or Backbone. I'm anticipating being able to remove underscore as well. - JavaScript payload is built using webpack - We're using the harmony option of the jsx compiler to allow us to use a few ES6 features. - CSS is written using Sass and Autoprefixer. Needs a lot of cleanup, so I wouldn't use it for reference. - Icon font is built using a gulp command that extracts artboards from a sketch document. - There's a cropper component that I'm using instead of jCrop (a jQuery plugin), which is implemented using some simple matrix transforms, which was very interesting to work on. - There's an (in progress) Scrollpane component, because I wasn't happy with the usability of native OSX scrollbars (the auto-hiding kind) for horizontal scrolling of the thumbnail list. If there's anything doesn't make sense, it's possible that it's one of the many things I haven't got around to completing, or it might be something I've overlooked entirely. We're using React very heavily at onefinestay, so if you have any general questions, let me know.
I would suggest encapsulating it completely and safely taking the global variable (function () { var root = this; // "window" or "global" or whatever the RTE defines var prevGlobal = root.myLib; var myLib = {}; myLib = {}; myLib.noConflict = function () { root.myLib = prevGlobal; return this; }; root.myLib = myLib; }.call(this)); This way if your library namespace conflicts with another lib (or another version of your lib) the developer is using they can de-reference your library from the namespace and it restores the other lib and assign it to another namespace. e.g., var myLib2 = myLib.noConflict(); This is how jQuery, underscore and Backbone (among others) operate.
None, use Baconjs and Funtional Programming.
/u/ChaseMoskal knows what he's talking about. Get into node.js, and see how webpack or browserify can take your node packages into the browser, along with any other node library. Bower is good for things that are strictly "browser only libraries", but node.js is the ecosystem for cross-platform javascript libs, which is why it's immensely popular.
What do you think of node.js + webpack or browserify? Why create a generic library, instead of plugging it into an established ecosystem?
Alternatively, if encapsulation doesn't matter to you, a simple singleton object is... err... simple: var MyLibrary = { someVar : 42, getMeaningOfLife : function () { return MyLibrary.someVar; } } ; Naturally, it'd be a bit silly to write a getter method for something you can access externally anyway, but you get the point. Like I said, you have to understand the ramifications of this in terms of external code messing with things in your library it shouldn't... but a lot of the time it just doesn't really matter, you really just need the namespace to hold all your stuff. Also note that when doing this it's a common convention to name any property or method that isn't intended to be accessed from external code starting with an underscore. Doesn't stop anyone from touching it, but at least now they know the library author isn't responsible for anything you screw up. 
You're probably better off keeping a separation between server and client templates. Put your client templates in separate files (ie. not in the markup that Express serves), and load them from the client.
No
+1 for browserify. Easy as shit to understand, and uses an established (node) convention to boot. Everybody should be doing this.
Since OP is still learning, let's follow the conventions of the language: `camelCase` for instances and `CamelCase` for constructors. `snake_case` is awesome in Python, but doesn't fit in with JavaScript.
Caching length in any case is fine, but this advice didn't originally stem from any of the cases represented in this microbenchmark. Caching length in Javascript became important and is still important, for html collections. These may have changed since the last iteration of the loop so the browser must re lookup the elements in the collection every time you access the length property (I.e every single iteration of the loop if the loop statement directly accesses length). 
I feel it's a bit disingenuous to describe these missing features as bad parts. The lack of unions and higher-kinded types makes purely functional programming difficult, but most JS is written in an OO style with functional bits. Most developers won't run into the limits of the type system in this way (especially the enterprise C#/Java developers that TS is largely aimed at). That's not to say it wouldn't be great to have a more advanced type system, but I don't begrudge the TS developers for not providing one - I suspect the effort to build it is high compared to the number of people that would make good use of it.
/r/Meteor 
As a JS game designer, I will definitely check this out! 2D arrays are the very base for tile-based game designs. 
Does the case really matter, or is it just for looks?
One more question. Is there any specific reason that people use parenthesis to encapsulate the main function, or is it just common practice?
As with a lot of microbenchmarks, this is fairly useless and the differences will be negligible in almost all of your application code. In 99% of cases a `forEach` or any type of loop would be fine. (The only real exception might be DOM access.) Even the slowest devices are performing tens of thousands of operations per second. If you need to iterate over hundreds of thousands of arguments every second I am seriously going to question the design of your API. 
Please don't attach more junk to the global object. jQuery's `noConflict` approach is a horrible hack that should never be recommended to new library developers. Just use a module system (ES6/CommonJS) and you don't need to worry about global scope and collisions.
Yup, agreed. If you are serious about making JS libraries, you should aim to understand a few core concepts: - publishing to npm so that others can install your library as a dependency - modular CommonJS code that users bundle with browserify/webpack/etc - node compatibility (where possible) and unit testing
In javascript, you can *attempt* to invoke any expression as a function by adding `()` to the end of it. So if you have `var foo = function(){};` you can `foo();` later to invoke it. Well you can also `(foo)();` which works the same as `(function(){})();` *The parentheses are there to make it clear to both the reader and the javascript parser that what is inside the parentheses can be boiled down to a single expression.
Ultimately case means jack. you could have a variable like: `Fo0BaR` or `FOObar`, but languages tend to have accepted style guides/practices. As /u/theillustratedlife pointed out, JavaScript uses `camelCase` for instances and `CamelCase` for constructors ("classes"), and I find a lot of `lowercasenames` for variables. Python uses `CamelCase` for classes, and `snake_case` for variables (and methods?). JavaScript also formats functions as: function blah() { return this; } JavaScript constructor(class): var Class = function() { return this; } Method (prototype fun!): Class.prototype.method = function(){ return this; } And usage: var class = new Class() class.method();
Thank you for the clarification 
 var simplicity = (function() { var library = {}; . . . return library; })(); //&lt;--------- You forgot your parentheses ();
*internal facepalm* EDIT: Just tried it and it works now. Thank you for all of your help! 
Love me some of those browserify. I've started using commonjs module for everything now. 
I have switched to webpack in order to take advantage of dynamic requires, which the browserify author has said will never be supported. Ultimately, like you said, it's all about commonjs.
Remember that the Javascript constructor(class) that you mentioned above won't be hoisted, so it may be best to use the old fashioned approach: function Class() {} var myClass = new Class();
How is it a horrible hack? I think it's a great compromise between ease of use and respecting the devs environment without adding a bunch of overhead, especially for mainstream support.
I mean that you can use variables in your require statement: require('module_' + moduleNumber);
Note: This is a terrible "shim" because it doesn't do *any* of the most important parts of the actual rAF spec. A while back I spent a few hours reading the spec and made a shim that actually conforms 100% to the spec. It is a little surprising how much is actually going on behind the scenes in rAF (and it's sibling, `cancelAnimationFrame`) compared to just `setTimeout(callback, 1000/60)`! Check out my shim here: http://jsfiddle.net/ImBcmDth/LemmLuba/
Not sure why you need dynamic requires, but have you seen [bulkify](https://github.com/substack/bulkify)?
Thanks. I'll start digging into this! I pulled this shim from an angular plugin that is about 7 days old. Needless to say it's not a robust as one would want so I'm using it as a baseline and building in a lot of improvements. This shim will definitely help. Any thing I should know about it? Does it cover older IE?
Another option for Rails + Browserify: [browserify-rails gem](https://rubygems.org/gems/browserify-rails)
I may be using them incorrectly, but I am using dynamic requires to load all controllers from a directory, without having to add a new line to the top of the loader each time a new controller is made. I've not seen bulkify! Thanks for sharing that.
&gt; Any thing I should know about it? It has almost no testing but it works! :) The most interesting aspect of http://www.w3.org/TR/animation-timing/ is that rAF can be called multiple times in *one frame* and all those callbacks will be executed *in order* the next frame. To this end, each time my shim is called it'll put the callback into a list and it will only start a single timer for the entire list. The "simple" shim that most people use won't do that! &gt; Does it cover older IE? Yes, that is a large part of the reason for the shim existing in the first place. For example, at the very top I shim `Date.now` for IEs &lt; 9 (or maybe &lt; 8 can't remember.) Other than that, I avoid using anything *too new.* EDIT: While writing the above, I realized I didn't have one silly little corner-case covered - canceling a callback from the *last frame* while executing the callbacks in *current frame.* Running: var logit = console.log.bind(console, "called on"); var cancelit = function() { cancelAnimationFrame(c); } var a = requestAnimationFrame(logit); var b = requestAnimationFrame(cancelit); var c = requestAnimationFrame(logit); Should only produce a single `console.log` from `a` since `c` will be canceled in `b.` I fixed my shim: http://jsfiddle.net/ImBcmDth/LemmLuba/2/
oh
While i'd agree about enforced structure -&gt; ember, I don't think ember has good (any?) animation support. http://ef4.github.io/liquid-fire/ is probably the most promising stuff i've seen recently. I don't know about React/Angular. And Backbone... well you can pretty much do whatever the hell you want in backbone
This is a post from 18 days ago. Look around here a bit about my 'just learning Javascript'! Rofl. and also just learning arithmetic maybe you were saying? Not even sure I understood most of this so maybe I'm just learning the English language too ;) 
Ehh I always dislike comments like this. Theres always a that learning experience by making one yourself thar you just dont get by just using one. It may not ever develop into to an enterprise level solution but even at the basic level its valuable if not atleast for the knowledge gained. I mean there are other solutions, top of my head, easel and maybe kineticjs but not many atleast that I know of.
I cringe when people insist on using React with backbone. React is a view layer that works best with an immutable data layer; Backbone models are the opposite of that due to unchecked mutability being the main way to transition application state. TLDR: Using React with Backbone is like getting a blowjob with a condom on
Yeah... You can pretty much throw out most of Backbone with React since you only need the data and a listener for when the data changes. React would work well with a socket.io backer or something like a simple observable/push layer to update the react component when data changes from a service. When working in React, my model is the data coming from the server.
I think /u/mattdesl is referring to published libraries. Of course we all re-invent the wheel in our own time, but what we publish to others should consider the ecosystem we are publishing to.
Ember is built on jQuery, so you can add animations pretty easily.
True constant with javascript (ecma5) !:) (function() { var localByaka; Object.defineProperty(window, 'Byaka', { get: function() { return localByaka; }, set: function(val) { localByaka = window.Byaka || val; } }); }()); window.Byaka = 123; //set constant window.Byaka = 2012; // try resetting it for shits and giggles window.Byaka; // will allways return 123! If you do this as above, in golbal scope this will be a true constant, becouse you can not overwrite window object. He-he!
I reimplemented the blink tag in a project I'm on now. It's close to done but I kept having a hard time cornering the client to get him to send me some docs he wanted to be downloadable. Make all the download links &lt;blink&gt; baby! Got the docs the next day. Highly useful element.
Angular is smaller than Ember and doesn't require Handlebars. Serving Angular templates in Jade should be fine. Or am I missing something here?
If you want to get deeper into design patterns, I strongly recommend this book. http://addyosmani.com/resources/essentialjsdesignpatterns/book/ It contains everything you need to know about design patterns in Javascript. Have fun coding! :)
Global scope leaks are a non-issue if you "use strict". Declaring a var in a loop definition is ugly and should be a syntax error, just like doing if (var a = 1) ... - so just don't do it. I am not against let but neither a big fan of it. Javascript is awesome without people from other languages forcing their shit on us. Making a language idiot proof means making it less expressive.
What would you recommend?
You aren't returning anything from `canGo()`. The line `return response.go` returns from the callback, not from `canGo()`. You can't really return anything from `canGo()` because that would require `sendMessage` to be synchronous, which it's not — `canGo()` returns immediately, it doesn't wait for the response. You need to do whatever you were going to do in the callback handler. Or you could return a promise which becomes fulfilled by the handler, I suppose. But then you'd have to `then` the promise, you wouldn't be able to write things like `console.log(canGo())`. That's just not how asynchronous code works. 
Bindonce really should be standard Angular functionality...
A polyfill is a tool that is loaded after using feature detection if that feature is missing. Polymer is a polyfill for web components. So if the browser doesn't support web components, you would load polymer. You are correct about react as far as I know.
Nice stack. You could probably remove gulp from it as well by using custom webpack loaders to require() and transform resources like fonts. See this video by React's Pete Hunt: https://www.youtube.com/watch?v=VkTCL6Nqm6Y&amp;index=3&amp;list=PLb0IAmt7-GS1hdDcokpVp1MBk-IaeaSgP
That's true, but with sketch files you have to be a bit more careful because of the way OSX's autosave has a tendency to mess up file watching.
I had no clue that's how it was supposed to be used. I simply thought it it divided your code into easily extractable models. That is very neat, will use it in my next project for sure! 
I recently read a good article that went over this topic. http://www.funnyant.com/reactjs-what-is-it/ In short, react is virtual and polymer is native to the browser since it is an implementation of web components. React uses javascript to create elements and polymer is utilizing native browser features. They are sort of doing the same thing in different ways. 
why does this library capture the spirit of angular.js? 
It was an honest question, because I see a lot of programmers gung-ho about functional programming, but my experience with it is a little different. The only time I *had to* do it was in university, in 2nd or 3rd year. It was very interesting, educational and satisfying, but I will never forget how frustrating it was to most of us. Because we had to labour for hours over something that would have taken us minutes in an iterative language, even if it would end up being 10 times more lines of code. Now sure, you can say, these are just college kids, but it was a real big-league computer science program. All of these guys came out of school a year later to make $50k+, and they're all at six figures now. So this is quality programmers, and they were all stymied by Scheme. I'm curious about how it works in an industrial setting. Is it efficient? Anyway, I think scheme in the browser is a whole different beast. While most of us here would probably enjoy writing functional in the browser, it could have never taken off as well as iterative did. A couple of years ago, when a friend of mine who works as a (non-software) recruiter asked me what I do, and I told her "JavaScript", she said "Oh, me too!" She's a soccer mom who probably wrote an alert box once. No way would she think that she can program in the browser if JavaScript was functional.
Tl;dr - the author thinks angular offers flexibility you shouldn't use, and prefers that angular not offer it, over having your team define it's own conventions.
There's already a framework that's like Ember. It's called Ember. 
I've been using cloud9 (c9.io) for my JS development lately and am really liking it.
The CodeMirror plugin mentioned in this video also exists as a ckeditor plugin. It's a really powerful combo that I've been happy with in my own CMS. http://ckeditor.com/addon/codemirror
`Object.getOwnPropertyDescriptor({'undefined': 'oh hai'})`
last question of javascript beginner test is wrong. isNan is undefined. isNaN is the right answer.
[Flux](https://github.com/facebook/flux) with one of its many implementations or home-rolled with Facebook's dispatcher. https://github.com/BinaryMuse/fluxxor https://github.com/spoike/refluxjs https://github.com/jmreidy/fluxy https://github.com/AlexGalays/fluxx or if you're geting fancy: https://github.com/Tvaroh/moreartyjs https://github.com/swannodette/om
Awesome podcast full of juicy and enlightening stuff. This is a repost from 2 days ago though - http://www.reddit.com/r/javascript/comments/2ffvx6/124_jsj_the_origin_of_javascript_with_brendan_eich/
I have heard of it. It looks very feature rich. That kobra.io thing that I showed actually uses ACE editor http://ace.c9.io/#nav=about which was made by c9 . 
Didn't know about that. I am definitely going to use that in the future. 
The point of this blog series wasn't to say Ember is better, the OP just posted THAT part of the article. The point is both offer good and bad which probably would have been a hell of a lot more useful for them to post.
Some things are worth reposting. ;)
:)
LOL js: }());
Javascript was originally going to be Scheme!: "Come and do Scheme in the browser" "And we can’t really let you do Scheme in the browser now." “Oh sorry. We didn’t really mean Scheme in the browser. We’re doing something with Java.” [Scheme online repl](http://repl.it/languages/Scheme) (+ 2 "2") Error: +: number required, but got "2 (= 2 "2") Error: =: number required, but got "1" (eq? "2" "2") =&gt; #t (eq? 2 2) =&gt; #t (eq? 2 "2") =&gt; #f (set! x 2) Error: global variable 'x' is not defined
[**@joewalnes**](https://twitter.com/joewalnes): &gt;[2014-08-29 14:45:37 UTC](https://twitter.com/joewalnes/status/505365660126310400) &gt;console.table\(\). &gt; &gt;One of those handy little things you can use in the browser developer tools console. [*pic.twitter.com*](http://pbs.twimg.com/media/BwNrY-ACUAApcN2.jpg) [^[Imgur]](http://i.imgur.com/N47vDLo.jpg) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2fnpfj%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
This may not be the purpose, it's just one problem that the extension function he uses solves, but if you have an object you can't declare properties on nested objects that don't exist. For example. var obj = {}; obj.one.two = 5; //Errors because obj.one is not an object. The function provided breaks down a string "obj.one.two", and forces the nesting of the two property within the one property that doesn't exist yet, which prevents this error.
- "useless" - "negligible" - "the only real exception" These are all things that may apply to your code, but not mine, and not everybody's. Stating them as universally true is simply self-centered. The problem that prompted me to test this was optimizing a fairly intensive mathematical function that needs to run dozens of times per frame, in addition to the other application logic, paint, etc. I reviewed 5 different libraries and none of them could do it fast enough to make 60fps, so I've been optimizing the fastest of them. I've brought it from 1,200 ops/sec to 2,500 in Chrome and 6,000 in Firefox, which is not quite there but it's much closer to acceptable, and a solid 10% of that improvement was loop optimization. So please, if you don't know the application of a post, don't fill in the gap by assuming it's utterly rudimentary, then tell me it's overkill for something so rudimentary, then go on to suggest that the reason I'm even testing this is that I can't write an API. You're throwing all that shit at me and all I did was show you a benchmark.
A good point. I was only trying to test browser optimizations on native data structures, but yes, DOM-land has its own host of problems/questions.
Please use [JSFiddle](http://jsfiddle.net/) for your example - Tool for prototyping, playing around with JS/HTML/CSS
This should work: function canGo(callback) { chrome.runtime.sendMessage({ message: 'go' }, function(response) { if (callback) callback(response.go) }); } canGo(function(response) { console.log(response) })
&gt; Its all about generating stimulating conversation about the pros and cons of the leading frameworks Then why not post the entire blog post so it does compare frameworks pros and cons rather than the pros of one and cons of another?
This whole "look, I'm such an asshole" bravado fits you surprisingly well. Please continue, you may well be able to make a living as a stand-up comedian or something. In which case your ignorance of basic JavaScript features like ASI will be mostly insignificant.
&gt; What was the problem you had to solve? Unfortunately I cannot recall, and I doubt I would even be able to find class notes from 15 years ago. &gt; I guess you were just way more experienced with an imperative programming language and the functional concepts were still new. You may be right about that, now that I think about it. I distinctly remember how we had similar trouble in high school when forced to write a complex algorithm in Pascal instead of Basic. Maybe back then the structural concepts were just as new as the functional were in university.
Use CSS class (not ID like now) for event binding. And then decide based on class/id which input update. Update only when current input value !== computed value (to not trigger "observe").
16 ms a frame to get 60fps...complex mathematical function that needs to run dozens of times per frame....ouch.
Maybe re read the original ( now 19 day old post your still replying to...) and this time imagine it being said with sarcasm. In the meantime I'll continue making my extremely comfortable living writing basically __nothing but javascript__ as I have for the last 5 years or so, stand up comedy does sound fun though!
Consider the first code section. If you don't use a pattern like this each of those nested objects may or may not exist so you'd end up doing something like application.utilities = application.utilities || {} all the way down the chain just to set a single property. With this method ou can just state the path in the namespace and it will construct the chain as needed. This is one area where a recursive solution may have helped out a lot with comprehensibility (and presumably ones namespace would never be so deeply nested as for this to be a major performance issue....but I guess you never know)
This is a common problem that isn't limited to just Javascript. Basically all [floating point](http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems) numbers are going to have this problem unless a different way of representing them is used. Generally speaking, unless you have some specific requirements for accuracy it's best to just leave the numbers as they are and use a library like [Numeral](http://numeraljs.com/) for displaying the numbers to the user.
If you want help you should really post what you have tried so far. For example what does your Gruntfile look like? Do you use a browser extension or something else? In general, grunt-contrib-watch will only trigger a live reload for a file that it is actually watching. If you don't have any other tasks to do when a PHP file is changed you can leave the tasks array empty.
Use [.toFixed()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) when displaying it.
 (function() { alert(‘foo bar ‘); }()); It's not a closure, its an [IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) (named by Ben Alman). It **IS** a closure: function who(name) { return function(message) { return name + message; } } console.log(who('you')(' should check this')); Also, with an iffy: var who = (function(name) { return function(message) { return name + message; } }('you')); console.log(who(' should check this'));
Yeah I needed the precision. I just ended up using big.js... Works fine here.
This was a fun little project. Maybe it will get bigger, I don't know. First time writing a CommonJs module for node, so any feedback is greatly appreciated. A browserify build should be available soon as well. In the future, I hope to have a test suite for performance comparisons.
Downvotes for being civil?
It's much more than that. It provides a reactive templating language which has nothing to do with the Web Component standard.
It hurts my feelings when people say that about LISPs. They make a lot of since if you think about every pair of () as a stack
You mean why not "comparing angular vs ember" over "what angular can learn from ember"? both are interesting topics, one is more general, the other more specific. If you want to post the former, please go ahead, but stop trying to police what people can or cant discuss here.
Hmm?
It is the most effective way to make certain text annoy the shit out of the visitor. So any time that is your use case the blink tag is your go to man. Use your powers for evil sometimes, it's fun.
I'm not sure you quite understand how livereload works. it sets up a mini "server" on a port, default :35729, and then the livereload js script in your page more or less reacts to that server. Grunt-watch looks at any type of file, php, html, css, js, anything and with the livereload option, sets up that server and notifies it of any changes. As long as your pages have the livereload js script, they will reload the CSS or reload the page automatically. The livereload chrome extension simply adds &lt;script src="http://127.0.0.1:35729/livereload.js?ext=Chrome&amp;amp;extver=2.0.9"&gt;&lt;/script&gt; to your page, and the express server livereload feature does the same. So in short—Yes it works. You just need grunt watching your php files with the livereload option, and the livereload js script on your page through the extension or manually placing it. I do it for all my wordpress sites through MAMP just like you.
I love that its 2014 and computers still can't do simple math.
For more advanced object and array manipulation, lodash can really help: http://lodash.com/ Highly recommend taking a look. But in vanilla JS, you could do: var people = [ {"name": "Dave" , "owns":["House", "Car", "Boat"]}, {"name": "Mike" , "owns":["Dog", "House", "TV"]}, {"name": "Fred" , "owns":["Sofa", "Elephant", "Space Station"]}, {"name": "Larry" , "owns":["Land", "Coins", "Iron Lung"]} ]; function updateOwnership(name, objects) { for (var i = 0; i &lt; people.length; i++) { if (people[i].name === name) { people[i].owns = objects; break; } } } updateOwnership('Fred', ["Guitar", "Flowers", "Socks"]); console.log(people); 
Honestly? I'd learn Clojure. It can compile to Javascript or the JVM if you want it to, is compatible with all Java classes and libraries, and honestly is one of the best designed languages out there. It's a beautiful, expressive language littered with parens all over the place. Don't let the fact that it's in no way a C-family language throw you off. [This looks like a pretty good overview of it](http://adambard.com/blog/clojure-in-15-minutes/)
Seriously, look into Clojure. It's my personal favorite lisp and super modern. I talk about it more in [this comment](http://www.reddit.com/r/javascript/comments/2fn6gp/the_origin_of_javascript_podcast_w_brendan_eich/ckba8ul).
Don't put your opinion in the title.
Absolutely! When you think of everything as a stack it gets a lot easier to understand any LISP. Haskell is a lot of fun too if you end up liking the functional aspect of things. Feel free to message me if you get stuck on the whole Monad/Applicative/Functor/Arrow thing that gets... A bit crazy.
I have done the changes, Answer option changed to isNaN. Thanks for your feedback.
hah :) I have a use case where I am pulling regularly updated CSV from two, three or four different sources that share a common key. The parsing is accomplished using d3.csv, join the data, and then render into multiple charts. Originally all of this was browser only. But, yeah a lot of it was just for kicks :) I didn't need the three different implementations, nor did I need all those join types. LoDash was used to keep it somewhat simple. Creating a second library for full blown relational algebra had crossed my mind though...
in this case you wouldnt need to include a whole library just to have a couple of functions done. done using plain native javascript.
Hm.. maybe just initial look then :) 
Thanks I will have a look at it. 
And with lodash you could do: var fred = _.find(people, { 'name': "Fred" }); fred.owns = [...];
Assuming name is a unique id you can simply do people.filter(function(person) { return person.name === 'Fred' })[0].owns = newOwns; If you wanted to update everyone with the name Fred you could instead use map and test name in the callback and set the owns property if you have a match. Apologies in advance for any typos, I am on mobile. Id mention that if you have to use vanilla js and need to work with this sort of data often you should just create a method similar to the above so you can just do something like var fred = find(people, 'name', 'Fred'); fred.owns = newOwns; 
Because Clojure doesn't have operators, only functions, and all of these little stacklets (as I will refer to them) as are in the form (func arg arg arg...). It is equivalent to a call such as sum(1,1) in JavaScript. Clojure also **discourages use of a state**, as do many functional languages (pure functional languages like Haskell basically forbid it). Your entire program is less of a list of instructions, and more a single function that has functions nested in functions that build instructions up and out. Honestly, I think this is a much better paradigm than OOP. I find it easier to reuse code and easier to reason about what parts of a program do, when implemented correctly.
Thanks for the explanation. I still have to wrap my head around functional programming. I guess closures come somewhat close to it in JS? I am mainly using JavaScript to try some game programming. And for that I find OOP very useful. But perhaps trying out Clojure might change my view there as well. Edit: Currently I would think Clojure would be bad for certain kind of games because of Garbage Collection.
A lot of my applications are also performance-critical. :) Are you saying that caching the string length alone actually had a *measurable* impact on your application's frame rate? Or was it only measurable in a micro-benchmark? The problem with posting a micro benchmark is that it has no context associated with it. Maybe you are developing the next moon landing and a tenth of a microsecond is unacceptable, or maybe you are developing a website for your neighbour's coffee shop and it's already running at a silky 60 FPS. Micro benchmarks can be unreliable, misleading, and definitely not something you should design your API around. Instead, you should profile for your particular application and optimize as needed. Sure, post about your findings, but don't do it with a sensational title and out-of-context micro benchmark.
[Github link](https://github.com/VelocityPlugins/vmd) Thanks, this will be a huge time saver !
So in Javascript, a closure is just a function that partially binds some of the variables of an internal lambda. I wouldn't worry about that too much; that terminology can get a bit confusing sometimes. Functional programming in JS can be accomplished by defining all of your functions as single return statements that have do not change any variables not in their immediate scope. OOP is awesome for games, but functional programing can be too! I'll agree that Clojure is probably not ideal for games that are insanely intensive, but for basic things I assume it would be fine. Most languages garbage collect, and while I prefer ARCs, anything is better than manually managing references in the heap.
Don't let any C++ developer hear you say that.
Last question. If I really get into functional programming.. Clojure or Haskell?
Honestly, I'm incredibly biased toward Haskell. I think it's a gorgeous language that is extremely idiomatic and comprehensible after a significant learning curve. Unfortunately, Functors, Applicatives, and Monads tend to be tricky (if you nerd help, I can explain them) and the language is very strange to anyone coming from a C background. Also, the entire language is non-strict, meaning that to Haskell, (1 + 2) is just an expression, not a value, unless something in the program requires finding out what it evaluates to (I.e. the == function). I also think Haskells Type classes are more powerful and more useful than Objects in OOP. That said, Clojure is compatible with **every** java library, uses less obtuse terms, and is far less strict in its pureness. You'll probably get more use out of it. Honestly, even with all the amazing design of Clojure, I just can't get over how much I like everything about Haskell. 
Another possible solution: var people = [ {"name": "Dave" , "owns":["House", "Car", "Boat"]}, {"name": "Mike" , "owns":["Dog", "House", "TV"]}, {"name": "Fred" , "owns":["Sofa", "Elephant", "Space Station"]}, {"name": "Larry" , "owns":["Land", "Coins", "Iron Lung"]} ]; var replacement = {"name": "Fred" , "owns":["Guitar", "Flowers", "Socks"]}; people = people.map(function(elt) { return elt.name === 'Fred' ? replacement : elt; });
very minimal I have to say
How was the high volume of mobile traffic a surprise to them? 
agree ;)
This is perfect. Clean and easy to read. Thank you.
Polish notation, or prefix notation (as opposed to infix notation, which you are probably most familiar with) actually has some very nice properties, namely that it's completely unambiguous. You don't need to worry about operator precedence, or anything like that. Now, just because it's unambiguous, that doesn't mean it's necessarily easy for a human to scan a long expression and immediately calculate the answer. A computer, on the other hand... Polish notation is already very close to an AST representation, so it's very easy to parse. That's probably most of why it was chosen originally.
So, is polymer to react what angular is to backbone?
Didn't consider ReactJS actually, but from what I've just read about it it sounds like a better library than Handlebars, as opposed to being a full framework. Am I reading that right?
Sleeplessness? Browser data for the normal site? (I try to read xkcd on a desktop browser just for the alt text! I know, you can go to m.xkcd.com on mobile, but from most embedded browsers the URL isn't easy to edit.) This also amused me: &gt;We anticipated a higher proportion of the Colbert Report referrals would be using IE.
Yeesh, this is pretty old stuff; i'd look into using a proper module system, or at the very least [the module pattern](http://toddmotto.com/mastering-the-module-pattern/)
I've never really had a problem with it before, since I could always round, but in this case I need to convert mm to inches. It's odd, with PHP and the same math none of the numbers used are wrong. I can see above why it would be an issue. Either way, big.js worked and it's not public facing so I'm not worried about performance: http://jsfiddle.net/9x152xb8/ 
On second thought. I can see the advantage of ( + 123 ) to ( 1 + 2 + 3 )
&gt; I need to convert mm to inches You could do your math in tenths of mm then. 1" = 24.5 mm Integers work fine up to 2^53 (9 quadrillion, a 9 with 15 zeros). &gt;with PHP and the same math none of the numbers used are wrong Eeeeeeh. PHP will say that 0.1 + (0.2 + 0.3) is 0.6 and that (0.1 + 0.2) + 0.3 is 0.6. However, those two "0.6" results aren't identical. (0.1 + (0.2 + 0.3) === (0.1 + 0.2) + 0.3) is false. 0.3333333333333333 &lt;- 1/3 with JS 0.33333333333333 &lt;- 1/3 with PHP Apparently, PHP just discards some of the value for printing.
I like it, seems to cover all the important parts and the syntax is pretty good. Does anyone know if there were contentious item left open or pushed through in the procedure? I know some time ago there was some debate from commonJS users but is that satisfied now?
Uhhh, what's the context? Are you talking about something for parsing the XML into some kind of object and using the object to manipulate node attributes?
I don't know. My lisp/scheme/clojure knowledge is very limited. If I had to guess, I would say infix is not an option. But apparently macros are very powerful in lisp, and you can basically create new syntax for the language, so... maybe? No idea how that would be done, though, if it was possible. Either way, my take is that it's usually best to write in the language you're using (i.e., if you're using lisp, write lisp, don't try to write C or PHP or whatever in lisp).
True. Although a language like Haxe does look interesting. Depends what you need. I'm of to learn Clojure now. So that one day I can write my own language haha :)
Amazing. Thanks again.
This is a WebGL game I am currently working on. The idea is pretty simple, you have to stop the attacking cubes from reaching the center of the map and deal you damage by turning a ring and blocking them. Turn the ring with the arrowkeys or by clicking on the left or right side of the screen. Each time a cube blocked an enemy cube it wil be damaged until it is fully gone. Each blocked cube will give you one resource of either red or blue. If you collected enough resources you can upgrade your ring with more, more powerful cubes. Later on you may buy healing cubes that give you back some HP. Please let me know what you think about the game, what you would have done different, bugs, features or ideas. Also I would enjoy your comments on my most crappy codestyle :)
Yeah, pretty much. ReactJS doesn't give you a full blown framework, it only focuses on the view layer. There's an application architecture called Flux: http://facebook.github.io/react/blog/2014/05/06/flux.html Unfortunately that's mostly the extent of my ReactJS knowledge. I haven't used it much. 
I say one of the best from these guys 
I agree with u/gregjsguy lodash or underscore is the best tool for this job. 
link is down.
Haha, yes, I know. I'm trying my best to avoid it where possible, store pre-computed parts, etc.
Certainly sounds like something to look into further, thanks a lot for that.
Thank you. Excellent catch, I was on my phone at the time and hopefully it was taken as more a general concept than anything else. 
That is totally fine. Sleep goes first.
Game concept is decent, game play is not enjoyable. 1. Pressing "enter" or "space" should start the game again (after dying). Don't make me go back to my mouse/trackpad. 2. The turning is so sensitive and the "capture" area is so small that it's too annoying to line up perfectly. It's not fun. 3. Seems like the capture blocks can only be used for their indicated count. They should count down as used. 4. Would be more interesting to have to control all the capture blocks independently. For example, I use my left hand to tap the number of the block and right hand to rotate them.
Yes, JavaScript can edit any kind of XML data.
Who in this age animate thing with jQuery?
Meh, I'm sure unit tests would have caught that :)
The vast majority of programmers outside of the bubble we live in. 
Check out CommonJS and browserify. Your modules can all have exports and depend on each other, but none of them actually attach themselves to the global scope. The entire bundle ends up getting wrapped in a function. :)
What is suitable for animation then ? I am not asking because I think jQuery is good, but I just wanted to know as I am just beginning with javascript.
I liked the article, felt like a good intro which I guess is the point of it :)
I've been using Velocity for the first time in a current project, it's very simple and smooth as butter. love it.
I've never heard of those books. Let us know what you think of them. As a "noob", I would try to stick with one book, read it attentively, try out all the examples yourself in the browser or with node.js, and keep your nose to the grindstone. The more you practice and write out yourself, the better off you will be. If you're looking for more resources, I would recommend - [Eloquent Javascript]( http://eloquentjavascript.net) by Marijn Haverbeke. (Free online) - [Learning Javascript Design Patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/) by Addy Osmani. (Also free online) Both of those really helped me out as I was starting to learn Javascript and I still refer back to them.
&gt; ECMAScript 6 modules export bindings, not values. That's one of the most important points in the whole article. &gt; There will eventually be an API for properly and safely evaluating any JavaScript code, but it won’t be part of ECMAScript 6. That's sad. This really cripples live coding in JavaScript. 
http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html This actually explains the concept better than I can.
What part of the word 'standard' do you not understand? All the others projects have names that either implies or explicitly states it is a fork or at least not that they are official/standard implementation.
Transitioning elements with JavaScript libraries can be ten times fast for all I care, but is it as *good* as CSS transitions? I see CSS transitions as native transitions, it leaves the implementation up to the device, browser and user. You are asking for the browser to make a transition whenever a style property changes, not implementing your own way of rendering it. Disabling transitions could be a battery saving feature or user preference. Hell, a device vendor could define the default easing to match the one in their UI. The browser ensures everything remains responsive and the transitions won't crash it. If some browser fails at doing so, it's their problem and will probably be solved in an update. I think doing transitions with JS is like creating your own, better select input. While it might be prettier and consistent across all the devices, you can't possibly account for all the usage scenarios and device configurations and user preferences. Better to just go with the native, or at least have it as a fallback. I also think transitions just make more sense in CSS, because that's where the appearance of the various element states should be in the first place. CSS transitions are certainly lacking in features and hopefully we'll see many of the things that were in the article as native implementations in the future, but this didn't convince me to switch. 
I would also love to hear what people might have to say about this!
I have a small JS project, theres a few slightly complicated parts too it, but its not tooo bad :) [Cluckles](https://github.com/ilikeprograms/cluckles) Also the [website](http://cluckles.com) is powered by Github Pages :)
Definitely sleeplessness, mixed with a little too much focus on fixing the most broken thing vs. the most common thing.
Quite a few projects will have "intro" issues for folks to get started with. Whether they're aimed at beginners-to-coding or beginners-to-that-particular-project can vary, but they're a great place to start. There's a good example on the [Glimpse](https://github.com/Glimpse/Glimpse/labels/Jump%20In) project. I'd suggest finding a project that looks like fun, and checking their issue labels.
Depends if you want plain JavaScript or JavaScript written using some other libraries/frameworks because projects mostly depend on frameworks. The code on top is simple but under the hood it's too advanced / requires some deeper understanding.
How about starting your own project?
I am self taught and I have to say that the best way to learn is to have a very clear idea of a simple project that you can realistically complete. I learned javascript with "JavaScript: the good parts", and I built a page with a deck of cards that shuffled when you press a button. I still have it on github https://github.com/SpencerCooley/poker_project. Both books you mentioned are probably good, but the real learning happens when you are trying to accomplish a specific goal and get stuck on something. "Javascript the Good Parts" is definitely good, very light and to the point. http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742 
[Secrets of the JavaScript Ninja](http://www.goodreads.com/book/show/4373732-secrets-of-the-javascript-ninja) is a good one for beginners. Be a little bit careful starting with a jQuery book, or any book that focuses on a specific library or framework. It's important to learn the language itself before jumping into libraries, otherwise there's bound to be confusion between which features/concepts pertain to the language itself or the library.
I’ve clarified the latter point: you can dynamically evaluate modules. But a more elaborate `eval()` has been postponed until after ES6 (as part of the so-called “realms API”).
There is a great site called [Up For Grabs](http://up-for-grabs.net/#/) that publishes different tags in open source projects and these are most often easy stuff. Remember that contributing to OSS isn't always about code but also documentation as well which people are always grateful if you help them with.
Seems really useful! But what unfortunate naming: https://www.google.nl/search?q=storagejs 
I would see React.js more as a render layer instead of purely a template library. The main components that react doesn't give you is Models/Data layer and Routing. React.js being a good fit for you depends on what jQuery is currently doing in your application. For example if jQuery is used to make some parts of your site dynamic react might not be the right solution. If your site has well defined widgets that jQuery is powering react is probably better at that. You are also talking about a large site and not a application so I am guessing SEO could be important? In that case react might not be the best solution. For example if you have a drop down navigation and you replace it with react it wont be crawlable. Picking a good Javascript architecture for a multi-page site with some app like parts is always hard. It mostly starts out as jQuery but then becomes an unmaintainable mess of plugins or custom plugins with a lot of state in the HTML.
 people.map(function(person) { if (person.name === "Fred") person.owns = ["Guitar", "Flowers", "Socks"]; return person; });
I am also trying to start and my colleagues at work have suggested me [paper.js](http://paperjs.org/) and [Codepen](http://codepen.io/). If you want a structured free basic course, [Dash](https://dash.generalassemb.ly/) by General Assembly is free and pretty pretty well structured. I hope this helps! 
It is very useful. Thanks a lot /u/gcanti
From basic: NOT: if (a == '') {...} YES: if (a) {...} JQuery: NOT if ($(element).length &gt; 0) {...} YES if ($(element).length) {...} To more advanced: http://www.javascriptturnsmeon.com/the-tilde-operator-in-javascript/ And remember to add in your article comment about trying to not be "oversmart". This techniques should help and not make things more complicated for other developers (like in advanced example)
Advanced usage of Object.create and the other functions on Object and Object.prototype could fill a book. I recommend being knowledgeable on that before worrying about the little snippets that reduce how much you need to type.
Thanks man! Gonna put it into the article
&gt;Using void 0 instead of undefined If anyone on your team is overwriting `undefined` you've got *much* bigger problems to worry about. `void 0` is *not common* and I wouldn't recommend it.
Don't worry, we're fine :) But `void 0` is something that you see rather often in source code of libraries such as underscore or backbone, and people keep asking wtf is this and why not to simply use `undefined` instead
First of all: Why you wanna use jQuery for DOM manipulation? Is slower than the native browser api which in this day of age is very consistent and supported cross all browsers above E8+. For your question, A example would be: var myComponent = (function(dependency1, dependency2) { var myTemplate = function () { return( ["&lt;div id='wrapper' class='wrapper'&gt;", "&lt;"h1 id='heading'&gt;title&lt;/h1&gt;", "&lt;/div&gt;"].join("") ); } var render = function (parentSelector) { var parent = document.querySelector(parentSelector); return parent.innerHTML = myTemplate(); }; var someBehaviour = function () {...}; return Object.freeze({ render: render, someBehaviour: semeBehavior }); })(); document.addEventListener("DOMContentLoaded", function(event) { myComponent.render(); }); Ofcourse, this is a very simplistic and quick way. It would be better use something like browserify and put the template in a diferent folder and abstract the render function, models, etc. Note: I don't support E8.
Instead of this: var that = this; function(){ // do sth with that } You can do: function(){ // do sth with this }.bind(this)
Thanks for your answer. I don't insist on using jQuery. I thought that is the preferred way to do dom manipulations nowadays, but maybe my knowledge is outdated in this regard. I found many articles about using different frameworks and libraries for doing gui in js. jQuery has its own mechanism (widges/plugins) for this. But I'd like to use regular js objects and build composable widgets from them. I haven't found too much examples about this, and this makes me think I'm missing something.
The smartest way I've seen to deal with overwriting undefined is this - http://toddmotto.com/what-function-window-document-undefined-iife-really-means/
Yep, so you see now why I put it on reddit before actually publishing it :) Any ideas on article title not so long?
"Demystifying Common Javascript Hacks" ?
Just started this [project](https://github.com/dreaddy/dreaddymck_json_object_rotator). A content rotator. Suits my purpose. Feel free to fork.
No one should support it in the first place.
Is all about how you modularize your project, nothing magic needs to happend :).
http://kangax.github.io/compat-table/es6/
I am wondering ..when you do desktop ui, do you create your own UI controls from scratch? JavaScript has evolved so much, so to use only JQuery is like doing your own controls from scratch when using Java or .Net. Use a robust framework, the right tool for the right job. You have so many options. If you use only JQuery you will be spending way more time and dealing with things that have already solved.
This is great. Marionette is a great extension (necessary IMHO).
I'm not sure about that length trick. While that technically gets the same result, it's not clear code. if(.length &gt; 0) is has an element or more, while if(.length) is has a length property that is truthy. The former requires less thinking around edge cases. Edit: words.
this
Absolutely agree with you on everything except regexps. I mean there are reasonable problems to solve with it, but if you can avoid it you probably should, because any other-way code would probably be easier to read and reason about, than regexp solution.
undefined, NaN, and Infinity are read-only since ES5.
you right, it is crowded. any suggestion? 
"Javascript Party Tricks" tricks where the only acceptable response when they are pointed out is: "sorry, I must have been drunk when I wrote that." Sorry, but most of these tricks are just really bad code. 
&gt; From basic: NOT: if (a == '') {...} YES: if (a) {...} I'm a bit slow today. Are you saying that if (a) {...} is preferable to if (a=='') {...} ? 
I'd say yes, because it's concise and most of developers are used to it. 
That's a nice addition
You can use it right away with browserify and es6ify. Since it's listed as a transform, others can install your module as a dependency and never even realize the library was coded with ES6. I think once es6 lands by default in Node, doing this will make more sense and be more acceptable. 
Um... Well kinda. Let me summarize. void 0 — bad (function(){})() — ok x = y || DEFAULT — ok if (s) instead of if (x == '') — ok +str — bad Again, I don't mean to defend the usage, it's just that they are really used inside of many libraries. I'll probably should add note to every of them, whether it should be used on regular basis, or only when drunk
I would say that the longer version is better. It communicates far more information and *intent* to the next reader of the code, and doesn't rely on the annoying JS truthiness stuff. And more to the point, nightman screwed up here. The two pieces of code are not even the same. nightman assumed that an empty string is "truey". It is falsey. It is a great example of why you should not write error prone code. 
Most of the time I'd rather take the hit on performance than the hit of adding another third party library to the codebase. That can vary if the focus of the project is on the animations and transition effects, but it doesn't come up that much for my work. 
by "reimplemented the blink tag" do you mean you set the opacity on a link to animate from 0 to 1 using keyframes?
https://gist.github.com/rmurphey/576723 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions#js http://agentcooper.ghost.io/javascript-interviews/ http://www.reddit.com/r/javascript/comments/1qn7bo/mildly_interesting_question_i_got_while/ http://jamiemason.github.io/front-end-engineer-interview-exercise/ http://www.reddit.com/r/javascript/comments/17d7xv/what_kind_of_questions_can_i_expect_on_javascript/
Holy shit.
Depends on your browser requirements and assuming you mean default browser functionality (no transpilers). Chrome has starting supporting portions of ES6, but there is a lot more to come in the next version (v38). FF seems to be supporting the most right now, but there is still a lot to go. IE9 and 10 don't support it at all, 11 is just starting to support it. If you don't need IE9/10, then MAYBE in a year most browsers will support it? Refer to kangax_'s post for current implementation details.
&gt; First of all: Why you wanna use jQuery for DOM manipulation? Is slower than the native browser api which in this day of age is very consistent and supported cross all browsers above E8+. jQuery uses native DOM manipulation when available. It's not slower than native because that's what it uses unless it falls back to another implementation.
This is very true, I thought I was clever until I tried to input 0 in my forms... 
Perfect, thank you!
Considering that || 10; is a number; what do you think about: var someFunction = function ( value ) { if ( typeof value !== 'number' ) { value = 10; } }; Some "type safety" right there if OP would only want numbers. Incidentally. Do you happen to know if '|' does the same as '||' ?
Is there any benefit to typeof age !== "undefined" vs age !== undefined ?
Wow.. that is important to remember!
The benefit is a clean API and a constructor that's composable as a normal function. The `new` operator adds performance because compilers are not yet sufficiently smart, but the cost is composition at the user of the class. If the issue is memory, you can still use prototypes. Object.create(prototype) works in all JS engines (with a polyfill for old IE), and doesn't force your prototype to be on the "prototype" property of the constructor function like `new` does. var Ctor = function Ctor () { var ctor = Object.create(Ctor.methods); ctor.foo = "bar"; return ctor; }; Ctor.methods = { m1: function () {}, m2: function () {} };
I have my own small project called [node-upload](https://github.com/jillesme/node-upload). It's basically an image upload script written 100% in JavaScript! The back-end is Node and the front-end vanilla JS. Would be cool to have some more people sharing ideas and working with me!
You're essentially just going to build your own framework, which isn't a bad thing but if you have more than one dev it's gonna get hairy
Since age is a parameter of the function `setAge`, we KNOW it is defined in scope. This means that `age !== undefined` is equivalent to `typeof age !== 'undefined'`. If we didn't know that `age` was in scope, we need to use the `typeof` keyword, which does NOT throw a `ReferenceError` when referencing a variable by name that is not defined in any reachable scope.
Here's a polyfill: if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== "function") { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {}, fBound = function () { return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments))); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }; }
wrap it in an anonymous function (function () { canNotTouchThis = {}; })(); 
Wow, thats sweet! Can you make a bit of it writable? I mean something like, defineProperty MyApp with value of { whatever: {}, inputs: {} } where MyApp is writable: false but the inputs bit is writable: true ? You could let people write stuff to the inputs object but read it from the rest of MyApp the way YOU want.
np
You can also argue the other way around: since we know `age` is in scope, we *shouldn't* be using `typeof` since that will silently turn into `if (true)` if we have a typo.
Thanks, guess I will add a notice to the article
&gt; since we know age is in scope, we shouldn't be using typeof [I think.. I think you're right.](http://weknowgifs.com/wp-content/uploads/2013/04/youre-goddamn-right-gif.gif)
If you just want to check for null or undefined and still have the other falsy values be acceptable (false, 0, "", NaN) you can use this: function(arg) { arg = arg != null ? arg : DEFAULT; } By using the equality operator (`==`) instead of the identity operator (`===`) you take advantage of the fact that null and undefined coerce to the same value. There are two caveats: 1. You should only use this when you absolutely know that the variable you're testing has been defined. If it hasn't been defined, a `ReferenceError` will be thrown. 2. If you're working on a team and only use the identity operator (as you should 99.9% of the time) then using the equality operator might appear to be a typo by other members of your team. This can easily be avoided by adding a comment explaining why you're using the equality operator.
Gist link would do just fine
I would suggest taking a long look at AngularJS, specifically it's directives, which allow you to build out self contained "components" that can be reused many different ways.
&gt; JQuery: NOT if ($(element).length &gt; 0) {...} YES if ($(element).length) {...} How do you feel about if ($(element)[0]) { ... } ?
 if ((void 0) !== undefined) { throw new Error('Script halted on moral grounds: The person who redefined "undefined" needs to be found and fired. Out of a cannon. Into a wall.'); }
Swapping variable values without a temporary third variable: a = [b, b = a][0];
Pretty much only when you're writing javascript environment independent library code, like this: https://github.com/umdjs/umd/blob/4a87e85450baf582005243f9e922566ef2fc533a/returnExports.js
I think it's better to just never do it than to sometimes do it because the type happens to be okay this time.
&gt; I've never used either of these in practice-- are there any even remotely common situations where an eval is the proper solution, that isn't a case where something else isn't horribly broken? ES6 Reflect.construct polyfill for browsers without native `.bind` method. [Here is my _R library](https://github.com/Ginden/reflect-helpers/blob/master/reflect-helpers.js), see lines 408-420 or search for *_R.construct*. _R heavily utilises eval and Function but _R.construct is the most common case. 
TIL
Totally agree.
Can't wait to try.
Well it's not the same thing though. `if (a) { ... }` passes for any defined anything (string, obj, etc.) so it doesn't check for the same thing. Doing `==` is also a no-no in JS world so I would definitely not do that. If you'd like to check if a string is empty but also defined, take a lesson from [lodash](https://github.com/lodash/lodash/blob/master/dist/lodash.js#L6589-L6600) and create a dedicated utility. Simplified, however, it's enough to do a `if (a === '')` check which will check that the variable is defined and it's empty. 
You are true but I will still defend if (a) {...}. I think that we should find balance between "smart" techniques and being "oversmart". After all in many teams code is written and maintained by proffesionals and it would be waste of time to strictly enforce if (a === 'string') {...} on them. Especially when you know that they know how to deal with it and what are traps (number 0). Other thing is that code should be maintainable by less "powered" users. My point here is that it's not easy to find right balance. BTW I use grunt/gulp with tasks: * JSHint * JSCS (JS Code Style - AirBNB style) So that some decisions are already made.
Yeah, this is great but I don't think I will use it in practice.
The actual project homepage: http://jhipster.github.io/ I'm not sure how a competent writer could overlook something so basic and important (such as the project's homepage) when writing about a new software project, though in true Infoworld fashion, they do manage to link to several other articles on the Infoworld site (I've never been impressed with Infoworld, and this isn't helping). As for the project, I'd highly advise a better name, since _hipster_ is a pejorative term with negative connotations.
I'll take worst named JavaScript library for $1000, Alex.
If you need to compare 2 Objects that are coming from different sources and may be equals: var objA = {"key": "value, "key2": "value2"}, objB = {"key": "value, "key2": "value2"}; console.log(objA === objB); // false console.log(JSON.stringify(objA) === JSON.stringify(objB)); // true Also, if need to avoid hoisting and referencing the same object (and thus modifying both objects when modifying one): var objA = JSON.parse(JSON.stringify(objB)); Admittedly you could use underscore library to do these things, but if your overhead is low.... 
What is Ragnarok? 
Define "not working" 
[here's an old list](https://code.google.com/p/jslibs/wiki/JavascriptTips)
I wish my companies clients would get on board with this notion, we are still partially required to support IE8 (especially when our clients work is being shown in foreign countries, namely China)
Attack on Titan intro. OP has good taste!
Using 1.10.1, the following line of code doesn't seem to be working: $('#result').text(myStorage[0][0] + '....' + myStorage[0][1]); and the bottom label doesn't get populated
wow i am so sorry. i just tried in Chrome and it worked fine. i guess IE is the problem. how annoying.....
I'm more partial to the Railgun S intro, but I wanted to make sure the default video was something that wasn't too intensive.
Smartest way to deal with vague non-existing problem. If someone overwrites undefined, your application needs to die ASAP to see there's a bigger problem.
Wow, this one is much bigger the mine. I put a link into the article
Works for me too with 1.10.1
wow i am so sorry. i just tried in Chrome and it worked fine. i guess IE is the problem. how annoying.....
wow i am so sorry. i just tried in Chrome and it worked fine. i guess IE is the problem. how annoying.....
alright, thanks for the advice
yes. what browser do you have?
The article was read like it was written as a paid advertisement. Infoworld is not a place where one would go for development news. 
IE ver 9.0.8112.16421 Chrome ver 36.0.1985.143 m
Once you learn Regexp, it's just more code. There isn't anything inherently difficult about reading or reasoning about properly written regular expressions than properly written JS. Yes, there are a lot of examples of really bad one-liner regexps, but you can write really bad, one-liner JS, too. Used as they are intended, regexp improves the readability of code. Practice with http://regex101.com/ and your text editor. Most programming-oriented text editors have regexp-capable search and replace. Get used to using it and it will make you a LOT more productive and less error prone. For example, I wanted to dump the results of a SQL query to a debug string printed to the console, with the names of the fields printed next to the values. A simple regexp in my text editor over the SELECT clause allowed me to very quickly construct that function call without making any spelling mistakes for field names.
Using Number boxes the number in an object. I've used eval in toy programming languages that translate to javascript. For example: https://github.com/capnmidnight/betty-boop/blob/master/pong.html ... oh, huh, you know what, I completely forgot that I didn't actually use eval for that. I used DOM to generate script tags with data URIs for the src attribute.
Yh from scratch. One of the rules of the comp was that we were allowed to use any external services of libraries. All my code for the game is here: https://github.com/ChrisToffee/Silly-Gooses Probs not the best example of html5 game dev, but yh all from scratch 
Very nice! I am currently remaking frogger for a school project from scratch. Not as impressive as your's though!
&gt; It mostly starts out as jQuery but then becomes an unmaintainable mess of plugins or custom plugins with a lot of state in the HTML. Do we work together? Seriously though, this is exactly how the codebase is at the moment, but I guess it's a pretty common path to have taken in cases like this (however unintentional or unwanted it was in hindsight). SEO isn't an issue for the areas I develop on, as these are all within a user login area. And JQuery has kind of been used for a bit of everything across the site. I actually spent a little time today looking at ReactJS and although I like the idea of it, I'm not too crazy about how it mixes HTML and JS - this was exactly what I was trying to get away from when introducing Handlebars. I've yet to look at Flux though, so that might be a little different.
&gt; Using Number boxes the number in an object. That is only if you use "new Number(foo)". If you don't use "new" then it actually does a type coercion. i.e. Number(foo). Also note that: (new Number(3)) !== (new Number(3)) The objects are not the same and not equal if you box numbers up. So, beware everyone. 
He even copied the GUI style! Pretty cool.
I disagree. There's a trade-off between convenience and security, and I find it hugely convenient to use this trick, especially since the vast majority of the time I'm not using a number or boolean value. Most of the time, it's an options parameter that is an object.
I will give advice as i read your project. &gt; It uses the js-expression-eval so be sure to grab it and include it in your html page else calculate.js won't work. You should bundle this as a dependency of your module/API. Keywords to search on: *browserify*, *bower*, *package.json* * I prefer function Class() { .. } syntax over var Class = function() { .. } to create constructors, i think the former one is more clear. * I would suggest using var DEFINED_LATER = null; this.firstBracket = DEFINED_LATER; or something similar. * When setting prototype this way, make sure to set the constructor property properly. [jsfiddle](http://jsfiddle.net/tqrfep0m/) Otherwise bad/unwanted things could happen if sometime in the future you will be playing around inheritance. * Unexpected behaviour can happen when: function init(out) { var consoleOutput = out || false; alert(consoleOutput); } init('1'); // when evaluated, this will be a truthy value, but i guess, falsy is expected * Mind, that **!=** is considered as **BAD** practice since it forces type coercion on operands, resulting in unwanted behaviour. '1' != true // false I think, The string 1 should NOT be equal to the boolean true, but when coercing, it is equal. see [ECMAScript 11.9.2](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.2), use the strong in-equality operator instead [ECMA_11.9.5](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.5) '1' !== true // true * The same applies to the loose equality versus strong equality operators. Use always === ! * When using parseInt you should always set the radix parameter, because omitting it can lead to errors, or to strange behaviour. See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt#Octal_interpretations_with_no_radix) * Such amount of [nesting](https://github.com/j0hnskot/calculate.js/blob/master/calculate.js#L340) is consodered as **bad practice**, you should reconsider your code, because it's unreadable in this way. 2 or max 3 level of nesting is affordable, top. * Always use braces! [omitting brace](https://github.com/j0hnskot/calculate.js/blob/master/calculate.js#L361), many style guide, and many _JS master encourages the use of braces because of automatic semicolon insertion. Omitting them is considered as bad practice. I think thats all, hope it helps :)
You can use [$http interceptors](https://docs.angularjs.org/api/ng/service/$http#interceptors) to display a loading icon when http requests occur. [Here's](https://github.com/chieffancypants/angular-loading-bar) some code you can checkout for an example. I always use resolves for data I want to have available when I instantiate a controller. Using resolves also allow me to handle errors prior to the controller loading the template.
As much as it is a dead horse, there are thousands of small to medium sized companies that can't afford to up their OS off XP yet. I deal with quite a few every day. 
So if there are multiple default parameters you want such as a number and an object you would use both methods? Btw, this also fails on strings: function setName(name) { this.name = name || "Not Specified"; } Can't enter an empty string. Also considering javascript always has a bad rap for weird falsy values, I'd rather spend half a second with a piece of mind, than writing inconsistent code that's possibly vulnerable to bugs. 
bind is really cool when you start to get creative with it. You can yank out built-in functions from Array, Object, etc, and bind them to different receivers to reuse them in interesting ways. E.g. a 1-liner filter against a regex, without having to write "function" anywhere: ["foo", "bar", "baz"].filter(RegExp.prototype.test.bind(/a/)) // ["bar", "baz"] 
If only that didn't magically make it 5 times slower. Also, "that" is possibly the worst variable name. `this` is arbitrary enough, now you want to give something a name that means "the 'this' of some unspecified other thing"? Come up with a real name. (Not picking on you, but the pattern you quoted.)
Wait wait. `* 1`? `parseInt`? `parseFloat`? Why are we using hacks for something that's build into the language? JavaScript has a "convert to a Number" unary operator, `+`. `var x = +'10';` sets `x` to `10`. And JavaScript has a "convert to a Number" function, `Number`, which is convenient for things like `var arrayOfNumbers = arrayOfStrings.map(Number);`.
 (function (undefined) {console.log(undefined);})(2); Run that, then tell me they're read-only. It's `window.undefined` that's read-only, and nobody's code is running outside a function any more.
Kind of don't know if I should share this, since I never see people talk about it and that makes me think somebody called it bad practice. But, most people seem to be unaware that you can label any JavaScript statement, and break any label by writing `break labelName;` (or, if it's a loop that was labelled, `continue labelName;`). This is most often useful in nested loops, but I've found use for it with plain old block statements, for example in the `setAttribute` and `appendChild` functions in [DOM.js](https://github.com/twberger/DOM.js/blob/master/DOM.js).
I too am exploring this kind of approach, although using d3.js (and idempotent DOM manipulation) instead of jquery. One of the most crucial foundations I've found is having a decent module system/build tool/package manager. Browserify, componentjs, or duo (when it stabilizes) are great, I haven't tried others. You might want to check out various components on the [componentjs wiki](https://github.com/componentjs/component/wiki/Components), many are designed the way you describe, although the quality varies greatly. There is also a [sample todo app](https://github.com/component/todo) that is a bit dated but could be useful to look at in terms of wiring together components. 
Yeah, especially seeing that I do front end dev for market research, and sometimes our respondents have a huge variety of browsers, its something we have to compensate for.
In case of the example this doesn't seem necessary cause you could just remove the 'left' rule. Could you give a more realistic example?
No, I'd imagine he means like this: function Constructor(opts) { this.opts = opts || {}; } So empty strings don't come into play. In any case, I feel as though a JS dev should understand falsey and truthy values. Or at the least, they should try to learn how types in the language work.
I meant you can't use it on numbers/booleans/strings, which is a large number of the types in javascript. Sure there are a lot of times you want an options object, I find this is mostly for public accessible library classes. There are plenty of times I find I want a constructor with some simple parameters of direct properties. I think it's much better to be consistent throughout your code than to swap to using some cheap hack when you know you can get away with it.
If all you need is a shallow copy of an object, then yeah, you can use Underscore for that. Underscore, however, doesn't have a way to make a deep copy of an object (albeit LoDash does), so nested objects are still copied by reference. I had to deal with this problem at work the other day and used the method you suggested: `_.partial(JSON.parse, JSON.stringify);` Sadly this trick doesn't work with objects that contain dates, functions, or RegExps. :/
It's definitely not considered the _best_ practice, that's for sure. There are definitely times where it does become useful, however. If it is used, I'd definitely suggest leaving some documentation explaining what it does and why you used it, since, as you explained, it's not used very often.
Even if that is even truth, just cheking availability make it slower. Note: I haven't checked jQuery source code in a while.
`JSON.stringify()` makes no guarantees about key order, among other things, so that's not a reliable trick. JSON.stringify({a:1,b:2}); // =&gt; "{"a":1,"b":2}" JSON.stringify({b:2,a:1}); // =&gt; "{"b":2,"a":1}" In contrast to JSON, Bencode guarantees a encoding normalization but that's not so easily available. 
I used a similar abstraction once. It's mostly helpful, but be warned that "tap" events being synthetic and merely derived from "click" and such, methods like .preventDefault() will not prevent interaction with a form element, for example. 
Javascript sorts arrays alphabetically by default. To sort numerically: [10, 7, 9, 8, 11].sort(function(a,b) { return a - b; }) // =&gt; [7, 8, 9, 10, 11]
It's impossible to tell for sure without a testcase — people need to be able to reproduce the problem in order to tell you what's happening. But if I had to guess, the server is configured for persistent connections, and the timeout is set to a value larger than 1 minute but smaller than 5 minutes. When persistent connections are enabled, the connection can be reused for multiple requests, avoiding the overhead of having to establish a new connection each time, which involves the three-way TCP handshake as well as potentially a SSL negotiation. But it's not kept open forever; if there are no additional requests it will be closed after a certain time. However, unless you're on mobile, the three-way handshake and the SSL negotiation should take on the order of 50 - 200 milliseconds, which means it shouldn't be noticeable unless you are precisely measuring the time. It would only become noticeable if you had dozens of requests each requiring a new connection.
Using functions to make up for lack of block scope. Eg: putting an anon function inside a for loop so that closure access to the loop iterator will have the expected value. Using IIFEs as a means of preventing pollution of global, and for defining modules. Also for creating "private" variables. The entire concept of the flexible 'this' value. It allows for some interesting and useful patterns, such as mixins and usage of Array methods on anything that has a length property.
It has nothing to do with the OS in most cases, if it was, they could just use Firefox or Chrome. Most places stick with XP because they have shitty legacy sites that only run on IE7/8
Pointer-events:none disables mouse events from triggering on visible elements. You could also set display:none on it which would probably be a better use case for your library since you can't change the display and animate something on the same frame. Setting top or left to be offscreen is super bad form.
How the hell is parseInt or parseFlost a hack? 
True indeed, my use case was to compare an object sent to server and sent back to the app as a validation of transmission, so the order of keys was the same, but Objects as themselves weren't comparing as equal, being by nature 2 different objects
I doubt it offers anything over Hammer, I think the author has more less just made a friendly share here
I can hear the "what the hell"s from here.
gotta break out those JS skills and recursively copy properties 
if you did display: none, then you toggled display: block, and tried animating the opacity it wouldn't work with transitions. pointer-events is supported by IE 11. Never heard about moving objects offscreen being bad form--it works great.
The source code is fully documented (well, maybe not *fully*, but to a great extent. The Object Oriented API surely is). I used yuidoc-complaint docblocks for making it, so if you have yuidoc installed you can build the documentation yourself. Pull requests are welcome by the way.
Probably don't want the var considering with var there `a` will always be undefined (unless you're redeclaring). Thankfully this can be done with ES6 destructuring: `let [x, y] = [y, x]`.
Could very well be a memory leak in your application. I just finished the Chrome Dev Tools on Code Academy. The last two lessons would be particularly helpful in debugging your issue. 
I have the most simple Ajax code ever. It's very basic and simple.
Its use cases are probably similar to asynchronous pipelines (eg. [async's waterfall](https://github.com/caolan/async#waterfall)), except that the order is called by examining the function's parameters rather than by the order of the functions. I'm not sure why that's useful.
I just cheked a little bit the jQuery's source code, is does many things around for example "$(#id)" than just cheking avaibility, also it check mobile support, it's css selection syntax and many thing more before even consider "document.getElementById(#id)", also there are many of [this](http://jsperf.com/jquery-selectors-vs-native-api/7) that prove my point. I have never seen any test which jQuery beats native.
Double bang to coerce to boolean. !!null // false !!undefined // false !!"false" // true :( !!"" // false
0 is falsey. 1 is truey. Thus it shall always be.^TM
True. Fixed. 
Its "truthy"
I wrote a serializer for that kind of situation, https://gist.github.com/holloway/05170a275b988b90144a Usage: `JSONc14n.stringify({a:1,b:2})` E.g. `JSONc14n.stringify({a:1,b:2}) === JSONc14n.stringify({b:2,a:1})` 
Creating your own `undefined` is meant to guard against stupid/malicious things done by other scripts. If you want a language where stuff like that can't happen in first place, try Dart.
Just in case you're as confused as I was, CSP in the title does not mean Content-Security-Policy, but rather [Communicating sequential processes](http://en.wikipedia.org/wiki/Communicating_sequential_processes).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Communicating sequential processes**](https://en.wikipedia.org/wiki/Communicating%20sequential%20processes): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __Communicating Sequential Processes__ (__CSP__) is a [formal language](https://en.wikipedia.org/wiki/Specification_language) for describing [patterns](https://en.wikipedia.org/wiki/Pattern) of [interaction](https://en.wikipedia.org/wiki/Interaction) in [concurrent systems](https://en.wikipedia.org/wiki/Concurrent_systems). It is a member of the family of mathematical theories of concurrency known as process algebras, or [process calculi](https://en.wikipedia.org/wiki/Process_calculus), based on [message passing](https://en.wikipedia.org/wiki/Message_passing) via [channels](https://en.wikipedia.org/wiki/Channel_(programming\)). CSP was highly influential in the design of the [occam](https://en.wikipedia.org/wiki/Occam_(programming_language\)) programming language, and also influenced the design of programming languages such as [Limbo](https://en.wikipedia.org/wiki/Limbo_(programming_language\)) and [Go](https://en.wikipedia.org/wiki/Go_(programming_language\)). &gt;CSP was first described in a 1978 paper by [C. A. R. Hoare](https://en.wikipedia.org/wiki/C._A._R._Hoare), but has since evolved substantially. CSP has been practically applied in industry as a tool for [specifying and verifying](https://en.wikipedia.org/wiki/Formal_specification) the concurrent aspects of a variety of different systems, such as the T9000 [Transputer](https://en.wikipedia.org/wiki/Transputer), as well as a secure ecommerce system. The theory of CSP itself is also still the subject of active research, including work to increase its range of practical applicability (e.g., increasing the scale of the systems that can be tractably analyzed). &gt; --- ^Interesting: [^Occam ^\(programming ^language)](https://en.wikipedia.org/wiki/Occam_\(programming_language\)) ^| [^Actor ^model](https://en.wikipedia.org/wiki/Actor_model) ^| [^Limbo ^\(programming ^language)](https://en.wikipedia.org/wiki/Limbo_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckd717u) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckd717u)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
jQuery does delegate to native methods for selecting nodes, but there's a cost associated with initializing a new jQuery object. Further, many jQuery methods return a new, different, jQuery object. For some hard numbers, see this [jsperf](http://jsperf.com/jquery-vs-javascript-performance-comparison/25) If you're handy with the Array methods and the native DOM APIs, you can easily mimic much of jQuery's core functionality. I often opt for a super lightweight, array-returning selection function like so: function select (selector, context) { return [].slice.call((context || document).querySelectorAll(selector)); } 
This one is nice
Here's another list: https://github.com/jed/140bytes/wiki/Byte-saving-techniques This list is more for JS golfing, but some of the techniques mentioned are similar to ones that you mentioned.
What's the deal with the rush? Why did this comic absolutely have to go live in 3 days? If it was because of the Colbert Report, why wasn't work started on it earlier? Was it just kismet that you guys decided to have the comic be interactive for the interview?
But you create an array, which is much worse performance-wise. Also, for anyone who isn't familiar with this gimmick, the code will be harder to read too. I wouldn't strongly advise against this.
Unfortunately, NaN, Infinity, and -Infinity are also considered typeof 'number', so it's possible that any one of these could slip in to your function with this check.
Thanks, I'll take a look
While "guarding against malicious scripts" is a great notion, it's impossible in JavaScript. If somebody wants your script to crash and runs code before you, they're going to take much more effective measures than overwriting `undefined`. And if we aren't solving the problem, are we not just introducing clutter? re "stupid" things, there's only so much stupidity you can tolerate before submitting a fix, switching libraries, or writing your own. In my mind, if a library makes you patch up `undefined` after running it, doing so would fall under "compatibility hacks" and make me dislike the library that much more.
Isn't return 0 considered a truthy in C++ returns?
Oh god you are right. Man there are a lot of uglies to JS. I wonder how I will feel once I am done learning Haskell as my second language.
Well, "meant". I never created my own `undefined` or did anything like that (e.g. making `new` optional). It's a waste of time. Anyhow, monkey-patching is a big issue with JavaScript. If there are any 3rd party scripts on your page, things can randomly break.
There's also the + unary operator for converting to a numeric value. var string = '500'; var num = +string;
What is the intended purpose of parseInt and parseFloat *other* than to parse strings into ints/floats? What else could it be? 
This is the best option for a lot of reasons. I'm somewhat surprised that the clumsy typeof method is so much more popular. 
&gt; In this day and age, why don't we in fact approach software design from the standpoint of multiple functions accessing separate, discrete data structures instead of data being bound with a function as in OOP? &gt; [...] rather than binding everything within a class structure &gt; [...] as compared to the current approach of binding data with functionality? I'm not real sure what the author is referring to here; OOP can leverage both data structures and methods, but nowhere does it say that the same object should do both. On the contrary, I believe OOP best-practices would dictate that your object either a) is data, or b) mutates data. In other words, if it does both, then you've violated the principles of OOP (SOLID). In traditional OOP, you might have VO's (value objects, which are simple data structures to model your data), and then you have various collections of methods to interact with that data, depending on the context. You might have a DAO/DTO type object to obtain the data and create the VO, and a view object that can take a VO and transform it in some way for display. &gt; The promise of OOP was to emulate real world objects to provide an abstraction human beings were more familiar with. I'm not real comfortable with this assumed definition either.... Regardless, perhaps the author is unfamiliar with functional programming? Because it kind of sounds like what they're getting at, though I can't be sure.
True. But also not true, because it's a standard workaround; and a secret nod to other devs : "js scoping sucks. tru *that*". 
&gt;Do we work together? Haha, it's a super common problem and I am in the same boat at the moment. &gt; I'm not too crazy about how it mixes HTML and JS It's what most people comment on right away. I am so used to it now that I don't even mind and either way you are going to need templating in some form. The one problem I do see with JSX is if you have an html/css guy that doesn't know Javascript. Since they need to work directly inside your Javascript files. &gt; I've yet to look at Flux though Flux just means that you extract your state from your components and store them in a global location (stores) so multiple components can use the same state objects. You have actions/commands that will update that global state and your components will auto update when that happens. 
*begs for penis pun*
Thanks ! Nice, be sure to put it up here! Also this might be a useful article (about game loops) to help you with you frogger remake. http://codeincomplete.com/posts/2013/12/4/javascript_game_foundations_the_game_loop/
To make it work to be able to set display block (from none) and then run transitions, you have to run the transitions on the next frame. Either set the transitioned property inside a setTimeout with 0, or inside requestAnimationFrame
The text input only works about 10% of the time on first try for me. Why is it people can't leave text input alone? It works. Stop trying to improve it with your bullshit.
I can see why they wanted to-- the effect is super cool. But yeah it misses half the clicks.
It does look cool, but its pretty broken too. Back button stops working. Text inputs are wonky.
That is fine. It is not trying to be a website. It is a web application. 
The font on the login page looks a bit wacky to me: [Screenshot](http://i.imgur.com/WzRggPi.png). Is that intentional?
The experience on mobile is pretty bad, since they are highjacking all native features your mobile browser would otherwise handle totally fine... like scrolling and touch events
Alright, I've just renamed it to "JavaScript hacks explained"
Polymer is too busy revolutionizing website design to function consistently, load quickly, or even work at all on mobile. Flash over substance leads to a lot of easy hype. 
That's just Chrome's font rendering being broken on Windows. It's being fixed... slowly.
I put that link into the article. Thanks
What about if you wanted to enforce a parameter type? function setAge(age){ this.age = (typeof age == "number") ? age : 10; } Edit: As [THEtheChad](http://www.reddit.com/r/javascript/comments/2fsu41/common_javascript_tricks/ckd9d3w) points out: &gt; Unfortunately, NaN, Infinity, and -Infinity are also considered typeof 'number', so it's possible that any one of these could slip in to your function with this check.
that
I'm not sure why text input worked for some of the fields and not others, but that's a full stop for me.
&gt; Annoying loading screen I waited less than 3 seconds &gt; Requires login to view... well... anything Thats what pinterest, facebook, twitter do &gt; Unnecessarily implemented as a client-side app instead of a progressively-enhanced website, for no additional benefit in this case and numerous drawbacks Numerous benefits too :-) &gt; Terrible SEO and spiderability, as at a markup level site is essentially empty of any content There are lots of ways to enhance "javascript websites" SEO
TIL I suck at general knowledge in just about any area.
That sounds complex. You may have something there though. Do you have an example of how that would work? Keeping in mind that the javascript interface would still be: animate().start(el); and animate().end(el);
Ah ok. Usually the answer to funky looking fonts on windows is chrome - apparently not in this case though :D
First time on the internet? I like polymer and google's new "material design" but come on, it's not even beautiful.
Looks good but the functionality is all wrong. It said I gave a wrong answer by typing 'yellow' instead of 'Yellow'
Define functions at the top of your function scope, so you can scroll to the bottom to see clearly what gets called in that outer functions Learn .call and .apply and use them when you need to. Replace tricky code with helper functions e.g. wrap something != undefined into has(something) function. Add your functions to the window while developing or debugging code and use the Dev console to invoke them at will. Just remember to remove them once you're done testing! Avoid for loops and use .map, .reduce, .some, .all, .filter and .forEach You can floor most numbers by using the bitwise or operator var int = float | 0 
Personally, all my form validation is usually on the back-end via AJAX, with javascript only to highlight the offending inputs. There's usually no discernible speed difference. I don't see the point of duplicating validation code at the front-end, as you need it at the back-end anyway. Duplication is generally to be avoided. The only use case I see as worthwhile is when you need to reduce server load. But really, how many times is a user going to mess up a form before it's successfully submitted? Once, maybe twice. Server impact is minimal, so what's the point of javascript validation?
CodeSchool is like the middle school to Codecademy's excellent elementary education. Highly recommended and a perfect next step. 
Cheers for the link, great info.
&gt; Numerous benefits too :-) Can you run through some of them? (Ideally from an end-user's point of view, rather than a designer or developer)
Fucking chrome man, I'm moving to firefox.
The difficulties described here are *exactly* why I am working on my own functional testing framework. Automated functional testing is too damn hard. Tests are hard to write and end up being really brittle, causing either lots of false negatives (failing tests when they shouldn't) or really defensive testing code that deals with delays, etc. Here's what (part of) your last test could look like in this framework: open https://www.rijksmuseum.nl/nl/agenda/ ## datepicker should be hidden by default assertHidden [data-role~=date-navigation-calendar] ## datepicker should open when button is clicked click [data-role~=date-navigation-value] assertVisible [data-role~=date-navigation-calendar] ## datepicker should close when you click outside click body assertHidden [data-role~=date-navigation-calendar] You'll never need to write callbacks or `waitFor()`s because it automatically waits for the action or assert to succeed. Unfortunately, it can't do stuff yet like storing stuff in variables like you do for the URLs, but those tests can be expressed differently. Tests are run in PhantomJS (like CasperJS) and run really fast because there is no need for artificial wait statements. Additionally, it makes an effort to truly simulate user behavior. The mouse pointer actually moves across the page to elements that are clicked. The viewport actually scrolls elements into view before they are clicked. The project is still in its early stages of development but articles like yours make me confident I'm on the right path. If you're interested, I'll be giving a brief presentation about it at the [Fronteers jam session](https://fronteers.nl/congres/2014/jam-session). http://mennovanslooten.github.io/DummyJS P.S. The test above is not bogus. It actually runs successfully.
It's ... like... not pretty at all?.... it also looks like an app, not a website. Does being HTML5 make it okay to call it a website? Webapp might be more appropriately. 
I'm on iOS7, and it works so beautifully on mobile I was really amazed. Will test it on my Desktop soon!
&gt; .then(function() { done(); }); is the same as .then(done); you'd think so, but it's not, it changes the scope of things. Anyway, apparently Mocha is aware of promises, so these calls aren't needed at all! Win.
im sorry, it's not pretty. not by a long shot.
Looking good! Very interested in the project when it gets a bit more mature.
The animation when you focus the field is weird too. The blue blob that appears then slides to the left doesn't appear where you mouse clicks, which I thought was one of the key elements of material design.
&gt; I waited less than 3 seconds [That's cute](http://www.cedexis.com/blog/for-google-400ms-of-increased-page-load-time-results-in-044-lost-search-sessions/). And that's for a site (Google) that people are strongly motivated to use because they have a task in mind that it satisfies, and it's already proven its value to them over and over again. This is a random website with no information-scent whatsoever or even a title or strap-line before requiring you to log in. The page-title says "Quiz App" if you happen to notice it, but that's a piss-poor introduction to the site and what it offers before demanding you sign in. &gt; Thats what pinterest, facebook, twitter do Those are social networks. This is a random website I know nothing about. Also, [no you don't](https://en-gb.facebook.com/). You need to log in to get into the social part of the site, but there's plenty of content available (check the links in the footer) to demonstrate value *even aside from* Facebook's universally-known brand and implicit value for visitors. And hey look - Pinterest and Twitter do the same thing too. &gt; Numerous benefits too Such as? What benefit does an *entirely* client-side JS app deliver to audiences **in this instance** that couldn't equally be delivered - and better - by a progressively enhanced site? &gt; There are lots of ways to enhance "javascript websites" SEO That's not what I said - I said *this site* has spectacularly bad SEO. Also you *can* put lipstick on a pig[1], but that doesn't make it a supermodel, or even something you'd want to make out with. [1] Like reinventing a lame pseudo-REST with hash-bang URLs instead of [HiJAX](http://en.wikipedia.org/wiki/Hijax), or continually manually fixing up the back button with History.pushState(), or running an entire headless browser on the server simply to deliver the rendered HTML to spiders that *you should have been delivering to them as the foundation of the page in the first place*.
Also, lack of scroll bars. Browsers can already do scrolling pretty well.
I don't think I'd even say this is a website.
 .then(done.bind(null, null))
Hey, thanks for the input! I'm wondering, what are the features that I use that IE6 does not have? Is there a way I could modify the requestObjectFactory() function to be compatible with IE6 and below?
so .then(done.bind(this));
Wow, this looks great! Definitely interested. I'm watching it on github
dvidsilva has posted a deep link directly to a demo application which is built using Polymer and web components. Its purpose is simply to demonstrate the kinds of things which can be built using Polymer. **It is a toy.** It would have been better if dvidsilva added some text to explain what it is, but he/she didn't and now the chaos here on reddit is complete. These critiques of this "website" here in these threads are comically absurd in a kind of Monty Python way. It is not that the logic used is faulty or the that the points made are invalid. It is just that the starting point is completely wrong, because this is *not intended to be a polished website*. 
Thanks man, this seems like exactly the right direction. 
Thank you guys for your replies. I am downloading those books now and the CodeSchool's site looks like a perfect extension of codecademy and /u/kluenitou's analogy is a perfect description, a middle school education to codecademy's elementary. 
Thanks! I'm working on it pretty actively, but there is a lot of ground to cover. In a week or so I'll freeze the API and work towards a 1.0 release, including documentation, etc. In the meantime, feel free to check it out and file any issues you encounter. Feature requests are welcomed, too. I need real world usage data.
Honestly, that looks like complete crap. As others have said, it hijacks all native controls. It breaks the back button. Text looks like absolute shit (Chrome on win 7). Annoying animations which don't add to the user experience and are only for show.
You can try [Khan academy CS course](https://www.khanacademy.org/computing/cs) which teaches JS
Breaks the back button. Grrr.
Site is cool, questions are infuriating.
Is there something like this to visualise a single js file? Meaning dependency on individual variables, functions, objects etc?
If you search the sub, many of the books that get posted are available online.
They made massive improvements recently. Looks fine for me (Chrome 37.0.2062.103, Windows 7).
Ah, okay. I use the windows version of chrome only at work, and it's still an old version (30 or 31) due to corporate policy. Glad to hear that it's better now. 
I would suggest life.
Yeah, huge improvement and about time, too.
* Man I have met some weeaboos in my time, but you take the cake~
another thing is, when completing a quiz, it doesn't tell you what the correct answers are.
If your doing javascript you should definitely do HTML/CSS. It's where you put in your javascript.
It's probably faster to just check `arguments.length` instead of type checking. Works the same way.
ITT - People being negative. I think it looks nice, worked fine for me in IE11, FireFox and Chrome... 
Glad to see this continuing to gain popularity. Have been harassing our recruiting department to start using it and also harass their vendors to begin supporting it.
This would fail in this case: setAge(undefined); It is typically expected that explicitly passing undefined should be equivalent to not passing a parameter. This is typically more necessary when you want to use multiple optional parameters such as: function setBirth(day, month, year) { this.day = typeof day !== "undefined" ? day : 1; this.month = typeof month !== "undefined" ? month : 1; this.year = typeof year !== "undefined" ? year : 1900; } This would let me call: setBirth(undefined, undefined, 1974); Or pass any of the 3 I want to. If you were simply checking against arguments.length, this would fail as it is still 3 in this example.
Works for me just fine. Which browser you using?
lol you fuckin dicks it's just a demo, settle the fuck down. I think it's well done. Does it break the back button? Sure. Does it have a little wonkiness? You bet. Is it still a cool ass "demo"? Absolutely. 
Thank you. I have added a polyfill (right at the top of the module). I guess it should work in old IE now
And it's doing what a demo app is supposed to be doing.
Start with [this](http://docs.sencha.com/extjs/4.2.3/#!/api/Ext.Ajax) and then ask questions. Edit: wrong link
http://jsbooks.revolunet.com
Human Javascript
The author has apparently been living under a rock :) but this is one of the things driving the recent revival of interest in functional programming.
Firefox 31.0 running on x86_64 GNU/Linux (Fedora 20 Heisenbug)
I'm not familiar with the library you created, but here is how you do it with vanilla JS. http://jsfiddle.net/062bgcad/
gtfoh
Welcome to the wonderful world of business, where "borderline dishonest" happens 5000 times before lunch
&gt; Annoying loading screen Looks fine to me: http://i.imgur.com/L2wUFKm.png &gt;Requires javascript It's an application. &gt;Unnecessarily implemented as a client-side app instead of a progressively-enhanced website Dude, it's a game.
Flashy animations could be said to be part of what a demo app should be doing. I'm curious how breaking the back button, hijacking native controls and making text rendering look like shit is good for though.
&gt; I have never seen any test which jQuery beats native. Neither have I. But that's also not what I said. If you are supporting more than the latest browsers, than jQuery is essential. That's what I'm saying. I agree, if you are only using the latest browsers, it's ignorant to use jQuery and not the native methods. But if you happen to still use jQuery, the performance effect is not noticeable unless you are working with tens of thousands of queries and having them looped.
They were using Firefox with a blacklisted GPU/driver combination. Chrome stable uses DirectDraw.
https://github.com/codemix/fast.js
Thank you for the article, and I will definitely post it here when it is finished. It will probably take me another week or two though.
A demo of a new tech can do anything they want. If it doesn't work in your browser or on your system, it doesn't mean anything other than they didn't demo it properly for you. But it works for a lot of us.
I'm running Firefox 31 on FreeBSD10 64-bit and it works fine.
They are using Gherkin syntax http://docs.behat.org/en/latest/guides/1.gherkin.html for test construction which is a lot different than directly writing tests. BDD testing can have a huge upside as user stories are the direct deliverable being tested.
You're missing [the whole point of the debate](http://www.reddit.com/r/webdev/comments/16m3d0/is_progressive_enhancement_worth_it/c7xajws?context=3). The "mandatory JavaScript" debate is not about people who turn off JavaScript. It's about robust, fault-tolerant, accessible architecture and industry best practice evolved over the last twenty years, and the people who would ignorantly and arrogantly ignore it without even understanding the problem properly, let alone demonstrating their solution is comprehensively better. Here: [educate yourself](http://www.reddit.com/r/webdev/comments/29q5x1/im_an_ancient_php_developer_who_could_really_use/cinnl4m?context=3). Believe me - [I know about that of which I speak](http://www.reddit.com/r/webdev/comments/1xplrc/how_many_of_you_support_users_with_no_js/cfdkxg6).
... hold on, let me just resize my phone real quick.
yeah, fuck :P that's not helping making websites look nicer
does this solve distributing multiple environments amongst a team? It still seems like you need conf files. Do you need to preset env variables before you run node? How would you get this to work with something like PM2, which has it's own conf files?
yeah, totally didn't see that coming :/
Not compatible with chrome and a popup telling me so?
Wow thanks for saying this. I come from a Java background and I've looked at a lot of JS code that uses || for default logic. I didn't even know it was a hack! I thought it was idiomatic in JS to use it that way. Hindsight is 20/20 and it's easy to criticize, but would you say that it was a mistake for JS to consider these values to be falsy? I have experience with Clojure and it only considers `false` and `nil` to be falsy. It seems like a much better choice. 
Yeah, I'm not arguing against BDD. I'm mainly arguing that creating a new DSL for testing is unnecessary.
Why would anyone care about those benchmarks?
The lack of scroll bars was one of my favorite parts. They've laid out the content so that you can see everything that's relevant at any given time, so you don't need to move a viewport around it. And if your screen is too small to fit all of it, it *does* have scrollbars. (Admittedly, the feat would be much more impressive with real content.)
Pioneer is a stack of tools using both BDD and A "widgetized" view layer to DRY up your tests. You are right webdriver is verbose, and the hard part of using it is managing the ASYNC nature of integration tests. The Pioneer Stack helps to mitigate these problems while providing real value in tests that double as a user spec and documentation. I agree this is more "verbose" however it is maintainable and scalable. I would love to chat more about this http://gitter.im/mojotech/pioneer Come join us.
I think @acphilly's point was that people already know this DSL. The cucumber project is pretty widespread (http://cukes.info/).
I get that every time. And yeah, you're right. It's just one of those things you can't un-know: that because the spec chose to give a pattern you'll never use (`.bind` with `new`) the exact same syntax as a pattern you often use (`.bind` without `new`), many many parts of your code are paying an entirely unnecessary penalty.
On the top of my head: - facebook/oAth logins (I know in a step they must be handled via a webview) - collision detection of objects that I'll draw not using DOM or canvas. 
Haha. Well, you've got a point on the second part. But for the first, the "standard" part only gives it the meaning I said above. If you go more than one level deep, or if you start passing things around, "that" quickly becomes meaningless.
Very creative game!! I like!
Ah, that's a decent point.
I see. That is good too and handles visibility fine. I still prefer the flexibility to toggling classes based on animation length. To each his own, thank you for sharing that concept.
&gt; * facebook/oAth logins (I know in a step they must be handled via a webview) Have you looked into something like this? https://github.com/wuman/android-oauth-client It's not a new problem, I found quite a few other hits for "android oauth". &gt; * collision detection of objects that I'll draw not using DOM or canvas. Are you drawing them in JS or Java? Sorry, I'm not very experienced with Android dev, but it sounds like you may be using Android API's here, and if that's the case, you're probably going to be working in Java instead of JS to handle those concerns. You might also try /r/AndroidDev.
You are missing the whole point of the site. It's too demonstrate a technology, not web design or UX. And I hardly need any education from you.
&gt; .then(makeSureThatThereAreNoTodos) Is not something that makes sense to stakeholders. The Gherkin syntax lets you directly test user stories that make sense to non-devs. 
You could use fractions... http://larrybattle.github.io/Ratio.js/
The purpose of `parseInt` is to parse a string in an arbitrary base into an integer, and the purpose of `parseFloat` is to parse a string into a float. I don't think their purpose should be stated any less specifically, because that's what leads to people expecting `arrayOfStrings.map(parseInt)` to work. And I don't think either of those is precisely the same as "convert to a number".
Tons of libraries on npm are engine/environment agnostic. https://www.npmjs.org/
What are the pros? 
Back button being broken drives me crazy. Otherwise, great looking site.
&gt; It's too demonstrate a technology, not web design or UX. *That's* a valid point, certainly. Your counter-argument against criticisms of mandatory JS sites, not so much.
Keep in mind that this is not my opinion, but I believe the argument is that `function Class() { .. }` hoists `Class`, which can lead to issues if you're not familiar with how this works in JavaScript.
Ofcourse is a link bait.
I recommend learning some Python. its a very versatile language with a nice and clean syntax. Here's a good resource for continuing your learning: http://learnpythonthehardway.org/book/
I spent some hour to hack into latest using your article but couldnt do it believing that Im doing a mistake. Seems when you were cracking, there was no protection in place but they activated it again. Better place a note on your blog post so people wouldnt lost their minds.. And the embedded one.. I would appreciate any help on this. Details -&gt; http://jxcore.com/packaging-code-protection/
You're kind of proving his point. Sure, OOP can be nice if you do what you describe, but you have to adhere to the patterns of clear segregation between VO's and DTO/DAOs. With the functional programming, or 100 functions approach, you get that separation by default. Some have argued that taking SOLID priciples to their extremes, especially the Single Responsibility Principle, just leads to functional programming. Check this out: http://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/
I've grown less fond of worrying about every little goof ball who's so scared to death of javascript while visiting his warez and porn sites that he turns it off. Someone, somewhere with a high volume web site like Facebook found out that less than 2% of their visitors had js turned off. Then something like Yahoo said the same thing. My own little test showed no one had it turned off. While I do strive to make my client sites work without js (they don't to care either), I do know that there are people out there with cheap phones that just might visit a client sometime and I'd like to be able to say that I can fix that. But I'm almost at the point where I don't care anymore and I know I'm not alone by a lot of well-known developers.
As someone who has dealt with a few Rails projects that had Cucumber tests, I think you'll regret it. I've never had a single stakeholder ever once look at the cucumber tests. Not once. It really is just an extra layer of abstraction, another thing to go wrong, which adds zero benefit. It just slowed us down and added one more thing to make testing more difficult, which lead to fewer tests.
Ext has Ext.Ajax. Let me start by recognizing that. But Ext.Direct is probably a better way to go. They have direct front ends for many languages. Basically lets you expose a function from the server side on the client side. You stop thinking in terms of "ajax" and instead it's all just data again. Any specifics you can share?
Embrace their hatred. Use it to sustain yourself. And when the time comes... BEGIN THE RECKONING.
&gt; I used DOM to generate script tags with data URIs for the src attribute. Was there a reason you did data URIs versus just filling in the content of the SCRIPT tag?
You don't need to hardcode the length of the animation in the javascript. Instead of setTimeout, you can register to the transitionEnd event and change the display in that. Then you can have different classes for the animation lengths.
Looks like someone took these language constructs... ...for a loop.
Removed, /r/javascript is not a job board.
&gt;I've grown less fond of worrying about every little goof ball who's so scared to death of javascript... that he turns it off. You apparently still aren't getting it and I don't know how to make this any clearer, so I'll just say it over again. Criticising mandatory JavaScript is **not about people who disable JavaScript**. That's an ignorant and shallow misunderstanding of the whole issue, perpetuated by people who don't have a clue what they're taking about it what the real, important issues are. Rather, it's about developers ignoring proper, robust, accessible, optimisable architecture, violating separation of concerns and other basic principles of good design and obliviously waving away hard-won lessons and industry best-practice in areas they don't even adequately comprehend, let alone have understood fully and taken an educated decision to handle differently. I don't want to be a dick, but with respect, yes, you *do* need an education, because your perspective on this issue is about as shallow and uneducated as it's possible to get. It's like criticising abortion campaigners because "like, they aren't pro-life, and what kind of asshat *doesn't like life*? Duh!". Seriously, read even one of those links I posted, because when the discussion is whether you should make JS mandatory for rendering a website then repeatedly harping on about "people who turn off JS" is pretty much the same as posting "I don't have a damn clue what I'm taking about". :-(
Mobile Chrome
I tried to back out of it back to bacon reader on mobile chrome. No go.
Do you know where I can get JavaScript The Definitive Guide in a .pdf?
You mean for free? Not really.
now that you have mentioned it, i am thinking I will write a quick one for that as well so that all the querysrting values can be stored into a single array. thanks for letting me know!!!
Ohh I completely misinterpreted the comment, I thought he meant within the app. Yeah, backing out to a different website is broken here too (Chrome 37 OSX). Seems like something that should be easy to fix, though.
I'm sure your entire site doesn't just consist of one Ajax request. I'm saying that you could have a memory leak in another part of your front-end code.
I wish firefox ran regular JS as fast as asm.js instead of 4 times slower. Some projects that use the type enforcement model run much slower in regular js than in asm.js, I wish firefox would optimize those cases too, rather than something like add in SIMD for asm.js Large projects written natively in JavaScript can't normally be done in asm.js, which kinda pisses me off. I mean, asm.js code looks fugly and is meant as a compile target where it's hard to move around code and using the one heap model is ugly... See [A gameboy advance emulator coded in JavaScript, not ported..](https://github.com/grantgalitz/IodineGBA) / [demo here](http://jsemu.github.io/gba/launcher.html#pokemonemerald) / [another demo](http://jsemu.github.io/gba/launcher.html#supermarioadvance3) as an example of something mozilla should optimize for. That should run at 20% of one cpu core used on a core 2 duo from 2010, yet eats up a whole one. I'm more concerned about Typed Objects being a thing (big performance boost implication), as well as SharedArrayBuffers allowing more useful tight multi-threading with considerably less overhead than that of transferrables and copying between worker contexts.
http://codewars.com
I'm yet to see a C# app that could not be rewritten in Symbolic Machine Code with significantly fewer characters. Doesn't mean I'd want to write my app in Assembly Code. Character count / code length is not a direct indicator of development time/cost. One of the big benefits OOP claims is that writing in a manner similar to how one naturally thinks (entities with properties and behaviours) allows you to write faster and get your logic sorted out more easily.
http://www.javascriptenlightenment.com/
Closure's source is hosted on Google Code, and their docs are on developers.google.com. Moo tools is on GitHub, and I'm assuming a link to their docs are on their as well.
Nice logo.
You're getting away with the checklist comment because Polymer is exactly the sort of project that makes this kind of criticism legitimate. But you're posting in /r/javascript, and there's a school of thought experimenting with strong Javascript applications that looks at your grumpy condescension as simply out of touch. Sorry. It's not that simple. Your robust etc. architectures are not that wonderful. Around here, we're experimenting with different assumptions. That's not to say that you're not allowed to think the whole thing is absolute garbage, but we're not _actually_ required to care, and you're doing the opposite of preaching to the choir. I get that your applications are stuck worrying about SEO. In my opinion, SEO is a grey-hat activity at best that needs to be obsolete. (And Google crawls my no-html SPA site just fine.) Progressive enhancement is a crutch when we should be deploying applications intelligently based on device and use-case. This kind of development is what /r/javascript subscribers get paid to do. **We don't build websites.** icantthinkofone might not be presenting particularly good arguments, but your snarky checklist would have been downvoted to oblivion if you weren't picking on such an easy target in Polymer. No one here cares about people that turn Javascript off. We've moved on. 
It's more than a toy, it's a _prototype_, and it _is_ intended to demonstrate functionality; additionally, it's a pretty good example of how shiny animations can sway people. 
I agree. What would be high school or college then?
Shoptalkshow doesn't really talk about javascript. It is pretty CSS(SASS) heavy. 
Wait, you aren't learning HTML and CSS too? I don't get it.
Seconding this. I found it much better than most of the other books recommended. Javascript Spressore is also good. He writes very well and both books really expanded my understanding not only Javascript, but functional and object oriented programming in general.
thank you very much!
underscore extend has a similar feature where you can do object = _.extend(new someClass(),{x:10}); then in someClass you can just do this.x = 20 and that will be the default value until you combine the object with the second parameter of extend. I just started using that now instead of x = x || default, and the only time i use that is when initializing. But if you do that then you cant do this.x = 10 and then do draw(this.x) in the same object, you would have to create a new init function that would would call after the new defaults have been set.
Things about strings: Along with Number and Boolean, they're immutable (i.e. not passed by reference) For the most part, you can treat them like arrays, meaning you can access characters by index, and can thus use array methods like so Array.prototype.forEach.call("abcdefgh", function (char) { console.log( char ) }); 
Don't know if it was a co-incidence but my PC crashed whilst using it (Windows 8, Firefox)
&gt; Your robust etc. architectures are not that wonderful. Around here, we're experimenting with different assumptions. That's fine, but none of the javascript architectures we have so far have solved even the basic discoverability, addressability and accessibility issues that things like REST solve straight out of the box. Frankly it's doubtful they even *could* solve them as elegantly as HTML, because you're running into the fundamental difference between a declarative data-description language and an imperative programming language. Certainly they allow for richer, more responsive apps, but flash animations did that too - it's just that that's *all* they allowed for. Likewise, the current crop of client-side JS apps are fantastic for snappy, responsive client-side *applications*, but they're awful, awful architectures for presenting information in a way that it can be discovered, consumed, transformed and re-used. UI presentation is only one of a whole host of problems that REST, HTML and HTTP solve, and in many ways it's the most trivial. The web and web technologies didn't take off because they were *pretty* - they took off because they were butt-ugly (certainly compared to all the proprietary, graphical online services available at the time) but *accessible and well-engineered*. the metaphor of networked resources that could be interacted with using a simple, specific set of verbs, returning content in a number of different content-types negotiated between the browser and client, but *without the server or client having to know anything about each other of their capabilities* is what made it powerful, flexible, successful and future-proof. Using javascript to play into that existing design (eg, by layering it over HTML and progressively enhancing pages) is a great use of it. Using javascript to try to *replace* (or worse, half-assedly re-invent) chunks of that existing functionality is not only pointless - it's actively wrongheaded and counter-productive - akin to when people discovered the problems with Flash websites (no history, broken back button, terrible SEO, etc) and set about fixing them by - essentially - *re-implementing half of HTML and the browser in their flash apps* instead of simply facing the fact they'd chosen fundamentally the wrong technology for their use-case. When people run into accessibility and SEO problems with JS apps and resort to hash-bang URLs, running entire headless browsers on their server to serve HTML to Google and similar ~~abominations~~ inelegant hacks... well, the stench of "unexamined bad decisions" is practically identical. There's certainly a place for client-side JS apps (eg, anywhere where you aren't primarily "presenting information" but are rather "providing user controls" for a complex system), but that doesn't mean that *many* (perhaps even most) of the sites being implemented as client-side JS apps these days are not doing the architectural equivalent of throwing out HTML and CSS in order to build "rich", "responsive", "experimental" flash websites that don't rely on the "crutch" of HTML and progressive enhancement. &gt;&gt; Criticising mandatory JavaScript is **not about people who disable JavaScript**. &gt; No one here cares about people that turn Javascript off. With respect, this is exactly the kind of clueless blinkered attitude I was pointing out. You can explain until you're blue in the face that X is not about Y (and how and what X is about, and how only people who don't know anything about X get it confused with Y)... only for people to flatly ignore it and respond with "yeah, but who cares about Y?". Seriously. How is that a remotely intelligent response?
I have seen a few javascript apps written as a total clusterfuck of things inheriting from things inheriting from things calling other things inheriting from yet other things with little bits of state stuck in each of them for the sake of maintainability and scalability. They achieved the exact opposite. All you usually need to do with JavaScript is pull data from API, plug it into DOM and then possibly read the changes and send them back to the API. I have no idea why people think it should be done by some kind of massive architectural circlejerk just because they invented it and try to sell it as The Right Way. Once you get over a certain codebase size threshold, code structures which try hard to act like natural entities and their dependencies can not be fully comprehended anyways and become a burden. The way I naturally think is cutting with Occams razor a lot to avoid introducing needless complexity.
I do that automatically using GreaseMonkey. At my current job we have an admin where we can write/paste code but I prefer working in Sublime Text, so I wrote a GreaseMonkey script that loads my HTML, CSS and JS from different folders in localhost (depending on the domain I am on).
Well, I suppose I did misspeak then. No one here cares about criticism of mandatory Javascript. You can repeat yourself until you're blue in the face, but you are wasting your time. I wasn't airily waving away your point by saying no one cares about NoScript folks, I was airily waving away your point by saying **you're not stating anything interesting**. You're not _wrong_ that JS architectures haven't (yet) solved a lot of problems solved by traditional architectures, but traditional architectures don't offer what we want. **We know there are problems**. We're going to try solve them with Javascript, which means Javascript is mandatory. Criticizing mandatory Javascript here is a waste of time, if not a 'clueless blinkered approach.' If you think Javascript can't solve them, then why are you here? What are you hoping to accomplish? We've already decided to write strong client-side applications, that horse is out of the barn. You don't seem to disagree that client-side applications are an opportunity. All you're doing is _endlessly_ restating the fact that client-side applications need to provide the same robustness as traditional websites--wow, what an insight--but you're doing it in a way contradictory to the purpose of our exploration. ...Now, I wish I could claim that everyone already understood that we need to maintain that standard, but we have a lot of really terrible solutions (like Polymer). That doesn't mean all of us are ignoring accessibility, forgetting that anchor tags explicitly define URL navigation, or blindly moving away from SEO. 
Ok wow, you edited in at least three paragraphs while I was writing my response. Edit: Fortunately you don't seem to have added anything I need to address. It makes for a decent lecture I guess (and it's clearly a favorite topic of yours), but you're not adding new information. (For what it's worth, I always thought headless browsers for SEO were an obviously terrible idea.) 
Seems like a nice start. However, I think it would be much more useful if you could turn each row of the table into separate objects. For example, the first table on that page would yield an array of objects like this: { "PLAYER": "1. Matt Ryan, QB", "TEAM": "ATL", "RESULT": "W 37-34 vs. NO", "COMP": 31, "ATT": 43, "YDS": 448, "TD": 3, "INT": 0, "SACK": 1, "FUM": 0, "RAT": 128.8 } Such a format would be much more usable, as it would not require a special function to read attributes.
3 - Within the body of a &lt;script&gt; tag, linked from the src attribute of a &lt;script&gt; tag, and as an event handler attribute on a tag
I don't hardcode the animation time. I get it from the CSS properties (delay+animation length) -- I'll look into transitionEnd. Your solution is good, it just doesn't work for all cases where being specific in CSS would. I don't necessarily want to toggle the display property when animating something with intro and outro classes. This is what causes a bit of a problem for me in accepting your solution and applying it to all cases.
Thanks! I definitely have that in the front of my mind. The only problem I need to solve for is accounting for `colspan`s on `&lt;td&gt;` elements that cause the lengths to mismatch.
It's safe to say I was handling time the hard way, :-)
I'm the author. If anyone would be kind enough to have a quick check and review the crypto part (usage of CryptoJS's pbkdf2), that would of course be awesome! Btw, I didn't find an existing implementation of such a utility that works in the browser but if you know one, I'm interrested too.
The first one sounds like the first one I got, the logic bug was that 'name' was in quotes rather than using the variable passed in to the function. So the output would always be 'Hello, name' rather than 'Hello, andyburke'
I got through about 4 of them. Neat idea, needs different difficulty scales though. I havent actually signed up.
I like the concept. I feel like it should allow you to keep working, even when the time is up. You may not get points, but it is still useful to find the problem so that you recognize it in the future.
If you don't mind a little flicker then you can inject a window.load script and apply your text after the page is done loading. 
These are *math problems* not debugging. For this to be debugging, it needs to show the input, the expected output, and the actual output - even if that's an error.
Yeah, not being able to run the code is a huge issue in itself.
I guess not, how could make it to load exactly on the right place without affecting the structure ?
&gt; The website-app may take a couple of seconds to load at the first time, but then it's butter smooth and lightning fast to the user because only the necessary data are loaded. This demo didn't really back up the performance point for me, but I'll take your word for it. &gt; In a classic web... Yes, I understand client-side web-apps and XHR. What in particular makes Web Components / Polymer better for me as an end user? That's also the first time I've seen a web browser described as intelligent :-)
Absolutely, not enough time is given to actually understand the expected functionality. 60s is barely enough time to read and fully comprehend the problem description, let alone debug the provided code. Also, it should be counting up, rather than giving a hard time limit, and you should get points based on how quickly you do it.
You should end the promise -chain (or just a single promise) always with a .done(), so that unhandled rejections will be thrown instead of disappearing.
What is *one of your decision*, exactly? Perhaps you've taken the wrong approach to get what you want? Why did you not apply the changes at server side? Why did you not use AJAX to replace the contents of current page, instead of loading another page?
If this is for a website wouldn't that make it vulnerable to XSS (Cross Site Scripting)?
Exactly. 
Someone showed me this: http://npm.anvaka.com/#/view/2d/sails - haven't seen anything larger yet..
There 5, actually. `4`. HTTP Refresh `META` tag's `content` attribute, via `javascript` protocol. &lt;meta http-equiv="refresh" content="0; url=javascript:(function(){alert('woot!')})()" /&gt; `5`. `IFRAME` tag's `src` attribute, via `javascript` protocol. But this one is isolated. &lt;iframe src="javascript:(function(){alert('ran on '+location.href)})()"&gt;&lt;/iframe&gt;
1. Are you sure you mean document.body? You probably mean to select particular element within body and change it, no? 2. If you want to avoid the flicker, here's what you do: Create a div id="loadingOverlay." Set it's CSS to position absolute, and make it massive and white. Then you delete this div *after* you've changed the text via innerHTML. I recommend wrapping all of this in a window.onload.
Interesting site, but it would really help if you could view the correct answers.
It should count *up* not down, probably. And then have an average or par probably, which is used to determine the score.
I would recommend emberJS instead of angular. EmberJS syntax is similar to backbone, so picking it up shouldn't be too hard (the principles are similar, but ember solves most of backbone's issues). Ember docs are much better than Angulars and Ember seems to scale better for large applications in my experience. Finally, Angular 2.0 completely changes angular, so why spend the time learning and designing for something that's going to be obsolete? http://emberjs.com/ edit: for learning angular, ng-book is the best resource I've found. https://www.ng-book.com/
I would love to learn Ember too (and I may well do in my spare time), but my new company use Angular primarily, so I am looking to get up to speed with that first!
What's a web application that you think is beautiful? 
Angular 2.0 won't be a complete change, migration from 1.* to 2 is planned to be very simple. Ember is a confusing mix of magic bullshit. Op, if you're planning on learning Angular I recommend the framework. I inherited an angular app built by a backbone Dev. I've not done backbone dev personally but looking through he relied heavily on pub sub with root scope, my understanding is that backbone involves a lot of pubsub design, avoid this in angular. I personally dislike pub sub, the Angular way is to put logic in services and factories. They should hold any logic that doesn't correspond directly to a view model property. Your controllers should be built as view models, they only hold data that is being displayed or interacted with. Angular didn't have a model concept but you can create similar entities with services. 
I've heard good things about this free CodeSchool course that was created by Google: https://www.codeschool.com/courses/shaping-up-with-angular-js After that, come subscribe to /r/angularjs, people are sharing good tutorials and libraries daily
All you need is a simple filter function, or you could just manually loop over the array. var filteredPeople = people.filter(function(element) { return peopleToRemove.indexOf(element) === -1; });
It is not debugging if I can't use my debugger. Also I got one that looked something like: ``` function(first, last) { var name = first; name += first + ' ' + last; return name; } ``` I changed it to: ``` function(first, last) { var name = first + ' ' + last; return name ``` but it wouldn't accept it because the number of lines changed... since when is that a requirement of debugging something?
You're kidding, right? His JOB uses angular, so he must learn ANGULAR.
Do you need to match case or do you want it to be case sensitive?
js-object-graph is a tiny program for exploring the webbrowser's object graph. There are a couple of usability issues I'd like to get sorted out so I was hoping for some tips maybe. I use the [js-springy](http://getspringy.com/) for graph layout but having problem with overlapping child nodes when I expand a node. I'd like to have a bounding rectangle that they're pushed outside. Any tips or suggestions appreciated. The code can be viewed [here](https://bitbucket.org/trondolsen/js-object-graph/src).
Removed as spam, please see http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). This is your only warning, next time you and your site will be banned.
&gt; confusing mix of magic bullshit Because $scope and the $digest cycle are so very straightforward 
&gt; Ember is a confusing mix of magic bullshit. How is Angular not even more magical than Ember? $injector, $digest, $scope are all much more magical in my experience (my current job uses angular, but the company has been looking seriously into changing to ember because angular becomes difficult at scale ,is very hard to extend, and bugs involving the "magical" parts are very time consuming to debug) changes in Angular 2.0: dirty checking becoming Object.observable(), replacing their injection system to one more like require or commonjs, changing the directive creation API, etc These are hardly simple, non-breaking changes. They may not matter for trivial applications, but for larger applications they represent a lot of man-hours.
Oh, I thought you just wanted to change the text. Did not know you wanted to change the DOM structure as well. Like you said, if you want to change the structure then the DOM structure will be changed. Are you referring to change of the layout of the page when you mean "affecting the structure"? Also, I'm hoping this is just for POC cause if this is your final solution then as /u/jcunews1 said, you might be taking a wrong approach. Also, to load it in the right place you would something like this. Let's say you have the following in your current page:- &lt;div class="parent-class"&gt; &lt;article&gt; &lt;p&gt;Lorem ipsum something&lt;/p&gt; &lt;footer&gt; &lt;sup&gt;Lorem&lt;/sup&gt; &lt;/footer&gt; &lt;/article&gt; &lt;/div&gt; And say you want to change the `&lt;sup&gt;` to `&lt;sub&gt;` and italicized. (function(){ window.onload = function(){ var parentNode = document.querySelector(".parent-class article footer"); parentNode.innerHTML = "&lt;sub&gt;&lt;em&gt;Lorem&lt;/em&gt;&lt;/sub&gt;"; }; }()); I hope this is what you're going after. 
Angular is very magical but I have never had to read its source code to debug a problem. I don't know anything about ember.
If you're doing Node dev, I highly recommend this plugin: https://github.com/moll/vim-node Also, if you like plugins, you might want a plugin to manage your plugins. There are two options: Vundle and Pathogen. Vundle is better IMO because it can install/restore plugins from GitHub: https://github.com/gmarik/Vundle.vim There are also lots more useful Node plugins: https://github.com/joyent/node/wiki/Vim-Plugins
Perfect. Thank you.
https://thinkster.io/angulartutorial/mean-stack-tutorial/ https://thinkster.io/angulartutorial/a-better-way-to-learn-angularjs/ These guys have a systematic aggregation of material to cover concepts. 
In order to use Ember you have to already know Ember. You have to understand which things it will do for you and how. The learning curve is massive. The resources suck because they made multiple major API breaks, if you don't understand something good luck googling it. 
That is an interesting challenge, but I think that it is also an edge case that you need to consider separately. For strictly tabular data, you can count on the table having a 1:1 ratio of fields to columns. For fields spanning multiple columns, you might try to insert it into your objects as the container for its child columns, but the true intention of multi-column fields can vary, so you have to be careful. For example, if a multi-column field appears at the top of the table, it is probably a categorization for the columns it encompasses. If it appears at the bottom, it is probably a total. If it appears in the middle? Your guess is as good as mine. That being said, I think you can ignore multi-column data for the first pass. [Here is a rough demonstration](https://gist.github.com/huttj/18860def9bf57f64af8c) that produces the sort of output /u/frankle described. If you paste that in the console of [the page you got your data from](http://scores.espn.go.com/nfl/weekly/leaders?year=2014&amp;seasontype=2&amp;week=1&amp;type=all), it will generate objects for the rows in the ~~first~~ second table, like so: { "AVG": "134", "CAR": "W 33-20 vs. NE", "FUM": "15", "LNG": "1", "PLAYER": "KnowshonMoreno", "RESULT": "MIA", "TD": "5.6", "TEAM": "1. Knowshon Moreno, RB", "YDS": "24" } **Edit:** I just noticed that the first column containing the picture throws the results off. I will go back and add a calculation to put those both into a single property. Stay tuned!
It's a bit dated now, but I wrote a post a while ago on [how I use Vim for my day to day JavaScript development](http://oli.me.uk/2013/06/29/equipping-vim-for-javascript/). Alternatively, steal anything you like from [my dotfiles](https://github.com/Wolfy87/dotfiles).
+1, though I'd recommend the firebase tutorial vs the mean stack one. Messing with express, mongoose, jade etc... is just a hassle if you aren't going to be using them later
1. 3 2. 9 3. I would give a candidate 1 hour 4. Not at all 5. If you are looking for a junior level candidate, maybe, but for something that is “UI-heavy,” I would want to see more freedom (e.g., let them edit the CSS, see if they make improvements anywhere—ask them to defend their choices), more involvement on events (click/toggling is pretty basic), and probably some asynchronous logic as well. 
Note: I don't work there, that was just the title of the blog post.
+1 for egghead.io their free angular videos were just what I needed to get started.
Pretty close to my thoughts as well. You give them a little too much with the template, the css, and jQuery. I'd almost not tell them what to use, but say something like 'you may choose to use external libraries', as this can be done almost as easily without jQuery. Give them a bit more freedom. It'll help you learn more about their process.
are these types of bugs even a problem? i was going into it expecting typos and was thinking "that isn't something that can be timed because it is so dependent on style/naming" and came out thinking that it wasn't as bad as I thought it would be.
Those two posts have several words in common, but this is the opposite question.
I created a different jsperf. Seems I was wrong, at least when using Javascript. Looks like the object creation has a lot more overhead than I previously thought... http://jsperf.com/test-indexof-vs-hash
Nope. Read the title again. He is my arch enemy.
You're locking into their way of doing things in an absolute manner. There is no wiggle room. It's great if you have no idea what you're doing I guess. I like being able to define my own style guide for my team personally. 
Nice one. You should x/post this to /r/cellular_automata :)
[grumble grumble]
I'm sorry that's not what i meant but I can see how that would seem. I wasn't saying ember devs don't know what they are doing. I meant that one of the criticisms of angular is the lack of forced conventions but if you maintain your own conventions that isn't a downfall but a strength. 
arch enemy, lol
There was a terribly complex "max of three numbers" function that I rewrote to `return Math.max(a, b, c);`. The trick is to not delete the dead code that follows so the number of lines stays constant. I closed the page after that problem.
I'm sure it must break some mortal sin of web development to put a timer on your website that says "lol too slow; go away now". 
Oh, thanks for the sub
I don't know if I would phrase it as "no idea what you're doing", but I get what you're after. Angular is a bit more open ended in comparison to Ember. Less functionality is baked into Angular giving you a bit more freedom to build out your own architecture. However, this flexibility is a double edged sword because it's pretty easy to get carried away organizing / refactoring your code into a perfect ecosystem. I would argue that this is bound to happen to everyone though and that it doesn't matter whether you know what you're doing or not. They are both great frameworks with their own pros, cons, and "magic", but I personally prefer Angular because I like working with vanilla HTML
Sorry, I can see how what I said might be interpreted that way. Angular's lack of forced conventions is touted as a failure, if you define your own conventions though it can be a strength. I didn't mean that Ember devs have no idea what they are doing, I meant if you don't know how to maintain your own conventions Embers forced way of doing it is beneficial. 
Ohhhh my god fuck this thing
You might be interested in http://perfectionkills.com/refactoring-single-page-app/
not deleting the dead code? I wouldn't accept that pull request.
Well, this is essentially Lodash/Underscore's _.difference method. Looking at Lodash's code, their implementation seems to be pretty good, so I'd try and use theirs. There are some caveats, though: for example, if we know the second array to be smaller than the first one, which is a pretty likely case (say, I want to remove these three objects from this array of thousands of objects) this would probably provide better performance: function difference(first, second) { for (var i=0; i&lt;second.length; i++) { var index = undefined; while ((index = first.indexOf(second[i])) !== -1) { first.splice(index, 1); } } return first; } If you know that your elements on `people` and `peopleToRemove` are only meant to appear once, you should definitely use ES6 sets; of course, if Lodash is out of the question, I assume ES6 sets are as well.
Are you not updating the values inside of Angular?
This is a war you can never outright win, so you need to decide how much you want to invest. Look at what multiplayer games do for copy protection and you'll see what I mean. My advice would be to put rate limiting on your APIs to reduce abuse and add a rudimentary hash of the request params + a secret key embedded in your obfuscated JS source. That way it requires someone to actually interpret what's going on in the JS which is a nontrivial cost.
1. 5 for me, but then again, I'm a non javascript developer. 2. 10 3. Took me 2 hours 4. No 5. You will weed out the people who don't know what they're doing. I'm new to js/jquery (from C#). It took me about two hours to do, with a lot of reading up as I went along. I think 1 hour is probably a good time limit to give someone who's applying for the job.
Thus why... &gt; I closed the page after that problem.
yeoman has 294 nodes: http://npm.anvaka.com/#/view/2d/yeoman
Use an api key
Cool! I did one as well when I started playing around with Canvases: http://srolfe.github.io/GameOfLife.js/ ([Source](https://github.com/srolfe/GameOfLife.js)) Was a fun and still incomplete project. Might have some feature-creep going on haha.
If your client code is visible than I think there's pretty much nothing you can do apart from detecting unusual behavior and then blocking those IPs and dropping connections. You can implement the usual things like referrer checking though. But what you can do is forbid the use of your API with anything but your client in the ToS / CLA. And if you find somebody use your API without permission you can maybe claim damages or so. 
Don't know why some people expect that we write javascript like it was C, and i hate to see questions that mention some kind of tool beyond the language itself, just leave them out, they just contaminate the flow.
1. 3 2. 9 3. Depends on skill level you're interviewing. Anywhere from a half hour to 2. 4. Generally, no. I do have a problem with your instructions being restricted to only editing the js file. Personally I'd change the markup to include forms. 5. Only for the most junior. It barely tests jQuery basics and maybe data structures. You're looking at event listeners, selectors and kind of sort of templates though not really since the markup is not to be modified. No AJAX. No use of plugins or external scripts. You do allow for knockout though so I suppose there's some room. Overall I think the instructions are restrictive and the scope insufficient to do anything more than a cursory analysis. Then again I prefer small scope paid projects that occupy perhaps an afternoon and I'm not much for the traditional interviewing methods.
Unfortunately, if he's using an AngularJS client himself, then using an API key won't help him.
All of those things can easily be spoofed.
I use vim with vundle to manage plugins, and YouCompleteMe for auto-completion. My .vimrc is basically [this guy's](http://amix.dk/vim/vimrc.html), but with subtle changes I've made over time; most of which I will never recall having made. None of that is really JS-specific, but then I'm not sure that I really need any extra plugins just for JS. Maybe it's one of those situations where I don't know what I'm missing until I try it. *shrug*
The tooling question is specific to my company. I explicitly mention that as well in the explanation section. What makes you think this JS is written like C? They're just bite-sized functions.
How is it a game of life if we have to set up the initial conditions?
This is awesome!
I get the obfuscation in your example aims to prove coherence by the interviewee but if one of my developers ever wrote something like that there would be issues... :)
Nothing is going to be 100% though, and OP recognizes that.
OP said 'annoying'. You want difficult to spoof? Do what I do and implement client certificates, using a server certificate signed by a trusted root CA.
You should add a [glider](http://en.wikipedia.org/wiki/Glider_(Conway's_Life\)) to defaults: .#. ..# ### Also the speed slider is a little confusing. Intuitively I think "to the right" means faster, but more importantly adjusting the slider while the simulation is running requires you to press stop and then start again.
So kool
Data structures and algorithms are languages agnostic. You can learn the theory and then write an implementation in JS. 
I imagine he is referring to that GCD snippet. Here is my rules on this: don't ask mathematical questions unless the job requires it. This isn't because finding GCD is a complex mathematical formula, but because you've taken a well known process with well know (and gorgeous) recursive algorithm, that everyone you are interviewing probably implemented in 2 different languages in college and done it in this super imperative method, with really poorly named variables (which I understand would possibly give away the algorithm, this is another good indicator of the problem) and people will look at that code (especially js developers and think... What?). None of these mention map, reduce, for each, closures on any important level, callbacks, etc which are things that do separate it from c. My advice is to do something you have to do all the time: take this json output from an api we don't have control over and map it to do the data model we need for a given business case. Let them use lodash/underscore. This gives them rope to hang themselves with if they don't know what they are doing but opens the door for discussions about things like composability and more functional concepts which I'd think are pretty important for a Javascript position. All the other questions were pretty good imo. Nothing wrong with asking about grunt as its probably not the deciding factor and can lead to a discussion of the different tools the candidate does use. 
I got one, inputs was two arrays in the format [hh, mm] determine which one is sooner.... this isn't a debugging problem, it's an architectural one. If I seriously have a need for a function that needs to compute this, I've got bigger problems -- screwy data structures. 
To learn the theory I would need to also learn the language that the resource is using to teach it. Wouldn't I? Or are there resources that teach strictly theory without using a language?
Nothing sensitive or even that valuable. I don't want someone using my API to copy my database. I want to add safe guards that would waste 12-24 hours of a very smart person's time.
Lost immediate interest when I realized it wasn't runnable. 
Ok, this is pretty goddamn fun and something I can actually use to challenge my developers to break out of typical fare when they've got some downtime.
You probably can't get 12-24 hours. Maybe an hour or two at most. You can add a checksum calculated by your client side JS, and checked by the server. Someone trying to use the API without reading the source will not realize to change the checksum. You can also XOR the sent data to obscure it a bit. The client side API will XOR the data with a key, and the server undoes it (this is not encryption BTW). (Don't just XOR the data - XOR the structure of how the data is sent, include field delimiters.) Something trying to use the API will have to first un-xor the data before knowing your data format. None of this will take them long - after all it's right in the client source, but it'll slow them down. Of course they could just use the functions in your client source directly..... Edit: For extra sneakiness if the checksum is wrong still return the data, but log the IP. After a small number of requests start returning incorrect data. They will check only the first few requests, everything seems fine and let it run - only to find out later it was all garbage. 
1. 4 2. 10 3. 40-90 min depending on if you want production ready code. Getting it to work and meet requirements is one thing. Making it robust and easy to read adds time. 4. No, and you don't want to hire someone who would be. 5. It is useful for identifying if someone writes in this style. Unfortunately, the test is too restrictive and opinionated to get a feel for how someone might choose to write. I prefer using some kind of observable, for instance, instead of crawling through the DOM. 
I love your evil API idea! You are right, I don't think I could keep someone like me out of any public API for more than 12 hours no matter how shitty the code. Just for giggles I could client side encrypt the post body and require the client to decrypt the response based on the phase of the moon. I am sure I could figure out a way to require a hidden Iframe to make it extra spicy. I will probably just hash the request body and send it in the header. Most of you could bypass that in less than an hour. However most of you wouldn't bother hacking my public API.
Yeah, I think your best bet is going to be the non-technical option (as /u/kuenx suggests), however... it may be hard/impossible to enforce depending on the type of data and the location of the other party. Applying every technical answer here will buy you several hours (optimistically speaking) versus a skilled developer, but might take you 100+ hours to implement. The effect it would have on your architecture and the increased maintenance would require a very compelling reason before I'd even attempt it.