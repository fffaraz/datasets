You're just shit slinging at this point. We get it; you don't like it.
Every time I come back to the semi-regular thought of "I should learn more JavaScript", such as I apparently have today, I always get stuck on this... At least it does re-kindle my appreciation for more concise languages.
At this point i am starting to think it would be better for node to pull the emergency brake and avoid the module spec all together. Or break it, like Babel does. It is crazy to think a consortium has went on deciding this while ignoring the living standard in node and large parts of the modern web.
 &gt; new URL('https://example.com/path/file?query#hash').origin "https://example.com"
People seem to be missing one of the biggest issues, IMO, which is that ES modules can't be required by CommonJS modules. This is very bad. I can provide a way to write a wrapper that will do it right here. pseudocode: uuid = generateUUID(); code = ` import * as module from '${pathToImport}'; require._standardInteropSetModule('${uuid}', module); `; vm.executeInThisContext(code); module.exports = require._standardInteropGetModule(uuid); All this requires is that import statements are processed synchronously at least in this case, which seems to be just fine when considering the spec. If it can't be done, please tell me why.
Sup dudes! Yesterday, I finally released my first npm package ever! It's called jazzer - because it adds visual smooth jazz to your site. ^Heh. Meaning it allows you to use pretty transitions when switching between pages of your site. I'd really love some feedback about this, as I think it's quite cool, but surely has a lot of room for improvement. https://robinloeffel.ch/jazzer / https://github.com/rbnlffl/jazzer
As I mention in my other post, the WHATWG shoots first and asks questions later. They are impatient children who don't want to wait for the science behind the technology, things the W3C did care greatly about, and just plowed ahead without thinking. This is how you wind up with abandoned standards and things that just don't work.
A tab area for instance is very unnatural with a virtual DOM. You end up redrawing the entire content when switching tabs, and you lose all DOM data (filled in forms, etc) unless you manually save it. By working with the DOM directly, it was easy for me to implement a tab area switcher that just swaps a DOM node for another. This can allow the browser to cache computed styling for instance, and components also preserve their state easily.
Oh, sorry. Yes this makes definitely sense. I will change that to /random to / (root) to avoid that! Thank you for your feedback /u/odisant &amp; /u/Maklite *Edit* New version is online with this change :)
just so long as lpad works!
That's already possible, case in point: Webpack. There's also the new spec for import(), which is async and it can be completely dynamic. 
It would be nice if Apple's iOS allowed real 3rd party browsers.
I didn't say you can't do it with a vdom, it just makes things unnecessarily complicated. For instance, in the Switcher primitive class (the only with a dynamic child) I only keep a weak map to past nodes, so that if there are no references to a removed child it can be garbage collected. Do you pass a special field to tell the vdom that you want this behavior? The more complicated you want your functionality to be, the more options you have to add to your virtual DOM library, and the harder it becomes for developers to understand what's going on. Edit: I saw the include/exclude options just now, it just seems needlessly complicated.
Don't give a shit about browsers. I'll bundle it up for the browser if need be. Give me synchronous imports.
your primary arguments are for speed and ergonomics. i can tell you that your argument for speed is throughly invalid, so let's just leave that aside. for ergonomics, there are plenty of good vdom options, plus excellent thin libs like https://redom.js.org/ if you want to work directly with dom elements and still have a light js structure. i'm the last guy who will try to shit on a new dom lib, but for you to come into an already crowded space with plenty of high quality options and say everyone does it wrong invites this type of feedback.
How do the svgs even open? Does Windows associate it with image viewer?
By default, it's opened in IE, even I'd default browser is something else. For some reason, GIFs are also opened in IE by default.
Thanks for the story with the polyfill bug, that's a major point for me: In the long rung you inevitably end up messing around in your library's code, just because it doesn't offer the exact functionality you need. When that happens, it actually matters that the library is kept simple and understandable when digging into it. No framework can ever cover all possible use-cases purely through their API, so in that case it's a design feature to allow easy modifications to the behavior of certain components.
Well then Microsoft is to blame, SVGs are not a common image format (most users deal with pictures) so it shouldn't be associated by default to anything
[removed]
I am working with Node two years in a row while working in another projects with PHP. I have some opinions about your questions, but I am not 100% sure about them: 1. Node allows clustering, so you can create workers, one for each core. If your app is state-less you can take advance of all the cpu. 2. Callback hell is something from years ago. The promises almost solved the callback hell, and now with ES6 generators and even more with ES7 async/await I think is completely solved. 3. I don't have enought knowledge to talk about scalability, I have never done an app so big. 4. In my opinion Node is cool because allows me develop very fast. Thanks to all of his frameworks and libraries and thanks to his high level of abstraction. Some times I encountered that my coworkers working with PHP or Java that some problem I can solve in one line of Node (also thanks of the ES6 arrow functions) costs lots and lots of lines and its more complex. This is only my opinion, I can be wrong. I love Node and I think some applications (like an API REST) benefits of it.
What are these dudes DOING?! Jeez horrible. 
&gt; Or break it, like Babel does. That right there. Babel made the right choice by favoring practical usefulness over spec compliance. I think Node.js should do the same. If everyone is on board with the way Babel does it, the spec will actually follow (just like plenty web standards have standardized the way things were already being done rather than dictating how things *should* be done).
This is so damn frustrating. Why should there be a compatible transition from the older CommonJS way to the ES6 way? Why can't both forms be available as different means of module systems even if the ES6 way is highly disruptive? Its not like there is any collision of names or grammar. There isn't. &gt; But it works in Babel! Fuck Babel. It's non-standard. If this is really a hick-up for the Node folks they are going about this entirely the wrong way. Stop worrying about big tears and just get the solution out there. Developers will adapt and figure it out. 
&gt; Moreover, how often do you see todoList.map(concatTime).filter(...).sort() and the like Typically that is still I/O bound considering where the data comes from, and typically the dataset is so tiny that it doesn't really matter anyway, but I see your point. Personally, for React and specially views, I swallow the performance cost and go for maintainability, since there are usually other things that can give you much better perf gains elsewhere. When implementing a virtual dom engine though, loops are the name of the game (I should know, I've written two). For me, the criteria is how generic the code is. If I'm implementing something super generic like `map`, then of course implementing it in terms of foldr (in js) is crazy, but if it's a specific and complex composition that is inherently local and single-purpose like some front-and-center-of-screen React component, then it typically pays to use FP style.
Webpack can (will be able to) only do tree-shaking when used with `import` though.
In the fewest possible works a closure is present when: *A reference is read or assigned in a scope where it is not declared.* To be more blunt: *When you cross a scope boundary to resolve a reference.*
Your approach sounds great if you live in a vacuum. Meanwhile people that have invested in existing solutions will ignore you rather than adapt, and if you're not careful you got a Python 3 vs 2 situation on your hand.
I don't quite understand why he dismisses the package.json solution so easily. There's probably been more deliberation than he lets on in the post, but beside mentioning performance there's not much explanation. But I'd say it's acceptable if ES6 modules and CommonJS cannot be mixed *within a single package* as long as they can be mixed across NPM packages. That way the module setting specified in the package.json that already needs to be parsed can be used as global setting for the entire package. It would obviate the need for custom extensions and maybe even avoid a lot of confusion that would ensue when ES6 and CommonJS is mixed too freely (for one thing, circular references become a lot less likely when it's across packages). For the remaining hurdles I'd say follow Babel: Don't feel too bad breaking the spec a bit if it results in a better developer experience for Node.js developers.
&gt; Babel made the right choice by favoring practical usefulness over spec compliance. Microsoft did the same thing with their IE6 implementation of the CSS box model and it did nothing but cause problems that we're still feeling 15+ years later. For a few years it was good, until a better competitor came out and suddenly we had to write conditional CSS.
Okay so I didn't know what Vagrant is and I googled it and I'm still not sure exactly what it is. Seems pretty complicated to me, but what exactly am I doing? Using the windows command line to feed commands into the VM I'm using?
From all the examples you could have picked it's this one? https://www.jefftk.com/p/the-revenge-of-the-ie-box-model Most css-reset libs these days set the dom to Microsofts box model by default. It's entirely ratified, many have spoken out in favour of it calling the previous model the mistake as it was highly problematic. If anything it shows that letting a committee that is entirely disconnected from the real world decide freely is questionable and at times opposing it has been for the better.
The fact we're still experiencing those problems 15+ years later had more to do with the fact that MS left IE to stagnate than it had to do with specific technological choices made in IE6. Now don't get me wrong, I think IE6 was an abomination, but I don't think that situation was very comparable to what we're seeing here. In the end I think the module spec will be better off if it gets adopted to properly account for Node.js' use cases rather than raising the barrier to entry to even use the module spec with Node.js.
You didn't say you wanted that. But that's usually solved by making separate files for each export, and a single file that exports them all for those who want that. So pretty much, yeah.
No. The answer is no.
This whole post seems to be from odd perspective "how do we stretch/extend the spec to work with how Node does things", instead of "how do we adapt Node to follow the spec and migrate to the new module architecture long-term". Sure there's about five metric fucktonnes of CommonJS modules out there and the system existed before the ES6 module specification was finalized. Transition is bound to be messy and many modules will probably never migrate, but the goal should still be to follow the ECMAScript standard when it's established. To me adding a file extension seems very counter-intuitive. In the future Node should default to ES6 and CommonJS should be treated as legacy modules. I don't care if I have to manually list all the packages that should be loaded with CommonJS in my package.json once I update my Node. I'd prefer that to loading "mjs" files in browsers because an unrelated library used to load js files in a different way.
After dealing with "grids" multiple times my top two most important features are performance and ease of customization. 
The thing is, those existing solutions existed before the standard did. It's a logical fallacy to call people incompetent for making a "bad decision" when what you're claiming to be the right decision just wasn't an option at the time they made the decision. Indeed, I am saying a lot of people might actively choose option 3, just like a lot of people are actively making the choice to stick with Python 2. Nothing emotional about that, and that's exactly the reality I'm accepting, but that seems to frustrate you to no end.
I completely disagree with you. **What standards made JavaScript a living hell for you specifically?** There were updates to the spec that I disagree with, like classes, but you don't have to use them. None of the updates broke backwards compatibility. &gt; Now with the extensible web we're finally at a point where the the consortium has been stopped from fragmenting the web even further How is the web fragmented? &gt; But to treat such a critical aspect again with such a haphazard attitude helps no one. What are you talking about?
&gt;So would I be able to access my windows files using Vagrant? Yes, Vagrant sets up a shared folder. I do all my coding in Windows, then switch to the command prompt and run it. &gt;I also had never heard of an SSH before, I had to google that too. SSH is a more advanced Linux topic, but Vagrant simplifies it so you don't need to deal with the details. 
&gt; The Haskell code runs in 1 second, and the C code runs in 8 Sure, because, again, you're using a specially crafted, convoluted example where GHC happens to be good at, and gcc is not. In the real world, one would obviously just do the math ahead of time and have it print the result instantaneously. I get what you're saying that FP can go from very slow to very fast in a large variety of scenarios given enough compiler optimizations, but loops already produce optimal (or nearly optimal) ASM for the vast majority of cases where they are used, i.e. single loops (albeit yes at the cost of composability etc, c'est la vie). &gt; The only reason nobody is doing it yet Well I think the fact that most people don't know enough FP is a big reason too. I'm not complaining about underachievers though, I'm perfectly happy being in high demand :) &gt; Because GHC is a mess I think GHC is pushing the envelope, so I think it's reasonable to expect some turbulence. SQL is another example that is quite stable, where you can unintentionally write sub-optimal code if you don't have the experience. Understanding what the optimizer does is always going to be a challenge in higher level languages. Though, for what it's worth, that's what makes mastering them fun.
How can you define "performance"? I have Virtual DOM as a feature, what should I add? How can you define "ease of customisation"? 
I wish Node.js would just release a Node 9 that makes breaking changes and aligns with the spec. It seems possible to write a one time use tool that would convert the CommonJS to ES6 modules. I work on a very large Node.js codebase and I'm more than happy to spend a week fixing our imports to get ES6 modules, even if a tool didn't exist.
&gt; The thing is, those existing solutions existed before the standard did. This is called technical debt - https://en.wikipedia.org/wiki/Technical_debt It is a solution to problems that didn't really exist. More often than not this particular problem existed to supplement code modularity in a way it was not intended, through the use of transpilers, in an environment the module system was never intended to support... node modules in the browser. This is absolutely non-standard. It is a really big land-slide of shit burying an application in a way that is too expensive to recover from. It was great while the party was rocking, but now comes the hangover. What frustrates me frustrated to no end is that Node is making this far harder than it needs to be, risking dicking up the platform as a result. This is just the matter of implementing new technology in a way that doesn't break old technology. Very simple since there is no collision to the old approach in the syntax or grammars. Just implement the new technology. Keep the old approach around until it becomes a security hazard, at which point kill it. How Babel, or other tooling, dicks this up isn't really a Node.js platform level concern. The tooling will update appropriately if it is actively maintained.
&gt; If the new value of a property is the same as the last one, I'd expect browsers to detect that and not trigger a redraw. You'd be wrong. &gt; And if it's different, then any vdom has to also change it himself and trigger that reflow, which by itself is the more expensive operation. Yes, it's faster to call one DOM operation directly via the DOM than via the vdom. That's not the point. The point of the vdom is the diffing algorithm. If we can do 1 DOM operation instead of 10, that 1 is GOING TO BE FASTER even with the overhead of the vdom. &gt; Code maintainability and flexibility I think are way more important than synthetic benchmark results. The fact that you think direct DOM operations are more maintainable is laughable. The only reason you keep mentioning synthetic benchmark results is because you know every single vdom implementation will outperform your "framework". Real applications have to hit the DOM A LOT. So we can either spend all of our time optimizing to reduce that number as much as possible, or we can use a framework that does that for us so we can actually work on the application we set out to work on.
Flexbox, box model, event system, just to name a few. There are also statements from committee members admitting that had they arrived to the extensible web earlier, they would have not published specs as they have (in reference to flex). &gt; How is the web fragmented? Why does Babel exist in the first place? Corejs, or previously Jquery. Or modernizr. Why do frameworks still ship with an artificial event bus? Why do we load dozens of polyfills before even getting to start an app? Why do we need "reset" libs for css? Why do we need font-loaders with 4 fallbacks? etc. &gt; What are you talking about? Modules. Look, i get where you're coming from. It is fine with me. The only point where i disagree, vehemently, is that the moment a "standard" arrives, everything that has been made is suddenly "incompetent" and obsolete. I think the standard should *always* look for the living standard first, and then they should publish.
I understand. And i feel for them having to deal with all the technicalities. I just hoped they would have found a common ground.
Big breaking changes = repeating mistakes of Python 2/3. It would result in big ecosystem fragmentation. 
No worries! Hope I didn't come across as critical. It's a cool service and I'll be using it in the future. 
Isn't that the point? The quote was "favoring practical usefulness over spec compliance", i.e. Microsoft's box model was the best one, but by choosing to implement that instead of the spec they caused a lot of issues. Yes, the spec was wrong, but doing things differently causes *other* problems.
Seems to be missing quite a few popular grids, Foundation, Bootstrap, Skeleton for example..
It still belongs to the web and the standards body. The last addition to the event system has been pointer-events if i remember the name correctly. &gt; Go ask the frameworks. Expecting an update to the standard to tip toe around your special snowflake framework implementation is stupid. The vendors have implemented it differently, hence, the only way to make sure is polyfilling functionality. If standards wouldn't have been published half baked much of these troubles wouldn't exist. Also, why are you so aggressive over this? There's really no need lashing out. 
[bootstrap grid](https://v4-alpha.getbootstrap.com/layout/grid/), [foundation grid](http://foundation.zurb.com/grid.html), [skeleton grid](http://getskeleton.com/)
Do your own homework and come back when you've actually tried 
I use browserify and not webpack, but I just run browserify on the resulting js-files (which by default map 1-to-1 to the corresponding ts-files) and I've had zero issues. 
[SlickGrid](https://github.com/6pac/SlickGrid/wiki/Examples) handles millions of rows (and columns)
I can imagine a world in which the execution of your javascript is suspended until the load is complete. I think we need to move past the world of single-threaded by embracing the asynchronous nature of javascript. I suppose eventually we can write `const package = await import('package')`, but that will be a ways off if how long it has taken to get es module support is an indicator.
The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more.
Well in that case a very misleading title.
Presumably he did look at the link to be able to comment on what was missing, but still missed it. 
This is good. Opt in migration path that doesn't break the existing ecosystem of millions of modules. The esmodule spec isn't proven yet. The hypothesis is sound but there's only Safari and Edge behind a flag. With no real world implementation there are likely future unknown caveats and downsides. CJS is defacto. We know the trade offs and have mitigated downsides with practices and tools. Esmodules are likely few years from that maturity if not more. And I need to deliver software now. 
Rethinking that, yes indeed, my bad.
My intuition says the variable is faster since the other involves a function call, but JS engines are heavily optimized so our intuition is often wrong. Always measure. That being said, this is almost certainly a micro-optimization. Try to focus instead on simplicity and maintainability. If the multiplier doesn't need to be exposed publicly, then the variable seems the simplest solution. As an aside, the init() method seems redundant. You could move that code into the constructor. The whole point of a constructor, after all, is to initialize the object.
Kind of apples and oranges, webpack is a whole other world compared to the simplicity of browserify. Anyways, I am leaning more towards Elm - I think the idea that "static typing is strictly optional" basically allows a backdoor and removes the universal guarantee that you can trust your code at runtime.
Very nice! Do you have any screenshots of it action?
What is the difference between each and forEach?
Sure, you can see https://github.com/edanchenkov/MenuTube/blob/master/docs/banner-v3.jpg, to get basic idea how it looks like. I also uploaded few screenshots there: https://github.com/edanchenkov/MenuTube/tree/master/docs/screenshots As it is stated here : https://edanchenkov.github.io/MenuTube/. It is a fully functional mobile version of YouTube webpage. Just like on your mobile phone, if you open it via mobile browser. Also MenuTube allows you to change YouTube look by changing user agent in settings to simulate different device (by default it is iPad).
Webpack doesn't implement es6 modules correctly. See https://github.com/airbnb/babel-plugin-dynamic-import-webpack/pull/14#issuecomment-275159815.
I think you mean "data tables" not grids
&gt; http://www.w3schools.com/js/ I thought developers didn't appreciate W3Schools?
Thankyou it's very nice! I just 'finished' the first day, but I can't seem to get the code working, to get rid of the playing class after a numerous amount of seconds. The finished code doesn't work either, I think it's a bug.
I don't think it was ever a forked version, just an old one. It's currently at 4.7 I believe. I find it really nice to use an opinionated ecosystem where the whole standard packages list is compatible without needing to worry about node version, they make sure everything (accounts system, build system, reactive pub sub system, etc) all retains the same API when they upgrade node versions. They're working on moving the whole framework to modular npm packages eventually as well, so you'll be able to pick and choose which parts of the framework you want 
Thanks! Haven't seen that many examples with Element UI so far. 
As someone already mentioned, each has their pros and cons. But to roughly answer your questions: 1) This is mostly true. Still, its CPU performance tends to be better than PHP, Python or Ruby, but indeed for CPU-bound work you'd be better off with Java or C#. Also, you can have multiple threads in Node.js, but indeed by default everything is single-threaded. If you want to do CPU-intensive tasks in a webserver for instance, you should take care to offload to another thread (or even a separate service) to avoid blocking your main thread which would affect all connections. 2) This used to be true years ago, but using Promises it's no longer an issue. If you're using Babel or TypeScript you can even already use async/await which is similar to what C# provides, but is basically syntactic sugar to make working with Promises even nicer. 3) This statement I'd consider false. Yes, it would perform worse in CPU-bound scenarios, but it would likely perform better in IO-bound ones. Either way, you're free to scale your Node.js instances horizontally so I wouldn't say it limits your scalability compared to those options. 4) I think indeed the popularity of JavaScript as a language is a large part why Node.js is popular on the server. Also having better performance than most scripting languages helps it there. You're right it's also great to build small apps, though micro-services are also a good fit.
Very nice, thanks for this. Did you look at [jsGrid](http://js-grid.com/)?
I worked on drag and drop support in Cx and made a clone of Trello: https://cxjs.io/fiddle/?p=H9Bb4Kf2
Cx has a very nice grid control. It doesn't handle many rows very well atm, but that will come soon! https://cxjs.io/fiddle/?p=vwyHzOO1
I agree. And the variable is closer in terms of the AST / lexical scope so it would find it quicker quicker
I didn't. Only looked at what I tried myself, but would love to add it in the future. I'm making a todo list for all the suggestions from here. If you know that grid, and wanna add it yourself, adding a grid to the repo takes 5-10 minutes max. 
I've always known them as data tables ðŸ¤·
ag-grid, clarity data-grid, js-grid, ui-grid, slick-grid, fancy-grid.. It is not unreasonable to take the greatest common denominator for the name IMO. I didn't think it was confusing, but now I know it is... My bad 
Thanks mate. This is what I was assuming. Thought there might be some magic shorthand for accessing the 'hidden promise' naturally returned by an async function. Appreciate your help.
Looks very nice! I added it to the TODO list. If you are familiar with the grid, and wanna add it yourself, adding a grid to the repo takes 5-10 minutes max.
Nowadays, most of them has "grid" in the name.. Next public repo I'll make a survey to find a suitable name :)
Also, I am going to create blog application example and simple admin page example.
I have to say, ag-grid has pretty terrible performance compared to the others.
I have plenty of experience with that one, and I don't know what you are talking about. How can you define "performance" in a quantifiable / categorised manner? I would love to add a performance category to the comparison. Currently, only thing there is Virtual DOM (true/false)
&gt; We are therefore considering the possibility of implementing a `require.import()` function that is modeled after the proposed ES6 `import()` function. I don't get it, why not just use the latter?
Mostly talking about scrolling performance versus the others. It's just not smooth. Compared to handsontable which feels like there's no delay or slowdown.
Look at the book Eloquent JavaScript. [Link](http://eloquentjavascript.net/)
How long until we can use ES2017 async/await in Node?
if your async function returns a promise you don't need to use await for that last call: async function myFunction() { return fromCallback((cb) =&gt; addSlow(4, 2, cb)) }
How about something like [this](https://jsfiddle.net/23q6v3a7/)?
In node 7.4 you can use await calling node with an option set. Seen this on phantom js readme on github
Jqwidgets has a pretty decent data grid if you're still trapped using jQuery. 
Facebooks [Fixed Data Table](https://github.com/facebook/fixed-data-table) is my default data table in React. 
Haha, yeah super confused for about 10 seconds when I opened this up. 
jquery-textfill was way too slow when you have more than fifty text fields. It was even slower when used with animations/resize events. The performance bottleneck was its heavy reliance on dom manipulation. So I've decided to design something similar, with performance in mind. The code is in the link. Can you, please, give me some feedback? thanks! 
Webpack also doesn't fully emulate `require` the way node implements it either, for example if you get the user to input a string, and then `require` it, Node will do what you would expect while Webpack will refuse to build.
very cool!
I dig it. Thanks 
Very cool! I was skeptical about watching videos like this, but it works very nicely. It's pretty much ideal for the the types of videos you mentioned, which are generally the types of videos I have on in the background when I'm writing code. Would it be possible to have an additional global accelerator to toggle the display? At a (very quick) glance it looks like you could just call `ipcRenderer.send('hideWindow')` from `globalShortcuts.js` when 'Cmd+Alt+Y' or 'Super+Alt+Y' is detected. It would be really cool if you could do 'Cmd+MediaPlayPause', but in the past when I tried this media keys didn't work with modifiers. Let me know, if you want I could clone and do a pull request.
&gt; The hypothesis is sound but there's only Safari and Edge behind a flag And now [Firefox 54](https://developer.mozilla.org/en-US/Firefox/Releases/54#JavaScript).
Handsontable is free on an MIT license. Handsontable Pro is a paid version, featuring more things. Comparison - https://github.com/AmitMY/grids/blob/master/differences/Handsontable.Handsontable%20Pro.md
Looks great. Added to my TODO
I can field technical questions, but probably won't spend too much time checking this. If you have questions about the why, feel free to ask. If you have a different approach please read up on github about all the alternatives that have been looked at over the past 1.5 years. If your proposal is not in there, feel free to fire away here.
Definitely interesting. Added to my TODO. And I agree that sometimes it is better to get a specialised thing for a task. that is what this comparison is for - what is best to use when needing somethings, in a framework.
I don't know how can I benchmark this.. I assume it is different on every machine, and every browser... But I get what you are saying
Is unambiguous grammar on its way out, then? I'm still not entirely sure why that approach wouldn't be viable.
We took it to TC39 in January. Have to wait on meeting notes, but yes it is most likely out of the picture unless a different way to do it is found.
Take a look at yarn: https://yarnpkg.com/lang/en/
I'd say virtual scrolling: having thousands of rows and columns without losing the ability to scroll fast. 
Looks amazing!
You're over thinking it. Right now you can specify the entry point in which `require()` will use on your library. Simply break that up, have two entry points in your `package.json`. One for the CommonJS way and one for ECMAScript. To make your project backward compatibility you would always supply both. Easy.
&gt; Sure, because, again, you're using a specially crafted, convoluted example where GHC happens to be good a The example is just mapping over a large dataset, I'd not say it is a "convoluted" example when it is one of the most used programming patterns ever... &gt; I get what you're saying that FP can go from very slow to very fast in a large variety of scenarios given enough compiler optimizations Not really, Haskell can, one could make a FP language that is always fast, by disabling tons of slow stuff haskell does
&gt; Personally, for React and specially views, I swallow the performance cost and go for maintainability, since there are usually other things that can give you much better perf gains elsewhere Sometimes it is just too slow, like when you have a big dynamic table on your site
How is that different than virtual DOM? Having DOM to update for a cell only when you see it?
Given that all 24 lessons are released on time (without any break for Xmas etc.) - you could graduate as early as 9th January 2018.
Thank you!
So... this is a gif player yes? Playing by pressing play/stop button?
I'm from Switzerland and I would say that I am an intermediate in javascript (but with xp in Java, C#). I see lots of ads talking about Angular but I am unsure if their HR departments actually realize that there's Angular2. So if the company is already converted to Angular2, it would make me look rather foolish walking in there with just ng1 knowledge. I've been flirting with the idea of jumping into React, maybe do the tutorials on codeacademy or something similar. Or any other suggestion about tutorials you might have. Typescript is whole new bag of tricks that I am not so sure I wanna get into yet. But it does look interesting since I worked with coffeescript in my previous company. Thanks for the advice.
`(0, _effects.put)(...)` is not the same as `_effects.put(...)`! in the first case, `this` will be `undefined` (i guess we can assume `'use strict'` in this context). in the second one, `this` will be `_effects`, which is not consistent with the original code (`put(...)` is a function call, not a method call). also `let put = _effects.put` at the top would work, but that way cyclic dependencies would be impossible. that's why babel (and maybe other transpilers) use this `(0, val)` approach.
It is not the same purpose, but nice project btw.
Let an UXer dream :) At least my barin didn't explode reading this one ;)
Makes sense. I'll sort that out ... thanks.
Cool. Have you considered using WebGL to speed it up a fair bit? Maybe it wasn't ready in 2009, but it's very mature now. Here's something I made along with another student back in 2011: http://liamness.co.uk/webray/
Wow, thanks a lot. Missed that entirely.
I think it's more like versioning tool for JSON data with a data-structure like git. edit: I'm not quite sure where the concurrent edits would come from in a js application or how conflicts are supposed to be resolved without making the user merge JSON data (urgh).
No there is no nextClick() function unfortunately. Instead of setting the boolean `boltcuttersclicked` it might be cleaner to have one variable that is simply the item of focus, so when you click the bolt cutters you set `itemOfFocus` to `boltcutters`, then on your chain click handler you query the current `itemOfFocus`?
I'm basically making a game in my free time which involves players writing their own code which will be converted into things within the game such as Debug.Log("Hello"); logging a message to some kind of console inside of the game so I'm converting code into an array or array map (whatever the best method to work in would be) so I can read from that array nicely and the depth of the array determines. It's kinda hard to explain so I'll just show you the very rough script I've written so far (I'll probably be moving a lot of it to the serverside as PHP eventually but for now I'm just messing around getting things working) http://seanscorner.com/sites/hackproj/templates/scripts/hsparser.js
Webpacks define plugin does that plugins: [ new webpack.DefinePlugin({ 'process.env': { 'NODE_ENV': env.dev ? 'production' : 'dev', 'URL': `http://${env.dev ? 'www.something.com' : 'localhost'}:3030` } }) // in your code const url = process.env.URL;
I dont think thats where my problem lies, because I've got no problem in "opening the door" function. Let me maybe word my problem definitely: After clicking boltcutters I then click on chain - everythings perfect, door opens. After clicking boltcutters I click on other element than chain - I get the "cant use it on it" message. I could obviously add such function to every element on the screen but I dont think that would be a good practice. So instead I need something like: http://prntscr.com/e85x7h How can I write a function that will determine what is the NEXT CLICK.
It wouldn't exactly be es6 anymore
what problem is this solving that a number of different database structures can't do? outside of just keeping data structures intact, there are also a lot of systems that have very efficient consensus algorithms (using [raft](https://raft.github.io) as an example). I only see the client side perpetuating a lot of those problems. I don't mean to criticize the idea negatively, I'm honestly trying to add to the conversation 
I think it would be rare to find an employer using ng2 exclusively. Usually what I see is large ng1 apps and *maybe* some ng2 for new features. If you already have experience with coding, I'd actually recommend not going for online courses, since their structure is artificially set in such a way to introduce concepts gradually. It may be more productive to just jump straight into hacking together a project.
I will tinker with this after I test my second idea, that is adding click event listener to body after boltcutters are detected. Im getting close, but I still encounter some problems, so I probably will try your idea soon.
What if you have lots of resources? You have to store all those url/token pairs. In the suggested scheme you just check if crypto signature is valid and do not store anything. P.S.: Somebody silently downvoted you. I give you an upvote for discussion.
I honestly don't understand why you're using Typescript for this..
First time I post some french here, but ok! Sorry for that.
Yeah I tried it, it's definitely better now that I'm on a desktop, but it still updates very slowly compared to handsongrid and others mentioned in this thread.
In pre-ES6, that might have been an OK-ish description, but not anymore in ES6+ with blocks. const x = 42; // ES6 block creates new scope { // Crosses scope boundary to access x, but no closure here console.log(x); }
What you can do is a main "interactive objects" handler. With a switch inside to match each actions, and forward it to the good function. Then you can store an "expectedAction" in a condition at the beginning or the end of the handler (no matter, this way you don't have to kill the current action). Something like function eventHandler( event, source ) { // true/false and detect inside your function what do you want to show if success or failure if ( __expectedAction ) __expectedAction.cb( __expectedAction.target === event.target ); __expectedAction = null; switch( event.target ) { case "boltcutter": __expectedAction = { cb: checkClickOnChains, target: "chain" }; openTheDoor( source ); break; case "chain": breakTheChains(); break; } } This way you don't manage "tutorial" parts with "pure gameplay" parts.
Canvas
Great writeup, eskoban, love the examples! I didn't know that ES6 had sets, maps, and proxies before your article. FYI, in the proxies section, I think you might have to add a closing ``` for the JavaScript snippet.
Looks really neat and brief, probably taking out a lot of 'Get up to speed with ES6' books/tuts down in one go, nice one OP! : )
Awesome! Just a small typo, it's written defualt instead of default
I've been trying to implement this into my boilerplate project for the past 5 days. No luck. :( The documentation hints towards an example project, but there is no link. Does anyone have suggestions or working code I can look at? Edit: I'm using create-react-app as a base, I tried ejecting and updating the babel plugins so that I can use the decorators. That didn't work for me. So I'm trying the method described in tmartlolz's comment.
Thanks, it's fixed now.
Hi all, I just finished up an initial release of this last night, I'd love feedback or ideas for improvement. The overview: * Write **standard, future javascript** â€“ with stable es7 features â€“ today ([stage 3](https://github.com/tc39/proposals) or [finished](https://github.com/tc39/proposals/blob/master/finished-proposals.md) features) * [Optionally use typescript](https://basarat.gitbooks.io/typescript/content/docs/why-typescript.html) to improve tooling, linting, and documentation generation * Export as a [javascript module](http://jsmodules.io/), making your work **fully tree-shakable** for consumers using [es6 imports](https://github.com/rollup/rollup/wiki/pkg.module) (like [Rollup](http://rollupjs.org/) or [Webpack 2](https://webpack.js.org/)) * Export Typescript type declarations to improve your downstream development experience * Backwards compatibility for Node.js-style (CommonJS) imports * Both `strict` and `flexible` Typescript configurations available So we can have nice things: * Generate API documentation (HTML or JSON) [without a mess of JSDoc tags](https://blog.cloudflare.com/generating-documentation-for-typescript-projects/) to maintain * Collocated, atomic, concurrent unit tests with [AVA](https://github.com/avajs/ava) * Source-mapped code coverage reports with [nyc](https://github.com/istanbuljs/nyc) * Configurable code coverage testing (for continuous integration) There's also a [folder with examples](https://github.com/bitjson/es7-typescript-starter/tree/master/examples) of how this project can be required from standard Node.js, Node.js with Typescript, and tree-shaken in the browser with Rollup.
The good thing about stuff that's on Github is that you can submit a pull request to fix typos yourself :P I submitted one: https://github.com/codetower/es6-features/pull/1
According to that definition scope is the running execution context of the given function, but we both know that scope isn't limited to functions in the same way that closure isn't limited to functions. Those terms are defined in that manner for the given context, which happens to be about function invocation. More explicitly, scope (execution context) is passed into the FunctionCreate function (among other things) and the returned result is a closure by which the function's constructor is created. This definition is accurate, but not limited in the way you intend. To be more precise a function is a scope, and scopes are closures (where there is lexical scope), therefore functions are closures. That doesn't preclude blocks from being scopes, and thus being closures according to the same logic. To be less precise closures are a phenomenon of lexical scope without regard for a given language's specification or whether a language even has functions. For instance closures are available in XML Schema although XML Schema doesn't have functions, at least not in the formal sense, but XML Schema does have namespaces and lexical scope.
Yeah it's awesome. I accepted the request and will update the gh-pages shortly. 
Thanks. :) Yeah. 
I agree. It is not really matching, but it does have its resemblence. 
Below code is something I use in several projects Axios is fine of course, but I never use it because the below code does more or less the same and is much smaller. I hope it will help you, as the code you present for Vue is a bit strange Vue has reactive properties, maybe you should look into that, instead of using setInterval. Hopes this helps. // Sample Ajax call to endpoint using abort options // Copyright none, just for the fun of it // // Call function on name value pair function Params(obj,func) { var i,l = obj.length; for (i=0; i&lt;l; i = i +2) { func.call(null,obj[i], obj[i+1]); } } // Return list of property names function Values(obj) { var a = [], propname; if (obj) for (propname in obj) { if (obj.hasOwnProperty(propname) &amp;&amp; obj[propname]) a.push(propname,obj[propname]); } return a; } // object data to string as application/x-www-form-urlencoded function Transform(data) { var result = ""; Params(Values(data),function (key,value) { result = result + (result ? "&amp;" : "") + key + "=" + encodeURIComponent(value.toString()); }); return result; } /* options method = "get" default | "post" .... url = "endpoint" params = { someparam : value } ?param=value&amp;other=value noCache = "random" | "minute" 2 ways to add a param which does not cache the call headers = { someheader : value } "x-access-token" ... token = "value for x-access-token" data = String | Object transform to String when application/x-www-form-urlencoded dataType = "value for Content-type" raw = true | false , set Content-type for POST application/x-www-form-urlencoded */ var Ajax = function (options,resolved,error) { var xhr, abort = false; // compatible with IE7+, Firefox, Chrome, Opera, Safari xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if (xhr.readyState == 4 &amp;&amp; !abort) { if (xhr.status == 200) resolved(xhr.responseText); else error(xhr.status,xhr.statusText,xhr.responseText || ""); } }; var urlParams = Values(options.params), url = options.url, params = "", data = null; // parameters var now = new Date(); if (options.noCache === "random") urlParams.push("cacherandom",Math.random()*Math.random()); if (options.noCache === "minute") urlParams.push("cacheminute",[now.getFullYear(),now.getMonth()+1,now.getDate(),now.getHours(),now.getMinutes()].join("")); if (urlParams.length) { if (url.match(/\?/) === null) params = "?"; Params(urlParams,function (key,value) { if (value) params = params + (params === "?" ? "" : "&amp;") + key + "=" + encodeURIComponent(value.toString()); }); } // start request xhr.open(options.method || "GET", url+params, true); // request headers options.headers = options.headers || {}; if (options.token) options.headers['x-access-token']=options.token; if (options.data &amp;&amp; options.method.toLowerCase() === "post") { options.dataType = options.dataType || ( options.raw ? "" : "application/x-www-form-urlencoded"); options.headers["Content-type"]=options.dataType; data = options.dataType === "application/x-www-form-urlencoded" ? Transform(options.data) : options.data; } if (options.headers) Params(Values(options.headers), function (key,value) { xhr.setRequestHeader(key,value); }); xhr.send(data); return function () { if (abort) return false; abort = true; xhr.abort(); return true; } }; Ajax.noop = function () { return function () {}; }; /* sample var abort = Ajax.noop; // initial value is an empty function function success(data) { // do something with data } function failure(error,errorText,responseText) { // act on error } // repeatable calls will first abort latest call abort(); // create new call, returns abort function abort = Ajax({ method : "GET", token : "some session token", noCache : "minute", url : "your/endpoint"},success,failure); */ 
Not sure if it meets your requirements, but for React apps I use this: https://facebook.github.io/fixed-data-table/ might be worth adding to comparison.
Absolutely no requirements. This one is in my TODO (you can see the TODO file in the root of the repo) Thanks!
this is great!
I know nothing about Vue nor Axios, but it's obvious from the code that by calling `getReunions` inside the `getReunions` function you fall in the infinite recursion. Wrapping the call inside the `setInterval` function you additionally raise your infiniteness to the infinite power. Also `rate` seems to be undefined, resulting in the infinite short time of calling the `setInterval` function. &amp;nbsp; And one more thing. If you want to clear an interval you should call the `clearInterval` function after calling the `setInterval`, and not before. 
Have to admit I have missed this aspect of CoffeeScript since the day I left it behind. Inspecting objects looked so much cleaner.
very nice article. also consider polymers [iconset component](https://github.com/PolymerElements/iron-icons/blob/2.0-preview/iron-icons.html). there is a nifty [webapp](https://poly-icon.appspot.com/) to see it in action, although the syntax is about as simple as it gets.
Very nicely put together. Thanks for this. 
You could check out [Preact](https://github.com/developit/preact) or [Inferno](https://github.com/infernojs/inferno) if you like the way React does things but are concerned of the legal ramifications. Both can replace React for existing projects using their respective *-compat bindings. 
I think you have your facts backwards here. The W3C's normal mode of working is to put a bunch of people in a room and see if they can come up with an agreement before breaking for lunch. The WHATWG has done things based on usability studies, research on data sets using literally billions of Web pages, careful collection and curation of use cases, proactively seeking feedback from Web author discussions, etc. Before the WHATWG started up, the W3C was a closed-doors organisation that didn't even have public discussions on mailing lists. If we'd left it up to the W3C, HTML would literally have stayed as it had been defined in 1998. They literally said it was dead, back in 2004. We'd probably all be using a proprietary .NET at this point. Have you ever looked at XHTML2 and XForms? That's what the W3C was pushing back then. Browser vendors weren't going to implement it, and nothing on the Web was compatible with it.
I tried to push a GraphQL api with a single endpoint into Lambda with Serverless. It talks to an RDS database, but my Lamda would take up to 11seconds to response. I'm assuming cold Lambdas spin up DB connections before doing any work, I havn't quite dug into the reasons why it took so long but I'm left thinking that Lambdas aren't quite the right solution for a serverless CRUD API just yet. They do however work really well for things like image processing or non time-critical work. 
Use Jest, keep your routes thin and devoid of logic. Call out to utility functions which contain your logic from the routes. This way, the logic is testable in a way that you don't have to start mocking endpoints. Keep everything functional and therefore deterministic. 
Thanks for checking it out! I know about the issue when going back, but I have quite a hard time figuring out what exactly is going wrong there.
This would be nice to have as a built in language feature since it's a problem that myriad libraries have tried to solve. Would make the syntax a bit messier but not too much of an adjustment and it's better than pulling in a library, some of which use string parsing.
Could also do `Math.max.apply(Math, myNums);`, though I don't know if that saves on heap allocation.
Any function in js can be called with apply Math.min.apply(null, yourArray)
Or, if you're using ES6, `Math.min(...myArray);`
Are you sure? They put out a new version of ag-grid every few weeks it seems like. I think they're on version 8 something now.
I think what you want is something like a state machine. with a state machine strategy you make the click handler replace itself with the next valid state. Example: to start with, the body (or whatever area you want) doesn't have anything to do, so no click handler. The boltcutters have a handler says : replace me with boltcutters next step, replace bodyclick with {bodyclick does nothing, boltcutters click to step one} Google 'state machine strategy' for a better explanation; in short, state machines are helpful because they model behavior in a way that's easy to follow.
One way would be to save the picture on your drive and put the path into the db.
What you seem to be asking is: why aren't these functions overloaded (i.e. autodetect their implementations based on the arguments). The short answer is that function overloading is generally a bad idea.
The correct answer for all your questions is "it depends". In this case it depends of technology, project architecture, framework / platform, programming language... 1. Role of frontend developer here is taking responsibility for look &amp; feel, functionality and triggering a correct call. Backend developer is responsible for results that it shows. In reality this is made in opposite order. But again - it depends. 2. Look above. 3. Same. 
Most site features require both the front and back end. Let's take a bit of a wider view. JS is code that's run inside the browser, and could do things like: - hold data in JS: let's say you have `index.js` on your page, in that file you have `var users = [ "user1", "user2", "user3" ];` - display data: same file as above could take those user names and put them on the page - retrieve data: having a huge list of users in `index.js` might be extra bloat that isn't useful, JS can request data from the server (backend) then do stuff with that data - move stuff around, UI, interaction: this is what most people think of WRT JS, carousels, lightboxes etc. Back to your questions... 1. Both most likely. Front-end will be concerned with the form submission (making a request to the server with the search parameters), back-end with the retrieving and returning the results, and front-end again for displaying results. 2. This could be either. Back-end just serves a page with that already rendered, or front-end JS does a similar path to #1 above. 3. No reason for this data to be treated any differently than #1 or #2.
nitpicking, but the computation of the average is wrong: const euros = [29.76, 41.85, 46.5]; const average = euros.reduce( (total, amount, index, array) =&gt; { total + amount; return total/array.length }); average // 118.11 should be average = euros.reduce((t,a,i,l) =&gt; t+a/l) also, the average is definitely not going to be 118.11. that said, reduce needs more love, is the sexiest function around. Thanks op
Hi again. So I have been trying to make blob work, and I am not having success. This is what I have persisted in my database: blob:http://localhost:9000/6e75594d-2eeb-40ce-a534-8aeb6515cc9c Now when I try to fetch that url from my database afterwards,I get a 404... saveCanvas() { const THIS = this; const image = document.getElementById('canvas').toBlob((blob) =&gt; { const newImg = new Image(); const url = window.URL.createObjectURL(blob); axios.post('/save', { params: { author: THIS.props.user, title: 'mootCanvas', png: url } }); //here I am saving to database }); } loadCanvas() { axios.post('/fetch', { params: { author: this.props.user, title: 'mootCanvas' } }) //here I am fetching from DB .then((response) =&gt; { const canvas = document.getElementById('canvas'); const image = new Image(); image.src = response.data; console.log("response: ", response.data); image.onload = () =&gt; { canvas.getContext('2d').drawImage(image, 0, 0); }; }); } Edit: Another thing, I noticed that blob gets appended to localhost in its url. Whenever I refresh browser, does that said url then become invalid? If so, I cannot proceed with blob. Another edit: out of curiousity, is blob the mean of how FB/Instagram, etc. persists images? Also I made sure that response.data is 'blob:http://localhost:9000/9605571e-a900-47c5-8b11-6aadbb6d891d'.
If you're using Lambda, Serverless (https://serverless.com/) is probably the best option. It takes care of some of the provisioning of things like S3 buckets. It takes care of deployments and allows you to run your lambda locally from the cloud kindof. Things to note are that debugging a lambda is a pain in the backend. Your logs go out to cloudwatch which is not ideal for trawling through to find an error (although I'm sure you can ship them somewhere more friendly if you try). It seems to me that lambdas are all a bit of blind coding and hoping it works in the lambda. They're definitely useful as I said for things like image processing, resizing, uploading to S3, triggering things from dynamodb stream events, I've even seen it used to throttle db writes in conjunction with SQS. My experience with it as a replacement for an API, is that it is just not there yet. I'm sure it'll get there, and I'd be happy to find out if there are things that I was doing wrong to squeeze more performance out of it because I think it would be a game changer. 
You need to store the actual data, not a URL. A URL is not a blob. 
`const maxArray = Math.max.apply.bind(Math.max, null);`
I've written a couple of different version of Yahtzee, including one in JavaScript.... so here is what I recommend: **Separation of concerns** You need three functions: 1) Process roll. Handle all re-rolling, etc. 2) Score roll. Update an in-memory object and any bonuses. 3) Display the score board. By separating the processes, you don't have the problem of values getting added on each iteration of the game.
Oh yeah, I remember reading a blog post by TJ H.. on building Apex. It's quite good and one thing I took away from it was the AWS lambda concurrency limit of 100 unless you phone up AWS and ask them to increase it. Bit weird that that is the process but if you work for a company, you probably already have an AWS contact. 
Oh shit, you just dropped the "a"-bomb (arity) on javascript programmers!
You can save another heap allocation and a bunch of redundant closure calls by reducing in a loop. I mean, either we want to go functional and we don't care about performance, or we care about performance and we can skip the heavier functional approach. 
I think he means that overloading is a bad idea in a dynamically typed scripting language
Anyone can submit the limit increase form and they are responded to very quickly. The limit is there both for capacity planning and to protect you and AWS (To mitigate catastrophic affects to AWS and to your bill if you accidently make a Lambda function recursive.)
It's harder to debug. If I get a chunk of code that's breaking and it looks like: doThings(data); And I can't be sure if `data` is an array, a string, or whatever else â€” because the function is designed to work with whatever input â€” then I have more digging to do than if I could be sure it always requires an array. In my experience it's often a case of clever code that causes maintenance headaches later on. 
or look for API solution like https://www.imgix.com/solutions/responsive-design Having Responsive images will save you tons of money and make your site silky fast.
Object.assign only do a top level copy. Which means that all inner object of your object *a* is a reference. I came accross this issue recently and here what I found : http://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript Make sure that the solution you are going to use do a deep object copy.
Thank you 'top level' is a good way to remember it :) and thank you for the link :).
On the other hand, I work for a very large company that doesn't compete in the Facebook space, but our lawyers are not okay with the React license. YMMV or YLMV (your lawyers may vary). We ended up going with Vue and so far are happy with that decision. 
I've been using Karma + Jasmine for tests with Sinon as needed! Admittedly kind of old, but it does its job and it's what I'm familiar with. Although I've never used it, people have recommended Jest as well.
you can use multer w/ the id of a user, in my implementation i directly made a dir with the id as the name, that way, the user can upload multiple images linked to his account and you'd statically host those dirs somewhere (if privacy isnt that important :)).
How would you handle a parent file which needs to `import()` a child file, but the child file also has to `import()` its own child file, but the original parent calling the first `import()` shouldn't continue until the innermost `import()` is complete? Expose the promise from the internal `import()`, or is there another strategy? Seems like that could get hectic pretty fast with a larger tree.
are you located in the US?
Yes. 
Strong points. Thanks!
If you can answer most of the junior's questions - and when you need help the other juniors usually can't help you. It all depends on the company though - if you are the only junior dev, then it could be when you gain some confidence from your boss - or it could be when you get your next job. My company only has interns and developers - everyone knows who the seniors are, and they get more $, but they don't have the title. It all depends. But to get back to your question, being able to learn new things quickly, and being able to figure out old shitty code is your job. Get better at that and good things will happen.
If you use ES6 features, you can just use spread.
It really depends on the use case, but having polymorphic functions is often very useful.
The WiFi icons are flipped in the thumbnail.
Ask your manager.
Can't you just pass Math.max directly to reduce()? Your wrapper is just another identical version of max(). 
What you seek is probably along the lines of: import cloneDeep from 'lodash/cloneDeep'; ... let b = cloneDeep(a); That Object.assign, or its more concise es7 form `let b = { ...a }`, only create shallow copies is a major benefit later when you're working with immutable state (Redux, etc).
Related: [2ality: ES proposal: import() â€“ dynamically importing ES modules](http://www.2ality.com/2017/01/import-operator.html)
The best path to be an intermediate developer is: * get hip the current popular framework * get everything you can from NPM and bundle it for the browser using something like Webpack or Browserify * follow trends * do whats most popular Or you can skip the intermediate step and go straight to rockstar with a bunch of additional practice. Just ignore everything I mentioned above.
Is there any good reason for properties of `const` being mutable? Fucking annoys me every day.
W3C grew to be much more than just browser vendors. https://www.w3.org/Consortium/Member/List currently lists 433 members and only a handful of those actively develop browsers. Other members have different reasons to participate. u/Hixie mentions Boeing as an example elsewhere in the thread. 
When your state is too big to manage via components
**vbuild** ([Repository](https://github.com/egoist/vbuild)) ([NPM](https://www.npmjs.com/package/vbuild)) **Stars** 435 - **Language** JavaScript - **License** MIT - **Release** 6.1.1 *(1 hour ago)* Develop Vue app with zero-config. *** ^(BETA | by /u/AtroxDev |) [^(Telegram Bot)](http://t.me/LibrariesBot) ^| [^(Something went wrong)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Something%20went%20wrong) ^| [^(Suggestions/Thoughts)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Suggestions/Thoughts)
Yes I'm aware what it means, I am questioning why.
- when you have race conditions (for ex: call fetch data and show loader at same time) - when you have reduplicates data in your app (for ex: count of likes on post page and sidebar - through Single Store) - when you have difficult data-flow (for ex: https://css-tricks.com/wp-content/uploads/2016/03/redux-article-3-03.svg) - if you need to have middlewares (for ex. for proccesing async actions) And redux have less boilerplate code than flux. And for summary, if you have little app, then you might use just props and callbacks for calling actions, but if you app is scaled - redux need for you. great article about redux: https://css-tricks.com/learning-react-redux/
Well that's convinced me to give yarn a go!
I had the same question recently and it turns out that I needed to understand how react actually works... https://www.youtube.com/watch?v=iwbkgOq1SMQ this is a nice video...helped me a lot to understand the concept... also start coding and see yourself how react manages states... you would easily understand why someone would need radux
Good news! it's been bought by CNCF and relicensed to be under the Apache Public License 2.0. https://www.joyent.com/blog/the-liberation-of-rethinkdb
Also known as a 'shallow clone/copy'. Just for reference.
Would be the same story as for static imports, I assume: - https://medium.com/content-uneditable/circular-dependencies-in-javascript-a-k-a-coding-is-not-a-rock-paper-scissors-game-9c2a9eccd4bc#.l4nykai7w - https://medium.com/@ehnertm/es6-cyclic-module-loading-28e469955e53#.j1dm9zodv
why?
This a really subjective question that is difficult to answer without context. Personally, I like Dan Abramov's [article about it](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367#.34s5bmrb3). He outlines some of the reasons you might use it and some of the ways you can use React without it. To speak generally I'd say Redux is useful when: - You have multiple components reliant on the same data - You have data that triggers updates to other data across the app - You have to process a lot of data from different sources Basically, you can use it to disentangle complex logic from the presentation logic, especially if you have multiple things going on.
You're right, just did CA's React and the fact that it doesn't introduce any ES6 concepts was a big no-no for me to start with. I've already started working with a small personal project to play around. Cheers for the replies.
That's more to verify that the function you're passing your pointer into won't mess with your shnoz, which is nice.
Because we have things like Object.freeze to force the object itself to be immutable. Or proxies to do other cool things const and let in JS is around the craziness of closures and hoisting. 
Because it makes the type signatures of functions ambiguous, which leads to hard to debug errors when you mismatch them and get unexpected results deep in an application (especially confusing because it often leads to errors that don't explicitly throw). I'm skeptical that it would ever cause duplication to remove it, especially if you're using function composition. If anything, a compositional approach would be more DRY because all the little "bits" that transform and standardize some ambiguous input would be externalized and could be reused/recombined: this type explicitly instead of implicitly. I think there is probably a place for them in a few high-level utilities for convenience (certainly is the lodash approach). But it's very easy to go overboard and the result is a lot of extremely complex different code paths to think through. If you offer multiple ways to use something, all of those ways are liable to get used at some point by somebody. That might seem super flexible in the moment, but it's often not a good thing in the long run, and it hurts the ability to create abstractions and simplifications. Simplicity and consistency are good things in the long run.
Yeah, it's certainly a lot harder to read than MDN, but if your main concern is accuracy you're not going to find a more definitive reference than the spec itself.
Hi /u/denar90, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
and what to do if these components are at the same level or in very different branches? With a Single Store which holds all the data in one place to make it much easier
You should use Redux when you are trying to solve a problem, you are looking for a solution to that problem, and Redux solves that problem. But not before. So state the problem you are trying to solve. Does Redux solve that problem and you can't, for whatever reason, do it yourself? If you can't state the problem you are trying to solve with Redux then you don't need Redux at all.
According to [this issue comment](https://github.com/nodejs/node/pull/11029#issuecomment-277922899), we should be able to use async/await with no flags in NodeJS v7.x very soon. In NodeJS 8, I believe this will be the case [as well](https://github.com/nodejs/node/pull/9618).
Thank you for your response. I'm still having a hard time understanding the examples on that github readme. I have: // var slider = new Slider('#range_slider'); // slider.on('slide', function(slideEvt) { // $('#range_slider').text(slideEvt.value); // tooltip: 'always'; and need to turn that into: $('#range_slider') .bootsrapSlider() .on('slide', () =&gt; {}) ??? Where does the function go? And the slideEvt value?
&gt; Your only alternative to function overloading is embedding the type/action information into the name of the function, or lots of if-blocks - and for things like n-arity, or those that take even a handful of arguments, that becomes impossible or just wasteful boilerplate that obscures the distinct and valuable logic information. The alternative to function overloading is to just write functions that take a single input format, and it's the job of the caller to make sure the input is in that format. That's what `Math.min` and `Math.max` are doing. They take vararg ints, and it's the callers job to unwrap the array if they want the max item in the array. It's not just debugability, overloaded functions in JS can just be hard to read and reason about. You can't do separate call signatures as their own implementation like in most C-like languages so you get awkward stuff like: function doThing(fooOrArray, maybeBar) { let foo, bar; if(isArray(fooOrArray)) foo = fooOrArray[0]; bar = fooOrArray[1]; } else { foo = fooOrArray; bar = maybeBar; } //Actual logic using foo and bar goes here. } It's awkward to write (correctly implementing `isArray` is non-trivial), awkward to read, awkward to document, and ultimately, all it lets you do is write `doThing(array)` instead of `doThing(array[0], array[1])` or `doThing(...array)`. --- There are exceptions: if a function is a "library" function - something that's called a lot - it might be worth the caller's convenience at the expense of the implementer's pain. And some operations naturally need to be overloaded: an overloaded `toString` is better than a `toStringFromNumber`, `toStringFromDate`, `toStringFromObject`. But for stuff like this, where we're just talking about the structure of the data? Pick a format and have your callers call it. 
It does process the code, I can see the -1, even with the alert
When you need it.
Put senior developer on your resume and go on some interviews.
Cheers guys, that was fast
IMHO, specs are not just for those developing internals! I think it's a sign of a seasoned dev if they know how to check the spec. I can't tell you how many "odd" behaviors that I've come across, which I first chalked up to browser or library bugs, only to realize that it was actually the way it's supposed to work. This goes for all languages (e.g. CSS, HTML, etc.), not just JS.
That is most likely due to the lack of experience but I find it quite complicated to read the specification. Can you provide an example of how that could be useful and what is the efficient way to learn from it?
With the caveat that if someone deviates from the spec, it might be documented on MDN but obviously won't be in the spec itself.
Why not just set Atom to use LF line endings?
Great question. I think you're going to get lots of different answers and the reason for that is that everyone is going to have their own definition. It can vary wildly between companies. For my two cents, think about it like this; You've seen lord of the rings? While you are a junior, you are Frodo. You know you've got responsibilities and sometimes it feels like you need to bear the burden of confusion all by yourself. There's a scene near the end of two towers where Frodo turns to Sam and says "I can't do this". At some point in your career, you will feel like that. You will feel like you want to stop. Don't You've seen Starship Troopers? At the end of that there's a scene where a fearless Rico turns around to his squad and says "COME ON YOU MAGGOTS WANT TO LIVE FOREVER??!" As he runs directly towards danger. At some point in your career, you will feel like that. You will realise that it's better to run towards the fires than away from them. Nothing will phase you. I don't really believe in "intermediate developer" as a definition. Just figure out where you are on the Frodo/Rico scale. 
Yeah, MDN also has info on things like which browsers support a given feature and documentation of upcoming features which aren't yet in the spec.
The same disadvantage that comes with writing your own version of any existing library: while it might meet your needs now, it's likely that your needs will change in the future. If they do, you'll either have to build more and more of your own fake DOM library, or you'll have to switch to a more robust one. By starting with a robust library now you avoid any of that. Also, the people that write these libraries likely create mocks which are closer to the originals than what you would create on a first try. But if you only need to test a few things, you know that's all you'll ever need to test, and you know your home-brew mocks are good enough for your tests, then there is absolutely no need to use a library like jsdom.
LF (`\n`) works fine everywhere. CRLF (`\r\n`) is only needed for Notepad compatibility. Seriously, that's it. Even Win9x's `edit.com` was fine with LF. No idea how to change it with Atom, but with VS Code it defaults to LF (`"files.eol": "\n"`).
strings are arrays. you can save yourself a lot of typing by just writing: var arr = "abcdefghijklmn"; //arr[0] == array[0] and have the same exact array (albeit a different type). from there it's return arr.indexOf(x); 
 input.split('') can be written as: [...input]
A quick, real-world example for HTML (the 2nd answer quotes the spec): [Correct value for disabled attribute](http://stackoverflow.com/questions/6961526/correct-value-for-disabled-attribute) And a longer, JS example: [JavaScript Closures - Using the ECMA Spec, please explain how the closure is created and maintained](http://stackoverflow.com/questions/15117687/javascript-closures-using-the-ecma-spec-please-explain-how-the-closure-is-cre) Many people have written untold numbers of articles about what a _closure_ is, but a majority of them just show a simple code example and then explain the crux of the matter -- which is fine, for a basic understanding. But sometimes you run into something unexpected, or you simply yearn to learn "how it really works"; in those cases, the spec is there for you. You might need to read a specific section several times, and you might need to research some of the terms used, and if you want to dive really deep, you may learn about some concepts like [Backusâ€“Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form), etc. If you actually learn what you read from the spec, it's not time wasted. Rather, it's the difference between reading a summary of an article and the full article itself. The summary will give you the main points, but the article (spec) will fill in all the details. Sometimes those details aren't important, and other times they are. Take this library [fast.js](https://github.com/codemix/fast.js), which implements JS functions -- in js -- which are faster than the native functions. How is that so?? Well, they don't fully adhere to the spec, which means that they cut corners to produce a more efficient implementation (see the "Caveats" for how/where they do this). It might be that you have a performance bottleneck in your code somewhere, and you could re-implement it yourself and make it faster -- but you have to know which parts of the spec that you need to keep, and which to disregard.
In my experience `assert` is typically used to defensively guard an API so a developer gets instant feedback when using it incorrectly. This is sort of a "hack" to get around lack of type safety. Imagine I am on your team an provide a utility function that cannot accept `null` args. With an `assert` the function can throw an error that tells you which function / argument / whatever has a problem, and as a developer you get instant feedback and can fix the issue immediately. Without an `assert`, you as the developer might get a more misleading error. The idea is, in production, you have already fixed any API misuse issues, and so the `assert` calls are now unnecessary. If you are using the `assert` calls to actually throw errors that are meaningful in the usage of your application, it might be best to create your own specific errors, or just don't compile out your `asserts`.
Forget redux and ask yourself when you would want a shared memory vs message passing abstraction. Share memory is going to work well when the access time is low and the number of processes you're coordinating are few. This is the runtime environment we have in the browser so Redux works very well there. But, if you tried to use Redux on the server (or servers) you'd find that the shared memory model breaks down at scale and becomes a global choke point for the performance of your app. In this context the overhead of message passing is worth it because it allows you to build a sane distributed system. 
We use it at our work. Not Serverless, but Lambda's and API Gateway. Works really smoothly for us.
I didn't get what you mean. Can you elaborate a little?
The iOS wi-fi icon is in the Android screenshot, and the Android icon is in the iOS screenshot. 
[removed]
That is default on iOS and Android actually, not from NativeBase.
WHEN THE JS GODS DICTATE
Classes in HTML elements are just identifiers. They're different from id's in that multiple elements can have the same class name while ids are unique to one. There is no respective "btn" or "submit" or "go" javascript class implementation backing these elements behind the scenes. That doesn't mean javascript isn't having some influence over this element, as, given its class name, it could look it up in the dom and perform operations on it. But you can't make any assumptions about that given the class name alone. 
sure, an optimal WebGL impl will be faster, no argument there. but the DOM can get you really far, and after that SVG can get you further still. it's a neat experiment, regardless.
I guess that makes sense. The way the article was worded made it seem like they were looking at job location, not where people lived 
there's little to go by here. are you using mousemove? are you throttling and/or using requestAnimationFrame? are you using CSS transforms or setting top/left css? you should put up a jsfiddle that exhibits the problem for you. without it you're unlikely to get anything but generic advice.
I use the mousemove event for the canvas to drag images around. I also use mousemove to change top/left of divs. And finally I use mousemove to trigger the scroll event, but the scroll (unlike the others) is smooth. I don't use requestAnimationFrame.
ok, so here's that generic advice: set CSS transforms (translate) to set the position instead of top/left, use requestAnimationFrame within your mousemove handler, do not manually trigger scroll events from the handler.
? I'm aware, sassy-pants. but for this use-case those distinctions are irrelevant. 
Ok I just tried with an event listener on mouse click (click the button) and then stepover, I just stepped over about 400+ times before giving up, hitting play to make sure the button still works after clicking a billion times still works. This is brutal lol, is there anyway to set up a listener from when a button clicks to list all functions that are called / where they are located or something similar? I think there must be just thousands of lines of code (weirdly) as stepping over is going to be impossible.
This article looks interesting, but it's giving the impression that recruiters are fighting for talent, and it's a developer's market: &gt;So what does it mean? In short, if youâ€™re a tech specialist with front-end development skills under your belt, congratulations: youâ€™re very unlikely to be unemployed. On the other hand, if youâ€™re an employer looking to hire JavaScript developers, sit tight â€” it will probably take a while until you find the right person for your company. &gt;The combination of high demand and insufficient supply of a certain type of tech workforce almost always means the same thing: the lucky few in possession of the required skills are going to command high salaries. This statement certainly holds true when it comes to JavaScript developers, who, according to Gooroo, have some of the highest tech salaries in the US at an average of nearly $96K per year. How does this compare with posts from programmers saying there's no skill shortage, and they are losing work to H1-B visa holders who will work for 50,000USD per year? I'm neutral, I have no viewpoint to push, but they can't both be right. I'm sure these statistics are true for high end, qualified seniors... but articles like these make junior job hunting sound easier than it really is. Can anyone give an honest, unbiased answer? 
Hi /u/abhiaiyer, you've [previously been warned](https://www.reddit.com/r/javascript/comments/3qpvmt/work_estimates_vs_noestimates/) for spamming `simplecast.fm`, and now you're just spamming `medium.com/@abhiaiyer`. Consider this your last warning, for any site. 
Hey Kenman, sorry for the misunderstanding. I just wanted to post an informational blog post on several subreddits. Is that not okay?
[removed]
https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript
That's a good point :O
Thank god. One of my favorite parts of playing this game is when I can blend my recreational and professional passions. If anyone reads this article and doesn't quite pick up the "magic" part, play this game enough so you can see the magic take place. The amount of web technology used to create an incredible desktop experience is absolutely something to study. Seeing this game evolve not just as a game, but as an interface experience, has been absolutely inspring. 
Very late! Also just finished a prototype for an idea I've been working on. It lets you navigate your typescript project and can find dependencies that you might miss. It also allows you to save the diagrams, which could be used to highlight dependency problems to others. If you have some typescript you'd like to draw up, I'd love some feedback. https://github.com/SpyR1014/ts-depDraw installation is `npm i -g ts-depdraw` use: `ts-depdraw &lt;filePath&gt;` from project root.
Yes, that Android icon is of Material Design actually. We have added the support for Material Design too in this version.
you're recursively setting the value of a. `set a()` doing `this.a = val` is calling set again (recursively). That's why setting it to something other than `this.a` inside `set a()` works. I personally see no need for getters and setters if all you're doing is returning/setting the value. I'm curious what use case you have where doing `const thing = new Thing()` and `thing.a` doesn't work.
Thank you for feedback! Do you remember what you had done right before this happened? Maybe changed preferences in MenuTube? Does restarting the app help? Are there other issues since then, or only icon related? If you know how to use CLI, try to remove config file with: (or if even better to send its content to me, then remove) ``` rm /Users/&lt;your user name&gt;/Library/Application\ Support/menutube/config.json ``` I ll try to do certain fixes and improvements this weekend, that might help to resolve your issue. Please check https://edanchenkov.github.io/MenuTube/ for a new release at the beginning of a next week. If removing config won't help, you can always try to simply remove the app and install it again.
The same reason why Best Buy has "best" in its name: marketing.
Damn those Â« Open Source Â» Advocates and their fallacies against Free Software licences. AGPL is not Â« closed Â», APL is not Â« really free Â». They just hate copyleft because it prevents capitalists to steal software and code from the community.
None. Pay $10,000 to your nearest coding bootcamp. 8 weeks later employers will be beating down your door. EDIT: Most likely 1-3 years, 6 months minimum.
If you know Java, you could try Spark (http://sparkjava.com/) with c3p0 (for MySQL connection pool) and gson for serializing to JSON.
Doug might have named it so because he took some design ideas from Java language, but modified the syntax to make it suitable for scripting.
&gt;refrain from answering "measuring skill" please, because objectively, they measure generic computer science knowledge and not field-associated skill Measuring basic computer science competency is probably the point though. If you've mastered the basics and understand datastructures/algorithms and how to implement them in javascript then you have the building blocks to solve problems at the job. A lot of employers want strong essentials as a lot of domain-specific knowledge for an entry-level web developer may need to be relearned anyway on a new stack. They want flexible developers. You'll notice that Facebook and Google have frontend engineer interview questions on glassdoor and they all involve similar types of questions. 
idk which language you are looking for. But here a small bullets list : (Classed by 'Framework to build' to 'Automatically generated') **PHP** * [Lumen](https://lumen.laravel.com/) : The simple version of [Laravel](https://laravel.com/) with powerful routing and ORM * [Limoncello-flute](https://github.com/neomerx/limoncello-flute) : The reborn of [Limoncello](https://github.com/InactiveProjects/limoncello-collins) * [MicroRest](https://github.com/marmelab/microrest.php) : A small DB to Rest using [Raml](http://raml.org/) as modeling language **Javascript** * [Fortune](http://fortune.js.org/) : Not a rest framework but a powerful ORM for node * [Restify](http://restify.com/) : A small Framework to quickly build restful api in top of node * [SailJS](http://sailsjs.com/) : Framework with similar mind with Lumen * **[Feathers](https://docs.feathersjs.com/rest/readme.html) : A well designed framework to build webservice (including Rest)** * [Hapi-Raml](https://github.com/dave-irvine/node-hapi-raml) : A raml plugins for [Hapi](https://hapijs.com/) [Further here](https://github.com/marmelab/awesome-rest)
It's broken for the Windows browsers in Win 10. It works fine even for the obsolete Safari in Win 7. The idea is that new browsers do not break old Javascript code for the next 50 years. But here they did already. I just can't stop thinking how they frustrated the entire browser business from the very beginning. Making pages from the competition look deliberately ugly and all that.
As someone who fell in love with Python n10 years ago, has programmed many ML projects with it, and is currently using JS in both his professional and personal life for the past couple of years: Python. You can definitely do all the same stuff in Python, but **there is no equivalent to NumPy/SciPy for JS**. There is math.js, but it's not at the same level. Aside from that, you have literally TONS of tools out for data crunching with Python. I have done data-crunching with Node, it's not a painful thing, but I really missed having NumPy's useful data types and functions. **A huge point for Python is the existence of matplotlib.** Plotting options in JS are just not that good. At all. Have a look at the fantastic SciKit toolset for Python. Nothing short of amazing.
[Looks like it's the tethering icon](http://i.imgur.com/BZPcbo0.png). Just pointed it out because I'd never seen it before.
seems great!! where can I find some performance benchmark results?
The specification is written in a formal academic way so it can be confusing to grasp but most of the time you have tables like [this](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-toboolean) that are straight forward. There are resources that translate in a pretty awesome way the specification like [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) so you can have a look into that as an alternative.
Wow, didn't realize you were on a Chromium based app for your new client. Awesome !
Why would you add negative connotations to the word "capitalists"?
Don't push yourself to unknown territory if you don't have a use case. Find a use case and then build it. Learning things for the sake of it wasted years of my career. Think of an React app, plan it, build it with all the tools that are needed to hit your aim and nothing extra. As a great React courses I highly recommend one by Wes Bos. https://reactforbeginners.com/ Was goes through he procedure slowly and explains every single step really well. You wont need any complicated things. Code editor, node + npm installed on your machine. The output will be fully working great React app that will give you a great foundations to build another project (great opportunity to learn new things). If you are not familiar with npm, don't worry. It is very simple to use and it comes with great documentation full of videos. https://docs.npmjs.com/ There is another tool worth to know about called yarn. It does the same job as npm with minor differences that you don't have to care about (yet). Be stick to one of those... https://yarnpkg.com/en/ This one is a great one as well. Don't be scarred by the price. When you sign up on this website they will give something line 95% discount for all courses :) https://www.udemy.com/react-redux/ Main thing. USE CASE, IDEA then BUILD. Don't read docs for the sake of it, you won't remember it tomorrow. Practice is a best teacher.
We use Ionicons here in NativeBase and that's [the icon that they have for WiFi](https://ionicframework.com/docs/v2/ionicons/)
Absolutely. Plotting is a big thing as well. Don't forget to mention that. Matplotlib.pyplot is absolutely amazing. A pleasure to use and extremely flexible. Also, the big plus is that NumPy will be well-maintained for a long time. I can't say the same about the JS-equivalents (not that I know of any that truly measure up to numpy's impressive feature-set).
Ah, 2012.... so many memories
For me, it's like writing with a pen and paper vs. keyboard. Sure, your typed words might be more accurate, but written notes are faster and less constrained. It just feels less "clunky", if that makes sense. [Here are some other thoughts.](http://softwareengineering.stackexchange.com/questions/122205/what-is-the-supposed-productivity-gain-of-dynamic-typing)
Well at least you can write trees of everything and everywhere. Seriously. It's historical choice of the past. Nobody going to make JS typed. Google tried with strong mode. They did discard it because internals of JS was too much evolved and complicated to make everything typed. But yet, welcome to the TypeScript! It's neat, try it!
As someone who has conducted technical interviews and asked people to implement linked lists on occasion, all I'm interested in is to see how you think. I want to see how you approach the problem and your attitude towards it. I don't care if you don't know how a linked list works - ask me, draw pictures on the white board, write some tests first. Show me how you might approach a problem that you're not familiar with already. That's why those questions are asked. 
It's much easier to track changes on MDN than on Wikipedia which is I can't even imagine how many times bigger in scope. 
It was newer version of firefox iirc.
&gt; how do you approach abstraction, or how would you balance maintainability with a team I bet I could find a dozen people that would have elaborate answers to those questions but fail at FizzBuzz.
&gt; It's much easier to track changes on MDN than on Wikipedia And therefore it's even less an issue.
Really great stuff here!
Jeeze. A little harsh? This seemed like a legitimate question. I had similar inquiries when I was first learning JavaScript moving from java, where all I knew was strong typing. It can seem a bit strange to someone new to the environment. 
You don't talk like a senior dev, though. Most senior dev that I talk to are always calm, rarely vent, and always know that everything has a reason. Most of the time they don't even call themselves senior devs even though they are great. I personally think that you shouldn't self proclaim that you are a senior developer, it's up to the people around you to decide.
Have a function which expects A, but you pass B. You have some object and try to access a non-existent property (e.g. you made a typo or you assumed the object is of a different type). TypeScript's and Dart's analyzer can catch this kind of mistakes.
Most interviewers don't interview regularly and make things up on the spur of the moment. "Hey, John. Come in and interview this guy." In my case, I've done it for over 30 years and can call it in if I had to. I know exactly what to ask and can spot the little nuances of the response including the girl who leans on the table letting her boobs bulge over the top. (Really happened) Some interviewers ask questions to show how the interviewer is better and smarter.
What bootcamp is only six weeks long and only charging $900? Are you sure you aren't talking about somebody's garage?
For a few years now it has seemed that finding good senior level developers is difficult. Plenty of junior devs though.
&gt; It just feels less "clunky" With TypeScript and Dart, type inference does almost all of the work. Well, you have to annotate your functions, but you should document the types anyways. Compared to doc comments, the type annotations are much terser. Also, now that the types can be inferred, you can auto-complete almost everything. There really isn't much drag in practice.
The JS tool chain these days is the most interesting, biggest and fastest evolving out there. Period. There are plenty of tools for debugging, static code analysis and testing
&gt; JavaScript &gt; the compiler can prevent a while pile of errors for you. &gt; the compiler can prevent &gt; the compiler &gt; compiler No compiler
Well, I didn't mean any specific bootcamp, but I can see you too found the important part. But put your hand on your heart and tell me that learning `proficient` javascript is not possible within 6 weeks.
interview questions suck because firing people is expensive. it takes months of building a record of bad behavior or underperformance before most companies feel safe and justified in letting someone go. that's a month of HR's time a month of a manager's time sometimes some coworker's time and all the while you have to pay the bad employee you want to get rid of. because it's so expensive to fire people, companies make sure they hire the right person, because *letting 9 really good candidates slip through your process is still way cheaper than hiring and firing 1 bad candidate.* because of this, companies try really hard to vet interview candidates. unfortunately this is really hard to do even for companies with infinity money like google and apple. it's almost impossible for a business struggling to grow and survive. so they do their best and often end up with a process that they dislike and you hate but really is about the best they can justifiably make given all the constraints of their business.
Just In Time
&gt; Since i can presume you are novice or just foolish, i should feel obliged to tell you to learn soft skills. dude what. the irony of this is just. i mean wat.
Thanx a lot!
Haha no. But it didn't make sense to me at first, having known only java. Personally I love it now. 
Excellent idea! :)
It isn't and the six week $900 bootcamps you're describing don't exist. However, someone can definitely learn enough from an actual bootcamp to be qualified for an entry level job front-end job.
Hi /u/theKrogster, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
For an import to be dynamic, all it really needs is for the import statement to allow a string expression. So far as the syntax goes, our current syncronous imports could be changed to be dynamic with full backward compatibility. What this spec is really changing is allowing *asyncronous* dynamic imports. Fine. Great! I'm suggesting we use the keywords we're already adding to the spec for a bit of consistency.
No it isn't. You have to convert it to a serializable type. That's not the same thing.
The convention is usually a single underscore prefix, e.g. `_a`. Pre and post exist in some native properties such as `__proto__` or `__defineGetter__` etc. (using 2 on each side of the identifier), but that's a little overkill for your own properties, and would also then potentially clash with something already there such as those I just listed.
&gt; I personally see no need for getters and setters if all you're doing is returning/setting the value Overriding is the main reason. You can't override a simple field, but you can getter/setters. class Thing { constructor () { this._a = 10; } get a () { return this._a; } set a (value) { this._a = value; } } class SubThing extends Thing { get a () { // override return super.a * 2; } } var t = new Thing(); console.log(t.a); // 10 var s = new SubThing(); console.log(s.a); // 20
So can unit tests which are much more valuable imo
Because that's how they were interviewed. They're looking for people like themselves, traditional CS people. They also think that is what makes a good front end developer, no exceptions.
I guess you've never heard of Tern which does everything you say without needing TypeScript or VS...
"The recruiters-who-use-grep, by the way, are ridiculed here, and for good reason. I have never met anyone who can do Scheme, Haskell, and C pointers who canâ€™t pick up Java in two days, and create better Java code than people with five years of experience in Java, but try explaining that to the average HR drone." - well said
Hey, you must have installed the dev deps. Go for `npm install plow --save --only=production`. The minified lib itself is 2kb of code...
&gt; "Good tooling" refers to things like context-sensitive auto-complete, call-tips, go to definition, find uses, renaming, and type checking. You listed not thing that cannot be done with JS "only", given that you're willing to dive into a nodejs based tool chain. Keep calling those tools poor while my startup puts the competition far behind with those exact tools. But I've learnt that talking to TypeScript people is pointless. Arrogant backend guys who are lost when there's no IDE that wipes their asses for them and who start to cry as soon as a files doesnt start with keywords like namespace or class
TIL about $_, neat!
Javascript doesn't compile. I haven't seen any grave problems stemming from dynamic types. Yes, they can get in your way in rare occasions, but such errors are trivial to find and they're not what makes writing applications a challenge. The upside is that they are very flexible. I've read studies last year that found no evidence whatsoever for applications being safer strictly typed and i've made the same experience. On the other hand, linting, proper state management, unidirectional flow, live editing, hot module reload, ternJS/intelliJ/nuclide/... these things make your app safe in ways types never could nor are there tools in the native landscape that give you this kind of experience. And of course, types are optional. If you need them, install Flow and you have a sound typing system that detects deeply nested cases. Or Typescript.
Sorry I respectfully disagree based on my experiences at various companies contracting and hired. If you're doing JavaScript professionally, TypeScript doesn't seem worthwhile at all. For instance tried to help a developer a while back with TypeScript and Angular that was dying when running unit tests when a specific file was included. The mess of hooks transpiling behind-the-scenes and butchering the source maps made it near-impossible to track down the exact problem (turned out to be something with the way TypeScript behaves when using ES modules and AMD/UMD w/ third party includes). I'd rather test JS running through a JS test runner and get precise stack traces and line numbers. If I pass a supposedly invalid value (number) and the function produces a valid result: \`${input}px\` then you've intentionally broken part of what makes JS great in the first place. Now I'm also using Babel which may seem hypocritical, but the surface area of what it affects can be so much smaller. For instance I only use the JSX and ES Modules transforms, changing code you don't want to test anyways. Babel also has a retainLines feature which is nice since it formats the output to ensure that lines match 100% w/o the need for unreliable Source Maps. Anyways just a different perspective. If JS added type annotations with host warnings in strict mode, I think that could be a nice compromise.
Riot's engineering blog is one of my favorites on the Internet. They have a way of explaining themselves and their architectural decisions that just mesmerizes the nerd inside of me. It also, in my opinion, reads easier than a typical engineering blog because it's in the context of a video game which is intrinsically fun. I'm glad to see one of their articles here. I highly recommend [their series](https://engineering.riotgames.com/news/running-online-services-riot-part-i) on the containerization of their infrastructure for anyone interested in the practical use of Docker.
They may work better, but saying that JS can't be properly analyzed is just false.
Quite a lot of type information simply isn't available. What you can do with static analysis in JavaScript is pretty limited. With any non-trivial program there will be countless blind spots. With TypeScript and Dart, you only need a few type annotations at the seams and type inference will figure out the rest. E.g. if you query the DOM for some element, you have to tell the analyzer what kind of element it is. E.g. if you say it's a canvas, then the analyzer will know that this got a getContext method and that this returns a CanvasRenderingContext. And this context got drawing methods etc. Without telling the analyzer this crucial bit of information, it won't be able to infer the rest and you also won't be able to auto-complete all of that.
I am avoiding the new client for as long as possible. Last time I tried, the performance was total garbage. :-(
You're talking about different things. Your IDE doesn't magically get insight into the browser's APIs just because you use TypeScript. Sure they have predefined information about that type (probably out-of-date already), but you could just as easily do that with Tern, and in fact, it already does work with Tern. Demo: http://imgur.com/a/x7QOE Sorry, but you're talking out your ass here since you've already made up your mind about TypeScript and what it supposedly gains you.
Please do us all a favour and put that advice in your CV.
when you say replace loops, do you mean just replace "for" with $.each($el, function() {});? 
If you are a sole developer it's one thing, if you are on a team though it lets everyone work from a common understanding and level. If you write something to say populate a list as a formatted ol/li from a json file chunk pulled from a database there's a number of ways to do it, but will the 20 other people on your team have to all learn your way or can you all agree on a framework and stick to it as to not amass technical debt?
Don't need to: I've been highly successful in a steady, high-paying development/architecture position for well over a decade and I've been a gainfully employed professional developer for around 25 years in total. Clearly I'm doing something right whether you or anyone else think so or not.
This looks like a class assignment. Why don't you have a go doing it yourself instead of trying to get the internet to do your homework for you?
That's great for you! It probably means you could be even greater by using tools. But do whatever you want and accept that people can work the way they want.
Tragic conventions and tools choices. Literally the worst choices for starters. Hopefully nobody will come up to this article when learning to code in JS.
Would you mind expanding on that? I'm kind of a standardjs hater but I never heard of the other tools before. What's wrong with those?
So no linter, no type checking and no tests. &gt; PRODUCE SHIT! Probably, yeah.
Standard: http://perso.ens-lyon.fr/jean-michel.muller/goldberg.pdf Edit: Good to also see all implementations confirming to IEEE specs. They've pretty much always done this correctly though.
Adding a framework will increase technical debt. Sometimes more than implementing the stuff yourself. You don't add anew angular2 dependency if you just want to display a simple list.
Funny how people just assume that the rest of us can't produce good stuff without crutches. One of us probably can't, but my guess is it ain't me buddy.
If you think you're above fizzbuzz, then fizzbuzz is working from my perspective. :)
because capitalists are garbage
Thanks :) I haven't prepared one yet, and it is not correct to compare DOM and WebGL directly (you can check the comment above).
I understand that, I guess i'm just a bit frustrated that there are so many frameworks/libs (that do the same thing) being activly used and required for front end positions ergo there's no standard / to many standards if that makes some sense? I will probably jump right into it and hope it becomes more clear then.
Thanks! Only thing I would add is a Yarn lockfile and perhaps an editorconfig to match some StandardJS conventions.
First and foremost: Do not use libraries you don't need. Second and equally important: Learning what a framework/lib does gives you the knowledge to determine whether you need it or not. ABL; Always Be Learning Every framework and lib is a tool. By familiarizing yourself with them you add a tool to your toolbox. As you get better at this you will be able to evaluate new tools quicker to see how they differ from the tools you already have. Then you can make the reasoned justification for adding it, replacing a tool you already have, or ignoring it because you're already familiar with something that does the same thing. Where this analogy breaks down is when you try to compare things like Angular and React and jQuery. They aren't equitable because Angular is a MVV* framework, React is a view framework, and jQuery is a library for manipulating the DOM. They have different goals and are functionally independent. Something like React isn't trying to replace jQuery, it just so happens that the way React works makes jQuery unnecessary and counter-intuitive. At their core they're just trying to make things easier for you. They are the result of a substantial engineering effort to solve common problems and popularize new patterns. edit: If you're also curious about why there are so many libraries that do singular things it's because modularity and composing various modules to do what you need is a very flexible and extensible way of developing applications.
 &gt; 0.1 + 0.2 === 0.3 false &gt; (0.1 + 0.2) + 0.3 === 0.1 + (0.2 + 0.3) false IEEE 754 is just like that. It's like that in any language. That's how our hardware works. Floating point is an approximation. It's good enough for most things but it's certainly not perfect.
Ok, I guess the pdf was a bit too much; JS internally uses double precision floating point numbers for all numbers, so everything you see is correct and expected (you just don't know it's expected). Again as for why, I suggest googling "floating point math" (the pdf linked is the "standard" answer, but it's also quite heavy I guess) If you want 6 + 0.81 to yield 6.81, you'll need to use an arbitary precision math library, like this one: https://github.com/MikeMcl/big.js/ 
Thansk!
Pad that out a bit, find a loosely-relevant full-acreen image, and throw that on Medium. I think we have this week's "Everything you think and do is fundamentally wrong" ragebait article. For extra points, give it a snappy name. "Zero-conf JavaScript: Shut up and code, already"
When I started I was mostly just a LAMP stack guy. I learned modern JS dev (node, react, etc.) on the fly. So I got a mid 90s salary for very little JS knowledge at the time. I expect to be bumped up into the low 100s soon. I will say I studied very hard this year and am much, much better at JS now. I would think you could do much better than 62k. I do have a comp sci degree and a MBA. Who knows if that matters? Do you have a degree? People without one usually get lowballed.
Sure, glad that helped. You might want to read through the rest of the presentation, which gives an overview of web dev history, and talks about the major tools and concepts used in modern web dev. Also, FYI, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics.
Find bug in multiprocess/message queues based Python scraper using a Tornado/Flask based server backend with multiple database drivers and a Webpack packaged mixed ES6/ES2015/LESS web client processed with Babel and lots of plugins. Now close all your browsers, pull the network plug, open your Notepad++ and fix that bug. You've got one hour. Eh-eh-eh, no cheating! No Developer Tools debugger, no rebuilding with source maps to see what line in the original non-transpiled, non-minified source code threw that exception, no documentation lookup, not even Stack Overflow, just Notepad and hands on the keyboard. Yeah, right. This isn't about acing some high school math test using just a pencil and a protractor, this is about getting stuff done, in complex projects, where everyone including the build bot uses lots of tools all the time. TL;DR: Harsh sarcasm. In today's web dev world, you simply don't get very far (at least not very fast) without at least a modicum of tools and (API) documentation, unless you never work on any other projects besides the ones you designed and built yourself.
You could look up what the bits in a floating point number represent and then you'll see that some numbers can't be accurately represented by it. The number you see in a debugger is a visual representation up to a certain decimal precision. And sometimes a number quickly receives enough error through arithmetic that the visual representation picks it up.
But you're making the assumption that all of that was necessary to build that project in the first place. I would argue it may not have been (or maybe only some of it was). You have to go back to first source. Yeah, I'll concede that if you're coming into a project you may not have any choice in the matter. Fair enough. But the point is that if everyone always thinks they automatically need all this complexity, whether they actually evaluate whether they do or not, then that's what creates the problem and it gets perpetuated when everyone is thinking that "setting up a basic dev environment" requires all of it as a matter of course because that's what all the latest blog posts say.
This is cool and all, but you need to talk first and foremost about what kind of javascript you are going to be writing. Are you going to be writing a node / express JS project, or are you going to be writing a webpack / bower / gulp / grunt client side project? Both are going to require a slightly different set of tools, but the distinction will be very important. The big difference will be how you are going to manage modules.
Hey sorry this was more meant as a proof of concept I am currently reading through the YDKJS books and covering getters/setters and was just having a bit of trouble understanding this particular feature :). Sorry should have been more explicit.
I dont look up to facebook or google lol they can do things wrong as well
Nice. Did you get the idea from this guy? http://macarthur.me/typeit/
what do you think medium posts are? what does a sr dev sound like?
Yeah these strawmen are such horrible developers. Let's keep bashing them to validate ourselves.
A lot depends on the current state of the project, and not all projects need all the tools recommended by the "batteries included" starter pack blog posts out there. But to suggest that all you need is to open an editor and start typing is taking things to the extreme. It would be better if blog posts spent more time on how to select the right tool for the job and less time on cramming every imaginable tool in there. There are some posts which try and do this, but they do tend to get drowned out by the "look here, new, shiny!" kind.
good, realistic reply. thank you. I actually got a little python script running today doing some of what I need, but I think the codecamp is a good idea.
Thank you for that repository link, i'm sure it's going to be useful. really appreciate the information js and it's lib &amp; framework eco system always felt like a strange beast to me compared to the non web programming languages.
And let's just keep throwing out the names of logical fallacies that you don't actually understand the meaning of in an attempt to look smart.
I might argue your statement that it's too extreme because the underlying principle (that actual understanding is key and there's no better way to do that then working as low-level as possible, at least early on) I stand by... but I very much agree with your second paragraph so I'd rather focus on that agreement :)
Native position: sticky is now supported in all modern browsers but Edge. Unless you absolutely need to have events for when the element becomes stuck, I don't see a reason to handle this in JS.
Its initializing the instance variable with the default value. This avoids any side effects that would result from going through the setter. And while you don't have any such side effects from Thing itself, SubThing could implement them, or you could have a conflict as you attempt to use variables before they exist. Constructors would ideally only initialize values and not really _do_ much, if anything at all. class Thing { constructor () { this.a = 10; // sets through setter } get a () { return this._a; } set a (value) { this._a = value; } } class SubThing extends Thing { constructor () { super(); // calls a setter, accesses _b before defined this._b = 2; } set a (value) { // override super.a = value * this._b; } get a () { // override return super.a; } } var s = new SubThing(); console.log(s.a); // NaN If you have special, complex behavior that you want to run the value of `a` through before setting it, you can handle that in a "private" method that would not be overridden by subclasses. class Thing { constructor () { this._setA(10); // isolated behavior } get a () { return this._a; } set a (value) { this._setA(value); } _setA (value) { // ... other stuff ... this._a = value; } }
Ahhh okay I think I follow you, I think I need to delve into the es6 class syntax a little more the `super()` function and `_setA` private methods are new to me, but as for not causing any side effects be using the setters/getters in the constructor I see what you are saying.
The context is relevant I suppose
`_setA` isn't _really_ private. But the underscore prefix is what hints to that, just as with `_a`. It's saying, "don't use this variable unless you're in the context which defines it". JavaScript doesn't explicitly support private variables (yet)... though there are ways to hide them within closures if you're so inclined (of course doing so creates other hurdles to overcome). So by convention, an underscore prefix is used to indicate private variables so people will know to treat them as so even though they're really not. The main point is that, if people are potentially overriding things, there's potential for breakage further up the chain, so you may need to protect from that. This generally isn't too much a problem for the basic objects you're working with now, but it might be something that comes up when learning about classes later. 
I'd like to avoid using any plugins or frameworks... is there a way to convert that to raw javascript code?
 function c3(s) { let a = new Array(26).fill(0); for(let c of s) { if (++a[(c.charCodeAt() | 0x20) - 0x61] === 3) { return true; } } return false; } console.log(c3('aabbcc')); // false console.log(c3('aaabbcc')); // true console.log(c3('aabAcc')); // true Lol. Yea, that's not really helping, is it? :&gt;
I use .spec.js sometimes. It makes it easier to find the tests with a fuzzy search (ie - ctrl+p in sublime, type half my module name and spec, and I can open the test file from wherever I am). Of course that wouldn't require you to use two dots. But it works. 
It's not about trusting the language. It follows the implementation specs.
I have had a personal portfolio since 2006 and a github account since 2010. I'm on my fourth job since 2006 and I've done a couple contracting gigs for a local agency, so I guess you could say I'm on my fifth job since 2006... At every in-person interview I've been to (including jobs I did not take or were not offered), I've always asked if the interviewers looked at my portfolio site and github. Only one person has said yes and that was to my github account. He was the engineering manager who actually got in touch with me after he moved on to another company. One person. IMO, this seems to be more due to really poor planning at these companies. I can't tell you how many people have actually been reading my resume when I first meet them. Most constantly refer back to my resume during the interview and apologize for not even reading much of it, or any of it, in advance. Note: job 1 was a mid-sized software company, job 2 was a global behemoth, "job 3" was the contacted work through local agency, job 4 and 5 enterprise-land software companies. Your mileage may, of course, vary...
Honestly, this guide is very unhelpful. The only part that actual talks about the "dev environment" is about installing two dependencies with the only reason given is "no config needed". Is the only benefit we get that we don't need to config anything? How do these tools compare to others? Does it support ES6 or above? Is this only for Node/Express projects? There is no discussion of why we should use these tools as almost half the article is writing a contrived example that proves that this setup actually works. If you're going to write a guide about setting up a dev environment, you should dedicate more than a paragraph to the actual setting up of the environment beyond doing the same old npm install incantations.
regexp var count = 0, counter = function (x) { count += 1; return x; }; myString.replace(/a/gi, counter);
Haha this is awesome! Someday I hope to also be able to perform such arcane wizardry. 
Thank you so much! That looks awesome haha, and I think I can learn a lot from it too
what does files linking mean?
And in particular, when the question was put to the Advisory Committee (the steering committee for the W3C, with one representative per member company) of whether to continue work on HTML or shutter it and only continue work on XHTML2, the browser reps voted to continue working on HTML, and were outvoted by the rest of the members. Which is why those browser vendors then started the WHATWG.
That is better.
If you want to do something for web you can easily use npm packages.
In my 15 years of professional programming, I can't recall floating point ever being an issue. It's more of an issue if you're doing scientific computing, where you have to start being more aware of how the mechanics of computations actually happens in hardware (like the [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for adding FP numbers together). This is also why for instance that JS has Number.MAX_SAFE_INTEGER as well as Number.MAX_VALUE. Edit: It's not really about trust, it's just you learning what programming really is about. It's not about reality. It's about modelling reality and being close enough that it works for most stuff.
This is a mixture of plain/vanilla JavaScript and jQuery. First, what is jQuery: it is a library, written in JavaScript, that provides some useful methods/etc, it is often denoted with the $. It is nice for newbies to use because it simplifies a lot of initial challenges with JavaScript. So looking at your code, the first thing it does is create a new variable (called $rows) and set it to equal to the DOM element(s) [could be 0 to n elements] that matches '#table tr', with jQuery functionality wrapped around the element. The "#"-sign means find any DOM element (e.g. &lt;div&gt;, &lt;a&gt;, etc =&gt; an element is anything wrapped with &lt;&gt;) that has an Id of table (e.g. &lt;div id="table"&gt;&lt;/div&gt;); and then find any &lt;tr&gt; elements under that, so it's requiring two criteria (e.g. it would find all &lt;tr&gt; elements in this scenario: &lt;div&gt; id="table"&gt;&lt;tr&gt;this tr would be found&lt;tr&gt;&lt;tr&gt;this tr would be found&lt;/tr&gt;&lt;div&gt;it would not find this div&lt;/div&gt;&lt;/div&gt;). The second part of the code, it does the same thing as $rows = ... did above, except it looks for any elements with an Id of 'search' and binds what is called a 'listener' to the 'keyup' function. Again, these are jQuery methods (under the hood of that function, it is executing further functions in plain JavaScript). So, what the listener does is say, "when the Id element of 'search' is currently focused, and any key is pushed and then released (e.g. keyup), execute the function specified =&gt; this is often called a 'callback'). Now looking at the callback, all it basically is doing is trimming the search box with a regex, setting the search also to lower case text, and then filtering the search results ($rows) by first showing all the rows available, and then hiding them again if they don't pass the filter. Hope that helps. Good luck!
Interesting that's another for the list, very helpful.
Who gave this answer gold lol
This is all wrong? `npm install` installs the package but doesn't add it to the `package.json` file. Add `--save` and it adds the dependency to the above mentioned file. If you use webpack it will bundle the requires / imports of your program into a bundle which contains those + the code you wrote. If you use SystemJS you will have to copy your required / imported files somewhere your server serves static files. Your post is full of outdated / malformed information
As people have said, floating point. But here's a nice video about it https://youtu.be/PZRI1IfStY0
I do agree with the kiss mentality you're embracing, but good lord does cmd+r after every change get old. At least throw some sort of automated browser refresh in there (live reload, browser sync, webpack dev server). Edit: I noticed node; nodemon.
I believe he means script tags
It's an artifact of trying to represent decimals with 1's and 0's. If a language follows a different standard than the IEEE 754 floating point standard, it will have other issues. There are tradeoffs no matter what. No floating point system can be perfect with our current computer architecture. 
People, let's not downvote. This person is asking perfectly reasonable questions and just wants to learn. If their views are incorrect, just be nice and correct them. There's no need for pettiness and downvotes. edit: wow, some folks really don't care about the human on the other side. I wish you'd come round, honestly.
I guess it's true that you can't write a generic serializer for an ES Map. However, any data structure is serializable.
I'm still amazed that we're seeing ES2015 (ES6) articles, 2+ years after the spec and features were announced.
I recommend you to look at this, it's not about JS specifically: http://0.30000000000000004.com/
This is hilarious. Thank you!
I didn't downvote (not sure who did), but the concept would remain the same. I could fuzzy search for module name + test instead of module name + spec. But yeah, you could achieve the same thing with `module-name-test.js` or something like that. But I suspect the ability to search and/or the ability to pass in globs (`**/*.test.js`) to testing frameworks would be the intent behind having a special naming scheme.
Yes I am familiar with CSS transitions, but our teacher wants us to use jQuery for the assignment.
http://jsbin.com/cuqipuk/2/edit?js,console const string = "aabsccAds", count = {}, amt = 3; let moreThan3 = false; string .split("") .forEach((char) =&gt; { char = char.toLowerCase(); count[char] = count[char] ? count[char] + 1 : 1; if(count[char] &gt;= amt) { moreThan3 = true; } }); console.log(moreThan3); 
You're gonna be really upset. Or at least I was, because I spent the last 10 minutes yelling at my computer. Change it to left: '250px'. Apparently, it's the direction you're moving away from, not to. I'm gonna go cry. EDIT: http://codepen.io/anon/pen/zNbgjp
That's such a dumb statement. Of course anything is serializable if you first convert it to an actual serializable type. 
ya but don't you feel it's more important to use/do what you love with the technology that you love than following market trends and use whats in demands etc ? Where are you in Canada ? im thinking to moving to Ottawa maybe to go work not sure yet, currently I am a network/system admins and there isn't a tons of jobs in this small region so thinking about moving to a large city but not sure feel like going back to programming too 
Hiya: np! Kind of like this, maybe? https://www.reddit.com/r/MachineLearning/comments/56s2oa/discussion_machine_learning_wayr_what_are_you/ At one go you can see the links for previous weeks, and quickly click and see what's been posted during the past week(s). I am subscribed (these reddits) via RSS feeds, so once a week I get them, click, and then they're buried (by new feed items).
It's not the direction you're moving to, nor the direction you're moving from. The object you create in there: { right: '250px' } Is what you want that element's properties to become - but you want it to animate towards that. Animate in this respect is exactly the same as setting `$(this).css()`. It's just slower.
The browser vendors are a surprisingly small fraction of the W3C membership, and their voice there isn't at all proportional to their impact on the Web.
We can disable it.
A very cool script. Was looking to do this earlier. 
Besides keeping everything in one file, is there any other compelling reason to use single file components? I know you can just use the runtime only build instead of the stand alone version, but what's there other than that? I'm currently using single file components (mostly because of server side rendering), but still keep my CSS separated. Before that I would just do ``` export default Vue.extend({ template: require('./template.html'); }) ```
Wicked! :-D
cool.
I mean, we still see map, filter, reduce articles and those features came out like 5 years ago Â¯\\\_(ãƒ„)\_/Â¯ 
We have the technology.
&gt; Then how do you know it was a good thing? I said XHTML and XML were good. Version 2 I didn't get into. &gt;XHTML had nothing like what is being developed today. Cause they stopped development on it. Or is it a chicken and egg thing. Not sure. Don't care anymore.
Scoped CSS.
It had nothing like it because the kind of thing we're developing now is exactly the opposite of the kind of thing that the people working on XHTML back then wanted to do. Today's work is very imperative, with APIs at various levels, deeply integrated into the DOM and JavaScript processing models. XHTML2's approach emphasized semantics, was declarative, and had an extension model based on vague promises of RDF ontologies, which to this day has yet to be proven as a workable technology for application development.
463 bytes followed by npm install babel.
Awesome. Will use this for background animations in my game. (It should be easy to plug it with canvas objects).
It's still possible to create situations where the garbage collector can't reclaim memory. It's getting harder but it's still possible.
Using your favourite* `compose`, `split`, `sort` and `zip`**, it's concisely expressed as: const chrDiff = (a, b) =&gt; a &lt;= b ? -1 : 1; const strToSortedArray = compose(sort(chrDiff), split('')); const hasTriplicates = compose( sorted =&gt; zipN(sorted, sorted.slice(1), sorted.slice(2)) // whoops! had to roll a `zipN` to help out here. see the demo link. .some(([a, b, c]) =&gt; a === b &amp;&amp; a === c), strToSortedArray); [Demo](http://ramdajs.com/repl/?v=0.23.0#?const%20zipN%20%3D%20%28...ls%29%20%3D%3E%20%0A%20%20range%280%2C%20Math.min%28...ls.map%28prop%28%27length%27%29%29%29%29%0A%20%20%20%20.map%28i%20%3D%3E%20%0A%20%20%20%20%20%20%20range%280%2C%20ls.length%29%0A%20%20%20%20%20%20%20%20%20.map%28j%20%3D%3E%20ls%5Bj%5D%5Bi%5D%29%29%3B%0A%0Aconst%20chrDiff%20%3D%20%28a%2C%20b%29%20%3D%3E%20a%20%3C%3D%20b%20%3F%20-1%20%3A%201%3B%0A%0Aconst%20strToSortedArr%20%3D%20compose%28%0A%20%20sort%28chrDiff%29%2C%0A%20%20split%28%27%27%29%29%3B%0A%0Aconst%20hasTriplicates%20%3D%20compose%28%0A%20%20sorted%20%3D%3E%0A%20%20%20%20zipN%28sorted%2C%20sorted.slice%281%29%2C%20sorted.slice%282%29%29%0A%20%20%20%20%20%20.some%28%28%5Ba%2C%20b%2C%20c%5D%29%20%3D%3E%20a%20%3D%3D%3D%20b%20%26%26%20a%20%3D%3D%3D%20c%29%2C%0A%20%20strToSortedArr%29%3B%0A%0Aconst%20xs%20%3D%20%5B%0A%20%20%27aabbcc%27%2C%0A%20%20%27aaabcc%27%2C%0A%20%20%27aabAcc%27%0A%5D%3B%0A%0Aconsole.log%28%0A%20%20xs.map%28s%20%3D%3E%20%5Bs%2C%20hasTriplicates%28s.toLowerCase%28%29%29%5D%29%29%3B%0A) - * my favourites come from [Ramda](http://ramdajs.com/). Check it out, it's great. - ** watch out for lodash's `zip`, it's broken imo
Five years ago means that people stuck supporting legacy user agents because of backwards clients (I'm looking at you, major banks...) might just be getting to the point where they might be able to use these features in production code!
what? you don't need babel
[removed]
Why does 'hamster' contain 'ham' when it has nothing to do with pigs? :D
There is a standard. Only older template-oriented frameworks (Angular, Ember, Aurelia, Vue) bring their own. Newer frameworks like React, React-lite, Inferno, Preact, Mithril, Kivi, Bobril, Deku, Vue2.0 and many, many others, they all base on the same principles and they all can share a pretty good amount of code. Some of them you can plug in and out with a simple alias. This has to do with the functional user-interface paradigm. The simple idea that UI can be expressed in a function that takes data and returns a layout: const SayHi = ({ name }) =&gt; &lt;span&gt;hi {name}!&lt;/span&gt; ... &lt;SayHi name="world" /&gt; SayHi is a re-usable component. You can use it everywhere, you can share it, extend it, it could be tied to a data-store, it can be more complex and react to events, it can use Javascript to create dynamic output, etc. 
[removed]
If you're using a language like Java, everything is a class. That is a lot of overhead that I don't necessarily need or want. Annotating functions and writing type definitions is pretty much the same level of effort.
Yes, basically. Instagram is a complex app, it needs more study and tools to get there. [Research es6/7](http://exploringjs.com/es6/index.html#toc_ch_first-steps), the latest javascript spec. Research and install Node. It doesn't just do things on the server, it will be your local build environment. Research npm, Webpack and Babel. Then frameworks. There are many, find out what they do and how they differ. At this point you will know already how to proceed.
[removed]
I'd like to take that course if it exists. Think you're missing the point, which is to ask thought provoking questions within those areas. Not just tell me what testing means, but how would you test x type of feature? I've experienced first hand that it's much more likely that somebody could slip through by studying the basic CS interview questions you google. 
JavaScript indeed started out as a tool for manipulating the DOM (essentially the web page document) on webpages but modern JavaScript has completely turned that principle on its head. Frameworks like Angular and React use JavaScript to generate the DOM in its entirety. Your HTML page becomes just a few short lines to bootstrap your app and JavaScript will take it from there. The advantages of doing it this way are that you have full control over when and how to render things to the page, giving you things like change detection for free. NodeJS lets you run JavaScript outside the browser - it is a port of Google's V8 JavaScript engine to the native operating system. This means you can write native applications in JavaScript. One major benefit is that this means a full-stack web developer can use the same programming language throughout their entire stack: from the server all the way to the client-side front-end code.
&gt; Is there more to it? You betcha. These days you can do anything with js. It's not just a client side language anymore. You need to get a newer book.
[removed]
(moment(n, 'MM/DD/YYYY', false).isValid() || moment(n, 'YYYY/MM/DD', false).isValid()) 
A first good reading : http://www.hammerlab.org/2015/12/09/our-experiences-with-flow/
Your code sucks as much as ours does. You just can't smell it
Could you expand on what you mean by static guarantees? I don't really understand much about what import vs require makes possible.
it's different &gt; Template literals expand on creation. This module expands the template on execution, which can be useful if either or both template and data are lazily created or user-supplied. which mean you can't do something like : `const str = somehowGetStringFrom()` and render the str later. similar to https://github.com/sindresorhus/pupa
this module is already precompiled
Couldn't you make the same argument by adding a thunk layer around the template string? (props) =&gt; `some tpl using ${props}` I guess that doesn't serialize though 
One obvious problem I can see is that you can't transpile ES6 within a template, e.g. vegito(` &lt;div&gt;{{items.map(item =&gt; item)}}&lt;/div&gt; `, {items: [1,2,3]}) Another problem is that it can't handle basic nesting vegito(` &lt;ul&gt;{{items.map(item =&gt; [ vegito("&lt;li&gt;{{name}}&lt;/li&gt;", item), // blows up ])}}&lt;/ul&gt; `, {items: [{name: "aaa"}]}) 
No need for loops. http://codepen.io/anon/pen/rjbmgR?editors=0010 But please do your homework by yourself next time.
As far as I'm aware the main benefits of BublÃ© over babel are speed, lack of configuration and, as it says on the site, it "limits itself to ES features that can be compiled to compact, performant ES5 (plus JSX)". The dependencies of your dev dependencies don't really have any impact on your final code - Ava, for example, might compile your tests with babel, but the actual production code on your site will be compiled with BublÃ©. 
Several years ago, my brother was creating a game in PHP (it was his second coding project ever). At some point, he asked me to review his code. It was basically separating concerns by putting everything that logically related to each thing in single files (so yes, CSS/PHP/HTML all in one file). At the time, if you asked any developer, this would be considered a horrible abomination. I told him it looked fine. He went on to finish his game and eventually moved on to other projects. The end. Interpret as you wish.
ok ... I think I have actually made life a little simpler, but still suffer the same issue. Here is a JSFiddle ... what I am wanting to achieve is that the search box (or a dropdown selection next to the search box) filters the table based on the select option selected in the table ... I hope that makes sense. https://jsfiddle.net/a3r3sdo1/ In other words, when Approved is searched for, that the other rows are filtered out. 
Import and export statements are independent of state and you can't use anything but literal strings as imported path. Also they can only be on top level and not inside of functions. This means whatever you do before or after doesn't change what they mean, so you directly know every imported and exported symbol after parsing the file
The analyzer will ensure that they pass the right kind and number of arguments. Non-nullable types are also neat. If your function asked for a Foo (and not Foo | null), you won't have to check if it's null.
yep, the source is around 3xx bytes, it's 463 bytes after gzipped, and about 531 bytes when compiled.
You'd have to run it for a-z, though.
yep, that's why it's limited to `micro` and `simple` but it does have use cases. p.s. I tweaked it a little bit to make it support **multi-line** (it does support ES6, depends on your environment), so your first example works now.
Yeah, that's my actual plan for the future, like twists, color changes and more :D PR are welcomes ;)
&gt; string.split('').forEach(char =&gt; {...}); You can just use for-of for this: for(let char of string) { ... } Now you can also simply use a return inside the loop.
how about user-supplied string? 
I do have some projects using JSX.
I understand this point. The production code are the main goal. But, we are going into a world when dowloading a total of more than 100 dependencies are not a problem. But for me this looks like a problem. I know, we do not need to reinvent the wheel, but for [a small project](https://github.com/Swizz/snabbdom-pragma) including only : ``` "devDependencies": { "ava": "^0.17.0", "babel-plugin-transform-react-jsx": "^6.8.0", "buble": "^0.15.2", "rollup": "^0.41.3", "traceur": "^0.0.111" }, "dependencies": { "extend": "^3.0.0", "snabbdom": "^0.6.1" } ``` The yarn.lock is already around 2875 lines at least 558 npm packages downloaded !
Would you mind sharing some examples, by any chance?
Sorry didn't noticed that. You could still use it if you don't mind the performance hit. "abcdefghijklmnopqrstuvwxyz" .split('') .some(char =&gt; threeOrMore(char, 'YEAH javascript!')) 
WTF that's so cool.
Found it pretty helpful not only because of saving me from stupid mistakes, but also because really cool integration with IDEs and text editors (at least Atom). It was my dream to have smart autocompletion in JavaScript for a long time:) So, I would certainly recommend using Flow with any size of projects you have.
That lockfile is for dev deps. Your actual deploy is likely two deps. Far cry from the hundreds you speak of.
Thank you for all the help. Could you provide an example of a bookmarklet that would do this? If not it's ok. Thank you. 
1.4 If you use rest, you get the arguments as an array. `arguments` is array-like and passing it around may cause deoptimizations. You have to use slice or whatever to turn it into an actual array.
I will try it out. Thank you for all the help. I'll let you know the results of what happens. Thanks!!!
Not really. I like BEM as well, and still use it with Vue/React, but scoped CSS is inherently superior. For a large site you will _always_ run into namespacing issues eventually (so you have to have absurdly long, ambiguous names to make them unique). Whereas with scoped CSS, if you have 5 different header components in different parts of the site, they can all use `.header` because it's scoped. You'd be surprised I think at how much this helps readability. Example. Before: .this-specific-section-specific-type-of-header { // stuff } After: .header { // stuff } Remember, that absurdly long class name will be all over your markup as well, especially in BEM.
&gt; you won't have to check if it's null. I only check if it's what I expect (and if not there will be an error message). No need to check what it should NOT be.
really nice. But it should also have vertical ordering of items. Some labels (+colors) would be nice too
Hi /u/wileymarques, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt; it does support ES6 It limits the usage of ES6 to the supported environment's level of support. This is different from supporting ES6. Babel can't know that any given string contains code, and thus cannot transpile it. In my first example, the compiled function runs *if* the environment supports arrows, but throws otherwise. Similarly, if I had used a complex destructure, it might or might not have thrown depending on what browser you're on, regardless of whether you have Babel in your toolchain. A library that supports ES6 would go through Babel transparently and still work in any old environment that it claims to support, but vegito introduces a caveat that effectively negates Babel's raison d'etre. That's kind of a big deal. I like minimalist solutions too, and in this case, I'd choose to go with a function + a template string, since it has much better tooling support, supports nesting, has more informative stack traces, works w/ Typescript, etc etc etc. The exact formatting and amount of syntax noise at the beginning of the template itself is, imho, a somewhat superficial concern compared to the amount of concerns covered by the slightly more syntax-noisy function+templatestring combo &lt;/2-cents&gt;
Oh for sure. I honestly dont enjoy J2EE all tht much. If given the opportunity, I would switch to Node right away. I am in Toronto. I recently graduated from a school in Ottawa, and the tech scene is pretty nice there as well. You also have Montreal not too far. Shopify, Alcatel, Ericsson are all pretty big in Kanata. But yes, I def think you wanna be doing what you like, but we also gotta consider the opportunities available. 
You can use user-supplied strings, no problems. That's an orthogonal concern. Say you have: var t1 = vegito("hi {{greeting}}", userData) vat t2 = (greeting =&gt; `hi ${greeting}`)(userData) There's nothing inherently unsafe in either line. To be able to run arbitrary code here, `userData` would have to be something with a malicious toString or something like that. But if the attacker could do that, they already have access to modify code elsewhere. Now take this code: var t1 = vegito("hi {{ (function() { for(;;); })() }}", userData) vat t2 = (greeting =&gt; `hi ${ (function() { for(;;); })() }`)(userData) They both freeze because the malicious code is in the template. But if the attacker can put malicious code there, then, again, they already have access to modify code from somewhere else. The key here is that even though you can write executable code in the *template* in both systems (and this is a feature), you can't elevate a *user-provided* string to run as code. Ironically, there was a thread about minimalist templating a while back, and it turned out that the function-compiling implementation had a vulnerability due to how destructuring parsing works. [This is the thread](https://www.reddit.com/r/javascript/comments/5nbvub/a_simple_template_parser_how_about_this/), and [this is my comment showing the security hole](https://www.reddit.com/r/javascript/comments/5nbvub/a_simple_template_parser_how_about_this/dcaf4ij/). Your implementation happens to be secure, but as you can see, clever small code can be vulnerable in very unintuitive ways that truly simple solutions don't need to worry about. Re: an API for babel, yes you could pipe the string to babel before you pass it into `new Function`, but then you've got this huge, slow runtime, and at that point, other solutions will start to look a lot more attractive.
hmm yeah that makes sense but I'm not talking the security issue, my question is, if user-supplied code is `'hi ${greeting}'` how do you evaluate it using template string? you're still using `new Function` anyway
and this &lt;code&gt;var tpl = data =&gt; \`hello ${data}\`&lt;/code&gt; is hand-coded not user-supplied
It's not really something I can define in terms of years (though my HR department would disagree.) I know some brilliantly talented people with less than 2 years "experience", and I know some absolutely talentless people with 20+ years "experience". For a mid-level dev, I'm looking for the equivalent knowledge of a bachelors degree in software development + at least 6 months experience in a dev position at a reputable company. For a senior-level dev, I'm looking for the equivalent knowledge of a masters degree in software development + a personality that will help foster growth in our team (i.e., mentoring, leadership, etc.). My opinions are not the same as many other major companies. Lots of places do still have degree and/or years of experience requirements for certain job titles. And to be honest, I probably would have the same requirements, if full-stack Javascript was taught in colleges, or if it was possible to request 5+ years experience with Angular2. 
Thank you so much for all this info. Now I know how powerful js can be, I'm more determined to stick with it for months and try new things over and over. I previously just brushed it off as something that will just make buttons work or open message alerts. That's where I probably got stuck, I jumped right in to the deep end. I know you probably have things to do, but I would appreciate it if you get any free time if you could link me a couple books with more info on learning JS, given its more modern usability, and whatever that es6/7 thing is!
You're thinking about this all wrong. You aren't sending data between "files", you're having a browser app send data to a server app using either ajax requests or through form submission. I'd look up some tutorials on building a node js web app
What do you want the output to be in this case? `tpl` would give you `hello hi ${greeting}`, which is what I'd expect. If you want it to output something like `hello hi john`, then we're talking about user input sanitization. You should not allow the user to write `${anything}` or `{{anything}}` and allow that to run as code. Because, again, the user could write `{{ (function() {for(;;);})() }}` and freeze the app. Typically, for things like that, you define some sort of very restricted set of conventions, e.g. maybe the user would write `hi [NAME]` and then in your code, you replace the substring `[NAME]` with the appropriate data. This is what templated-email services typically do. Some systems offer more powerful mini-languages (e.g. Liquid), but they are implemented in such a way that they are still severely limited in scope. But you cannot expose the full power of the host language to the user, that's just asking for trouble.
&gt; the user could write {{ (function() {for(;;);})() }} and freeze the app this is like doing XSS in your own browser. Sure it should be trusted data.
[removed]
You can't do that, what you are doing is technically not possible and doesn't make sense. Node has no way of knowing when user clicked somewhere on the page because it's being executed on the server. So to get that data to Node, you need to use AJAX. You need to understand this, otherwise you will get even more confused further down the road. I don't have a good tutorial to recommend, but you need to research the basic concepts some more. Good luck! P.S. Unrelated: Look into the "event delegation" keyword, you don't want to do what you did with the click event listener on your table.
All assignments consume memory regardless of where they occur and whether or not something consumes memory does not necessarily indicate a failure to reclaim that memory. The problem with global references is that they are easily clobbered, which means they can be easily reassigned by other code without your knowledge, and thus break your application. I would not worry about memory consumption too much. JavaScript is a high level language and you have absolutely no control how it allocates or reclaims memory. You do control how references are accessed, though, which grants limited control on when GC attempts to reclaim memory from a resource. This is largely in regards to external APIs, such as: the DOM, animations, and file system, and so forth. The bottom line is the more frequently garbage collection runs the less performant your CPU intensive or high frequency tasks become leaving a sawtooth graph of performance failure in your profiler. Further reading * http://stackoverflow.com/questions/864516/what-is-javascript-garbage-collection * http://stackoverflow.com/questions/18364175/best-practices-for-reducing-garbage-collector-activity-in-javascript * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management * http://javascript.info/tutorial/memory-leaks
You and tmartioiz just saved me a lot of time and frustration. I'll look into using AJAX for this and I'll look up event delegation too. Thanks.
yup, and handling external libraries manually without tools like npm.
it's only really a spectrum if you consider any explicitly categorized collection to be a spectrum 
~9000
The real power of javascript comes when you discover the type of language it is. Javascript sometimes gets some hate, but I believe that stems from people treating it like more of procedural language (which it totally can be) but I believe javascript really shines when you embrace the power of reactive or functional programming. If this response seems a little complex, check out some videos on functional or reactive programming and give it a go! Some other cool languages like that are f# and Scala!
I believe something like this should work, thought I'm not sure what the point of your second `catch` is if all your first `catch` does is `throw`. var Observable = Rx.Observable; function xhr(url, json) { return Observable.create(function (observer) { $.ajax({ url: url, data: JSON.stringify(json), success: function (response) { observer.next(json); }, error: function (jqXHR, status, error) { observer.error(error); }, complete: function () { observer.complete(); } }); }); } var request$ = xhr('/echo/json', []); const req$ = request$ .flatMap(result =&gt; { console.log("inside 1st flatmap"); if(result.length &gt; 0){ console.log('success'); return Observable.of("success"); } else { console.log('throw'); return Observable.throw(); } }) const requestCatch$ = req$ .catch(err =&gt; { console.log("inside 1st catch"); return Observable.throw(); }) const requestCatchCatch$ = requestCatch$ .catch(err =&gt; { console.log("inside 2nd catch"); //If I come here then I want skip the next flatMap and jump straight to subscribe() return xhr('/echo/json', ["from 2nd catch"]); }) const lastFlatMap$ = requestCatch$.flatMap(result =&gt; { console.log("inside 2nd flatmap"); return xhr('/echo/json', ["from 2nd flatmap"]); }) Rx.Observable .merge(requestCatchCatch$, lastFlatMap$) .subscribe(result =&gt; console.log("result", result));
That's a given already, as it's probably the single most breaking change that could ever be applied to JS. Just about every website using JS would instantly break. So that's never, ever, ever even a remote possibility, making the point a bit useless to make don't you think? Regardless, whether it's his writing, or the sheer impossibility of making JS itself typed, I can't really recognise that 'point' in his comment.
Looks pretty unsafe up there...
Here's what I've told all my friends to do. 1) To learn the language syntax, use Nodejs. Now, I'm not talking about making web servers or anything, but It's a nice quick way to run some js programs to learn the basic ins and outs of JS. 2) Pick an app Idea you'd like to make, could be a Todo, could be anything you feel comfortable with and then I'd suggest youtube for more tutorials. Just watch, within a month, I'm willing to bet you'll have made something that you not only feel proud of, but learned tons along the way! Then It's onto your next idea!
 function check(s) { const counts = s.toLowerCase().split('') .reduce((acc, curr) =&gt; (acc[curr] = (acc[curr] || 0) + 1, acc), {}) return Object.keys(counts).some(key =&gt; counts[key] &gt;= 3) } console.log(check('abcabc')) console.log(check('abcabcabc')) This first creates a histogram that maps each character to the number of occurrences in the string. It then checks whether any letter has 3+ occurrences. Note: this *does* use ES2015.
Every time I see this image I feel like a 'jack of all trades, master of none'. Or ' master of some' I would like to think :)
Very interesting! Thank you.
Here's a really basic way to do this: http://codepen.io/lemmin/pen/KNaVpJ
That's awesome!
Read the full article, it's amazing!! Thank you very much for sharing it!!
Read the full article, it's amazing!! Thank you very much for sharing it!!
Why is rails and node in here?
Yeah, that's the question I'm asking; what does the OP mean by "powerful"? Short of mathematical properties like turing-completeness, that's not something that's very easy to quantify.
I tried flow for a few weeks but ended up using typescript instead because of better editor support, tooling and added benefits like es6 features. Also regular JS is already compatible so you can gradually add more and more typescript. Another thing is that its supported by your current stack. Anyways flow is neither bad nor is typescript superior. I think it depends soley on your project, your team and the amount of coffee you drink per day. I started with flow because I thought the added type support would help our project in the long run and it certainly did but typescript fit the team better. Type support is definitely worth it and in my humble opinion it makes fun. A lot of fun. So go for it if your team is fine with flow or typescript.
Hi /u/kenman! Sorry for the inconvenience, it won't happen again :D
First of all thanks for the very complete response. This is not for homework! Now i like the idea that you said that you could create a database and store file,content,link. I think this is a clever idea. I will try to work on this but not with Javascript. I think i can use either php and mysql or aspx and sql. My initial idea was to have a process run multiple times a day and have it read and make an inventory of all pages. It will then write a flat file with all &lt;divs&gt; and page names and all relative links. This first process could be run in powershell (which i am good at). Then have that file being loaded through javascript and search it. At this point i was or still am not too concerned about scalability and because of that one reason, i thought of venturing to seek for wisdom here in this subreddit. I don't anticipate the .html file count to grow past 5 but now that you mention databases, now it is a very different strategy. Now my questions (and i will be googling all afternoon) is how to query and process data dynamically... This will provide a good solution after it is done so other people can benefit from what i will be developing. Thanks kindly for taking the time to help me take a step back and see the bigger picture! 
If the initial connection is not encrypted, it could easily be intercepted and modified as anyone sitting between the browser and the server could perform a MitM attack without requiring installation of rogue certificates. Because of this, it would be possible for an attacker to send to the browser code that replicates your codes behavior but then sends the session id to the attacker's server, allowing them to impersonate your user. Writing the encryption code isn't at issue, you could use something like [sjcl](https://github.com/bitwiseshiftleft/sjcl) but since you can't guaranty complete control over the executed code, this would pointless.
Average users have a much higher chance of knowing what the downside to sharing their location or allowing notifications are. They probably wouldn't have any idea what CORS was or what the downsides could be.
tyvm!
This is not the best way. Or the simplest way. Or even the easiest to read way. But it is another way. var chars = "aababc".split("").sort(); var threeOrMore = new RegExp("(" + chars.filter(function (x, i, a) { return a.indexOf(x) == i; }).join("{3,99}|") + "{3,99})","i").test(chars.join("")) console.log(threeOrMore); &gt;&gt;true 
The questions are useful, the answers not that great. I have a feeling it was someone's course assignment.
Preach! That sub won't load on mobile for some reason. 
Angular (1 at least, don't know or care about 2.0 or whatever they are calling it these days) have these factors that played a roll in my reasoning to abandoned it: 1. Scope management does not intuitively act as js closures do. One cannot necessarily have access to higher level data from within, even when using transclusion. This came up numerous times when trying to make a directive that contained an ng-if around an ng-children. React does not suffer from this due to its use of standard js functions and closures. 2. Renders from directives must be valid html, because Angular uses actual dom, not a virtual dom. This prevents the ability to transclude only part of a table, and if I remember correctly, you also can't create a directive that renders to a table internal such as tr. Same goes for other dom parts with strict allowed tags, like ul and li. Complex tables were nightmares in Angular, either forcing hacky css (display:table-row on divs, removing the ability to use colspans) or limiting the ability to break up the table's parts significantly (massive directives that had more than one responsibility). Asking on the official site how to do this, the response from the Angular team was, "yeah, that's not possible." React is immune to this problem entirely. 3. There is no built in way to do multi-transclusion or otherwise control where directive-wrapped code goes. React gives full control over what happens to children dom from within the component. Also, because it is just js, React also has other options available, such as passing in the results of a render to a component, or passing a callback to a function that can do rendering when called, delegating specifics as desired. 4. The api was hilariously unstable. Our remaining Angular codebase runs on Angular 1.2 release candidate 3. An attempt to bring it to Angular 1.2.0 (the NEXT version) was abandoned due to the large number of breaking changes. Let that sink in. The final release candidate (not alpha, not beta) had BREAKING API CHANGES when transitioning to release. Protip: that's not what release candidate means. Meanwhile, React's API is largely unchanged since the original public release. Breaking changes come in the form of how things operate, not their syntax, and mostly only for edge cases near the dom layer (such as ref). Any breaking changes are warned to the user in the console for at least one version before the new behavior becomes mandatory. 5. To do anything in Angular, you had to have dom to attach the behavior to. This led to massively deep div trees, because every nested ng-if and ng-repeat-while had to have their own attachment points. Well, not all of them did, but you had a hard time keeping track of what could be collapsed and what couldn't as the scope and transclusion rules of any given directive varied non-transparently. Meanwhile, since React is just js, and functions can naturally wrap other functions, React is capable of calculated behavior via components without itself rendering anything. Zero-cost components, if you will. This has been used for per-component css injection and js-controlled layout without deepening the dom tree at all.
Weird. Try their site instead https://privacytools.io/ or check out the /r/privacy wiki: https://www.reddit.com/r/privacy/wiki/index#wiki_quickstart_for_privacy_technologies
Weird, every time I see this image I get an aneurysm thinking about how all of this will be irrelevant in 1 year. 
Thanks man. 
My pleasure!
EDIT: This isn't as long as it looks. It's mostly code blocks. ---- We keep trying to explain closures with analogies. Personally I find closures easier to understand by getting closer to the concrete details. #### Function objects We say JavaScript's functions are function *objects*. A function object is an object that you can put a pair of parens after and invoke ***as if*** it were a function. Python let's us do that. For example: class CallableObject: def __call__(self): print('I\'m an object and I was called as a function.') instance = CallableObject() # Call object as if it were a function instance() Also in PHP: class CallableObject { public function __invoke() { echo 'I\'m an object and I was called as a function.'; } } $instance = new CallableObject(); // Invoke object as if it were a function $instance(); And we can do the same in C++, which JavaScript engines are implemented in. In C++, that special method is spelled `operator()`: class CallableObject { public: auto operator()() { cout &lt;&lt; "I'm an object and I was called as a function."; } }; CallableObject instance; // Call object as if it were a function instance(); That's a function object... an *object* that you can call *as if* it were a function. #### Storing state Like any other object, function objects can be constructed with and store data in private fields. In Python: class CallableObject: def __init__(self, n): self.__n = n def __call__(self): print(self.__n) # Construct with the value 42 instance = CallableObject(42) # Object has value 42 and can be called as if it were a function instance() # 42 In PHP: class CallableObject { private $n; public function __construct($n) { $this-&gt;n = $n; } public function __invoke() { echo $this-&gt;n; } } // Construct with the value 42 $instance = new CallableObject(42); // Object has value 42 and can be called as if it were a function $instance(); // 42 In C++: class CallableObject { private: int n_; public: CallableObject(int n) : n_{n} { } auto operator()() { cout &lt;&lt; n_; } }; // Construct with the value 42 CallableObject instance {42}; // Object has value 42 and can be called as if it were a function instance(); #### Closures It may not look like it, but we've already implemented closures. ;-) Consider this JavaScript: function outer() { const n = 42; function inner() { console.log(n); } return inner; } const inner = outer(); inner(); // 42 `outer` and `inner` are both function objects that store data from their surrounding scope. We could achieve the same result without any special lambda/closure syntax in Python: class Inner: def __init__(self, n): self.__n = n def __call__(self): print(self.__n) class Outer: def __call__(self): local_n = 42 inner = Inner(local_n) return inner # Create outer function object outer = Outer() # Invoke outer to create inner function object inner = outer() # Invoke inner function object inner() # 42 In PHP: class Inner { private $n; public function __construct($n) { $this-&gt;n = $n; } public function __invoke() { echo $this-&gt;n; } } class Outer { public function __invoke() { $localN = 42; $inner = new Inner($localN); return $inner; } } // Create outer function object $outer = new Outer(); // Invoke outer to create inner function object $inner = $outer(); // Invoke inner function object $inner(); // 42 In C++: class Inner { private: int n_; public: Inner(int n) : n_{n} { } auto operator()() { cout &lt;&lt; n_; } }; class Outer { public: auto operator()() { auto local_n = 42; Inner inner {local_n}; return inner; } }; // Create outer function object Outer outer; // Invoke outer to create inner function object auto inner = outer(); // Invoke inner function object inner(); // 42 Of course, writing it out this way is really ugly and verbose, so we certainly *like* when a language provides a lambda/closure syntax. And frequently that nicer lambda syntax is just sugar for generating and instantiating a callable object. In PHP: $n = 42; // Sugar for defing a class with an __invoke and a private $n // and immediately constructing an instance of that class $closure = function() use($n) { echo $n; }; $closure() == $closure-&gt;__invoke(); In C++: auto n = 42; // Sugar for defing a class with an operator() and a private n // and immediately constructing an instance of that class auto closure = [n] () { cout &lt;&lt; n; }; closure() == closure.operator()(); In JavaScript, that special lambda/closure syntax is... the function itself. In JavaScript, *every* function is one of these function objects. Every function is a closure. Though, whereas PHP and C++ have you specify a capture list (such as `use($n)`), JavaScript's function closures instead capture the entire scope.
no worries there. Just get a rough idea and you will get a job. The idea of these interviews is to make sure you know "=" vs "==" and short hand arrow functions with "=&gt;" and promises. there are too many libraries to test on individually, so dont expect anything on those. I would also say that the rough idea of components would also come up. So write a component that counts down from 10. Nothing more complex than that. Most JS guys are glued to google due to lack of documentation of features, being to new, etc. And hiring managers should know that. 
Thanks. Gonna read it later. 
I set up a rogue WiFi hotspot at a Starbucks somewhere. I give it a confusing name, so a bunch of people start connecting. Now, if anybody makes a request over plain HTTP (GET, POST, whatever), I can modify the data as I please. I control the WiFi access point, so all data flows through me. If you do your own crypto scheme, you are going to have to run code in the browser. That code needs to *get* to the browser somehow, and somehow is plain HTTP in your scenario. When the browser requests `custom-crypto.js`, my rogue WiFi hotspot can return a fake version with whatever tweaks I like. I could disable the RSA key checking (or just swap your key for mine). I could also tweak your code to forward any sensitive information to my own servers. The sky is the limit. The only way to avoid this problem is to *already have* trusted code running on the client. For that, you have three options: * Use the browser's built-in HTTPS code. * Have the user install a browser extension. * Use custom crypto for some stuff, but serve all HTML and Javascript over HTTPS. Otherwise, there is no point even bothering with encryption in the first place. You might as well just send the data in the clear and pray that nobody is tapping the connection.
Isn't it yet another tracker ? Piwik is open-source and you can self host it.
I signed up for code school last week and have completed all of the node/angular tutorials there. I was hoping for challenges more like fizzbuzz that frequently come up in interviews.
Does that give you CSS linting?
 let myFunction = (a, b) =&gt; new Promise((resolve, reject) =&gt; { //doSomething })
It sounds like you're nudging towards a Diffie-Hellman key exchange. DH is a well used, well tested and cryptographically sound method for key exchange. By using complex mathematics and large primes, it can prevent an intercepting party from determining the keys, even if they're sent in the clear. Your issue will come from the initial page load - it's insecure, and it is at this point an attacker can change the scripts you receive to thwart any encryption you're about the use. This definitely comes under the "interesting but not useful" category of ideas. 
I know how to code in HTML5, CSS3 and Sass but my JavaScript is basic to non existent right now. So i did some research and i figured that it would be a good idea to learn from different sources at least that way i can cover all the bases and i get a comprehensive learning method. I will gain knowledge from each tutorial, apply it and then use flash cards and practical projects for muscle memory and training. Your Speaking JavaScript book has good reviews which is why its on my list for reading material. I think the others are above my level right now. &amp;nbsp; **Free tutorial websites** Codecademy Free code camp **Paid tutorial websites** Treehouse Lynda Codeschool Udemy **YouTube** JavaScript Tutorial https://www.youtube.com/watch?v=fju9ii8YsGs Object Oriented JavaScript https://www.youtube.com/watch?v=O8wwnhdkPE4 **Books** Object-Oriented JavaScript, 2nd Edition 2nd Revised ed. Edition Head First JavaScript Programming: A Brain-Friendly Guide 1st Edition Speaking JavaScript: An In-Depth Guide for Programmers 1st Edition **Resources** https://developer.mozilla.org/en-US/
Who are they?
I think it's important to make a distinction here, between the programming language Javascript, and the browser environment. I'd gonna presume you're talking about the browser environment here, with JS being the language you use to interact with it. You're quite right that originally JS was only meant for simple DOM/page manipulations. However, that was 20 years ago. Nowadays, the browser has access to GPU acceleration (even for GPGPU use cases) via WebGL and the Canvas, microphones, webcams, and gamepads (like an Xbox Controller). Basic CPU multithreading is possible via Shared Memory buffers and Service Workers. With optimisations like ASM.js, performance is also approving, exceeding 90% native C++ speeds in some cases. Using nothing more than the browser environment and JS, you could create applications that perform internet video chat, video and image editing, audio editing, realtime collaborative spreadsheet/slidedeck editing, and more. Even advanced pieces of software like the Unreal Engine (a popular video game engine) can run natively in the browser. So, in that regard, the browser environment has become exceedingly powerful over the last few years. ---- With regards to JS the language, as others have said, any Turing-complete language can do anything another Turing-complete language can do, provided it has the same access to externalities such as hardware and the operating system. Therefore, it is common to measure the 'power' of a language by how naturally/succinctly one can achieve a given feature using that language. In that regard, I've found JS to be wonderfully expressive, especially with the recent additions to the language (spread/rest operator, etc). So, in that regard, JS is 'powerful'. ---- That all being said, JS and the browser environment are not perfect, there are quirks, and at times a sharp learning curve. But in terms of what can technically achieve, the ceiling is pretty high.
A group of volunteers who care about privacy. It's all crowdsourced, open source, and available under a CC or GNU license. Suggestions and contributions go through Reddit and Github.
The code for HTTPS is baked into the browser, along with the certificate store. Therefore, a rouge WiFi hotspot can't mess with them. The rogue hotspot can *try* messing with HTTPS traffic, but then the checksums wouldn't be valid and the browser would refuse to continue. So, with HTTPS, the worst an attacker can do is stop the connection going though, but not decrypt or modify information.
My Crytography profession in college told me one day "always remember algorithms are not the same as implementation, never roll your own version of AES, RSA, etc" because there is so much to consider besides the algorithm itself. Things such as timing attacks and more. Please use a well documented library even if you don't want to use HTTPS (which has been broken itself even)
I tried to write my books that way: The idea is that I explain something abstractly and then show an â€œinteractiveâ€ exploration of that idea â€“ what you would type in if you were sitting at a computer. That way, itâ€™s a bit a like a video: something you can watch/read while offline, even without a computer. The books are free to read online, so you can check whether you like my style or not: http://exploringjs.com/ (Apologies for the self-promotion, but that really is a core principle behind my writing.)
Im on mobile so I can't post the link easily. But project euler is really good
Yay for immutability!
There's nothing wrong with that. You can put whatever code you want there. Your executor isn't even referencing `this`. And if you wanted it to, you could use an arrow function or bind it explicitly to `this` using `bind()`.
If this not pollution I don't know is.
Microjs is awesome. Also incredibly easy to get rolling.
Nah that seems ok. The thing about promises is they Leave a good amount up to the style of the developer.
I was thinking ReactJS but i never heard of MicroJS. I'll check it out now.
I think I'm unfamiliar with that specifically. But this might help, consider each bundle.js file to be its own app, and if you need more than just use multiple webpack.config.js file and host multple bundles
Just read this comment and all of a sudden receive an email from Mozilla about a privacy paradox..
In a similar vein: â€œPeopleware: Productive Projects and Teamsâ€ by Timothy Lister and Tom DeMarco.
DUDE... Life changing. Thank you so much for putting this together.
Big SPAs need code-splitting based on routes and vendor libraries. That's more to do with your router and packaging (eg. webpack) than the GUI framework. That said, React+Flux (although I'd prefer React-Redux) with React-Router and code splitting would probably be a good choice. &gt; and its expected to be maintained for years (even decades!). No particular choice can guarantee you decades worth of compatibility, but Facebook are behind React and they're not stopping any time soon.
React+Flux is probably what you will end up choosing. It's solid, well supported, scallable, and testable. Not going to become legacy any time soon
What's with the downvoted people saying thanks? Are they bot posts or something?
or, you know.. make your own.. I found piwik to be very slow and not much more user friendly than google analytics...
As I typed the question I realized the answer would be more complicated than 'years of experience'. It's just hard to gauge your own skill-set sometimes. Good to remember that teamwork and helping others grow is important for senior positions... and maybe all levels. 
It's because of the . /r/privacytoolsIO
Interesting canvas library. Wondering if https://roughjs.com can be combined with something like vectorcam https://jywarren.github.io/vectorcam/ to apply the same effect to SVG images
afaik to make something happen while a key is pressed you need to restructure your code like, var RIGHT_ARROW = 39; var locationX = 0; var velocityX = 0; document.addEventListener('keydown', function(event) { // when key is down start moving if(getKey(event) === RIGHT_ARROW) velocityX = 15; }); document.addEventListener('keyup', function(event) { // when key is up stop moving velocityX = 0; }); function getKey(event){ // normalize keypress codes return event.key || event.keyIdentifier || event.keyCode; } function eventLoop(){ locationX += velocityX; // draw mario at locationX requestAnimationFrame(eventLoop); // redraw forever } eventLoop(); // start drawing mario 
Ahhh that works haha
well, yeah... but its a front-end web dev spectrum. 
no can no bbðŸ˜‚
This is absolute garbage advice, lol.
Yeah, seems like it. Not surprising that the guy posting articles about analytics is followed around by a cloud of bots...
I'm not so sure about this. Ember and Aurelia are arbitrary templating libs, they will slowly fade away. Using them with longevity in mind is going against everything that happened over the last years (functional user interface paradigm). Vue kind of is in their mold as well and is highly arbitrary, but it recently switched to Reacts principles at least under the hood, it's still a derivative with a thick and complex Angular coat on top, and Angular being somewhat of a lesser choice seems like the only sensible recommendation you have made.
A good question indeed. I am doing the calculations on server, because my teacher wants it so. I read about the manifest=appcache, thing, but I didn't understand then how can I control the cache size. For example if I want to keep last 5 calculations on cache and have some kind of input form where I could increase or decrease cache size, to set how many calculations should be cached?
Huge enterprise software implicates larger team where value of standardized patterns and approaches shines the most. For these reasons I would go for Angular 2 which offers all that is needed ( eg router, with lazy loading of feature modules ) while supporting well known software engineering patterns used on large backend projects like dependency injection... This should enable enterprise teams of standard developers with couple of leads to deliver expected resulta in predictable fashion. Cheers!
Author has the arguments to Map.forEach transposed: m.forEach((k, v, m) =&gt; console.log(`key:${k} value:${v} map:${m}`)) should be: m.forEach((v, k, m) =&gt; console.log(`key:${k} value:${v} map:${m}`))
Okay, people will downvote me for this. But I actually really liked playing with Angular2 Dart. I would consider it, it is the web framework AdWords and AdSense use. Dart is in itself a very good language. The problem is that there is not a big ecosystem. So you often have to extra work, like writing the type definition files (although you can convert from definitely typed, i'm not sure how good it is). I'm not going to say, you should definitely use it, but I would consider, you may actually like it.
I wonder how much work it would be to make TS' analyzer identify variables which are written to more than once.
Set/unset flags to represent the up/down states of the keys. In your rAF-driven game loop, you then react to the state of these flags. When you get a keydown event, you set the corresponding one to true. And when you get a keyup event, you set it to false. window.addEventListener('keydown', e =&gt; keys[e.keyCode &amp; 0xff] = 1 ); window.addEventListener('keyup', e =&gt; keys[e.keyCode &amp; 0xff] = 0 ); Something like that.
We need a better 'function' keyword which explain we store a function in a variable : ```const foo = () =&gt; { /* ... */ };``` ```function foo = () =&gt; { /* ... */ };``` ```func foo = () =&gt; { /* ... */ };``` 
At first, I myself felt it was wrong. but when i thought about it, it was not. If you compare react+redux vs vue+VueX, yeah *react is far more stable and preferred.* Now add react router and vue router to the mix(after all you will need a router), now things don't look that good, do they? react router has seen tons of breaking changes consistently and is not official solution from facebook. On other hand, vue-router is in sync with vue core and is officially supported by original creator. Also in react community, it is preferred to use babel with stage 2 presets (and sometimes worse) . This is something any company looking for longevity should avoid. 
My comment was deleted due to downvotes u___u
Imperativist propaganda. The only way to be functional is to abolish the state. Jokes aside, in the latest project of mine I have a few hundred `const` declarations and I don't think I have used `var` or `let` more than five times at all. Since `const` doesn't enforce the immutability of an object value and only guards against reassignment it's surprising how little you actually need `let` if you code the right wayâ„¢. &gt; Deciding up front whether some variable should be declared via `const` or `let` introduces some mental overhead at a rather inconvenient time. I donâ€™t think this distraction is worth it given that you only get a questionable improvement in return. I strongly disagree with that part, this "mental overhead" the author is talking about is called "solving the problem". Variables should have a single purpose, and if they do (and you know what the hell your code is doing) it should be immediately clear if you will ever reassign it or not.
OP's own words &gt;this app is going to be maintained for **years (even decades)** so it's important for us the future, popularity, and traction of the framework. As such, I have choosen libraries on basis of longevity instead of current hype. Now, we can't see future at all. but let's analyze the past. If OP has picked up angular TS 6 months ago, would you have considered it good choice? now compare with ember, no breaking changes during that period and more. 
I agree with the feeling of the article, but I think it's a losing battle.
Hard to read on mobile but it looks like you are using this.hostname when hostname doesn't exist?
Ember, Aurelia and Vue do not have a standard, they are highly volatile. They cannot even stay true to their API from one version to another. Their kind of "extended HTML" won't be cast into a standard. Not just that, it's an outdated concept. Mostly every new framework that comes out is functional, that is where it goes. The three you mentioned are the best leftovers of the old paradigm. And Vue even switched to a functional kernel. Though compared to React when it comes to longevity it is a one man project and adds tons of volatile complexity and abstraction.
I would say there is **zero** cognitive overhead, if your linting is good. I know how to properly use const/let/var, but in the interest of speed, I always use `const` and allow my realtime linter to figure out when I should be using `let`. Right now, I believe ESLint handles this for me, but I do have 2 or 3 additional code analyzer plug-ins installed in VSCode, so my advice is to do your research. 
Babel is just for JSX. Everything else is optional. Otherwise React bets on es6. Vue on es5 which means it will go through another refactoring soon and so will you. Polymer did this, and everything collapsed. Redux is framework-neutral and the go-to standard. VueX is tied to Vue. If you move on you write the app from scratch while Redux is portable. Breaking changes happen everywhere, like Vue 1 &gt; 2. In that aspect React itself is stable, as it doesn't dabble in templates. Fiber proves that point, no breaking changes. React router never stopped working, previous variant still being being maintained. They just made it component oriented and declarative. 
Thanks for the reply! Ofc it helps, this kind of experience similar to ours is really valuable, because it is a really hard position. Well we also considered in building our own framework, but to be honest the team thinks that it would take a lot of time to build and in the end of the day it would be a burden for us because instead of adding value to the product we would be maintaining the framework.
Too bad they can't be transpiled to ES5, otherwise I'd definitely use them..
This is what I was looking for, thanks
&gt; those created with const are read-only This simply isn't true. `const` simply creates a reference that can't be reassigned. It can still be mutated which would require writing, not just reading. If you want read-only you would want to use [Object.freeze](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze). &gt;Sounds like mindless busywork to me, but what does pressing all those extra keys actually improve? Are keystrokes (especially two per declaration) really the bottleneck of your workflow? &gt;Now that const was â€œfreed upâ€, it can be used for numerical (etc) constants again, which means you can also use ugly ALL_CAPS to mark them as constants â€“ just like in the good old days. `const` in JS isn't the same as a global constant declaration in something more like C. &gt;Personally, Iâ€™d prefer to leave keeping track of the â€œconstnessâ€ of variables to machines rather than doing this myself. I agree, therefore I use `const` so the machine can keep track of it without additional developer tooling.
&gt; as long as dynamically generated content is required, html templates will be considered first. 4 years ago maybe. Not anymore. &gt; and jsx/render will be standard? It doesn't break one. They're just functions. It is being used everywhere now, even Vue as of 2.0, as i've told you. You get [penalized with a runtime parser](https://vuejs.org/v2/guide/installation.html#Standalone-vs-Runtime-only-Build) if you use templates instead of JSX unless you use single-file-components + webpack, which translates to functions at compile time. All frameworks do this now. &gt; vue core is 23k gzip + min react is 45kb gzip + min React normalizes and re-pools events which adds the 20kb you're referring to. It is incredibly useful. Add an alias to cut that out and you can run React on less than 10kb. &gt; I am not sure how do you conclude that vue is more complex Because it literally *is* React, with a complex template parser + an observable dirty checker that hacks around the browsers inability to observe. React has an api surface of, say, 3 apis and doesn't abstract. It makes no sense to discuss this, have you worked with both to question it? If you take a bike, and tack on motors and wings and a microwave oven, wouldn't you say you've complicated the bike?
Just thought it was worth sharing. I have recently implemented something similar in a big client. It's a simple concept and still so powerful. I always find it hard to find real life examples like this. I hope somebody can find it useful :)
I just had the idead of a potential usecase when I saw it XD But yeah I'll tell you (maybe with a Github PR lol)
Why did I not know about Piwik?
&gt; Anyone here with similar experience? Yes, I have similar experience. At my previous job, we had a legacy, 15+ year old intranet that we had to maintain/modernize. Several hundred thousand lines of code. This was 3 years ago. At the time, for frontend, there were three main options: Ember, Angular 1 and Backbone. Backbone was very stable, but already starting to get a reputation of being behind the times. Ember conventions and magic frankly made no sense to us (and since we were a .NET shop, Ember CLI not working well on windows was a huge blocker). I had done a proof of concept app w/ Angular and it seemed nice enough, so ultimately we picked Angular. Fast forward to 3 years later, Angular 1 is in Backbone's position, being said to be behind the times, or worse. While Angular 1 proved to have good developer ergonomics, it also showed performance problems and technical/design issues. Also, it proved extremely difficult to hire for Angular, even though it's the most popular framework used in the city, by far. Parts of the intranet were written in ExtJS and that codebase exists to date and is still actively maintained, but it's permanently stuck in an ancient version of the framework and there's effectively a single developer maintaining it - not even Sencha supports that version anymore (so very very high bus factor). It's pretty much impossible to hire for this skillset, so the best we were able to do was hire a generalist and have him sloooooowly learn the ropes. Moral of the story: there's no silver bullet and you *will* end up behind the times with anything you pick in as few as a couple years down the road. So my recommendation: have everyone in the team research the current batch of trendy frameworks and have a vote on what people found the easiest to get setup, learn and use. Pick *not the winner*, but the *least contentious* choice in the rankings, as this will be your legacy code in a few years, and the criteria at that point is that it needs to be tolerable. You'll want things with low emotional momentum. If you look around this thread, you'll see people getting downvoted for having not-so-popular opinions of popular tech. That should give you a clue as to what techs get strong emotional reactions and what is going to get the most flak when the-next-big-thing(tm) comes along. Don't be shy to try not-so-famous frameworks: if there are more than a few companies using it in production, then just trust that it's solid. You'll want something a generalist can pick up quickly because down the road, hiring for React or Vue will sound like hiring for Backbone today (as crazy as that sounds). You'll have to hire for Javascript dev or full stack dev or software engineer. Most well known frameworks these days are relatively interchangeable in terms of structure, so prefer those over highly opinionated ones (e.g. Ember, ExtJS, Enyo) to increase the chances that a new hire will be able to onboard quickly. Good luck
I would be very nervous to bet on big opinionated framework for long lived project. I was there with angular1 &amp; ember and since then I prefer to just throw in bunch of libs and since they aren't coupled in any way, I can easily upgrade/swap them over time.
You don't want to use appcache, it's deprecated and doesn't behave like you would expect it to in any regards. If you do want to cache the results, you should consider looking into either a service worker to act as a proxy on the requests, or use something more simplistic like localStorage. For you as a student, I'd recommend going with the localStorage path, as it will introduce the least amount of trouble and then go with the same kind of approach that IrateGod has done, but instead of doing it in-memory, keep it in the localStorage. 
Can't get rid of your shitty pop up when reading from browser in Reddit app and therefore cannot read the article 
Some experiments by me today (finally did some with mouse instead of touchpad) http://i.imgur.com/a3sCfNy.png http://i.imgur.com/E5NkJ4y.png
So, what are you using at backend? 
&gt; Okay, but penalized is too strong a word here. The point is, it switched to functional. &gt; I thought you are talking about code complexity That's what i did. &gt; Learning curve varies from people to people There is a 3 api framework. You learn it in a certain amount of time. Now you take that 3 api framework, as it is, and add a 100 apis more, a template syntax and a very intricate observable system with gotchas and fallouts. Is it not logical to you that it causes cognitive overhead? Vue has great docs, 64 pages currently, React doesn't need any documentation, it can be taught on a beverage coaster. I use the two obviously, i haven't looked into a React documentation because i can remember 3 apis and a couple of lifecycles, everything else is common Javascript. Three years in with Vue i still look up stuff - because it's surface, api and otherwise, is *considerably* larger. 
I think we need a `const function foo() {}` syntax
Great testimonial, thanks! Now I feel I am not alone in this. We did research and still doing, but it's hard to prototype something so big and with so many particularities. And for example React brings a lot of decision fatigue so choosing React is only a small part of the whole, you have to choose how you get and manage data, unit testing, etc, etc, while Angular offers this to you out of the box even if it is not perfect. But on the hiring side, it seems that React is getting more traction than Angular (maybe due to the Angular 1-2 episode) and that scares us as now we know how hard it is to find developers to work on a deprecated technology (I don't blame them ofc). Agree when you say this discussion most often than not goes to the emotional side, and I was afraid of that. People discuss the frameworks and libraries outside of the context of the problem and I think this is the true issue because **building a simple app with a couple dozens of pages is completely different than building at our scale**. I would like that people could focus on that. 
That's what I found too. Const by default, and it prevents you from accidentally reassigning something you didn't want reassigned. It helps you accidentally creating a new object or array when you wanted to modify the previous.
TypeScript's and Dart's analyzer are used by multiple editors and their respective playgrounds as well. So, if, for example, some feature is added to Dart's analyzer, you get it in Atom, VS Code, WebStorm (etc), Sublime, and whatever.
Forgot to mention that, we are migrating Silverlight RIA Services to ASP.NET Web.API, added in the post.
And probably this prompt https://github.com/sindresorhus/pure
Angular 2 solves everything you are pointing out
&gt; We did research and still doing, but it's hard to prototype something so big and with so many particularities. And for example React brings a lot of decision fatigue I hear ya! For what it's worth, my research was building something relatively small (in my case, it was a simple app where you could put in an address and it would show all of the ones you had on a map), mostly to get a feel for it. Take note of the things that don't feel smooth (like the decision fatigue thing you mentioned). In my case w/ Angular, one of the nagging feelings I had at the end of the prototype was that it was a bit too magic for my taste, and sure enough, that's exactly what snowballed into a big problem later on. The good thing about React and the current batch of frameworks is that most are component-based, so it's relatively easy to jump from React to Vue to Angular 2 (compared to starting from jQuery/Prototype.js spaghetti and choosing between Backbone, Angular and Ember, all of which were wildly different). I expect that it should be easier nowadays to get someone up and running in, say, Mithril.js, even if their resume only has React in it. So, again, try to get your team be honest about weaknesses of their preferred frameworks, and pick the least controversial one.
Yeah, but ... no.
http://concourse.ci/ - if you want to host your own travis.
Can you elaborate? You are bashing the guy but contributing nothing to the discussion.
Is it actually hosting your own travis, or is it hosting your own CI, which travis also happens to be? Like, can you use the same config files and everything?
What is the current behavior, and what behavior are you wanting 
Only reason to put a comma in a parameter list is to have another parameter follow, I don't see how this helps anyone, it'll only encourage writing poor code, that isn't supported in all browsers.
[removed]
It wouldn't be named CORS. The browser could say that the page is requesting permissions to access images on the following servers: `*.google.com`, something like that.
Just playing devil's advocate, why should the last element have different markings from the other elements? Commas are used to separate things in written language, but why should it be the same in programming languages? Should we allow other natural language rules to dictate our programming languages? Ok, from now on we use `var ar = [ 1, 2, 3 and 4 ];` Why can't the comma simply mean "this is a distinct item in this list / set / array" or "all references to this element precede this marker?" 
So the parser dying when it finds a trailing comma is a better behavior?
Different CI, can't reuse travis files. 
This seems to be getting downvoted pretty hard, and I'd love to understand why. Is this article missing something?
Extremely pointless feature. You don't really mess around with function signatures that often. I don't even use them for arrays/objects. It looks silly and no one gives a flying fuck if some ',' is highlighted in the diff as well.
Assuming that passFail function is your code, there's at least one syntax error and one undefined variable. Review the syntax for declaring functions and check your code to make sure that you're using the correct names in your logic.
 function passFail(score,minToPass); { --&gt; function passFail(score,minToPass) { Lose the semi-colon. Then see if it does what you want.
Besides the syntax errors, yo udon't need to be parsing score and minToPass from strings to numbers. Presumably, you're getting passed numbers.
&gt;Person I was responding to was talking about **Google's surveillance capitalism**. Reading comprehension.
I didn't downvote but I thought that it could have had more of a focus on the changes over the past year between TS1 and TS2; the first few paragraphs were kind of fluffy as well. Overall the rest of the article was okay.
Why the fuck is this company not surveillance capitalism?
&gt; well-known points Most Javascript users I've interacted with (who aren't already using Typescript), still think it's "like CoffeeScript." For people who haven't been paying attention, Typescript 2 is probably an entirely different product than they're expecting, and it's only been available for a few months. Honestly, if these points were actually well-known, I think most big projects would be using Typescript already.
Or you just read the shit you just pasted.
&gt; it'll only encourage writing poor code, that isn't supported in all browsers. Agreed. I can't fathom how this would be useful, outside of allowing people to get lazy with copy/pasta...
Different but you operate it also with yaml files - you can create any pipelines you want.
Excellent! :) For the record, what you did was terminate that statement with the semi-colon, so it created an empty function of that name, then there was just a block of code hanging there and trying to work, but failing.
What does this mean exactly? Will it be maintained? Will it get better?
Oh look at mister fancy pants with his pockets bursting with commas. Who cares if there are people living on 3 commas a week in some parts of the world, I want to waste commas by listing things inefficiently! Listen buddy, I don't care that your daddy made bank by shorting question marks in the 80s, punctuation is scarce to most people. Just because you've never faced this scarcity doesn't mean you should advocate waste. Instead of using the Oxford comma, hold back and give that comma to a library, school or charity. I'm sure whoever you're writing to will be able to deduce that you want the list to continue. Wait, I get it. You work for big punctuation! Next you'll be telling me that capital letters aren't addictive, or that 2 spaces after a period isn't causing global warming. 
 basically your point is that Vue takes longer to learn than react. You are correct. One needs more time and practice to fully realize the potential of Vue. so, does this really matter here? In my opinion, it des not. is vue's learning curve so big that it is an issue for you?? Vue's learning curve is not that high. and ayone will be productive before reading half the docs.(though one should read them all) PS: I can't see why you bother with vue at all when I listed ember as first recommendation and aurelia as second. 
As a node dev, the thing that has always kept me off from TS (and also from Babel) is that I feel like I lose the freedom and iteration speed of simple running from the command line, or I start having to maintain run scripts through VS Code or similar. Admittedly I haven't done much research lately, but is this now a non-issue? 
I'm not a bot. I'm a user of digital analytics tools (GA included) and legitimately found this post insightful. I have a feeling I was downvoted by Piwik supporters.
I don't understand, they are changing the parser so it won't die. "They are raising the speed limit from 30 to 35." "Why would you want to get a speeding ticket for going 35?" And sure, other parsers exist and this won't work for those yet, but JS improvements have always rolled out this way.
Proper inlining is so very hard...
You can use ts-node as a drop-in replacement for node to run TypeScript directly. It registers a require hook that transpiles on-demand. It also has a "fast" mode that skips typechecking. That might sound crazy, but IDEs have excellent TS integration, so they can highlight your errors, and ts-node will start your app quickly. https://www.npmjs.com/package/ts-node
Go has this feature. I started out not liking it but realized quickly it's actually really nice. Great for consistency and moving or reordering params.
I work mainly in Node too, and that was my impression until about a month ago. Typescript has gotten a lot faster (4x, according to their benchmarks), and you can even compile on a watch task, which makes using typescript almost unnoticeable. Check out this repo: https://github.com/bitjson/typescript-starter It includes a watch task for building and testing any code changes (using AVA) â€“ might be closer to what you're looking for in terms of speed.
just skimming, but probably: while ( x &lt; arr[i].length ) { // at last x x += 1; // at last x + 1 valuesString += '&lt;li&gt;' + arr[i][x] + '&lt;/li&gt;'; // past last x (x+1)
So I don't really care either way about the support for this (there's linters for style preferences like this), but my question is does this "support" introduce more overhead to a list of params/etc the JS engine does? In other words, in the JS engine itself did it assume all params were split by commas? If so, does this now do some kind of type checking on the last entry of every param list it goes through to check if the list ended? Probably a pretty minor performance hit but nonetheless this does make me think evaluating a list of params would take longer considering there will be a check on the last value to see if it's empty or not (unless maybe there's some parsing up front the engine does to clean these). 
No time, have dozens more 3 line npm modules I need to publish to get web scale!
Honestly, you don't know anything about programming javascript, right? I suggest reading the book JavaScript: The Definitive Guide. You'll learn both the language, and an entire chapter about javascript for web developers. Welcome to the community! 
**Document** is the *interface* you're given to access the loaded webpage's **DOM tree**. It contains all sorts of *methods* like **querySelector** that you can use. Methods are what we call *functions* when they're *properties* of an** object**. Another popular method used associated with the document API** is: *document.getElementById('id')*. var el = document.querySelector(".myclass"); So **querySelector** is a *special* function that *returns* the _first_ element that matches ".myclass" or whatever you pass as your argument string. It would search the entire document until it found ".myclass" and return it to you. Does that make sense? **Further reading:** 1. [querySelector](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector) 1. [Document](https://developer.mozilla.org/en-US/docs/Web/API/Document)
TSLint has a warning and a fix for replacing let with const, meaning that you can write let everywhere and get it replaced by a const when saving (if autofix on save is set, ofc). I suppose ESLint can probably do it too
U should learn and read more about programming and javascript but here it is what ur asking Document is the actual document the hole document of the page. querySelector is a method used to get DOM elements. The last part is the actual dom elemet you are getting. Im new to javascript too and im reading eloquent javascript it is a free ebook.
Number 1 is the most elegant. I'm surprised the puzzle piece is winning. 
Hahaha. "Everyone i know is using angular 2 and typescript so it's definitely time to give it another chance" oh okay
Wow, your response is highly inline with the pulse of the community, but you still got downvoted. Pathetic typescript fanboys in here brigading users who choose not to use it (for valid reasons)
I've thought about using TypeScript, but I don't want to diverge from ES6 and potentially losing out on backwards-compatibility in the future. Also with the existence of `flow`, I'm not sure what advantages TypeScript has anymore. You can just flow type your existing JS.
It's not just diff highlighting. And even if it were, why in the world are you objecting to somebody fixing a problem because "it didn't bother me that much anyway"? - It's in function calls, not just signatures. If you don't mess around with function invocations often then you're doing it wrong. - It makes editing multi-line invocations faster, as you edit in one place not two. - It removes (in one small way) a need to perform manual bookkeeping, marking in one place whether there's code in another. - It makes the syntax more uniform, therefore easier to visually check. - Messing up commas when swapping or otherwise editing multi-line function invocations is a common cause of syntax errors. As a rule of thumb, if everybody seems insane then it's less likely that they all had a mental break at the same moment, more likely that you don't see what's motivating them.
I agree, it feels pointless if you already know JS well. I would rather have a good set of tests instead of type annotations.
Here you go: ['a','b','c','d'].map((x) =&gt; [x,x]).reduce((arr, x) =&gt; arr.concat(x));
&gt; trying this with a for loop and a splice I assume you want to modify the existing array. The other solutions work, but do a lot of memory allocations. This one is more efficient: function dupe(array) { array.length *= 2 for (var i = array.length; i &gt; 0; i--) { var cursor = i * 2 array[cursor - 1] = array[cursor - 2] = array[i - 1] } return array } 
I prefer to put that stuff in the promise body because if for some reason an error is thrown outside of the promise body, it will have to be caught with a `try/catch` block, but if the error is thrown within the promise body, it can be caught with `.catch` as if the promise was rejected.
TS is definitely better than it was a year ago. The latest versions added interesting and sorely missing inference features and more advanced types, the compiler's better, tooling is more polished than ever, etc. Type definitions are unfortunately still a trainwrecked (I can't start a new project and spend more than an hour before one of my dependencies need some definition patching. At least TS makes it really easy to "enhance" an existing definition without modifying the source while you wait for a PR to go through). Projects like Prettier can't be used until there's TS support in Babylon or someone makes it from scratch. Still, it's now pretty good and I use it in some of my projects, but it's not as "free" as some people claim. I use Flow in some others. It doesn't suffer from the problems above, but it is significantly harder to use because of poor tooling and more bugs (but the type system itself is a little more interesting, if hard for newcomers). There's still a lot of benefits to sticking to vanilla standard JavaScript as far as ops goes through. You're guaranteed to be able to interact with everything without hitting a brick wall. So in the end I end up hopping between all three depending on my target audience...
Yeah no worries, didn't offend me. It just comes off as uninformed and will turn people away from even reading the article. Somewhat sensationalist title.
I work on a huge enterprise full stack JS app (tens of thousands of lines of code). No typescript, no flow .... and no problems either. Maybe one day I'll encounter all of these problems TS solves. EDIT: Okay, "huge" has obviously offended a few people. I checked: ~140k lines of code written by our team. It is an enterprise product with over 100k users. Nevertheless, we have had no issue.
Really bad advice OP. I'd not give much weight to this opinion.
Do you think the presets will just go away? If you're referring to property initializers or object spread syntax ... the babel transforms already exist. They won't just magically disappear.
I think these are some of the best variable names I've ever seen.
Are you using TS 2.1? It supports untyped imports, you should be able to use anything without defs if you must.
10's of thousands of lines of code, that's cute :)
Nice one
This explains why it's a good idea - https://github.com/airbnb/javascript#commas--dangling
&gt; Read the code with fs.readFileSync and then eval? Sort of yea. The key point is that the code is executed. Code inside ES6 modules isn't executed. They export bindings, not values. foo.js export var foo = 1 + 2 then bar.js import { foo } from './foo.js' That `foo` won't be 3, because `foo.js` isn't executed while importing it. Another noticeable thing is that they not automatically understands the extension as commonjs does in the nodejs. So in commonjs you can `require('./foo')` without writing the extension, but in ES6 you should.
I haven't used TypeScript, but I've used Coffeescript extensively, largely because that was what was available a few years ago, and I like the vaguely Haskell-meets-Python syntax choices. How does TypeScript compare with Coffeescript?
If you have to use `eval`, that's not static analysis. Static analysis means that you can analyze the code without having to execute it, which is considerably easier, safer, and more reliable. 
Not using Babel to me is a big deal. In my opinion it's the gold standard of modern JS. I'm seeing some comments about Flow tooling not being as good? I've been using Nuclide and I get super fast type checking with all the extra power Flow provides. Not saying TS is bad, I just think that Flow is taking a more compelling direction.
Just curious, but when you have to debug your javascript in browser, how complex is it to try and decipher the compiled JS?
Less elegant, but avoids looping twice Array.prototype.concat(...['a','b','c','d'].map((x) =&gt; [x,x]))
"You can just TS type your existing JS" is an equally valid statement. /u/bitjson said it well, but I wanted to repeat it because it's such a common misconception. TypeScript's compiler can even injest raw, un-annotated JS and give you many of the benefits it brings to TS. Then you can selectively rename files from .js to .ts and get even more benefits in those files. (you might get type errors, but type errors *never prevent the code from compiling correctly!*) Then you can sprinkle in type annotations and get even more benefits!
sourcemaps have been solving this for a long time, it's the same way you debug code thats' been transpiled with Babel
Ahh, ok. That makes sense.
For loops inside for loops are to be avoided for efficiency reasons. Surely with for loops it's simpler to do something like function duplicateEachItem(arr) { const newArr = []; for (item of arr) { newArr.push(item, item) } return newArr; } duplicateEachItem(['a','b','c','d'])
Actually it only feels pointless if you don't know much about software engineering. To even add a typing system to JS you have to really know the language, so it can't be pointless for people who really know JS, otherwise there would be no TypeScript from MS. Furthermore it is no surprise that this is coming from MS, a company with a deep knowledge of software engineering.
This is a tiny change to the parser which should have no measurable effect on performance.
Sounds like the problems your having are just lack of experience with the type system, or others lack of experience causing you problems. Once you get used to it and it starts saving you time, you learn to love it. I wouldn't want to be without a type system now it cuts out many bugs, not all of course, but a whole host of problems. Yes I managed without, no one died, would I want to now, no.
HOW is it going to save me time. The best it can hope do is to be as fast as I am without static types. As I said, I simply do not have those types of bugs.
They're both programming languages compile to JS, other than that they have nothing in common. TS syntax is JS syntax + type annotations.
Its still 0-based. Slice just takes what's in between. a.slice(0, 0); // [00] ... 'zero', 1 'one', 2 'two', 3 'three']; a.slice(0, 1); // [0 'zero', 1] ... 'one', 2 'two', 3 'three']; a.slice(0, 2); // [0 'zero', 1 'one', 2] ... 'two', 3 'three']; a.slice(1, 2); // [0 'zero' ... [1 'one', 2] ... 'two', 3 'three']; a.slice(1, 3); // [0 'zero' ... [1 'one', 2 'two', 3] ... 'three']; 
Good call. Thanks! 
That does also sound good. Thanks! Lots of options now it seems (and maybe before too and I just didn't research well enough). 
TypeScript can emit your code almost verbatim, including comments, minus type annotations. If you ask it to be a transpiler, then it'll downlevel from ES2017 into ES6, ES5, or ES3. Or if you ask it not to do that, it'll emit ES6/ES2017/whatever verbatim. You can pass the result through Babel if you need to, but again, TS's compiler can do transpilation itself, so it's your choice. EDIT: tweaked my wording to be clearer
Are you saying that you never have type bugs at any point, or only that by the time you get to production you've eliminated the type bugs? 
If you refactor your code it tells you immediately where to also change stuff. If you work with foreign code you just need to hover over the variable to get its type or just read the definitions yourself. Again if you change code it tells you immediately where else this code is used. Can jump to definitions much more accurately. Gives you better autocomplete support.
Yeah, you have no idea what you're talking about. 
&gt; I think it's pointless for someone who knows JS well to use it. Do you feel the same way about linting? TypeScript seems like linting but for types. For example: // Oops! Duplicate keys. ESLint will catch this for you at compile time var foo = { bar: "baz", bar: "qux" }; Likewise: // Oops! Arrays don't have that method. TypeScript will catch this for you at compile time const s = ["Hello", "World"]; console.log(s.toUpperCase()); Think of TS as just an extension to linting. It catches more things.
Thanks. Autocomplete is not an issue, but I'll try refactoring something and see if it helps, although I doubt it
&gt;It frees space in your head to focus on what really matters hmm, Interesting! I have have found that this is generally the first argument AGAINST type systems, and I generally agree with that having come from heavily typed languages into JS. I find that type systems for me almost always lead to Abstraction bloat, and that getting rid of them allows me to get closer to focus on what the code abstractions are trying to say to me and not worry about whether they are just there to keep the type system from blowing up.
Well if you never make mistakes and your code changes very little, then I guess yeah, TS won't help you much. I do recommend it for my fellow mortals though.
&gt; I find that type systems for me almost always lead to Abstraction bloat, and that getting rid of them allows me to get closer to the code and what it is actually doing. I have to disagree. Types allow you to name your abstractions, but they don't create abstractions themselves. Just because your abstraction doesn't have a name doesn't mean it isn't there.
You should take a look at the Zeroth Stack - it covers those cases you discuss, particularly DI and shared models and validators. It's still pretty new but worth a look if you're starting out wondering if you need to roll your own. 
I haven't worked with Babel myself, so I can't compare TS emits to Babel. But the TS compiler is really flexible, you can make it emit different versions of ES. You could probably target ES2017 (essentially the TS code without type annotations at that point) and then run that through Babel, I assume, although I'm not sure what Babel would offer over the TS compiler itself in that case.
Trailing comma is a huge convenience feature. I don't understand how anyone could be against it.
I think this is a point of contention. One side says it is better, others feel differently. When I started doing AS3 coming from pure JS I found they strict typing to be handy sometimes... but mainly a massive PITA... "type mismatch l! var fontSize is of type Number - expected uint" ugh. Their both just numbers... let me code! I found in the end I designed everything to be a Number because it was easier to work with. On the other side of the coin... autocomplete code assist. For many this is a wonder they can't live without... for me I never use it because I've been coding in JS for 20 years and could do it in my sleep... and much faster.
I just clicked the link because of the title, but I have to say it was a bit of an odd mix. Most of the points boiled down to: See, Angular isn't bad because it doesn't force you to do X. But even if it doesn't force you, it appears that X is the default way of doing things in Angular whereas apparently some/a lot of people don't like to do it that way. Even if the choices aren't forced, an opinionated framework is gonna get judged by its opinions.
Not the guy you responded to, but DI = Dependency Injection.
and you have? Please explain:
ELI5: TS was at the right place at the right time.
&gt; I'm not sure what Babel would offer over the TS compiler itself in that case. It offers a modular tool that's the closest you get to drafts and standards. Not just that, through its plugins it open the doors for any kind of transpilation, like JSX conditions, postCSS, and many others. TS is non modular, interferes with other tools and only transpiles drafts that Microsofts deems worthy. It got object spread last month for instance while half the modern web was using for a long, long time, same applies to async/await and other drafts. And that tendency will continue. If it would at least excel in checking types, but it doesn't. Flow does, probably because it does one thing, and doing it well. The whole reason Flow was made is to get control back into the developers hands. Types shouldn't come in tow with dictating javascripts reach plain and simple and there's zero reason for TS to do so as proven by Flows approach.
ok thanks for the clarification.
Relevant: [FizzBuzzEnterpriseEdition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition). I would never try to convince you that you're wrong, since your experience with it is very different from mine. I would ask whether it's possible that the patterns and approaches of the typical corporate Java/Scala app lend themselves to painful code in any language.
&gt; i.e., reducing a term to the normal form I already told you that's not what function inlining does... You can't just call whatever you want "inlining".
&gt;I'm told that enterprise Java is full of this yeah that would be the principle offender for this kind of thing hahaha.
But it also makes you spend more time on pointless hand waving. I am a fan of linting within reason. Currently i'm on a project that won't start up the webserver if you have any linting problems, even whitespace. I think that's completely unnecessary and defeats the purpose of using a front end tech - one that shouldn't need to be compiled to view the results of. *edit* as a general refute, I haven't run into the problems that TS helps prevent. Like... nearly ever. I don't think it's worth it. 
OK. So the author makes a rather convincing case that the "compiled" Javascript is just the Typescript without the types, so the original code is still very much recognizable; and that there are benefits in having a compile time parameter type checks. (The latest version of VS Code even does it while editing.) He gives an example of how convoluted runtime parameter validation can get, using code from "Request" and "Bcoin" as examples. What he doesn't do is show how functionally the same code could be written, hopefully more compact, in Typescript. In particular, I'm curious in how an expert would handle the case in Request where the value of params.method is 'HEAD" and thus the body should be not there. So it's only half convincing. 
Ah, thanks. 
I use vscode, I am definitely very impressed with the editor. It's a better sublime text 2. I feel less productive, and in fact know I am because I have to futz around with everything being typed and matching parameter types in parent classes and all sorts of that garbage. Everything in our project is typed. 
&gt; "You can just TS type your existing JS" is an equally valid statement. There is not a single advantage over Flow. Flow has dozens of advantages over TS. It has been demonstrated to detect deeper cases, cases that TS couldn't get into. It doesn't interfere. It is modular. It lets Babel do the transpiling, a field where TS isn't even competing.
Sorry. Dependency Injection. Basically... registering all the shit you need into one big beauteous object and passing it in to all your classes. It helps to make things more unit testable, and it makes it easier to swap out components because it helps enforce the use of interfaces over concretions.
Smells like homework. Might as well make op rewrite it and learn something in the process.
Yeah it definitely depends on the coder. I've been pretty lucky the last 5ish years in that I've only been working with very talented people. 
Yeah they're really nothing alike. 
I *really* don't want to roll my own. I've seen the errors that can come out of bugs in handrolled DI containers written by... lets call them... rogue developers. Since DI uses reflection heavily usually, the errors are impenetrable. See any error from C#'s XmlSerializer for an example.
&gt;Types allow you to name your abstractions, but they don't create abstractions themselves. Obviously code inherently has abstractions. Not all abstractions are necessary or helpful. Working within a type system necessitates generating abstractions, putting abstractions on top of other abstractions, and making sure your abstractions are 'right' for the sake of functionality regardless for whether those abstractions have any meaning or value.
&gt; I would ask whether it's possible that the patterns and approaches of the typical corporate Java/Scala app lend themselves to painful code in any language. Java yes, Scala no. For me it honestly comes down to not actually doing "work" in JavaScript/Node. I do calculations in the data layer when I need to do calculations. Most of what I do is deconstruct a json object into strings and then display/update those strings. Any time I capture a numeric value it's captured as a string and then sent into the data layer to be converted to whatever type of number is needed. I don't really need any kind of class for my request and response objects either. We use GraphQL which gives me all the typing I need. There are plenty of ways to get the benefits of a type system in an untyped language. 
Do you use a linter?
Anyone is free to reinvent the wheel. In the meantime, productive developers are leveraging open source and understanding that [code that doesn't exist is the code you don't need to debug](https://medium.freecodecamp.com/code-that-dont-exist-is-the-code-you-don-t-need-to-debug-88985ed9604). Programming is not just about writing code, it's about solving a problem. The less code and the more efficient, the better.
Is there a conceptual difference between containment and composition, in this case? Am I using the term "composition" wrong? Thanks for the comment.
stack overflows are the new black.
THANK YOU. I've talk with really old devs who always worked in languages without a static typed system, and they see it as something bad, which makes the code ugly. The thing is that there are static type systems with type inference (as Haskell, or TS, if you type all your code) and are much more readable than, e.g: Java, yak!
It's not THAT bad anymore. Type inference is way better than it used to be (e.g. generic type inference). Lambdas allow you to make abstract classes without ever specifying a type.
If this is really just about linting, sorry to say but you might be better off with ESLint. Flow is as good if not better than TS types and doesnâ€™t demand you to adopt a completely different tooling to work in Javascript. You can enhance existing JS code iteratively with Flow.
Which is like babel-node is by the way. But you wouldn't use ts-node in production do you ? Those are only there to help local development flow.
Where is the code? The github link is empty.
&gt; arr.reduce((p, c) =&gt; p.concat(c, c), []) bro do you even es6 arr.reduce((p, c) =&gt; [...p, c, c], [])
I was just stating the point that it is useless for people who know JS is nonsense. If you don't need it fine, but not because you're an expert JS programmer. I've seen this way too often that people who only use JS think it is some set of training wheels and if you use it, it is because you don't know JS and they pride themselves that they don't need to use it, while those with a more technical background where JS is one of many languages can see and appreciate the point. The point being to apply more traditional software engineering paradigms to JS. It is no surprise that as JS apps get more complex we now have typing systems.
Behavioral tests, not merely type tests
Good software engineering does not require a static type system
How can you easily ensure parity between model objects/requests/server-side? You'd need to cover every member in the unit/integration testing which has a huuuge margin of error in an enterprise compared to static typing and takes way more thought
Not sure if srs...
As I said: we moved our API layer to graphql. Graphql has a schema and types, my code does not. Any API that isn't graphql gets unit tested because it's not my code and I don't trust people. Even when my team was writing restful APIs instead of graphql, we used a library like json-scheme. Going the other way and pulling data from somewhere else, every API I consume has some sort of documentation requirements (swagger v2 for the most part). If a team isn't following their own swagger docs then attempting to wrap JavaScript in a fancy linter won't actually stop them from doing something stupid. You only need type checkin when other people's data comes into your closed system. 
It depends entirely on the situation. You're speaking in absolutes. 
Is there a good reason to avoid ts-node in production? I've done this in the past without issues. Either way, the alternative isn't very painful: compile all your `.ts` files â†’ `.js` files and run those using plain old node.
I actually meant to say composition. I used the terms interchangeably, though I think containment refers to data structures, and not really dependencies. i.e. a container composed of several instances of a data type. To be completely honest, I only read the title while commuting home from work. I only saw the link now. 
That's not the best argument for it, you're just cherry-picking arguments you disagree with. As has been mentioned, trailing comma... 1. Keeps edit history intact in version control 2. Allows for individual lines to be quickly and easily commented out for debugging purposes 3. Allows for more consistent coding (i.e. the last element isn't treated different simply because it's the last element) 4. Allows for lines to be easily moved around (e.g. options alphabetized or otherwise grouped together in a more logical manner). Now here's the real kicker. All of those things? _YOU CAN ALREADY DO THEM WITH EVERY OTHER ITEM_. All trailing comma changes is that the last item is no longer treated differently. (unless you format your lines `, likeThis`, in which case a: you're a psychopath and b: just swap "first item" for "last item"). So far, the best argument for not allowing trailing comma is "I want the last element to be treated differently because there's a 50/50 chance it might inconvenience someone doing something that I think is dumb". Of course, that's just code speak. The _real_ reason people are against it is because they learned The One True Way and all of TOTW's weird idiosyncrasies are vitally important and slaughtering any of those sacred cows is just dumbing things down, but they don't have the self-awareness to admit that so their mind comes up with bizarre rationalizations.
&gt; working with a large project For anyone reading this... the above is the operative part. It can be a pain in the ass to work with but on a really large project it can be helpful to have interfaces defined for complicated API integrations. For smaller to medium sized projects that do not have the above need... I'm still not sold. Typescript can add a lot of boilerplate and pointless work.
Are you counting the implicit loop that ... desugars into in that count?
Here's a one-liner that does it: document.write( eval( prompt("Enter Math Equation") ) ); But this represents just about everything you are not supposed to do in JavaScript anymore. The solution your teacher is probably looking for is something like this: var equation = prompt("Enter Math Equation"); var pieces = equation.split('+'); var answer = parseInt(pieces[0]) + parseInt(pieces[1]); document.write( answer ); 
Totally agree. Whether you use Babel or TypeScript for transpilation, you have options. But in production I would precompile everything.
So, I'm really conflicted about the Flow/TypeScript/JavaScript dilemma. The major issue I take with TypeScript is that it bills itself as a complete compilation layer- in other words, while it's not unheard-of to use it with a Babel transpilation layer underneath, such a situation doesn't appear to be the norm. And that's bothersome, because I *really* value how Babel lets me tune the syntax transformations it's performing. This is one reason I like Flow, because its syntax extensions to Javascript are implemented as a Babel plugin. It feels like less of a commitment. On the other hand, Flow's error messages are cryptic, its library support is patchy (to say the least), and its documentation is nigh-inexistent. I have every reason to believe that TypeScript would make for a better developer experience, but... eh. 
See my post above. I absolutely agree with you on all these points, but *actually using it* has been a massive pain. It's frustrating, because I want to like Flow *so badly*.
&gt; Keeps edit history intact in version control How does seeing 1 line edited (adding a comma) and 1 line added (the new code) constitute failing to retain an intact VCS history? &gt; Allows for individual lines to be quickly and easily commented out for debugging purposes Very true. Convenience factor here is big. However, it *is* just a convenience, not really worthy of changing a language specification. &gt; Allows for more consistent coding (i.e. the last element isn't treated different simply because it's the last element) Only if you update your entire existing codebase with commas. Otherwise it'll only be consistent for new projects (and likely only those with a single developer). Again, doesn't really justify a change to the language specification. &gt; Allows for lines to be easily moved around (e.g. options alphabetized or otherwise grouped together in a more logical manner). This implies it's not already easy to do, but it is (and is common knowledge amongst people who use text editors daily): 1. Select the line you want to move including the comma preceding it but not the comma ending it. 2. Drag-drop your selected text before the comma preceding where you want it to appear. There's no benefit here whatsoever.
They're generally used interchangeably. For example, [here's an excerpt](https://i.imgur.com/2p9Le6i.png) from a C++ book by Herb Sutter (the #2 guy in the C++ community). I've occassionally emphasized that composition is containment, since a couple well publicized folks in the JavaScript community have unfortunately hijacked the word "composition".
Thanks, updated. Let me know if this looks right now :)
extreme amount of marketing (and well, it's also decent) 
Even still if it were me, I'd want a freaken type system for that much code. I'd want a type system for 200 lines of code. In my experience a type system will save you development time no matter how big or small a project is. Not to mention it will save you an immense amount of time if you are a completely noob with a given library. It saves me time every time my IDE gives me 100% accurate auto-completion on a library's API, and saves me opening a browser tab just to find the name of the method I want (and this is assuming there is some documentation for the library and also that the documentation is up to date). There are reasons that make using typescript impractical in many cases, but this doesn't negate any of the benefits that a good type system would provide for javascript. 
The types are optional... You can be as agile as you want, if anything it'll help you from making mistakes, thus less debugging, and more developing.
I have 2 problems with flow: 1) in my experience tooling is worse 2) they maintain the js extension, even though it's not js and flows version of types will likely never make it into js. 
First question you ask, now you do a git blame, person adding the comma may not have been last to actually touch that line, but now they are blamed. All they did was add a comma, it just adds haze to your repository. Now you have to go back multiple commits to find the actual true last commit to that line
Chrome 58 won't ship for months. When it does, the functionality will be in Chrome. Until then, it's just working its way through the pipeline that results in Chrome.
&gt; I find that type systems for me almost always lead to Abstraction bloat I disagree with this.... I started with Java a long time ago and as I progressed, I went from a weird state of no bloat (because I had no idea what I was doing) to incredible amounts of bloat (because I wanted to abstract away everything!) to a small amount of required bloat (because I was thinking ahead to business requirements, that I knew were going to be implemented, while throwing out everything else). The point is, bloat comes from the developer's idea that something needs to be abstracted away when in reality it probably doesn't unless you *KNOW* it will be in the future. The worst case is you end up refactoring that portion of code... I think a lot of people get caught up in the idea of needing to abstract away concepts in typed languages when you really don't the majority of the time.
&gt; JS's nature was at least partly responsible for its success. I disagree.... JS was successful because it was the only widely supported front-end scripting language for the last 15+ years... Although I think node gave it a huge push as well because you could now use the same language for the front and backend.
Call me sadistic but I use typescript for snippets and scripts &lt;100 LOC. But it does really pay off on larger projects. I just can't remove that crutch anymore. 9/10 times, I have all my bugs solved by the time I get a successful compile. No surprise "gotchas". Ain't nobody got time for that. Edit: it's like having a mental advisor. They think so you don't have to.
Interesting. I find TS a lot in Angular or companies engineers with a Java background engineers coming into web technologies. Not much in the React community from my experience, except for the slow adoption of Flow.
I have used JSDOC in big projects and it really does help a lot, at least with Jetbrains IDEs, also there is this library called Flow which is a light type system for JavaScript, haven't use it yet myself but it looks useful. Thanks for your insight about TypeScript.
Ditto. We're of recent trialling moving one project from Flow to Typescript because Flow was being so so painful. Silly things that just ruined our workflow. Typescript can target different targets - like es5, es6, etc. Currently I target es5, then let webpack do the module/bundling work. However I could target es6, and let webpack and babel do the module/bundling + transpiling work, but I found the former quicker. Overall I have felt Typescript to be less intrusive than Flow, and far more consistent. Our team had an ongoing "Flow broke, do this checklist" because breakages were so frequent. However Typescript isn't perfect, I much prefer Sublime to VSCode, but the TS plugin for Sublime is pretty buggy. I have also had a few minor problems with particular webpack code splitting techniques (like require.ensure) working within TS, but nothing that couldn't be resolved. Reading through the comments here, the verdict is still out - I like the concept of Babel as it seems the most current, but don't love Flows approach. Time will tell I guess
Might be easier to use ffmpeg: https://npms.io/search?q=ffmpeg
My company switched over about a year ago and it's a godsend. Fragile code bases I would not touch with a ten foot pole are now manageable and can be modified with confidence. I can go to any other team, jump into their code base and instantly be productive. There was a lot of push back at first before we jumped to typescript, but it was well worth it. We are adding features now way faster and our quality is way up. We have our server emit typed DTOs automatically and it makes working with any API endpoint a breeze. Especially when you start passing around pieces of a DTO around your client side code it can be super hard to lose track of the properties on it. Refactoring DTOs as well used to cause all kinds of unforeseen affects in client side code that we don't have any more. Plus we don't have to worry about writing test code that validates types, our tests can be a lot more focused on the logic and not easy stuff that the compiler can find for us.
That's not sadistic. Coding in a C-style language without types is sadistic. I think Javascript developers like to fool themselves into thinking that they aren't coding in a style that is almost completely comparable to Java or C#. They say, oh but javascript is more functional, or its more dynamic, or it has a lispy flavour, as if a type system would interfere with some unique quality that javascript brings to the table. 
I feel like people new to programming steer towards dynamic languages because there are no compile errors (which for a new programmer are hell to figure out), and even a buggy app you can get running in some capacity. For experienced programmers compile errors and typings are easy for us, so they don't stand in our way. They are actually super valuable in catching dumb mistakes and giving us insight into program structure, fast refactoring, etc... As a result we write better code, faster. 
Well, since React already solved all of these problems, and my code is using it, I think I'll stick with React. No point in learning a completely new library that shares only a name with the former version.
I don't think you understand what agile means. Types make you *more* agile. You can move faster and change more things with less chance of breakage.
kinda
Have you ever worked in a massive codebase?
You don't understand what Agile means. Types or not types have nothing to do with agility. And types will not make you more agile, that's unrelated.
Try trailing comma style on multiline literals for a week, and you'll see why. It's about modifying the code later. Also, how do you figure that this encourages writing "poor code"? You either make it part of your style convention, or you don't. Use a linter. As for browser support, not really an issue if you're already using babel. Just turn it on.
If you're talking about a convenience feature, "it's possible to get by without it" isn't an argument.
Callbacks? Object literals? There are tons of times where even few-argument functions break onto multiple lines. Also, there are plenty of cases where a variadic function might take many arguments, especially in test code.
Exactly. There is a small overhead on startup, but this is absolutely non-issue until you have ridiculously large codebase. Or you're doing a microservice which needs to spawn as fast as possible. 
This only helps if function definitions and calls are *both* written with every parameter on a separate line, which is very very rare. And even then, the goal is to help git and other tools figure out differences, so why not change those tools to also work with single line versions? Giving contrived examples with every param on a separate line doesn't really help. e.g this is commonly used as justification foo(a, b, c) then if you need to remove c, you have to do foo(a, b //, //c) but this is silly, since the actual way people write code is going to be - foo(a,b,c) foo(a,b /*,c*/) which of course doesn't need support for trailing , and is simpler. 
I'd assume that'd be faster as it's a single native operation as opposed to an explicit loop (leaving aside transpilation)
&gt;This only helps if function definitions and calls are both written with every parameter on a separate line, which is very very rare. Huh? Why do you think this? It looks like part of your confusion is that this style only works if you put parens on their own lines. One place this really shines is with variadic functions. For example afterRequest(request, response) { return Promise.all( request.user.updateLastSeen(), this.model.updateLastAccess(), this.fireAfterHooks(request), response.send(), ); } Now if you need to add or remove a promise, it's easy. And putting them all on their own lines improves both readability and diffs. (For the sake of argument, we're pretending that `Promise.all` is variadic; in a real example, we probably wouldn't be talking about a built-in. Or you can imagine there are square braces there, where the argument for dangling commas is the same)
Hah yea, that's the nice thing with typescript is that the metadata reflection can be leveraged nicely for DI. The framework I mentioned uses the Angular 2 DI under the hood, so it's been pretty well thought out and tested. Angular DI has some really nice capabilities like multi providers and symbolic injection for primitives that can't be reflected 
One note: you can actually run node such that the v8 gc is exposed as a global. There are cases where this can be useful, e.g. memory is constrained, swap is slow (I'm looking at you, heroku), and you know that you're going to have regular spikes in memory usage. I assume it's because v8 is primarily a browser JS engine, and in that environment none of the things I listed are usually true. You probably have plenty of RAM, swapping to disk is pretty cheap, and websites use a fairly predictable and regular amount of memory. On a fleet of small VMs, those assumptions break, and it can sometimes be helpful to take matters into your own hands (especially because you can scale horizontally to ensure that there's plenty of time for GC passes).
Still the easiest way to check your javascript for syntax errors from the command line. 
worked on implementing my own version of fallout 2 in vanilla javascript. Completely agree with your points. Would absolutely love for javascript (or another browser ran interpreted language) to have types, if only to free up "mental space". edit: Just looked at the article. lol gonna give typescript a shot. 
I've the same experience. 
Microsoft has a billion dollar marketing budget to buy TypeScript shills.
You're giving an example of what I said, with each param of the function call on a separate line. This is also the justification given in the original proposal for this feature.
I agree. It is a community effort. Plugins are usually implementing ECMA drafts or standards, not a separate language from JS.
There are other services which understand travis.yml's format, like Shippable.
Does Google Analytics fit here, especially as you have a web client? Most AWS options are not going to work for you directly, as your users would need a key to interact with them. Less convoluted than setting up Cognito to give keys to your users, would be simply creating an API that logs data posted to it in a small database. Make it fast, cheap and simple - it's just a silent data gatherer.
To be fair, any linting process should first have a formatting process. We block all builds on lint errors, but we format the code first via lint rules, so things like indentation or white space never break a build.
You said it was contrived. I was showing why it's not. And you don't need to talk about diffs to justify this. In most editors, you can toggle a line comment with a keyboard shortcut. That's way faster and easier than carefully inserting a block comment around an argument.
Currently porting the RethinkDB webui from coffeescript to es6 with Invig
For personal projects relying on comments for types might be good enough but on any sizeable software I've worked on comments have a nasty habit of not being updated when the code is. That's why I would recommend typescript (or flow I guess) for any decently sized project. The code becomes functionally self documenting as compile errors will be thrown if the types change. I say functionally because the comments will still have a tendency to lose sync with the code but if the comments are describing why instead of how and what it should be less of a problem for future developers.
Thank you so much for responding atkinchris. I haven't used Google Analytics more than copy pasting the load script. It would need to be able to look at a JSON storage (redux). Regarding creating a simple API with a small database, do you know or recommend a platform? Thank you once again for your response! 
Closures and lambdas were special and quite unique to javascript in the 90s, that isn't the case any more. Most of the popular languages getting used now have good lambda and closure features, which play really well with the type system. I'd argue that the programming style of 99% of javascript developers is only superficially different to programming in a standard and modern OO language. I would be interested to see some code though which really demonstrates the power of the dynamic nature of javascript. In a language with advanced meta or macro capabilities I can see where the dynamic nature of the language would be advantageous, but I just don't see how javascript is all that different from a standard OO language with sprinklings of functional features.
I love spreadin dem arrays like dem ol bewtycheeks yawnamean?
suppose a function add two numbers , if you pass it 2 and 3 it will output the correct answer of 5 , thus in this case the unit test will tell you that everything is OK. BUT if you (by mistake) in your code pass it a 4 and 'user' it will output "4user" which will miss up stuff down the execution path and possibly make it too dificult to track. where is the problem? the problem is that dynamic typing does't prevent you from shooting yourself in the foot. i program in c# and in c# (or any static language) you can't pass a string to a function that expect an int. so isn't that a source of error?
I see JS people say "I just don't get type errors in my code, so don't see the point" constantly. And then I see the same developers spending hours in a debugger trying to trace problems that a type system would have picked up in seconds. Often without needing any manual type annotations (So it's literally just statically analysing straight up JS). A good type system, used properly, will catch the vast majority of runtime bugs with very little effort. 
suppose a function add two numbers , if you pass it 2 and 3 it will output the correct answer of 5 , thus in this case the unit test will tell you that everything is OK. BUT if you (by mistake) in your code pass it a 4 and 'user' it will output "4user" which will miss up stuff down the execution path and possibly make it too dificult to track. where is the problem? the problem is that dynamic typing does't prevent you from shooting yourself in the foot. i program in c# and in c# (or any static language) you can't pass a string to a function that expect an int. so isn't that a source of error? for small programs it is OK ,the larger the program the more this get significant.
Why would you want to pass any of those in "as-is" and not assign them to variables? Doing so makes the function call unreadable, IMO.
AWS EC2 &amp; RDS would be my professional choice - but you could do just as well with Heroku or Digital Ocean, likely on free/cheap tiers indefinitely. The API itself could be a simple Node server (you already say you have experience with express) accepting POST requests, and logging the required information to whatever the cheapest, persistent, indexed storage is for your chosen platform.
If you're just learning node, you don't need to use `nvm`. It's only useful if you want to fast switch node versions. Read carefully the text, not just copy-paste every commands. If you still want to use `nvm` â€“ you need install it first (there is the link in the article), after installing the node itself.
I would choose either ClojureScript or Elm. They both are excellent purely functional languages. They also both go way beyond any solution JavaScript and its gazillion frameworks offer in terms of managing state and data flow. As much as I like and respect libraries like Redux and RxJS, they are bandages on the wound that is called JavaScript and much less elegant in the way they try to solve the same problems as Elm and ClojureScript. In part because JavaScript doesn't have native support for things like immutable data structures. When it comes to choosing either Elm or ClojureScript you'd have to take into consideration what you're trying to build. If you're also developing the backend and it's important to have the same language for your front and backend than ClojureScript is the obvious choice because there's Clojure for the server. AFAIK Elm is currently limited to the front-end. There's also a difference is philosophy. While ClojureScript is a very capable functional programming language, one might argue Elm tries to be (even) more pure in the way it allows you to do functional programming. This can be a limitation or a benefit depending on your personal programming preferences and what you want to achieve. Also, because Clojure/ClojureScript has been around longer and has a broader scope (front- and backend), it has a bigger ecosystem and community compared to Elm. Things like Om, Reagant, Re-frame and DataScript come to mind here. Elm on the other hand has most things you need out of the box, so it has less use for these kinds of libraries. But overal I would say both languages are a solid choice and a real step-up from JavaScript.
Thanks for a great write up! Where would you recommend learning either of these languages? 
Ohh I was checking it and thought it's not a lib file. Sorry for that. Nice job!
No worries, glad you like it :)
&gt; it was just a shorthand for doing some kind of typeof or instanceof TS or Flow is basically that. The compiler checks that all types matches so you don't have to do those checks in runtime by hand. On top of which algebraic types and type classes are derived to check the soundness of more complicated relationships. (ML, Haskell) On top of which dependent types are derived to reunify type and value and the soundness of the whole program can be proven before it is even run. (Agda, Coq) That is, no tests needed.
In addition, trailing commas also make git diffs look cleaner and more understandable. But judging from the reasoning of the people against this in this thread, I'm not sure if they've actually been in the industry long enough to have even used Git
[It's not an entirely different language](https://vincenttunru.com/TypeScript-vs-Javascript/), so there's less risk adopting it. 
You're almost there.
Only one I've used personally is *ClojureScript*. I'm a fan. Syntax is weird, as it is a Lisp, but once you get used to it, rather elegant. The toolset is petty good. *Figwheel* will compile your code as you work, *Om* is a ClojureScript version of React. I can't compare it to the directly to the others, but I think it might be what you're looking for.
&gt; One of the primary reasons that Microsoft created JavaScript you should correct that typo. &gt; So at that point, why not use something like C#? optional typing. You have one language which is perfect for small experiments where you don't bother with types. Once the experiment grows large, you start to work on it with other people, you start adding types. For me, optional types are the way to go. &gt; TypeScript = Cancer. Microsoft = Fascism This might have been partially true 10-15 years ago. Not true anymore.
lol, if types solve the bugs you'd otherwise need to write tests for then why aren't you using types??
As someone coming into this post blind, it sounds like compilers are the last thing this person wants to deal with. Just write JavaScript. 
hah! i like you.
I was very careful to mention it only happened in bad TS codebases, not in TS in general, and it was a complain about how people use it, not about the language itself.
You have to do a way, way, way better job explaining yourself
I disagree. A compile-to-js language can actually greatly reduce the complexity of your overal system because a lot of the complexity involved in building your app is being handled by the compiler (e.g. tree shaking, module loading, sourcemaps, ...).
Any code? Hint of a library? 
Typescript, you don't really need all the dependencies either FYI, and it is easy to get it to compile on change. Try using tsc instead of babel. I'm client js only too, and deployment is exactly pushing out a war file. It isn't the language we deserve, but experience has taught me that in a situation where you have numerous browsers (and operating systems) and all their idiosyncrasies, you don't want to get too far from the underlying language. And it seems evident that typescript is where it is headed anyway, anything else is much more of a gamble (even, or especially, with web-assembly on the way). Yes, lipstick on a pig, is better than a beauty pageant of pigs. And if employ-ability is your main concern, then you know what you gotta do.
Sorry I forgot to add the link. Updated the post 
All it boils down to is some people preferring stricter languages. Some people don't think it should be about smashing out code as fast as you can, but taking the time to write the best code you can. Also you've put words in my mouth, I started off by saying I wasn't against it, just that I don't see any real merit in it. &gt;So far, the best argument for not allowing trailing comma is "I want the last element to be treated differently because there's a 50/50 chance it might inconvenience someone doing something that I think is dumb" Not really. The last argument isn't being treated differently, because the comma isn't a part of the argument; it's a separator, indicating that something should come after it. I struggle to think how people who think commenting out an extra comma is too much work would cope if they were to work with strictly typed languages, or indeed if they were working with a language that wasn't as forgiving as JavaScript. Surely you could make eerily similar arguments about types just being extra work, having to cast to change and explicitly stating each type on definitions.
For all we know it's be slower in current engines, but either way it's worth counting as an iteration pass when thinking about the number of times you have to loop over the list in a given operation.
I didn't say anything about you at all.
&gt; everybody Most people don't make use of trailing commas, though.
My understanding is that what you are talking about is called manual dependency injection. I haven't read the SOLID principles book (been meaning to), but I think I get the idea behind it.
TypeScript, because it offers good tooling and because its d.ts stuff also works with JS, Dart, and Kotlin. Writing libraries/frameworks in TS seems to be the most convenient option for all parties.
OK thanks didn't see that typo. You can build robust JavaScript systems with other people if you take full advantage of modules (each with its own repo and readme for example) and unit/integration testing. MS sure acts like they want to be _perceived_ as not being evil anymore. But you _still_ can take say any 5 web applications -- 8 times out of 10 they will run fine on Chrome and Firefox, but they _still_ either will not run without tweaking on MS Edge, or they cannot run at all because of missing features. There are a billion $ reasons MS keeps it that way -- to preserve their desktop monopoly against the encroaching web. Same reason they made up a bunch of BS about WebGL being a security risk -- when IE and its variants have always been the biggest security problem ever introduced to computing. 
I was talking about the build system
It looks like you're almost there-- you just need to clear off the old points before you draw them. Try adding these lines before your for loop: stroke(0); rect(600, 0, 600, 400); stroke(255); you'll probably also want to move your guide lines from the setup() function to that same section too, so they'll be redrawn. It looks like you might need to change the coordinates so they're where you think they are :) .
TypeScript, because it's a proper superset of JavaScript, and its type system is designed to be compatible with all existing JS libraries. This means you can rename your .JS files to .TS and boom, you have TypeScript now, because JS is valid TS, but with more features. Most of the other languages you're mentioning are islands on their own, so they have ecosystems that require significant effort and investment to maintain, and once their communities decide they're bored with that language, its ecosystem and support will be gone. Not good for business if your app is written in such a language. While TypeScript ecosystem is in fact the JavaScript ecosystem, and it closely tracks ECMAScript developments so it can stay compatible in the future (many of TypeScript's features are future features in JavaScript itself). This alone makes it much more trustworthy in the long run.
Flow looks nice, although it still requires an extra build process. Not a big deal for the client where a build process it pretty much required anyways, so another step isn't a big deal, but personally I try to avoid a build process on the back end.
Been using Dart a lot the past couple couple months. Love it. Not strictly a compile to JS language but that's one of its bigger features imo.
bump
Static typing makes renaming a function a one click operation, refactoring code safe and foolproof (you'll never forget to update some reference), and documentation for other devs 10x better than without types. You don't *need* any of that, but once you have it, it's such a boon to productivity and dev happiness that you'll never want to go back.
Choose your own server-side protocol and it is possible to just use JS and DOM on the client side.
I'd say they are the same. The only difference is the definition of facade uses the term "object", but I think you can extend that to mean any kind of interface. When you wrap a library, you're usually providing a simplified interface because you're only exposing the functionality you're using (rather than the entire functionality provided by the library).
Same for me about lodash. I made a "[poorMansLodash](https://gist.github.com/samueleaton/aa96663f536bf3942630)" gist a while back that I keep adding to so I can grab a small function when I absolutely need it. Anything to keep my codebase smaller.
Hello, I found potential issue with configs, that might cause error you got. Please download new version from https://edanchenkov.github.io/MenuTube/. And replace your local MenuTube.app with the new one. 
JS's OOP-ery is rather unique...
wall of text. use some line breaks, bro!
I've never heard anyone make reference to 'function inlining' as normal form reduction. Speaking in the general case: The compiler typically cannot do this because the outcome of a function is unknown until runtime. Additionally, in a mutable language, the process of any function may have side-effects beyond its output. In this specific case (`[x,y,z][0]`), this would be called a structured array optimization in some literature, or a subclass of array lineralization, but definitely *not* function inlining. 
Nope, consider the libraries on npm, you sure need to check multiple node.js versions support if you target them, for example you can't not abandon people who're still using node 4 now. Node isn't like browser but check out http://node.green/
Supply your code too, what exactly isn't working. It could be a number of problems, bad src, bad id's etc
Thanks for the feedback! Yep, it's the basic bootstrap css for the site; I'll look into further customization. Thanks!
I did an experiment of importing subsets of lodash and it wasn't smaller than what I could make myself. I need some of my scripts smaller than 5kb for work, and Lodash will add more checks to functions so that it fulfills several edge cases that I won't ever need.
The first step I take in managing old code is renaming the file to .ts and fleshing out the typings. It makes it an order of magnitude easier to work with after that.
I guess it's obviously no one will use this/travis/circleci to test against multiple node version if they're building an app
I'm just interested in what benefit you get out of a dynamic language after 20 years.
Elm is the big name in the realm of alternatives, after ClojureScript. The best thing it has over the others is that it has its own ecosystem (which is both a benefit and a drawback), and has, within reason, zero runtime exception (that's huge. The difference between "almost none" and "none" in the Elm sense is drastic). If it compiles, it will work. It might not do what you want, but it won't be because it crashes (give or take because of Ports). The interop with existing stuff is bleh though, so Elm is best suited when you're doing something from scratch with few dependencies. Companies doing Elm don't seem to have too much trouble hiring because a lot of people want to do Elm and just can't find companies using it. In the tech hubs on the west and east coast there's reasonable amounts of meetups and hackathons and stuff with Elm. The functional concepts you learn are portable, so it's not like its useless knowledge if you end up using something else. The next one for me will be PureScript, because with Pux, you get to essentially use Elm but with React and CommonJS ecosystem interop. Cake and eat it too. A bit harder to find people for than with Elm, but existing knowledge is more reusable, and it's 90% the same thing as Elm. Keep in mind that when using those things, the ecosystem doesn't go away. You still need to optimize, code split, your CSS still needs to be processed, your images still need to be handled, your code still needs to be deployed, and you still have a compile step. You save a few dependencies, sure, but the ops parts are still there. 
Fair enough! Thought that might be the case but wanted to mention it in case you were unaware.
An example on jsfiddle.net or codepen.io would help us a lot.
What other language can be used for front-end web development?
If &gt; I'll have trouble finding work is a concern, then really only JS and maybe TS are options.
Are you sure it's the `mouseenter` callback triggering it? Do `#kDropdown` and `.hidden-dropdown` have the `.hide` class applied by default, in your HTML (if not, they should).
Pretty cool, but this is probably somethin you would do in a CI. For my own packages I just let Travis run with multiple Node versions.
IMO, this post contains bad advice. 1. Telling a would-be webdev to learn another language before learning JS makes no sense. Sure JS varies somewhat from other languages, but most things are very similar. Classes, functions, variables, etc. Few people would have the patience to go learn (for example) C#, then turn right back around and relearn another language. Cut out the middle man and learn other languages when they fit a purpose. 2. I vehemently disagree that it's more important to know a framework than a language. This was a massive issue when Ruby on Rails was in its prime. You had devs with great RoR knowledge, but their Ruby knowledge was lacking. Similarly, a lot of my coworkers couldn't begin to program a static page without jQuery. Strong fundamentals makes it trivial to learn frameworks, but investing in frameworks without fundamentals can leave you in a rut. 3. Due to my strong JS fundamentals I was able to pick up React+Redux in less than a week, and I just wrapped up the basic functionality for a production application at work yesterday. OP: Id recommend really getting the fundamentals down, and then analyze local job postings to find what framework has the most employment opportunities. 
Under the surface, yeah, but ES6 syntax would feel very familiar for most people who use classes.
false.
I'm a bit of a hobbyist programmer, mostly in javascript, but there are a lot of things I run into in the javascript world and I end up having to ask myself "why?". I usually just use javascript, HTML and css when I need to - but I run into questions like OPs and I get kind of worried that I'm missing out on something. Things like compilers, stacks, etc, I have no idea if I should be learning about - and while I'd love to, I just can't seem to find a reason to dedicate time to delving into them. Can you(anyone really) give me a straight forward answer on why people use these, situations I can use these "for fun" while learning? 
I learned how to create a var. It's something! 
I get downvoted every time I suggest this, bit honestly try Ember. It's a really good way to get out of dependency/JS-fatigue hell. It doesn't have everything you're asking before, but it's a good way to stop worrying and just accept a single standard to get yourself writing code.
Generally this kind of tooling helps with larger, complicated projects. They'll allow/encourage scalable coding practices. For example, many modern UI libraries require you to break up your UI into small and reusable components which will generally result in an easier code base to reason with. Generally these libraries have a high up front cost for learning/setting up but allow for quicker development and better code (in large code bases). At my current company we have a large webapp, which is built on react and redux but our landing page is built using plain javascript and some jquery. It's about understanding the pros and cons of your tools.
I use non traditional languages quite commonly for lazy side projects. For instance now I'm working on a personal file sharing for my raspberry pi server which is powered on the backend by rust and frontend elm. It's a nice to have and not something I need. When I get a few hours of spare time I hack on it. Anytime you don't really have a time constraint is a great time to explore languages and learn when you can apply them or parts of them to more serious projects. A terrible time to explore a language would be anything that needs to be done on time. Exploring any new technology always results in unforeseen hiccups or you may find it just doesn't jive well with you. These are great lessons to learn when there's no pressure, not so much if you want to get done. Usually one little project is all you need to learn most of a new tool, after which you'll find you have a really good understanding of new concepts and sometimes even a new framework or language to carry into your next serious project. 
&gt; you don't have a clear view of what you actually want to get What I want: * One language to rule them all * Fewer dependencies on libraries that comprise much of your code (on my last job a lot of time was spent replacing Q with Bluebird 2 with 3, then upgrading to backwards incompatible features of 3. Same thing with underscore -&gt; lodash -&gt; lodash/fp. Why? Because that was the ask. * Optimal readability and terseness * No need for linters. * Adherence to open-source best practices that engender intuitive understanding (I've worked in developer marketing at a leading SaaS company. Their proprietary language was poorly documented and intentionally inscrutable so as to create a market for very expensive certification courses. Their strategy paid off.) * Immutability, composability, type checking, fewer runtime errors, asynchronous functions (callbacks are unacceptable, that's another conversation) * Nice to have - a language that runs on the client and that can run in both JavaScript and JVM environments (maybe this is an uninformed ask on my part) &gt; What React, Express or Knockout provide you, you won't magically get it by switching to another language. Exactly. What other languages have to offer is language features, like immutability, asynchronous functions, composability, type checking. Since it will be transpiled to JS, the libraries that are ultimately leveraged to accommodate those features should be opaque. &gt; You mention Elm is "really a replacement for React" and that there is a good example of the difficulty... Elm is both a library/runtime and a language to use that runtime/library. Unfortunately these two things are not separate. Exactly. If you're going to use Elm, go all the way and leverage the architecture. What's the point of a bridge? The more technologies you employ, the smaller your pool of qualified developers. &gt; You don't have a clear view of what you actually want to get. I want a language with the constraints outlined above that transpiles to JavaScript, that supports a functional programming style, and that will be relevant for years to come. &gt; I would also suggest solidly establishing your goals. That statement opens up an entirely different can of worms that is beyond the scope of this reply.
Sorry, I meant native languages. I'm familiar with all of the transpiled ones.
unless `x` is declared outside of the scope of `adder` then `x` will be an undefined variable, hence the error.
DNE
Except that the linter prevents actual errors, whereas the type checking stuff doesn't.
What? They're essentially functioning by the exact same mechanism--statically reading your code to meet some criteria and give you warnings. You may not be getting type errors because you're being diligent. I'm arguing that, just like a linter, if you added types in certain places, you could write code more quickly or more confidently. Hopefully you're not saying that you would have runtime errors without your linter... I assume you're saying you catch them more quickly with one.
&gt; The thing is, you don't need to have a lot of dependencies to write an app. Exactly. &gt; I use Mithril.js, ES5.... Mithril is not an option unless your company uses Mithril. ES5 will eventually go away, literally and/or figuratively. At some point you will have a harder time finding people that know ES5 then ES6+. &gt; I can produce apps just fine...I'm a month ahead of schedule I don't know the context of your schedule. Have you launched? Why write your own toolkits when there are other people writing them? There are more eyes on them. Maintenance is distributed. A major problem with developers that insist on writing their own libraries is that they believe it is bug free. Developers may accept that there will be bugs, but at some point they have to tell themselves "this works, I'm done" in order to justify submitting the work. Most likely, if you're writing your own library, other developers on your team are using it and now they have to trust the library works. When they have bugs, they have to make sure their code works, then they have to make sure your code works. They will not like you if they find bugs in your code. If it's a bug in lodash, there's a good chance someone half a world away has already opened an issue. The idea that good programmers write their own libs is pernicious. The more work you create for yourself, the less time &amp; energy you have to distribute among the work. &gt; Learn to say no. I would prefer not to. Yes, boundaries are important. They wouldn't need to be established if humans weren't flawed. There can be enormous energy expended in saying, "No". For a "no" to be accepted, it presupposes trust, and trust is not established over night. You may have to back up your "no" with time consuming research in order to convince the asker that it's legitimate. You may be saying "no" to someone that already said "yes" to someone else, and to accept your "no" will come at a cost to their reputation. Some people interpret "no" as "that's so stupid. How could you even ask?". Knowing how to say "no" is an artform, and if I had a talent for it I might have a different career. "All truth passes through three stages. First, it is ridiculed. Second, it is violently opposed. Third, it is accepted as being self-evident." - Schopenhauer &gt; Do you really really really need that arrow function syntax. yes. 
Haha, you maybe didn't heard for https://github.com/developit/mitt - 200b. It exposed before few weeks here and in github trending. It is ES5 too. When more browsers support Set, it can be 160b. There have few opened issues and features that we dont want and want, so it depends what features is needed. If we support chaining e.g.`emitter.on('foo', fn).on('bar', fn)` and etc we should drop support for some other thing. In just depends. Edit: Why not just write it in pure language and use uglify then, so contributing would be easier. Edit2: I did a PR to `mitt` but we are waiting the author to get some time. My PR cleans almost all issues and other PRs. Edit3: Complete clean source https://github.com/tunnckoCore/mitt/tree/refactor &lt; 200b
For clojure, the book Clojure for the true and brave. It's free to read online. 
&gt; Probably 90% of jobs are writing in plain JavaScript What is plain JavaScript? If you're coding for CommonJS/AMD and using jQuery/Bluebird/Lodash, that's not plain JavaScript. Now you're relying on third party language constructs. Whether the plain JavaScript is generated by a transpiler or lives in a dependency is just a matter of compile vs runtime.
This is exactly what I was thinking but for some reason I couldn't form the right words and had to write a novel
&gt;[**If Woody Had Gone Right to the Police [0:05]**](http://youtu.be/H3NxwSpLeEQ) &gt;&gt;...this would never have happened &gt; [*^Chris ^Warren*](https://www.youtube.com/channel/UCu_3NJJRb1tUReHeLDXorfw) ^in ^Comedy &gt;*^25,291 ^views ^since ^Feb ^2015* [^bot ^info](/r/youtubefactsbot/wiki/index)
Does Not Exist
O_o Surely I know what I do or don't need... linters save me from thing that occur from time to time. Type checking add extra cruft for something that _never_ happens
Well I think it was more they realized that to have people adopt Angular2 they had to make to easily accessible to JS developers. Typescript is much easier to transition into than Dart. Regardless if Dart is an objectively better solution it does have an ever so slightly higher learning curve as it's an entirely new language rather than just being (mostly) some syntactic sugar for JS.
But wouldn't `console.log(adder("var x = 2 + 2")) ` raise an error as well?
Vars are hoisted 
I want a blowjob alarm clock and a Bugatti Chiron. 
One language that hasn't been mentioned here yet is F#, so I'm mentioning it now. It's functional-first, but also supports OO. It can run as a backend or API server. It can compile to Javascript via Fable [1]. It can be used to build native apps for Windows, iOS, Android, and Mac. [1] http://fable.io/
&gt; Dojo, Mongoose, Knockout, Durandal, Sails, Express, CoffeeScript, and Angular 1.x. BaconJS and Rx.JS Solving problems and the whole mantra... What do you think about bucklescript?
If your goal is employ-ability, learn a few of the most popular options in use by the big guys. I can tell you right now that means Angular2 and Typescript should be on your list.
This seems cool. 
ClojureScript?
We really need to get google and Microsoft to back a language to replace javascript. We're writing languages that get translated into java script and that is when you know the dependent language is dated and needs to be rebuilt.
&lt;html&gt; &lt;button id="mybutton" value="val" onclick="myfunction"&gt;click me&lt;/button&gt; &lt;script&gt; var myvar = ""; function myfunction () { myvar = document.getElementById("mybutton").value; } &lt;/script&gt; &lt;/html&gt;
What is the 2nd "document" in: let qs = document.querySelector.bind(document); supposed to be? I'm getting an error on this line
Also You Don't Know JS
&gt; Maybe this helps (or maybe not). That was the first place I checked. I was confused by Dart's number one spot, beating out even TypeScript. Seems fishy. &gt; Developers that are really well qualified will have little problem picking up (reasonable) technologies. That's not necessarily true. Things are changing but for years it seemed like Java (and especially C#) devs couldn't grok JS and vice versa. &gt; The only two options worth considering in this regard may be Scala.js and Kotlin. This is the first I've heard of Kotlin. I'm confused by the existence all of these technologies. It's good that people develop them and that the ideas behind them are disseminated, but where are you going to find a job using Kotlin? &gt; I have successfully worked with JavaScript for many years without needing a linter. So have I, but once I started using them I saw no reason not to use them. I think having a uniform coding style across your team makes it easier to fix bugs in code you didn't write. &gt; That's quite subjective. I would suggest ClojureScript, but what I like about its readability may not be the same you want. I do, however, find peculiar that you'd point to Scala.js as a good choice in this regard. Scala.js looks very similar to JS, which I've been reading for years. It is subjective. &gt; The best languages (IMO) know they shouldn't incorporate userland functionality into the language itself but put that in libraries. The features I'm asking for though should be standard, more or less. You're right, most of them are in ES6, but immutability, type checking, and reactive features aren't and I'll still need _.compose(). Dicking around with immutable.JS prompted this question. &gt; But then again, what is it that you were using from Q/Bluebird or underscore/lodash? I ask because well, Promises have been incorporated into the language. The codebase was written before they were incorporated into the language. It's like when you go to a nice restaurant and don't finish what you eat. You just see it as food, but the owner sees it as money going in the trash. There wasn't any pressing need to migrate to ES6 until we moved over to React. And those features really aren't incorporated in the language, they are incorporated in the language that you're transpiling from. The reasoning behind the upgrades was that they performed better, which is true, and probably because they were cooler. Then in lodash 4, some aliases we were using were removed. C programmers don't have to deal with these shenanigans. 
I worked for the state Fish and Game department and they let me do whatever I wanted. One guy wrote his own programming language to use. I used Meteor, which was awesome. BTW I think the answer to your main question is OCaml. It has one of the best JS transpilers. 
DISCLAIMER: This comment is too long because I haven't had time to make it shorter. Typos and grammar are left as is. There was no second review, just thoughts thrown as they came from my head. The definitions of the patterns came from my head, no research was done to confirm. --- &gt; I'd say they are the same What are the same, a decorator, a proxy and adapter? They are different than Facade, no? &gt; The only difference is the definition of facade uses the term "object" That's a detail, I guess. The examples on the link are also using OOP with JavaScript, even without the `class` keyword, just using closures. So yeah, it's an object oriented interface nevertheless. &gt; When you wrap a library, you're usually providing a simplified interface because you're only exposing the functionality you're using (rather than the entire functionality provided by the library). Not always. I can wrap a library and keep the interface. That would mean I'm not using a Facade anymore because the Facade requires the interface to change (or maybe not? Correct me if I'm wrong.). **Let's say there's a cookie lib who has only get/set/remove. This could be a proxy:** Definition of a proxy: Add additional behavior to the object without changing it's interface. CookieProxy = function() { get: function(name) { return Cookies.get(name); }, set: function(name, value, attributes) { Cookies.set(name, value, attributes); }, remove: function(name, attributes) { Cookies.remove(name, attributes) } } Despite the point above, if the lib adds a new method called ".getAll()" would the pattern being used change the name? Would that be called a Facade or would that still be called a proxy? Maybe it's not a proxy since the beginning because it doesn't ensure statically the interface will be the same and it doesn't change the behavior (see the proxy definition). But then, if it's impossible to ensure the implementation will always follow the interface in JS because it's dynamically typed, so can we ever create a "proper" proxy in JS? Even if we are changing the behavior because of the definition of proxy or not, we are still wrapping the vendor and it has benefits. Is it worth creating another layer doing the same thing for the sake of Single responsibility? **Let's say there's a cookie lib who has only get/set/remove. This is a decorator:** Definition of decorator: Wrap an object, changing it's behavior by also changing it's interface. MyCookie = function() { // default path: /, for example set: function(name, value) { Cookies.set(name, value, { path: '/' }) }, getAndRemove: function(name) { var cookie = Cookies.get(name); Cookies.remove(name, { path: '/' }); return cookie; } } This is a decorator because we added behavior changing the interface. It also has the benefit of wrapping the vendor, so maybe we don't need an additional layer? It's no a Facade anymore because it's just adding behavior. Would you consider both Facade AND decorator then if we assume this is enough to wrap the vendor? **Let's say there's a cookie lib who has only get/set/remove. This is n adapter:** Definition of adapter: Change the interface by keeping THE SAME behavior so that the interface can adapted to different use cases. MySmartCookieFactory = function() { createInstance: function(attributes) { return { get: function(name) { return MySpecificPurposeCookies.get(name); }, set: function(name, value) { MySpecificPurposeCookies.set(name, value, attributes); }, remove: function(name) { MySpecificPurposeCookies.remove(name, attributes); } } } }; The object resulted from `createInstance()` is an adapter because it was constructed with a different interface, albeit keeping the same behavior of setting the cookie in the end, with no additional feature. Is that a Facade too along with an adapter? Maybe. The Facade could be because we're wrapping the vendor and providing a simplified interface while the "adapter" is just a side-effect? -- I guess the point is that there are too many terminologies and the focus of this, as stated in my previous comment, is only to wrap the vendor. That don't necessarily means we need to provide a simplified interface because that might come with additional assumptions based on the [developer's own beetle](https://medium.com/@fagnerbrack/wittgenstein-s-beetle-in-software-engineering-dcea89a5db92)
&gt; &gt; var myvar = ""; &gt; function myfunction () { &gt; myvar = document.getElementById("mybutton").value; &gt; } Save that as a JS file, then reference it in the HTML file, along with the `&lt;button ...&gt;..&lt;/button&gt;` code in the body. 
Why does this get you angry? It's Just JavaScript.
 There's no accounting for taste. 
I've heard people complain that using TypeScript breaks their NPM dependencies. 
Startup in Seattle.
&gt; reference it in the HTML file Right before &lt;/body&gt;, that is. It won't work when it's included in &lt;head&gt;, because it doesn't wait for DOMContentLoaded.
Thanks for sharing that.
JavaScript the good parts
&gt;TypeScript is the BMOC right now. BMOReddit you mean. Nowhere else. Don't believe everything you read on reddit. I would use C cause we use C cause C works on everything everywhere with the highest performance of them all. 
It's a little more than that, though. Angular 2 expects you to use TypeScript.
&lt;script src="myfile.js"&gt;&lt;/script&gt;
He meant no transpiler
Ah that was a typo. But even after deleting the bounce function within the move function, it wasn't working. /u/griever989 solved the issue for me. Do you have any ideas how this can be expanded to have the pucks bounce off of each other?
OK but what is wrong with `pify`?
JavaScript is an interpreted language. The code doesn't get compiled. To have a language (typescript) get interpreted into another language (javascript) just doesn't sit well with me. It's just bad programming architecture. Languages shouldn't be dependent on each other. 
/r/cscareerquestions
Woah. Perfect. Thank you! 
Tell that to my aunt who was making $100 an hour in the 80s writing COBOL. Now she watches television.
You will likely have a hard time getting a visa without a degree and only 4 or 5 years of experience. You don't absolutely need a degree for a H-1B, but roughly you need 3 years of experience for each year of college you lack. You may be able to count any years of tertiary education you have even if you dropped out though. That's not the only requirement either, you probably want to research H-1B requirements. 
I've already taken a pretty in depth look. It increasingly looks like my options are the internship visa or physically going to the USA and pummelling companies until they offer me a job. For anyone who might come across this thread in the future, [this](https://l.facebook.com/l.php?u=https%3A%2F%2Fblog.sourcing.io%2Fvisa-guide&amp;h=ATMoKLIyxnYIhV9KQfDKMXhjA9Wz9mFK9Uy74JngtzjxnV_e9AFaJHvhbihGF56AOsjzoa0JFsyOPMQeasxWXAFd3pOMmZs37JyyV2kkmlCrnRnXX532Ni0FPufX8juhSOmTqNuwngt0Tw&amp;s=1) is an amazing readup.
Maybe you should choose to not be a developer as all languages fit this possible fate.
C++'s type system would be like a rocket ship assembly kit where the instructions are so complicated that people give up and just build a skateboard instead.
Try reading through the V8 doc I linked above, it should clarify it. From the second paragraph: &gt; V8 was first designed to increase the performance of the JavaScript execution inside web browsers. In order to obtain speed, V8 translates JavaScript code into more efficient machine code instead of using an interpreter. It compiles JavaScript code into machine code at execution by implementing a JIT (Just-In-Time) compiler like a lot of modern JavaScript engines such as SpiderMonkey or Rhino (Mozilla) are doing. The main difference with V8 is that it doesnâ€™t produce bytecode or any intermediate code. ---------- &gt; which doesn't get "compiled" in the regular sense of the word. I'm not sure I understand what you mean. The "C" in "TSC" stands for "Compiler". TSC is quite advanced, and is a compiler in the only sense of the word.
It's not used by Opera, IE or all the other browsers so it doesn't matter.
It sounds like you're trolling. If someone is reading this thread and is genuinely curious about other platforms' JITs: - Opera uses V8, but in the past has used https://dev.opera.com/blog/carakan/ - Internet Explorer uses Chakra https://github.com/Microsoft/ChakraCore 
Yeah that's right, the discipline of maintaining composition roots is the hard bit :)
Yep, that's why I said it's not a huge deal. If you're calling the function multiple times, that extra allocation might matter though.
Sure, but you don't know if the tests could be passed on CI before pushing the commits, you can keep your git history clean this way
You need to set the `tabindex` attribute on your `&lt;div&gt;` to make it "selectable" so it captures the keydown event.
You're capturing the _reference_ variable `i`, which means it's going to always be the last value that `i` gets set to. What you want to do is create a function that takes in `i` and returns a function that calls `shart` with the captured variable.
The YDKJS series is fantastic
If you tell a CBA that you are doing interviews in the US you'll be refused entry.
Or just use "let" to make "i" block scoped. 
Make 'i' block scoped in your loop for(let i=0;i&lt;myArray.length;i++) {
I've added my own answer, but here's an example of the method lord2800 has suggested. function createShart(i) { return () =&gt; { console.log(i); } } for(i=0;i&lt;myArray.length;i++) { const shart = createShart(i) myArray[i].addEventListener('keydown', shart); } 
You need to use closures in such cases. In your case, you're using reference to var `i`, so all handlers are executed after the cycle is finished and `i` already set to 5 (after last cycle). Here is how you can do this: function shart(local_i) { // making the closure return function(e) { // this internal function will be your event handler // here you still can use event (`e`) argument // and in the same time, it will use the value from the current context, not from the cycle itself console.log(local_i); } }; for(i=0;i&lt;myArray.length;i++) { // pay attention here: // to save exact `i` value // you need to call `shart` function here in time of binding // (not in time of event execution) myArray[i].addEventListener('keydown', shart(i)); }
I am currently using [FCC](www.freecodecamp.com) and currently enjoying it. The material really makes you think and you'll also need to do further research
Sololearn is what Im using. It helps making programs along with the exercises commenting it with explainations that help you! 
If you want a quick overview of the language, Codecademy is great for this. Otherwise, Free Code Camp is good and will give you some real world experience Learn X in Y Minutes is an awesome quick reference for pretty much every language, but it's for experienced programmers. It's late and I'm tired so I'm just gonna drop a list of books: Head First Javascript Head First HTML5 You Don't Know JS Javascript The Good Parts The Pragmatic Programmer Eloquent Javascript
These are pay courses on Udemy, but they're good. Take them in order. [The Complete JavaScript Course: Build a Real-World Project](https://www.udemy.com/the-complete-javascript-course/learn/v4/overview) [JavaScript: Understanding the Weird Parts](https://www.udemy.com/understand-javascript/learn/v4/overview) The second course covers prototypal inheritance and functional programming. Also, here's a link to get the courses for $10 each: [$10 course link](http://onlinecoursespro.com/udemy-coupon-code/)
False.
The learn X in Y for JavaScript is abysmal. Much lower quality than the other languages from what I can tell (which isn't much since JS is the only language I know well).
That's cool. Now go and learn everything about 'hoisting'.
A great book, but not the best student book
He can do interviews while here on the Visa Waiver Program, but it will certainly perk up the ears of the CBP officer and he should be very clear he plans to do interviews and then leave and that he understands he can't work while here under the VWP (and it's not completely clear he does understand that from his posts). It's ultimately at the discretion of the officials at his port of entry whether he is at risk of trying to work illegally or overstaying and they can deny him entry if they make that determination. 
[removed]
At a glance, Fullstack React is using functional components, jest, and redux so it's probably better but you might need a few tips from elsewhere if you're just getting started.
I would highly suggest looking into using spritesheets when you need to load in 350 images. 1 big file vs 350 http requests with tiny images makes A LOT of difference!
It sounds like you don't know how a server is supposed to operate, see [this page](https://developer.mozilla.org/en-US/docs/Node_server_without_framework) for a simple implementation of a static file server in node. The way it works is this: * It receives a request in the form of a URL * It decodes the URL and attempts to read the referenced file * It writes the contents of the file to a response and sets the mime type of the response in order to tell the browser what format the response is in * It then sends the response to the browser
Got it! Thanks man. I think I will start learning some Electron. Any tips or something? haha. Thanks ;3
Write it down in pseudocode and then start converting it into real code. There is no crazy API you need to make this work, just logical thinking. You have all the knowledge necessary to implement this - that is, comparing numbers and using logical operators.
Pretty much. How are you getting the images right now? 
A couple things: It looks like you're not limiting the args array to the length of the provided function - 1. This will lead to the callback being in the wrong place. Maybe you meant Array(fn.length - 1), not Array(arguments.length). Another thing is that I think you could use rest parameters and stuff, as well. Like this maybe: function (...args) { args = args.slice(0, fn.length - 1); while (args.length &lt; fn.length - 1) args.push(undefined); // etc etc }
&gt; Element creation Via innerHTML. In a separate event handler. &gt; custom attributes Buttons have a "value" property. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-value &gt; pseudo elements to display content from css Keeps it DRY. &lt;button value="+"&gt;&lt;/button&gt; if(target.value === '+') etc. &gt; even creating a shortcut to querySelector I explained that one, but going by the downvotes I shouldn't have, I guess. Anyhow, even if you don't know what bind does, you can see that it was used to create an alias. &gt; You're over-complicating things for a beginner I was just reusing an older event delegation example. It creates new buttons for demonstrating the benefit of using event delegation.