Posted sample code as a reply to my OP. 
WebStorm has this functionality with native JavaScript or ES6. It is wonderful, but not exclusive to TypeScript.
It's called a "callback".
You would have to pass back the response in a callback. You can't use a `return` like that in asynchronous code.
This is actually really cool. Demo sometimes doesn't work though.
Could you give me an example? I want to eventually return the data I get back from the response.
I just know what is the electron shell, now, automated electron shell is new to me.
I'm on Yosemite / Chrome 44. It seems to 'stop working' when I hold down the mouse and drag outside of the playable area. It highlights the area around the keyboard for a brief moment and then stops registering events.
Also on Yosemite &amp; Chrome 44: Using the 'I' or '9' keys breaks the demo and I have to reload the page. Very cool idea, though!
Stuff of which I have little to no knowledge. Thanks again!
Nodejs really brings some niceties to JavaScript!
I don't see any attribution to the Scala scale library you're using here. Did I miss it?
on our [github page](https://github.com/abbernie/tune), in the overview at the top of the README, we link to the MTX tutorial &amp; archive compiled by Victor Cerullo, which we followed to build this.
No problem. Is it working correctly now?
It does amuse me that there is now a two, three and four.js 
Yeah, but then I have to build a parser from the formal expressions like I have given to regex. And that's the part I'd like to avoid, applying a filter chain via lodash or something isn't hard.
I didn't think of selections, that's a very good point, and nobody should be styling plain old spans. I'm excited for webpack-require, looks like it'll be awesome. Probably everyone and their mother will make an implementation of `&lt;If condition={...}&gt;...&lt;/If&gt;`. It would be great if there was an official one, mustache kept the rabbit hole small by only giving you an if and an unless. It really isn't much more than a maybe. We'll have to agree to disagree about dangrouslySetInnerHTML. I think something like setTrustedHTML would be more friendly and gets the same point across.
Interesting. Totally jarring tonally... but interesting. :)
That, indeed, sounds like a very good solution - did not know anything about before...
It's only a few months old now and as I'm the only developer of the project getting it out there and in the public view has been a little challenging. The website is www.hamsters.io , I would love any feedback you have but I recommend using my library over trying to roll your own as I've done the leg work to make it extremely flexible and performant, you can not only run single functions across multiple threads but you can also run many parallel and non parallel functions concurrently.
A real worl article http://artandlogic.com/2013/08/client-side-fulltext-searching-with-fullproof/
I'm not.sure what you mean by language but as I said it only supports north American time zones at the moment, I'm sure it can be updated to support more 
lol seems there was at one time a library called one js, but it seems like it was more a precursor to browserify. Not a one dimensional non observable line drawing library like I had hoped
No. Even if there is a way, no. Ever wondered what the A stands for in Ajax?
yeah anything useful you think i could build in a short period of time? my friend said maybe some sort of web shopping cart but that sounds kind of boring to me. 
We don't use a CDN anymore because most of our web apps these days are bespoke and don't have heavy external dependencies and we bundle everything with webpack, but for websites etc. I have personally used these in the past: * https://cdnjs.com * https://developers.google.com/speed/libraries/ * http://www.asp.net/ajax/cdn They all do exactly what you would think.
Thanks, you are probably right. I was hoping for something more ready-made, but maybe I'll have do dive in parser generators :)
go to npm and put in fuzzy theres 3 or 4 good fuzzy matching libraries. not sure on the boolean expressions library
Thanks man, I was doing a university course in Javascript which they wanted us to learn from scratch but I also had another course with PHP of which I knew neither so I was trying to learn 2 at the same time and probably confusing myself.. I hope these resources can help many thanks.
I'm no expert either, but have you tried just calling: &lt;script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"&gt;&lt;/script&gt; once between your &lt;head&gt;&lt;/head&gt; tags?
You're right, it says "Redirect at origin 'http://getbootstrap.com' has been blocked from loading by Cross-Origin Resource Sharing policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://futwatch.com' is therefore not allowed access." [This is the link](http://futwatch.com/pack-simulator/beta.php) in question Time to google "Access-Control-Allow-Origin"
yea thats a job for phantom js im sure you can find a script, this exact feature is always requested. i would google `site:stackoverflow.com phantom.js save a local copy website that uses ajax`
shakas!
Nice. That page is all jacked up. Do you know you have a bunch of scripts before the DTD and opening &lt;html&gt; tag?
If the browser/OS language is set to a language other than English, you wouldn't be able to parse out "EST" cause it would say "Hora del Este" or something like that. 
Google Closure Compiler is another great alternative. I'm wondering if I'll have a good reason to switch from closure compiler to Babel anytime soon. 
&gt; Any runtime signature changes will make you hate TypeScript This makes me hate JavaScript. Any time I encounter this, I fix the code to make this not happen, even if this means creating many adapters. Changing the data type a variable contains at runtime is a big no-no everywhere but JavaScript, and it's just insane. &gt; It may be worthwhile to at least take a look at Facebook's Flow, since it provides static type checking without going 'all-in' on a new language. This is true of TypeScript. You can use none or all of TypeScript and still get advantages from it.
Also VS Code.
Alright Dwight. A stated goal of TypeScript is to conform to the ECMAScript specification while adding types. TypeScript not supporting every feature does not exclude it from being a superset.
It's not *my* code, it's just a simplification (hilariously yes, a simplification) of the code module I'm working with. I messed up the loop_obj reassignment because it was actually meant to be a prototyping line like the other prototyped objects, I just didn't cut that stuff out well enough. Nothing was meant to be verbatim, the 'logger.log' lines were just standins for actual error logging methods. I'm almost certain there aren't any exceptions because they'd be logged - there's no error logs anywhere though from this. It just exits where the "Actual" exit message is, instead of completing the loop (it only runs through the loop once). 
if test is false if test is not the same as demo if this event doesn't occur 
I think that having an interface for your JSON structure is invaluable when you want to update it. Just change the interface definition and the compiler will tell you everything that needs to be updated.
Sure it is, you get compile time warnings. I wouldn't want it adding any runtime checks/overhead.
Thank you for the quick response. For the last one does that mean if this event doesn't occur in something or just this event doesn't occur?
Have you seen [tsconfig-glob](https://www.npmjs.com/package/tsconfig-glob)? It is a CLI that lets you specify glob patterns in your tsconfig, and it will auto-populate the files array. Useful if you don't use Atom.
well the exclamation mark negates what is ever in the brackets, so you would have to have the event return a true/false boolean otherwise it will always return true, meaning this if statement would never actually fire 
this problem prompted me to change direction in what i wanna achieve. and so I'm thinking of just parsing the html and present it myself. but thanks for the suggestions
And it might not be obvious either way. "var fn = function() {...}" is available via window.fn if it's at the top of a .js file, since it will implicitly be defined as a property on the global scope. Also, you can have a function defined locally but be assigned to the global scope later. You really just have to read all the code to know.
When did 1.0.0 become such a black sheep?
I'll have to read up on all the code on Friday (I don't have access to it at my house) and see if I can figure out where it's defined.
A pretty good read. Hopefully what you're looking for: http://stackoverflow.com/questions/9915311/chrome-extension-code-vs-content-scripts-vs-injected-scripts/9916089#9916089
I'm already good on what that page covers, namely injecting the content script. My question deals with manipulating the functions on the page with my injected code.
Knew*
You have 2 possible solutions: - if the API support JSONP and you only need to do GET requests, you can use JSONP. - You can have a local proxy server, you'll need to run node or whatever to forward all the requests to the API. using something like https://www.npmjs.com/package/proxy-middleware
still [patiently waiting for android](http://www.reactnativeandroid.com/) ... “Give us 1 month, 4 days, 8 hours, 23 minutes and 44 seconds” at the moment
I was so hyped when I read your post, because that's exactly what I need right now. But then IE11+ an no Safari happened :(
I haven't used tsd for some time now. But when I did I had to first fetch not the master from github, but the @next or something branch otherwise it wouldn't run for me. Then it didn't want to update stuff for me, it might have had something to do with the tsd.d.ts file there, I don't know. Once tsconfig arrived and Atom started automatically collecting all files and managing them in tsconfig things became much simpler and the need for tsd went down. My project doesn't use a ton of external .d.ts files. It is quite manageable by hand. TypeScript in Atom is really good now, as good as if not better than VS Code. 
The goal is to be ECMAscript plus types. The reason why they don't support some ES6 features is simply because TS is still a work in progress. TS isn't actually meant to be a ES6 -&gt; ES5 transpiler. They do a lot of this but some harder features (e.g. generators) will probably never be supported when outputting ES5. You will have to target ES6 in this case. 
I've used jquery before and did find it alot easier than JS.. I'll check out coffeescript and see what that's about. Thanks.
CORS is also a client mechanism. If you can disable the checking in your client, you can bypass this mechanism. Chrome for instance has a "--disable-web-security" flag (beware that this disables security, duh)
It makes a lot more sense now. Thanks!
(I don't know if you're aware, but the links to codewars cannot generally be seen by everyone. Just in case you didn't know.) On the topic, I understand your point, [it's just silly fun](http://i.imgur.com/9IJHGZz.png). But I have to say I felt that was a lot of explanation for a simple trick. Kind of spoils it a bit.
Since [Semantic Versioning](http://semver.org/). With SemVer, there are rules for how you version releases. Unless the major version is 0, in which case most rules don't apply ("Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable."). Thus, one can use SemVer, which is good, but don't have to think about it or actually follow the guidelines, because that is not fun at all. Also, with SemVer, the major version tends to increase quite fast, and no one likes high major versions.
Why the switching between using JSX and not using it? Also Shai missed `burder`
I'm aware of SemVer. Let's look at what it has to say about this... &gt; Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. &gt; Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes. And... &gt; How do I know when to release 1.0.0? &gt; If your software is being used in production, it should probably already be 1.0.0. If you have a stable API on which users have come to depend, you should be 1.0.0. If you're worrying a lot about backwards compatibility, you should probably already be 1.0.0. So, again, when did 1.0.0 become the black sheep? By definition, React should definitely be v1.0.0 by now.
React is still changing the API and breaking stuff. React 0.14 is splitting the vdom and the components API into separate packages and moving addons to independent packages, removing the DOM ref indirection and deprecating `Component#getDOMNode`. So yeah it's being used in production, but on the other hand it doesn't quite have a stable API and isn't worried about BC.
1. Does the company value on-the-job training, and provide it in any way? This can be as minimal as encouraging taking time to research things, to mentorship, tuition reimbursement, certification reimbursement, and travel to seminars/conferences/conventions. 2. Is the company strictly a $TECHNOLOGY shop, or are they open minded to letting things change in the future? 3. What is a developer's responsibility in this company? Why these questions are important: 1. Technology changes fast, and your current skill-set *will* be obsolete in 5-7 years, tops. If your employer isn't doing their part to enable you to move with the times, that means you have to spend extra effort on your own to get there. 2. Likewise with point #1, the company's technology portfolio can also obsolesce on the same timeframe. This is the enemy of business investment, where the attitude is to pay up front and ride that investment out until it doesn't make money any more. Usually this means that the risk of running with old tech (e.g. PHP, ASP, ColdFusion6, Java2, etc.) must outweigh the costs of re-tooling, before things can change. Be aware of where they are on this timeline, and what that means for your portfolio. 3. Developers do *not* have the same role in all seats across the industry. How the company defines "developer" will have profound ramifications for your job satisfaction, stress, responsibility, where the glass ceiling is set, and future job trajectory. Some of us are "butts in seats" coders that do nothing more than fulfill requirements at the behest of architects, project managers, and so forth. Others are more "cowboy coders" that are given very lose requirements and a short timeframe to achieve dramatic results. Yet others are like "sales engineers" that turn around quick (disposable) prototypes for prospective customers. And then there are the "developers" that gather requirements, perform QA, do customer support, *and* write code. There are innumerable permutations, so it's important to know which one you're singing up for.
Hi /u/clintgh, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Right now we have to build applications for each OS in our machines, having to manage versioning, backup and so on. It would be great if there was a thing (like gobuilder) that would build every tag release for each OS
Agree, but those party tricks can be fairly cool. Recommend this book: http://www.amazon.co.uk/Hemingway-Wrote-JavaScript-Angus-Croll/dp/1593275854 
For your little shitty private site: Sure, go for it. I do that as well. But otherwise you want to keep control. CDN goes down/is slow and you can't do shit about it kinda sucks. Apart from that you usually put all your JS code in one file so you don't have to open so many connections and thus a public CDN becomes quite pointless.
Thanks! Our archive was converted from Victor Cerullo's .mtx archive for the Max Magic Microtuner, (http://www.venetica.net/Sites/16tone/mtx_file_specs.htm), which was converted from Manuel Op de Coul's .scl archive for Scala (http://www.huygens-fokker.org/scala)
That is an incredibly useful website.
I feel like "All you need to know" is reaching a little. Here's some things I don't know by looking at the code: * Are class definitions hoisted? * are they block scoped? * can they be used as expressions? * do they have to be named? * can they be called as functions without new? * What if I don't include super in the sub constructor? * does it always have to be the first statement? * if there is no sub constructor, does super get called automatically? * Can you define class member variables in the class block? * getter setter properties? * use string literal or computed member names? * are class members enumerable? * How do I call a static method from within the class? * are they inherited? * is it safe to reference them through the class name in case the class gets redefined to a different name in the outer code? * Does BaseClass automatically extend Object if not specified? * if not, can you explicitly extend null if you don't want it to? On a side note, "! not" also seems like a double negative (given, after all, we're dealing with JavaScript here ;).
`Intl` may be not supported natively in safari or &lt;IE11, but just like it was said... [use a polyfill](https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/Intl) But even without `Intl` it just means you cannot know the user's language settings immediately (on the client, there are other ways of knowing it on the server), noone said you cannot use `formatjs` for organising locale stuff.
Enterprise/corporate jobs, which vastly outnumber the kinds of jobs where that list is relevant.
Yeah, well, the gist was meant to be something like "all the essential features of es6 classes and class inheritance you need to know to start using them effectively" but that seemed like a ridiculous title. But basically the gist shows **features**, it's not a book (neither an article) on es6 specification, and that's what I really wanted to know being familiar only to es5 syntax. Some of the things you mentioned are exactly the things I didn't want bring up because it creates unnecessary confusion for those who just want to get familiar with the new syntax. So things like these &gt; *are class members enumerable?* &gt; *are class definitions hoisted?* have to do more with the specifics of javascript language as a whole, and less with classic Class model. &amp;nbsp; But things like these &gt; *getter and setter properties* &gt; *what if I don't include super in the sub constructor?* are indeed good questions in relation to classic OOP. But it's just too easy to get carried away and create 200 lines of code instead just 40 in pursuit of trying to cover everything. &amp;nbsp; &gt; On a side note, "! not" also seems like a double negative I agree, thanks :) edited that.
See compiled online on official [babel site](https://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=class%20BaseClass%20%7B%0A%09constructor(name%2C%20age\)%20%7B%0A%09%09this.name%20%3D%20name%3B%0A%09%09this.age%20%3D%20age%3B%0A%09%7D%0A%09static%20getDescription(\)%20%7B%0A%09%09return%20%22this%20function%20can%20be%20called%20without%20instantiating%20BaseClass%22%3B%0A%09%7D%0A%09getData(\)%20%7B%0A%09%09return%20%5B%22data%20is%3A%22%2C%20this.name%2C%20this.age%5D.join('%20'\)%3B%0A%09%7D%0A%7D%0A%0Alet%20base%20%3D%20new%20BaseClass('Al%20Pacino'%2C%2075\)%3B%0Aconsole.log(base\)%3B%20%2F%2F%20logs%20%7B%22name%22%3A%22Al%20Pacino%22%2C%22age%22%3A75%7D%0Aconsole.log(base.getData(\)\)%3B%20%2F%2F%20logs%20%22base%20data%20is%3A%20Al%20Pacino%2075%22%0Aconsole.log(BaseClass.getDescription(\)\)%3B%20%2F%2F%20!%20not%20%22base.getDescription(\)%22%0A%0Aclass%20Person%20extends%20BaseClass%20%7B%0A%09constructor(name%2C%20gender%2C%20age\)%20%7B%0A%09%09super(name%2C%20age\)%3B%0A%09%09this.gender%20%3D%20gender%3B%0A%09%7D%0A%09speak(\)%20%7B%0A%09%09return%20%60Hi%2C%20I'm%20%24%7Bthis.name%7D.%20I'm%20%24%7Bthis.age%7D%20years%20old%20and%20i%20am%20%24%7Bthis.gender%7D.%60%3B%0A%09%7D%0A%09getData(\)%20%7B%0A%09%09return%20%5B%22person%20data%20is%3A%22%2C%20this.name%2C%20this.gender%5D.join('%20'\)%3B%0A%09%7D%0A%09getInfo(\)%20%7B%0A%09%09return%20super.getData(\)%3B%20%2F%2F%20!%20not%20%22this.getData(\)%22%20%0A%09%7D%0A%7D%0A%0Alet%20person%20%3D%20new%20Person('johny'%2C%20'male'%2C%2027\)%3B%0A%0Aconsole.log(person\)%3B%20%2F%2F%20logs%20%7B%22name%22%3A%22johny%22%2C%22age%22%3A27%2C%22gender%22%3A%22male%22%7D%0Aconsole.log(person.speak(\)\)%3B%20%2F%2F%20logs%20%22Hi%2C%20I'm%20johny.%20I'm%2027%20years%20old%20and%20i%20am%20male.%22%0Aconsole.log(person.getData(\)\)%3B%20%2F%2F%20logs%20%22person%20data%20is%3A%20johny%20male%22%0Aconsole.log(person.getInfo(\)\)%3B%20%2F%2F%20logs%20%22base%20data%20is%3A%20johny%2027%22%0A)
on windows, yeah.... :)
You HAVE to learn how to do async programming if you want to work in JS. This is fundamental! 
Hi there! Winterfell allows the ability for Custom Input Types, so plugging in inputs with further functionality is completely possible. If you ever use it and write one, feel free to pull request it and I'll give it a look over etc! Sounds like it could be some quite powerful stuff, but got to make sure its not becoming unused bloat! :)
In addition to being a programmer for my whole career, I'm directly responsible for hiring programmers. I don't know if that makes me more or less qualified to answer this. **How much will you pay me?** I can't believe this isn't everyone's #1. You can learn a ton about a company based on their answer to that question: * What value do they place on the position itself? * What caliber of developer will you be working with? * How does this company value technical employees compared to everyone else? * How healthy is the company financially? * Does the company trust people enough to be transparent with them? Plus, this isn't a question that can be sugar coated or bullshitted. It demands a quantitative answer and yields a wealth of qualitative insights. **How much time off will I get?** Or in the case of open vacation policies, *how much time do you expect me to take off each year?* Again, a simple question that tells you a *ton* about the company's motivations: * How interested is the company in retaining top talent for the long haul? * Does this company value work-life balance? * Will I be working with people that share my desire for a healthy work-life balance? * Are employees evaluated by the contributions they make or by butts-in-chair? **How much of the company is distributed?** This is extremely relevant for anyone that is considering a remote position. Working remotely for a company that isn't significantly invested in building a distributed team is usually an awful experience for both parties. Some things to pay attention to in the company's response: * Is a significant enough percentage of the company remote, or will you be in minority? * In the event that most employees work on site, how quick are they to defend that? * Are they proud of their remote culture?
You can get browser's set language via *navigator.language* for main language or *navigator.languages* for all the set languages
1) The archive of scales are hard coded frequency ratios (in decimal form) that describe the intervals that make up one octave. The program takes care of key assignment and octave transposition, so you can arbitrarily set the fundamental frequency of your scale. 2) Only 12 tunings are included on the demo, but the whole archive is included with the tune.js file, can be incorporated into your projects, and can be explored at http://abbernie.github.io/tune/scales.html.
Thanks for your reply. Nothing in the archive list seems to be clickable though.
Grunt and browserify? Sorry but no thanks!
nice
I have never seen an eval used in a setting like this and if you did this, you obviously don't care about security. However, this being server-side, is there a way to actually get the output of your actions. Spawning a process is alright, but reading a directory? Where will the output of that go?
it doesn't really matter what language you're using, if you are about to use eval(), you need to stand back and think very hard about what you're doing. eval() is almost never the right choice.
we're talking about browser support here, and [navigator.language](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/language) has even less support than `Intl`
That's done on purpose — I always like to mix up things like that when *testing out* features to make sure there isn't any "magic" going on that i don't know about. ES6 offers lots of shortcuts and syntactic sugar, but for learning purposes you sometimes wanna be a little bit more verbose than needed.
or if you wish, why, who and how
 This one was is easy mate: [6, 4] output: (6 and 4) = 210 first digit (2) = (6 - 4) other digits (10) = (6 + 4) (210) [15, 3] output: (15 and 3) = 1218 first digit (12) = (15 - 3) other digits (18) = (15 + 3) (1218)
Most of these pre-date React. Have they been rewritten just to use it? I'm skeptical.
Who the fuck is using eval like that?! Also parsing json like that can be as equally as damaging. Huge payload will block the event loop for a while. There is a lot of good writing about that out there. 
Can you explain? I don't think I got what you want to say.
&gt; JavaScript has been notorious for security vulnerabilities No it hasn't! As an example XSS is mentioned, which is not javascript vulnerability (problem is not in javascript). If someone is using eval to parse JSON then he has no idea what he is doing and as /u/i_ate_god mentioned you could substitute javascript with any other language.
&gt; I thought that was the whole point of React. I've seen this comment on so many different discussions that span so many different topics, it makes me wonder if I know what "the whole point" of React even is anymore. No one seems to know.
Ah it's okay, those are cool, you should do one for this one as well: https://www.reddit.com/r/todayilearned/comments/3cyltp/til_if_you_write_any_number_in_words_english it will require more work thought.
give me one good reason NOT to use react for everything.
you can call it "Simple ~3kb virtual-dom alternative for immutable data." 
&gt; I was using this moment to learn anonymous functions/closures so that is why I have some funky functions I see. Well, it's a pity because now the old code is gone and with it some of the _strange_ things I was referring to. I vaguely remember you had a weird thing with the `next` function, but I don't have that code now. What I do remember is that it seemed to be a case of "complicating things too much". That part seems to be cleaner now. There's still a couple of things you could improve... ###### An easy one is the `setTimeout`. Doing this: setTimeout(function() { next(); }, 750); is unnecessary. You can simply do: setTimeout(next, 750); ###### One thing that's clearly not needed at all is the immediate executed function inside the `for` loop: for(var i = 0; i &lt; shapes; i++) { (function makeDivName() { var text = ""; var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; for( var i=0; i &lt; 5; i++ ) { text += possible.charAt(Math.floor(Math.random() * possible.length)); } if(ids.indexOf(text) &gt; -1) { makeDivName(); } ids.push(text); })(); document.getElementsByTagName('path')[i].id = ids[i + 1]; document.getElementsByTagName('path')[i].setAttribute('stroke-width', '5'); var currentShape = document.getElementsByTagName('path')[i]; path[i] = document.querySelector('#'+currentShape.id); } The problem with this is actually double. The first problem is you don't need it. Doing things you don't need is almost always bad. The second problem is one of performance. You're doing things multiple times when you could do them just once. Like... you're creating a new `makeDivName` function each time. And the `possible` string each time too. And that recursive call when you have a collision of random ids... Well... it's not really such a good idea. I mean, it complicates things that could be resolved in an easier way. A better way to do this could be... var text; var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; function generateId() { var id = ""; for( var i=0; i &lt; 5; i++ ) { id += possible.charAt(Math.floor(Math.random() * possible.length)); } } for(var i = 0; i &lt; shapes; i++) { text = generateId(); while(ids.indexOf(text) &gt; -1) { text = generateId(); } ids.push(text); var shape = document.getElementsByTagName('path')[i]; shape.id = text; shape.setAttribute('stroke-width', '5'); path[i] = document.querySelector('#' + text); } While I was at it, I also cleaned up a bit those last lines in the loop. It makes the code a bit less confusing to refer to `text`. (I tried not to change names too much, so I didn't change `text`, but IMHO a better name for that variable could be something like `id` or `newId` or `randomId` or something like that.) You could still clean up some other stuff that is not being used or not needed (like, in the `next` function you don't need neither `newshape` nor `currentShapeId`; or calling `getElementsByTagName` each time in the first loop) but that's just general cleaning, or you could completely avoid those `document.querySelector('#'+text)` calls because you don't need them (*). Oh, and this is just a personal preference but... well... doing: (function next() { // ...all the code... setTimeout(next, 750); })(); ...would be more clear if the first call is made more explicit: function next() { // ...all the code... setTimeout(next, 750); } next(); (*) If you don't see why this is so, just tell me, but I'll give you a hint: You already have the elements, you don't need to look for them again.
Increases dev costs for no good reason in a lot of cases. Enjoy maintaining this shit in 5 years when the syntax has changed 20 times and you're having to find blog articles from 2015 saying how to do X because react's official docs still suck let alone their depreciated ones. 
http://www.smashingmagazine.com/2015/04/react-to-the-future-with-isomorphic-apps/
Typically the client side frontend (html, css, javascript) is just the user interface for a program. You need a database (MsSQL, MySQL, PostgreSQL, Mongo, etc) and some sort of server to serve the web site (Apache, IIS, node Express, etc). Then typically you need some sort of middleware to server the data from the database to your frontend (Python, PHP, .net, Node, Ruby on Rails, etc,). Here is a pretty good video about what you need to know to be a web developer: https://www.youtube.com/watch?v=pB0WvcxTbCA That video does a good job focusing on the different layers. You don't necessarily need to know how to do them all, but you need to know how they work together. 
~~Have you used the React dev tools? The entire news feed is React.~~
Have you written games before? If so, just check the docs of the relevant APIs. Canvas, Web Audio, Gamepad (maybe), and requestionAnimationFrame. There are also a bunch of frameworks like Phaser. https://www.reddit.com/r/webdev/comments/3i3g6s/2d_javascript_game_for_my_website/cucz5uz?context=3
In development, there is no such thing as an absolute.
What makes you say it is overkill?
&gt;var bankData = eval("(" + data + ")"); All of /r/javascript collectively facepalms.... &gt;While this might seem safe to the untrained eye Um... 
You're not getting a separate VM at $3/mo. You're getting really terrible shared hosting and the worst "support" you could ask for. You can turn that Linode server into a shared host if you want and then lease it to your clients for whatever (but I'd add that any client that cheap isn't usually worth dealing with). note: I mention Linode because I've used them a fair bit, but they're not the only hosting game in town that doesn't cost a fortune.
To paraphrase: &gt; React is a solid framework, meshes well with the latest ES6 features, promotes good modularity, and all the smartest devs are raving about it, but I'm tired of hearing about it, because JSX *something something* and I'm more used to using these other tools. I agree react can be overkill for simpler websites, though. That would be one valid takeaway from this article.
mother fucking website is not really a website. Its a single document. If you have no internal links you have no benefit using react. If you had to do it in react you would create a single component and render it, which would indeed add some boilerplate. React shines when you have a website with atleast 2 pages. Becuase you get a SPA w/ serverside rendering for free (try building this w/o react).
 var React = require('react'); var Template = React.createClass({ render() { return ( //Copy/paste the HTML from that website here //and run it through something like Atom's JSX converter ); } }; module.exports = Template; Now all you need to do in your node server is import that template, call `React.renderToString(&lt;Template /&gt;)` and then ship the result to the client or alternately use `React.renderToStaticMarkup(&lt;Template /&gt;)` if you don't plan on using React in the client.
&gt; Are you going to be nice to me? What time does everyone generally go home? How are breaks handled, do you have a break room? How often does your team eat lunch together? Bob, whats ted's eldest childs name?
Just curious, where are you employed that is using React in production?
You mean it's not safe to run unsanitized user input? I'm shocked I tell you! [Shocked](https://i.imgflip.com/dclzm.jpg)! 
Also per the first one you can also render react on the server and serve the rendered HTML. No libraries (outside of react) required.
&gt;Increases dev costs for no good reason in a lot of cases Seems like a very authoritative statement with no evidence or argument to back it up. How does React increase dev costs?
[!..](http://i.imgur.com/ZLCOYh0.jpg)
the projects I work on for my employer (3 days a week) dont use react (they have their own stack). The rest of my time I spend on developing a pretty big react project which is not yet in production. Had 2 small React projects (SPAs for interal stuff) before that.
Who the fuck eval the output of a post request ? total nonsense.
It's use case is very rare. eval(..) can at runtime modify the author-time lexical scope. Also the JavaScript engine has a number of performance optimizations that it performs during the compiling phase.Most of those optimization it could make are pointless for the engine if ***eval(..)*** or ***with*** are used so it simply doesn't apply the optimizations at all and the code becomes pretty slow. Don't use them!
Facebook uses it production. They don't open source any project unless its in production. http://opensource.com/business/15/7/keynote-oscon-james-pearce-facebook?sc_cid=70160000000wptgAAA&amp;elq=1a1afca5d20b45348ea180631ab778f1&amp;elqCampaignId=55450&amp;elqaid=20324&amp;elqat=1&amp;elqTrackId=77990e8d9e1f4f7ca81f707e22b2ce9e &gt; The projects they're open sourcing are not just hackfest ideas or work that interns contribute, these are tools Facebook uses in production. Facebook open sources only what it uses in production—this way, people know that their offerings are supported and valuable.
I saw a dog chasing cars, and its own tail in a traffic circle the other day, if someone where to make a "dog language to human language" translator to interpret the barking, it would probably end up like the theme of this article. Lets go chase that car! OMG Squirrel!!! 
Where are the private member variables and methods? Private fields are pretty much the only reason I would use a class over a series of pure functions and a set of data structures.
"You guys think you're cool but news flash: UR NOT." Wah wah wah. Low effort shit post.
Removing this post as it doesn't provide anything related to React other than some screenshots. No code, no interviews, no architectural discussions, etc. 
In next episode: Have a password on your server. 
i've seen that. Did you implement all the fancy event-stuff that react has? the livecycle-mechanisms? how about serverside rendering? Mb u have all that in that lib. but w/o (and I just cant believe that its possible in 3kb) u cant call it an alternative to react in my eyes. also trying to solve something w/ less kb is nearly pointless, since u can deliver staticly rendered pages w/ react. Libs like this just ignore the real great things about react. Thats why I am a salty about it. Dont use the name of something great to push your own "product".
res.send(filecontents), for synchronous output of files. Otherwise there's always the http library with which to send data to my server.
5 years ago YUI2/3, and Prototype had tons of popularity, now they are both dead. It's a terrible argument.
&gt;Enjoy maintaining ANYTHING in 5 years when everything has changed... Just redo it in whatever framework is popular in 5 years then. Planned obsolescence, also known as job security :v
As all other webbdev-tech people get way to attached. I decided to play with react since it integrates well with Clojure and I like that. This makes me a language dick, not to be confused to a framework dick. 1. Item 2. Item
Check out some game programming patterns - The main one most games use is [The Game Loop](http://gameprogrammingpatterns.com/game-loop.html). That'll definitely help you get started, and it's written with pseudo-code so you won't get a bunch of beginner JS stuff. 
Stop suggesting Angular for EVERYTHING!
that's what isomorphic means. (yeah it's a pretentious word)
Try doing a search on /r/gamedev. They have some great resources over there.
react rendering canvas? I call shenanigans. I mean it can append a &lt;canvas&gt;, but it can't actually draw anything right?
Template in the same file as my rendering logic and listeners. That right there is my reason to use react for everything.
If it's an office thing..... * What is the average rent within 3km of the office (I walk to work). I will not work anywhere that I'll be paying over 30-35% in rent. Most people now-a-days are happy enough to pay 45%, I will not. Note to new businesses. No, being in the trendy suburb is not cool, making your staff have to pay $40 for lunch is not cool, making your staff commute 3 hours from affordable rent is not cool. Appearances are not everything.
I'm a new guy to this sort of development, that's why this all seems very odd to me. Thanks for letting me know!
&gt; The point is that it reduces complexity and mental overhead over time. How does this differentiate it from Ember, Angular, Aurelia, Durandal, etc. They're all abstraction layers to reduce mental overhead and complexity.
mhm I guess I have to take another look at times. And pls stop beeing so polite. edit: one question - Is it possible to initialize the clientside-code after getting a server-rendered page w/o rerendering in tusk? I think the word for this is "hydration". also u might want to consider to ditch coffeescript. I think alot of ppl dont take a deeper look just because of that.
ahh so they replicated a tiny subset of HTML/CSS that renders from react virtual dom to canvas. For something reason I thought you meant something else.
the author's point is that you don't need a react-based UI for a toaster you need a lever and a knob, that's it. how often are you switching out your knobs and levers that you need a layer of abstraction for them?
Because you should choose the best tool for each job, not pick one tool, fall in love with it and then bend and mangle every set of requirements you run across until they're mutilated enough from their original intent to conveniently fit your tool. You don't use React for everything for the same reason you carry a whole toolbox instead of a hammer - because if you don't then eventually you find yourself hammering in screws and trying to nail bits of paper together, and then you've slipped from being a professional developer and turned into a halfwit liability to any project you encounter.
What's worse is that when `eval` is noticed as A Bad Thing™ then people plump for `Function` instead as it looks safer. Or they use `setTimeout`...
Righto-- isomorphic running the same code on both front/back end-- I just meant to point out that there are no 3rd party libraries required and that [react does this out of the box](https://facebook.github.io/react/docs/top-level-api.html#react.rendertostring).
ahh
You should also check out Unity. It's a very popular, free, cross-platform game engine. Instead of limiting yourself to a web game, you can make a game with javascript (with minor changes) and port it out to Android/iOS!
I assumed that was obvious. I guess not
"Culture" doesn't mean making friends on the job. It's a question of whether your personality, proclivities and preferences are going to mesh with the way things work at the company. If you like to be left alone and don't care about making friends, there are companies whose culture will fit you well. You should seek those kinds of environments. That's still a company culture, though.
I want to put a vote in for [Phaser](http://phaser.io). Solid framework, lots of examples, and you can get quite deep with it. It's also open source so if the game making aspect isn't challenging enough for you, you could contribute to the code-base. 
Indeed react can basically target anything. Netflix also forked it and made it to target a native view layer they created for their apps running on things like blueray players o_O there is a talk on YouTube about it that I'll try to locate but it's worth searching out. Really clearly points out the things this article misses about the benefits of react. For lack of a less buzzy word it's a complete paradigm shift in how we develop. It's also the reason react native has taken off so quickly. The ideas are universal. 
So, put your template in the same file. [ES6 template strings are great for that](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings). You can get those same benefits from something simpler like, say, [ampersand-view](https://www.npmjs.com/package/ampersand-view).
It's pretty straightforward. The big question is: **Do you want to use an engine or build from scratch?** . . I've written 13+ games/prototypes in javascript, and more on the way [(shameless plug - there's 9 mostly unfinished games listed here ;)](http://gamejolt.com/profile/madmarcel/386095/games) The space invaders game has really simple source code on github btw. [This series](http://www.somethinghitme.com/2013/01/09/creating-a-canvas-platformer-tutorial-part-one/) is an excellent tutorial on how to build a really simple platformer. . My current project is to squeeze [a super mario bros clone into 13kb](https://twitter.com/madmarcel/status/636871749737431041), and obviously there is no space for a game engine. Gotta make it all from scratch. 
[**@madmarcel**](https://twitter.com/madmarcel/) &gt; [2015-08-27 12:03 UTC](https://twitter.com/madmarcel/status/636871749737431041) &gt; Progress on \#js13k so far...just need to add the player and some monsters. &gt; Also, making levels is hard :\ &gt; \#gamedev &gt;[[Attached pic]](http://pbs.twimg.com/tweet_video_thumb/CNafevPVEAAUpIM.png) [[Imgur rehost]](http://i.imgur.com/Yf85whH.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Welcome to Medium. The amount of pretentious blogs on that site by self-proclaimed authorities on subjects who think they know better than everyone else is a real turnoff. When I see titles like this, I don't even read it.
You may find this live coding walkthrough helpful. [Mary live-codes a JavaScript game from scratch – Mary Rose Cook at Front-Trends 2014](https://vimeo.com/105955605)
Honestly for me these days it's, What technologies do you use, What time do people typically show up, How's the coffee? 
http://imgur.com/gallery/91sn32Q
Fantastic, what was it built with before?
&gt; Yet Another Why?
I sincerely doubt that u/te7ris works for Facebook.
I would suggest starting with canvas. Here is a very simple game tutorial that got me started: http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/ 
My shameless plug: 1ofthesethings.com. It's a variation on a game whose name I forget. 
You could use React to build a form for someone to fill out to bid to build your toaster for you
React hasn't been in the wild for more than a year, do you have any personal projects that predate React?
This project started with Dropzone. I was working on a site that required drag-and-drop fields. I tried to use Dropzone and I couldn't meet all of my functional requirements. It was incredibly frustrating. The design of Dropzone tries to anticipate all the ways in which a drag-and-drop field will be used and to speak to those use cases with configuration options. This is why it's an odd mix of "works out of the box" and "advanced API"; it's trying to be too many things to too many people. The problem with this is that one can't anticipate all the possible functional requirements for a drag-and-drop field. Even something like "the most common use cases" isn't really knowable. And by trying to take responsibility for those features/behaviors Dropzone limits and impedes the developer and the application. Building a drag-and-drop field with Hemulen.js is different because it's much more open, much more flexible, and much less out-of-the-box. It occupies a middle ground between writing a drag-and-drop field from scratch and using Dropzone. Hemulen.js establishes a separation between UI/presentation/interaction design and data. Handling the data can be standardized and abstracted for most (maybe all) applications. So that's what Hemulen does. In doing so, Hemulen.js provides an interface for updating the data and knowing the state of the Hemulen instance. This interface can be used to "build a drag-and-drop field" in the sense of define behaviors of a DOM element that update the data and reflect the internal state. All this requires is listening for Hemulen events and updating the DOM with data from the event object or listening for user actions and updating the state of the Hemulen instance with data derived from that user action. The beauty of this is that it gives you complete flexibility to construct your UI and define your interactions in whatever way the application requires. No halfway hacking the plugin which is what I started doing with Dropzone before coming to my senses. 
What language do they use to create React?
I mean, the dude has a decent point, but has he ever been to five guys for breakfast? The breakfast sandwiches are amazing, and a large part of that is that they re-use the cheese and buns from burgers. Not that he's wrong, just, y'know. 
Why does that matter? Production ready is production ready especially with battle harden apps from Facebook.
I solved this problem with docker for myself: https://github.com/mattbailey/docker-corsproxy
Wait, Five Guys does breakfast? Talk about burying the lede…
&gt; The debate isn't on whose making what claims, but which claims hold weight I'm not sure what you're trying to say here - that other tools claims don't hold weight when they say they reduce complexity? Virtual DOMs goal is to reduce complexity. Agreed. A framework uses its features to accomplish its goals, I'm confused what exactly you're arguing. Rendering speed is a byproduct of the method, sure. And?
Im picturing a totally from the ground up webgl project where they wrote their own shaders and everything... also using react for data updates ... then i'm picturing getting hired by that company and looking at that code base for the first time ..... then i'm picturing drinking ... allot 
I found this [tutorial](http://blog.sklambert.com/html5-canvas-game-panning-a-background/) helpful. [Here is my implementation of it with added junk](http://dethstrobe.com/shooter). I also found [Eloquent Javascript](http://eloquentjavascript.net/) had an awesome platformer tutorial I stole a lot of code from to make another game I'm working on.
Or better yet, avoid using Gulp unless you really need it. There's better tooling that lets you achieve better results than what's shown in the blog post. I [wrote about this](https://blog.cesarandreu.com/posts/a_reasonable_starting_point_for_building_a_web_app). tl;dr: webpack ftw. 
I use this, as well, though I haven't tweaked the default rules at all.
Here's a presentation I did about making JavaScript games with no libraries: http://ericlathrop.com/making-javascript-games/#/ I've been doing it for almost 2 years, and happy to answer any specific questions.
Mostly jQuery and mustache composed as AMD modules pulled in with require.js. The backend was varying flavors of MVC .NET. It got the job done and required little on-boarding time but was very difficult to maintain. React + flux in comparison provides a very prescriptive way to modularize code that promotes re-use across the company. We've begun publishing our common components to a private NPM registry to get some SemVer goodness. The only pain point so far has been jest, but it's easy enough to use a different unit testing framework. I'm very partial to mocha with chai assertions.
takes like 3 seconds... github even provides a textbox with a copy button next to it... 10 keys, shift+insert, return and it's yours. git clone https://github.com/freizl/js-vd.git There's an example in the `examples` directory.
It's called a scene graph. Most 3d packages and game engines have them. A 3d scene definable in terms of tags (scene objects), attributes (animation and behavior functions), and styles (materials) would be a breath of fresh air by comparison.
React can do that too though and, at least in my opinion, is way less verbose and complex than Backbone...
I'm already not using React for anything. Do I win?
And in even less time, the author could host it on github pages, thus saving us each that amount of time.
If you expand "everything" beyond websites, hell yes use React for it. I love that people are porting it everywhere. https://github.com/Yomguithereal/react-blessed/ https://facebook.github.io/react-native/ 
0) Don't use gulp at all, and switch to webpack
Angular complicates the mental overhead, IMHO. I have not looked into the others that much, but I dread pulling out Angular projects. * Trying to track down `someName` or `some-name` to find uses. * Having to open up a directive, a controller, a template, a module file and whatever else someone decided to separate it into. * You have to manage artificial scope. Isolate vs. Inherited vs. same * Worry about WTF a transducer is. * Be able to read/understand the constructs for factories, services, and providers because someone might like using one over the other. * You need to understand the proper cases for using `&amp;`, `@`, `=`, or the appended `?` to each of those. * You need to know when a template requires a dot notation string vs a curly braced notation for parameters. * $watch, $timeout, $window, $emit, $observe, $apply... ugh * I can think of at least 3 ways to bind a controller to a template/directive and I'm there are more. If you need to find use cases, have fun. * Fun cases where you can easily find yourself in a non-obvious template value loop and blow out the digest. * And last, but not least... "The Angular Way" Then you have to train a junior on what exactly is going on while they stare blankly at you like you are speaking Klingon. I've ramped juniors up on React in a 3 hour session. It takes weeks to figure out Angular.
This is a poor way of demonstrating how code works. Lines 14 - 17 alone assume the reader knows enough about how classes work that they wouldn't be seeking out this sort of example to begin with.
Thanks for the suggestions everyone. I eventually solved it by running the API through Apigee and setting *its* header to allow CORS. Similar to this video https://www.youtube.com/watch?v=7f3c3ujBXoM except it threw a request header error that I solved by including this line of code: &lt;Header name="Access-Control-Allow-Headers"&gt;Origin, X-Requested-With, Content-Type, Accept&lt;/Header&gt; Hopefully this might help out someone else in the future that runs into the same issue. Thanks again.
A couple of small points: The definitions you use for Entity and Value objects are not really precise, making it a weak starting point for all the rest of the explanation. The definition of Entity is not very good, but in particular the definition of Value object is extremely vague and handwavy. If you want to talk about Entities and Values, you should at least mention _identity_ and state. It doesn't make much sense to point out that making `strMerge` local to the module "also is a bit of a memory boost as your function is declared only once" but not take advantage of prototypes on the `fooBar` method in the ES5 code snippet. I'm not saying it's _wrong_, just that it seems contradictory to point that out. What's more, the ES6 code using `class` does actually translate into using the prototype, so the ES6 and ES5 snippets you present are quite different. An alternative to using `defineProperty` to achieve immutability, which gets a bit tiring if you have to do it for every single property, is using `Object.freeze`. It might be worth mentioning it or even comparing the two approaches. There's a typo in the following line; the closing `}` is missing: var entity = new Entity({foo:'testing', bar:' entities'); But more than that, I was extremely let down by that space in `' entities'`. It's lame and totally unnecessary in a blog article where you _assume_ the existence of `strMerge`.
&gt; even Thanks suggestion. Add express example http://freizl.github.io/ftp/js-vd/index.html Feel free to ask for adding other examples. 
An astute question. I agree, classes without privacy encourage you to add a bunch of unencapsulated state as object properties. Encapsulation is normally the key benefit of OO. Maker functions are the traditional way to achieve information hiding by creating objects that access their private state via closure. Classes are, at best, a distraction from the more powerful constructs for encapsulation that already exist in the language. That said, having a class keyword gives Java programmers a warm fuzzy feeling, so it is helping to entice more people into the JavaScript community.
If I wanted to see facebook memes I would go to facebook... and re-add that kind of people as friends.
Depends on if you would like to use any framework. [Udacity](https://www.udacity.com/course/html5-game-development--cs255) has a HTML5/JS Game course without framework, but I am not sure how good it is.
Who the fuck uses 'eval'? Ever piece of documentation I've read regarding the use of 'eval' has warnings and exclamation points saying DONT USE THIS FUNCTION. If nodejs was introduced 10 years ago maybe it wouldn't be as obviously bad to use it, but the evils and dangers of 'eval' were well known before serverside js became popular. People shouldn't program JavaScript if they aren't aware of all the ways you can shoot yourself in the foot. I am legit curious about service vulnerabilities - but at the same time - I believe that open source combined with popularity = libraries that are battle tested and well made, which is better than anything baked into a programming language by default. I hope people who use server side js do their research on proper libraries to handle important functions. It's too fragile / dangerous a language to roll your own unless you're extremely competent with the specifics of JS / node.js. There's also no precedent for the open source ecosystem that surrounds the language - in that there is no comparison - not that it's the best - just the largest to have ever existed. It completely changes the dynamics of how you choose to compose a program - and my experience working with programmers 10 years my senior is that they just don't 'get it'. They're so used to solving problems using language x or z that they learn the fundamentals of Js and then start writing server code with 2/3 npm libraries. And then I'm having to go through nested callback back hell of someone trying to roll their own orm in vanilla js - which in its own merit is a terrible idea, but made exponentially worse by rolling your own validation, etc. when there's dozens of npm libraries that do it better 
Try this maybe? https://github.com/maryrosecook/retro-games
Thanks a ton for linking this, I remember reading it forever ago and not understanding it, but now I understand everything that is being said! I was wondering, what is the best method to do custom/pre-created levels in a game with JavaScript? I want to be mindful of the filesize, but I am not sure what the best method (if any) is to create a level. Let's say the super mario clone you are making, how would you go about storing the level and rendering it? Thanks in advance for any advice. Also, your super mario clone looks hella great!
You know how I know the author doesn't use React? because he says this: &gt;If you have a highly dynamic application that **needs to rerender frequently and you want to avoid the heavy weight of template diffing**, you’re looking at a grass-type opponent and ReactJS’s virtual DOM will be super effective... That stuff is a nice feature of React, but that is not it's primary benefit. The primary benefit is that React+Flux provides a sane, scalable, testable, maintainable architecture for building complex software. For front end devs with experience in building large javascript applications, that benefit is *by far* the most important benefit of react. 
Gona use react for "hello world" page, 30 components right there. U jelly? /dance
I'm not following you
I just use a plain text string to store the levels, where each character maps to a tile. There's probably better ways, but it compresses well. I will add some special chars/tiles for monster/player spawns etc. To build the levels I wrote a super duper quick level editor using jquery and table cells :o [js13k entry WIP](https://madmarcel.github.io/js13k2015/) Link to the tile editor as at the bottom (sorry, didn't bother making it fit on low res screens) If you open the web console and click on 'export' you'll see it dump the level string. I just paste that string straight into my code after I'm done editing. If you didn't worry about size, then you'd use [Tiled mapeditor](http://www.mapeditor.org/). Plenty of libs available to import those maps into js code. 
In the grand scheme of things, yes. Also consider that the PHP of today looks nothing like the PHP of 15 years ago. Likewise for Python.
A great thing about react is that server rendering is built into the core. (Render component to a string), so it's a much better experience for the user on a bad connection. 
This is a great little library. Thanks for sharing.
Directed at myself 4 years ago: 1. most places programmers don't code 8 hours a day. Hell some companies with meetings, mail threads and just their enterprisy bullshit can drive this down to 2hrs a day. Don't feel bad if you don't get to code enough. 2. if they don't do code reviews via pull requests, GTFO 3. if they do pair programming more than 40% of the time, GTFO
True. It's good to see primary rendering heading back to the server side rather than being yet another thing that the client is expected to reimplement.
Hope this help you out -&gt; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Exception_handling_statements
the simplest way is to rebind your events when the user changes tabs... so instead of using `&lt;div class=tab onclick=somefn` make a fn like `initEvents()` function initEvents () { someElem.onclick = clickhandler1 someElem1.onclick = clickhandler2 // etc etc for all tabs, might have to check if the element is actually a part of the DOM before you use it? } then its just 1 more line of code to add to `document ready` and your `handleTabClick()`: `initEvents();` and thats it
Sounds bomb as fuck, I know where I'm going for breakfast today!
Very basic question, this isn't ajax based is it? Would the images all have to be loaded at once? I was looking for a small library to build a product page where the images don't all have to be loaded at once...if anyone has any suggestions. Would it be doable to modify it to use ajax requests, or is that really not beginner territory?
This guy isn't doing Pinterest engineering any favors with this blog post. 
so you can use it to CYA in bits of sloppy code or fragile code... not with events but with just inline javascript if it hits an error the code will stop running and not be run again on the page. at all. so if you have a fragile code, say like sometimes does things on say elements that are possibley removed from DOM: its gonna break. if you need it to keep working, try/catch comes in... its also good for not stopping your code on error: for(i=0;i&lt;5;i++) document.body[['asdf','bcde'][i]].innerHTML = "testing 123" // logs one error message for(i=0;i&lt;5;i++){ try { document.body[['asdf','bcde'][i]].innerHTML = "testing 123" } catch (e) { console.log(e) }} // logs 5 error messages, this obviously keeps going some people use it for error handling `somewhere in another mvc galaxy, 10,000 frameworks away:` function println () { ... if (error) throw "dood your not using the force" if (error2) throw "documentation you must read" and: for (i in somehugearray) try { println("asdf") // assuming this errors, console will print the right error msg` } catch (e) { if (e == "documentation you must read") {} //openDocs()? continue? break? log? return? anything! if (e == "dood your not using the force") { .... } // so now we have two ways to "recover" and can handle errors/fix the data in a specific way } so now when you catch the error you can continue the loop, break, return, log errors, open docs, basically anything.... instead of the javascript on the page just stop working. much better! this isnt the de-facto way to handle errors though because it breaks the code flow, as soon as `throw` is called the vm will jump to the `catch` block. also most people think throw doesnt have enough data passing options, so its hard to do something like `return {validData: arr, errorMsg: 'msgtext'}` because it jumps right to the catch block. (theres also kind of a scope issue, where all vars you might need to debug or continue, are not always available to the catch block.)
Uhh lmao what? Okay honey. I guess I was never writing JavaScript in 2010 then. Where is this idiocy coming from? 
It looks like the goTo method (https://github.com/peduarte/wallop/blob/master/js/Wallop.js#L101) is public and doesn't do too much. You could probably do something like Wallop.goToOld = Wallop.goTo; Wallop.goTo = function(...){ this.goToOld(...) } I'm sure that is incorrect, but it should give you an idea of how to proceed 
 class DankMeme extends Meme {}
Is the ice cream guy's dangly penis necessary? Other than that, looks nice.
thanks for the tip, interesting project for me to work on *edit: Maybe it doesn't actually make sense to use a slider for a product gallery anyway, since the whole premise is just "previous" and "next" - whereas a product showcase would have a set of choices like thumbnails or whatever... Although, maybe with ajax this could be cool to hook up to a flicker stream or something where the prev/next item is not known or expected... 
Well, I was talking about sane people.
I wanted to cover some things I hadn't seen in previous guides. :) 
[^(**Mouseover** to view the metric conversion for this comment)](#20 lbs = 9.1 kg "20 lbs = 9.1 kg Post feedback in /r/ToMetric")
Any sufficiently competent programmer could recreate Qt, Cocoa, or WPF. They don't because they don't want to waste the developer time and fragment the ecosystem. That said, most developers don't have the knowledge or understanding of that part of the system to make a good framework. The ones that do tend to understand the complexity and realize that NIH isn't good development practice.
If you're doing an unknown number of slides, you'll have to hook into more than just the goTo method. The whole systems resides around the number of slides to determine if you need to loop or not
The React render to string methods make a string from the vdom and return it. That should work perfectly well in Rhino or any other ECMAScript compliant implementation. For large projects that need to be isomorphic, a great solution is to spin rendering off into a separate node process. Your java, python, ruby, or whatever passes in the required data and gets back a string that can be returned to the client and (in a lot of cases) cached for reuse. Your front-end team is going to have to write this template code anyway. The benefit here is that it allows more graceful upgrades on the client and allows the client to reuse as much of the back-end as possible (which reduces template overhead and potential conflicts). If large companies like Netflix or Facebook (with PHP no less) can make these ideas work, then I don't doubt that other companies can as well.
Yes, with HTTP/2's Server Push, you can just push all the other crap along with the document response. A pre-assembled document will still win the speed race, however. It's smaller and you can start displaying it as soon as you got the first few KB.
Heck, it's beautiful! What's the browser support?
if you're not implementing a virtual dom i don't see how this requires a lot of tools and knowledge 
A away to login and logout for users lol, I tried to put it in more technical terms but I assume I failed.
Also, a signup.
Google "PHP login".
&gt;People on reddit are saying things can't be done in plain javascript Where? Frameworks facilitates code reusability, readability, maintainability, security, you name it. Of course you can reinvent React, but why?
Heh. There is actually a somewhat obscure optimization technique which makes really good use of that. If you know that it always will take a while to assemble the response (search queries or something else which requires some heavy computations), you can improve the loading time with chunked output. E.g. as soon as you get the request, you just write the cheap mostly static stuff to the buffer and flush it to the client. The client will then know about the resources which are referenced in &lt;head&gt;. So, it will start to fetch the CSS and JS which was mentioned there. Ideally, this first piece already contains something visible like the page header. Once the more dynamic side bar is done, you write and flush it. And finally, when the meat of the page is done, you write and flush it, too. If it takes longer than 100 ms to assemble the response and if there is no way to make this any faster, this kind of optimization might be a good idea.
Reinventing React is not my point. To the question of "where?", is this your first visit to reddit? 80% of all redditors believe it's impossible to code anything without a framework, library or someone else's code.
None of what you said is my point except a modification of this: &gt;most redditors don't have the knowledge or understanding
I don't see any errors in the console tab, but I pretty much do not see anything in it either. Nothing loading in the network tab. I have my manifest file here: http://codeshare.io/ZUyrD and the code that's being executed in the browser on the site via the contextMenu: http://codeshare.io/5LSsK "context.js" jquery is directly in the app folder. Is there anywhere else it needs to be loaded?
I don't think that sentiment correlates with reality at all. People encourage use of popular, ubiquitous frameworks because of aforementioned reasons. If someone asks for help on reddit, he/she is not quite capable off writing their own implementation, hence framework hype in comment sections.
I've never heard of a name. Bubble Point Tooltip seems to be popular on Google. I would guess most people search "Tooltip with Triangle"
For anyone interested in learning Falcor, we just did a tutorial over at Auth0 :)
thank you
Great example, thanks!
Thanks everyone for all the nice comments and stuff! :D
When I stop using jQuery completely, this would've probably screwed me over silently. Thanks for the heads up.
This was a very well written guide. Most of this is well know but I did catch some stuff I wasn't aware of. Thanks OP!
If they're using Microsoft's script engine, and you have access to CreateObject(), there are some possibly cringeworthy ways to create GUIs with it, such as [spawning/controlling Internet Explorer](http://nerds-central.blogspot.com/2007/01/using-internetexporer-as-gui-for.html). If you dig around you might find other COM objects people have made for creating gui's from wscript, like [this](http://veretennikov.org/Default.aspx?f=WSO%2fDefault.aspx), but I haven't tried any.
You have absolutely no reason to be worried. The worst that will happen is that you'll learn how one company interviews and not get this particular internship. You'll want to know the basic gotchas in JS, the basics of CSS (plus advanced selectors), and the newest HTML 5 standards. You'll also want to have a Github account with some projects up. They may ask you to do a coding challenge, white boarding, or some inane puzzle. All companies interview programmers differently. The best of luck to you. Stay confident and **admit when you don't know something** and all will be well.
I think it really brings the demo together nicely.
I only get a blank black screen with UI http://i.imgur.com/yyoPyB1.png The sounds are playing but the controls do nothing. Macbook Air 2010 model, Chrome Stable, runs most webgl applications perfectly fine (I used to develop webgl projects on this machine).
Since JS is already "the most popular language in the world" by various metrics, I would argue the appropriate action would be to reduce the OO Overkill of Java so that JS programmers might be more comfortable when using Java.
The concept is so new, no-one has a firm name for them yet. However, they are, by definition, "render targets," so I think that name is appropriate. Just like game engines have platform targets (xbox, pc, mac, etc).
If you're playing in Firefox this is a problem I'm working on right now and in ~30 mins it should work. For some reason mousemove when pointer locked is not firing.
You need to add a callback parameter to customerNumber, then pass that to the done function, and then have the done function call the callback. 
Thanks for the reply man; that was a good pep talk! Right, I've heard of the gotchas and puzzles. Are some more standard than others? I think they also would like for me to know how WordPress works on a basic level. 
**Potentially NSFW** [Here's a rare pepe, just for you!](http://rarepe.pe/?i=1658) I am a stupid bot, please don't hurt me.
It shouldn't happen. Refocus onto input/button and submit the form, otherwise I guess there's some error in the console.
I see what you're saying, but even CRUD apps that are rendered server-side can't usually deal with the idea that you'll modify any number of templates. That is asking for major breakages on pretty much any non-trivial website. Even without React there's a need to isolate your side effects to something manageable.
Does your browser ask you to allow pointer lock? Could you please tell me your OS and browser vendor?
well like the others are saying it's buggy as all hell but, great job. clearly a lot of work went into getting it this far and i wish you the best in the project's future development
Very nice. Thank you!!!
Thanks a ton! I'll give both these methods a shot, thanks!
whoa, that is so evil
http://2.bp.blogspot.com/-3xtPQ5Mc88c/VTiUiYJspSI/AAAAAAAAS-c/rF-0oHwlb4A/s1600/but-why.gif
Changing my statement to Redditors substantially changes my statement. I have no knowledge of the general programming competence level of Reddit as a whole -- probably not what you meant. I would also not make the mistake of saying that most Redditors in the programming sub-reddits are below average (especially since many developers with far above average ability are on reddit). Finally, I've made frameworks over the course of my career as a developer. I use React because it is easy, effective, has a decent ecosystem of libraries, and reduces my framework maintenance and design time to almost zero. Even a basic version of a React-style framework takes more time than most devs have available to spend on non-paying work. Claiming that any dev could potentially write a framework using basic JS is like claiming that any dev could potentially write an OS in assembly. Just because a group of devs has [done so](http://www.menuetos.net/) doesn't mean that doing so is practical. Technically possible and pragmatically do-able are very different. Calling out redditors for speaking about a practical framework in a pragmatic way does little to contribute to the discussion.
Thanks :) good support IE9+ only using transform http://caniuse.com/#feat=transforms2d
Thanks mate!
each item has its own modal.. try this: (line 5) $(document).on('click', "a.btn", function (e) { $(e.target).parents('.image-container').prev('.modal').toggleClass('modal--show'); }); https://jsfiddle.net/9n2ax13v/
yea, thats what it is kinda, but less cartoony.I dunno when I searched for callout SVG's it was more like a comic style rather than a box with a priamid
Honestly, it is pretty crappy. I couldn't even exit the game without switching to another application and clicking the close tab icon in the browser window underneath, otherwise the game just keep switching to fullscreen if I click anywhere on the chrome interface. I hope you haven't been working on this fulltime for the past 6-months.
My first thought would be to include something like the following at the top of any js files containing react components: if (!React) { var script = document.createElement('script'); script.src = 'https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.min.js'; var first = document.getElementsByTagName('script')[0]; first.parentNode.insertBefore(script, first); } The script tag is then only inserted if the React object doesn't already exist.
Since they are on the same page, it would be better if there were one global reference to a single react. Multiple react instances could work, but such a system would use a lot of unnecessary bandwidth and memory. You should look into loading react through requirejs, rather than amd. Requirejs will load scripts based on dependencies at runtime in the browser, using async techniques. Thus, no matter how many react-dependent components you loaded, you would only load react once, and all the react dependent components would wait to startup until it is available.
Java was the language I said I knew the most on my resume. I mean, I'm still a student and nearly all of my assignments have been in Java. And I actually had to deal with an application that made Java into a web page with JavaFX! I'll be sure to mention that I know HTML, CSS, JS, and Java the most.
I stated it was my modification. My experience with redditors is proof, to me at least, that 80% of are clueless and their whole life experience is based what they read on reddit, which fits in with your own statement that most developers don't have the knowledge or understanding. &gt;Claiming that any dev could potentially write a framework using basic JS is like claiming that any dev could potentially write an OS in assembly. That you think writing an operating system in assembly is equivalent to writing a framework in JS shows you lack knowledge and understanding, too. You can't blow that line by me and expect me to think you have a good, technical background.
[Why?](http://i.imgur.com/OpFcp.jpg)
I'm going off the assumption that you've tested updating the badge manually in a console and that window.fluid.dockBadge is absolutely the correct variable. If not, do that. Barring that, your regex is super complicated for just checking if exists and extracting a number from the document title. Why not just use something like this? /\\(([0-9]+)\\)/ Keeping in mind I've never used this application before and you may have to change some things up to get it to work, try something like this out: function updateDockBadge() { var title = document.title; var res = title.match(/\(([0-9]+)\)/); if (res &amp;&amp; res.length &gt; 1) { var newBadge = res[1]; window.fluid.dockBadge = newBadge; } else { window.fluid.dockBadge = ''; } } window.fluid.dockBadge = ''; setTimeout(updateDockBadge, 3000); setInterval(updateDockBadge, 15000);
I wanted to come on this to you since I have taken the path to explain some fundamentals of BDD... first post can be found here http://www.richardruiter.nl/why-use-bdd-to-describe-your-software/ 
&gt; var Foo = { C: 3 }; &gt; var bar = Object.create(Foo); &gt; bar.A = 1; bar.B = 2; &gt; Look at how drastically simpler this is Here's the thing, though: The way you initialize a newly created Foo object (`bar.A = 1; bar.B = 2;`) will be copy-pasted *everywhere* that you create a Foo. That's bad. Let's fix that by putting an `initialize` method in Foo. var Foo = { C: 3, initialize: function () { this.A = 1; this.B = 2; } }; var bar = Object.create(Foo); bar.initialize(); And here's the next thing: We will *always* want to make sure newly created Foo objects are initialized, so let's combine creation and initialization into a single step. var Foo = { C: 3, initialize: function () { this.A = 1; this.B = 2; }, createAndInitialize: function () { var instance = Object.create(this); instance.initialize.apply(this, arguments); return instance; } }; var bar = Foo.createAndInitialize(); These are both good things. Yet, in case anyone hasn't realized, we just re-created constructors and the `new` keyword. It actually would have been a whole lot easier if we just used the built-in language constructs.
Impressive. I'll be using this. 
Can you gist the npmdebug log and share with us?
Is it based on Node? If it is you are in luck. If it is an embedded JS engine, chances are difficult. There are node.js bindings for common GUI frameworks, e.g. QT, GTK. Also, you can also spawn a server locally and just access it via browser on localhost
I'm confused. So how should I create an object and a child object? What if I want common properties on all children? And what if I don't? 
Wasn't a priority. But why make when you can borrow?
Typo: bar.B; // 2 (actual attribute of bar) bar.c; // 3 (*inherited* attribute from Foo) vs bar.B; // 2 (actual attribute of bar) bar.C; // 3 (*inherited* attribute from Foo)
&gt; Is the ice cream guy's dangly penis necessary? Absolutely.
No problem for me. So you're saying to get ready for a lot of work, but relatively nice job security? =P
Hey Jones, it's the author here. Thanks for the suggestions I appreciate. I've started a new branch called next. I'll push it in the weekend with a few things including more real examples, better documentation and a small polyfill for IE. The examples are very very basic but it looks like people get confused. Anyway, for me the main challenge is keep it under 3KB :-)
What exactly is the reason of this post being removed? If the reason is actually relevant can it be moved to another section i.e. r/WebGames/ retaining current comments and votes?
Well...
I agree with you. I'm really not sure why people keep trying to ignore classical inheritence in Javascript just because it happens to also have prototypal inheritance. ES6 proves that you can have both; the new "class" features in ES6 aren't getting rid of prototypal inheritence; they are adding syntactic sugar around it to ease the use of common construction paradigms, without taking away any of the benefits of prototypal inheritence. To the OP's point, I agree that people really should have a better understanding of what's going on under the hood in Javascript, but I legitimately think it is foolish to sweep things like the "new" keyword under the rug and pretend they aren't there.
&gt; if they do pair programming more than 40% of the time, GTFO 40% is excessive, but I am a big fan of pair programming, both for the Jr. and the Sr. involved. It's like training while working, and both sides always learn something. 
&gt; I have plenty of friends lucky. :( 
&gt; java is not javascript I develop for a platform in Javascript, and i constantly get reqs from recruiters who want to know about my "java experience". Well as it happens, it's strong, but I don't think you know what you're talking about, and I'd rather either talk to someone who knows what they're asking about, or not do business with your company at all. -- I get 3-5 of these emails and at least 1-2 calls PER DAY (usually at 5-7AM, when nobody should be awake, and usually from Indian call centers). 
Interesting
Thank you much. I kept forgetting to take a look at that. 
I agree.
&gt; What exactly is the reason of this post being removed? From the guidelines that I linked: &gt; If you'd like to show off your latest project, then that's great! We love seeing what fellow redditors can come up with. However, the same posting rules apply: it must relate to JavaScript. For example, this could be a link to the project page (unminified/unobfuscated source code), or maybe an overview of your architectural decisions, a code review request, etc.; you can even do so in the comments if the site itself doesn't meet the posting criteria. NOTE: The fact that a site was made with JavaScript does not automatically make it eligible to be posted to /r/javascript, including games. If we allow any site that uses JS to be posted to /r/javascript, then we'd soon be indistinguishable from /r/WebGames, /r/InternetIsBeautiful, etc. Instead, we aim to foster discussions around the source code, and/or the development processes and practices used to create the project. Since it didn't meet that criteria, it was removed. &gt; If the reason is actually relevant can it be moved to another section i.e. r/WebGames/ retaining current comments and votes? Unfortunately not, sorry. The way reddit functions is that each subreddit (of which /r/javascript is one, /r/WebGames is another) are 100% independent entities. Each has their own moderation team, guidelines, etc. and a post made to one is wholly different than a post made to another. Feel free to (re)post it there, though.
That's called a factory, actually. Not a contructor.
Well . . . i programmed for 1½ year, and got my first job at a it-company, they asked me to set up a rest-api on a drupal site, and i just installed a module that did it, the module didnt do everything they wanted so i was screwed due to no php or drupal experience... time passed, and the site eventually went up with close to 0% contribution from my side, then i was put on a c# project which was a little better, i did 2-3 contributions, nothing huge, but it took me a long time to learn c# etc. and i got taken off the project with 1 other guy, because the clients demanded university degree people only on the project, then my internship started and i was at the same firm, and ive been developing some internal tool that manages time, i think ive maybe earned about 10% of my salary and i still have my job, i think i started 23th of january this year. I code all the time, like every hour i have free, and im improveing alot, but im still not able to make real valuable contributions to projects of high caliber like webshops etc. but they keep me around, because as soon as i get to a decent level, i will be billing customers like crazy and allmost make up instantly for the time lost training me... i think they bill customers 4-5x as much as we get paid in hourly wages, and the thing is, and they know this, the first job as a developer is allways the hardest, if they fire me now, i will have a new developer job within the month, its just how the it-business is, alot of job security, and the businesses have ALOT of trouble finding slightly qualified developers, that want to put in the hours. But then ... it is alot of work, and its allways a on-going process... its not 9-5 :)
Roughly how `new` is implemented: function notExactlyNew(F) { const instance = Object.create(F.prototype); const result = F.apply(instance, arguments); return typeof result === 'object' ? result : instance; } Seems pretty similar to me, unless you want to be really pedantic.
I don't think MoTTs_ was calling it a constructor, just saying that the effect is essentially recreating the same that you get with a constructor and new. 
You guys really have to include some information as to why we should be excited about yet another component framework. Shit is getting silly out here in js-land
You say that a lot, but the O/C principle doesn't mean what you seem to think it means. The O/C principle says that **source code** should be closed to modification. From the paper: &gt; It [the open-closed principle] says that you should design modules that never change. When requirements change, you extend the behavior of modules by adding new code, not by changing old code that already works.
&gt; nother) are 100% independent entities. Each has their own moderation team, guidelines, etc. and a post made to one is wholly different than a post made to another. Feel free to (re)post it there, though. I'm thinking about reposting it there, but the game is not really finished yet to be added there. There are other subreddits for game devs but nobody visits them so I thought that here may be the right place to get feedback from other JavaScript developers and people who are casually interested in JavaScript stuff in general.
Looks awesome!
&gt; Coding anything substantial without an extra layer of abstraction on top of native API / jQuery is a horrible idea anyway. Not sure what you mean by the extra layer? And how so is this a bad idea?
Holy crap you weren't kidding. What's the use of promoting open source in such a way?
I think you've replied to the wrong comment cos what you've quoted is nowhere to be found... Easy mistake to make when you've spammed so many times as /u/voxtex points out, keeping track of all those identical shitposts must be difficult
This is incredibly unperformant as libraries go - for one, on calls to `push()`, `pop()` and `unshift()` you're rebinding the relevant `Array.prototype` methods on *every single call*, instead of at the very least caching them per object. I also haven't seen a library so convoluted logic-wise in a verrrry long time. You're doing so much work that could be handled simply by creating a constructor with a prototype based on the Array prototype. It's really not confidence-inspiring.
Maybe it isn't a big deal. Maybe after posting and commenting about it non-stop for a month and only getting 60 stars people aren't as interested as you think. If people want basic DOM manipulation they will use jQuery, Zepto, or any other assortment of libraries available. Zepto is 9kb gzipped and provides significantly more functionality than yours. For any serious web app development, a framework or library will be used. This can be Angular, React, Ember.js, whatever, but at that point they certainly won't be doing manual DOM manipulation. You are trying to fill a niche that doesn't exist. Manual DOM manipulation using ANY library is already considered bad practice for anything but the most trivial applications.
I feel you. If this somehow doesn't work out, there are plenty of other fish in the sea.
&gt; Manual DOM manipulation using ANY library is already considered bad practice for anything but the most trivial applications. jQuery?? which is still used in a lot of libraries. There are devs who don't use frameworks and like doing things in vanilla-js (which again this will make it easier). &gt; Zepto is 9kb gzipped and provides significantly more functionality than yours Well the point with my library is that its using the *Native DOM APIs* which there's a whole bunch of functionality. And whenever browsers add new methods or properties to `HTMLElement.prototype` or anything above this (meaning what it inherits from) my library will also get those methods and properties. If there's any deprecation, the only deprecation they'll have to deal with is whatever the browsers deprecate (which is usually for good reason). And they can keep focusing on learning the browsers' Native APIs.
Also their are valid reasons, why some of the methods from `Array.prototype` are rewritten 1. Method chaining 2. Take `push`, and `unshift` to only accept Nodes and throws error if it doesn't 3. `pop`, `shift` to take arguments as to how many elements to push and pop. etc There's a whole bunch of functionality your code is missing. But this is interesting, I wonder if your way you can figure out a shorter way? But I'm sure its gonna take more code than this.
The link is to a library. Not a guide to using native dom. And this library is steeped in jquery styling.
Yes its to a library/wrapper to the Native DOM API to allow you to use it in "jQuery styling" I didn't say "here's how to use the Native DOM API", you'd still have to learn how to use the Native DOM APIs through docs or articles. But once you do learn an API you can do the following, take the method `addEventListener` once you learn that from let's say [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) instead of you manually writing: var nodes = document.querySelectorAll('div'); for(var i = 0, l = nodes.length; i &lt; l; i++) { nodes[i].addEventListener('click', function(e) {...} } For only about 5kb gzipped you get to do: $$('div').addEventListener('click', function(e) {...}); You get the same Native DOM APIs (so nothing new to learn) And a whole set of other functionality.
If you're not calling the lookup in a loop it isn't going to have any noticeable slowdown. ID lookups are the fastest type of lookup and at worst it might take 0.5ms (in something like IE8). If you just want the code to be easier to read you could memoize the first lookup. 
Nah, not really interested. You're far too defensive for me to think that a discussion with you would ever be productive. This code works without trying to overload the array with element methods, and in 16 lines too: $ = function (selector, parent) { var results, _results; parent = parent || document.body; if (selector.charAt(0) === '#') { return parent.querySelector(selector); } results = []; _results = parent.querySelectorAll(selector); for (var i = 0; i &lt; _results.length; results.push(_results[i++])) {} return results; }; If I'm already going to write vanilla JS, I don't know why I need to *bother* with your library. Those 16 lines will wrap and normalize selections to an array, and I'm confident enough in my own knowledge of the native DOM methods to take it from there... On the other hand, if I'm going to be doing lots of DOM manipulation, I don't know why I'd go with a library that doesn't even have tests and makes poor performance choices for my mission-critical dependency. Also, have you even *read* zepto source? They *also* use the native DOM methods for querying and slicing selections, which is pretty much the sole "advantage" you like to claim. Also, /u/voxtex makes the best point and you seem to ignore it point blank - you're filling a niche that doesn't exist. Why would I be selecting my own elements in the first place, unless it's such a trivial application that I don't want any dependencies? In which case, I'll use my 16 lines of code to normalize selections and call it a day - I don't need to worry about method chaining and the like lol. Your shrill abrasiveness and desperate responses to every comment on this post also aren't helping the confidence in your abilities, the shortcomings in the actual code notwithstanding. Best of luck lol. I'm good without this edit: fix link to /u/voxtex
This is really neat. It fails in some cases, for example with lookahead: // This should fail, but RandExp gives "zx", "zy", or "zz" /^(?!x)(?=z)[x-z]$/.exec('x') // This the only possible match for the regex: /^(?!x)(?=z)[x-z]$/.exec('z')
&gt; I may be wrong I don't know, but if I can sacrifice 0.02ms of performance for readability I will.(as long as that 0.02ms is on the front end). Readabilty? The cached way is still readable (and to me even more readable): var el = document.getElementById('theEl'); function foo() { el.doSomething(); } over: function foo() { document.getElementById('theEl').doSomething(); } Also in the future if you were to use that element again, instead of typing `document.getElementById()` or copy pasting whichever, you just have to use the variable again. Also again its cached!!
&gt; Nah, not really interested. You're far too defensive for me to think that a discussion with you would ever be productive. I'm explaining. &gt; Your shrill abrasiveness and desperate responses to every comment on this post also aren't helping the confidence in your abilities, the shortcomings in the actual code notwithstanding. Why wouldn't I reply to every comment? What's wrong with that? &gt; I'll use my 16 lines of code to normalize selections and call it a day - I don't need to worry about method chaining and the like lol. That's totally fine, others are also cool with the one liner: `NodeList.prototype = Array.prototype` and call it a day. It's a library (meaning optional, you may not like it, or need it, or want it, or care, but you care enough to comment about it) And thanks. (I actually mean thanks, I take feedback as positively as I can)
I can't tell if your being sarcastic?
I believe your a moderator, I'm assuming you changed this from showing up. Why? I prefer this one to show since its actually getting attention. I don't mind deleting the other ones, but could you please put this one back? Thanks. Let me know if I should delete the other ones.
Maybe report that as an issue on github? No guarantee that OP of this post is the author.
Also... Use throttling for rapid-fire events. Lots of people bind handlers to things like scroll or resize, which can trigger dozens of events per second. Use a throttling function to limit the number of times an event can trigger to a fixed maximum number. Features like `requestAnimationFrame` are pretty good for this, but you can also just do something silly like this: // accepts a function, and a delay (milliseconds, default to 150ms) // returns a throttled event handler function throttled_handler(handler, delay) { var throttle = false; var queue = false; var delay = delay || 150; // this is the actual event handler that will be bound to the event var throttled_handler = function() { // if the handler is throttled, queue the next execution and do nothing if (throttle) { queue = true; return; } // enable the throttle and execute the handler throttle = true; var args = Array.prototype.slice.call(arguments, 0); handler.apply(null, args); // after a delay, disable the throttle, run the handler if it has been queued // NOTE: the queued event will run with stale arguments (&lt;delay&gt; ms old) setTimeout(function() { throttle = false; if (queue) { queue = false; handler.apply(null, args); } }, delay); } return throttled_handler; } // 'hello' will print at most every 150s window.addEventListener('scroll', throttled_handler(function() { console.log(arguments); })); You can see another example of a throttling handler here: https://developer.mozilla.org/en-US/docs/Web/Events/scroll.
No it doesn't, necessarily. There are things culturally associated with 20 year olds, but 50 year olds can be a part of that culture too. They just generally don't. Ditto for the reverse. If for example, "nursing home culture" consists of laying around all day waiting for someone to call you so you feel less pathetic, then I spent most of my 20s ascribing to that culture. I might not refer to it that way, because I don't exist in that context, but if someone were to accuse me of not ascribing to or fitting with a 'nursing home culture', they would be incorrect in the context of this over-extended joke. 
You're doing it wrong. Your first example is already using an object as a class rather than a prototype.
It's been taken care of -- thanks for the reports everyone.
There would be massive discussion if it was down for a day or more. You might want to keep this site in mind for problems like this in the future: http://downforeveryoneorjustme.com/
You can thank Eric Elliott for spreading that one.
Ah yes, [I knew I heard that somewhere before](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3): &gt; Constructors violate the open/closed principle because they couple all callers to the details of how your object gets instantiated. Making an HTML5 game? Want to change from new object instances to use object pools so you can recycle objects and stop the garbage collector from trashing your frame rate? Too bad. You’ll either break all the callers, or you’ll end up with a hobbled factory function.
&gt; Does anyone have any really compelling examples of where prototypes are easier to develop and maintain than classes? They are slightly more flexible and can be easier to unit test, but the downsides aren't worth it. Any codebase that uses `Object.create` extensively is hell to deal with in my experience. Subtle bugs that are nearly impossible to track down without binary commenting. It's sometimes worse than code written by Java architecture astronauts.
I also feel like any time I try to be true to the prototype, various libraries and frameworks fight me all the way. I was excited about classes but now I'm worried they will just create yet more deviation on how to do things. I wonder if a simple langauege that has deficiencies is better than a complex language that yields many ways to do one thing. Hmm. Maybe that's why I love Python and maybe Python makes me hate JavaScript. 
what about `document.body.innerHTML += '&lt;script "type=text/javascript"&gt;console.log(Object.keys(window)); console.log(FaceIt)&lt;/script&gt;'` might give you a different scope? edit: you could possibly replace the jquery ajax func, and get the data `if (ajax.url == 'myurl') ...`
No. Don't have initialization code that doesn't depend on parameters. You're doing that because you're recreating classes.
Jumping in late, but I thought I'd still comment. It depends. Are you the type of programmer who sees your code as a means to an end - who wants to get to where things are working and quickly see something working? jQuery might be your answer, then. At a lot of hacker schools, though, one of the first things you learn is reimplementing DOM traversal things. The DOM, if you're not familiar yet, is basically a tree. jQuery, provides a bunch of convenient means for interacting with that tree. Suppose you have a node in your tree and you want to see if it's part of a certain ancestry (checking if a click event happened within a certain part of your app, for instance). You can use a method from jQuery right out of the box. Or you can write a recursive method that checks all of the parents until you get to the top. This will obviously take longer. But you'll walk away with a much more solid thought process for how to go about DOM manipulation. The jQuery approach will get you where you need to go. The JS approach will give you a richer understanding of working with the DOM. That said, tools like React make tools like jQuery less valuable - as it removes the need for DOM manipulation and instead presumes efficient reloads (and they can be extremely efficient). It's not just a fad, it's got some strong functional principles proven in many other programming realms. jQuery is becoming outdated. 
Yes, that's an even better approach if you have tens of sources. Thanks for your feedback
&gt; So I am wondering is there ever a time it's ok to just re call document.getElementbyId() in a function that is rarely called? First of all create an alias for any long method name. Secondly, just create an object to store your dom references. This way the DOM references are confined to a single location so that the rest of your code remains easy to read and you only have to reference everything once. var id = function (node) { return document.getElementById(node); }, domnodes = { fancytext: id("fancytext"), outer : id("outer") }; domnodes.fancytext.innerHTML; 
Its his personal site, his opinion doesn't affect the company at all. People are allowed free speech, that doesn't go away just because he has employment. Pintrest might even use React!
Afaik the browser support isn't good http://caniuse.com/#feat=multicolumn I believe the CSS grid layout will be the answer in the future for those cases but it just being draft.
NPM. Also this article is worth your time http://gofore.com/ohjelmistokehitys/stop-using-bower/
Well except that you can't take advantage of function composition with new and you can with a factory function. That's a pretty big difference.
mb some of the browserfeatures cant be used because they are not supported by older browsers wich fb has to support? Could it be that react inserts the spans for performance reasons in long texts? &lt;div&gt;[a lot of text...]{x}[another long text]{y}[...]&lt;/div&gt; now if x changes tusk has to rerender the content of the entire div? Not sure if thats actually a performancehit or not.
 var jsObj = {}; jsObj.customerNumber = function (email) { return $.ajax({ url : "http://www.myurl.com/" + email, type : "GET", dataType : "json", async : false }); }; // Usage jsObj.customerNumber('test@test.com').done(function (customerNumber) { if (customerNumber &gt; 10) { foo(); } else { bar(); } }).fail(function () { alert('We failed to retrieve that customer number'); }); 
Hey, so I reinstalled Node today, and I still have the same problem. [Here is the log](https://drive.google.com/file/d/0B3eyHW4ppiSXNC11em82bWd4NWc/view?usp=sharing). [Here is my console at the end](http://i.imgur.com/qsZQpXO.png).
While I philosophically agree with the `Object.create` approach, my problem lies here. Which one of these is more readable and scalable? var Person = { getName: function() { return this.firstName + ' ' + this.lastName; } }; var bob = Object.create(Person, { firstName: { value: 'Bob' }, lastName: { value: 'Saget' } }); vs. var Person = function(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; }; // Readability is debatable here but more memory efficient Person.prototype.getName = function() { return this.firstName + ' ' + this.lastName; }; var bob = new Person('Bob', 'Saget'); or if you still want to have your initialization values to be named var Person = function(opts) { this.firstName = opts.firstName; this.lastName = opts.lastName; }; ... var bob = new Person({ firstName: 'Bob', lastName: 'Saget' }); For me, the `new` keyword wins.
steven hawking describes the nature of the universe more succinctly than this
Did you check the site? I got a masonry style working fine with just CSS.
So, if I understand correctly, his new architecture is: a Dialogue with capital D takes input and produces output. They can be nested. Woah. Revolutionary. 
my bad. i did say 'dare i say'. i shouldn't have dared.
I've intentionally stopped keeping up on PHP. 5.3 Was still current when I checked out and never heard that even 6 had come out. /relevant if you're asking /r/javascript and not just PHP developers who coexist
What's are the pro/cons of using browserify or webpack ? And when you say npm, you refers to browserify/webpack or running npm script ? 
Me too. I have about a decade of experience with PHP and I have been rolling in the market quite well as a consultant and doing active open-source contributions. But, I stopped at the version 5.4. I have decided that being an expert in PHP and JavaScript is just too much. Now I think that being in JavaScript alone an expert is a challenge (considering how fast everything is changing; or am I just getting old?). That said, PHP 7 is really well designed, has some great new features (http://php.net/manual/en/migration70.new-features.php), got rid of a lot of legacy compatibility issues, etc. Personally, I have added "PHP 7" keyword to my job market search, just to see how well it becomes adapted. 
13kb is a pretty huge budget. You can even get away with using [npm modules](https://gist.github.com/mattdesl/73e3b9f902f9c834b721) during early development and strip them away later if needed. 
&gt; "Web Components doesn’t have an idiomatic way to define things like where events go. How do you pass data when everything is a string?" Says a Facebook developer, one responsible for React, who chose to forget that JSON is a thing (and also a string).
It won't have any effect on the Node community, nor on any other. It may improve quality of life for existing php devs, but no-one (who isn't already using php) will be picking up php for new projects. 
Because... ?
The web is full of frameworks that deal with the core HTML elements. Given that trend, why would people want to hide those elements inside custom objects? It seems like you actually lose ability to manipulate the DOM, which is a bad tradeoff. Disclaimer: ive not use web components at all, just an outside perspective
Tusk has been tested in ie9+ (although not for a while but I'll ensure support before 1.0 for ie9+). React only supports ie9+. The biggest thing that would stop tusk working pre-ie9 is the lack of support for capture events. Also the performance hit in that case would be negligible or favorable toward tusk. I was testing [splitText](https://developer.mozilla.org/en-US/docs/Web/API/Text/splitText) and it is a very fast operation. Also it only is ever used during the initial render/bootstrap. In my tests I could never find a situation where react bootstrapped faster than tusk and often tusk was ~10x faster. As far as updating text nodes after the initial render it works very similar to react, if x changed only the section that contained x would be updated since its is an individual TextNode. In react instead of updating a text node (nodeValue) they are updating the innerText of a span [which is often slower.](http://jsperf.com/innertext-vs-textcontent-vs-textnode/6) Again I thank you for prying and all of your questions. Helps me make tusk better!
Avoid premature optimization. :)
The code isn't the problem. The result is zipped and you can additionally use a tool like uglify. There are even some templates on the contest site if you don't want to set up your own toolchain. But don't expect to get any assets in there apart from simple pixel sprites. If you want your game to look good you have to rely on procedural generation.
Because why should it? As far as purely technological reasons go, PHP is generally something you start out with, not something you switch to. The biggest benefit of PHP is availability and affordability of programmers.
&gt; co-location rats nest Can you elaborate this bit? [edit] I've also noticed views getting bloated but wanted to compare notes.
seeing your example makes me realise how similar it is to the factory pattern, would they have the same issue of object identification because they aren't called with the new keyword? aPerson instanceof Person; //false aCreatedPerson instanceof createPerson; //false, does this even make sense? 
I couldn't agree more :) https://en.wikipedia.org/wiki/Composition_over_inheritance
&gt; You put this in your own response and then try to argue against it? You're hilarious. Yes, I acknowledge that the **behaviors and beliefs** of a given age group constitute a culture. I assume that you will acknowledge that not all **members** of an age group share the same behaviors and beliefs. Thus, **members** of one age group can share the **behaviors and beliefs** (the qualifying factor for a 'culture') or a **different age group**. Is that clear enough? 
Bye 
Cool read. That site though..
&gt; never heard that even 6 had come out. It didn't. They skipped it...for *reasons*.
And in ES6 we can do function createPerson( opt={} ){ ... } 
Adding to /u/mattdesl's answer, you can also just return opt after modification so as to "inherit" whatever came in. var animal = { poop: function(){...} } function createPerson (opt) { opt = opt || {}; var name = opt.name || 'John Doe'; opt.sayName = function(){ .... } return opt; } var guy = createPerson( animal ); guy.poop();
Are you referring to functionality or aesthetics? IMO it rates high functionally, and I don't care about aesthetics as long as it doesn't impact usability.
Well you don't lose the ability to manipulate custom elements any more than you don't have the ability to manipulate native elements (like buttons or inputs). Instead of having to include 3 scripts, 1 CSS file, provide a folder with images, and then hope that none of those classes conflict with anything you have elsewhere in your application, you include an encapsulated element. It lets you treat the element as a native one in 90% of cases, and still allows you to dive deep into the element and modify it like you would be able to before anyway (there is no true "private" variable/method type system, everything can still technically access everything). It means that I can make an "upload image to imgur" element which contains all the JS, CSS, html, and other shit that i need in a single import with a defined external API. Bring in that one file and it just works. IMO a combination between Polymer and React would be perfect.
&gt; Given that trend, why would people want to hide those elements inside custom objects? But you don't mind that the native objects do this, do you? E.g. the controls of a &lt;video&gt; element are something you don't have to put there yourself. Imagine you were doing the UI of a software synthesizer or drum computer. Would you rather have this: &lt;div class="SmallKnob" style="background-position:uar...wtf"&gt;&lt;/div&gt; or this: &lt;small-knob value="127"&gt;&lt;/small-knob&gt; &gt; It seems like you actually lose ability to manipulate the DOM, which is a bad tradeoff. You still can manipulate the DOM as you always did. You now just got more "native" elements with their own "native" methods and properties. So, if you set the value of one of those `small-knob`s (just `foo.value = 5`), it will turn accordingly. This knob Custom Element will also work with React, Angular 1/2, Ember, or any other framework. As far as your code and those frameworks are concerned, those Custom Elements are exactly the same as the native ones.
The art of making something that could be very simple seem incredibly complicated.
&gt;how does it affect JavaScript and node communities. How does the pope becoming atheist affect where bear takes a dump? 
There are a ton of staggeringly incompetent responses here. Sorry about that. I think this is a truly excellent write-up that covers the nuances, motivations, designs, and considerations between different systems. Furthermore, I agree with you that truly modeling UI means having hierarchy baked into MORE than just the rendering layer. You need to have behavior trees, action graphs, etc to get things really moving. A lot of people think "this stuff is overkill and I've been writing UI for years w/o it". They are not your competitors or peers, just let them be.
oh yeah I had that problem for the endless scroll thing in my app, I noticed that it was making multiple calls to my server (which is bad). I forgot what I did to fix it, but it had to do with a on off boolean variable that only goes to true again when the success function triggers with results from the server. So in reality what happened is I did not fix the the fact the event called more than once but I did stop it from triggering the ajax call with help with a boolean variable from the module object that is scoped for both functions. 
so when I bind an event to a class is that creating a listener for all elements with that class being created? Or is every element that is clicked parsed and then checked for listeners? Also so when you day delegate, lets day for a parent &lt;UL&gt; that has the listener, who would it know which of the LI children node was clicked? Is there a like or phrase I can google to read up on this thing you just explained? 
Question, I heard that for Browsers the JS engine runs on a predefined lowest common denominator so that it runs the same regardless if someone has a shitty computer or a good one. Is this true? I mean my program runs very fast but I have a decent computer .
Because it's an abstraction. While there are many parts of Angular that I'm not comfortable with (and I've only done one project with it), I did really enjoy the concept of custom elements. They're not as useful for simple elements like inputs, but for more complex elements that you might call components (datepicker, etc.), they can really improve development IMO. For instance, [some (many/most?) UI frameworks require that you implement a non-trivial amount of very specific markup](http://getbootstrap.com/components/). While not exactly hard to do, it can be time-consuming, and in my experience, the chance for bugs increases with every line. On the other hand, custom elements typically require only a single line of markup with all configuration done via a set of attributes. They're faster, less error-prone, and more modular by design. If you're using a UI framework, should you really need to be manipulating the DOM of the components anyways?
Using the following in my contentscript: var script = document.createElement('script'); script.appendChild(document.createTextNode('('+ testLog +')();')); (document.body || document.head || document.documentElement).appendChild(script); function testLog() { console.log(Object.keys(window)); } I did get a much larger array than just calling Object.keys(window) from the content script yes. I tried in the testLog function to directly access window.Faceit too but that gave me a big fat referenceerror (Uncaught ReferenceError: Objects is not defined). So not quite sure what to do.
13 KB of minified and compressed code is actually quite a lot. It's enough for 2000-3000 lines of code. You can create simple games with a few hundred lines. So, this kind of limit actually isn't very restrictive. Anyhow, there is still something to keep in mind: ZIP isn't the most advanced nor the most optimized format. Each entry has two headers. This makes the per file overhead surprisingly large. Secondly, each entry is compressed on its own. It isn't a solid archive. If you have 5 files with the same large header, this large header will be stored 5 times. You can for example inline the minified JS in the HTML file. Use a Grunt (etc) task for the entire packaging step. You can also inline images. Here is an example with a 4-level/6-bit/64-color palette ([same as the Master System](https://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Master_System)): https://www.reddit.com/r/gaming/comments/3hh9ej/how_oldschool_graphics_worked/cu7stdw Also note how I create a canvas there and then use that canvas as if it were an image. You can create procedural graphics the same way. Create an off-screen canvas, draw to it or mess with its pixels, and then you just use it as if it were a regular image. You just draw it with `drawImage` onto the on-screen canvas. Finally, make all your identifiers local. Local identifiers can be "munged" (renamed) by minifiers. Global ones, on the other hand, cannot since they are the public API of your library/framework/whatever. A linter and strict mode will prevent you from accidentally creating any implicit globals.
I've looked over cycle, but haven't used it yet. That said, your criticisms aren't exactly correct. Rx is event triggered, so your toggleButton event shouldn't be called any more than it would be in any other framework. `forEach()` is transformed into a for/while loop by all the popular libraries (except the built-in ES5 version), so complaints of forEach performance vs for loops are hardly justified (especially in libraries that are lazy). Modern JITs cache anonymous functions intelligently, so they aren't recreated every time. If you did want to push this point, when you use "controller as" syntax in Angular and put functions inside the constructor instead of attaching them to the prototype, you are guilty of the same thing. You should be able to use React's JSX with cycle as this is already possible with that vdom implementation. HTML and controllers aren't really separate concerns since they are tightly bound to each other anyway in 95%+ of cases.
&gt; Gotta write more boilerplate code if you want to use static typing. You can write interfaces around a JSON structure to get static typing on JSON objects. While this is nice, it can be tedious to maintain if your JSON structure keeps changing. The good thing is that it's entirely optional. So if some of the libraries you use are too much of a pain to statically type, you can just use them as you would in normal JS. 
Because php has zero appeal do developers who aren't already heavily invested in php. They've already got better options.
Why are you including both a CSS class and a style tag...? that makes it seem extra obtuse.
I'm conflating my argument? With what? What are you going on about
https://gaming.youtube.com is already using web components, inspect their markup, you guy's can see it for yourself. It's a mixture of angularjs2 &amp; polymer
Please elaborate. How would you style a knob with a variable `background-position`? By creating CSS classes for every possible integer?
Yes, but you still need a `style` attribute. Writing `$('#knob').css({ backgroundPosition: '' })` instead of `document.getElementById('knob').style.backgroundPosition = ''` doesn't change that fact.
Not enough jQuery. Dont worry you will improve /s
They are certainly simpler. There's no denying that. But they are also much more prone to bugs than ES6 classes. For example, if you share an array or an object several levels up the chain that gets mutated, good luck. If you override a method or property that an object up in the chain depends on, good luck. If you forget to initialize an object, good luck. (Or you could just create a function that both creates an object based on the prototype of another, and then calls an initialization function... aka basically constructors without `new`. And then you have to worry about parent `init` methods, etc.) All of the problems caused by this are compounded by the fact that people overuse `Object.create`, resulting in large, brittle chains of dependent objects. If you ask me, classes and `Object.create` are both bad because they rely on inheritance. But at least with classes, people are relatively aware that inheritance is bad. I don't see `extends` very often. Because the syntax is statically analyzable, you could even write a linter rule that forbids `extends`. The problems with `Object.create` can be remedied somewhat by using immutability and writing your own framework around it, but then you run into interop issues and have to maintain your own framework. I think the best approach is immutable or stateless objects and functions/closures. But I would definitely choose `class` over `Object.create` any day. Sorry, had too much coffee.
What happened to responsive layout? TL;DR the original website is not readable on mobile:-( 
the fn passed to `swapFns` are local variables and wont effect the outer code works: https://jsfiddle.net/pvgq7mum/ you can do something like window["funcName1"] and window["funcName2"] probably... but what you probably want is `fn.call(obj)` this way you can set the `this` value to a custom object. ex `fn1.call({a: 1234})`
I'm curious, why do you find yourself needing to do this?
Node is single threaded. The benefits async has more to do with all users existing on a single thread than, than your example. To oversimplify it, this saves on resources and improves performance and allows the server to support more users more easily than throwing each request on it's own thread. In your example, the async means that users B,C, and D don't have to wait on user A's query.
This seems really unconventional. What are you [really trying to do](http://mywiki.wooledge.org/XyProblem)?
Part of Stephen Hawking's genius and infamy is an innate ability to distill abstract and fantastical ideas down to layman's terms. This piece opens by stating it is not intended for beginners. Your criticism is trite.
&gt; We’re not going to build React on it because there’s a strong model difference – imperative in Web Components to declarative in React. Web Components doesn’t have an idiomatic way to define things like where events go. How do you pass data when everything is a string? We see it more as an interop layer that lets various frameworks talk to each other. This is some serious misunderstanding of web components by Sebastian Markbage. First, I don't see how React components are any more declarative than web components. In fact, React components seem more imperative in at least two ways: 1) The most popular web components library, Polymer, is built around templates that are more "declarative" than JSX. 2) Once defined a web component is used in plain "declarative" markup just like any element, and without the need for a surrounding script-driven framework. Second, what's with this statement: "How do you pass data when everything is a string?" I'm not even sure what he means, but he's not describing web components in any form I'm familiar with. Yes, elements do have string-valued attributes, but they also have object-valued properties, and fire events with various types, including custom events with object payloads, and they have children of various node types, which in turn can have complex valued properties, etc. In general, data types and data flow in web components work very much like React anyway: properties and attributes flow down (they're set by the host component), and events flow up. Even Polymer's 2-way data-binding is still data-down, events-up, it's just that elements fire events when some properties change, and the host reacts to it. &gt; In talking to the Atom team, this doesn’t solve different framework idioms as it doesn’t have an opinion on how they relate. This is strange as well, because HTML clearly defines the different ways in which elements relate. There is the parent-child node relationship, events, attributes, properties, the custom element lifecycle callbacks (created, attached, detached, attributeChanged), and Mutation Observers, all together giving custom elements some powerful means of collaboration.
Some assertions: 1. We want our web servers to be able to respond to a large number of user queries simultaneously 2. Most of these queries in, say, a CRUD app, are blocked by I/O. So the CPU is idle. 3. Spawning threads and processes for new request / response cycles is expensive 4. We could multiplex threads, spawning a pool in advance and using them as required, but these will need to be either sandboxed or written in a threadsafe manner. So, if we run everything on a single evented thread, with serial concurrency, we have a fairly convenient compromise where we can respond to high volume I/O bound traffic without having to worry about thread safety.
Firstly, you really shouldn't worry about it until you discover a bottleneck and profiling proves an issue. At that point, you're allowed to make exceptions to your idiom. Secondly, I'm not aware of any particular constraints around using 'new'. If you're dealing with that many entities you usually decompose them into some more primitive data structure, or just recycle within an object pool.
I haven't read OP's article, so perhaps this is addressed. My understanding is that browser vendors can't agree on key aspects of how web components should work, and Apple is making matters difficult by dragging their feet. Edit; just read it. Pretty much spot-on.
Yeah and it doesnt work on ie10. I really wanted to use polymer on my project but it requires better browser support unfortunatelly :(
http://www.joelonsoftware.com/articles/fog0000000018.html
You should lint your code at build time, fail build on error, do this and eval and other things will be caught no problem, I work sometimes with less experienced devs and even though we code review, sometimes things just get through the cracks, in my experience linting is a must. My 2c
Can you post more of your code? I'm a little confused by how you say "For reference, it's not the act of looping through the list." and then "That dropped the response time of iterating through the whole list for @ to ~600ms." The 600ms is the total loop time, not including the final DOM append?
Can you clarify what the improvement would be?
Code snippet of the object is correct, except it's a string, and a number, so `"175"` instead of `someThing`. And I don't necessarily need it autocompleting right away, but some of the numbers are hard to remember, so it might be an inconvenience to not have it do that. Perhaps @ could be done away with, but @N kinda needs to be there. it's a complex, and sometimes hard to remember, numbering system (it's a browser extension, and it's the way they organize their help center, so I do it that way to allow easy linking). Anyway, it seems that the bottleneck really, is the .append() calls, or rather, the amount of data appended (several hundred characters per item in the list we want to show). I can do Object.keys(), and then a for loop to append each item in the filtered object to the list, but I don't think having less items in the for loop will be as time-saving as finding a different way of appending the stuff. I could be wrong though. Ideas?
In the above example the `id` function is just a shortening of the document.getElementById method. The `domnodes` object is your cached DOM nodes.
Well, they still became popular. Do you think it lose traction? Because with PHP 7 becoming more mature and performant it should at least stay as much popular as now. I think you're right when you say it won't have any effect on both communities, but I think at least as much people will be picking PHP for new project as before.
I think for(i in x) is an expensive operation, and pulling out the keys as an array and working with that will give you a bit of a performance increase. If using something like ramda, can have var mention = 'javaS'; var test = new RegExp('^' + mention + '.*$',"g"); var result = R.pickBy(function(val, key) { return R.test(test)(key) })(x); Although the .append is probably the more expensive operation. Reducing how often you do it is probably your best bet - after the loop/having your results, and also throttling the search so it only fires off every few ms, so something like $.on('whatever',$.throttle(250, thingThatDoesSearchAndAppend)) So if a person is typing fast, it'd only trigger every other 250 ms instead of every keystroke. Also, how are you forming up the HTML that you are appending? there could also be a performance bottleneck there.
There's a huge difference with web components that comes from being integrated with the browser. Since the browser creates elements, including custom elements, all the right things happen if you set innerHTML, or document.createElement(), or just have some markup in your index.html (index.html, remember that?). You also get callbacks when attributes change, or when your component is added or removed from the DOM. The critical part there is that you can manipulate the DOM with any script, like jQuery, and it works with your component. Interop is paramount with web components, and usually non-existent with other frameworks.
The timing starts when the .on('input') event fires (when you type), and ends when the whole thing completes, which goes beyond the loop and .append(), and runs through one final .show() to unhide the element we're working with. Edit: And what I meant by the first bit was that it seems like the slowdown isn't because of the loop, but because of the .append() calls (or, for the append to string, and .append() string at the end, the volume of data being appended).
There has been a ton of progress recently. Things are looking good!
This is the story of the web. What happened to web components? Doesn't align with M$ business model (since it competes with desktop components).
All custom element attributes are strings. Being able to pass in attributes of a certain type is dependent upon that type being serializable on the user side and deserializable on the component side. Or injecting properties directly into the component. For example, Polymer deserializes objects using `JSON.parse`.
Nobody likes IE, but ehh, IE10 was released, what, 3 years ago? I don't recall any browser having good support for this stuff back then.
If you are using it to replace your workflow, that's one thing. It's limited in that aspect but if it provides you all you need then I can't knock it. However, in my opinion, the best part of Webpack is how it separates modules so that code can be pulled in as needed. Unfortunately Angular 1.x's all or nothing dependency system doesn't support this. As such, Webpack is largely useless for that aspect. I plan to mess around with it more when Angular 2.0 is in a stable release though as I suspect that I will be happy to switch. 
http://i.imgur.com/MFRV9Ut.jpg How would your markup for those knobs look like? There are 20+ of them. How many elements would you need? How do you set it into a specific state? Would you use a data attribute? Do I then have to run some jQuery plugin on that element to activate it? How much of a pain will it be when you replace the implementation? E.g. the first one used a sprite sheet with 64 states, V2 uses layered elements and rotation, and V3 uses canvas. The point was that you'll leak those implementation details. You have to interact with this very specific thing in a very specific manner.
With the async nature of JavaScript, things get pushed onto the event-loop, so that other things can execute while waiting for the callback to get executed. This is what allows for a highly performant system despite being single-threaded. Toss in the ability to do clustering/etc. The async nature is what has lead to people coin the term 'pyramid of doom' of having deeply nested callbacks that are hard to follow. However, various patterns/libraries have come up to help solve this problem. The most obvious one is promises, which can help make code easier to reason about by being able to do things like. getSessionFromDb .then(getCartInfo) .then(sendPaymentInfo) .then(sendtheResponse); Instead of blocking things at each step of the process - it gets pushed onto the eventloop, allowing other things to come in and be processed. So while the getSessionFromDb may be slow - it'd only slow down the response for the user expecting that - it wouldn't be blocking the requests from other users. Now, if the getFromDb call returned a row with 1,000,000 records, and you did something like result.sort() - that might cause things to lockup and kill the performance of your app - unless you did an async sort that would chunk things up, and and push things into the event loop to sort instead of trying to do everything at once. If the database calls were being handled synchronously, where you could do var session = getFromDb(); var cart = getCartInfo(session.userId) var paymentDetails = getPaymentDetails(somePrams) var payentResponse = sendPaymentInfo(whatever) res.send(paymentResponseStuff) then yeah, the single-threaded nature of node would be a huge performance killer. With some features in ES6, and some of the proposals in ES7 - you can write async code that looks like it was synchronous, but at core - it's all still async. 
So like ES4?
Assuming you've already checked the project's issues, you'll most likely just need to dive in further to investigate. Use a profiler, or sprinkle some timers in the code and figure out where the time is going; if it ends up being a system call (like filesystem/network operations), then you may need to dive even deeper and use some lower-level debugging tools (perhaps `strace` or similar). 
What he said is: &gt; Not everything is a string with web components. Which isn't true. All custom element attributes are strings. As far as Polymer goes, I believe that if you use a Polymer element within the context of Polymer, then it uses JS to inject the properties directly. Either way, that behavior is framework-controlled.
&gt; Unfortunately Angular 1.x's all or nothing dependency system doesn't support this. As such, Webpack is largely useless for that aspect. I'd disagree with that. Although recently I have been wondering 'what is the best practice for things to be injected via DI, vs things to come in via an import statement'. But, for example - I can have say: app/component/someComponent/index.js, which looks something like import SomeController from './some-controller' import dep1 from '../path/to/angular/module/that/exports/a.name' export default angular.module('myModuleName', [dep1]) .controller('SomeController',SomeController) .name where some-controller.js simply has a default export of a class like export default class SomeController that is a plain old JS class that looks something like import * as R from 'Ramda' export default class SomeController { constructor(somethingInjectedByAngular) { R.filter(somethingInjectedByAngular) } } SomeController.$inject = [ 'somethingInjectedByAngular'] then the nice thing with my unit tests, I can just do something like: let ctrl = new SomeController(myMockedSomethingInjectedByAngular) and I don't need to worry about dealing with angular mocks and setting up custom-providers/etc. When looking at the bulk of the code in this project - it barely looks like angular code, and the only time you see that much angular-specific things is in the index.js that is basically wiring up my imports to things that I want to be available to be injectable into angular at large. That said - I'm still torn on where to draw the line between exposing stuff as 'angular services' to be picked up by DI On the constructor/etc, vs what I should leave as an Import at the top (and looking into other mocking libraries to help with testing). This approach though very much has most of my application looking like plain-old-JS, of which Angular is just the framework that it hangs off of - but not necessarily depends on, and there is more modularity allowing aspects of the codebase to be re-used client-side/server-side, or with other frameworks, or simply on it's own. If anything - it opens up some exciting possibilities, and can lead to an easier migration from Angular 1.x to 2.x, or another framework all together as most of your code starts to become framework independant. 
My bad. I thought he was referring to custom element *attributes* not being strings. (Which would be easy to get confused about, since you can write `&lt;custom-element obj="{{obj}}"&gt;` in Polymer, which looks like an attribute.) But yes, a custom element *property* can contain an object, and Polymer (presumably) desugars to that.
http://jsperf.com/prototype-vs-closures/21
Three reasons I prefer to use node: 1. Simple streaming interface: a.pipe(b) 2. The vast amount of abstractions available via npm 3. It's really fun.
The closest thing to changing "the actual function bit that runs" (a.k.a. the internal `[[Call]]` property) is known as [function decompilation](http://perfectionkills.com/state-of-function-decompilation-in-javascript/), which means parsing the output of `Function#toString()` to build up a new function object based on the source code of the original one; it really is an ugly thing, it only works with non-built-in functions (that don't have custom `toString` methods), and it *still* involves making a whole new function object, to which any properties not inherited from `Function.prototype` would need to be manually copied.
Indeed. I was trying to articulate why I preferred react at the time but couldn't put my finger on it. Among other things the main contributing factor was that React had Flux and therefore was a complete front end architecture whereas I couldn't imagine a stack with Web components as easily because it wasn't spelled out.
I v e found that with react I don't need to worry about DOM manipulation or traversal. My components just represent some state and React handles all the manipulation to make it happen. If I was doing a lot of visual effects I may have different needs though.
Could you elaborate on what you mean by "the logical part" a little bit? The way things work? How JavaScript processes information? How to plan your script? 
/r/freelance is a better place for this
Wow, I've never seen anything by Google load so slowly. Takes a full five seconds to display any content for me, versus one for YouTube.
We can give advice here (though no, it's not the norm), but I personally don't think node/js has anything to do with it (it's my field). It's more about general marketing. You're going to get similar advice from Rails, PHP or Java Devs, graphic designers, etc. There's no need to limit yourself to /r/javascript :)
This is being added as a standard with requestIdleCallback https://developers.google.com/web/updates/2015/08/27/using-requestidlecallback?hl=en Still not production ready though.
 function swapFns(fn1, fn2) { firstFunction = fn2; secondFunction = fn1; } Ignore all the "it's impossible" replies, that's this subreddit's way of saying "it's slightly unconventional".
Wow, Joel on Software! Really liked his articles back then in 2001 and true to the point made, a lot of the technologies he mentioned did not survive and died with the dot com era. Back in our future we are dealing with making modern apps in the mobile age. An era that was pretty well ignited by Steve Jobs in 2007 and again in 2010, need I say more! Both Java and Flash were banished from his mobile devices and so began one of the greatest r/evolutions as HTML5 and JavaScript seized the day. In the years between 2011 and 2014 the brave astronauts at W3C, Google, Yahoo, Microsoft, Facebook and many others evolved their web engines and produced frameworks. Each time pushing forward with something better than before. This is how progress is made, not by ignorant cowards and retards but by brave visionaries, like Kennedy who because he set a mandate to get a man on the moon also had a big impact in shrinking computers down to a smaller size. Today we are benefiting from the space program and using astronaut sized mobile technology everyday. The present lineup of astronaut frameworks includes React, Angular, Firebase, Relay and Falcor just to mention a few. None will please everyone and it is only by iterations that we can see the forest for the trees. Also, when you think about it there is actually nothing that spaced out about MVC or MVI or Rx, they are essential and just the way things work and getting better all the time. The real problem was that we forgot about the fundamental Human-Computer Interaction flow and that this flow needs to be FULLY reactive. Cycle.js just reminds us about who we really are and that this interaction is indeed a cycle. We have to remember that technology exists for us, see "What if the user was a function?" below to be clear on the concept. https://www.youtube.com/watch?v=1zj7M1LnJV4
Just put it in a npm module. If it appears to work, nobody will ever even glance inside it. ... no but seriously. I've actually gone to use an optional parameter in Node's core libraries to find that it simply wasn't implemented. An old, documented, stable feature, with discussion around it and people arguing about their use cases, and it's never existed. Why did nobody notice? Because it was stubbed with a no-op, and in some cases the function would turn out to be a no-op, so people just assumed it was working as expected and never once verified it in any way. And this is in Node itself.
Hard to say if it's a cause of any issues, but just be aware, that's a massive race condition. You have no guarantee that your delete will have run and finished by the time `csstask` and `jstask` run.
It's a Greasemonkey script, so I'm on Firefox. I'm calling a .hover() to style the css on the items in the list, but that defines the function and moves on right away, so the rest of that code is finishing while it's still listening for the hover, so that's not an expensive call. I'll tweak the timing and get some splits at different parts tomorrow when I'm at a computer again.
First off, Mozilla has amazing Javascript documentation. You should read [their page on Object.create()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) to get a thorough understanding. `Object.create()` creates a new object which inherits all the properties of the original object, but they can be overwritten. Assigning a variable to another variable that is an object using `var` only creates a reference to the original object. So here's how that plays out. var original = { a: 42 }; var reference = original; var created = Object.create(original); // All three objects have the same value for `a` at this point. `original` and // `reference` are the same object, and `created` is inheriting it's value from // `original` console.log(original.a, reference.a, created.a); // 42, 42, 42 // Let's change a value and see what happens original.a = 43; // All three are still the same. `reference` is referencing the same actual // object as `original`, and `created` doesn't have it's own value for `a`, so // it uses `original`'s value. console.log(original.a, reference.a, created.a); // 43, 43, 43 created.a = 'created a'; original.a = 44; // since `original` and `reference` refer to the same object, they continue to // have the same value for `a`. However, `created` now has it's own value for // `a` and we see that reflected here. console.log(original.a); // 44 console.log(reference.a); // 44 console.log(created.a); // 'created a' // Additionally, since `original` and `reference` refer to the same object, we // could have changed `reference` to the same effect created.a = 'created a new value'; reference.a = 45; console.log(original.a); // 45 console.log(reference.a); // 45 console.log(created.a); // 'created a new value'
I see what's going on now. When I change the created value only that one changes. I did notice though if I changed the original mentioned in your code that bar.a changes as well. Thanks!
No it isn't. Stop trying to solve the general case and think about his exact question.
That's webcomponents for you. Works in chrome.
Sorry, I'm nit understanding what you're referring to with the regex. Then again, it's 1am. Care to point out where I'm using regex? Probably something I shouldn't be able to miss, but you know. :) Edit: Can I still profile the code in Firefox if it's a Greasemonkey script and not actually part of the page?
This. The problem with webcomponents is they dont work. They don't work at all in old browsers... and they don't work well in anything except chrome. The polyfills are slow and crash; there's no significant effort made to making sure they even run cross platform. React has a clear stance on [browser support](http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills), and its here *right now* and it *works*. That's the difference.
Check out something like [run-sequence](https://github.com/OverZealous/run-sequence) to get around what pertheusual@ mentions.
If only one for test grammar.
I am on Chrome, not working. It works on Safari. Pretty strange. It shows me the site, background and layout for exactly 2 seconds, without the content then it redirects. Like there's a bar running across the top of the page, and once the bar hits the end it redirects.
yea it was probably the other poster who posted regex my bad just as a general speed tip put the var m = new Regex(...) outside of the forloop for better speed ;) should be able to profile greasmonkey scripts.
Nope, no angular.
I don't think you're wrong -- the JS eco system feels like it's evolving at break-neck speed. You can almost be sure than anything "must have" in JS 1 year ago is considered passé by now.
[Image](http://imgs.xkcd.com/comics/regular_expressions.png) **Title:** Regular Expressions **Title-text:** Wait, forgot to escape a space. Wheeeeee[taptaptap]eeeeee. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/208#Explanation) **Stats:** This comic has been referenced 141 times, representing 0.1801% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cuki4hq)
Are you talking about short circuiting? Becase this has been a programming staple in nearly every language I've used including C.
Generally, when people say: &gt; Here is an example They don't want a solution that takes advantage of the simplifications of that particular example, but a more general solution. But I could be wrong, of course.
The easiest way (in my opinion) to learn about JavaScript objects and their prototypical inheritence is the watch (I guess you can read the papers afterwards) an explanation from the creators of the [Self language](http://www.selflanguage.org/) about Self because that's where JavaScript got it's "computational model". Prototypical inheritance [explained](https://www.youtube.com/watch?v=Ox5P7QyL774&amp;t=3m23s) by Randall Smith one of the creators of Self (the other is David Ungar). 
You don't have to worry about DOM manipulation in Polymer either, or in most frameworks that provide a robust template system. The difference with web components is that if you do have code that manipulates the DOM, such as framework code like React or Angular, or just some jQuery snippet, it'll work.
In Node's JS-land modules like `assert` etc. It was an optional additional parameter to a fairly commonly-used function, and the no-op wasn't an obvious one like an empty function but an if-statement written in the wrong place causing it to always evaluate `false`. I submitted a patch to fix it and add relevant tests that was accepted. I don't want to give more detail because I act like an asshole with this account and I've deluded myself into thinking people who know me in person can't already tell I'm an asshole. I realize that makes it harder to believe me.
what a fucking asshole... ;)
I was thinking of eventually having it track your usage, and learning what links you use more, and suggesting those first, but I literally just implemented the thing today, so might be a while yet.
well stop posting stupid shit every time!
Yeah, you're actually right ("short circuiting", that's the phrase, thanks!). However, I do still stand by my point that a ternary would be more appropriate in this context (and would not look "terrible" at all like the article/its author suggests).
This isn't correct. If you run this code, `bar.a` is equal to 41. Due to the nature of `Object.create()`, `bar.a` will inherit the value of `foo.a` until you manually set a value for `bar.a`
Ok. In any case, as others have suggested, it would be helpful to see the code in full (or at least all parts involved) to try to pinpoint the problem. Otherwise it's mostly guessing.
That was interesting, thanks for sharing these benchmarks. FYI the latest is https://jsperf.com/prototype-vs-closures/95
I find it easier to think of as the prototypical chain. When JS is asked to read a property of an object (eg. `console.log( created.a )`) it goes: - Does the object itself have a property with this name? If so, return it. - If not, go to the objects prototype (which is just another object). Does this prototype have a property with this name? If so, return it. - If not, go to the prototype's prototype (which is just another object). Repeat. - ... - If the property couldn't be found, return `undefined` The objects are in a sense layered. If the top object doesn't have a property, it checks down through the stack until it finds it (or returns `undefined` if it can't)
Thank you for the detailed answer !!!
I think we're agreeing with each other :) I just wanted to clary one point I made earlier: I think people will still be starting new projects with php, but it will only be teams which already have experience with php. So, for example, a team that have existing apps in Python and Clojure won't be switching to php.
&gt; But updates to original.b will still change original.b unless you also change created.b. You mean: But updates to original.b will still change created.b unless you also change created.b. ? 
you got a similar code but without new operator and its issues : 1) handling a reference to the prototype and not the constructor ; 2) constructor is optional and you can declare several different constructors if needed ; 3) no worries about forgetting the new keyword and mutating window ; 4) easier inheritance, no need for the B.prototype = new A() trick ; 5) factory functions can be composed contrary to constructors ; 6) getting rid of instanceof and the constructor property makes your code safer because these references can be easily compomised contrary to getPrototypeOf / isPrototypeOf
Not sure to follow you considering that classes use the prototype chain in the background, so all the problems you mentioned about inheritance hierarchies are the same. &gt; at least with classes, people are relatively aware that inheritance is bad okay so I guess the only problem here is people that do not learn lessons from their past experiences
Mutation - there you have source of the problems with writing frontend code.
"Desktop components"? 
Very nice lib, hate react.addons.update and we use it a lot, thnx!!
I cant quite follow. Can you explain?
This means that the actual selling point of NodeJS is not the async nature but the fact that you can share resources between requests (ie: a database connection) that don't need to be created on each request (as would happen with a php app). Is this correct? Regarding the CPU being idle in an async model when you have a lot of requests to a database that all happen to resolve at the same time that will require a lot of CPU so you can get into trouble more easily than in a "normal" environment. Right?
Well no, it's prototypal ~~inheritance~~ ~~delegation (thanks /u/MrBester)~~ inheritance. Maybe. I dunno. Thinking of it as a chain is a very common (and intuitive, given how it functions) way of understanding it. Thinking of it as a stack is another. Thinking of it as "overwriting" the parent property is another (but comes with a lot of special cases).
Yeah I got that, but arent arguments private aswell? Also I dont want log() to be private, thats why I return it in the first place.
Sure, but that argument you passed in needs to exist at the point in time where you call the log function, so it should be stored within your function object. The title said vs private. &gt; prototype methods vs private functions I wasn't saying "do it differently", I was saying, "that's not quite private"
Ah. Ok got your point now :] I think arguments are in the closure aswell. So u dont actually _have_ to store em.
Awesome. Nice performance win and it is pretty close to the chromatic.io version. If you want to flatten the jagged right edge, just lay this inside of a container with right-padding and an overflow-x:hidden, no?
yeah I'm going to consider some improvements to the DEMO and example jquery plugin to deal with crossbrowser scrollbar size and window width hell
Great point! I love conversations like this. Made me dig a little deeper and sharing is caring, so here's a couple interesting links just for reference. [http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/) and then a stackoverflow questioning the previous article. [http://stackoverflow.com/questions/18655275/javascript-closures-function-parameters](http://stackoverflow.com/questions/18655275/javascript-closures-function-parameters) 
On mobile, it's not really usable. 
That's insane. For the longest time I assumed when you write `var reference = original` that the reference is a new copy that could have no effect on the original. How then do you create a copy of an object that you can modify without it updating the original? 
You can very easily swap functions if you store them as methods in objects. example: http://repl.it/BE3E **but if you really** want to hack your way through it, then you can use the global *window* object example: http://repl.it/BE3N function firstFunction() { console.log("first"); } function secondFunction() { console.log("second"); } function swapFuncs(fn1, fn2) { var temp = window[fn1]; window[fn1] = window[fn2]; window[fn2] = temp; } firstFunction(); // prints 'first' swapFuncs('firstFunction', 'secondFunction'); firstFunction(); // prints 'second'
I like to use the [RequireJS text plugin](http://requirejs.org/docs/download.html#text). define(['text!my/template.html'], function(tmpl) { // ... }); If I'm forced to inline, I'll use newline escaped strings. var tmpl = '\ &lt;div&gt;\ &lt;p class=\'foo\'&gt;html&lt;/p&gt;\ &lt;/div&gt;\ '; There are a few real problems with newline escaped strings: - It's a little brittle. It works just fine, but it's easy to break. Having said that - you will get a straight up syntax error if you do happen to break it. This can happen if you add extra whitespace after the escaped newline, or add a blank line after an escaped newline. So... as long as you write tests, or even just evaluate the code at some point before committing it, it's fine. - You include all the indentation and you are, in fact, escaping the newlines. So the HTML turns into something like: `" &lt;div&gt; &lt;p&gt;html&lt;/p&gt; &lt;/div&gt; "`. I don't usually care about this because if I'm dynamically creating HTML with JavaScript, I'm never going to need to read the raw generated HTML - I'll probably just be inspecting the resulting DOM, which is nicely formatted for us. - You still have to remember to escape your quote character.
Well no, it's delegation, because there isn't such a thing as inheritance in JavaScript, merely references to other objects that can be checked for requested properties, normally through the "magic" binding of `[[Prototype]]` or explicitly setting.
Nasty way? JSON.parse(JSON.stringify(obj)) Requiring a library? _.clone(obj)
I wrote about all those image layout algorithms on my blog if you are interested: http://blog.vjeux.com/2012/image/image-layout-algorithm-google-plus.html
I've used this module for this [o-element-visibility](http://registry.origami.ft.com/components/o-element-visibility@1.0.1) [demo](http://build.origami.ft.com/files/o-element-visibility@1.0.1/demos/element-visibility.html) it doesn't take into account if an element is above the element you're tracking, you could do that using [document.elementFromPoint](https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint) but it'll probably be very intensive and slow down the page.
Your social life is pretty important to you, isn't it... 
 How about something like var obj = { function1: function () { console.log("first"); }, function2: function () { console.log("second"); }, swapFunction(fn1, fn2) { this.function1 = fn2; this.function2 = fn1; } }; obj.function1(); obj.function2(); obj.swapFunction(obj.function1, obj.function2); obj.function1(); obj.function2(); Technically you are modifying the original function inline in this case, but only because you are passing in the same functions that end up being set. EDIT: Typo. Oh and also, heres a [js fidd to the diddly.](http://jsfiddle.net/s7oxkzbb/2/) 
it is rather unconventional but it is possible to do using the global *window* object example: http://repl.it/BE31 function swapFuncs(fn1, fn2) { // get function names fn1 = fn1.toString().replace(/(function |\((.|\s)*)/g, ''); fn2 = fn2.toString().replace(/(function |\((.|\s)*)/g, ''); var temp = window[fn1]; window[fn1] = window[fn2]; window[fn2] = temp; } swapFuncs(firstFunction, secondFunction);
"firstFunction" actually, not "firsrFunction". Otherwise, yes, that's right, it only works if we're talking about OP's question. For other questions it does not work. I would think that's implied.
Make sure to use [DocumentFragments](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)
This is definitely more about the business side of things. * Pound pavement. Budget around ~30% of your time to prospecting for new work. * Model your deal pipeline. Understand how many contacts/warm leads/closed deals you have at a given time. * Find your niche. Are you a Node person? The react guru? C# wizard? Which one? All said, it's going to be really hard to match your current compensation package in the near term.
Even if you try to squeeze that function you are still going to block the UI for more than a few frames so most likely you will have to change how you insert the content. When I had this problems the 2 things I do is (you will have to do a combination: * Combine as many updates as possible Batching the updates. Manipulating the DOM is expensive and you want to combine as many operations as possible. DocumentFragments can help you with this. [This article about DocumentFragments from John Resig](http://ejohn.org/blog/dom-documentfragments/) although a bit old still applies (especially on mobile where the CPU is less powerful) * Second one is to not do all at the same time. The total time to do all the inserts might be longer but the user perceived performance will improve. [This article of Nicholas Zakas about Timed Array Processing](http://www.nczonline.net/blog/2009/08/11/timed-array-processing-in-javascript/) should put you in the right track (you will have to replace setTimeout with requestAnimationFrame).
Also .appendChild() is faster than .innerHTML Make sure to use append!
&gt; Furthermore, I agree with you that truly modeling UI means having hierarchy baked into MORE than just the rendering layer. This is interesting. Maybe it's obvious to you, but I wonder — what would it really *mean* to hierarchically structure controllers or models? Would e.g. a nested model hierarchy just transparently delegate ("proxy") to a nested model? Or would it be the fact that you actually explicitly *can* call upon descendant models? 
Okay, so I replaced it with the .forEach() code with Object.keys, and times are ranging from 420ms to 530 or so for all items with @. One outlier of 791 though.
I think it was quite succinct, although there were some concepts I've never heard of before. Complex topics are very hard to describe in a simple manner.
React does a lot more in terms of restricting. For example, all elements, attributes and events are white listed. I have not done this and honestly its a pro for me because twice now I have run into places where react simply couldn't support it until they updated their white lists. Tusk just uses createElement as you would normally (with some clever stuff to ensure the proper namespace for svg and mathml). Also events in tusk are case insensitive; I did this because JSX should act like html and things like this catch people off guard. Also when you set an attribute in tusk it never sets it on directly through the DOM and instead used setAttribute which is the same perf wise but ensures an api more symmetrical to html than JavaScript. For example there is no "htmlFor" or "className" in tusk, you just use real html attributes. The other reason react is large is because they do a ton of stuff that is simply not needed. They have custom implementations for every element, custom events not in w3c as well as component validation built in. Never understood why people think validation should come with the vdom when it is so easy to do externally and often more efficient and user friendly since you aren't forced into learning React.propTypes as well. As far as switching goes, its not all that difficult if you are already using top down immutable state. Tusk doesn't support state at the component level which is actually something I have added and removed from the library a couple times; it always feels out of place in a vdom and I constantly find better alternatives. Perhaps at some point before 1.0 it will again but we will see if myself or others need it. Currently when I need isolated state I am just attaching it to the real DOM on mount and removing it on dismount since it is usually for things like Google maps. You wouldn't replace immstruct however, as you can see in the example I am using it for top down state, however I'd recommend looking at baobab as well. In closing - there is no tusk ecosystem. Although - like react - it is extremely easy to make your own components for things like dragula and Google maps, you aren't going to find tusk-google-maps. This works perfect for me as all of the styles are done in house and I'm never satisfied with prebaked react components. After 1.0 my company may make a splash page for tusk and setup some little promotions to get it in the wild along with an isomorphic framework we have developed that I'm extremely excited about.
I don't really understand it entirely either, but it seemed to me the unique parts were in being able to compose parts together and especially *how* they were composed, i.e. using Observable event streams.
I'm currently building with require.js and babel (i.e. files written in es6, transpiled with babel and bundled with require.js). I am seriously looking at moving to webpack with babel, because it seems to have more options around non-javascript content. Babel adds a bit of overhead in the same way es5-shims add overhead. I would recommend for any non-trivial app, that you use babel-external-helpers so that babel doesn't repeat all of the various shims that it uses. Without benchmarking and assuming that 6to5 transpiled javascript has an overhead over raw es5, I would say that the developer productivity gained is more important in the short term and, in the long term, is somewhat more future-proof (because it's basically a race to full browser support for es6, and even Microsoft is in the game).
You can already grab the query params as JSON. req.query An object containing a property for each query string parameter in the route. If there is no query string, it is the empty object, {}. // GET /search?q=tobi+ferret req.query.q // =&gt; "tobi ferret" // GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse req.query.order // =&gt; "desc" req.query.shoe.color // =&gt; "blue" req.query.shoe.type // =&gt; "converse"
not to mention a few parsers support formats such as `user[name]=tom&amp;user[password]=tomiscool` and maps it into formats such as { user: { name: 'tom' password: 'tomiscool' } } actually becoming increasingly more common
thanks, it was my JS task taking too long I made a watch-css and watch-js task since I don't do that much JS nowadays.
Yes it does, but the compile time will be longer if you import the angular module in your js source files, what I do is just use html script tags to import angular and it works well.
The difference is that `Object.create` inherits state in addition to behavior (technically you could do this with classes, but nah), and `class` provides certain invariants that make it harder to screw up. Just the fact alone that `class` must be used in strict mode is a pretty big win, because that helps prevent a large class of security vulnerabilities. &gt; so all the problems you mentioned about inheritance hierarchies are the same. But yes, that is kind of the point. `Object.create` inherits almost all of the problems with classes (pun intended) and many more. &gt; okay so I guess the only problem here is people that do not learn lessons from their past experiences Eh. Most people know that class inheritance is a bad idea. But when it's just Objects Linking to Other Objects™? Time to inherit from everything. I don't blame the developers for getting pulled into this trap, because the people who push `Object.create` don't explain that it has these problems.
While I agree that information overload can be a UX problem, pruning information shouldn't be a crutch for poor performance. It is very easy to display a thousand data points without perceptible lag.
I do a decent amount of Node and JS (going on 8 months).. but I can't read those JS files. That makes me sad. And I'm just learning Generators, yield, and ES6 promises. Maybe too new. 
Rewrote your test [here](http://jsperf.com/for-loop-vs-foreach-boredom10000/2). Oddly enough, Using the for(i in helpList) was essentially the same as the regular for loop with Object.keys(). I would have expected it to be a fairly expensive operation. Guess not.
Cool, thanks for following-up!
I actually have two separate build tasks for JS in my gulp process: one for actual code that I'm touching (ie, browserify/babel), and one for libraries. Then I just import the libraries separately.
We're talking about dynamic styles. Unless you're talking about dynamically modifying a stylesheet or something, your solution is wrong.
I did this mainly because I'm testing with apidocjs and it sends the query string pattern this way by default. I honestly didn't think it was a bad pattern though. I'm not encouraging anything either way, I just made this middleware because I needed it and I thought I'd share in case someone else might need one too. Why not? Can you elaborate why this is "not a good pattern to use?" - The only thing that crosses my mind is that the parameters could be too long maybe? 
Not really a profiling question, but try hiding the calendar `display:none` before writing, and then show the calendar afterwards. This is a simple technique to avoid reflow.
This is also possible in browserify. https://github.com/babel/babelify
Oh I'm not denying the feasibility of the hack -- just questioning the necessity and the wisdom of having to resort to it.
Why not both? Browserify (or webpack) to bundle and add other features (like static file inlining), and Babel (i.e. babelify) as the source transpiler.
Large Entity errors.
I am the OP of the article, and the creator of the framework/CLI. It's a product that we've mostly been using internally at Platypi for consulting engagements. It is obvious that this article is a marketing piece (as are most posts). That being said, the message is not disingenuous. The product works well, and we (Platypi) will continue to support it. I'm sure you or others can come up with a number of reasons to put down the framework, and that's your right. We just want anyone who is interested to take a look. I don't know /u/comebackbrighter, he/she probably uses the framework. If you have any comments on anything in particular, you can direct them at me.
DocumentFragments will probably help but for profiling you can use new Date().getTime() (and then again, and subtract) or Date.now() may be slightly faster. Also don't forget to profile the network time. Also don't try to show 1000 appointments.
Insert the div into a virtual one then only insert the whole blob into one
pretty sure it uses the standard format &gt; $.ajax({url: "http://example.org/", data: {test: 1, foo: "bar"}}); E: XMLHttpRequest cannot load http://example.org/?test=1&amp;foo=bar. No 'Access-Control-Allow-Origin' header is present on the requested resource.
Yeah I'm not sure, all I know is apidocjs uses jquery to send ajax calls and it sends the data with json as one query string param. So the author of apidocjs likes it this way, I guess?
If you are ever worried about overhead or speed issues you can check out http://kpdecker.github.io/six-speed/ If you wanted to test some very specific piece of code you could fork that library and add your test. The way he has it laid out makes it easy to do so.
Eric's course doesn't even exist, so how can you claim his course is comprehensive?
&gt; Also consider that the PHP of today looks nothing like the PHP of 15 years ago. I will certainly agree with this. I was wondering why you chose to mention a PHP as old tech without specifying a version, unlike Java or Coldfusion or ASP (where it is implied, because modern ASP is ASP.net)?
I'm using babel to compile ES6 to ES5 for node and then browserify to compile the node code to a browser bundle. Babel translates the import/export syntax to CommonJS automatically.
Hmm I'm sending rather tiny entities then. 
using a module system(ES6 or cJS or AMD) always feels wrong with Angular 1.0, because Angular has it's own lame module system. It is better to use a module system rather than not, but you have to swap angular for something more modern. Best choices are IMHO React, Aurelia or Angular 2. Regarding performance issues-no I haven't experienced any. Only downside is that the generated ES5 code is a bit longer than what you would have writing straight in ES5. The gains greatly outweight this con.
Good point. That's just sloppy writing on my part: I presumed that the reader would simply look back 5 years and think "yeah, things *have* changed." That said, my advice above is really more cautionary in this area than a definitive hard fact. Choosing to stand by a programming language or computing platform, assuming that "this is here to stay for at least a decade or two" is very likely to be proven wrong. We all train with the intent to learn something and use it forever, but many find it disheartening and painful to embrace the notion that this cycle never ends. It's that "burying one's head in the sand" kind of behavior that I would like to encourage us all to avoid.
Actually JSON.parse(JSON.stringify(obj)) is not correct. This way you can only clone objects that have property values supported by the JSON spec. For example: var obj = {a: 1, b: function() { /*...*/ }}; var clone = JSON.parse(JSON.stringify(obj)); "clone" will now be "{a: 1}" because functions are removed during JSON.stringify. It gets even more complicated when the object has getters and setters or defined/configured properties (even for library provided solutions).
If every DOM manipulation is causing a reflow then that's your problem right there.
Um, sure they are. They are tiny lines, but they are there...
It's a monthly at a glance calendar.
You shouldn't be including third party (vendor) code in the same bundle as your app's code, as it reduces the efficiency of caching. Third party modules generally change less than your app's code, so they can be cached for longer if they're loaded separately. On the other hand, if you bundle everything together, any changes to your app's code will also mean the user needs to redownload all third party libraries too. I'd suggest using a CDN such as CDNJS or Jsdelivr for third party code, with a local fallback in case the CDN is down. With Webpack, you can use the "externals" plugin to reference external files from a CDN (eg. So `require('react')` uses the global `React`) 
"Element Query" already means something else. https://github.com/marcj/css-element-queries http://www.xanthir.com/b4VG0
Would it serve me well to make some novice programs in C++?
Meteor package manager never stood a chance.
If that's something that interests you, but if you're interested in Javascript development, it's pretty unnecessary. The only reason C++ is involved in this JS discussion is that the parser and runtime - that is, the code that actually reads any JS you and others have written, makes sense of it, and then executes it - is written in C++ (at least in the V8 engine). If your eventual goal is to be able to work on compilers yourself, or even to just be a polyglot, playing with C++ might be a good way to get started. But if you're focused on being a good JS engineer, you can definitely accomplish it without ever touching C++, imo. I've never written a line of C++ - but reading the code has helped me understand how the Javascript I write is handled and executed, which has allowed me to write better Javascript.
With ES6 (supported in Firefox, not yet in Chrome), [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign). But you have to be careful with nesting, as you do with `_.clone`: var a = { b: { c: 3 } }; var d = Object.assign({}, a); // or d = _.clone(a) d.b.c = 4; console.log(a.b.c); // prints 4 with both underscore clone and ES6 assignment
I'm aware, I mostly do so on side projects on development, on production none of this methods are used. Thanks for that tip about webpack and externals, I don't use it that much because browserify is easy to get going but webpack looks great if I want to go more specific.
I don't think you understand--your code won't run in a browser if you're just using Babel for modules.
Imagine recursion like Russian nesting dolls. Each recurse is one doll deeper. Itteration is like flipping pages of a book. For each page *flip* or while pages *flip*.
yes with some screen ratios and especially with various subsequent portrait images sometimes it shows them too big, I need to figure out why and when exactly this happens. I'm thinking it could be related on how the images are distributed on the linear partition: they are not presented in their optimal order I guess, but in the original array order. I will try to figure out a solution that do not involve changing the gallery order.
I fully support the notion that any good programmer should teach him/herself more than one (or even 2) programming languages to an intermediate/expert level. However, I'd also like to point out that in reality, when a language achieves a certain level of popularity/success, you will continue to find companies that are seeking that skill, because they based their business on that stack/skill set and are reluctant to switch to the shiny new, because that costs money. It's 2015 and a Fortran developer can still make a handsome income (perhaps even more than average), because those skill sets are higher in demand as the new generation of developers haven't got those skills (or even find value in learning that language). Now these developers aren't going to work on build new fancy products. They are just there to maintain an existing infrastructure. Some day those languages will disappear entirely, but popular programming languages that hit a critical mass tend to fade away slowly (saying that, PHP is by no means anywhere close to this camp. It has managed to stay relevant and evolve, despite a lot of the hate it gets). To add to that, there is also the notion that the new shiny is better because it is new, but what a lot of developers and our industry as a whole tend to forget is that more often than not, we are just re-inventing the wheel and many times the new wheel is desirable because it addresses a number of issues with the current wheel, but given time and enterprise architects, the new wheel begins to look like the old wheel and thus a new language is invented and the cycle repeats itself. Case in point, it is also dangerous to follow the herd for the sake of following the herd. The new wheel may look attractive today, but it may not gain enough momentum to stick as the herd flocks to the next shiny new wheel. Ruby on Rails is dangerously close to falling into this camp IMO (which would be a shame).
It's strange this uses User Agent sniffing rather than properly determining the polyfills to load. 
Sounds like a good use case for react.js
This is an older version of a [seed project for Angular/Gulp/Browserify](https://github.com/nick-brown/seedProject) I use. It needs some updating but it will show you how you can wire some of this stuff together.
Correct. I guess it would be bad for an example to use modifying the variable as it might appear to be the reason recursion works for someone new to the concept. "num-1" is how it should be done. Also I typically prepend underscores to aid in distinguishing variables as parameters. Just a style preference.
tldr; A closure is a reference declared in a higher scope than where it is accessed. Scope has nothing to do with `this`.
You have to change gallery order to get to a solution, I'm not sure how to prove this, but I'm sure one could give a counter example. Glad you know about it! Thanks :)
You might find FlyJS interesting :)
Do you need all 1000 for a single month? Why are you using JS to do this on the client? Can it be done on the server instead? 
I guess they wanted it to work as fast as possible without having to have another step of checking what polyfills to load. I can see this becoming a nightmare for them to maintain though. Useragent sniffing is fairly evil especially if they dont keep their mappings up to date. 
I attempted to try it out, but when I add `&lt;script src="https://cdn.jsdelivr.net/polyfills/polyfill.js"&gt;&lt;/script&gt;` to a page I just get "Internal server error". Not a good first impression :) 
Do you not have a server side language like PHP, .NET, or Java available to use? If so, then rendering it server-side would likely be much quicker. The problem with doing it all in JS is that you're relying on the client hardware. It takes 5-6 seconds *on your machine*. But developers tend to have nicer computers than the average person, which means it likely takes a little longer than your benchmarks. 
Looks like this is their database: https://github.com/polyfills/db/blob/master/lib/polyfills.json Polyfills should absolutely be doing feature checks. A site shouldn't totally fall apart if I change my user agent. It's not the 1990s any more, user-agent checks don't belong any more, except for very very rare cases (eg. Safari "supports" IndexedDB but it's so broken that libraries explicitly blacklist it and pretend it's not there)
Yes, the backend is .net. That's an interesting idea... I'll have to see if the extra html would be faster than generating it client side.
passes: 22 failures: 16 Doesn't work for Chrome on Android 
A closure is a function that accesses variables outside itself.
Currently reading this on my phone. Pardon my ignorance, but how does this work?
const someTransformation = (itemsToTransform) =&gt; flow( mapOverArray, firstElement, doThingToThatFirstElement, doYetAnotherThing )(itemsToTransform) This thing you have done here is slightly funny to me. You have removed a definition of a function created via a higher-order function and attached to it an arbitrary name which you then supply to the function itself. The thing you have un-wittingly undone here is called "point-free style" and it's part of the powers of expressiveness possible through function composition and partial application.
Do note that all the major browser are finally, actively working on tail call optimisation--meaning if the recursion is written so the last return is a call to itself, the system should be around as efficient as iteration. The inefficiency of recursion and possibility of a stack overflow is the main reason a lot of programmers shy away from recursion--although a lot of languages sport this optimisation and some, like Erlang, embrace it. Recursion's statelessness makes it more predictable and has less moving parts since there isn't an iterator.
This might help: http://www.uxebu.com/blog/2015/06/learn-ecmascript-6-in-a-different-way/
If you're using webpack with React, wouldn't you be using the [babel-loader](https://github.com/babel/babel-loader) already? It transforms both ES6 and JSX. (Edit: Some old tutorials will mention the old [JSX-loader](https://github.com/petehunt/jsx-loader). The author now recommends using the babel-loader instead.)
Cool idea! If you're gonna use BDD-style tests *please* follow BDD guidelines tho - e.g. using **3rd person singular present** in the spec description (first argument to `it()`). Bad (what some of these do, like this example from `Array.from()` koan): it('call `Array.from` with an array-like object', function() {}); Good (using 3rd person present singular): it('calls `Array.from` with an array-like object', function() {}); May seem nitpicky but the entire point of BDD is that you can read the spec definition in plain english to understand what behavior each spec tests. edit: i apparently don't know my verbings
https://iojs.org/api/
I really don't like articles like this: "Hey, I just learned about this feature! -- Here's absolutely no insight about it"
If a function is a box of code, the closure allows the box to have holes through which you can pull in stuff from outside the box.
So Babel doesn't convert ES6 modules to something ES5 can handle? I still need a separate module system for that?
Yup. It sucks, but Babel converts it into CommonJS by default, so you can bundle with Browserify or Webpack. [More info.](https://babeljs.io/docs/usage/modules/) Babel is going more towards just being a compiler, and not a next-gen JS polyfill. Not so smart, IMO.
Iteration is doing same steps over and over with slight differences each time. Like prepping letters for mailing. You take each letter, put it in an envelope, add addresses, add a stamp, seal it, and set it aside for the next. The process is the same for all the letters, but the letter content and the address changes for each one. Recursion is the same idea, just that you accomplish it a different way. You put the instructions to do the letter prep in a box, and then have one of the final steps make another box with the same instructions, just for the next letter. This means that each box prepares a letter AND will make another box that prepares another letter, and that box will make a box that prepares another letter, and so on until there are no more letters and no more boxes.
Depends what sort of resource you're looking for, there's an absolute abundance of tutorials, written or video, there's the official docs and then there's online courses like nodeschool, codeschool, and treehouse. Here's a few: * NodeSchool: http://nodeschool.io/ * YouTube: https://www.youtube.com/watch?v=FVdH9YcB3Dg * CodeSchool: https://www.codeschool.com/courses/real-time-web-with-node-js * Treehouse: http://teamtreehouse.com/library/nodejs-basics I think its hard to definitively say one way or another which is the best, it's what works best for you. **I, started with NodeSchool's "learnyounode"** as it was concise and from [a resource recommended on Node's official site](https://nodejs.org/documentation/tutorials/). I then used a combination of the docs, tutorials (written and/or video), and a few treehouse courses.
Let's go through that loop: First, `list = null` and `array` is something like `['a','b','c']`. So (pseudo-code): i is 2 do list = { value: array[i], rest: list} this means: given that i is 2, then array[i] is array[2] which is 'c', and list is null, so: we build { value: 'c', rest: null } and assign to list next cycle: i is 1 do list = { value: array[i], rest: list} this means: given that i is 1, then array[i] is array[1] which is 'b', and list is { value: 'c', rest: null }, so: we build { value: 'b', rest: { value: 'c', rest: null } } and assign to list next cycle: i is 0 do list = { value: array[i], rest: list} this means: given that i is 0, then array[i] is array[0] which is 'a', and list is { value: 'b', rest: { value: 'c', rest: null } }, so: we build { value: 'a', rest: { value: 'b', rest: { value: 'c', rest: null } } } and assign to list I guess the problem is that you're thinking: &gt; and rest points back to list But this is not so. It doesn't _point to list_. It takes the current value of list. Imagine a simpler example. Imagine we did this: var thing = "something"; thing = thing + " else"; Do you see that this means...? - First `thing`'s value is `"something"` - Create a new value which is _the current value of thing_ plus `" else"` - That value is `"something else"` - Now assign that to `thing`. Now `thing`'s value is `"something else"` The list example works the same.
You work at facebook or you're just judging that based on a tweet about babel?
If you're already familiar with Javascript and coding in general, just watch an introductory YouTube video like [this one](https://www.youtube.com/watch?v=GJmFG4ffJZU) and then learn as you go (using Stackoverflow/Official Documentation/YouTube?)
Then you read at the wrong places. JSPM is the only package manager currently prepared for HTTP2. Just by this feature, it is obvious it's popularity will only grow.
This is an awesome reply -- you hit the nail on the head. I have a much better understanding now than I did before. Thank you!
You totally could. I would probably build an error reporting library that try/caught the Cycle app and sent state logs home. I'm not sure how much overhead is involved, because I am effectively recording the observable streams.
seems like a solution looking for a problem.
You are writing java not javascript. You should post your question in r/java or r/learnprogramming. you are reading your name as an integer. 
This is known as future-proofing yourself. It's a good idea to get up to date with the latest technology. Keep in mind ECMAScript6 is still not even fully supported by the most recent versions of Google V8, server side, let alone, browsers like Firefox, Opera, Microsoft Edge, and so on. The features which are supported in modern browsers client-side doesn't mean they are in any way supported by older browsers. Therefore it is necessary client-side to compile or process your ECMAScript6 into 'regular' JavaScript. Server-side you're still not even going to be able to use all of these features. It's a good exercise and will open up your mind to possibilities still to come, unfortunately it wouldn't be wise to use in production grade applications still for a little while. That's my position at least, if you disagree I'm interested to know!
&gt; Therefore it is necessary client-side to compile or process your ECMAScript6 into 'regular' JavaScript [Which people are doing today](https://babeljs.io/users/)
&gt; In all seriousness, all programming languages are roughly the same. A mistake many people make is falling into the trap of thinking that there are vast differences between languages and that they take years to master. _Somebody's_ never tried to learn functional programming...
https://nodejs.org/api/ Read the documentation it is an easier read than you might think initially, its filled with examples.
Add `pre { tab-size: 4 }`. 8 (the default) looks ridiculous.
Forgot to mention that you'll also need `-moz-tab-size` for Firefox. IE/Edge doesn't support it yet.
It's always nice seeing new solutions to fizzbuzz :) As for why I didn't consider this: I don't think the task lends itself particularly nicely to recursion, at least not in the "part resembling the whole" sense of the word. I can't really think of any thought process that would end up with a recursive solution for fizzBuzz, unless of course you're just trying to think of new ways to solve it. Regardless, I had several alternate solutions that I ended up scratching for various reasons. Maybe I'll make some sort of appendix of them later on.
I just doubt that they have rewritten each constructor function into an ES6 class. Yeah, they have Babel and all that, but I doubt they will bother rewriting all old code. It is therefore highly misleading saying that all FB JS is ES6.
I dunno, the web seems to be working because it's starting to really standardize stuff. Or the differences are bubbling into a few core libraries. Look at what JQuery did -- providing a featured, uniform interface is why it got so big.
There is also an extra detail to notice. The loop executes from high to low. This maintains the order in a cleaver way. 
Node is just JavaScript on the command line. Like u/zayelion and u/simast pointed out read the API. To understand Node here is a list of things to learn: * JavaScript * The Node API * HTTP * writing for callback hell
Great idea, it's much better to learn that by writing even small pieces of code than reading examples. Small issues with UI, like grey buttons on grey background.
Enjoyed the post, but the font being used is terrible. It was a pain reading the paragraph text. 
You mean you wouldn't do it like [Enterprise Java](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)?
Thanks, that's good to know. Can I ask what device and browser you viewed it on? I'll reconsider the font - currently it's an open font called [Raleway](https://www.google.com/fonts/specimen/Raleway), but I don't insist on keeping it. Any suggestions?
Yeah, I think Browserify and webpack are currently very hot and would explain why they have a lot of attention atm. But I think with an eye to the future, JSPM is on the right track.
Looks neat but I don't quite understand everybody using the term 'vanilla-js' for libraries that clearly imitate the jQuery API. Just because it uses native DOM APIs under the covers doesn't make it 'vanilla-js', since both jQuery and Zepto defer to those APIs when available as well. Apparently 'vanilla-js' just means 'I wrote a library that doesn't use jQuery', even if it has the exact same API.
Anyone want to point in the right direction on what is going on with #6 Arrow functions? class LexicallyBound { getFunction() { return () =&gt; { return new LexicallyBound(); }; } getArgumentsFunction() { return function() {return arguments}; } } describe('arrow functions have lexical `this`, no dynamic `this`', () =&gt; { it('bound at definition time, use `=&gt;` ', function() { var bound = new LexicallyBound(); var fn = bound.getFunction(); assert.strictEqual(fn(), bound); }); I get what is happening to give me the AsserctionError of {} === {}, but don't understand this enough to figure out how to fix it.
At this case Vanilla means: 1. The most of the code of your app needs to be written on vanilla. Balalaika includes only the most common methods: on, off, extend, domReady, is. 2. You can easily extend it by yourself with jQuery-like methods and you need to know vanilla to make this done.
This is exactly why I'm against these 'as a service' projects. Even when built by larger corporations, there is no guarantee that they will be maintained and your project is now fucked if you were using it in production. This isn't directed towards you, but in general, relying on someone's side project as a service is really dangerous.
I did [this stupid thing](http://i.imgur.com/9IJHGZz.png) some time ago. I bring it with me to interviews just in case. Luckily so far none has ever asked me to write FizzBuzz in an interview. I don't know if I'd actually pull that _thing_ out if they asked, but I've done sillier things in interviews, so maybe.
I dont mean this negatively but is this a side project or something people could consider using in production? 
I'm using Baobab now and must say it is a very good fit for React!
I've never heard that setInterval() didn't keep time well but I have heard about it tripping up new programmers who aren't familiar with it. setInterval() runs on the interval despite the contained logic being done processing or not. setTimeout() can be called at the end of it's execution block but it will not run until it's timeout has expired.
Great feedback. Thank you for clarifying the distinction. I believe setInterval () may be a solution for me. Still working to understand the full syntax.
The title is confusing. This ISN'T a discussion on node.js nor server-side javascript. It IS about dynamic HTML back-end vs front-end which is interesting to me.
You should make an effort to remove unrelated inefficiencies: - `Object.keys(setB)` creates and populates an entire Array that you never need. Use a for-in loop instead, in both instances. - `forEach` makes you create a function and associated context that are unnecessary. Replace it with a for-in loop, or a for-of for Sets. - Reading `Array.prototype.length` or `Set.prototype.size` is an O(n) operation, so don't do it carelessly. Instead keep a counter as you iterate over the first set, and only read the second one's size.
This is a very relative area. OP, can you give us an example of something specific that should be handled in the UI that is currently handled by the backend?
It could be ever-so-slightly faster: you're doing three tests in the default case and you can implement it with only two. I agree that something like this is the best all-around solution, but you can't justify the claim that it "couldn't be faster." The agony of fizzbuzz is the very tightest, minimal, most efficient version really needs goto. :-)
Be aware that there is a large disparity between those that TALK about frameworks like you mentioned and those that USE those frameworks. Let's take Angular for example since it is the most popular js framework on earth. It is still only used, for the most part, on niche applications. Check out the site https://builtwith.angularjs.org/ and browse through the examples. Hardly anyone is building entire sites with it. That is because, compared to server side code, it is immature, insecure and device dependent. Offloading your app to the client works well when you are serving desktop browsers but is not so great for mobile users. Also, solutions can be poorly implemented regardless of the tier they were created for so just simma dah nah and maybe you will find a legit piece of your site that could benefit from using a client side MV* framework. Until then, know that server side really IS better for most functionality.
If it's something like "Likes" or "Retweets" then it requires the user to be logged into Facebook or Twitter, so there's no issue. It's handled automatically because it's bound to their account. If it's something like voting on a poll, you can possibly do IP-based tracking, although this poses a problem for people who share an internet connection (roommates, siblings, college campuses). This is also less secure for something like e-commerce because it's fairly easy to spoof an IP address. If this is your use case then just rely on the user to only do it in one browser. In my opinion, the downsides greatly outweigh the benefits.
Your TL;DR is too long :)
&gt; full-stack JavaScript That's not front-end development then is it :P Apart from criticizing you for that moot point can you explain what you mean when you say, "give up complexity to the front-end"?
I recently started using a variation of this problem for interviewing candidates at work. But instead of asking them to write it from scratch, I give them an intentionally broken implementation and ask them to debug it. That's proved very useful in eliminating candidates who cannot diagnose and fix bugs in existing code.
Can you post the code you have for it? Or direct me to somewhere where the standard code is featured?
standard code - http://www.gwt-ext.com/demo/#toolbarAndMenus
Thanks. I don't have anything in works currently. Was considering some hypothetical scenarios and this problem I couldn't solve it.
Except you can't test that at all because it's in a console.log
&gt; Gluing "Fizz" and "Buzz" together may not work for a different locale. He specifically addressed that with this line. So you do need 3 if you think this might be a future requirement.
Good on you. Writing code from scratch is always pretty terrible IMO for an interview. Being able to debug is a skill that MOST developers seem to not have, regardless of how well they can write code. Hell, I spend half of my day code reviewing and helping other people find bugs. It's a skill that's absolutely required in even to write great code, yet interviewers love to ask about ridiculous minutiae that you may have to write once and never look at again.
GMail and Facebook are exceptions that prove the rule. They are each showcases for their respective frameworks, React and Angular. They are basically required to be built on those frameworks. 
We ask a FizzBuzz-type question during interviews. As long as you could spit this out in under a minute, I would be amused by it. FizzBuzz is boring for the askers too.
Courtesy of [elevator.js](https://github.com/tholman/elevator.js) :)
My suggestion is to pretty much always use a forEach, unless you need to do something fancy, that prevents you from doing so. It's less error prone given you do not have to rely on working with an index. Since you can access the item directly, it also can lead to less refactoring of code, since you do not have a ton of explicit references to what you are looping. And lastly, it takes a function, which makes it nice to isolate scope, you can create temporary variables inside, without having to worry as much about hoisting. I tend to use them sparingly, but it's also worth looking at map and reduce as well. Oh and filter is priceless.
**for loop**: for when you have a start and end index and you want to operate more on indexes than individual elements **for...in**: Never use this. **for...of**: Use when iterating over items of a collection (arrays, objects, trees, etc) when the collection implements the iterable protocol (true for built-ins like Array, not necessarily true for libraries). **forEach**: Used only for its side effects, and therefore I'd say never use it. Map, Filter, etc. are perfectly acceptable though and most useful in a more functional codebase.
You are right! Well there you go OP, not even Google uses Angular on anything big even though they created the framework. It turns out that Google does rely heavily on Closure. https://github.com/google/closure-library
Its probably because I'm pretty new at node development, but when I do: object.pipe(response); It does nothing. I'm using [mongoose-gridstore](https://www.npmjs.com/package/mongoose-gridstore) to add GridFS to my mongoose schema. The object itself looks like this. { name: "some name", attachments: { data: "Base64 mp3 data here" }, slideshow: [ "slideshow data here" ] ) Is there something I'm missing to stream to the http response?
Is that a joke repo? Please let it be a joke repo... EDIT: phew, read the readme.
Guess you are technically correct. Does anyone have anything to say that is relevant to poor OPs question?
&gt; front-end development is still being treated like a necessary evil by back-end developers Most places I have worked then to be Java shops. Java devs seem to have these expectations of JS: * JS is too slow. JavaScript is actually (now) only half as fast as Java when written well. For most tasks that difference in speed is largely irrelevant and unnoticed. * JS can't handle that. There are some tasks that absolutely should not be performed in JS, but they are typically things that would never be needed in any sort of web application anyway. * Fear. I have encountered one environment where a lot of the devs were envious of JS work like they are expiring and about to be eliminated. * Ignorance. It is pretty common for Java devs to be pushed into JavaScript when they are formally educated in the former and absolutely ignorant of the latter. This means they attempt to write Java in JavaScript (since they really do look similar) and then blame the language when their Java like code conventions are horrible and challenging to maintain. &gt; Is there any way they (those people, the back-enders) can be won over? Education. In Java everything is a class (at least until Java 8 where most things could become a lambda expression). Classes are best avoided in JS until they have absolutely mastered the language, at which point they would have little or no need to use classes anyways (or OOP for that matter). Web technologies (almost all of them) are based upon the concept of lexical scope at their core. Once they learn to write their code to that model (at least those that actually do understand it) will completely come around (and sometimes even want to give up Java for JavaScript).
I'd argue it's more than a technicality, but I can be an overly analytical prick. I responded already with a high level comment though. Dude needs to tell them what's up. 
All nitpicking aside, "if it can be done on the server why would you want to do it in JavaScript?" is a legitimate question. Any choice you make has trade-offs. You have to know the advantages and disadvantages of each choice. It depends on your user demographics, your functional requirements and a hundred other factors. The next time you get asked that question OP, have an answer.
I still find it odd that tail call optimization made it normal to say "recusion" and "optimized" in the same sentence.
It's not more than a technicality because Google practically owns Angular and is the public face for it. Your high level comment is not helpful because OP is clearly not an expert. You can't have someone who calls themselves a Frontend Dev making architectural decisions.
Did the question involve writing an automated test suite?
If you are using global namespaces then you are probably doing something wrong. While it was something commonly done in legacy JavaScript code bases, it is something you want to avoid in any modern JavaScript application. Instead, you should be using a JavaScript module system (either CommonJS/Node.js-style or ES6) and that will solve the problem for you. You will typically need to use a JavaScript module bundler to generate a JavaScript file that can then be loaded in the browser.
&gt;how we educate the old-school php crowd to give up (at least some) complexity to the front-end. What are you advocating for? I think that moving complexity (logic? I don't know what you mean by complexity and typically in applications you're trying to eliminate complexity) to the front end is inadvisable. Ideally you'll have all your business logic in one place, not sprinkled across boundaries. People (businesses, engineering organizations, etc) prefer to have logic on the back-end for two reasons: control and portability. When you control the environment, you can optimize for your team. You can choose php or ruby or golang or whatever, and you can choose the hardware it runs on. The other reason, the main reason in 2015, is portability. Moving your logic out of the server and into the front end means you have to duplicate that logic for every front end you write. Right now, there are all sorts of clients we have to support: desktop web, mobile web, ios, android, as well as anyone who wants to consume your API. All the logic that you move over to the front end now has to be moved over to every front end. Which means you're going to have the same logic duplicated slightly different in JavaScript, Objective-C and Java. So it makes sense to keep business logic on the back-end. I love JavaScript, but have you tried to do anything relating to math or time with it on the front-end? It doesn't have a proper integer type. The tools for back-end languages are much more mature and consistent and widespread. It's a much safer bet from a business perspective to keep your business tech there. If I was starting a business, I wouldn't use JavaScript for anything critical, because I've been using it to make front-ends for a decade. So ideally, the front end logic exists to take care of the interaction between the user and the business logic. Any logic in JS should be directly related to showing data to the user, or translating input from the user into a format the back-end can understand. Don't knock that; first, it's fucking hard to get right, and second the interaction with the user can make or break an experience, and a good front end engineer who understands all of this stuff can easily be worth two back-end engineers. &gt;TL;DR: front-end development is still being treated like a necessary evil by back-end developers, which results in poor implemented solutions that causes more problems down the road. Is there any way they (those people, the back-enders) can be won over? Make everyone write to a spec. I.e. write a bunch of unit tests at the boundaries of the systems and make the output from the back-end conform to a well-defined spec that is validated with running code (i.e. tests). Then make sure the JavaScript correctly consumes the well-defined spec. Then do the same thing but going the other way with JS as the data provider.
I give them this code along with a brief written description of the fizzbuzz problem. // Broken Code for (var i = 0; i &lt; 100; i++) { var n = i; n = (i % 3 === 0) ? "Fizz" : i; n += (i % 5 == 0) ? "Buzz" : ""; console.log(n); } For the candidates that decide to keep the structure of the code as-is, there's 3 mistakes that must be fixed to make it work properly, and 2 extra issues that should be cleaned up. However, I most often find that the candidates will look at that for a while, struggle to find all 3 critical issues and then just rewrite it in a cleaner way that works. So far only one candidate has completely failed to get it working at all.
I would have said ES6 + Babel, but there are some caveats if you go below IE9. Use TypeScript.
My favorite is this one. It's extremely clear what the code will do, and it's easily editable. I've also include a configurable one, because I didn't see it yet! for (let i = 1; i &lt;= 100; i += 1) { let fizzbuzz = ""; if (i % 3 === 0) fizzbuzz += "Fizz"; if (i % 5 === 0) fizzbuzz += "Buzz"; if (fizzbuzz) console.log(fizzbuzz) else console.log(i); } // and the configurable version function fizzlemybuzzer(count, buzzers) { for (let i = 1; i &lt;= count; i += 1) { let fizzbuzz = ""; for (buzzword in buzzers) { if (i % buzzers[buzzword] === 0) fizzbuzz += buzzword; } if (fizzbuzz) console.log(fizzbuzz); else console.log(i); } } You can call fizzlemybuzzer like this fizzlemybuzzer(100, { "Fizz": 3, "Buzz": 5, "Flozz", 7 });
Awesome, thanks
I personally update under the following circumstances - latest update patches a security flaw - latest update squashes an annoying bug - current version of library will no longer be maintained - newer version has a performance upgrade, and as your product starts getting competitors, performance will definitely keep you ahead of the game - newer version has a killer feature (as you said) - newer version makes it easier to work with - the organization that you're working for has a policy to keep libraries updated to the latest stable release I try to limit my library use to those that release under the semver versioning scheme. I'm also very conservative about updates, as well. Under the semver versioning scheme, I only update on minor releases, that is, say the current library is v3.3.1, and the next version is 3.3.2, I would update as soon as possible. But, for updates that go from v3.3.1 to v3.4.0 or even v3.3.1 to v4.0.0, I'd be more cautious. Edit: added a new bullet point and some clarification. Edit 2: spelling Edit 3: more clarification
Just wait until the day before release, then update everything and be sure to check it into master appending whatever the last commit was. /s (No, don't do that...)
&lt;=&gt;
The requirement was to output 3 distinct strings. Just because you see a pattern there doesn't mean that there actually is one. http://science.nasa.gov/media/medialibrary/2001/08/28/ast24may_1_resources/pio_med.gif This looks like a face to us, but it really isn't. "car", "pet", "carpet". Could be concat. 64, 128, 192. Could be a bitmask. 0.5, 10, 5. Could be multiplication. Thing is, it could be just a coincidence as well. We see patterns everywhere because this was a desirable trait. If you don't know what the values mean, you can't tell if there really is a pattern.
Clearly I've been looking at the wrong tutorials, then. I gave both a try and gave up in frustration. I'll have to give them another go
I'd argue that React isn't that bad because server-side rendering is entirely opt-in. To me it's not really "blurred" because of that. It seems to me like the ability to render server-side is more a nice side-effect of the state/props pure rendering style. We're avoiding isomorphic code now, but it is nice to know that it'd be trivial to render some top-level UI server-side to a provide better user experience at initial page load. I'm very glad it's not a requirement of React, though, definitely.
In general, the way the browser handles it is usually based on the HTTP headers; for instance, `Content-Type` is usually something like `application/octet-stream`. For seekable streaming, you'll have to do quite a bit more, like implementing `HTTP/1.1 206 Partial Content` along with the `Accept-Ranges`, `Content-Range`, `Content-Length`, etc. headers.
Kind of crazy I never knew that splice automatically places it inside a newly created array, I kind of just always assumed it worked that way because it was being taken from an _already_ existing array. Thinking about it that makes sense because that's how `Array.prototype.slice.call(arguments)` works considering it's only an array-_like_ object :)
In this case you can just use `Array.prototype.map` to create a new array of promises, and then use `Promise.all` on that array. Here's an example of what that might look like: listProjects().then(projects =&gt; { return Promise.all(projects.map(project =&gt; listVersions(project))); })
isscammer isn't defined where you're using it. I don't know exactly what you're trying to do here, but it looks like maybe your lower if block should be inside the callback function you defined above. As it is, the flow is: - call SteamRepAPI to find out if steamID is a scammer, start waiting for result - check if (isscammer == true) [isscammer not defined here] - callback function called, sets isscammer
It'll depend a lot on your background. I used TypeScript for the first time this year when I moved a small (~1kloc) NodeJS app to TypeScript. It took a couple days, although I was using minimal TypeScript features. But I was coming to it with a lot of experience with strongly typed languages with classical inheritance so there weren't any new ideas. D3 is a strange library. It has a very specific way of thinking about things that not everyone will find natural (it's never felt quite right for me, though I've used it heavily for years). But the basics are pretty simple and should be learnable quickly if you know JS.
Not necessarily. Node will run JS, but if you are writing something that you want to run in the browser, it is probably best to develop in the browser. I would look into [browserify](http://browserify.org/) and set it up to watch your files. This will trigger an auto rebuild and you'll just need to refresh the page. There are a lot of ways to bundle your code and a lot of different module systems, some of which provide different styles/capabilities than browserify. But this will probably be the easiest to work with at first.
&gt; Reading Array.prototype.length or Set.prototype.size is an O(n) operation, so don't do it carelessly. Instead keep a counter as you iterate over the first set, and only read the second one's size. Not the OP, but wow, I had no idea. Is there a source for this? Does this vary between v8 and, say, SpiderMonkey? Seems simple enough to just cache the length or size as the collection grows or shrinks.
Your welcome, and that's because it only causes 1 reflow. :)
Does [this](http://bost.ocks.org/mike/join/) make sense to you? If yes, D3 will be straightforwardish. If not, it'll be some work.
There's somewhat of a steep learning curve with D3. Actually, now that I think about it, TypeScript might make it easier to understand what's available to you when using D3 selections (if you're using an IDE that can offer TypeScript suggestions or atom-typescript). Get the [d3.d.ts typescript definition](https://github.com/borisyankov/DefinitelyTyped/blob/master/d3/d3.d.ts) to get started.
I do upgrades every so often (once a month). I'm under the assumption that there are too many libraries that change too often, and mostly everyone is pretty good at keeping up to date so they satisfy the user base. Some of the tools that make it easy: [Semver flexible ranges](https://nodesource.com/blog/semver-tilde-and-caret) - ~3.3.1 patch upgrades - \^3.3.1 minor upgrades Minor upgrades I usually use for `dependencies`; patch upgrades I usually use for `devDependencies`. This is so my user's don't encounter a shit ton of conflicts if I don't publish for a while (mainly bower, but soon to be npm3 with flat structure). [npm-check-updates](https://www.npmjs.com/package/npm-check-updates) is a nice little tool to see if you have the latest version of npm packages.
I think /u/every_post_is_stupid is wrong regarding this. If accessing `.length` property of array is O(n) then its performance should have the same growth rate as plain iteration over array. Which is easy to test: function timeIt(length) { var array = new Array(length); console.time('Iterating through array x' + length); var sum = 0, sum1; for (var i = 0; i &lt; length; ++i) { sum += 1; } console.timeEnd('Iterating through array x' + length) console.time('Accessing array.length x' + length); sum1 = array.length; console.timeEnd('Accessing array.length x' + length); console.log(sum, sum1); } Running this program with increasing `length` shows that accessing `array.length` has constant time, regardless of how big is the array. You can edit code here: http://jsbin.com/kidipodolu/1/edit?js and explore terminal output here: http://output.jsbin.com/kidipodolu/1 Both Firefox and Chrome show O(1) for the length property. Same holds true for the `size` of Set ([Code](http://jsbin.com/wupiqanuca/1/edit?js), [Output](http://output.jsbin.com/wupiqanuca/1)) Regarding `for in` vs `Object.keys()` - I tried both and found that `Object.keys()` is faster: Compute jaccard similarity with Set x 1,199 ops/sec ±2.25% (89 runs sampled) Compute jaccard similarity with objects (Object.keys()) x 662 ops/sec ±1.66% (88 runs sampled) Compute jaccard similarity with objects (for in) x 609 ops/sec ±1.77% (85 runs sampled)
X-Post referenced from /r/aureliajs by /u/pwkad [Creating Multipage Apps with Aurelia](https://www.reddit.com/r/aureliajs/comments/3j6q6y/creating_multipage_apps_with_aurelia/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
Promise.map is non-standard though.
React *can* be used on both the front- and back-end, but it doesn't have to be. React also isn't really a full-stack framework, per se, but a view layer that plays nicely with other frameworks (backbone, flux, etc.). I don't have much experience with ember, but I think that server-side rendering is [a new feature under active development](https://github.com/tildeio/ember-cli-fastboot), and isn't quite ready for production yet.
Besides promise interoperability, what other reason is there to care about the standard? Most, if not all of the "syntax sugar" methods from bluebird don't care if the underlying promises came from bluebird or not, so I don't either.
Well for one it is monkey patching the global Promise object. It makes it harder to find usages in a larger a project if you were to remove it. Monkey patching was a pain in the ass when moving from Date.js to Moment. Have fun searching a large codebase for generic functions like "map" and such.
Your post makes very little sense, and i'm not sure who's upvoting it.
Aliasing it as `banana` doesn't really solve the problem, and i'm not going to attempt to explain why since i'd expect someone in an advanced JS subreddit to know
I thought "the problem" is patching prototypes. You made up another problem from your high pedestal?
yea its not intended for returning 1 item, if you just want one item you use `item.shift()` or `item[0]`. splice is for multiple items so it returns an array.
Here is a [description](http://speakingjs.com/es5/ch18.html#Array.prototype.push) of what `splice()` does: Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ···) Starting at `start`, removes `deleteCount` elements and inserts the elements given. In other words, you are replacing the `deleteCount` elements at position `start` with `elem1`, `elem2`, and so on. The method returns the elements that have been removed: &gt; var arr = [ 'a', 'b', 'c', 'd' ]; &gt; arr.splice(1, 2, 'X'); [ 'b', 'c' ] &gt; arr [ 'a', 'X', 'd' ] If the string `'b'` were an Array, you’d get a result similar to yours.
&gt; How do I reduce mp3 size in the browser before posting to the server? At a guess, JSMad and [libmp3lame-js](https://github.com/akrennmair/libmp3lame-js)
This isn't java
Messy, hard to read, short, and most likely slow ES6 implentation: FizzBuzz = (n,s) =&gt; { '.'.repeat(99).split('').map((q,w)=&gt;{i=w+1;console.log(i%n[2]===0?s[2]:(i%n[1]===0?s[1]:(i%n[0]===0?s[0]:'')))}) } Call it with: FizzBuzz([3,5,15],['Fizz','Buzz','FizzBuzz']) 
Yep, [Section 23.2.3.9 of the ECMAScript spec](http://www.ecma-international.org/ecma-262/6.0/#sec-get-set.prototype.size). The section for `Array.prototype.length` is less clearly O(n), but it is defined in relation to "all properties", not some cached internal value. This used to be a bigger deal than it is now. Nowadays JS engines have become sophisticated to the point that they will generally detect that the result will not change over the course of the iteration and cache it for you. It's gone from being necessary for a performant loop (which is why you often see `for (i = 0, len = arr.length; i &lt; len; i++)` in old JS) to being the same or faster without manual caching. That being said, I don't like to count on compiler magic. It won't work in less sophisticated engines, and it won't work in edge cases: last I checked even V8 didn't optimize away the penalty for `arguments.length`.
See my other reply. It's difficult to write low-level benchmarks because the compiler rewrites your code to make it faster. Instead, plug the new code into your actual function then benchmark that in every browser. It may still be the same, I don't know the limits to what browsers can figure out nowadays (and it's constantly improving). I'd be interested in seeing the code you used to test `Object.keys` vs for-in.
Yep. Tail call optimization is throwing out the current stack frame when we enter the next one, but you can't do that if you're going to need the current one again.
Could you do it anyway please?
This stuff is really old mate, why post now?
Yes, it hasn't been maintained in years, and I would really advice against using it. For modern browsers there is no need anyway, their native support is quite good and consistent now.
FSAs and FSTs are used in a variety of engineering applications. One of the most prevalent uses is as part of Natural Language Processing systems, see: http://www.cs.colorado.edu/~martin/slp.html (chapter 2) http://www.nltk.org/index.html http://web.stanford.edu/~laurik/fsmbook/home.html https://code.google.com/p/foma/ 
I always thought this way until I was roaming in Sweden and had 2kb/s from the nearest cell-tower. Then you realise every kb counts.
Consider this markup" &lt;div style="z-index:1; position: relative"&gt; &lt;div style="z-index:100; position: relative"&gt; &lt;/div&gt; &lt;/div&gt; Will Intro.js be able to highlight the inner `&lt;div&gt;`? EDIT: forgot about `position: relative` 
Great list dude
I reached out to the service provider first. There was a technical help forum where many other users had the same complaint. They could leverage the external javascript and successfully retrieve artist/song information for the first track, but that data was cached and never refreshed. The moderator of the forum left a short reply suggesting to "use AJAX", but provided no example.
Why does no one use switch statements for this except me?
What is the model solution you have in mind? Something like this? Or is there a way I am missing in which you can achieve it without a conditional in the log statement? for (var i = 1; i &lt;= 100; i++) { var n = (i % 3 === 0) ? "Fizz" : ""; n += (i % 5 === 0) ? "Buzz" : ""; console.log(n ? n : i); } 
This is an older version of intro.js but here is a fiddle: http://jsfiddle.net/xtf2qr3z/3/
Sorry, forgot about `position: relative`. It works: http://jsfiddle.net/xtf2qr3z/4/, but only by changing the `z-index` of parent to `auto`. This may not be acceptable in some cases. 
Note stack frames are indeed destroyed in JavaScript as well. Variables in closures are just allocated on the heap, not on the stack.
Short answer: No, because event listeners don't take parameters other than the event (and a couple others that aren't important for now). Your best bet is to read the values from the elements with ids `q` and `r` inside `merge()`
In the [browser](http://jsfiddle.net/9maa7pnj) it does.
Yes? I think I understand what you're asking. Change the passed parameters to onkeydown="merge(document.getElementById('q').value,document.getElementById('r').value)" *also see /u/mkwong's shorter version! And they're default type is string, so you want to change your function to handle that. Like this: function merge(q, r) { var q = Number(q); var r = Number(r); var total = q + r; alert(total); } That what you're looking for?
I'll have to think about this one for a bit but I really do appreciate the input; I've gone ahead and moved the connections object outside of the export -- great call, there :)
It does not monkey patch anything. It *replaces* the global, which you can restore with Promise.noConflict().
disclosure: self submission
Fascinating. Thank you!!
I'd probably just use Google Forms for this unless you had a lot of time. (In my opinion,) the hardest part of doing this yourself would probably be the back end code to handle writing the file to your drive/database, handling all the security issues that would result in someone writing files on your system and setting up all the server stuff.
How's the responsive/mobile support when you need to reveal elements below the fold then scroll to the next item which is now either above or below the fold, etc. Has it been built/tested for responsive support?
exactly. :)
&gt; Logos are added by company representatives. These companies may or may not be using Babel on their main web properties, but they're definitely using it somewhere in their organizations :)
I'm gonna see if I can use GF to download a txt of all the info, otherwize it will be rough to get it all into matlab without doing this job manually 
&gt; It’s because we have this foolish notion that a marketing buzzword will somehow bring some legitimacy to whatever we’re interested in. Well it won't bring legitimacy, but it most certainly will bring newbies in doves replicating your use of the word in any project they start, to try to appear smart.
I used [doT.js](http://olado.github.io/doT/index.html) for my degree project. It compiles the templates, so, instead than string replace, the use of the template is simply string concatenation. Look it up. The problem with generating your dynamic html, is that in real time applications, you have a lot of filler html, which is set only to add little small gimmicks on the page. For example, if you use a grid system, you'd have to create everytime the container than the row than the column, and only then the div container for your widget. This makes creating dynamic html extremely unpractical, unless you can design the website around using as little html as possible. 
I suspect it's to do with the fact that jQuery is running in noConflict mode. Wrap the code in your locator.js file in a self-executing function where the parameter name is $ and pass in jQuery and your code should work again. (function ($) { // Your code here. }(jQuery));
&gt;Turning our attention back to this bullshit “isomorphic JS”: having two copies of the exact same JS code running in two respectively different environments just doesn’t fit the notion of isomorphism. Sorry. You try to be nice about it, but there's really no good way to point out that people trying to use "Isomorphic" this way are revealing themselves to be ignorant, and I'm trying to say that as neutrally as possible while also knowing it can't come across as anything but insulting and elitist. Not knowing a thing, not having learned a concept, isn't something to skewer people over. But if you don't know what isomorphism means, you can't experience the awful collision in meaning that would have prevented this. Argue linguistic prescriptivism vs descriptivism all you want, but when mathematics conflicts with temporary web application buzz, don't expect the fad to win. 
First comment over there: "If a framework dies alone in the woods does anyone care?"
Javascript is a frontend language. That means it lives and dies in the browser and doesn't save data from one page refresh to the next. If you're wanting to have people access your webpage from any internet connected computer, have them interact with a form and then hit submit to send you the data, then you're going to need to host the page on a server and use a backend language (like PHP) to handle the data. That being said, there are some *hacks* you can employ. You can use something like CodePen or JSFiddle to host a page. You can create a form that can throw it's data in to an email and send the email to you (but that requires users to have an email client installed on their machine). Or you could probably figure out a way to do it with web based mail like Gmail (potentially eliminating the need for an email program installed on the user's machine). I think there are also some "hacky" ways to do it using Google Drive APIs...
 I was simply talking about generating html code. No matter if it's generated at initialization, or to modify things on the page. Imho templates are superior to generating the html code using javascipt element functions, because of the html fillers. I think that your javascript code should only handle data, not design things like adding images to make your containers pretty. I'm not talking about your particular app, i'm talking about bussiness apps. For your app, generating dynamic html could fit better than html, but when working for a client, I'd use templates almost every time. Also, the doT templates has linear scaling. I don't think there's a better system to create templates than the system doT uses. It's a brilliant piece of software. No other templating system I used could even compare with it's speed. 
You are being pedantic here. The API was still monkey patched, even if the implementation uses a new reference. It still has all the problems that come along with it, with the exception that you can restore the original reference. The [readme](https://github.com/petkaantonov/bluebird#browsers) and all the API docs use Promise. I would expect most of the users are going to use it that way, just like the user I originally replied to.
last time i used google forms it made an excel spreadsheet to hold all the data. you could save that and then export it as a csv file (basically just text).
We dont pass it. We declare argument there. You could replace both *res* with any valid variable name. .get function is the one which passes two arguments to that function.
The variable "res" in that example is the *response* object (not result) representing the server response. The "send" method (I'm assuming this is express) sends a response body to the client. There can be other methods on the response object, e.g. for manipulating the response headers or sending cookies. You seem horribly confused. I think /r/LearnJavascript is a better place for you to ask questions like this one in the future. Also consult the manual of whatever you're working with (e.g. the API docs of express in this case, I presume). And last but not least: don't put opening curly braces on a separate line. JS is one of the few languages where that really is objectively wrong and can lead to nasty surprises (especially for beginners like you).
React pretty much lets you write JS without "templates" (the JSX syntax that looks like X/HTML is entirely optional and just syntactic sugar). The reason most people prefer not manually constructing DOM subtrees in pure JS is that it's simply not a very maintainable and intuitive way to do it in non-trivial projects. Except for template languages than jade (which gets rid of the redundancy of closing tags and angle brackets by using whitespace-aware indentation) it doesn't get much more straightforward than HTML. Plus, when you look at the final product, you're looking at HTML again (or a DOM inspector that closely resembles HTML).
Thanks for this dude. Very detailed.
Post moved, new features and bugfixes so please check it out and vote in the NEW PLACE! Thanks :) https://www.reddit.com/r/WebGames/comments/3j9gqq/badcity_multiplayer_3d_gta_in_javascript_first/
Post moved, new features and bugfixes so please check it out and vote in the NEW PLACE! Thanks :) Mouse in Firefox also fixed so if you'd like you to test again that would be great https://www.reddit.com/r/WebGames/comments/3j9gqq/badcity_multiplayer_3d_gta_in_javascript_first/
Post moved, new features and bugfixes so please check it out and vote in the NEW PLACE! Thanks :) https://www.reddit.com/r/WebGames/comments/3j9gqq/badcity_multiplayer_3d_gta_in_javascript_first/
Post moved, new features and bugfixes so please check it out and vote in the NEW PLACE! Thanks :) https://www.reddit.com/r/WebGames/comments/3j9gqq/badcity_multiplayer_3d_gta_in_javascript_first/
&gt;that's really all that matters. :/ Is it really that wrong to struggle for a better term? I guess my reaction is _no_, it's not all that matters. People _aren't_ put on the same page by it. Pretentious phrasing alert, but: I just can't stomach this resigned acceptance of mediocrity. No one's contesting the need for a term. You're pointing to the fact that we're bikeshedding, but getify already pointed that out. 
I hope so.
As far as I can tell, your code is susceptible to SQL injection, since you're taking (unverified) user input ($week), and just putting it into your $sql query, and sending it off to your database to be executed. Someone who crafts some malicious input might be able to do stuff like delete everything in your database or worse.
You can definitely pass more than one variable in the url like you're attempting. When you're calling "showWeek(this.value)", in both case you're only passing one var, and by the definition of "showWeek", it's q. Try it like this, note how I'm passing pass vars in both cases (you don't really have to pass both in the first case, as the 2nd var would implicitly be undefined): Week Number: &lt;input type="text" name="q" onchange="showWeek(this.value, undefined)"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Enter Date: &lt;input type="text" name="r" onchange="showWeek(undefined, this.value)"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
Wait, Dojo still is a thing? http://i.lvme.me/arjhcm9.jpg
I think IBM is the reason Dojo is still around, they seem to use it in everything.
You can attach event handlers to the response stream so you know when all the data has been sent. Is that what you mean?
Calling jQuery or the Dojo Toolkit a framework shows you you don't understand either of them. 
They still use SGML too. I'm not kidding.
Yup, I know. But like other comments I'm thinking about the what if scenarios. 
I concede your extensive-er experience then. Nevertheless, if you find objectionable the idea that you should share a sense of camaraderie with your co-workers, then I don't want to work with or hire you.
You're so smart. 
What's stopping you from using vanilla JS? The two aren't mutually exclusive. 
Interview some junior candidates and ask them fizzbuzz. Plenty have never heard of it and you'd be shocked how many can't give you a working answer.
48 pages isn't *that* much (the examples could be counted in that as well)
Do not install gulp globally. Make it a dependency in your package.json and install it through npm install, then use the bin it installs. That way you can have all the plugins and versions specific to your project without colliding with other projects. Plus other people will be able to run it if they grab a copy of your repo.
Here's an idea: let's call it "javascript" and get back to productive tasks like rewriting all libraries in it or taking over the world.
I'd recommend looking into [koa](http://koajs.com/), which has a really easy way to do what you're looking for. ~~Express makes this a little more challenging.~~ In Koa - every middleware has the option to respond before *and* after a response. It might look like this: function *(next){ // I happen before the route handling var start = new Date; yield next; // I happen after var ms = new Date - start; this.set('X-Response-Time', ms + 'ms'); } I take it back - you can actually do something pretty simple and similar (except with two different functions) in Expresss - see [here](http://stackoverflow.com/questions/24258782/node-express-4-middleware-after-routes).
[removed]
I couldn't say, but for me: git checkout &lt;url&gt; docker run -it --rm -v `pwd`:/app -w /app node npm install docker run -it --rm -v `pwd`:/app -w /app node ./node_modules/.bin/gulp Makes the project very portable.
I quite liked SGML. I wrote my first book in DocBook SGML...then manually converted it to XML and then automatically (with a lot of manual touchups) to Word for publication. The SGML source was the nicest to work with (but maybe only because I had vim setup for it...and never went to as much trouble for XML DocBook). I wouldn't be all that unhappy to come upon SGML in a project, is what I'm trying to say.
True, that is nice. I'm not asking this question to imply something wrong with the setup, but: if you're using a docker image that has npm installed by default, is there really anything different about installing a build tool globally (whether Grunt or Gulp) in that image? I think my answer to that question is that npm is actually doing a lot of the image building regardless of where the build tool is in the process, and personally I've been leaning towards freezing the installed node_modules/ as images in the last six months. It's an interesting reversal of the same problem on the front-end, actually. 
We were still using it a few years back. But we were just converting it to XML immediately so now we naturally begin with XML. I suppose I'm a bit young, but I remember being a teenager in the late 90s reading books on XML and how it was suppose to completely wipe out the need for SGML. So when ten years later I find myself starting a new job where we were working with SGML I was a little surprised and slightly nostalgic. As far as that conversion chain for your first book it hadn't changed too much for some. I herd that O'rielly was converting from DocBook XML to PDF a few years back, but has been trying to [begin with HTML more recently](https://github.com/oreillymedia/HTMLBook)
My brain has switch to the luxury of changing a model and letting the UI just figure it out. Vanilla JS still makes you manipulate the DOM manually. It's a whole kind shift. 
Mother of god! What an abomination...
thanks that's exactly what I was looking for.
All this reminds me of the word "responsive" and how I would have never used it for what it is being used today. 
Not disagreeing by any means, but remember that node is written in c++ :) 
Tbh, the Dojo foundation is more than just Dojo. it's the home of multiple projects, with the most popular ones being Dojo (yeah...), Grunt, RequireJS, Lo-Dash and the intern. But the Dojo foundation itself is just a bunch of projects together, even if the people controlling these foundations join, this doesn't change a thing for the projects within these foundations themself. Also, there is no real 1 to 1 mapping of these frameworks. Merging, or abandoning one of them wouldn't really make sense imho.
Won't happen. The foundations join, not the projects inside the foundations. The only thing that will probably happen is that both the Dojo foundation and jQuery foundation websites will disappear and that all projects will be organized in a new foundation. Besides, Dojo and jQuery have different functionalities (though they have some overlap), dropping one of them wouldn't make sense.
To expand on this point, I think people often underestimate the power of portability. I also think it is a huge part of the success of Node and one of the things you don't truly understand, until you've used it for some time. Combined with the fact that most NPM modules are open source and follow the Unix philosophy of small modules that do one thing and do it well, tests with high coverage. The speed of development can reach new heights. You just fork a github project, clone it locally, enter the folder and type ```npm install```. You now have all source code, all dependencies and all development and build tools. You then fix the code you want, run the tests and do a pull request. And for almost all modules, the process does not differ depending on the platform (Win, Mac, Linux). The only thing you need to install is Node, git and a text editor. Simple. Compare this to traditional development environments, where you often have to install some IDE and a compiler that must be some specific version, perhaps even built for some specific platform, then find, download and install different libraries from random websites manually, then link those libs in your IDE, then setup environment variables, then, then, then, then... I have no doubt in my mind that ```npm install``` is one of the biggest contributors to the success of Node and why development of both Node itself and the modules in NPM are exploding at an exponential rate.
Dojo and jQuery definitely overlap. The DOM manipulation stuff is still in Dojo under the main 'dojo' package. It did go up against jQuery back in the day (and got its ass kicked). Most of modern Dojo is other support libraries for application and a ton of stuff for building component based UIs ('dijit'). I was under the impression that for the big Dojo 2 effort which is going on right now, they were planning to remove the DOM manipulation stuff or just have it defer directly to jQuery. 
You really want to read this: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
Indeed, I also said they have overlap, but the `dojo/query` module is only a small fraction of what Dojo has. It also has XHR (jQuery too), promises (jQuery too), widgets/Dijit, MVC framework, mobile widget framework, mobile MVC framework, store API, lots of tools and utilities (some of them overlap with jQuery), ... . That's why dropping 1 in favor for another won't work. But you're right, the [proposal for Dojo 2](https://docs.google.com/document/d/1fXGrlsl3aTqst7mCj3XqlKdbuCJs4rB9r7qIxC-tWMQ/edit#heading=h.k4rte11hqkre) mentions that for DOM querying, jQuery will probably be leveraged in stead of their own `dojo/query` module.
I wonder if this works with modern versions of windows. Article is from 2007
(I might be misunderstanding something but...) Something I'm having problems with in Gulp is the conflict between `gulp-rev` and ES6 (Babel) imports. Gulp intrinsically handles each file independently but when you're importing between files you need to know what the referenced filenames will be. Preferably you'd want to point to a versioned/hashed filename at build time, but because each file is processed separately there's no way to use gulp-rev and Babel at the same time. So I guess it's a general problem of how to resolve dependencies when files are processed separately. Is the solution to do Babel first and then calculate hashes, and parse the resulting ES5 (with what?) and replace the references with the appropriate hashes? Or is there a way to refer to files which are eventually resolved?
Block scoped declarations: let, const and class are not supported in Chrome yet. Believe it or not, Edge and Firefox are the two best supporting browsers for ES2015 support.
Firefox isn't really a surprise :)
JScript. The bastard child of Microsoft. Nothing to see here. Move on.
Use browserify with the babelify transform 
&gt; Here's an idea Oh, did you come up with that idea? Meh. I addressed that in the post already. Misses the point.
But I'd be surprised if any devs weren't using babel to make stuff. 
It looks like gulp has bin settings included, meaning that you should be able to use it via npm script entries. So if you have a gulp task named "gulptest", you should be able to do something like: "scripts": { "unittest": "npm run gulp gulptest" } And then run it by doing ```npm run unittest```.
Oh never heard about that(and trying reading long stuff with scrolling is pain on my small screen phone). But still React, would be overkill for my small simple app.
Agreed. JScript is one of the scrappy products of past corporate language battles.
Not sure what is going on, because IIRC let support was put in Chrome 41, and current version is 45. Could try using the code from https://github.com/GoogleChrome/samples/blob/gh-pages/lexical-declarations-es6/index.html and see if that works?
here's my minimal js library for showing/hiding elements. function visiblity(visible) { return function(id) { var el = document.getElementById(id); if (el) { el.style.display = visible; } } } var show = visiblity('block'); var hide = visiblity('none'); // example show('someElement'); hide('someElement');
Its completely broken in IE, even IE11.
&gt; Its completely broken in IE Web dev summed up in one sentence.
Also, no photos. Typically when you make something, you show it off. 
html isn't going anywhere, if you're going to be doing web development you really should try to get over your aversion to it.
It is, and it will
1. jQuery (and all other frameworks/libraries) do AJAX by wrapping [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) and alternatively having a fallback for browsers that don't support it. I'm not quite sure what the fallbacks use (I've come across that they use ActiveX). 2. I'm not using RequireJS, but I think its supposed to mimic the way NodeJS requiring works. The way it knows what object to export is by exposing a global "module.exports" property. Whatever you put in the "module.exports" will be returned when you require that particular file.
Should have been more specific on both of them. 1. I want to know how *.success()* part in *$.ajax({})* works. I know we can extend object/function using *.prototype* , but we aren't using it as constructor, so that doesn't make sense(unless they assign it as property each time, which is bad pattern, isn't it?); 2. I've tried that, but somehow managed to fail, but I'm going to retry that, thanks! 
I think you're right about all of that. But the simple fact that it's an opinionated choice will surely deter some folks that may want to contribute
Not the most recent IEs or edge. I tend safari followed by chrome cause the most bugs on desktop.
Dev is troll. Read last option. 
I agree, moving is not quite there yet.. Use the buttons on top ;)
Looks like a good learning experience. 
Feel free to ask any questions ;) edit: about the project..
jQuery's ajax returns a jQuery style promise. I can't really help you much with jQuery deferred/promises, but promises are a part of the ES6 spec so there are many articles about them such as this: http://www.2ality.com/2014/09/es6-promises-foundations.html?m=1
What do you mean by air?
https://www.youtube.com/watch?v=nyJPM2jIwjQ
Yea, titles can't be edited. Even mods can't do that.
Well you said feel free to ask questions.. He wants to know more about air. Please op.
Why exactly do you need the iframe?
That won't bother any developers so it doesn't matter.
&gt; let, const and class are not supported in Chrome yet. They are in strict mode. Firefox only supports `let` if you use `&lt;script type="application/javascript;version=1.7"&gt;` which prevents it from being executed in any other browser (which means Firefox's support of `let` is completely unusable). It also doesn't support classes at all yet. https://bugzilla.mozilla.org/show_bug.cgi?id=837314 See also: http://kangax.github.io/compat-table/es6/
Which version? :/
The latest.
I really hope it's a parody. I fear it's not.
Nope. :/
Just make it so we can flip them over in that interface, and we can play our own games of solitaire. 
What's it supposed to do? I'm in IE11 (don't judge me--I'm at work) and the buttons don't seem to do anything. 
Assuming the Yahoo Finance API supports CORS (which, being an API, it probably does), you can cut out the PHP and make a [cross-domain XHR](http://www.html5rocks.com/en/tutorials/cors/). Worst case, you can still make an XMLHttpRequest to your local PHP that queries Yahoo: var xhr = new XMLHttpRequest(); xhr.addEventListener("load", DoStep2D); xhr.open("GET", "symbol.php?q=[user_input]", true); xhr.send(); EDIT: One more suggestion. It would be better to make a single query to the Yahoo Finance API rather than one for each symbol in localStorage. Loop through localStorage, build a single API query with multiple symbols and send it once.
Read first comment. Got what I wanted.
Same here, still a junior dev trying to be helpful :) Check that course out though, only 15 bucks if I recall. Normally 100+
Why don't you try it for yourself? It just doesn't do anything else but show 1 card in the middle of the screen.
I did, as a matter of fact, though I certainly wouldn't claim to be the first person in the world to think of that idea (or any idea, actually). With the sheer number of rename-happy articles being posted as of late, I don't have time to more than skim the contents. Please understand.
Works in my Firefox.. Have to check out if I have some older version. I don't use Firefox that much.
The problem must with the css prefix - have to check it out..
That's a beautiful logo. Looks straight out of a fashion line.
If you're interested in promises in particular, then look [here](http://modernjavascript.blogspot.com/2013/08/promisesa-understanding-by-doing.html) for a barebones implementation. If you're interested in chaining functions (what I think you're interested in), then it's fairly simple. The secret is to keep returning `m` if you want to be able to keep chaining. var makeNumber = function (num) { var m = {}; m.num = num; m.value = () =&gt; m.num; m.log = (before, after) =&gt; { console.log(before + ' ' + m.num + ' ' + after); return m; }; m.add = n =&gt; { m.num += n; return m; }; m.sub = n =&gt; { m.num -= n; return m; }; m.inc = () =&gt; { m.num += 1; return m; }; m.dec = () =&gt; { m.num -= 1; return m; }; m.ceil = () =&gt; { m.num = Math.ceil(m.num); return m; }; m.floor = () =&gt; { m.num = Math.floor(m.num); return m; }; return m; }; You can now do something like: var n = makeNumber(20); n.add(5).sub(3.3).floor().log('foo', 'bar').value(); //=&gt; prints "foo 22 bar" then returns the value 22
You have Mixed Content errors on your deck.min.js if you load the page over HTTPS (I have HTTPS everywhere install so it loaded automatically). You should always use // instead of http:// to prevent this from happening. It will attempt to load the resource over the same protocol as the parent page. 
Besides how you write your gruntfile/gulpfile, not much. They are both task runners. What you use is really down to preference. Some people like one more than the other but they can do the exact same things. Look at examples of both and choose which syntax you like because both can run tests, build apps, concatenate files, and a lot of stuff I don't feel like listing out. There's also the crowd that likes using Make, maven, or another language's build tool. Then there are the NPM purists. Just do whatever you want because they all work and any advantage is marginal.
Now fixed - thanks again!
Fixed now!
Better yet, use `https://` instead!
That's fixed now, thanks!
No argument there, https should be used everywhere. This can lead to issues also. I have only seen it lead to issues if you use iFrames that have HTTPS when the parent page is not and you are trying to communicate between the two through the use of sockets. Your best bet is to use // everywhere and than use nginx or some other Web server to force all requests to HTTPS, but this is just getting into the heavy technical side that OP probably does not care about. // gives you the least possible chance of issues because of mixed content which is why I perfer it. 
Yeah, it's https now.
Wow, I've studied your code, very interesting. Haven't seen anyone bitch about no semi-colons yet. I used to leave them off too, until I gave up the fight and just started conforming with everyone else. I really like your style. Something I've never seen before either is for example your queue.js, where given an object it assigns .queue to the object and returns. Took me a minute to work out what was going on. I'm looking at the code thinking "this function doesn't do anything", then I realised the queue function is in scope even though it's defined after the return. I'm wondering could you also put the queuing variable after the return too?
That's JavaScript's function hoisting where function definitions are implicitly moved to the top of their scope. Variables get hoisted to the top of their scope as well with the value undefined, it isn't until the point in the code that you specify that they get assigned something else. This means you can use variables before you've assigned them and they'll have the value undefined.
You need to lawyer up and hit the gym. Enjoy the gold stranger!
Yeah, I tend to keep the "basic structure" of the function as high as possible (initializations and returns).. Hoisting does the magic. About those semicolons: I use [standard](https://github.com/feross/standard) with sublime and it's been awesome!
Do you repo braw? I should just copy and paste the code like some kind of savage? It don make no sense. EDIT: Also, I think it's time to tailor a logo and slogan and cool short name like sh.js and you got yourself a library. ^Anyway, ^go ^with ^Christ, ^braw. 
Congrats. Someone confirmed you can program at the most basic level. FizzBuzz isn't designed to be useful to the interviewee, it's meant as a tool for the interviewer.
I'd also add that the current card should default to the highest z-index (this is how they work in real life and is expected behavior).
You can set it up as middleware: app.use(function (req, res, next) { res.once("end", function doSomething() { //... }); next(); });
NP, Seems to have fixed the animation in Firefox nightly at least 
Yeah you might be on to something -- it wouldn't be limited to games with traditional card decks either if the cards were skinnable and you could add different attributes to it, etc.
Maybe I should create another more barebones project for that..
JavaScript would be a terrible choice for a project of that size. Especially if there are many contributors. You really need the tooling. I wouldn't be interested in Angular 2 if it wouldn't offer good tooling. (I'll use the Dart flavor.)
I've recently seen the light of modules (mainly due to css modules possible with webpack), so will reverse my earlier decision to keep child components out of Kilroy. Anyway, you can use the current Kilroy in an ES6/webpack workflow, or ES5.
Anytime!
I don't want to break things up when used from file:// – if you want to try and tinker locally.. I think I'll keep those https://
&gt; `queueing` would get hoisted, but the value would be undefined - I think. Correct. While you know what you're doing, newer developers may not. Hence I advocate declaring `var`s (uninitialised until you need them), internal `function`s, then the meat of the main function with `return`s liberally spread around. Anything to minimise the slightest possibility that old IE will cough. It already has enough ways, so why give it more? You also get to see at a glance just how much you're declaring - instead of picking through the code - so you can tell if you really ought to refactor it...
You can also modify the kilroy instance at any time with `.d()`: const filter = Filter() document.getElementById('application').appendChild(filter.node) fetch('items.json') .then(function (items) { filter.items = items filter.d() }) 
Is there a way to get a stripped down version of react? 40kb for something simple like this seems way overkill.
Hi /u/jamie337nichols, please don't spam.
Is there a particular reason why sometimes you're using the notation `el.style[prop]` and other times `el.style.prop`? I haven't seen the first one a whole lot, just curious why you've done it that way, and more so why you're doing it both ways in the same file.
Not spamming. But if you see no benefit to this post I'll just delete ir
No limitations, I'm just researching right now. 40kb seems like a lot when compared to other frameworks, for example Mithril is only 12kb.
Oh, that looks nice. Do you have to call update() any time you want to update the DOM though?
Alright :) thanks for the info 
I trust Paul Irish: http://www.paulirish.com/2010/the-protocol-relative-url/ Plus there's such a thing as free certificates these days. It's not like when they cost a packet anymore. 
Which computer do you use? 
FYI it works on my Firefox.
(full disclosure: i am a noob) I'm pretty sure this is just minified code. Btw, be sure you understand that "java" and "javascript" are very different. you posted minified javascript, NOT java. often code will appear in its: - developer version (full variable names, comments) which is a version which is meant to be understandable so that it can be tweaked if need-be or - minified version (which I believe your example is). minified code works the same as the developer code, but it has a smaller file size. this is accomplished by reducing the names of variables &amp; function names to the bare minimum, often just 1 letter. more info here: https://en.wikipedia.org/wiki/Minification_(programming)
Very cool. Good job man.
Thank you! The Java typo was my bad; I definitely know the difference and am reasonably well-versed in Java, but unfamiliar with Javascript. So, is there any way to unminify (?) the Javascript? 
I don't see how it is like backbone in either intent or implementation. What do you consider to be boilerplate? 
Construct2 or Phaser.io
Because there are people who are trying to make the tech world a more sensitive place. Personally I don't think it's necessary but at the same time I downvoted because it's not really adding anything to the discussion to simply say that this shouldn't be a thing.
Slick! 
Holy crap. Durandal is on there.
use superagent and webpack is a lot more easy. 
Almost always... Phonegap/Cordova apps wrap a webview which go to file:// 😁
Maybe check out [Knockout Components](http://knockoutjs.com/documentation/component-overview.html)?
I have a 15" MacBook Pro.
Thanks! I have no idea about open source licenses. Which one would you recommend? There is "MIT" text in package.json, so maybe I copypaste that one from somewhere..?
Copy and paste the whole thing. That way we can try and work out the errors together since we are learning. 
MIT would be good, yeah.
It's actually a feature, but I know that it is not that intuitive. Have to fix the whole moving around logic..
I tend to prefix references to DOM elements because I want to separate view objects from DOM elements.. jQuery doesn't own the dollar sign in any way :)
You are right..
I *think* it may depend on whether your event hander is an anonymous function or a function statement elsewhere in your code... However; An even better option for you may be to utilise event bubbling/delegation, thusly *(here I'm assuming that .uttwparent is a parent dom element which contains your .uttw elements)*: $('.uttwparent').on( 'click', '.uttw', function(ev){ //ev.target will be your .uttw element }); This method of adding event handlers is highly efficient, and removes the need to manage the addition and removal of eventhandlers as you manpiulate the DOM. You simply add the handler when the .uttwparent is first available (document ready?). See 'Direct and delegated events' [on the jquery 'on' page](https://api.jquery.com/on/)
I feel this needs to be said re: rollup. the readme file... it has rap lyrics at the top. I get youre trying to be a brogrammer or whatever, but its cliche and cringeworthy. nothing dorkier than a programmer including rap lyrics in code. try harder.
Author of rollup, ractive.js and many other great projects – follow the link bro! I mean who cares about some stupid rap lyrics, when he's developed such many great software anyone can use for free.
`eval()` takes a string and treats it like javascript I think. All I really know for `eval()` is that you should never ever use it because it's extremely dangerous. Try keeping the person creation in a string.
That's totally fine and you won't have much problem, but the big gotcha is the first load. First, it's going to be a relatively crappy experience for the user because you need to load your page and then fire an AJAX request to populate the content, and that takes time. Or you'll need to implement exactly the same features both server-side and client side, which is stupid. The other gotcha is that you'll need to have routers both in the back end and the front end and make them match. 
Yep that is how I normally do it. Very handy.
What you're describing is possible, and it might be the right approach for you. You have to make that decision. However, what you're describing is **not** isomorphic. Isomorphic Javascript refers to using the same code on the server and the client. If you're using one framework to render pages server side, then React to render more content on the client only, you're not writing isomorphic Javascript. You're just using Javascript to enhance a page
I prefix some functions with dollar sign. I have no idea why. Have seen others do it too.
It's called minification. This is done to reduce the size of libraries that are way larger in their human readable form. Remember that this code is transmitted on every single request. This adds up, and it becomes a big deal once a site gets big enough. 
Firstly, thanks! Another question - Wouldn't something like function __n(intgr) { this.m = intgr; return this; } __n.prototype.add = function(i) { this.m += i; return this; } function number(intgr) { return new __n(intgr); } be better, so functions are stored only once? Or performance difference won't be that huge? Of course all of that should be wrapped somewhere else, so __n isn't exposed to global. 
Thank you!
Even Google use rollup to bundle: https://github.com/google/incremental-dom/blob/master/package.json#L45
Oh, I see now. You're passing in variables, not strings. That is certainly an interesting approach.
1. I'd leave those `type` attributes in those two at the top, wouldn't hurt. 1. You have a rogue `script` tag at the end. Delete that. 1. And most importantly, `script` tags are not self-closing. You need to remove those self-closing slashes and add back in the closing tags (`&lt;/script&gt;`) after each one. Other than that, just make sure your links are pointed to the right resources, because I can't verify that. And if after all of that it still isn't working, note that you're now bringing in what looks like *only* regular jQuery at 1.11, when the original had jQuery at 1.7 *and* jQuery UI.
I think you've got the answer to your first question about minified code. As to your second question—can you explain a bit more context? You're playing around with some HTML/CSS and some of your styles won't update? If that is the case you may be changing them somewhere too early or not specific enough and they may be getting overridden by other styles. Open up the page in your browser and inspect the element (F12 Windows, Cmd+Opt+I Mac) to pull up all of its current styles and try to figure out what is getting applied and what is canceled.
The biggest differences: \#1 grunt uses temp files, i.e. disk operations, while gulp uses node streams for its operations, meaning the tasks are all run in memory. Memory vs disk writing means that gulp is [a lot faster.](http://tech.tmw.co.uk/2014/01/speedtesting-gulp-and-grunt/) This is probably pretty trivial for most projects, but is pretty convenient when working on something large. \#2 they're written in a significantly different way. Grunt configuration code looks more like JSON data, while gulp code looks more like a regular Javascript file. Both are pretty easy to understand once you get the hang of it, just preference after that.
You're trying to replicate a do/while or do/for. There are several major code smells: * you're using negative variable names ("isntFirst === NOT_FIRST" is very awkward to read) * you're using a special marker value as a flag (a boolean or in fact any truthy value would suffice) * you're duplicating information (if i is always 1 on the first run, you already know whether it's the first run just by looking at i) * you're closing over the counter variable but passing the `isntFirst` flag as an argument (this is inconsistent) So with these things in mind, you could rewrite it like this: sayHello(); function sayHello(i) { if (!i) i = 1; if (i &gt; 1) {console.log('hello', i);} else { console.log('only executed the first time'); return sayHello(i + 1); } } ```
Space, &gt;, +, and ~ are combinators. \&gt;&gt; is already proposed as an alternative for space, because that will make more sense in conjunction with &gt;&gt;&gt; (shadow-piercing descendant combinator). E &gt; F = child E &gt;&gt; F = descendant E &gt;&gt;&gt; F = shadow-piercing descendant https://drafts.csswg.org/selectors-4/#descendant-combinators https://drafts.csswg.org/css-scoping/#deep-combinator
Sort-of, it doesn’t know who you refer to when using a name and a pronoun currently, but it does know to ignore `mailman or mailwoman` because the occur adjacent (whereas otherwise it would suggest `mail person` and whatnot). It also knows that “he” is meant literally because its quoted. He - same for the preceding one, and following ones: he. It’s not perfect, I’d rather have some superfluous warnings than maybe missing a a few really important ones!
&gt; sugges To build a truly single page application you have to use routing on the device itself (Not to wait for a response for every route change we intend to do). You could transfer the routing "rules" to the application and start time, this way routing is still located at one place (database or whatever), or even better, at build time.
Sorry, I guess my explanation wasn't sufficient. But if you're not sure what value will be passed into that function, your code is insufficient. Say you need to do this: var AFTER_FIRST = {} new Array(1,2,3,4).forEach(myfunc) function myfunc(el,afterFirst) { if (afterFirst===AFTER_FIRST) console.log('hello') else if (el&gt;2) return myfunc(el/2,AFTER_FIRST) } You couldn't do that with a primitive, because you need a reference. This also couldn't be replicated by a do-while loop, because you couldn't call it recursively. 
Yeah, well I also run uglifyjs on my code, so my production bundle is absolutely unreadable. I don't think readability of the production bundle is really important. If you still need to debug the production bundle then you can use codemaps and chrome dev tools to get the actual code back in your development console.
Arrays in JavaScript can grow and they can be sparse, too. The VM automatically picks the more suitable implementation. There are also tightly packed typed arrays which are interesting for WebGL, Canvas, working with bytes, and Asm.js/Wasm. https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays Linked lists are very rarely a good fit. Even if you do particle effect stuff without reusing the particles, you're still not doing enough inserts/deletes for making linked lists look any good.
Twitter and Adobe use grunt, Atom by Github is written in coffeescript, bootstrap 4 switched to sass. I think you should be going to rewrite some code :) Rollup is only 3 months old and noone knows if it will stay for next 3. Also it probably has more bugs to be discovered, so KEEP CALM and BROWSERIFY
&gt; I have no idea why. This is the last thing I ever want to hear from a programmer.
Good rant. It reminds me of the time that went to find some HTML encoding/decoding functions. NPM has a huge curation problem. There is no organisation or quality control and it costs heaps of time to find the good stuff mixing in with the tons of garbage. Make no mistake, NPM has way more garbage than any other similar repository (i.e. CPAN, Java's big maven artifact repos). Whenever I hear about the exponential growth of NPM's repo, I roll my eyes. There needs to be a way for people to directly rate modules and for us to remove them from search results. I personally keep a HTML document listing modules which I have already vetted. It is comparable to Python's package index. Also, unix didn't ship with multiple buggy versions of the same tool. They just ship one good default. Regarding libraries vs "small modules", I'm with you again. Libraries are just more practical because you only have to vet the library and the project behind it once. A much better solution for reducing the amount of unneeded code which is sent to the browser is a compiler or linker or some kind of build tool which can do proper dead code elimination. (Typescript code should be a lot more suitable for this kind of optimisation.) PS. The correct answer for "HTML encoding/decoding" is https://www.npmjs.com/package/he . All the other results are the same 4 lines of garbage copied from stackoverflow and thrown up on NPM without even checking to see if someone had already done it first (and better). sorry everyone, I was ranting a bit too. 
Same thing with cars: there's Toyota, Volkswagen, Hyundai, Ford, Nissan, Fiat, Honda, Suzuki, Renault, BMW, Mazda... They all have four wheels. And every year they release a new model, can you imagine? Wouldn't it be better to just stick with current models and not invent anything new? And better yet, only one manufacturer..? Where's: "Great, another Tesla."?
Well, not every year we change how to define modules. And if you think about Tesla for example: at least for me the way throttle pedal works is a whole new way to drive. You control the "brakes" with lifting throttle. I like innovations. I'm not afraid of change.
Uh, all cards of the same colour all look like aces, but with a different number, or letter in case of the "people" cards.
Efficiency here is an implementation detail. In JS, all primitives (numbers, strings, booleans, regex, and functions) are immutable. Since a function primitive doesn't change, an intelligent JIT can see that we're accessing the same function and not make a new copy. This is what all modern engines do. In truth, there are minor differences in performance between prototype and factories for other reasons. The differences are small enough that I wouldn't recommend using classes for anything except very primitive data because of what you lose in exchange. Consider my implementation vs yours. I *chose* to allow a user to access the number by assigning it to `m.num`(I didn't decide to add the `.value()` method until I was almost done). I would normally **not** do this and would instead do something more like var makeNumber = function (num) { var m = {}; m.value = () =&gt; num; m.add = n =&gt; { num += n; return m; }; return m; }; In this case, the `num` value is completely private and I don't have to worry about my users messing with the inner workings of my factory. The standard convention in JS classes is to do something like `this._num` to mark something as private. The problem is that programmers *always* wind up accessing these properties. Once they do, you cannot change the private parts of the class without breaking something. The factory is better because the closure enforces encapsulation while the overhead is pretty much zero (you won't ever notice it until you have thousands of instances). TL;DR The performance is about the same, but factories allow better encapsulation and private variables.
This isn't specific to npm. Want a JavaScript MVC framework? New libraries are being pushed weekly. The reality is, you will never have the perfect stack of modules. Maybe your stack is 5kb more than another developer's stack. But you are still 100x more productive than the old days of JavaScript, where you would be copy-pasting some sketchy and untested code from StackOverflow into a 4000 line file. Just choose something and stick with it. Example: [domready](https://www.npmjs.com/package/domready) is small and fits my needs, so I've never spent any extra time looking for alternatives. There is also nothing stopping you from using `lodash.*` modules instead of relying on things like [once](http://npmjs.com/package/once) or [uniq](https://www.npmjs.com/package/uniq). &gt; What are the problems that small modules solve, and are they worth the cost? See here: - [Why tiny modules?](https://gist.github.com/mattdesl/f613d796b190d9e5e929) - [Sindre: Why one-line node modules?](https://github.com/sindresorhus/ama/issues/10) PS: http clients and `extend` functions are two of the most duplicated things on npm. :) 
One nice thing with small modules is that the cost of replacing them is rather low, compared to frameworks like angular and backbone.
This is designed to be really easy if you are comfortable with angular: https://github.com/Hypercubed/angular-ecs
I would definitely read a blog post about the process of making this.
Many of the complaints against Angular 2 in this post are due to the fact that Angular 2 is in alpha and still does not have a stable API. I think it will be a lot easier to do a fair comparison once Angular 2 reaches beta stage and the API is stabilized.
We never see [riotJs](http://riotjs.com/) in theses post and its the most elegant, no nonsense UI framework out there. But then again... Op is a troll :)
Your API is leaking implementation details. new Array(1,2,3,4).forEach(myfunc) function myfunc(el) { function _myfunc(el, i) { if (i &gt; 0) console.log('hello') else if (el &gt; 2) return _myfunc(el / 2, i + 1) } _myfunc(el, 0) }
I will fix that.
True dat.
I had to Google up what does "phat" mean, but thanks, I guess! :D
I just found the Angular.js version as well: https://web.archive.org/web/20130823182335/http://pakastin.fi/cards Close wayback machine's topbar to use the controls ;)
Here's first HTML5-version: https://web.archive.org/web/20130823182335/http://pakastin.fi/cards (just close wayback machine controls first..)
&gt; Just choose something That's the whole problem. If there was a place where we could go and just punch in some search terms and then grab the first thing out of the results and be confident that it was maintained, complete, correct and documented (i.e. quality), then we wouldn't be having this discussion. The arguments for tiny modules in those links sound plausible but there is no point if it is too hard to find quality. 
Very nice. Pity it doesn't work on Firefox. (FF doesn't like some CORS header when it tries to fetch the database.) 
Well, you can continue to use X if you like ;) I think it's good to have options, and innovations moving things forward.
If you have data local to the outer function that is needed by the inner function but which doesn't make sense as a parameter then you should nest functions. I find, however, this to be a rarer case than the one in which two functions at the same scope can work together.
I'll give ya my blessing. :) Can help out too as I've been looking for a side project to work on.
You're right, it is good to have options. I just wish things would slow down a bit...I'm getting too old to keep up with all this. 
Thanks, got it
1) ES6 modules: https://github.com/pakastin/deck-of-cards/blob/master/lib/deck.js#L2-L8 2) Destructuring: https://github.com/pakastin/deck-of-cards/blob/master/lib/deck.js#L10 https://github.com/pakastin/deck-of-cards/blob/master/lib/card.js#L21 That's about it :)
The problem is `visible` is not a display property. Try `block` or `inline-block`
Your still the realhacker, don't worry.
Must. Do. That. :D :D :D
:D
But sometimes you might need to dynamically set the not first. Maybe you're going to call the not first routine outside of the function for something else. var AFTER_FIRST = {} new Array(1,2,3,4).forEach(myfunc) function myfunc(el,afterFirst) { if (afterFirst===AFTER_FIRST) console.log('hello') else if (el&gt;2) return myfunc(el/2,AFTER_FIRST) } // dynamically called based on some other condition myfunc(7,AFTER_FIRST) You couldn't do that with your code, because _myfunc is private. Not to mention, it's kind of hard to read. Granted mine isn't that easy to read either, but using 'i' to denote the condition is a little esoteric. You could also have multiple conditions to check. Say you had multiple constants. Then, you could pass in whatever constants you want, in any order and check them out dynamically like this: var PASSED = {} var NOT_PASSED = {} var ALSO_PASSED = {} function wasPassed(constant,args) { return !!~Array.prototype.slice.call(args).indexOf(constant) } function test() { if (wasPassed(PASSED,arguments)) {console.log('PASSED')} if (wasPassed(NOT_PASSED,arguments)) {console.log('NOT_PASSED')} if (wasPassed(ALSO_PASSED,arguments)) {console.log('ALSO_PASSED')} } test(ALSO_PASSED,PASSED) // yields PASSED, ALSO_PASSED I mean, I'm sure you could find a way to do that too, and I could find another use case it wouldn't satisfy, but the point is it's just a different way to look at/do things, and I just thought people might think it was a cool idea.
WARNING TO MOBILE USERS: Crashed my phone. Looks super handy though. Will check it out when I'm at my desk.
I assume your username means pakistan? hows sharia law treating you? ill laugh when trump turns your country to glass. in the meantime, youre on my shortlist if I ever need to hire a curry at .50 shekkels an hour
Interesting post. I used to select a module based on github stars, but very fast I realized it doesn't mean anything. Many libraries are hyped hence have a lot of stars, but do not provide quality code / functionality. In such small things I tend to stick to standardized APIs with polyfill if needed, like Fetch API for ajax, or Object.assign for extending and etc. No everything must be a library, writing a "dom ready" handler is a matter for 5 minutes and 10 lines of code.
Oh boy do I have something for you. It's called a [Version Control System (VCS).](https://en.wikipedia.org/wiki/Revision_control) The most popular of which right now [is called Git.](https://git-scm.com/) It sounds pretty complicated to get ramped up with, but do some research and get yourself familiar with how it works. There is usually a master branch of the filesystem, then individual devs can create their own branches to edit the entire ecosystem how they want, then merge back to master once their edits are complete. And provided you give good commit messages, you'll always be able to see a history of how the project came into being. And if you merge something that breaks the system, you can always roll back to a previous version and see what happened. Commit early, commit often. You've got some reading to do my friend, but learning how to manage a proper VCS like git is an essential part of becoming a developer. Feel free to ask questions as well.
&gt; Just choose something Error: infinite recursion detected, stack size exceeded :-)
javascript plebe...should be using Haskell code compiled to JS for true purity 
I really like the read side of the GraphQL approach, it seems like the right thing that each individual component can request their own data and the framework takes care of only requesting what's necessary and every component gets only the appropriate data - no more cascading effects in parent components. That said, I don't see the mutation API getting accepted as an easier approach by frontend developers. As of now I think using GraphQL on the read side of a CQRS architecture would be pretty neet. I can also think of many use cases in my day to day work where I could leverage a GraphQL endpoint to abstract our *not so optimal* database design when querying stuff. Put an an event store on the write side and you're good to go :-). We'll see how the spec evolves...
Not effective in my opinion. Reliable software is not the same as well marketed software. It takes some good marketing to get a bunch of Github stars. With an awesome upvoted article on Hacker News you can get 3000 Github stars in a weekend. If nobody is regularly using the software then really who gives a shit. Check this out: http://nipstr.com/#pretty Notice repo "recast" has 567 Github stars which is about 50% more than the next repo "prettydiff". But actually go to the NPM pages for those repos. "recast" gets almost no traffic at all. Nobody is using it. "prettydiff" is getting roughly 1500 downloads everyday. To me that is a greater indication of reliability, an active need. Another strong indication of reliability is the number opened issues and the frequency with which issues are closed. Projects that are super in demand have a lot of issues. A super high issue count indicates strong community demands in the form of defect identification, feature requests, and general questions. If issues are regularly and quickly closed the project is more reliably maintained.
Good day to you too! ♥︎
Do whatever you want with it! ;)
I think everybody agrees npm search sucks. :) Google usually provides a good module as the first or second result. Examples: - [object assign polyfill](https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=+site:npmjs.com+object+assign+polyfill) - [object deep extend](https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=+site:npmjs.com+object+deep+extend) - [domready](https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=+site:npmjs.com+domready) - [cross browser xhr](https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=+site:npmjs.com+cross+browser+xhr+) 
The best thing about Javascript is that almost anything is possible. The worst thing about JavaScript is that almost anything is possible. While I agree that people have pushed a lot of modules to NPM for no reason at all, JS as a language will always suffer from this because it's a dynamic language that can do almost every programming pattern out there and can now also be used on the server side with Node. This will naturally lead to a lot of modules that might *seem* redundant but really aren't, since they build on different methodologies to do the same thing. Does the module work with callbacks? Promises? Co-routines? Async? Streams? Event-emitters? There are so many patterns that might not always be compatible in any meaningful way. For instance, to truly understand the Unix philosophy of small modules that do one thing well, you *have* to understand the concept of streams and piping. The thing is, streams is a *huge* part of both Unix and Node but how many JS devs can honestly say that they grasp this concept? I can count the number of good Node streams tutorials on one hand. It wasn't until gulp and browserify made their appearance that streams gained any kind of real traction in the Node community. However, from the questions I see, few JS devs understand what is actually going on behind the scenes when they do e.g. gulp.src('main.js') .pipe(uglify()) .pipe(gulp.dest('dist')): [This is what one of the things substack tries to explain here with a comparison between browserify and webpack](https://gist.github.com/substack/68f8d502be42d5cd4942). Want to see the true power of small modules built as streams? Have a look at this [article](http://ejohn.org/blog/node-js-stream-playground/) and playground. For instance his last example where he: 1. Downloads a file from a server. 2. Unzips it. 3. Changes the encoding of the unzipped file. 4. Parses the unzipped file as CSV. 5. Compiles the CSV rows with a Handlebars template. 6. Joins the compiled templates with a newline at the end. 7. Concatenates it all as a string of HTML. 8. Wraps the HTML in an HTML table. 9. PUTs the result to a new URL. How many lines of code did this take, if we exclude the require statements? *11 lines of code*. Have fun doing something like that without small streaming modules that do one thing well. I promise you that you can't find find a module or framework that does it all and every part of the chain can be swapped out with another streaming module if need be. That is where the power of true modularity lies. I *do* agree that the JS landscape is insanely confusing at the moment and I too hope that it will settle down, hopefully by having some kind of "branches" according to design patterns or methodologies somehow, especially at the NPM. But I think JS is just so versatile that it will always be at the expense of immense fragmentation.
This is more than just Javascript but I didn't know where else to post it.
I don't like this model at all, but at least I've never had a problem re-activating a previously purchased JetBrains product.
Thanks for posting this. Webstorm is a popular js IDE.
I don't understand why people say it's like comparing apples to oranges. * They're both fruit. * Both are roundish and typically about the same size. * Both grow on trees and contain DNA.
wazzup :P npm keeps mentioning how they are "working on module search/discovery" - it would be good to see more about their plans on that. "Collections" like [this](https://www.npmjs.com/package/npm-collection-http-clients) help a little, but aren't a long-term solution. The "small module" approach is best when you are dealing with things outside the scope of jQuery/Lodash. Solving specific problems like color quantization, binary search bounds, robust point-in-polygon, markdown parsing, pitch detection, language processing, etc is often easier with npm than in many other languages.
Ugh... I might go back to Sublime.
&gt;AngularJS 1.x filters are helpful for formatting output in our templates. With Angular 2, we get this same great feature, but they are now called pipes. At the time of this writing, Angular 1.x and Angular 2 have an equal number of filters to pipes, but there isn't direct crossover. The following table shows a comparison: Good lord 😱
https://github.com/bolshchikov/js-must-watch
Ha! There's ES6 and you... &gt; [JavaScript es5](http://new2.fjcdn.com/thumbnails/comments/You+do+know+some+places+can+t+get+faster+internet+right+_773c6da37639bd7553d3bba0f1f6d961.png) 
A year ago I was really inspired by: https://vimeo.com/channels/fronteers14/109912254
an IDE is a core tool - building a career on top of a tool that uses a subscription model is a form of technical debt ... not really the direction i want to go (if they guaranteed that prices would never increase, it might be acceptable). they're giving till nov 2 to get grandfathered into the old system, so i guess i'll evaluate the latest webstorm version and netbeans and make a decision
&gt; JavaScript was meant to be a smaller version of Java Actually "Java" is a substring of "JavaScript" which makes Java a *shorter* version of JavaScript
not sure if I should throw('up') or catch(Exception)
&gt;All existing customers who have purchased perpetual licenses prior to November 2nd 2015, qualify for discounted subscription pricing. How does one get a "perpetual license"? How much is it? edit: called their sales number, seems like if you buy a normal license now (the one that comes with a 1-year upgrade, $49 for WebStorm for individuals), you'd be eligible to switch to the discounted subscription model (I'm assuming the restriction of "Offer to be redeemed no later than Jan 1, 2017." still applies)
Hard to actually play it for more than a second or two&amp;mdash;the blocks which one punches are moving very quickly. Maybe I'll just slow though. :)
if only he wasn't indian.
whats wrong with that?
This is correct. My understanding is that JavaScript the name was chosen for marketing purposes. Brendan wasn't attempting to emulate Java in any significant way when designing the language.
Except hamster wasn't named to sound like ham.
nothing, its harder to understand
Hmm. Atom it is!
Have you run into any problems with just requiring/importing it like you normally would? Make sure you have Stage 1 features turned on for decorators
&gt; class TempConvertPipe { Writing functions as classes? Cool! Welcome to the future! Are the Javadocs for Angular 2 up yet? [Crossing my fingers for stuff like this.](http://www.gwtproject.org/javadoc/latest/com/google/gwt/user/cellview/client/AbstractCellTable.CellTableKeyboardSelectionHandler.html)
The issue is: would you rent a jackhammer if you only need it now and then? Yes. Would you rent a cheap screwdriver if you need it all the time and it never changes? Then why would you rent an IDE?
I've been using Atom, coming from RubyMine, and found it pretty good. I've always used Sublime and it feels pretty close to that with a little extra UI polish. 
Can't tell if serious, or making fun of the fact you need to wrap the Pipe's transform() method in a decorated class just to pass it to the view via a decorator. Yeah, that sentence hurt my head.
I was having this same problem with a js project. Are you are using a continuous build tool? If so it's probably re-indexing your entire compiled program after every save you do. You can tell it to ignore your build directory, which will fix it.
I don't really care if you rent an IDE or not. That's a personal decision, one I will **not** be doing. My point wasn't about the subscription it was about building your career on top of a tool. Subscribe to it, rent it, lease it, buy it, I don't care. Don't build your career off of a tool. Don't use it as a foundation. Build your career off of things like problem solving, understanding engineering principles. Tools can change, IDEs are way better than when I started development. I've used several different IDEs over the past 20-30 years. They change all the time, and they have had **zero** impact on my career.
I don't think JS is associated with any animal or symbol aside from the yellow background/black letters JS logo.