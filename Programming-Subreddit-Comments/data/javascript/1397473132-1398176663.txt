Prototype is nice for those cases where you'd want to create many instances of a class, or where you feel like having an extendable class. But in any other case, where you just need one instance for a specific task, JS's object shorthand is much more convenient: var nameHandler = { names: [], add: function(name) { this.names.push(name); } }; [edit]: AndrewJM also has a point, with prototypes your code can be a nice and flat list of components that can be included as you go, where it otherwise might be a messy hierarchial thing stored in one big blob. Whichever you choose, make sure to read through [this article on objects and variable scope](http://javascriptplayground.com/blog/2012/04/javascript-variable-scope-this/) to avoid some object-associated headaches.
What does this do? 
jQuery is a library for working with HTML/DOM, 'prototype' is core language feature, they can not be compared.
Is this a current version of chrome? I'm assuming this is on Windows? It's likely that Flash wasn't installed successfully in Chrome but was in IE, which is why that works. Try reinstalling Flash.
And, again, a javascript error is a coding error on the part of the web site. Browsers don't run on javascript. They only execute what's given them by the web site. Also, Java is not JavaScript, and is unrelated in any way, shape or form.
Thanks for clearing up which 'prototype' you mean. And yes. It's definitively worth it. As mentioned in my other comment, it's really not that hard to start using. One of the most popular MVC frameworks for JS Backbone is relying heavily on it. That's how they can achieve their small codebase. Their source code is pretty well documented: http://backbonejs.org/docs/backbone.html If you care to brush up on your JS in general. There are some excellent articles on http://superherojs.com. From the more conceptual to the 'you should probably do this' articles, it's all there.
I assumed the OP meant [prototype.js](http://prototypejs.org/)
How did I not know about this?
Works in IE10 and seems like an awful, awful idea. Looks like IE did it originally, and other browsers copied for compatibility. Ugh.
Related =&gt; http://www.reddit.com/r/webdev/comments/2023ex/windowclusterfuck_a_tale_of_global_variables/
nope.
So what happens if a page has a tag with an ID that's in use by a global JS variable already? Who takes precedence?
I just tested it and it works in IE8.
This may be the grossest thing I've learned about Javascript. I love js, but this is egregious. 
Who the hell thought that this was a good idea?
Thanks for the post, didn't know about that. And, its f'ing terrible. Preceding any id with a "id_ somename" seems to be a good idea, just to create a "id_ " namespace of some sort. 
Eich, apparently... **edit** I stand corrected. Looks like MicroSoft is to blame.
Is this actually in the standard? I guess we can give Eich a pass, since any language designed in a week is likely to be pretty awful.
See the rest of the comments. It looks like this one is actually on MS.
&gt; Surely there would be a great potential for conflicts, right? And that is why no one actually does this. If you do, stop right now. This is a horrible horrible practice to follow.
I probably was better off not knowing.
Internet Explorer gave us this. But it also gave us XmlHttpRequest. So you gotta take the good with the bad.
**This is NOT Javascript. This is the web browser.** One very common misconception that many programmers have is confusing the web browser for the programming language Javascript. This doesn't happen in other places javascript can run because they aren't web browsers. And yes, you can blame IE for this. This started long ago, maybe IE4 or IE5, I forget it's been so long. Some modern browsers have adopted this behavior. All too often when people say they hate Javascript, what they really mean is they hate the web browser API and the things that come with it. Many don't understand the distinction between the language Javascript and the environment in which it commonly runs - the web browser. 
In the old days, that's how people used IDs: yourformid.submit(); . Easy, no need for a huge document.getElementById() call. The jQuery proliferation has created a whole generation of webdevs who never used these aberations and will one day lose hours on a bug created by a &lt;div id="form"&gt;&lt;/div&gt; hidden in their HTML.
This, this, this. Seriously, everyone pay attention to this.
While you're obviously 100% correct, I don't find it to be a *terribly* valuable distinction to make. 90% of JavaScript that has ever been written is for the web browser. So much so that until Node, 'JavaScript' was practically a synonymous short-hand for the web browser's JavaScript. The post is exclusively about web browser JS, so while JavaScript isn't at fault for this, it's (for these practical purposes) a synonym. 
Also a bad idea. If it HAD to be done, I'd say using # to preface would be the smartest way to go.
Which filesystem would it be accessing? The one in the client or the one in the server?
What is this "global variable" you speak of? How have I been writing JavaScript all these long years without using these wonderful devices?
Because it's a very bad practice that can lead to unexpected results if you're not careful, particularly if you accidentally left the variable undeclared. Always declare variables with `var` before you use them and this won't happen.
OMG... Who ever thought that this would be a good idea? I found out that it also works on nested divs... http://codepen.io/anon/pen/dCqec
&gt; egregious I think that using that word is egregious 
Unless it's a DOM event handler, in which case `this` refers to the DOM element.
I mean, as a user of JS, preceding each id with an "id_ " could be a way to get around this rediculous thing. It's still not good behaviour on JS's part, but at least it gives you as a JS user some safety to not accidentially contaminate the window name space.
this needs to be higher. I'm sure quite a few people would like to disable this "feature" by default
Ah, I see! :)
 &gt; ~~var~~ a,b,c,d,e,f,g,h,i,j,k &gt; &gt; ~~var~~ last,next,token,uuid,seq FTFY, much more global now. 
&gt; Stop setting HTML id attributes? I never advocated to stop using the id attribute. I said you should not be directly referencing it in javascript, even if it lets you. i.e. use document.getElementById() instead.
In case this wasn't clear to anyone, this is a very old "compatibility" feature that should **not** be relied on. It might work pretty much everywhere but is not standard, and it's also just plain ugly.
&gt; Some modern browsers have adopted this behavior. works in the web dev tools console on latest chrome. is this a global variable, or a shortcut?
Ah, that wasn't clear. And you still have to deal with the conflicts that the GP comment was worrying about. The full answer is that the best practices around keeping the global namespace clear are not just academic – shit can and will show up in unexpected places. 
most undoubtedly, yes.
It was invented by IE. Firefox, Opera and Chrome implemented the same behaviour so they would work with badly written IE-only web pages.
&gt; It's still not good behaviour on ~~JS's~~ [the browser's] part 
`'use strict'` still allows at least some of the stupid to pass through: [example](http://codepen.io/anon/pen/zfgHe). "Always declare all variables at the top of your scope" would fix this, but in this case `'use strict'` won't enforce that.
Exactly wrong. It was the way JS *used* to work, before W3C APIs like the DOM interface were designed and supported and we got built-in functions like getElementById() and getElementsByTagName(). Also, IIRC IE was also one of the (if not *the*) first to implement it, and then other browsers followed suit. Modern browsers support it now only so legacy code continues to function.
How do you know you're old as a web-dev? When youngsters and newbies breathlessly post about legacy features they've just discovered that have *always been* part of the JS browser API for as long as JS has been in browsers.
Yeah it's still annoying that Mozilla went that route and that everybody followed. Microsoft implemented the functionality to add fancy features to Outlook Web Access. But they did it with ActiveX so it didn't have a proper name in JavaScript. It was called an XmlHttp object because it was part of the XML lib and was built to get XML data used by Outlook Web Access. Then Mozilla had to come along and decide "Hey, this kind of functionality is great, lets make something called XmlHttpRequest so that people can use it for lots of stuff, including but not limited to Xml!" Even Microsoft standardized to what Mozilla picked.
Indeed. Very short-sighted naming convention.
Damn, I was 100% sure that strict mode prevented these shenanigans. WTF everyone.
s/in browsers/in Internet Explorer/ Though I guess it was in IE3... But hey, at least we don't have document.layers anymore, right? Remember that?
Mozilla only just [added it in 2004](https://bugzilla.mozilla.org/show_bug.cgi?id=256932), same year that they added the document.all support.
Haha, thanks! Sorry for the late reply, we had spring break this week. I'll PM you the code that I made right now.
Fair point, though it's worth noting that that's still two or three months before Firefox 1.0 was even released. I exaggerated slightly claiming it had "always been in browsers" rather than "always been in IE", but it's always been a known aspect of web-development that deva had to bear in mind - first of all because one browser with 50% market share did it, then because that browser killed the other and achieved 96% market share, and subsequently because *all* major browsers then did it. 
No, you can't just do this. First, [underscores are technically forbidden in CSS id names](https://developer.mozilla.org/en-US/docs/Underscores_in_class_and_ID_Names), so you can't preface with `id_`. More importantly though, it's the tail wagging the dog here. You can't expect that the coding conventions of every webpage your scripts might operate on (including your own pages, for the parts managed by FE buildout teams) will change to accommodate a cleaner global scope for your JS. It's entirely unreasonable to tell the CSS people "you have to reference everything by `#id_foobar` – especially given that that's syntactically incorrect CSS. But even with `#id-foobar`, it's overstepping for you to dictate this. That you propose this broken CSS is illustrative of why it's unreasonable for you to impose coding standards on other dev teams. It also doesn't address the issue that the JS global namespace can be polluted from many different sources that you will not be able to control. Almost any seemingly trivial change to a webpage in the future can cause changes to the JS global namespace. The correct response to this standard HTML behavior is to never rely on names in the global namespace, as far as is possible, and to understand that this is a source of potential bugs on an ongoing basis, even after the JS is finished and shipped. 
I'm on the fence. Yours is clearly the pragmatic response, but I can't help but think adding a ton of global variables to an application is a good idea. I've been class-only for a while in theory but I think I'm going to be class-only in practice now too.
&gt; "Always declare all variables at the top of your scope" would fix this What you mean? You mean I should do var whoa; ?
quirks mode, say thanks to ie
This is in every browser...
worth watching even for the Batman joke alone
&gt; First, underscores are technically forbidden in CSS id names, so &gt; Last Updated Date: Published 05 Mar 2001 Major frameworks like Django use "id_ " prefixes, so I guess between 2001 and today, browsers may have changed a little. Also, what I said was more of a "workaround" than a "solution".
Or unexpected conflicts, methods and definition out of the blue and everything...
Won't actually make any difference where you declare it because of hoisting: ``` var hello = 'world'; (function () { console.log(hello); // undefined var hello; })(); ```
One possible improvement I would suggest to the writing is to avoid using the word "scope" to describe the `this` binding. I've known people who have started to think that the lexical environment and the `this` binding are the same thing. I suspect that confusion came about because too often we use the word "scope" to describe both concepts.
The problem is you're using regex to validate a numeric value. [`parseFloat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat) on the value, and compare it to 7.25.
As you'll note if you read even that same old document, it's always worked in most browsers. People have been writing invalid (HTML|JS|CSS) from day one. That doesn't make it a good practice, and the broader point is in the cross team workflow issue – and subject matter expertise – your workaround misses. 
Ok, guy with a blog likes how underscores look. As ever on the web, just because it works when you load it in Browser X (or in this case, pretty much every browser ever, as noted in the MDN article) doesn't make breaking the rules a good general practice. 
I've changed it to Parsefloat (), but not luck even worst -- var regx = parseFloat('7.25'); -- sorry if it's wrong I'm a newbie in this 
Strict mode only applies to the JavaScript file or function it's turned on for. The global variables are created by the HTML, not by the JavaScript file.
It fakes a file system using [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) Well, it uses [level-js](https://github.com/maxogden/level.js) to simulate [leveldown](https://github.com/rvagg/node-leveldown) API for IndexedDB, it's basically a wrapper around [level-filesystem](https://github.com/mafintosh/level-filesystem) which consumes this API (through a few other abstraction layers).
Notice that the 2004 patch was quirks mode only. They only added it to standards mode much later.
Don't use a regex to validate a numeric value.
That's the thing, it was talked about a long time ago. Everyone agreed it was shitty and 90% of developers avoided using it. I have no idea why this behavior still exists in 2014 but I can only imagine it's some weird backward compatibility reasoning. Now it's 2014 and this long dead "feature" is simply being *re-*discovered.
&gt; All too often when people say they hate Javascript, what they really mean is they hate the web browser API and the things that come with it. Many don't understand the distinction between the language Javascript and the environment in which it commonly runs - the web browser. I don't think so. I fuckin' love browser APIs. For all the warts, browser APIs are where the magic happens and there's usually a library available that abstracts a particular API's problems. What I and probably many others *do* hate about javascript are actual wat-worthy language features that are like little time-bombs designed to enrage otherwise competent coders who aren't versed in unexpected behaviors of ==, +, etc. After stepping on a lot of mines and learning from my mistakes, I'm finally coming to the place where my all-hate relationship with js is finally becoming a love/hate one. I'm striving for full javascript enlightenment, but it's a long road.
Moot. His var definitions weren't inside a function so it doesn't matter.
For a robust code example, you want to make sure it will work no matter what context someone cuts/pastes it into. An unsuspecting reader could easily have dumped that stuff into a function body and missed out on the global feature's benefits. 
The advanced items seem too easy.
 element.addEventListener("click", function () { console.log(this === element); // =&gt; true }); Which is sugar for: element.onclick = function () { console.log(this === element); // =&gt; true }; So yes, the above rules apply perfectly well. 
Not really possible, from the JavaScript side of things. What's to stop a library disabling it when your code relies on it? And then if a library uses it, what'll happen if you disable it?
I discovered you can't do `delete window.foo` and the ID properties don't show up when you iterate over the `window` object either. This suggests to me that the browser does a special kind of lookup for the DOM element at the time you access the property. The solution I came up with to clear this garbage out is [this](http://codepen.io/Chevex/pen/trpeg/), using a little JQuery. Just set them all to `undefined` :)
I'm not the author of this article—this would be better left as a comment on the article itself.
 var data = parseFloat($(this).val()); if (!isNaN(data)) { $('.result').addClass((data &gt;= 7.25) ? 'over' : 'under'); } don't use .css() to change appearance, make a class
I think you meant "isn't" a good idea lol. Anyway, do [this](http://codepen.io/Chevex/pen/trpeg/) if you're that concerned.
Yes, bind returns a new function. call and apply try to modify the context of an existing function if you want to be pedantic about it. :) So here's some pedantry right back atcha. obj.fn.bind(other) obj.fn() =&gt; this refers to other, not obj Actually wrong. obj.fn.bind(other) =&gt; function () { [native code] } //No assignment so the value of obj.fn is unchanged obj.fn(); // =&gt; this refers to obj //If you did var boundFn = obj.fn.bind(other); boundFn(); // =&gt; this refers to other //But if you do this, you should be slapped with a wet sock boundFn.call(obj); // =&gt; this still refers to other 
If you're still using .match to check it, you're doing it wrong. Your code should look like: ``` if(data === '' || parseFloat(data) &gt; 7.25) ```
If you want to know more about this, see http://kangax.github.io/domlint/ for more horrors. It's not just about global variables, it's about standard DOM properties and their name conflicts. Don't ever name a form field something like `id` or `nodeType` because eventually, something will break somewhere inside your code. It doesn't matter if you use jQuery, such is the cruelty of this problem that it reaches out to sully the things you hold most dear.
I still remember the awful day I discovered this behavior. I found some production code that looked like this (heavily simplified): function setContent(html) { foo.innerHTML = html; // do more stuff with foo } It *worked* but I couldn't figure out why -- the code didn't declare 'foo' anywhere, so I expected it to throw a ReferenceError. But of course, the developer who wrote it just happened to have added an HTML element to the page markup having id="foo", and it happened to be the element they were trying to reference. So it was equivalent to a hidden **foo = getElementById("foo")** statement at the top of their code. I flipped out. FWIW, it's easy to identify errors like this if you strictly follow the JSHint pattern of declaring all the global variables your code uses in a block like this at the top of the file: /*global $ foo bar */ Then the linter can statically check every variable reference in your code, and flag anything that doesn't resolve to an in-scope symbol. It will identify "foo" in the code I posted above, and it regularly saves my ass from misspelling variable names and stuff like that. Lexical scope is the only kind of reference you can easily check with static analysis in JavaScript, so use it often! **Edit:** formatting
Type coercsion in javascript isn't as mysterious or problematic as most seem to think it is. It follows a simple pattern and is predictable so far as your knowledge of it is concerned. To hate javascript is to not be a master of it, but that seems to go for most languages. So stop hating and learn it. Browser APIs on the other hand are sometimes painful when they don't behave the same, and even with abstraction there are often missing features across different browsers and varying levels of bugginess. The same is not true for javascript - at its core, it runs the same on every browser without exception. Just try doing any advanced work with SVG, or webfonts across browsers and you'll run screaming. There are no good abstractions that will normalize font rendering across all browsers - it's a nightmare.
yeah with passport.js I used it to build www.rubbercat.info
Browsers are in a sorry state for app development. Luckily, JavaScript provides mechanisms for guarding against atrocities such as the one described here. I guess what I'm saying is that a best practice is to ignore the global environment (except for libraries). In light of this, the browser creating global references to nodes isn't a big deal, since I would never write code to depend on it. That being said, I'm still crying on the inside about this. 
i changed from using ID's to only using classes 3 years ago and i couldn't be happier, IDs are just a mess
&gt; Surely there would be a great potential for conflicts, right? Long story short, so long as you always declare new variables with *var* the first time you instantiate them, it'll silently override the equivalent DOM ID if it exists. thus they'll never conflict so long as you don't have any improperly declared variables. Hence why most people don't encounter any issues with this.
http://codepen.io/anon/pen/oyjuh &lt;-- Its at least on the window.
why not?....it works great 
thanks, it should be &gt;= tho, if i make that change it works like it should
In Dart, it's `HttpRequest`. I really like that they cleaned up most of the DOM API. E.g. it's "innerHtml" instead of "innerHTML", all those list-like things are actually lists, and so forth.
Checkout Marionettejs doc built with gitbook
- mongo - mongoose (orm) - express - angular - node - gulp Also zeptojs is nice to use sometimes.
Yes, I just installed it other day and have uninstalled and re-installed it multiple times thinking that might fix my issue, I'll look into flash, but last time website said it's integrated into chrome and latest.
There is no good answer to your question. I have found that the field is too diverse now and to have a full understanding of the field you need roughly 10+ years experience or PhD equivalent education dedicated to the field. I know this sounds completely absurd, but there are a couple of reasons for it. The best thing you can do is to get to know the company, your prospective team, and your interviewers. I know this is hard, but do it anyways. Find out if there are certain technologies or tools they favor. Discover if they are an Agile shop, or what their planning schemes look like. Discover if there are patterns or frameworks they favor. You will have to talk to people to discover what best to study in advance. Personally, I have been doing this a while, and so I no longer care what is important to the interviewer. I am an experienced technician and either I am a good fit or not. For instance if a team is dedicated to using jQuery UI for absolutely everything (because they are Java developers who fear the DOM) and I were a vanilla JavaScript fanatic I would gladly fail out of the interview. Experienced developers are so desperately in demand that if I fail to fit the culture of one team there are several more on standby waiting to interview me. The demand is crazy high, and I don't even live in the bay area or anything like it. If you **REALLY** want to look prepared extremely (unnecessarily) pump your confidence then go the extra 1000000 miles by studying these concepts and knowing them well: * accessibility * semantics * security * privacy * MVC * test driven development * QA automation * algorithms * parsing strategies * data transmission/encapsulation * data analysis * data service integration (mashups) * XML (Schema) * markup language design * namespaces and translations * all the latest and greatest of HTML 5 (even though nobody is using it yet) * vanilla JavaScript * JavaScript design patterns * OOP in JavaScript * lexical scope (closures) in JavaScript without any OOP * native DOM * jQuery * presentation (CSS) * node.js * grunt * npm/bower * git/svn * Angular/Ember/Backbone/Dojo (you can just pick one and be just fine) * progressive enhancement vs graceful degradation Keep in mind that mastering all these topics will allow you to cover most, though not all, the topics that could arise in your interview. You should expect, however, that your interviewer will not care to ask you about most of those. **TL/DR** Don't cram. You know what you know. Just do your best and be confident in your current level of performance.
* [react](http://facebook.github.io/react/) + [backbone](http://backbonejs.org/) - backbone for collections/routing, react for templating/logic. * [greensock](http://www.greensock.com/) - easy to use animation, powerful, flexible. * [express.io](https://github.com/techpines/express.io/tree/master/lib) - combines express/socketio * [node-webkit](https://github.com/rogerwang/node-webkit) - desktop apps * [phonegap](http://phonegap.com/) - mobile apps Edit to edit.
Angular has really grown on me. I've started using it more and more recently, and it offers a lot great features. For anyone who isn't familiar, [AngularJS in 20ish Minutes](http://www.youtube.com/watch?v=tnXO-i7944M) from this year's NG-Conf might be worth checking out. 
Also then all of the styles are in the same place, so when you have to change a color the day before the site goes live (this does happen) you only have to look in one place.
Raised one issue, thinking up enhancements already. Keep up the good work. 
Oh I see. I always imagined that document.getElementById would crawl through the DOM recursively or something until it found the tag with the given id. Now everything makes sense
Considering that 80% of my work at the moment is all front end my go to stack is * Angular JS * [Cordova](https://cordova.apache.org/) * Bootstrap And when i have to venture to the server i use C#. 
Sorry for the ignorance
I think it does exactly what it should do. :) I think people often forget the useful thing about Function.prototype.bind isn't to change the context of a function, but to partially apply one.
ini_set('register_globals', false); I think I have to cry now. 
This is actually standardized in HTML5 http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#named-access-on-the-window-object
I WIN!! This game was absolutely awesome, last 3 levels and boss were amazing. I really want to hear other people's solutions, but don't want to give anything away.
Since this has been already successfully answered, I'll just leave this: "Some people, when confronted with a problem, say 'I know! I'll use regular expressions!' Now they have two problems."
So from an optimization standpoint should this feature be utilized? No human should be writing this code because of the potential for conflicts but an an optimizer could replace all the `document.getElem...` by their global variable equivalent because the browser is going to create them anyway, it might as well use them.
I am a fan of [LEBRON](http://lebron.technology/): LEveldb, BROwserify, Node/npm. It's a slam dunk. Aside from those, I just use lots of very tiny modular libraries. When I need to serve static files, I use [ecstatic](https://npmjs.org/package/ecstatic). I like sticking to ordinary html and use [hyperspace/hyperglue/trumpet](http://substack.net/shared_rendering_in_node_and_the_browser) to do that in node and in the browser. It plays particularly well with leveldb and [streams](https://github.com/substack/stream-handbook). For realtime, it doesn't matter so long as it gives me a stream. [shoe](https://www.npmjs.org/package/shoe), [engine.io-stream](https://www.npmjs.org/package/engine.io-stream), and [websocket-stream](https://www.npmjs.org/package/websocket-stream) are all good and very interchangeable. For task automation, I like using the ["scripts" field in package.json](http://substack.net/task_automation_with_npm_run), augmenting with node or bash scripts where necessary. For tests, [I like tap/tape](http://substack.net/how_I_write_tests_for_node_and_the_browser). Here are some dream-team LEBRON resources: * [levelmeup on nodeschool](http://nodeschool.io/#levelmeup) - interactive leveldb tutorial * [level me up scotty](https://www.youtube.com/watch?v=41oDDTRWjIQ) - live coding talk by juliangruber where he creates a complete leveldb and browserify application from scratch in 17 minutes * [browserify articles](http://browserify.org/articles)
LEBRON is the best. Made http://jsw.bestofjs.com with it and it was awesome.
No neat acronym for it, but here's my choice: * [CouchDB](http://couchdb.apache.org/) - easy to use document store with a changes feed * [Engine.io](https://github.com/LearnBoost/engine.io) - hook the changes feed up to this and get a realtime connection from your db to your front end. * [Atomify](http://github.com/atomify/atomify) - use components with css, templates, and JS from npm (and not from npm too if you need private modules). Optional: * [Ribcage-ui](https://github.com/Techwraith/ribcage-ui) - client side view management * [Backbone](http://backbonejs.org/) - for models, collections, and routes
agreed, also: - if you want to share code a la JSFiddle: [RequireBin](http://requirebin.com/) - if you want a development server built for browserify: [beefy](https://github.com/chrisdickinson/beefy) - if you want a browserify project generator: [kindling-browserify](https://github.com/ahdinosaur/kindling-browserify) - if you are using WebGL: [modules.gl](http://modules.gl/) - if you want to add CSS / LESS to browserify: [cssify](https://github.com/davidguttman/cssify) / [lessify](https://github.com/dstokes/lessify) - if you are using real-time sockets: [primus](https://github.com/primus/primus) - if you are using React, a promising set of modules with similar functionality: [mercury](https://github.com/Raynos/mercury)
Meh... `modules.gl` is a nice idea but the code is really ugly and doesn't really get rid of most of the annoying boilerplate that necessitates a GL wrapper in the first place. And as soon as you need context management, asset loading, or anything remotely high-level, you're gonna have a bad time. Then again, [I'm pretty biased](https://github.com/mattdesl/kami)..
If you think that is bad, try this one in IE http://codepen.io/anon/pen/DCouE It uses the "name" attribute of input fields as global vars also... /facepalm
Sometimes DHTML and Flash
I get what partial application is, but there we have different philosophies. `this` is a different mechanism from the formal parameters, and I think that mixing them together in one mechanism is a poor design, and I think that using a method instead of a function for partial application on either axis is a different, but equally suspect paradigm. These are my opinions, that's all. p.s. in my own code, I use functions for both, with the partial application function not binding `this`, and I have hard- and soft- binding functions that only bind `this`. I suspect it's my own myopia, but I have never needed to bind `this` and simultaneously bind formal parameters.
i don't have experience with Level* (i know i should make time to explore it, thanks for highlighting a couple of resources, i will try to look at them), i've been using camlistore.org recently (https://github.com/bradfitz/camlistore) it's a very `lightweight` content addressable object store with a simple CLI, it just stores whatever you pipe/stream at it, and returns a unique key if you want to retrieve it later, you do need to take care of managing some sort of index for your app but i think it's nice because of it's simplicity. browserify/watchify has been my primary build tool for a while now, i used beefy before but don't need it now (i use watchify), i'm used to doing integrated client bundles served by node.js, having that continuity in the codebase just makes the actual coding process flow that much easier :) agree with substack on the npm run scripts, with new projects i normally have at least 4 npm run scripts configured (watch,build,test,clean). i guess my stack could be called `CAMBRON` but i don't wanna start any trouble ;-)
Thanks for the feedback. The difficulty level is more or less arbitrary. I will shuffle posts around based on the feedback. Some topics under intermediate section, could probably come down into the beginner section. Posts themselves are subject to change and I encourage others to participate, if not by contributing, at least by mentioning how can I improve a particular post.
* Angular scaffolded with Yeoman * Rails API 
Hi! I'm the author of some of the packages that have come to be called modules.gl. I'm not really sure about what you mean by not getting rid of WebGL boilerplate, but the original reason I wrote those modules was to streamline some of the low level and tedious parts of the WebGL interface without changing the core semantics or functionality. This came out of frustration with frameworks like THREE.js and even lower level libraries like lightgl, precisely *because they did not allow the sort of control that I wanted in my own projects.* If you want a framework or something like three.js, you can just build your own library on top of it (or even just use three.js! It has a ton of stuff built in), but that isn't really the whole point of the project. The idea is to factor out all of the orthogonal things like asset loading, materials, scene graphs, different geometry formats, and so on so that you can handle those with whatever module you think is appropriate. For example, if you want to load PLY files you can just grab [something off npm](https://www.npmjs.org/package/parse-ply) to take care of that. Each of the parts of gl-modules is small enough and independent so that you can pick and choose whatever you like and ignore the rest if you want. It does not lock you into some gigantic codebase with inertial development.
It's in the specs. http://www.w3.org/TR/css3-selectors/#id-selectors http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier Secondly, if you don't support IE6, your identifiers can start with an underscore and you won't have to escape them. You aren't breaking any rules if you use underscores in your CSS identifiers.
taking this bit further, this is the only thing missing in html5... naming your own elements. I know a JS script which let you do it. i.e &lt;mypara&gt;&lt;/mypara&gt;but it should be rather builtin.
pfffttt.. we've all been told to use var before. hey kids, use var. 
http://eleks.github.io/js2js/ :p
* lib: RequireJS, Backbone, Underscore, jquery * test: jasmine, jslint * build: grunt + various grunt plugins * design: compass + bootstrap-sass
The name itself is inconsistent: XMLHttpRequest. The first initialism (XML) is in all caps but the second one isn't (Http).
Here's a site where you can find out about upcoming JS conferences throughout the world: http://lanyrd.com/topics/javascript/ Also, I'd strongly recommend checking out meetup.com. Not quite the same as a conference, but you'll get to attend a lot of great events for little to no cost and they can be far more accessible than conferences.
Definitely agree there. I prefer to just modify Function.prototype with a curry function for partial application. The conflation of context manipulation and partial application is indeed a strange design choice. But I very very rarely find myself needing to change the context of a function in my own code. Just a style preference, but I prefer behavior which operates on state rather than state that also happens to have behavior tacked on. Honestly whenever I use `this` It's most likely because I can't avoid it due to some API, or I'm referring to the global object for some reason.
JSConf 2014 will be in Florida at the end of May. http://2014.jsconf.us I went last year and am going back this year. Good selection of speakers, lots of breakout sessions, and a day 'off' to enjoy the outdoors or hack on some node copters.
Egads. So many different mentalities, and so much reliance on unproven technology. So much reliance on node.js, which doesn't even have a stable release version yet. So many different document stores. Does anyone here work with more than just themselves? It's worth considering that what's popular may not be what's best. From my personal standpoint, it is frustrating to see projects churned out from one source written with their arbitrary list of libraries, databases, templates, frameworks, etc. It takes time for others involved to digest just what is going on in a project when nothing is static in webdev. OP's purpose with this post is to see what developers commonly use, yet clearly there is no consensus. Why is the popular opinion to keep using whatever is hot and new for every project? It's not possible to keep up with.
http://en.wikipedia.org/wiki/Flash_of_unstyled_content
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Flash of unstyled content**](https://en.wikipedia.org/wiki/Flash%20of%20unstyled%20content): [](#sfw) --- &gt; &gt;A __flash of unstyled content__ (__FOUC__) is an instance where a [web page](https://en.wikipedia.org/wiki/Web_page) appears briefly with the browser's default styles prior to loading an external [CSS stylesheet](https://en.wikipedia.org/wiki/CSS_stylesheet), due to the [web browser engine](https://en.wikipedia.org/wiki/Web_browser_engine) rendering the page before all information is retrieved. The page corrects itself as soon as the style rules are loaded and applied; however, the shift is quite visible and distracting. &gt;The aberration, called FOUC, was documented in an article named *Flash of Unstyled Content*. At first, FOUC appeared to be a browser problem unique to Internet Explorer. FOUC behavior has also been documented "as a Safari epidemic..." &gt;FOUC is indifferent to changes in [CSS](https://en.wikipedia.org/wiki/CSS) or [HTML](https://en.wikipedia.org/wiki/HTML) versions. The problem appears to originate from a set of priorities programmed into the browser. As the browser collects HTML and all the ancillary files referenced in the markup, the browser builds the [DOM (Document Object Model)](https://en.wikipedia.org/wiki/Document_Object_Model) on-the-fly. The browser may choose to first display what it can parse the quickest, namely the text. &gt;==== &gt;[**Image**](https://i.imgur.com/wR4Y3Y0.png) [^(i)](https://commons.wikimedia.org/wiki/File:Wikipedia_FOUC.png) - *FOUC when loading Wikipedia's main page.* --- ^Interesting: [^Web ^browser ^engine](https://en.wikipedia.org/wiki/Web_browser_engine) ^| [^Unobtrusive ^JavaScript](https://en.wikipedia.org/wiki/Unobtrusive_JavaScript) ^| [^Angelina ^Love](https://en.wikipedia.org/wiki/Angelina_Love) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgsskn1) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgsskn1)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Sorry if that came off the wrong way. I think your libs are good for low-level GL programmers who want to build more modules, and eventually a framework or engine for a 3D game. But gl-modules is extremely low level, and probably not the kind of thing you'd be using directly for your next game or WebGL app (as the above poster implied). Particularly if you aren't already proficient with OpenGL ES and it's various quirks. I'm curious if you have plans to build some sort of context management on top of gl-modules. I found it to be a [real challenge](https://medium.com/p/cebd176c281d) when writing kami. Context loss also ties in strongly with asset management, and tools that consider this from the ground up often seem better suited to handle it. 
You just noted an incidence of convergence around node followed by a complaint about a lack of consensus. The thing about node and particularly the ecosystem surrounding npm is that it [explicitly embraces dissent](http://blog.izs.me/post/69091089622/the-hazards-of-consensus). So instead of bickering over "the best way" of doing things that is always going to be an unpleasant political battle over [trivial but necessary details](https://en.wikipedia.org/wiki/Parkinson%27s_Law_of_Triviality), the node way of doing things takes a step back, admitting that people will always disagree on some things but perhaps we can all live together in harmony anyways if we embrace certain more fundamental tennants of modularity and reuse that will give us a basis to more productively disagree. Complaining about too much quality free and open software is a bit like complaining that there are too many books and that nobody could possibly have the time to read all of them. It is the reality that we live in and it's wise to adopt tactics that take this into consideration.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Parkinson's Law of Triviality**](https://en.wikipedia.org/wiki/Parkinson%27s%20Law%20of%20Triviality): [](#sfw) --- &gt; &gt;__Parkinson's law of triviality__, also known as __bikeshedding__ or the __bicycle-shed__ example, is [C. Northcote Parkinson](https://en.wikipedia.org/wiki/C._Northcote_Parkinson)'s 1957 argument that organizations give disproportionate weight to trivial issues. Parkinson demonstrated this by contrasting the triviality of the cost of building a bike shed to an [atomic reactor](https://en.wikipedia.org/wiki/Nuclear_reactor). The law has been applied to software development and other activities. &gt; --- ^Interesting: [^Parkinson's ^law ^of ^triviality](https://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality) ^| [^C. ^Northcote ^Parkinson](https://en.wikipedia.org/wiki/C._Northcote_Parkinson) ^| [^Business ^plan](https://en.wikipedia.org/wiki/Business_plan) ^| [^Parkinson's ^law](https://en.wikipedia.org/wiki/Parkinson%27s_law) ^| [^Sayre's ^law](https://en.wikipedia.org/wiki/Sayre%27s_law) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgst9uv) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgst9uv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Strawman. This is my position: &gt; It takes time for others involved to digest just what is going on in a project when nothing is static in webdev.
That sounds great. There are always new ways of doing things better all the time coming along to replace the older, cruder ways. This is called progress and is somewhat fundamental to the human project of technology.
&gt; So much reliance on node.js, which doesn't even have a stable release version yet. Not having a 1.0 is not the same as not having a stable release version. Node is far from "unproven".
No, and I don't think it is actually possible to implement safe context loss recovery in general. Any approach to this problem must take into account a large number of situation specific issues that don't make sense to try to automate. Probably the best solution that I know of is to just make the state of the application persistent, and have a mechanism to gracefully reload the page.
* Task automation: [Jake](https://github.com/mde/jake) (But most people prefer [Grunt](http://gruntjs.com/) or [gulp.js](http://gulpjs.com/)) * Linting: [JSHint](http://www.jshint.com/) * Dependency versioning: [npm --ignore-scripts](http://www.letscodejavascript.com/v3/blog/2014/03/the_npm_debacle) * Continuous integration: [test *before* merging](http://www.jamesshore.com/Blog/Continuous-Integration-is-an-Attitude.html) * Node.js testing: [Mocha](http://visionmedia.github.io/mocha/) and [Chai](http://chaijs.com/) * Cross-browser testing: [Karma](http://karma-runner.github.io), [Mocha](http://visionmedia.github.io/mocha/), and [Expect.js](https://github.com/LearnBoost/expect.js/) * Smoke testing: [CasperJS](http://casperjs.org/) * Front-end modules: [Browserify](http://browserify.org/) and the [Karma-CommonJS Bridge](https://github.com/karma-runner/karma-commonjs) [Reasoning and more details here.](http://www.letscodejavascript.com/v3/blog/2014/03/dependency_recommendations)
I disagree. The fact that defining variables without var makes them global is awful. The fun stuff that happens with type coercion is also ugly to the max. And what about the silent errors that make the JS VM just stop? For example, in some circumstances, a function call like foo.bar() will cause just that. Sometimes an exception is thrown, and if not caught, will cause the VM to stop, so you gotta surround a lot of calls with try-catch blocks. Sometimes, not even that helps! After having to deal with the pitfalls of dynamic typing in general and Javascript in particular, I am *very* glad to be using C and C++ again. Yes, you read that right. I prefer these two any time over any dynamic typing language. Even with C-style casts all over the place. Even with the obtuse C++ syntax.
You. I like you.
&gt; Note: I am going to use CoffeeScript in this post to make it difficult to read examples for the vast majority of visitors. Alright.then();
I wish strict mode would make using the '==' operator a syntax error. edit: so I'm just wondering why I was downvoted. Am I wrong? Is that a controversial thing to say?
- Node - Restify - Marionette - Browserify Goto isomorphic modules: momentjs and async Persistance (not js) Redis + LUA never fails me
&gt; But all-in-all, JS is a delightful language. Maybe *now* it is...
I used CoffeeScript because I would have gotten RSI from writing `function` hundreds of times :) Plus I lay out my reasons [here](http://maori.geek.nz/post/why_should_you_use_coffeescript_instead_of_javascript).
Hahah. I read that as "This is called Postgres..." like five times.
I love live coding videos. Are there any other good ones that you know of? Or somewhere I could find more? 
To be fair, if JS isn't essential for the core content/functionality of your site, that one's still a good idea for reasons ranging from SEO/spiderability to accessibility to good architecture to device agnosticism to proper separation of concerns. It's just that a generation of newbie developers has got all excited about trendy client-side javascript frameworks and are now busily abusing them to build even things that should more properly be done using the "boring" old traditional, industry-best practice and battle-tested approaches (like good old server-side rendering and progressive enhancement)... just like they did back in the day with CSS absolute positioning, tables-based-layouts, flash-only websites and (going back far enough) putting text in images. All those techniques were touted at the time as the new trendy thing and gleefulyl employed by naive or inexperienced but overconfident devs - usually to a soundtrack scored for a thousand variations of "fuck your dusty old architecture, grandad!" - and *every single one* was subsequently proven to be exactly what the boring, experienced and professional developers had been saying all along - appropriate and even highly useful for specific uses and certain edge-cases, but generally sub-optimal or even a flat-out *anti*pattern for the vast majority of websites and content you want to deliver over the web. The part that gets me is that *even Twitter* - who were the absolute flag-waving vanguard of client-side JS apps, and the one shining example that everyone pointed to to demonstrate that 100% client-side JS was the Right Way To Do Things Now - ended up tripping over their own dicks and were [forced into a humiliating climbdown and a re-implementation of their entire site back to using server-side rendering](https://blog.twitter.com/2012/improving-performance-on-twittercom), because they eventually realised that client-side rendering *wasn't the right architecture* for content-based web systems... ... and overnight people stopped holding up Twitter as a great example of why it was right, but *never bothered to re-evaluate their belief* and learn the lesson that Twitter should have taught them. Mark my words - in a few years people will look back on catalogue sites, blogs and forums implemented entirely in client-side JS the way people now look back on Flash-only "websites" or tables-based layouts.
:I
Indeed, I remember finding about this two to three years ago and back then Mozilla didn't yet do this. I cannot believe everyone adopted this approach instead of MS removing it from later IE versions...
You're just adding salt to the would. Recklessly fulminating all global variables that are "referenced" in the DOM seems like a fun way of shooting yourself in the foot, if you're into this kind of stuff. If you're using external libraries, or worse, using external snippets to add ads or tracking pixels to your site -- do not do that. It'll be like playing Russian roulette. I know from experience most of the shitty snippets from advertisers create global state. 
Jenn Schiffer agrees. https://medium.com/cool-code-pal/1f6430781393 Usually when Jenn agrees with something on Medium you can know for sure it's a bad thing.
I would argue that "Javascript" itself is a worse name. Absolutely nothing to do with Java, and yet I have to correct someone about that almost daily...
Not necessarily. Many companies have a naming scheme that uses the following rules (my last two companies are among them): * If an abbreviation is 2 or 3 letters long, then it must be entirely capitalized. * If an abbreviation is 4 or more letters long, then only the first letter must be capitalized. I suppose MS must follow the same standards.
My company, of 10 years, doesn't use ANY library for the reasons you mention but we're experienced, professional programmers who don't need a library for any help. Libraries, such as those mentioned on reddit, come and go over time as do the methods used on the web and none of them can keep up with the changing times. They all just add to the confusion and if you can just learn to code, you can write your way out of any situation using faster and smaller programs.
var stack = [ [node.js](http://nodejs.org/) &amp;&amp; [express](http://expressjs.com/) || [XAMPP](https://www.apachefriends.org/index.html), [jade](http://jade-lang.com/), [node-sass](https://github.com/andrew/node-sass), [mongoDB](https://www.mongodb.org/) ];
Thanks
That's the most disgusting thing I'll read all week.
It seems sluggish on high image "books"? GPU Rendering is on for my GTX760 too, so I'm not sure why the lag is occurring.
I don't understand this. Why make life harder for yourselves?
Just to nitpick: The effect looks great, but the term 'based in HTML5' is a little silly. The markup used in their example doesn't even use HTML5 elements; the entire thing actually utilizes CSS3 and JS. 
This is very cool. Like a super robust scrollorama. With horizontal scrolling. That I will most definitely use.
We already know how to write javascript. These libraries just write deliver javascript for you but you may already have most of that you are already using (or should be). Learning how those libraries work is a burden, as is the weight of adding them. It takes more time and effort to learn how to use them and include them than it takes for us to generate our own "fixes". Recently, someone advised us to add jQuery to fix a problem we noticed on one client's site. The fix would require adding one line of jQuery plus including jQuery into the page, a total of 60K(?). However, we fixed it ourselves using one line of vanilla javascript for a total of 10 chars or so and that only took us a few minutes cause we already know how are apps work. It would have been harder to include other stuff. The DOM **is** our API and library. It's not hard!
Oh I 100% agree, and already look at sites abusing &lt;script&gt; tags for templating and think "what a maintainability nightmare". To be honest I think a lot of front end work these days is completely unnecessary and is undertaken purely to create additional work for themselves (had someone try to convince me to install npm to be able to download a css styled button as a dependency the other day, I shit you not), but that's a rant for another day ;)
No Vue?
That dude's laugh kills me
Glad you like it. :)
You're right that it's not hard, but it is surely going to give you more work for most projects
This works in a few cases, but there is a performance penalty from constantly entering and leaving user land to native. This isn't a unique potential of JavaScript, since you can write native bindings in pretty much any higher level language. What's limiting about this approach is that you now need to compile per system, this is not what we'd expect from a JavaScript application. So it's not really just JavaScript anymore, it's bound to the native compiled source. So, yes, while this increases performance in some cases (where you aren't calling into native often), it comes at a portability cost.
Nice, except the fact that I want this scrolling trend dead :P
I downloaded this game and I am addicting to it now can't drop my phone. : )
I'm pretty sure Backbone and Ember aren't JavaScript Templating Engines, since they use template engines from that same list: Underscore and Handlebars. But thanks for your spam anyway, Ajitesh.
I agree that it can be situation specific, but the majority of 2D games I've seen and worked on should have no trouble handling context restore. It's mostly just a few shaders, textures, FBOs and a couple of big (dynamic) vertex buffers. Other "targeted" applications using GL (eg math/graphing) should also be able to handle it without too much hassle. Complex 3D games is often a different story.
If we used someone else's library, then we have to know how their library works including our own stuff plus vanilla javascript. Once you include one library, you always have others, which also need to be learned and maintained. In our case, we only need to know vanilla javascript, period. Far less work. Documented everywhere. Everyone knows it (or should).
https://github.com/AutoSponge/utils I was using the browserify API wrong. The output files work much better now.
This is put on by an amazing group call;ed NoFluffJustStuff, I went to a conference of theirs in boston and it was awesome. I'd highly recommend anything they put together.
Yep, I know that tastes differ. And for this very reason all general examples in js-related articles should only be written in.. [ClojureScript](http://himera.herokuapp.com/synonym.html)! (see [Why should you use ClojureScript instead of CoffeeScript?](http://youtu.be/R4sTvHXkToQ?t=20m28s)) But if seriously, you can use native JavaScript arrow functions, classes, template literals, and other ES6/ES7 stuff today: with [traceur compiler](https://github.com/google/traceur-compiler/wiki/LanguageFeatures) for the web, and nightly builds of modern browsers for native debug in some cases.
thanks!, it is a very useful and easy to use application
finally, the shitty page transitions that we used to make in flash 5 years ago have been ported to css/js. except with more blurry text and worse performance.
Well, it's free if your thing is free too. And it costs money if your thing costs money too. The price is not even an hour of your time. And usually third-party license fees can be passed on to the client. BTW, there was once a story about this guy's PayPal account (i.e. his money) being frozen because he didn't have a US green card while doing an exchange student year or so in the US.
Hehe, I like the donate button at the end. How cute
Sorry I don't really get it. Is it slow on your machine? I tested on mine it looks just like native. It has nothing to do with HTML5 but JavaScript with native bindings.
Yeah, it's sad how HTML5 has become an umbrella buzzword. Cool project nonetheless!
Although there's a lot about Eclipse that I despise, it handles this fairly well already.
Oh skeuomorphism.
Although this plugin isn't badly written (it uses `MutationObserver` and falls back to `requestAnimationFrame`), it's use is bad practice. If you're waiting for something to show up in the DOM, that ought to be a callback, not a polling or observation operation. I'm interested to hear of situations where DOM observation was the only way to get something done.
I thought we buried that with Jobs
I was curious so I created a test if it runs any faster: http://jsperf.com/getelementbyid-vs-global-id tl;dr getElementById is over 2X faster than the global id in Firefox, but about equal execution time in IE8.
Exactly; I'm not so sure that Paypal, Walmart et all would be betting their futures on an unproven technology
I have some doubts about it... I don't know if you can command an entire file comment generation using keyboard shorcuts from Eclipse or get something similar to.. automatically generate comments inside each javascript file in a folder just typing a word at command line...
[Confirmed](http://jsfiddle.net/cQm96/), using one id that has a corresponding var'ed variable and another that does not.
I have a bunch here: http://www.letscodejavascript.com
That's fair. Fortunately, we have an alternative, if we'll use it. EcmaScript.
But you aren't calling JavaScript anymore, so it's not really a reflection of the language. You're calling into a native space that runs native compiled code. Now if you were talking about emscripten and compiling native code to JavaScript and it was blazing fast, that's a different discussion.
That was my point, sorry if I didn't articulate it well.
Yeah, differing use-cases might warrant it. In my work, most of the comments are already present, and if not, I can just enter `/**[enter]` and it generates it for me, same as if defining a new function. For generating them on a whole file though, no, it won't handle that I don't think, though I rarely need that myself.
I just went through releasing a [widget](http://www.leshylabs.com/blog/leshy/2014-03-29-Leshy_Tuner_Update_and_Web_Widget.html) a couple weeks ago. I'm new to this, and not certain I'm doing everything perfectly, but there are a few things I'd add. Some of these are mentioned in the blog post as well. * **Performance matters.** When someone is embedding a widget onto a page, they are going to have at least one more request. This can impact the page load time and download size, and can be especially notable on mobile. It is probably best to enable the async attribute on the script. It is definitely nice to serve all static assets from a CDN. You should try to minimize requests when possible. Also keep file size down. Don't unnecessarily include dependencies. Enabling your widget ideally shouldn't cause any blocking of page load. If you are making a very complicated widget, it is probably best to write a small loader script that enables the widget area, shows some sort of loading indicator, and then manages the download of the larger script and any other assets. * **Do not unnecessarily leak variables.** Keep everything possible wrapped in a closure, and name variables outside of that in a way that is extremely unlikely to have collisions. If you don't do this, you could likely break the JS on the site. Do not assume you can throw a dependency like JQuery on there in the global namespace, since that may collide with their version. * **SSL Support.** If you put "http://" anywhere in your widget, then it won't play nicely with sites using HTTPS. If the web server(s) you are storing the assets on and communicating with is configured to support HTTPS, then you could use "//" instead of "http://" to match whichever protocol is being used. 
This isn't 1990. Memory is cheap.
There is a fine line between genius and insanity. The only way to do fonts cross-platform that will render the same exact results on every platform would be to use an SVG font file and draw the fonts on a canvas element with javascript code you write yourself to render the curves from the SVG font data. Even using the native canvas drawing tools will give slightly varying results. I've worked with fonts in-depth enough to know the pain they cause. Fonts on the web for anything that has to produce precise results is just an awful mess. 
Why? You want your data and information fed to you in a static, clean, and easy to consume fashion? Like a *peasant*??
Everyone remembers what is traceGL, right?.. Here are some links, just in case: [on reddit](http://www.reddit.com/domain/trace.gl/), [video demo](http://www.youtube.com/watch?v=4vtKRE9an_I), and [random informative post](http://blog.whydoifollow.com/post/an-arrow-in-the-developers-quiver-tracegl).
I'm sure the code to do this is awesome, but welcome to 2006?? Who wants this today?
uhm why?
I don't really even know
The fact that you think we need to reinvent the wheel every day shows you are not as competent as you think you are.
Haters gonna hate, I guess. I absolutely love Javascript because it has dynamic typing, and *zero boilerplate*. I just don't need any of that to get work done. It's useless to me. I've never had a serious problem caused by type coercion in 16 years working with javascript. If you are having to use try/catch so much, then you are doing it wrong. Yes, the VM will stop but that's because you have a bug in your code and you need to fix it. Use the debugger, modern browsers have really come a long way at helping debug your code. There's so many examples of complex javascript systems that work, and work well. I will say that if you want to master javascript, it might take some time and dedication, and you have to stop using strong typing as a crutch. If it makes you feel any better you could always name your variables like whatever_str or whatever_int, etc, if you really need to remember what they are supposed to do. Of course type problems won't be caught in a 'compiler', but javascript is a different beast meant for a different purpose than C++. 
flash is a js with a different api, isn't it?
It was very distracting when I was trying to make it
Consider the "Stability Index." http://nodejs.org/api/documentation.html#documentation_stability_index &gt; API is still somewhat changing.
Fuck it, server side render to an image, with google specific page with raw text for indexing.
I do agree that the code should be commenting as it develops is a good practice, which does not mean you have to insert yourself into a project that did not use this good practice, then, from the very beginning, for those cases ready have SmartComment as good starting point. Also, keep updated documentation, if the semantics has not changed, only certain parameters or function names, then you need not worry, because it will update automatically. Moreover, Maybe we should take into consideration that many developers of the JavaScript community, just uses Emac, Vim, Sublime Text or other text editors to write his code. Also they use NodeJS as part of their daily workflow Minify the code, run tasks and create production enviroment are a few examples. Smartcomments can integrates good with this workflow.
Are you sure the owners and boards of WalMart and PayPal were involved in technology discussions?
Experimenting and expanding your horizons is great. I'm not sure why you feel not using node technologies is cruder, however. My major issue with the vocal node crowd is that they ignore any pitfalls of these technologies in the name of progress. I want to make stable websites and not have to deal with the ever changing landscape of node.
Dariel, this is awesome! Funny enough I just watched Partrick Dubroy's talk on using Esprima for building tooling like this on my way to work today, and was pretty inspired to build this exact module for auto-documenting my codebase: http://2013.jsconf.eu/speakers/patrick-dubroy-parsing-compiling-and-static-metaprogramming.html The amount of power that you get from being able to operate on your code at an AST level is unreal, and it's awesome that Esprima gives an average dev like me access to that kind of power.
Not sure if xss or just nice easter egg you've got here.. [](/fshmmm)
Strings are data literals that represent text characters (most Unicode characters supported). Strings are always wrapped in a set of matching double or single quotes. The *if* keyword represents a condition, which is a decision based upon some sort of comparison. I recommend you use the === operator to compare strings. if (myVar === "this is a string example") {//do something if the match is true
This is incredibly cool! I don't know why there's an 8-bit Princess Luna sprite on the thumbnail, though. 
Yeah, sometimes that works. Other times the lag caused by sending the text to the server, and waiting for an image response is too much for some applications. Especially on wysiwyg applications with thousands of concurrent users - sometimes a fat client (html5) is the way it has to be done. But I digress. The point was, browser APIs suck when they don't work exactly the same across browsers, and there are plenty of examples of that other than SVG and fonts. And, Javascript isn't at fault in those cases. 
Beautiful! My main complaint with Marionette was that the docs were just a pile of md files in a folder on github, but this is much more convenient and readable. My one bit of feedback would be to use a light color scheme for the code examples. Switching from dark-on-light to light-on-dark as you read slightly hinders readability.
Welcome to Web 3.0 bro.
I guess maybe that's because she's clearly the best princess.. Isn't she? :I [](/lunapoker)
&gt; data literals someone isnt very good at ELI5ing ;)
Mongodb - node.js - express.js - angular.js
Broke it on my first try - just doubleclick on any demo button.
Not all libraries are big kitchen sinks like jquery or underscore. There are many libraries, [particularly on npm](https://npmjs.org) that are small, easy to quickly understand, and do just a single thing. Often they are a single function. The overhead of dropping one of these into your application, especially if you are using a [package manager](https://npmjs.org) and [a module system](http://browserify.org) is very low and you get the benefit of a library that has already been written and tested. If you find bugs, you can fork the module and send the patches upstream. Here's just how easy it can be: $ npm install gamma now just require('gamma') in your code: var gamma = require('gamma'); console.log(gamma(3.4)); then browserify to generate a bundle with all the necessary files: $ npm install browserify -g $ browserify main.js &gt; bundle.js and drop that in a single script tag: &lt;script src="bundle.js"&gt;&lt;/script&gt; You can even automatically recompile the bundle whenever a file changes with source maps to help you debug the concatenated bundle: $ npm install watchify -g $ watchify main.js -o bundle.js --debug -v I think [weaning yourself off of jquery](http://substack.net/weaning_yourself_off_jquery) is a laudable goal but not all libraries are gigantic monoliths that add a huge amount of complexity. It does take some time to learn these tools but no tool individually takes all that much time and learning is a one-time investment. To recap, here are the benefits of using external open source modules that you are perhaps missing out on: * save time using something that has already been written * much of the time, already tested with a unit test suite * many bugs already fixed * incremental, granular package management with semver * access to a huge pool of experience and different ways of doing things * contribute to the progress of the human species in a small way by sharing your patches and libraries Software is about standing on the shoulders of giants. Your sentiments, taken to their logical conclusions, would have you etching your own custom circuits on your own hardware instead of just trusting but verifying an external solution.
To understand what a string is you have to understand what a character is. A character in JavaScript is a single value from the giant list of values called UTF-16. [Here's](http://unicode-table.com/en/) a visual example of what individual characters make up that list. So now that we know what a character is, what do we call a collection of these characters, like say if we were to string these characters together on a proverbial bead necklace [like so](http://bds.jewelrymakingmagazines.com/-/media/Images/Tips/BDSSC0506_10.jpg?mw=600)? Well, let's just call it a string. But just by itself a collection of characters doesn't denote a string in JavaScript. To specifically tell JavaScript our collection of characters is a string we have to wrap our collection in either single quotes or double quotes (' or " respectively). The two kinds of quotes are useful because sometimes you want a quote to be part of the collection of characters and not a sign to JavaScript that we have come to the end of our collection of strings (see the example below). And that's it; that's all a string is: a collection of characters enclosed in single or double quotes. Example: "Hi, I'm a string"; Tune in next week when we learn that collections of all kinds (even characters) are actually something called an object, and that strings are actually a special kind of object called a string that works, mostly but not entirely, like another object called an array. It's going to be exciting!
Haha thanks for the comments. I can't wait till next week! 
I believe you're missing a critical piece of information here. No worries - this eluded me for a while as I was first getting into AMD, and I believe that it continues to elude many other developers, as well (it's poorly documented, IMO). The critical piece that you're missing here is the concept of the "package." AMD gives you two primary mechanisms by which you can organize your application: 1.) Modules 2.) Packages An AMD "module" represents a single "class." In your config file, you'd define it like so: requirejs.config({ 'paths': { 'my_module': '/path/to/module' } }); You would then get a reference to it like so: require(['my_module'], function(MyModule) { var mod = new MyModule(); }); Great. You've defined a single "thing," and you know how to get a reference to it. Big deal. Any serious application is going to need more structure than that. And that's why we have the "package." Define a package like so: requirejs.config({ 'packages': [ { 'name': 'my_package', 'location': '/app/packages/my_package' (this folder should contain a `main.js` file) } ] }); Your application's structure might look something like this: /app /packages /my_package main.js lib/something_else.js Within your package's `main.js` file, define your package like so: define(function(require) { var something_else = require('./lib/something_else'); var MyPackage = function() { }; return MyPackage; }); If it's not obvious, the main benefit that you're getting here is encapsulation. As a "package," you are able to import additional dependencies relative to the location of the package itself. No one else needs to know about them. Once you have loaded in any dependencies used specifically by this package, you can then organize them in such a way as to finally return a clean, unified API that anyone can use by simply loading the one package: require(['my_package', function(MyPackage) { var package = new MyPackage(); /** Happy happy, joy joy. **/ }); Make sense?
Also note that you can use the libraries underneath koa without using it itself and the result is pretty sensible. I personally don't like assigning onto `this.body` to send the response, but I can use [co](https://npmjs.org/package/co) and [thunkify](https://npmjs.org/package/thunkify) directly instead with a vanilla http.createServer() and the result is pretty nice: https://gist.github.com/substack/9881504
&gt;Your jQuery example is the silliest example you could have chosen. But it's that sort of silly example people on reddit give me all the time. Don't attempt to belittle me. I'm just the one who was delivered the package. As far as frameworks go, same story. If you need a framework to do your work then you mustn't be capable of creating extraordinary sites on your own. We only deliver the extraordinary and not the "me too". &gt;I'd be hesitant to hire your company or any company with that fear-of-outside-code attitude. You are confusing "fear of outside code" with "been there, done that, years ago". I wish, sometimes, I could publish our client list. 
&gt;this eluded me for a while as I was first getting into AMD Mainly because the official http://requirejs.org/ site is a dumpster fire: completely useless to read unless you're heavily steeped in knowledge of how AMD works and how r.js would eventually end up interacting with your modularized directory structure. Partially unrelated, but I don't think AMD is the way forward anyway. CommonJS and browserify/webpack/etc are so much cleaner that I ditched AMD without second though.
How the fuck does this not get upvoted to the front page? The Reddit algorithm is shit now.
an early downvote, and it's older than a day.
Hyperbole aside, your position is ignorant. It's perfectly possible to make a stable dynamic website.
http://www.jtypes.com/blog#20140412
I would suggest dodging requireJS entirely and going straight to browserify. It uses the same syntax as nodeJS, so your modules can work on the server or browser and it's just a lot nicer to write. Large projects need to be broken up logically. Sometimes you need to expose a constructor, other times you need to expose a plain object. Your module loader should not dictate that for you. The main reasons people are moving from namespacing everything: 1) we can (thanks to good module loaders). 2) it provides additional security from malicious code. 3) it eliminates the chances of namespace collision due to loading plugins or 3rd-party code. You're right that all large apps used to look like that. And loading modules takes some time to get used to. But once you figure it out, you probably won't look back.
I'm actually experimenting with diagonal scrolling, spontaneously change direction scrolling, and other trolling / cool things. But I'm not using this library because I'm abstracting the onmousewheel event, not scroll. I'm wouldn't use on scroll to trigger anything. I'm just saving the mouse events in an array and when it the sum hits a certain number I do something unexpected, just. Because. I can.
I assume I would write something before or after all the infowindows have been created, then change the variables for each infowindow??
Yes. Yes she is. Brohoof!
It's the author's picture on github - https://github.com/sahat
Not so great on mobile :(
&gt; Sometimes you need to expose a constructor, other times you need to expose a plain object. Your module loader should not dictate that for you. You can do both those things with AMD.
Including all of my vendored libs, I've got around 10 mb of js spread over hundreds of files for one of my larger projects: I consistently get 50 ms rebuilds using this: https://github.com/gulpjs/gulp/blob/master/docs/recipes/fast-browserify-builds-with-watchify.md I used to be annoyed by the build step before I discovered gulp + watchify, but now literally don't even notice it (especially with live-reload). Between that and source maps, I don't see how AMD can be seen as a better approach (unless someone was absolutely allergic to a build step for some reason) 
Pretty cool, but would it really take a full day workshop to learn? The API surface area is really small and well designed; it shouldn't take a relatively experienced dev longer than an hour or two to pick up (even less if they have a decent background in "functional thinking")
Thanks for reporting. This has been fixed.
so use it ;)
Love the sarcasm, but a good designer, as always, uses this tool to enhance information consumption, not obstruct it. Like with every web technology the right dosage is important. And I think there are just as many static pages that are designed in a fashion that hinders information consumption as there are pages that abuse animations.
I wasn't definately not aware of the packaging part of r.js. Thanks. I have never tought about writing an application as a package.. do you have useful resources about this for an application scale project?
I like this phrase, it's absolutely true. &gt; Software is about standing on the shoulders of giants. However I think you meant to reply to the other guy. I have the same point of view as you do, but less motivation for typing a large response!
Create only one infoWindow instance and replace it's content on marker click...that's the standard solution.
Looking forward to this. Sooner, the better :)
A few issues can cause this, custom fonts, loading masonry before images. Take a look at http://www.epicwebs.co.uk/jquery-tutorials/quick-and-easy-jquery-masonry-tutorial/ which details loading masonry initially and then loading it again after the custom fonts are loaded, helped me with my google fontage!
actually tested and proven: https://www.npmjs.org/package/utf8
nice, surprisingly not using yeoman (grunt/npm/bower)?
Thanks! will take this into account:) Communicating right now with guys from marionettejs to add this as official docs.
Master-lincoln is correct. Keep the data for the info windows in a structure that is easy to retrieve and use for the info window.
I can appreciate the focus on just JavaScript, but there are many different types of full-stack developers out there that use different technologies. I would at the very least mention those as well.
I didn't say you couldn't, I just don't think it's the place of the module loader to dictate it (i.e., make recommendations). From the requireJS site: "Returning a function as the module value, particularly a constructor function, leads to better API design." There's a lot of unsubstantiated BS in that sentence.
Looks broken to me. The encoder doesn't have any handling for astral plane characters; javascript is UTF-16 so it should stitch surrogates into a single 4-byte sequence. The decoder doesn't have any handling for invalid input; at minimum it should handle unexpected trail bytes, missing trail bytes, and overlong forms. It should also of course split astral plane characters into their UTF-16 surrogates. 
yup. that's the plan. This series is going to be a pretty high level overview, and I will explain the alternatives for each layer. You can't escape the fact that you have to use javascript on the client though, so if you only have to learn one language...
RequireJS !== AMD AMD is the specification, RequireJS is one implementation of it.
bump
Prepare your anus.
Good thing it's called webtoolkit.utf8.js so it doesn't have to deal with UTF-16 characters. You should extend it to be UTF-16 compliant and call it webtoolkit.utf16.js instead.
&gt; If it's not obvious, the main benefit that you're getting here is encapsulation. As a "package," you are able to import additional dependencies relative to the location of the package itself. No one else needs to know about them. I've been using RequireJS for probably close to 2 years now, and have never understood packages. I mean, I understand the general concept (as you've laid out here), but I'm not seeing the functional difference between using a module and using a package, nor any benefits. What I'm seeing here could just as easily be accomplished with a module, no? Are there any concrete examples that demonstrate the benefits of packages over modules? Also, have you used Browserify? Every time that I have to modify/debug the r.js build, I find myself inching closer to switching, though sadly I have a lot invested in the r.js setup and so I'm worried about the cost of switching (and apprehensive that it won't support everything I need). I have no idea if it's any better in that regard, but I'm not sure it could be much worse...
It absolutely *does* have to handle UTF-16, because all JavaScript strings are UTF-16.
Use this instead: https://github.com/yeoman/configstore
I will better prepare my brain and my patience. But if you prefer work with your anus that definitely your choice, buddy!
That can attach to an option element and do what?
Dime-a-dozen article that just parrots the first section of the Gulp readme (or any other of the endless stream of these me-2 articles). 
Which is why I was steering the OP away from RequireJS. I never mentioned AMD, you did. Please read the thread.
AMD is ridiculous for big applications. As soon as you go above ~20 modules you'll find that you will want to bundle all (well, most) of your JS into one file anyway, because loading 200 small JS file is very inefficient. This of course means negating the whole system of AMD. Then you can wonder why you'd want to use AMD in the first place. If you write bigger JavaScript you might want to look into TypeScript. It can generate bot commonJS and AMD modules. I now use it to generate commonJS and then use browserify on that. Is it pretty zippy and gives a lot of safety from the compiler step (plus all the benefits from browserify like npm code and node API's). Of course this makes edit-reloads slower but that model is not very sustainable anyway if you go bigger. Although with a good watch setup and LiveReload you can get some of it back.
Actually, in a browser, are they really global, or merely in the "window" scope, since it owns everything?
I converted a smaller app from RequireJS to browserify in about 45 minutes. While I was there, I replaced some of my modules with npm modules that did the same thing which took another hour. When I was done, I cut a significant number of lines. In the end, I think that's worth the time.
&gt; this.play = function() { &gt; this.playing = true; &gt; return function(){ &gt; this.playing = false; &gt; }.bind(this); &gt; }; While that works it's less common and harder to read. If you do that, wrap the return value in parens to indicate you're returning the result of an expression. In production code, you pay a significant performance penalty for .bind(). It's usually fine for most apps, but don't use it for games or computation. 
This might help a bit: http://YouMightNotNeedjQuery.com Also, the MDN is very helpful: i.e. https://www.google.com/search?q=addeventlistener+mdn
If you have 100+ files and you're not factoring common dependencies, you're probably doing it wrong.
Someone clued you into it, but always add mdn to the end of your searches for JS related questions. Really great documentation of the spec, will even give polyfills for useful methods not implemented in &lt;IE9.
Feel free to work something [like this](http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/) into the code and create a better version. The original developer probably only needed to solve his problem, not yours.
It's like the bad old days of "Ruby not Rails."
MDN. Best resource for javascript by far.
Maybe you could show some examples of how Gulp improved your workflow (your before vs after setup), what plugins you thought were really cool, or how a total newbie could start integrating Gulp into their workflow. Otherwise there's not a lot of value in your article. 
So, what does vis.js offer over other popular visualization/graphing tools like Javascript Infovis Toolkit, FlotCharts, D3, so on and so forth?
I'll see if I can do that. Might have to ask more questions
still really new to this
Good luck, I hope your hard work pays off.
Thanks!
You have alternatives here now, but I always use "vanilla javascript" or specific terms like "javascript object notation" to do this. Yes jQuery is ubiquitous now, no that's not a bad thing. It's good to have a tool that helps abstract common needs out. 
I was looking at https://github.com/lodash/lodash/blob/master/dist/lodash.js while it happened. And then I re-read the chapter on closures in "JavaScript: The Good Parts". Perhaps that will bring you to enlightenment too :D This is nice too: http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html
[mdn.io/array slice](http://mdn.io/array slice)
Or even addeventlistener site:https://developer.mozilla.org
Thanks a ton. Exactly what I was looking for.
But how else can you write functions if not like this? $(function () { //Put my entire app in here. }); lol. Use MDN. But the best advice I can give: **READ THE SPEC** You will be so glad you did.
At my office, we never use things like _this, that, self, etc. generic names for a closure, for 2 reasons: When you need to keep closures inside closures, you end up with horrible shit like __that. Makes code very hard to read when tracking context. (let's say you pass the this as an argument to another function, and there you have a closure, how you name them can be awkward. What we do are 3 things: When possible pass the exec context to the function, for example forEach second param is the this for the callback. (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) When listening for events we bind the callback to the context with bind (e.g.) obj.bind('event:name', function callback(){bla...}.bind(this)); (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) And lastly when using closures, we use the name of the object "Class" it represents: var myController = this; obj(fn(){ myController.method(); }); No more ambiguity anywhere. (if you name your classes well enough, hehe)
or mdn.io/addeventlistener
i think my real problem is terminology. I do / use these things all the time and now the different reason why to do things in different ways but if I had to explain it in an interview id probably fuck it. Memorization is not my strength.
Thanks, Many things need to be done yet. SmartComments is a community. Your contribution is welcome.
Bad naming convention is the root of all evil. Haha :) Thanks for the links!
\#\#javascript on freenode
What does that have to do with anything?
&gt; One of the few opinions they have is to use AMD to separate the code off into modules. I’ve seen this pattern become more and more popular with newer JavaScript libraries, so it’s no surprise they went this route too. Forced to use AMD? I'm out.
I've been using the timeline bit for some time to visually benchmark timings.
Some stuff: * A Dive Into Plain JavaScript. http://blog.adtile.me/2014/01/16/a-dive-into-plain-javascript/ (16 January, 2014). * I know jQuery. Now what? http://remysharp.com/2013/04/19/i-know-jquery-now-what/#backToTheFutureToday-heading (16 January, 2014). * javascript - Turn jQuery into vanilla JS - Insert p element after h1 - Stack Overflow. http://stackoverflow.com/questions/3444891/turn-jquery-into-vanilla-js-insert-p-element-after-h1 (19 March, 2014). * Vanilla JavaScript FTW. http://sharedfil.es/js-48hIfQE4XK.html (19 March, 2014). * Vanilla JS vs jQuery. https://gist.github.com/liamcurry/2597326 (27 July, 2013). * weaning yourself off jquery. http://substack.net/weaning_yourself_off_jquery (4 December, 2013). 
Not my kind of thing to register for. A general note, please make the fade in animations of the dialogues about 1/3rd to 2/3rd faster :) They feel /really/ slow atm.
There should be some meta tag in HTML which lets you put in terms that people *don't* want, so that its safe to *mention* it somewhere in the site (so that such a search result can return results.) That way, someone could have a site called "Javascript, not jQuery" and it would be listed. 
It has to do with whether the people who control the company and are worried about the companies future had any say in what technologies were used for their websites.
You create a single object and put the code inside it, so you're only using one name from the global namespace. (Assuming we're talking about browsers here). And then execute that after DOM has been loaded or other suitable event (apparently JQuery's document ready event is non-trivial). This doesn't answer much about the application's layout, though.
Answer: You don't. Expanding on that with 30 seconds of interview answer top-of-my-head bullshit (cuz I'm great at that)... * I'd look for source code that has good comments, source code that is mostly easy to read, though this depends on what the library does and what your experience in that area the library addresses is. * Great documentation with examples/demos always helps drive adoption. * What's any github activity like? * Also, does the library fit a specific niche or is it solving very wide-spread problems? * A quick stack overflow/google search can't hurt, either. Is there an existing community or is it no man's land? * How quickly will I be leaving this position? If very soon, go with the craziest shit possible. This is to see if they have a sense of humor. Also can tell you a lot about past employees if they have any snarky commentary as a response.
But they do have a say in who they hire to oversee those types of decisions. And I'm pretty sure those in charge of technology are somewhat worried about the company's future, and their jobs.
Thanks for the feedback!
There are only two hard things in programming, naming things and cache invalidation.
Yes really, rails is a way to make applications, node is a way to make applications, jquery is not. If you wanted to get specific it'd be like *javascript not ember* or *javascript not meteor*
I posted this in /r/learnjavascript , I hope it helps you; I come from a design background hence I learn visually. https://www.youtube.com/watch?v=PMfcsYzj-9M
As if it's so much more difficult than CommonJS.
But I thought the whole point of putting it in the $() wrapper was to make use of the document.onload() hook. If you're arguing that you don't need the whole jQuery library to help you write document.onload(); then I agree with you.
Thanks. Good idea using the index file as namespace wrapper. That was one of the points I was missing in all examples. Makes definitely sense. Gotta try out what PHPStorm's auto complete can do with this.
The worst is when someone on SO asks for help with *javascript* and all the answers are "Well, if you use jQuery..." Not everyone likes (or can use) jQuery. It's annoying when everyone assumes it's already there just because it's their favorite toolkit. Yes, it makes a lot of things easier (like so many other toolkits/frameworks), but people seem to forget that jQuery != javascript.
I could map strings to functions, but that's inelegant, and annoying when I want to update my object. 
I'm testing it. Very nice! Congratulations! Could you share the main libraries (node and client) do you use?
...those do totally different things for different purposes though. Passing a function into $ isn't silly if you want that stuff to happen on DOM ready. Use the IIFE too, but know what you're getting and not getting out of each pattern. I have lots of JS files that look like (function ($) { // setup stuff $(function () { // DOM ready stuff like event wireup }); })(jQuery);
Yep. I had a couple of points there. 1. I've seen that rather strange alias being used in application code that has nothing to do with the document.onload event. i.e. the developer just thinks that that is how you write a function. 2. Throwing all your application logic inside a single function is poor design.
Not really because plenty of people use JS without node but not as many use ruby without rails
You can check for a property with `foo in bar`. Also, `class` is a reserved keyword, so your sample code has no hope of working. 
Add MDN to your search engines.
I wonder if there are any sites that have tutorials on snark. Some people just aren't very good at it.
So, I've been sticking a lot of the functions I write for my web audio apps into a library as I go along. Here it is! Suggestions/bugs reports/pull requests extremely welcome.
Interesting, good answer!
Yeah, I'm finding out I don't understand certain things very well. 'this' confuses me in JS. Thanks again
more difficult? no. more complex? yes. Don't get me wrong, browserify is complex too, but if you compare the [issue queue for require.js](https://github.com/jrburke/requirejs/issues?page=1&amp;state=closed) to the [issue queue for browserify](https://github.com/substack/node-browserify/issues?page=1&amp;state=closed), you will notice that the types of things that can go wrong with require.js are of a much more punishing and frustrating variety. Those errors happen very late, and on a much larger variety platforms in ways that are not always straight forward to reproduce, with many layers of indirection and abstraction between you and the actual error. I think the vast majority of serious applications are going to end up needing a build step in the end, and once you accept that fact you can reduce a lot of runtime complexity by just not using require.js in the first place. There is one case that I think AMD is a good solution, namely something like [Atom](http://atom.io) or another desktop-like tool. You want users to be able to configure and load various plugins on demand, and it doesn't make sense to rebuild the code every time they enable a plugin.
I like the idea. I do think that a cleaner &amp; more efficient lib than jQuery or Zepto could have its place in the JS libraries jungle. However I think that using the jQuery API would have made cash a more usable product by allowing it to be a dropin replacement for standard DOM manipulation (jQuery without all the -often- unused promises/deferred and stuff). But maybe I didn't understand enough your goals and motivation. (I'm thinking about those [dom](https://github.com/component/dom), [jQuery evergreen](https://github.com/webpro/jquery-evergreen), [jBone](https://github.com/kupriyanenko/jbone)...). This being said, good job at designing this lib and making it a real product !
I think today there aren't really any compelling reasons to roll your own library over using an existing one (especially jQuery). * Even if you make a function a million times faster than a jQuery method it's probably going to be unnoticeable. * It's maintained and well documented by others, so it's less for your team to worry about * Since jQuery is the most popular library out there, basically everyone knows it * Also due to its popularity, there are lots of plugins to choose from * If whatever you build gets passed to another team, they don't have some new library to learn I've seen some terrible, terrible jQuery code with hundreds of uncached jQuery objects, but it still performed well. If you had fun making your library, great. If I had to inherit it, though, I'd be bummed.
A lot of interview questions are. Just roll with them, have some fun with them, trust your gut reaction and go for it.
That's a solid answer, particularly on the "devil's bargain"... I think now it's going to also matter who can justify existing in the coming ES6 age. Much library code than thankfully go away. And who can adjust to web components? If the 'declarative renaissance' is real this will make modularity paramount.
Which one was more readable?
@ayamflow thx, and there is some great stuff in jBone -- I have used it elsewhere. If I were adhering to the jQuery API I would have started there, contributing and extending as needed. Moving away from the API was more interesting to us in that we were freed to make only what we deemed necessary. Not being beholden to the range of arguments that the $ function itself would demand is a great example. 
The $ callback isn't the same as the document.onload. document.onload fires when all images are loaded, $ fires when the DOM is finished.
pfft, stackoverflow "how do I get the value from a div?" "Oh you should totally use jQuery for that!" my brain hurts whenever I see something like that...
Cool job guys. I'm just learning how to use Sockets(with Sockets.io), but wish I could find a good treatment on the subject. 
I tend to use chromes "search engines" features to skip google entirely. That is, to search MDN, in the address bar, I type `"MO" [tab] &lt;my search&gt;` or `"ST [tab] &lt;my search&gt;` for MDN and StackOverflow respectively. 
You're gonna go down faster flash for that comment!
[more serious than my other comment] jQuery *is indeed* primarily a library for interacting with the DOM. I don't think that anything he said is misguided or incorrect however. Your answer, on the other hand, seems a bit confusing, and misinformed. jQuery *does* do js abstraction, and provides helper functions on top of JS which are totally unrelated to the DOM. He says, correctly, that jQuery and javascript are NOT synonymous, as often feels like the case on SO. I tend to agree, but don't think its a bad thing. Unless you're specifically working in node (in which case you'd add that to your search), chances are super-high that when someone is talking about JS, they mean within the context of the browser. Find a question with an jQuery answer where a vanilla-js one will do? Answer it with the JS solution and win some sweet nerd points. Find a question with plain-JS solution, but have a way to simplify it if jQuery is present? Add that too. More nerd-points. I can't tell you how many times I've been grateful for a jQuery solution down the page on a JS question, or a plain-JS solution down below when the selected answer is jQuery-specific.
We were actually using socket.io in this game early in beta testing, but switched to the more lightweight SockJS. Socket.io is great to get up and going easily, especially if 1.0 ever comes around.
IDK about all that. If you're already using jQuery, it is a bit simpler and adds clarity to the code. After all, jQuery is *built* for interacting with the DOM. What benefit do you get from doing it the plain-JS way? A fraction of a millisecond quicker lookup? In the simplest case, where the plain-JS solution is most attractive, jQuery *still* feels better. document.getElementById('myElement').innerHTML // versus: $('#myElement').html() This gets *much* more complicated if you have to iterate through a set of elements after matching a class or tag name trying to match a specific set of criteria. How would you do this simple lookup in plain-JS, and why would you if you can do this: $("div[class^='foo']").eq(4).html();
No, but other developers do.
Will end users notice 100kb of extra page load thats likely to be cached anyway? Chances are no. Especially if its a relatively small project to begin with. Be careful of premature optimization. Code for maintainability and productivity. Getting more done, cleaner, faster === better. I definitely used to nitpick every performance concern I read about, even on trivial sites. Now I have the experience to know what will make a difference and it results in getting things done. When you get things done faster, you have more time for support / features. Do end-users notice an additional 50ms load time? Or the quality of your product? 
This repo is describing Grunt-based dev environment. I'm just looking for tools that can be helpful in automation of processes. The most interesting part for me here are Testing &amp; Metrics tools. Some great, but still not widely adopted, things like: Accessibility testing, Visual regression testing, Code complexity metrics. Looking forward to add more useful stuff. Suggestions and PRs are welcome.
You seem to be advocating two different things here. AFAIK no CDNs serve modular builds of jQuery (which they *are* supporting now in 2.x), and if they did, it certainly wouldn't be cached on the vast majority of users' machines. Also, and I can't put my fingers on a source ATM, but I'm pretty confident that you're overestimating the amt of users who will have the specific version of jQuery from the specific CDN you're loading. I'm pretty sure I've read that the number is &lt; 50%.
I've removed jQuery too, mostly for file size reasons (not just download, but parsing time on slow mobile CPUs). So I just use this for node selection (it doesn't solve traversing like Cash does), var $ = function(selector, scope){ // very simple node selector var nl2a = function(nodelist){ //nodelist to array if(nodelist === null) return []; return Array.prototype.slice.call(nodelist); }; scope = scope || document; if(!selector) { console.log("Empty selector"); console.trace(); } if(selector.indexOf(" ") &gt;= 0 || selector.indexOf("[") &gt;= 0) return nl2a(scope.querySelectorAll(selector)); if(selector.substring(0,1) === "#") { if(scope.getElementById === undefined) return nl2a(scope.querySelectorAll(selector)); return [scope.getElementById(selector.substring(1))]; } if(selector.substring(0,1) === ".") return nl2a(scope.getElementsByClassName(selector.substring(1))); return nl2a(scope.getElementsByTagName(selector)); };
Yea, its pretty common to see people use this unnessicarily. I'm probably guilty myself sometimes. I do sort-of disagree with point #2 however, though of course it depends on the project. You're probably right for large-scale projects Wrapping all your logic inside a single function creates a new scope, allowing you to (more) easily insulate your code from the rest of the world and vice versa. In the past, I've done things like /u/filyr suggests: (function($, window, undefined){ // my code })(jQuery, window); why do you think this is a bad pattern?
So is it not silly to replace 30 lines of code with 100kb library + 2 lines of code not using the library otherwise? 
Yea, probably not the best example. I find that the vast majority of jQuery methods, etc, are very readable. For the record, `eq(n)` just grabs the element at index `n` for that set of elements. That one has always bothered me too, pretty ugly. Perhaps a better challange if you wanna take a stab: You have an element, but you want its parents next sibiling's title: $('#el').parent().next().find('p.title') Funny how I for some reason thought up till this point that `querySelectorAll` was IE 9+ when its supported by 8. Almost made a stupid reply then thought the better of it and looked it up. `querySelectorAll` certainly makes JS/DOM interaction much much prettier. You kids have it easy nowadays ;-) 
Reading these comments ive realized web developmeny has become the visual basic of the 21st century
I might be the odd one out here but there's no harm in using jQuery. Manipulating the DOM api directly can be error prone (especially when there's multiple cases). the YouMightNotNeedJquery site is a pretty good example of why , even if you might not need it, jQuery sure is helpful. Plus browser support.
lol. You got me. Good job trying to sound pretentious, however, you seem to be confused about what 'however' means, and the post in question is ambiguous at best. 'However' doesn't mean (though it *can* imply) that there is "another way". It means that what you're about to say contrasts (or at least seems to) with the previous statement. In this case, it can easily be interpreted as: "customize jquery to mitigate perf issues, but you don't really need to b/c using a cdn fixes those anyway" I'm *still* not sure what you're trying to say __however__. So you *don't* recommend modular jq builds? B/c "this is more of a reason to learn how to" certainly sounds like your advocating that approach. Also, and I might come off as an asshole (too) if I'm wrong, but I'm pretty sure you're mis-using the word lexicon. At the very least that sentence is one clunky mofo.
I don't think it's inherently silly at all. I've included libraries for less. It very well *may* be a bad idea, but that all depends on the project.
I heard MDN's resources aren't bad. 
(in the voice of my boss) "Now make it IE6-friendly, and make that other thing spin when you click on it" ;-)
I don't blame you - results from that awful w3schools site always appeared higher in searches (and for ages I thought MDN was a Microsoft thing just based on the page titles). I only noticed it last year, it's a really good resource.
Only if they can tell me which stocks to buy. There's not really a right answer. The question is more about how you think about the problem and seek solutions. As someone who has reviewed applications and helped hire devs, you may have impressed them with uncommon answers. When considering an external library, I: - Discuss it with my team - Notify legal with the license information (including dependencies) - Review the test coverage - Research reference implementations or production cases - Estimate the training and refactoring time for our project
google "native js [query]" if you know that's what you want.
 document.body.innerHTML = "&lt;img src='http://comps.canstockphoto.com/can-stock-photo_csp7935936.jpg'&gt;"; I see your point. But I don't see your boss's :) I mean, does he want it to work on Mosaic as well?
Came here to say this. Most of my spec questions are prefixed with MDN in the search, e.g. "MDN get element by name"
@holloway we thought about the selectors. I decided to leave that out totally as searching the DOM can be as simple as using querySelectorAll for everything or something more granular like this. A dev or a team can decide how they want to handle that. For example we have 'view' classes that 'scope' all operations to their element (a la Backbone's 'el'). Most operations are then $(this.el).doStuff()... As far as Cash is concerned, it would be a simple matter to create a module that introduced selectors, then build. The goal was to be modular from the start to allow that. 
MSDN - those guys are the f-ing worst.
There's really only one difference here: whether your code runs when it's called or when the document is ready. You also can get the free jQuery reference if you want it.
Hehe I like your use of strict and non strict equals to make your point, but I'm afraid that distinction may be lost on him :)
Full-stack? Where's your persistence layer? Your UI? Your CDN?
Thanks!
Great work.
Call your poop. Weirdest. Answer. Ever.
I honestly thought you were trolling about "astral plane characters." [Nope](http://en.wikipedia.org/wiki/Plane_%28Unicode%29). &gt; Sometimes, the terms "astral plane" and "astral characters" are used informally to refer to the planes above the Basic Multilingual Plane, that is, planes 1–16 and their characters
Close that image tag, yo. 
&gt; IE8 My sympathies.
I'm no expert, but you should probably put ; at the end of your lines and declare variables. I think you're missing a " at the end of c.setattribute. I've never seen '&lt;![CDATA[' before, don't what that is. You should probably use === instead of == 
Why are you so negative about it? Someone asks for javascript, somebody answers with the way he solved his problem. So many people already got angry about the topic that it sound like 2012 was calling.
No frameworks last. You're best bet though is using the ones that adhere as closely as possible to current and future web standards.
100kB of tested library vs 30 lines of my own code? I think I'd spend my time drinking coffee after finishing the task with 100kB and 2 lines.
anything. From what I understand you cant bind event listeners to option elements inside a select drop down (specifically drop downs, doesn't affect option tags elsewhere. I wanted to show custom tooltips when you moused over options in a drop down without having to code a custom drop down. It didn't seem possible.
Actually I'm sure that was a calculated move. Naming a language something unique means all you need to remember is that name. Name it something like Hack and you will refer to it as "Facebook's Hack" language giving them brand recognition.
&gt; About 4,610,000,000 results (0.44 seconds) I don't know what you did to mess up the google search query... 
I guess I'd take it on a case by case, but rolling your own library for the sake of a few ms because of old devices still seems like a bad idea to me. Could also look into [building jQuery minus various modules](https://github.com/jquery/jquery#how-to-build-your-own-jquery) which would have the up side of easily being able to add those modules in later.
&gt; With any REAL programming language &amp;#3232;_&amp;#3232; To be fair, the reason JavaScript is forgiving and allows for sloppy, error-prone code like the snippet you included, is because the standards body who develops the language (TC39) values backwards compatibility, so scripts like the one you included will actually run. Always declare vars, and always end lines with semicolons. Once you memorize all of [JavaScript's ASI rules](http://bclary.com/2004/11/07/#a-7.9.1) (when semicolons are automatically inserted), then you can skip using them. JavaScript is a very real programming language and you can do amazing things with it, from high-level web graphics, to low level networking, and everything in between. You can't complain about a language being forgiving of mistakes, while knowingly writing code that contains those mistakes. If you would like to learn more about best practices in JavaScript, look into tools like JSHint and JSLint to help validate your code, and read "JavaScript: The Good Parts". Including the quote (as parent suggested) allows this script to compile. But without the rest of the code, it isn't possible to know why it isn't working.
Please see my other comment regarding bad practice in your code. I believe your issue is on this line: &gt; C.setAttribute("d","M 0,0 L "+pieceWidth+",0 "+pieceWidth+","+curveHeight+" C"+heightCPX+","+heightCPY1+" "+heightCPX+","+heightCPY2+" "+pieceWidth+","+LEP+"L "+pieceWidth+","+pieceHeight+" "+TEP+","+pieceHeight+" C"+widthCPX1+","+widthCPY+" "+widthCPX2+","+widthCPY+" "+BEP+","+pieceHeight+" L0,"+pieceHeight+" 0,0) You appear to be missing a " at the end. 
$(module.init) &lt;-- this I am not used to seeing. Will jQuery '()' execute this?
What I am trying to do is on connect when there are two sockets, fill a room where the sockets create new player objects which each socket gets assigned to. The players will have: id- for the socket id name- for player name score- to keep track of score something along those lines.
The reality is that jQuery will not be the go-to library forever.
Are you generating requests' IDs in the client? Isn't it dangerous? ([image](http://i.imgur.com/tQVBMtl.png))
w3schools is good for one thing: checking my SQL syntax
"ya let me just add this 10mb pack of junk to my files so I can animate some css. Thanks for the tip"
Now do it for IE7!
I don't know how to quote W3C properly but the specification states void elements do not need to be closed in html5, if you're not joking of course.
He manipulated the search on purpose. &gt;What it ***felt like*** looking for non-jQuery help
the point is that it's a lot easier to just animate/transition css in the css file than to install jQuery to use the .animate() function as every google search seems to suggest. People are far too reliant on jQuery when those sorts of answers to questions get voted up. I would never install jQuery ever again but I know that when I removed it from my website my filesize dropped from 1097kb to 155kb.
I hope so. I hope for new, better APIs build on top of javascript and browsers. Maybe not that intertwined and with a bit different choices ;)
You aren't forced. Out of the box, it uses the AMD commonjs wrapper. You can easily convert a project to CommonJS using the browserify-ftw npm module (which I contributed to recently to make it work with famous). Here are some instructions on how to convert famous to commonjs. https://github.com/Famous/famous/issues/27 Furthermore, we're eventually going to support a module pattern that is compatible with both npm, bower and components. 
All this you don't have to doesn't mean you shouldn't. stick "use strict" at the top of your document and make your program run. It will make your life better and the people you paste snippets to.
HTML5 != IE6 friendly.
While I understand that adding jQuery for simple animations may be a bit of an overkill, yet it's a working solution to do so - I guess adding this 75kB library to the site won't make them any difference for a person asking "how to do basic html animations" while actually working. And... "Easier to animate/transition css... than to install jQuery" - well, that's a trivial use case and you've highly extrapolated "the bad stuff" (big file size). That's not very effective way of proving any point or convincing anybody.
jQ, jQ-UI
But if you look at the image, it's a photo of a letter of resignation, implying he works with html5 and if someone wanted him to write something IE6 friendly, he would resign.
JQuery has two index accessors. Subscript notation gives you DOM objects. Using eq() instead gives you a wrapped element. A wrapped element has all the DOM methods and properties plus a bucket of useful jQuery methods.
yeah, it's called webpack (http://webpack.github.io/)
We've been slowly moving away from using jQuery in our application. We're lucky to only have to support IE 10+. Here are some general things we've learned: * Using something like Backbone or React greatly decreases the need for complex DOM traversing/DOM selectors. Most selectors are contained within the view you're working on. * jQuery Ajax combined with Backbone/framework X has to tendency to create circular references and therefor memory leaks. * Underscore/Lodash has most of the non-DOM/Ajax functionality you need, and more. On DOM travering/selectors: * Native DOM selectors are extremely powerful and when used correctly a lot faster then jQuery for one reason: .querySelector instead of .querySelectorAll. jQuery has no clear way to stop traversing after the first element has been found. As soon as you use Backbone/React/any other framework that creates views, your views are so incredibly small that most of the time querySelector will suffice. * jQuery caches queries A LOT. In the long run in a big Single Page Application this will run up memory, creating random crashes as you hit the memory ceiling. * Creating an object where you namespace your own events is really easy to do and ensures proper event clearing without weird tricks. The only thing you'll miss is a wrapper for triggering your own events, which you can make. * Ajax requests are a meh. Memory leaks gallore if you're not careful. * Measuring: while true, its not very clear. It also allows you to think on your feet. I've been using element.getBoundingClientRect() more often then element.offset().left etc. GetClientBoundingRect is relative to the viewport and also returns right and bottom. More elegant in a lot our use-cases. And if you need offset, a wrapper is not difficult to write at all. *edit:* Formatting
Metered ISPs around the world love you.
Mootools will rise again! You read it here first.
So basically you're better-off not learning Polymer, right? Libraries like Ember and CanJS let you do custom components. As browsers implement web-components your library of choice will leverage those capabilities but continue to give structure to your app, while Polymer doesn't offer that.
Don't forget [$(foo).get()](http://api.jquery.com/get/)
Unclosed void elements are IE6 friendly though.
Rails is a framework for building web applications. There are plenty of others for Ruby. I'm a Ruby developer who's never used Rails. The parent is talking about looking for Ruby help without Rails results.
Polymer allow you to incapsulate control aspects into reusable tags, that is most logical way to organize components in web based (read html + css + js) application. 
use `document.write( testor( [1,2,3,4,5], poop ) );`
[can.Component](http://canjs.com/docs/can.Component.html) does this... except the CSS part which is a minor and temporary (until browsers implement that) inconvenience. Given the fact I would be required to use Polymer on top of an MVC library to get architectural benefits and the fact that (last time I checked) Polymer is heavier than CanJS and almost as heavy as Ember I don't think it's worth the effort. I see Polymer more as a learning platform for a future browser feature.
I was suprised when I couldnt find a way to go through the different images. Had to close one, wait for the fade to end, then click another, and wait for it to fade in. If you could make it use Left/Right keys or overlay arrows to click to go through the images, that would be my only suggestion :) Looks good though!!!
"How do I load a library dynamically?" "Use JQuery for that." "But how do I do that without JQuery?" "What are you a traitor? Why do you hate JQuery!! Why can't you purists just accept JQuery the Christ in your heart and be born again like me?" "But I was gonna load JQuery dymically...in a bookmarklet." "Oh.."
You could just add the player name to the socket object. That way you dont need to create and manage a separate object. // Set player name socket.set('playerName', name); // Get player name socket.get('playerName', function (err, name) { // Do something });
Except when bar is a variable instead of the name of a key. If bar is set to be a variable, then you have to use foo[bar] for it to work properly. Correct me if im wrong, as its always good to get things wrong and learn things :)
&gt; Apache is functioning normally I don't think microjs is running.
Using [Browserify](http://browserify.org/) is much better than just concatenating multiple javascript files to one.
&gt; If bar is set to be a variable, then you have to use foo[bar] for it to work properly. Well, yes, obviously, but that isn't relevant here because the example was `foo['bar']`, i.e. bar is not a variable. 
They have 2 different use cases really, although a solution can often use one or the other. An if statement is more about flow control while a case/switch is more aimed at identifying data. If I need to check a single condition then I would use an if statement, I can then break or return the flow and have clean code after it for the false case. It's also alot nicer to read this: var d = 1; if(d == 1){ return "Is one"; } return "is not one";
They do on mobile.
Sorry if this comes off harsh: If you're learning JS, you need to refrain from "it should" statements and concentrate on "it does/is" statements. Accept it for what it is and you will learn faster. Reading "Good Parts" by Crockford will also help.
Angular and Ember both announced they will allow Polymer for components. If you develop the components separately without the framework in mind, theoretically, you can port them between frameworks with little effort.
It would be absurd to use `switch` for most of the common use cases. Example: var foo = document.getElementById('foo'); if(foo) foo.classList.add('bar') vs. var foo = document.getElementById('foo'); switch(foo != null) { case true: foo.classList.add('bar'); } That's just insane. Having to write out the `!= null` and `case true:` is really noxious -- who would want to do that? The necessity of being explicit about `break` is inherited from C, and it makes it possible to write fall-thru cases. That's the one thing that you can do with a `switch` statement that's difficult with a series of `if` statement. Without that, there would be really no need for the `switch` statement to exist. 
it's without www
Have done this in the past: get unminified jQuery, write your code in jQuery. Debug code with Firebug or your in-browser dev tool of choice. Profit! Bonus is, it forces you to learn how jQuery works under the hood and you might learn some JavaScript techniques you weren't aware of. I did this recently when I needed to do something that's a one-liner in jQuery, but didn't want to load the library just for that one purpose. 
I would use such a construct and in some languages it is the "way" switch( document.getElementById('foo')) { case undefined: console.log("undefined"); break; case null: console.log("null") break; default: console.log("not null") } Something else to consider is that in java, c etc, you can only evaluate primitives in a switch. 
But that example doesn't make any sense. I don't find myself wanting to log whether something is null or undefined or not null very often, if at all. I would just write `console.log(value)` in that case and it would be readily apparent in the log whether it was null, undefined, or some other value. What I find myself doing quite often are things like querying the DOM, and doing something with the result if it's non-null, as in my example, which is a particularly poor use of `switch`. Also, the return value here is discarded, which makes it especially useless.
Switch conditions are generally faster to execute than if conditions, but their syntax is atrocious. If you fail to include a **break** keyword in a *case* clause of a switch block there will be fall through, which is seriously error prone if accidental. The *if* and *else if* conditions also allow a substantially higher degree of expression than *switch* blocks do, which is generally necessary and also generally explains why *switch* blocks are generally faster to execute. I personally avoid switch conditions, because i want to reserve use of the **break** keyword for actually breaking out of a loop of just exiting some condition.
I wonder how hard this would be to use for ARM Thumb code? The Espruino JavaScript board just got inline Assembler support, but the assembler in the Web IDE is pretty rough around the edges.
I looked at this and thought "really cool project, can't see any practical use for it though". That Espruino board looks like the right use case for something of this ilk. It seems like all the x86-specific stuff is actually imported from an xml spec file. Not sure how easy or hard it would be to write an equivalent spec for another architecture.
A more simple approach: var $ = function (x) { if (document !== undefined &amp;&amp; document.getElementById !== undefined) { return document.getElementById(x); } return null; }, _ = function (x) { if (document !== undefined &amp;&amp; document.getElementsByTagName !== undefined) { return document.getElementsByTagName(x); } return null; }; For those of us who are not afraid to walk the DOM this shorthand is completely enough. For extreme power users who need to extend the shorthand of searching by tag name against any node and returning a proper array, oppose to just a node list, and automagically supply event binding I create a micro-framework to solve for this at line 983 of http://mailmarkup.org/xyz/ My little micro-framework got me more than I ever got out of jQuery in only 67 lines of code.
$(fn) is a shorthand for $(document).ready(fn)
Factory bullshit drives me mad. If you really want to improve your JavaScript skills you must admit to yourself this is not PHP and not Java. Then attempt to write your code **without** *this* and **without** *new*. It may be painful at first, but once you figure it out it will be like a revelation. I further recommend putting all of the above into a single function, since its not doing much anyways, and using closure where necessary. JavaScript does not have native classes. Don't pretend like it does.
Just have to be careful that the you aren't using a firefox only feature. I've been bit by that a few times.
I understand that js is a different beast. Your comment isnt very helpful though. What's wrong with the factory pattern? Why do you suggest not using new and this? Why would I wrap all this in a single function and not use dependency injection at the application level? ( this is pretty much psudo code I wrote to illustrate my problem. My actual application is more complicated )
So... Not minecraft pistons...
You made me check whether I'd posted to the right subreddit.
You only need self-closing tags if your page specifies XHTML Strict. Pretty much nobody does that. I used to, when I was insane. FWIW, the rendering engine was noticeably faster with it set, since it could assume a pretty rigid set of rules to parse against. In the end, it just wasn't worth the maintenance pain.
Ah, another JavaScript library with classical inheritance. BOY DOES THIS LIBRARY SUCK! LOOK AT THAT AWFUL SYNTAX! /sarcasm ...so I guess this Google engineer doesn't know anything about the language either because he's "hacking" JavaScript with some REAL private and protected variables: http://philipwalton.com/articles/implementing-private-and-protected-members-in-javascript/ And I suppose all you JavaScript geniuses know more about the language than myself as well. Since I think this is a GREAT idea with plenty of scalability, I must be stuck in the stone age and not have the ability to really learn how JavaScript works, right? I must have no idea about prototype chains, first-class functions (closure), Symbols, Proxies, and all the other things in JavaScript that makes it an AMAZING language. As a complete and utter moron, I should really take the time to learn the language like all you amazing developers. Now, even though I love JavaScript and think it's a really great language, I guess that means I have to accept everything they put into the language because Brenden Eich is a God and this is how he intended for the language to be. There was never a 10 year hiatus on the ECMA TC39 committee during the 90s when they argued this EXACT topic and pretty much halted the entire progression of the web for 10 years. Boy would I just LOVE to put classes together by assigning first-class functions to a prototype object on a function object which then magically extends an empty object from it when using the "new" keyword, or better yet, can use the amazing `Object.create()` function which is just so simple and elegant, right? Everyone should just do it that way! ...or maybe there are some developers out there who love trying new things. I mean, how else are you going to stumble onto something new and exciting? Hell, there are still plenty of developers out there today who STILL think Node.js is a HORRIBLE idea. But after seeing it implemented and trying it, plenty of developers came around and now they think it's great and is the next best thing in web development. Anyway, I'm happy to see someone else thinks that this is a good idea as well. There are PLENTY of ways to offer all kinds of syntax options, so all the developers who complain about the syntax must be very creative indeed. Here is my GOD AWFUL library for all of you to grill as well: https://github.com/gaulinsoft/jTypes Here is my explanation of why it's actually important: http://www.jtypes.com/blog And here is an introduction from a game engine technical article that I think all you haters should actually take the time to read (if you ever want to become good OPEN developers that is, otherwise just keep doing what you're doing): https://plus.google.com/+jTypes/posts/S3c6bEDfaX5
native Promise (e.g., Chrome) &gt; jQuery's implementation es6-Promise (shim) &gt; jQuery's implementation any A+ Promise lib &gt; jQuery's implementation
if you're using http://devdocs.io it pulls all javascript resources from MDN and all jQuery resources from the jQuery docs. Good stuff!
I've seen plenty of corporate, educational, and hospital sites that use XHTML Strict to "avoid issues" in IE 5/6/7. Not saying it is right, but there are still plenty who are stuck using it due to aging infrastructure at these instutions.
...which strictly speaking, isn't really IE6 friendly either. Thankfully we don't have to worry about that sort of thing too much these days :)
Some thing you learn might be have a benefit but it definitely has an opportunity cost.
&gt; Something else to consider is that in java, c etc, you can only evaluate primitives in a switch. Interesting JavaScript hack: you can call functions in your case: switch (foo) { case bar(): break; } It's a little smelly, but it can make sense in certain use cases.
If you're learning *any* language, natural or programming. It's worth asking these questions to discover best practices you suspect might exist. However, if you've learned the idioms and limitations of one language and still try to apply another language's, you're gonna have a bad time.
You know, maybe this could be good for sharing and commenting on assembly code. Not that there is a huge community of people writing ASM, but.. I could see the potential in the social aspect of sharing code.
&gt; error ... accidental Use jslint / jshint!
tl;dr [canvas.toDataUrl()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement#Example.3A_Getting_the_data-url_for_a_canvas) Also, the HTML5 canvas is super cool and I'm surprised more people aren't using it. I see things like basic polygon shapes being created with images or wacky CSS "hacks" that could have been easily rendered by a canvas, saving everyone bandwidth and headaches. 
Unless you need to support IE8.
In the past I've used this with some success: https://www.npmjs.org/package/deamdify No idea if it works on famo.us
Do you even jQuery brah?
I know your pain. We have one or two legacy .net 1.1 apps with similar problems. Luckily IE8 was actually a pretty decent browser (by IE standards)!
Yes and no. I did take that into account. It's not the number of issues, it is the type of issues that occur. Browserify has precious little it does on the client-side, and the complexity it does have is all occurring at build time.
Why does the site use a Java logo but with "JavaScript"? That's disgusting.
Maybe only that, and the ability to specify a filter function, would do most of what people do with selectors already.
The AMD commonjs wrapper is [pretty crazy black magic](https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#cjs) too. It uses regular expressions to extract the require strings using Function.prototype.toString... at runtime. I'm glad you are taking non-AMD builds seriously though. 
Be wary reddit's rules for self-promotion @ [/wiki/selfpromotion](http://www.reddit.com/wiki/selfpromotion)... &gt; You should submit from a variety of sources (general rule of thumb is 10% or less of your links being your own site)
No percentage width/height for the canvas element is pretty much a deal killer in a lot of situations. It also likely takes up more resources to do these sort of things with canvas, and potentially more code.
Yeah my syntax highlighting is picking this up too, I'm also seeing this as well: C = document.createElementNS(xmlns,"clipPath") Where I'm not sure if the variable "xmlns" is defined in the code block described (you may be declaring it elsewhere).
It goes to maintenance of overhead. A class based approach will have substantially more overhead to maintain than a purely lexical approach. This is because you have to specify all the integration points in a class based approach and provide patterns and provide wrappers for various components to work together with that integration. This takes substantially more effort to maintain in part because it is more to read as fragments where the connection points of those fragments is not immediately clear, or even known. You don't have to do anything of this with the lexical (closure) approach. Write less code and spend less time finding fragments in the code so you can spend more time drinking beer on the beach.
An expectation that linters should parent sloppiness is dangerous and separates newbs from seniors.
Also, remember that JS is functional! In some cases, you can use associative arrays and vectored execution: function a(x) { return x; } function b(x) { return x*2; } function c(x) { return x*3; } var vectorTable = { "a": a, "b": b, "c": c } var result = vectorTable["a"](5); 
And an expectation that senior programmers always write bug-free code and immediately spot small accidental errors is misguided and a waste of everyone's time. Programming is difficult, why not use IDE tools to improve your workflow?
You're right, it's XHTML. Habits die hard I guess. 
Isn't that more of a problem to be sorted out by making sure things are documented and structured properly? If your naming and separation of concerns are well thought out the application's hierarchy and dependencies should obvious. If that's not enough you should have commenting and doc-blocking to explain things that aren't particularly obvious at first blush, no matter the paradigm you are using. Can you give me a large open source project with many disparate components that purely uses closures in JS?
what the fuck is going on in this thread?
Contrived examples for the sake of illustrating syntax? You'll have to be more specific on what gets your goat.
Thanks for the feedback, though I'm a little confused about what part of the game you are referring to. What images are you trying to go through?
No, it's not at all like that. It's more like this: "Hey, my tire is flat, and I don't know how to fix it." "Hmm, I have a tire that will fix it, but first you're going to need to upgrade your rear axle."
Unfortunately `toDataURL()` won't work for large images -- large either by resolution or by being uncompressable (too noisy). 
Well, as you know, `$();` is just a shorthand version of `jQuery();`. The jQuery function accepts 3 types of arguments; `selector`, `html` and `callback`. In return you will get an object with an array-like structure, containing a lot of method names that I would say are pretty self explanatory.
Yeah, I just think it's wrong to introduce the concept with a shoddy implementation when we have a spec now. This would have been a fine article 2 years ago.
It's safe to say the author is [Missing the Point of Promises](http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/).
You don't necessarily need to concatenate all into just one file. You could use sprockets to manage how you want to concatenate your js files.
I think I understand. So Polymer elements can be seen as helpers/libraries to Angular and Ember.
The 'takes up more resources' is untrue. The canvas is GPU-accelerated and I've never seen canvas drawing as a bottleneck. 
Remember, canvas drawing is deferred to the GPU. There's little to no serious performance concern when drawing to the canvas. There *may* be a performance concern in how your Javascript is executing; what calculations are happening before/after the canvas is being manipulated. But that's a totally different ballgame. 
Also the German spoken video's are not Dutch...
sell it to the russians. i think uve got a billion dolla product there
@jesse I absolutely agree on the higher-level framework and we do that. It makes for all the more reason to reduce the responsibilites/capabilities/footprint of the lower-level dependency(cash in this case) of said higher-level one.
I'm curious how you got on NYT? Cool libraries btw.
Where are we at with the term 'noob'? Maybe I've never been geeky-cool enough to get it :)
But why not just split those three use cases out into three separate methods? It's a pretty huge violation of the single responsibility principle. Setting a DOMContentLoaded callback, finding existing elements, and parsing a chunk of HTML are three totally separate operations that should have totally separate methods. What if you only want to load part of jQuery? Will the functionality of `$()` change depending on which parts are loaded? That's even more confusing.
The video description from the website: A talk by Gary Bernhardt from PyCon 2014 This science fiction / comedy / absurdist / completely serious talk traces the history of JavaScript, and programming in general, from 1995 until 2035. It's not pro- or anti-JavaScript; the language's flaws are discussed frankly, but its ultimate impact on the industry is tremendously positive.
Yea. I'm referring to the rendering of the DOM itself. `&lt;canvas&gt;` is still a block element that needs to be painted into the flow. Granted, it may not be any better or worse in terms of resources for any other element.
I routinely ask about closures in interviews. You'd be surprised how many non-newbs know about them.
I think it is the NYTimes data visualization team that runs this blog.
lol first reaction upon clicking the link: "You used the wrong kind of brackets! wtf? Y U no write { closures } ???"
Here's what my heuristic is like: * I can install it with npm * code snippet on the readme using `require()` - from a quick glance I should see how to integrate the library into what I'm presently working on * has a very clear, narrow idea about scope and purpose * knows when to delegate to other libraries - doesn't try to do too many things itself * written or maintained by authors whose opinions about software scope, modularity, and interfaces I generally agree with (often a faster shortcut than reading the code/docs very closely) * inspecting which modules depend on the library I'm evaluating - this is baked into the package page for modules published to npm When a project tries to do too many things, parts of it will invariably become neglected as the maintenance burden is unsustainable. The more things a project tries to do, the easier it is to be completely wrong about some assumption and this can also lead to abandonment because it's very difficult to revisit assumptions later. The best, longest-lasting libraries are small pieces of code that are very tricky to write, but can be easily verified. Highly mathematical tend to be very well represented in this category, like the gamma function or an ecosystem of highly decoupled matrix manipulation modules such as [ndarray](https://www.npmjs.org/package/ndarray). When a library is embedded in an ecosystem of other libraries in a thoroughly decoupled way, a mutual dynamic results where the main library doesn't need to inflate its scope but gets enough attention to find subtle bugs while the dependent libraries can offer excellent interoperability and fit into a larger informal organizational structure. Here are some things that aren't very important: * number of stars/forks - often this is a reverse signal because projects with overly-broad scope tend to get much more attention, but also tend to flame out and become abandoned later because they take too much effort to maintain over a long period of time. However! Some libraries are genuinely mistakes but it took writing the library to figure that out. * activity - at a certain point, some libraries are finished and will work as long as the ecosystem around them continues to function * a slick web page - this is very often (but not always) a sign of a library that put all of its time into slick marketing but has overly-broad scope and is very likely to become abandoned
[a slick web page](http://browserify.org/) 
^a "slick" web page
Naturally.
&gt; Isn't that more of a problem to be sorted out by making sure things are documented and structured properly? No, and trust by verify. Once you have figured out how to organize your code in a lexical fashion you can answer this question yourself. I have no doubt the answer to this question is apparent and obvious, and will be to you as well once you figure it out. &gt; Can you give me a large open source project with many disparate components that purely uses closures in JS? http://prettydiff.com/
As in: you would be surprised how many non-newbs don't know about closures, or you would be surprised at how common it is for non-newbs to know closures?
That is not what I said. Linting tools are helpful, but there is a world of difference between catching accidents in the code and expecting tools to auto-magically solve for incompetence. If this is less than clear then we can this conversation in mutual disagreement.
The nice thing about linters is that they tell you "this is probably wrong, please fix it" and you can google the message and learn how you're supposed to write it. It's good as both a self-education tool and as a mistake-catcher.
Can't you attach this to a resize handler with a small timeout and solve that issue? ctx.canvas.width = window.innerWidth; ctx.canvas.height = window.innerHeight;
My guess, without running any debugger against the engine itself, is that you're seeing a lot of compile-time optimization. If there are two things that compilers are heavily optimized to do, it's looping and control logic. Decades ago, the choice between switch or ifs was much more important, as a series of if/else would always literally run through each check in sequence, while a switch could essentially work like a hash, and quickly match based on its position ( O(n) vs O(ln(n))). Obviously we've come a long way and this is almost never the case anymore. Unless your ifs are actually running something functional, the compiled code is unlikely to be running them all in sequence, as it's just a comparison operator against a primitive. I have a feeling that FireFox expects switches to always work like lookup tables, so you'll notice it does exceptionally well in the switch(homo) case, but very poorly when the index is constant, because it's probably looking those up the same way. I think the browser differences between Chrome and Firefox are by far the most interesting result of this test. Firefox optimizes a sequence of ifs comparing a constant way, way faster than Chrome, while Chrome looks constants up very quickly in a switch, and optimizes its long-list-of-ifs for the case that the comparison is a variable. It'd be interesting if you built out the comparison statement a little more - perhaps Chrome does best for complex ifs, while ff does best at simple ones. There's really no right or wrong approach. What makes it an optimization is that it has to be worse at one thing to be better at another. Of course, since node.js is a place where perf tends to matter more, and that runs on chrome's engine, this suggests I ought use switches on my server-side code when it looks up values based on constants 1million+ times per request.
I'm not in the bay area, but I'd recommend finding a local user group and attending. There is sure to be a local JavaScript group that you can join. A lot will be over your head at first, but soon you'll pick up on things as you study JavaScript on your own time, and you'll be a much better developer in the long run having learned in a room full of potential mentors.
Closures for people with short attention spans: http://www.youtube.com/watch?v=1R2A8Q4QPa8
Thanks for your comment. It helped me a lot in understanding the graph. However, I found that the graph still has some interesting stuffs. First, on Chrome, switch(last), the "default" case, runs significantly faster than switch(1st). This is against our conventional idea, where the default case is the last choice made after failing all other cases. I have no idea, of course, and even started thinking it's actually not intended by the developers. lol Second, if(homo) is far slower than if(*). If if-statements are JITed into a lookup table, it should take the same amount of time to look up random values. One possible reason is that FF reorders the cases depending on their frecency. This can also explain the exceptional performance of FF in other if(*). 
What are your thoughts on statistical analysis of software complexity? I ran across [plato](https://github.com/es-analysis/plato) and [escomplex](https://github.com/philbooth/escomplex) yesterday, and I was considering adding it to my heuristics. __As for NPM:__ I love npm as much as the next guy, but I think long and hard these days before I try to use it to install anything that will only be used on the front end. Especially if it's going to need to include jquery somehow, but basically anything that interacts really deeply with the DOM. I find that installing the package with bower, and then using the package.json browser field, leads to many fewer unintended consequences. 
Some of us still have to support all the way back to IE6. Weep for us, not the IE8 crowd.
Thanks Nick. I have been to some so far but was hoping to find someone to code with for motivational reasons. I appreciate the advice.
No problem. I wish you luck. You might consider posting to the local subreddits. It may seem like a rather random request for those, but when we posted about our Intro to Python night in /r/pittsburgh, we got our biggest response ever.
The thing is - putting together node with websockets is not enough to do what Meteor does. Can you have several app servers connected to the databases those get realtime updates from 100s and 1000s of clients across different servers? Probably you can put something together with additional Redis server or just paying for Firebase but how much time would it take you to get it right? For you second point about decoupling: you are right, there is a plan to get Blaze (ui rendering engine) to a separable component. Blaze is actually comparable in performance and design to react. It is not really handlebars, more like a syntax resembling them but the rendering engine is entirely different. And the community already figured out how to separate client components from server. There are tools to do it and it is pretty straight forward - Meteor's codebase is a set of packages. Definitely don't hesitate to take a second look.
Nice, and good work including the original authors in the copyright, but why not send a pull request against Tween.js?
People who use linters like to focus on the pedantic aspects of programming. While you're busy linting your code and fixing missing semicolons, your competitors are shipping code that just works, because they know it works. Linters aren't going to make your code work if you already know what you are doing. Shipping code is more important than being pedantic. I'll be happy to eat your lunch while you're busy linting.
&gt; As of application structure. I would recommend using modules. This. Modularizing, clearly identifying inputs and outputs of each module and the data flow makes for manageable complexity. Divide et Impera
I modularize my apps in my own way and use jQuery.
This is a great advert for jQuery. Just look how readable and short is the jQuery code.
Edit: Learn something new every day. Edit edit: Apparently there's learning value in stupid comments. I don't have it exactly, but it was something like this: function outer() { function inner() { console.log(x); } var x = "Behold the power of closures!"; inner(); } outer();
Edit: This is, in fact, an example of a closure, but it's not a useful one (see my [other comment](http://www.reddit.com/r/javascript/comments/23arbj/javascript_closures_for_beginners/cgw0p5p) below). ~~This isn't an example of closures.~~ When `outer` is called, it declares the function `inner` every time; the lexical scope doesn't *need* to be captured because it's never lost in this context. The point is to have a function that is created within a scope (which "holds" the scope) even after you *"lose"* that scope... function outer() { var x = "Greetings from the closure!" return function() { console.log(x); }; } var inner = outer(); inner(); // Greetings from the closure! You see that even though the scope of `outer` is gone (the function has been called and exited), the function that it returns retains the value of`x`.
I won't use libraries that depend on jquery. Other dependencies are fine but that particular dependency causes nothing but problems because people make all kinds of crazy anti-modular assumptions when jquery enters the picture. Bower is really rubbish for packages that have rich dependency graphs because of its flat namespace, but I'm only interested in packages that can fit into a rich dependency graph without stepping on each others toes and without incurring dependency hell. npm was explicitly designed to solve dependency hell and it does. You can just `npm install pkgname` and not worry that pkgname's dependencies will break your app in some incomprehensible way because its dependencies conflict with the dependencies elsewhere.
yeah. that dependency. \*shakes his head\* I use bower for packages that don't have dependency graphs really. like d3.js and three.js. basically stuff that i will need to shim anyway, and will never load on the backend since there is no DOM. 
Hmmm... I wonder if he's pronouncing JavaScript that way because of some accent (though he doesn't *seem* like a native Spanish speaker...), an odd speech impediment or just to be a douchebag? Either way, it's annoying.
This article makes a common mistake regarding closures: it conflates them with a function returning a function. From the definition presented in the article: &gt; In JavaScript, a closure is often referred to a function returned by another function. And every example of a closure in the article is just that, a function that returns a function. This is certainly one way to create a closure, but it's hardly the only way, and most often it is a confusing and unnecessary way to create one. I often see this technique used by inexperienced JavaScript programmers when simpler code would do the job. I [wrote about this at some length](http://www.reddit.com/r/javascript/comments/22m7cm/the_insiders_guide_to_javascript_interviewing/cgosyzy) in another recent thread. A company that hires out JavaScript (and other) developers wrote an article about interviewing JavaScript programmers, and they made this mistake, using a function returning a function to create a closure where a simpler named function would be a better solution. 
Just for future reference, it would be much better to keep your original comment and add the edit note at the end. That would preserve the context for comments such as minrice2099's and make for a more enlightening discussion. Do you happen by any chance to have a copy of your original comment somewhere? If you do, it would be great if you could copy it back into the comment. If not, no worries! :-)
Ah okay, why would someone want to do that? The only reason I can think of is to pass variables client to server or if you didn't know PHP or ASP etc. 
Typescript is awsome. I know it's fashionable to hate anything coming from Microsoft, but IMHO, this is a gem. With that said, ES6 is almost always a better bet than a javascript compiler. Things like generators and promises are going to be mainstream pretty soon with browser adoption and you'll have to be using ES6 to get a load of that.
*Some* people lint pedantically. I personally turn off a lot of the niggly style rules and instead take advantage of more serious warnings like "this variable wasn't var'd" (typo or leakIng variable into global), "missing break in switch", "missing .hasOwnProperty inside for-in loop". Yannow, things which may actually cause bugs which are hard to track down while running your code. A lot of the linting rules are simply stylistic, and that's great for beginners who don't know good style. But when you know what you're doing, you also know how to configure the linter to help you double-check your work and help assure you that your code will in fact work when it's shipped. I'll be happy to eat *your* lunch while you're busy debugging a missing `var`.
I find managing a large code base in any dynamic language becomes tough, and I start to miss types. This may just be my background so YMMV. That said, I recently converted a large codebase to typescript with good results. It's much easier to reason about abstractions, and several bugs emerged. Future versions of typescript will include the ES6 stuff, which is not yet widely supported enough to be used in anything other than intranet or tightly controlled environments.
Did you find the TypeScript compiler slow?
if you are serious about big JavaScript then you'll like this very practical presentation that shows how TypeScript would keep your large codebase manageable.
Thank you. My nerd rage was rising while reading that article. You have provided the only *real* example of a closure so far. Returning a function is powerful. Accessing variables existent outside your scope is powerful. But accessing a variable outside your scope when the scope that declared that variable is no longer active is the *only* definition of a closure. **update** I'd just like to point out that you don't have to return an anonymous function to create a closure. This is a common pattern for creating what I call "stretchy methods" which uses a closure: function MyClass() { var self=this; this.stretchyMethod = function() { self.doSomething(); } } var instance = new MyClass(); instance.stretchyMethod(); // invokes closure, calling doSomething()
Watch this presentation about a practical case for TypeScript: http://channel9.msdn.com/Events/Build/2014/3-583 
At the moment, there may be no practical use for it - but once you want a NDK for JS-based systems like Firefox OS, there's suddenly the demand to have something that can create binaries without having a binary first.
Can you explain why you're calling that a stretchy method?
As a Finn I can confirm that his pronunciation is 100% correct finnish pronunciation of Javascript. 
Backbone gives you some pieces and let's you assemble them. Angular gives you all the pieces and tells you how to assemble them. Angular is "opinionated". If you feel out of your depth in backbone, chances are you would benefit from using an opinionated framework so that you can see some good patterns in practice. Once you're experienced with angular or ember, or whichever, you can come back to backbone and I bet it'll make a bunch more sense :). [Edit] as for jQuery, there are not many reasons not to use it. You can build your own (probably poorly designed) power tools to work with, or you can just download em for free in the form of jQuery. Its fun and insightful to use plain js, but often more practical to lean on a few quality libraries like jQuery and backbone.
Yes and no. You can always go through exercises like https://projecteuler.net/ or http://www.codewars.com/ but you will not often find whole applications worthy of an MVC framework in there. My first big app was an oDesk request. I underbid to get the job and worked my butt off learning how to do things. I was dealing with the client's requirements and just concentrated on implementing it.
The TS compiler is surprisingly slow, even with very small projects it takes a few seconds just to compile the TS files. Its not a deal breaker but I do find the delay annoying when I'm trying to tweak apps.
Will keep that in mind and also look into both the sites. Thanks again.
Well, you can take client side code and run it on the server and only have to change a few things.
I think that's just your anger issues
Hmm... I'm not seeing any JavaScript at all in the code you posted. That could be a problem :)
Start with [Knockout](http://knockoutjs.com/), it's MVVM (model-view-viewmodel) and has a much lower learning curve. Go through their [interactive tutorial](http://learn.knockoutjs.com/), it's quite nice at showing you what it's all about.
AFAIK Sublime is maybe not the ideal choice for TypeScript as Sublime doesn't deeply understand the language (it is a text editor, not an IDE). I use WebStorm myself and it can do all the sweet stuff like safe project-wide refactoring. But to compile TS you can use the default compiler or a wrapper, like for grunt (`grunt-typescript` or `grunt-ts`) edit: a quick google turns up this: https://github.com/Railk/T3S which looks promising.
I don't see any reason TypeScript couldn't add ES6+ features and still serve as a preprocessor that offers static-typing for tools/bigger projects. Not sure how TypeScript will choose to handle features that will be impossible to shimmy together a backwards-compatible version of, though.
Have you gotten to the 'compartmentalization' stage? I wish he had time to go through that in a bit more detail. How do you link together multiple compartments? He mentioned generating a single .js and d.ts file for a larger set of files, but how do you do a single d.ts for and/commonjs modules?
It really doesn't scale well at all unless you use external modules
If you watch around 8:00 he starts out saying JavaScript with a 'proper' J sound and he 'corrects' himself back to his pronunciation. I think he's saying it the way he is on purpose.
I disagree. Having the function return something takes priority. So, there should be one return at the very end and maybe one or more at the beginning (error, special case, from cache, no calculation required, ...). If you change that "else" to "else if", you might (implicitly) return `undefined` in some cases, which isn't what you promised in the documentation. Not returning something by accident is something which happens somewhat frequently with JavaScript. With other languages, where the return type can/must be mentioned in the function's signature, the editor/IDE/compiler will generally notify you of this issue. Also, if you change it from return to assignment, you're making the function a lot uglier. Maybe you shouldn't do that. Anyhow, I wouldn't preemptively increase the cyclomatic complexity just because I *might* decide one day to uglify that function. Nice looking diffs are just nice to have; it's not a priority.
Hmm.. yeah, I see your point. If this block changes to setting vars instead of return, then the code should be significantly more complex (ideally not much--but significant) and it's worth highlighting that change.
TypeScript is awesome if you're using an IDE because you can get instant feedback on types in your code, with auto-completion and red squiggles. If you don't plan on using an IDE like Visual Studio, though, you might as well just use ES6.
Even without the IDE there are some advantages. You can catch errors at compile time rather than runtime. Although with the above mentioned slowness of the TS compiler this isn't as big a benefit as it could be.
Either I write super awesome code or something is wrong here... I dumped 579 LOC into jscomplexity and it gave me a maintainability index of 119. Everything I just read about that index (0 being bad, 100 being excellent) means that I'm a badass!
I'll try. In Java/EcmaScript, any function can be called and executed from anywhere... you can even apply a function defined on one object to another object. I'm sure we all know this. But when you apply a function to another object, the "this" pointer switches to the new object. This is usually fine if you define the function such that it doesn't really care which object it's attached to, but sometimes you want the function to only apply to the object it was *originally* attached to. But you may want that function called from another object... typically as an element event handler. So you can "stretch" the method by applying the function to another object, but the function still only affects the original object by a closure on the the variable "self" where self is defined as the original "this". I apologize if this explanation is weird, I'm having trouble finding a good set of words to describe it. 
&gt;I'll be happy to eat your lunch while you're busy debugging a missing var. That's funny. You assume I write missing vars into my code. I do not. It's a habit of mine to use them, that I simply cannot stop. I can't think of a single case in the last 10 years that would have been helped by using a linter. Of course, I can't say the same for my dumbass co-workers. They still can't quite grasp ASI, but then they are "full-stack" developers who seem to be jack of all trades and master of none. 
it is on the [roadmap](https://typescript.codeplex.com/wikipage?title=Roadmap&amp;referringTitle=Home) &gt; We also expect to add more ES6 features to TypeScript post 1.0: &gt; - More ECMAScript 6 language features &gt; - ECMAScript 6 modules syntax &gt; - ES6-compatible codegen
As an ex-Nokia employee I can confirm your confirmation. That's perfectly fine (you should hear how badly I say Finnish words...). It's not the pronunciation, it's the affectation that was bugging me. Apparently I missed the gag.
It compiles to JS, so it's reasonable. 
It was just an example. The return line just represents a piece of arbitrary code. Normally, I would write that like this anyways: return x == a ? z : y; 
Are you already well versed with JavaScript? If not, you should learn the basics before diving into a framework. Otherwise you won't have an understanding of why different frameworks are the way they are, the quirks that make them special, etc. If you know the language better you'll have an easier time deciding which one you want to learn. Understand first WHY you want learn a JS MVC framework, then figure it out which one to learn. There isn't a "best" framework, it's all relative to your needs. For example, if you're learning so you can build an app quickly, then you'd want nice features baked in (2 way data binding, etc), so AngularJS might fit your needs. If you're learning MVC for your career and improving yourself, Backbone is less opinionated and lets you do things your way so that you can learn from your mistakes, improve upon your code, as there isn't "one true way" to do things. In any of these cases the I think the best thing is to not dilly dally and just jump straight into it and start writing code. Just pick one and go. That's the best way to learn!
Angular is probably beating Backbone in popularity. From what I've read about its approach, I prefer Angular to Backbone or Ember or whatever else. But everyone appreciates a different approach.
I love OPTIONAL static type checking that exists in typescript
Sure, but is strangulation the answer?!?
[Ever hear of 1TBS](http://en.wikipedia.org/wiki/Indent_style)? That is how you should be writing javascript code, and it will save you from some problems. Putting a return value on the next line after a return is a sin, and nobody who practices 1TBS would ever do that sort of thing. I do write 100% perfect code, believe it or not. I actually think before I code. When I write code, it is already well thought-out, well formatted, and runs the first time as I'd expect it to. I also write code and test in very small chunks. There is a button on my mouse who's only job is to refresh the browser, and I hit it *very often*. I catch any typos before there would be any chance to run code through a linter. I've been coding javascript for as long as there has been javascript, and before that assembly language and many others. I know what works and what doesn't. Noobs should probably use a linter, but there comes a time when it's just superfluous and pedantic for some people. &gt;Programming is difficult Not for everyone! 
That is quite a big question and even when broken up there are so many choices you can make. This could be your future: 1. subscribe to /r/gamedev and /r/html5games and /r/LearnJavascript 1. find a code editor that suits you (whatever if it supports JS) 1. find a way to create simple art (images usually so anything that produces PNG's) 1. find a html5 game engine/framework that fits you (so many choices, pick something simple with decent tutorials and docs. stay mainstream for now) 1. do basic tutorials for that framework: it should show where to put the code, how to import assets, how to get stuff on screen and reacting to input. 1. do some more tutorials, get comfy with your tools 1. make a simple test game (not your ideal game, but something very simple to learn the end-2-end process) 1. try to get it online in a browser and working, maybe even on your mobile. 1. read more about the game logic you need (animation, hit detection, simple physics etc) 1. optional: switch to another framework that actually does what you need (you know more then before) 1. make some simple prototypes to try stuff for your main idea 1. make the game you want 1. throw it away half finished because it is buggy and wrong and overcomplicated 1. optional: do something else out of frustration 1. read some more on game technology, try some new stuff, setup a debugger, get a better IDE, go level-up. 1. make the game you really wanted to make 1. $$$ 
I know it's a terribly petty thing to point out, but ... &gt; who's only job
Nice one. Surprised how little code this requires.
The raw score on jscomplexity is "from negative infinity up to 171". Plato and Microsoft's tools normalize it to 100. A 119 can be improved quite a bit.
um, okay, Mr. Pedantic.
I should also add that while 119 isn't horrible, that's your average. You probably have "hot spots" that go much lower as well as "gems" that are near perfect. Based on my other research, "churn" will kill your productivity. If a complexity "hot spot" also has a lot of churn, you need to iron that out ASAP. If it's complex but hasn't changed in a long time and has great test coverage, you can afford the complexity.
You don't always need a language abstraction to find type bugs. WebStorm (and many other IDEs) read code comments and can display errors when you don't follow them.
Thank you! this is what i have now but it still isn't doing anything: http://imgur.com/mwTbeCn
&gt; IDE like Visual Studio Basically the single most important reason for the existence of TypeScript - Visual Studio is the more importaint tool to MS and their ecosystem than which language is being used i.e. if you can't change JavaScript to fit VS, use another one. 
Not always. I am speaking to your mention of functions being created every time. You are correct in that the child function is created each time the outer function is called. This is why functions should never be declared in a loop. However, if the outer function is a shell for a large application the child function is created only in the one time that the outer function is called, and therefore the inner function can be called many times from a loop without recreation of anything. Example: var outer = function () { var a = 0, b = 1, inner = function () { a += b; }; for (b; b &lt; 1000; b += 1) { inner(); } return a; }; outer(); //499500 I am not returning a function and no values are retained, but there is still closure. Additionally, there are two functions that are each created once, and the child function is called 1000 times. Notice that the *inner* function returns undefined every time, because returning a value is irrelevant to closure as a concept. This is a perfectly valid example of closure because neither *a* nor *b* are local to the scope of function *inner*. These variables are declared in the higher *outer* scope, which explains why they are mutated in one scope and retained even after this current scope exits. To really dumb things down closure is merely the access of references from a scope that different from the scope in which those references are declared. **This is the very simple part.** Closure is only hard to understand because people **make it hard** by super-imposing irrelevant OOP concepts onto the concept of lexical scope, such as the *this* keyword and object properties. To keep things simple: in ES5 and earlier versions of the language **only functions have scope**, which means that objects do not even if they define methods (it would be the function in the method that supplies the scope and not its object).
You're spot on about not having to return a function object. I always forget that when I'm trying to explain closures. The point is that, however you do it, you have to leave the inner function accessible *somewhere* after the outer one exits.
[http://badassjs.com/post/93526882798/metal-js-its-happening-for-real](http://badassjs.com/post/93526882798/metal-js-its-happening-for-real) - 404 yet.. but comments seem to be already working.
You know nothing John Snow.
Yeah it'd be really easy to do, you already have examples from the other exchanges and bitfinex already has a wrapper available on npm [here](https://github.com/gferrin/bitfinex) if you're asking someone here to do it for free, then lol
It's similar to Kalei, but its more geared toward being a tool that helps you create your "toolkit"...not just auto-documenting the stylesheets.
You're right, that's *technically* a closure, as was your original example. They're just not particularly useful ones. You could easily replace the call to `inner` with `a += b` and get the same result. In fact, this would be *better* in this case as you wouldn't be wasting time on a function call (in some quick tests in Chrome and IE11, not using an inner function was between 0.7 and 3.7 times faster). I think the point here is that some closures are 'closurier' than others. Take this attempt at logging some numbers (`0` through `numTimeouts-1`) every half-second: function runTimeouts(numTimeouts) { for (var i = 0; i &lt; numTimeouts; i++) { setTimeout(function() { console.log(i); }, 500 * i); } } runTimeouts(5); // 5 5 5 5 5 While the loop correctly creates five timeouts at half-second intervals, it only logs the number `5`. This is because each function retains its reference (yes, in a closure) to `i` and only logs the result after the loop has finished and `i` is `5`. Here is a fix that creates a *second* closure, saving the current value of `i` within the scope of an IIFE, and using the returned inner function in `setTimeout`. function runTimeouts(numTimeouts) { for (var i = 0; i &lt; numTimeouts; i++) { setTimeout((function() { var closured = i; return function() { console.log(closured); }; })(), 500 * i); } } runTimeouts(5); // 0 1 2 3 4 Again, while you're *technically* right in saying that your code uses closures, I (and maybe others) would argue that they (the closures) aren't of any real value. The utility of a closure is in its ability to keep one or more variables around when they would normally be lost when they fall out of scope.
Hey all, creator of the project here. Thanks for the interest! The code/documentation is definitely a work in progress. I am doing my best to add more detail. To clear up some confusion, I created Fabricator to help me build "tiny Bootstraps" for clients (I work at a digital agency). That's what it helps you produce - your own little Bootstrap-like thing - what I call a "toolkit". Kalei, Pattern Lab, KSS, etc all do similar things, but none of them gave me the control, ease of use, frictionless documentation, and purpose that I wanted...so I created my own thing.
i know typescript ain't javascript and this post belongs under r/typescript along with all the jquery tutorials under javascript that should be under jquery. this is truly common sense.
Im seeing 2 downvotes, and no comments. Why is this library bad? Im a php developer. My js is just jquery plugins and have begining to make my own jquery code. Its a mess. I want to start doing Single page Aplications and thats why im messing with backbone(im lost), angular (seems so much complicated) and Enyo (just started today). This library seems to be easy enough for me and my requeriments, but I want to know from JS devs, why is bad or good. 
Also known as 7 basic javascript traits you'd learn in any beginner tutorial.
Also known as a decent intro to 7 very nice JavaScript features everyone should know
Not quite... If you wanted to create something like Bootstrap, you could use this tool! That's how we've been using it at Resource (digital agency) - building front-end "toolkits" for clients, rather than highly-integrated templates. Its a useful paradigm when working with CMS integrators.
In the case of my example you are entirely correct. The inner function is largely worthless primarily because it does not instantiate references of its own. I suppose I was just trying to make the point that closure is merely the crossing of scope boundaries. That said it is kind of puzzling why many people work so hard to challenge themselves on this otherwise very simple concept.
I remember my first beer.
So in ecmascript I need to create unit tests just to test something I can take for granted in Typescript? I think I'll choose the latter, then.
I use sublime every know and then, when I just want a quick edit. There are a couple of god plugins for sublime and Typescript. Just search for them with the package manager. They offer some auto complete. Not as good as Web storm or Vs though. Also, I think there was an ng-conf video on typescript and it went over these things. Should be on the angular js website. 
Hey, quit being an elitist dick. This sub is about community and the exploration of different aspects of JavaScript. Whether you like it or not, typescript is another part of JavaScript as it compiles down to JavaScript. Quit being an ass hat. 
Your HTML is incorrectly formated and although it should not be a cause of code failure in this case, it's always a best practice to have it right : &lt;div&gt; shouldn't be inside &lt;p&gt; and each tags should close in the corresponding order. What you're trying to do can be achieved with the &lt;audio&gt; tag introduced in HTML5 and compatible with most of the recent browsers. You should also look into a very popular javascript library called [jQuery](http://jquery.com/) which makes writing JS much easier and less verbose. Anyway, here is your code with some groovy music inside :) [http://jsfiddle.net/3wTvb/](http://jsfiddle.net/3wTvb/)
Dart's compiler is even slower (it's an optimizing compiler which analyzes the entire program). However, this isn't a big problem since there is a VM and the editor package also contains a build of Chromium with native Dart support. With a VM, compiling to JS is more of a test and deploy thing. Microsoft could do something similar. Unfortunately, they don't have a cross-platform browser. Additionally, installing multiple versions of IE doesn't work that well anyways.
Yep, type annotations provide a safety net, which will catch refactoring issues or some lib's "breaking changes". Without any types, you'll need tests which exercise each and every line if you want something similar. Just adding some types to the surface area is clearly the better option since it's a lot less work. Additionally, it acts as documentation and it also improves tooling.
Are you sure that's the right URL? Comments always load regardless of whether or not the article exists. For example: * Exists: http://badassjs.com/post/73526882798 * Doesn't: http://badassjs.com/post/73526882797 EDIT: I may be wrong here, but as far as I can tell every Tumblr's post has a unique number and we haven't hit 93 billion yet. EDIT2: Oh wait. Post in the future. Got it.
https://github.com/alexhancock/meteor-export-packages is a simple example for extracting client side packages (as I understand it)
FYI this [errors in Chrome and doesn't work](http://cl.ly/image/101Y1Q2S2522). Access Control Origin issues.
These aren't quirks, they're basic elements of the language...
The ratio of "ROMFGLOBL JAVASCRIPT IS WEEEEIRDDDD!!111 LOAL" articles to actually useful content is pretty high. Yes. We get it. '==' doesn't work the same way it does in other languages. 'this' has a behavior that is different too. We don't need another fucking article that complains about that. Please. Enough.
This is really sweet. How easy would it be to port my existing Tween.js code to using your library?
Would be better titled "JavaScript primer for C# developers"
There's no way Angular is beating Backbone in popularity. *maybe* with hobbyists and non commercial sites, but in terms of real, live companies, Backbone and Ember are both absolutely destroying Angular. 
JavaScript != !JavaScript
These two frameworks have such different approaches that it is very hard to compare them. I have used both, and personally prefer the approach AngularJS takes, however I think ExtJS has it strong points as well.
List some urls I can type in to test with.
No no no no. Unless what you are testing is the type system which makes no sense. Do you feel this way about code you write in whatever strongly typed backend language you use? Every hit of logic should be covered by tests in any language. Logic is what you are testing and types have nothing to do with it. 
To me typescript will at least fill the gap between now and es6 which is a very long time off on the client side where you are not in control. It's also far less fragmented that coffescript imo. That being said, I'm rugged enough to use js2js :D so I don't use either although I have used typescript on a few projects. It felt like forsaking every thing that is good and superior about Javascript to me tbh but I do understand why some teams feel it's a necessity. 
I'd also point out that in my pretty limited experience with angular you may pick up the basics more quickly up front and be able to put together a todo mvc app quickly. However, once the use case of the app steps outside of the typical applications you see in tutorials and gains some level of specificity, things will get thorny very quickly. Whereas with backbone you'll need to make design decisions to fit those specific use cases, that is the difficult part. Assembling the pieces of the design is very easy with backbone. With angular you'll begin to spend your time working around it if the needs of the app don't align well with the philosophy and lose any level of productivity you had up front. That's why it's so important to keep the tool belt stocked with various tools that you know the best use of. 
One final thing I'd point out is what you should *really* do is digest the underscore and backbone code by reading the annotated source. It is *exactly* what modern js is supposed to be. It's beautiful. I don't feel the same about angular. I do think it's useful but it's not like reading the underscore code. You'll learn a ton if you read through the source (and step through it) as you build up a simple app with it. They experience is going to be extremely valuable to you regardless of which one "wins". 
Source: https://github.com/conundrumer/crowdsound Not guaranteed to work on non-Chrome/Firefox/desktop browsers, sorry (though it would probably be too laggy on mobile anyways). EDIT: I'm also suddenly coming up with the issue of needing to refresh (the first time loading the page) for it to work. I'm not sure why this is happening.
Christ, calm down you psychos
I agree with you that types can give you some peace of mind in certain cases. Ultimately, I'm so entrenched in Javascript and have been for a long time that it feels like the trade off is productivity and flexibility vs the safety net and wanted to have access to traditional OOP patterns that I think are grafted on in Javascript. So as always it's all about context. However, what you would be describing above would imply logic is occurring to me and it needs coverage in any language. That's the gold standard. 
What you described is a not an issue with Angular in my experience but with the lack of planning and understanding what your application requires from the start of the project regardless of technology being used. Having said that, I'd say I'm quite familiar with Angular and I can't imagine a case where I would have to work around the current Angular capabilities to get the desired effect. There are some libraries which are necessary in my opinion to make it a complete package as it is but after learning and implementing those, it's ridiculously powerful. The packages are angular-ui and particularly ui-router, Restangular is nice though $resource is catching up.
Nice! It looks like yours is doing a lot more under the hood than one I built a while ago: https://github.com/bwiklund/kdtree.js Can you talk more about that stuff?
I found [this](http://www.objectplayground.com/) the other day which is super cool. Covers everything you're asking for and has a little interactive suite to go along with it
There are a few things going on that are maybe a little tricky: * The tree is stored in a flat typed array in [BFS order](https://github.com/mikolalysenko/bfs-tree-layout). This speeds up repeated searches due to improved cache utilization of the upper levels of the tree. * To construct the tree, a [linear time partition algorithm](https://github.com/mikolalysenko/ndarray-select) is used. * Traversals of the tree are performed in level order where possible to make best use of available cache. * All typed arrays are [pooled](https://github.com/mikolalysenko/typedarray-pool) for memory savings and cache reuse. If JS had value types the code would probably be 10x smaller, since a lot of the stuff in there is just extra loops for copying vectors around.
There are some cosmetic changes that weren't planned in "simple enough" features that creating full set of tests for them seemed like an overkill, or at least as a waste of time (considering there are other much more important tasks). Also there are moments when you remove some functionality and change it with new functionality, when most of previous tests get irrelevant and new tests are not yet done. Also if you're unlucky and working with undertested software - then well, you're on your own. Those are not very nice, but are real life situation many developers have to deal with (me included). As you've written - "you don't have enough test coverage".
Man those all sound like excuses to avoid writing tests. You need the tests to define what your app does so that you can go in and refactor it all (and make it better, but stilll pass the same tests) later. If writing tests is really that difficult you should get that fixed. It should be easier to write the tests than it is to write the code. 
The question should be: 'do you prefer Typescript or Traceur?', as both offer ES6 language constructs and neither of them implements all of them. If you want more ES6 stuff than just modules, classes and arrows, go with Traceur. If you're into types and only need a small subset of ES6, choose Typescript. I like types (adding a rubustness to complement tests, rather than to replace them) so I use Typescript for my current project and it's mostly nice. Webstorm doesn't always understand the code tho and the gulp plugin we use is terrible. 
This is great, I love music visualisation. I spent a bit of time last week making a bunch of visualisers for my music store startup. If you go here: http://kicktone.com/mixtape/yzmfwh/coding-music and click the little "eye" icon underneath the mixtape cover art, it'll load the visualiser, and if you hover over the cover art there are a few different plugins to choose from. All of them are canvas-based. Only works in Chrome at the moment because the code is sloppy as hell and really shouldn't be in production.
Oh absolutely. "Can't see a use for it" doesn't mean "there isn't a use for it". Just that I couldn't see one at the moment.
Check Douglas Crockford's classes out on [YUI Theater](http://yuilibrary.com/theater/?start=291).
First thing that grabbed me: String.prototype.replaceAt Don't modify objects you don't own; you can get away with it, it's OK if it's to shim/polyfill behaviour but it's generally bad practise. There's a plethora of articles but I'm struggling to find 'the best' so just google around, read a few.
Ah, thank you. What if I replace that for: if(!String.prototype.replaceAt){ String.prototype.replaceAt = ..... } Although I guess then the original replaceAt implementation should have the same outcome as mine... Interesting issue :)
I've seen if (typeof String.prototype.replaceAt !== 'function) ...
Crockford's the good parts talk is a good start imho, he also did a full series more in-depth: https://www.youtube.com/watch?v=JxAXlJEmNMg Skip to the second part if you don't want a history lesson.
if you are serious about big javascript you'll use javascript and not typescript
After nearly a decade of programming in JavaScript I finally stopped trying to force it into my perceived view of what I wanted it to be (class based, like Java) and accepted it for what it is - a [prototypal language](http://en.wikipedia.org/wiki/Prototype-based_programming). When you embrace it and stop trying to force something else on it, it becomes easier to use and more powerful. It's just a different way of looking at the problems to come up with appropriate solutions, and letting go of preconceived notions of the 'right way' to do something. I very rarely do any direct inheritance these days, there's little need - the same with mixins. Most often I just have properties that are instances of those objects. If I do need to do anything more, I just use the prototype directly. I don't use instanceof to enforce contracts like I used to, I find my code is more reusable and flexible if I just check for the things I need (which you have to do anyway to check the values) - a lesson I learned from the early browsers before standards were (largely) adopted. It did take me many years to see it.. but now my JavaScript code is clean and simple, doesn't use tons of wrappers/extensions/etc. which confuse things for other developers, doesn't create unnecessary dependencies that can clash with other libraries/platforms, and minimizes bloat. It's a compromise, definitely - but one in which I feel I've now got the better deal.
 Function.prototype.inherits = function(superClass){ function Surrogate(){}; Surrogate.prototype = superClass.prototype; this.prototype = new Surrogate(); } This is how I learned inheritance, which IIRC is done with the surrogate so that you get the superclass constructor. 
`Cakey = document.getElementById("cs1")`, after this line `Cakey` will not contain the value you want, but the element object instead. Use `document.getElementById('id').innerHTML` or `document.getElementById('id').value` to get the value from the element object (depending on what kind of element it is). After that you'll want to convert it to a number using `parseInt` and check for `NaN` values (in case the string is not a number). Just for fun, here's my version: function caesar(s, n) { return s.replace(/[a-z]/gi, function(x){ var t = x.charCodeAt(), l = t &gt; 96 &amp;&amp; t &lt; 123? 97: t &gt; 64 &amp;&amp; t &lt; 91? 65: 0; return String.fromCharCode(l? (((((n % 26) + 26) % 26) + t - l) % 26) + l: t); }); }
An extremely complex (data and animations, logic, etc) html5 app that was going to only be used on mid market Android phones (based on analytics and the pay scale of the users) was one example where performance was just not going to make it. This was basically true with any library with two way binding mind you. Consider, encrypting and decrypting data on save locally with two way binding present on shitty phones and the disasters that can ensue. There are a ton of use cases where basically nothing but the vanilla js framework and pieces of backbone make sense when you work in that context. We pray it won't always be true but by the time it changes we will hear "hey can you get this design responsive enough to work on my watch and glasses?". 
Object.create
This is going by the number of Angular projects in Github vs. Backbone and Ember. But, yes, there's no way of determining how many of those are hobby projects and how many are corporate.
Just a fact question. In JavaScript, is a switch _really_ faster than a dispatch? If so, why? Usually switches run in N operations against the options where a dispatch is a single logarithmic hash lookup. Is JavaScript different here? 
&gt; It has occurred to me that it could be done by having a string of the JavaScript code be built on the client Why? Is it so difficult to just compress all your files into one file using Browserify and UglifyJS? &gt; Are there any reasons not to do so?" Performance. Eval'd codes will never be as fast as regular codes. So there is not any reason to use it. IMHO the only proper usage of eval is to create a polyfill for the JSON.parse function. ;-)
I believe that any sound cloud link should work. The trick is that to copy the page you have to be on the actual song page. https://soundcloud.com/bassnectar/nina-simone-feeling-good-remix
HTML5 is fine. It is not dying. The writing in this article is terrible.
&gt; Why? Is it so difficult to just compress all your files into one file using Browserify and UglifyJS? It may be a bit difficult with a lot of files, but I don't think that will stop it from working. However, I think I'd be able to pack the JS to a smaller download size if the JS were to be reconstructed as a string on the client side - I may be able to get better results using custom compression + gzip + uglify than gzip + uglify. &gt; Performance. Eval'd codes will never be as fast as regular codes. So there is not any reason to use it. I don't follow the logic. If the code is 1% slower to run but I get 50% smaller downloads then it's likely worth it. However, those are made-up numbers, it may come down to tests so a decision gets made upon evidence. 
Can you add triple monitor support? [This](http://i.imgur.com/NsFa4fj.png) is what it looks like atm.
Unsolicited advice: from my experience, dynamically creating building a property name (line 27) is a maintenance headache because you (or anyone else) can't easily find callers of "setUint8" and "setUint32" if you need to going forward. I would still switch on the type (or better yet, create a mapping of types to functions or function names, which is essentially what a switch is in simple cases like this) to make your code more greppable and divorce the naming of your EventView methods from the types inside of your frame structure.
I get what you're saying and its probably a better way of doing it. I just felt clever that the dynamic property names let me write everything that I was doing previously that took a hundred or so lines into a single line. I can definitely see it being a huge pita to maintain. Thanks.
Do you have any data to prove your thesis? In my tests, once the code is evaled, it runs at the same speed of regular code.
Thanks, it's good to hear from someone who has tested this.
In my experience, visitors to sites rarely care about how small the stuff they're downloading is, but they do care about how fast it runs. Sure, minifying and gzip'ing code is good, but beyond a certain point, nbody notices the download speed. In any case, js files should be cached anyway, so regular viewers really aren't affected by download speed of any files. On the other hand, custom compression incurs two runtime costs every time a page is loaded. Firstly, you have to decompress the code, and then the code needs to be eval'd. The first gives a hang similar to the delay that downloading content will give, except at this point the page has been loaded and it'll be quite obvious that you're hanging. Additionally, you'll have to manually cache the decompressed code, or face having the hang exist for returning visitors. The second adds general sluggishness to the page. This will be felt most keenly on platforms that are already slow (mobile devices, for example) who are depending on you, the developer, to make everything run as fast as possible. Of course, on top of this, compressing compressed (gzip'd) code is rarely very effective, because if the original compressor wanted to further compress the file, they would have done so in the first place.
Can you show me (us?) some of your code? I'd like to see some of it
I made my own thingy ( https://github.com/Morantron/underclass ) just for fun, and to better understand the prototype chain. But in the end just using _.extend does the trick most of the time for me.
Nice work! I also did an experiment with canvas, webAudio and the Soundcloud API a few months ago: [http://www.michaelbromley.co.uk/experiments/soundcloud-vis/#muse/undisclosed-desires](http://www.michaelbromley.co.uk/experiments/soundcloud-vis/#muse/undisclosed-desires). Check it out and see what you think. I must say, your code is much more nicely organised than mine.
This is incorrect for the average Web application being accessed over a mobile network where the general case is that the network is the biggest bottleneck. Obviously with mobile you need to optimize up the entire stack but latency is being shown to be the biggest issue for performance of mobile sites through current research. Getting the above the fold content into the browser and on the page is of the utmost importance. If you are talking about a js heavy html5 "app", I think their is user expectation that it needs to "load", however. 
I did and it looks like this : https://github.com/laurentszyster/fragment.js
Is anyone still using Ext JS these days? I remember using it back in 2009 when I was still hacking together terrible apps with no understanding of WTF I was doing, and found it to be a godsend since it abstracted away so much stuff I didn't understand (how the DOM works/CSS/HTML etc.) That being said, I feel reallllly bad for whoever has been tasked with maintaining those applications.
You get hit by JS' poor tooling and the absence of that type safety net fairly early on. You can feel that drag as soon as there are about 3-5 KLOC, a dozen or so files, more than 1 developer, and maybe 1 or 2 libraries. From that point on, it just gets worse. In a *worse than linear* manner, that is. Well, it's "just" drag. Just like air drag, you can overcome it if you use enough force (this is why fast cars need that much horse power - air drag increases quadratically with the velocity). So, it's certainly not impossible to write large-ish applications in JavaScript. It's just harder than it needs to be.
The download time for a minified + gzipped JS file is pretty insignificant, even on a mobile device. I doubt you would be able to save much space using this technique anyway. 
&gt; That's the gold standard. In reality, however, not every line which calls some function is exercised by tests. Actually, it can even take a few weeks until someone trips over it in production. With TypeScript or Dart, some breaking change in some library or some refactoring/merge fuck up will be identified right away.
Extjs is the IE of JS frameworks.
E.g. a breaking change in some library or some refactoring/merge fuck up. With types, you can be sure that each and every function is called with the right kind and the right amount of arguments. With type inference, you can further ascertain that the things you're doing with an untyped return value are okay, too. Without types, you need tests which exercise all those lines.
Looks sweet! Is that WebGL?
They way Im loading scoundcloud is realllllly janky. If anyone can improve it and submit a pull request that would be awesome.
Haha its a lot more jiggly. 
The more and more I use it (not by choice) the more and more I hate it.
Docs are available without logging in. We meant to have it that way but didn't have time to get it done before the launch event. https://famo.us/guides/ https://famo.us/docs/0.1.1/core/Context/
Definitely. I'm a CommonJS person myself and the tools engineer at the company and the CTO/founder is a RequireJS person. At the end of the day, we realized that this dichotomy exists in the JS world and the best thing to do if make options for people in both camps. 
Bacon.js, rx.js, ripple.js, react, Ember's HTMLBars... man we are experiencing a renaissance of sorts in terms of client side reactive programming.
I was really hoping to see those two libraries get together. Thanks for the post!
I had to use it in a commercial project. I wasn't the lead developer, and when I joined, ExtJS was already firmly in placed. I found it to be surprisingly decent. The documentation was rather good, the API not too shabby. That said, I never tried to deeply modify any of the widgets. So, my impression is that as long as you travel within the confines of the ExtJS design, you are fine, but as soon as you try to do something in an unorthodox way, when you need to tweak and/or deeply extend something in ExtJS, you are in for quite some pain. Is that correct?
I'm considering how long the hang would be while decompressing the code. That would depend on the algorithm used. It may be something as simple as replacing the string 'f' with 'function', possibly some other replacements of the most commonly occurring strings. It could be done in a web worker process to avoid the UI hanging, but the app still would not have loaded. The server will be delivering a page that has yet to be activated, so it's not as though the user won't see anything for that moment. GZIP compression has a limitation to do with a 32KB window. A different kind of compression could be more tailored to compressing JS code. I don't know what 'original compressor' you mean in the last paragraph.
trust me, I know exactly how you feel. Fortunately everything at work is being ported to angularjs. 
Once you use ExtJS you will immediately recognize it by the default theme/icons and it is all over the place. SpecificMedia, Experian, etc have it in various places. I see it pretty often for being maligned on reddit. It has it's own paradigms. Every version of ExtJS has added more unnecessary complexity...to the detriment of the user base imho.
I will agree with you that the [essential complexity](http://en.wikipedia.org/wiki/Essential_complexity) of the two are the same, because they are trying to do the same thing; I think that require.js has a much higher level of [incidental complexity](http://en.wikipedia.org/wiki/Accidental_complexity) because of the way it tries to solve the problem. I'd actually love to hear your thoughts on the module stuff. I'm busy rebuilding nodezoo.com to be an example of [microservices](http://daemon.co.za/2014/04/monkeys-and-microservices) architecture, so I'm right now busy pulling in github stars/whatever to try and figure out a confidence rating for npm projects.
It's hard to show you some existing code that illustrates it as it's not what's there but what's not there. A better approach would be to have a specific and simple problem that everyone understands, then show some different possible solutions. This also allows everyone to wade in with their solutions to compare. Remember though, it's all a matter of taste.. it's taken me years and years to come to where I am now, and that wasn't down to a lack of understanding of the language. So let's do a classic OO specialization example where we have a Shape class then specialization classes that extend it to provide the code/data for specific shapes such as a Circle and a Square. Let's say we're ultimately going to be drawing these shapes on a canvas or something - I won't get into the implementation of that as it's not needed in the context of the example, but it helps me highlight another point. It's a trivial example, so doesn't fully show the benefits and is arguably a little convoluted, however I think it captures the subtle difference in thinking. If we were to use inheritance and standard OO practice in the vein of Java, without using any libraries or wrappers, which I sometimes DO find the need to do, we'd get something like the following ([from here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)): var Shape = function( x, y ) { this.x = x; this.y = y; }; Shape.prototype.move = function( x, y ) { this.x += x; this.y += y; }; Shape.prototype.render = function( context ) { // Do stuff. }; var Circle = function( x, y, radius ) { Shape.call( this, x, y ); this.radius = radius; }; Circle.prototype = Object.create( Shape.prototype ); Circle.prototype.constructor = Circle; Circle.prototype.render = function( context ) { console.log( "Rendering circle: " + this.x + "," + this.y ); }; var drawScene = function( shapes ) { var context = null; if( shapes &amp;&amp; shapes.length &amp;&amp; shapes.length &gt; 0 ) { for( var i = 0 ; i &lt; shapes.length ; i++ ) { if( shapes[ i ] instanceof Shape ) { shapes[ i ].render( context ); } } } }; // And define the data. var shapes = [ new Circle( 0, 0, 5 ), new Circle( 10, 10, 3 ) ]; shapes[ 0 ].move( 2, 2 ); drawScene( shapes ); Now let's do the same thing but without inheritance, and lets loosen things up a little and make things more flexible too, and make it what I see as more 'JavaScripty': /** * x Number x-coordinate * y Number y-coordinate */ var Vector2 = function( params ) { this.x = params.x || 0; // I know! Just to keep the example clear, I do do this differently. this.y = params.y || 0; }; /** * x Number How much to modify the x-coordinate * y Number How much to modify the y-coordinate */ Vector2.prototype.modify = function( params ) { this.x += params.x || 0; this.y += params.y || 0; }; /** * location Vector2 The location of the circle. * radius Number The radius of the circle. */ var Circle = function( params ) { this.location = params.location || new Vector2( params ); this.radius = params.radius || 1; }; Circle.prototype.render = function( params ) { console.log( "Rendering circle: " + this.location.x + "," + this.location.y ); }; var drawScene = function( shapes ) { var context = null; if( shapes &amp;&amp; shapes.length &amp;&amp; shapes.length &gt; 0 ) { for( var i = 0 ; i &lt; shapes.length ; i++ ) { if( shapes[ i ].render ) { shapes[ i ].render({ context: context }); } } } }; var shapes = [ new Circle({ x: 0, y: 0, radius: 5 }), new Circle({ x: 10, y: 10, radius: 3 }) ]; shapes[ 0 ].location.modify({ x: 2, y: 2 }); drawScene( shapes ); So, to highlight the differences: * We're not defining a parent Shape class. Instead we're encapsulating what's common into a separate class (Vector2) and creating an instance of this as a property of our various shape classes. So we're twisting this from being a specialization into a composite. * Note that although I'm using a Vector2 class here, I actually wouldn't if I didn't need any methods for it. Wherever possible I use primitive data structures, e.g. [], or {} where no methods are involved. There is no need to create a class for just data structures, as we do no type checking. * While you'd probably have the Vector2 class in the first example anyway, I'm just using it to illustrate the point of pulling out data and logic into separate classes and linking them as properties. A useful side effect of this is that you get a lot of great little classes you or users of your code can use elsewhere. * The constructors for each type of shape will have common code that's not shared (the vector line in this example). This is rarely a problem, and it's a judgement call each time to determine if it is an issue. Those rare cases where it is an issue are those occasions where I do use inheritance. * I've renamed the move method to modify, so it makes more sense when being called. We're now not moving a shape, we're modifying its location. The call to this has be changed as well, which is slightly more verbose - but in large complex classes actually helps group methods together. * The class constructors now accept a single object which is used to set the properties of the object being constructed. This allows us to do two things. First, any object can be passed as the parameter - we don't care where it comes from, what other properties it has, what class it is - if it has the properties we're looking for, we'll use them. Second, we can pass these properties on as-is, which we do when instantiating the Vector2 class. Together these allow our code to be more reusable and flexible. * As we're now accepting that single params object, the shape definitions have changed - effectively using named arguments, which I personally prefer to normal arguments. They're a little more verbose, but make the code so much easier to understand without having to constantly delve into every function definition/the documentation. * You'll also notice that we've been forced to document the constructors and methods as the parameters are no longer defined in code. Of course we'd do this anyway, but now we have to and so I added them only in the second example to illustrate that (not to make the first example look bad!). I once read somewhere that an Interface is just a form of documentation, and it's true to an extent. * Our drawScene function has been subtly modified to no longer do type checking, and instead checks for a render function and calls that. It doesn't matter what class the object is, if it has what we want to use we'll use it. The call now accepts an object, so has been modified accordingly - again for the same reasons as above. Now, obviously you could use a library to 'simplify' the first example a little, but I'd always prefer a vanilla solution if it's not terribly different just for ease of understanding by other developers. You'd probably create the Vector2 class right from the start too, but then you'd also probably create a Shapes class that extends Array and test for that at the top of your drawScene function. So overall I think the second example is simpler and cleaner - though I appreciate it's a matter of taste. The second example is undoubtedly more flexible though. We're not imposing any restrictions on what objects we get passed in, we check if passed objects have what we need and use it if they do. One of my pet peeves with object oriented programming, which is in fairness much more prevalent in strongly typed languages, is people presuming to tell me how I should use their code - assuming that they alone have thought of all possible uses cases for all time. The days of my life I've wasted re-implementing locked down code.. grr. One of JavaScript's great strengths is the ability for you to be able to reuse and adapt existing code. Want to modify an objects methods? Want to add new properties/methods? Want to copy a method into your own class? You can do all of these things. Should you? Well, that's on a case-by-case basis - however I do believe that I should allow you the programmer using my code to make that call, not me. And so how I code in JavaScript (or any language actually, I never make anything final and very rarely private) is just an extension of that thought process really. I was a C++ programmer before I was a JavaScript programmer, and as I said previously I was a big proponent of strict class-based OO and strongly typed languages (don't get me wrong, they have their place - there are projects I wouldn't touch with JavaScript!). But trying to force JavaScript to be like that is fine if that's what you want to do, JavaScript is flexible enough to allow you, but it's missing the point somewhat. The beauty of JavaScript is in some ways how many traditional rules it allows you to break, and how you can use those to your advantage. However, as with all things, it's about how you do it.. it's easy to write crappy code using any approach.
&gt; be sure that each and every function is called with the right kind and the right amount of arguments. Or you could test your code and then making sure that function A calls it the same as function B wouldn't matter -- as long as all your tests pass and you've got decent coverage. If the app works correctly (as defined by the tests) and some code does things slightly different than some other code, no one cares. 
Is there a reason you need to write this yourself? It seems like Google's protobuf's solves similar problems and already has lots of library support, well tested, etc. https://developers.google.com/protocol-buffers/
a renaissance in functional programming too. 
Agreed, and there's also msgpack.
Got a laugh out of me for sure, btw good taste in music. 
Probably not, just from a cursory glance I saw protobufjs on the npm which looks exactly like what im doing, but better. Thanks.
"Without types, you need tests which exercise all those lines." The point of this whole branch is that you have to write tests to get this kind of benefit. With type annotations, you get it for free. Also, let's be realistic here, the vast majority of code out there is not covered by tests. "Decent" coverage won't cut it, by the way. You'd need 100%.
Maybe not where you work. Where I work if there is logic that isn't tested in a commit your pull request will be denied before an actual code review even happens. If people are tripping over bugs in __production__ where logic wasn't covered by tests (also your example of a function call doesn't really fit with unit testing, the function being called is what should be tested autonomously) is a major failure of your management and it should be fixed immediately. Obviously, a human can miss edge cases and bugs do get introduced to production, but if the question of "what do the tests say" can't even be immediately answered about any bit of logic running in production, you need to start having a serious conversation with your managers and leading the charge on your team. Since you stated this, I imagine you'd all already be aware of the outcome of a cost/benefit analysis on doing so and the value gained. 
&gt;your code will be tested to about 80% coverage Empirically, this assumption is completely false. You haven't actually tried Dart or TypeScript, did you? If you add type annotations to a function, your IDE becomes much smarter immediately. Secondly, the minimum amount of documentation is also already done. Super annoying: /** * Whatever. * @param {Number} x * @param {Number} y * @returns {Boolean} */ function foo (x, y) { ... } No big deal (+ immediate benefits!): /// Whatever. bool foo (int x, int y) { ... }
&gt; also your example of a function call doesn't really fit with unit testing, the function being called is what should be tested autonomously Imagine you call function "foo" from library "bar". You pass it two arguments of the type Number and you expect that the returned value is an object which has "baz" property. You now need a test which exercises every line where the function is invoked and also every line where the "baz" property is accessed. This is what you need if you want the kind of safety net you get with type annotations. The vast majority of code out there is not covered by tests.
&gt; Empirically, this assumption is completely false. Empirically, your statement is completely unfounded bullshit. But whatevs. 
Damn. Legit.
I'm currently working with Sencha Touch on a commercial project along with some of the folks who actually helped create the framework. The devs who developed the product (at least the ones I've talked to) are extremely bright, and when you think about it, it's kind of impressive what all you can create with it. With that said, I hate how it puts you into DOM hell with billions of unnecessary nested divs. I also hate the templating structure within the js files, it's super ugly and hard to maintain. We are looking into AngularJS and the Ionic phone framework, however it's still in beta so it will be impossible to convince stakeholders to use it on an enterprise level application anytime soon.
I use Backbone so tend to use its wrapper around underscore's extend() in most cases. However, I've got a growing need for mixins and am looking at giving [this Backbone mixin manager called Cocktail](https://github.com/onsi/cocktail) a spin.
I use [inherits](https://www.npmjs.org/package/inherits), which is just copied from node's util.inherits and has fallbacks for old browsers. I use inheritance sparingly, and only with primitives that the platform provides; that pretty much just means EventEmitter or one of the kinds of streams that node core exports. The rest of the time, these approaches work much better: * instances as member properties - obj.foo instead of inheriting all the properties of Foo onto obj * use function arguments to supply custom hooks - you can pass in custom functionality to other functions by supplying a custom behavior as a function in an argument - foo(f) instead of implementing f as a subclassed method
I'm fairly new to JavaScript. By that I mean two weeks in. But I have an understanding of other languages and some of the DOM. What I can gather from a quick once over is it's just subbing you to spam accounts to gain followers. Nothing /that/ malicious. How they could have potentially gotten access to the other account, I'm not sure. Maybe someone a little more experienced with cracking/exploits and JS could help there.
I de-obfuscated the second bit, http://pastebin.com/waHDZppQ ... the first bit with all the escaped characters just contains an unused function called Report (??) -- after that though it gets interesting. It looks like this code tries to iterate over all your friends and posts a comment with all of them tagged to a particular comment, somewhere on facebook... I don't know enough about facebook's inner workings to figure out where this post is, there is a magic 'id' number though, 1390334794524626 that seems to point at the id of the post.
Just a friendly reminder -- never execute arbitrary code from untrusted sources, in any context.
Your wifes attempt at being a l33t hacher backfired. i see nothing wrong with this. 
The code isn't actually stealing any passwords, it's simply simulating tagging/commenting/liking the original post (it seems). Looks like you were lucky. If she doesn't run the code again/run some other code, no more damage can be done. It looks more like a proof-of-concept than anyone trying to take over accounts.
Haha, by "my wife" do you mean yourself trying to be a l33t haxx0r? Reminds me of the script kiddie hacks back in the day. Pasting JS in the URL bar to move things around on the Google homepage and stuff. Half of them ended with some obfuscated JS that stole your cookies.
This: http://jsperf.com/eval-vs-code And this: http://jsperf.com/tag-vs-eval-fn-construction And my own test: http://jsperf.com/eval-vs-regular-code Can I ask you to post links to your tests? Thank you very much. :-)
&gt; It may be a bit difficult with a lot of files No, it's not. I have an automated Brackets plugin which merges all needed files to a single one using exactly the Browserify and the UglifyJS. And it works fast even with a huge amount of files. &gt; I think I'd be able to pack the JS to a smaller download size Really? Why? We live in the 21st century. A few more kilobytes of a JS file are not a problem anymore. ;-) Even on a mobile network. &gt; If the code is 1% slower to run Eval'd code is never only 1 % slower. See the link above. ;-) (http://www.reddit.com/r/javascript/comments/23fz16/never_use_eval_what_about_this_specific_case/cgx75wx)
Word from the wise: **Don't execute code you don't understand and trust.**
You found some strange exploid code somewhere on the nets and she was smart enough to use her *real* Fb account to try it out? 
&gt; Someone else said that evaled code runs at the same speed once it has been through eval. It is still [very, very slow](http://jsperf.com/eval-d-function-vs-regular-function). And anyway it's still not your plan. Your plan was to eval the whole code, right? &gt; I currently need statements like that to get the local variables in the right scope Yeah, that's a better solution. But I'm affraid there is not any automated solution for this. If your module exposes the whole API like this (one object - namespace), you have to manually create variables for all constructors needed. A better solution (in my opinion) is to expose all constructors as single modules so you get them immediately to variables by default. &gt; I'm using AMD modules Isn't this the problem you are focusing on? It sometimes takes more time to load all modules asynchronously so there can be delay between loading of the page and the execution of modules. It's fine for developing but for production it's good to optimize your modules using [the r.js optimizer](https://github.com/jrburke/r.js/) (which is something like Browserify but for AMD).
&gt; If you literally mean a library then no: the first thing you do after basic discovery about a potential library you may use in your code is run their test suite. Yes, with "library", I do mean "library". And no, running their test suite won't change anything. It would pass. Do you really have no idea what "breaking change" means?
Yes, my plan is to eval a large amount of code all at once. Within various modules, there would be statements like the one I gave. I'm thinking that if Control were local throughout, that's less code. That is one thing I want to achieve, but it's tangential to the question about if using eval once will have such a sever performance impact, I was saying that other parts of the build process may not be so easy if I want to use / modify them to use them to maximum effect. I started using AMD but browserify looks better in some ways. At the moment I'm not sure which way to take the code, but if possible I don't want to go changing all the code files in the framework I'm making. I'm thinking more along the lines of putting code files through a filter as part of a process of my design but using AMD or browserify. I'm not planning on delivering the code as I have described, I asked the question to generate a discussion about it. At some point I'd like to try that type of compression, or experiments using eval. I could measure how much eval slows things down separately from how long it takes to decompress the code. Thanks for the link to the r.js optimizer. I'll still need to work on a way to automatically remove local variables copied from namespace definitions. I think the jsgui namespace (or object) is too central to the project not to use it, but I'd like to find ways the references could be removed where they are not needed.
Thanks for those tests, eval looks much much slower, even when eval is run once. It's occurred to me that the benchmarks maybe are not fair though, as eval will get called and cause recompilation each time the test runs, while the JIT compiled functions may remain from the other tests. I don't know though, it's a suspicion. If those benchmark results translate to real-app very low performance, I'd also consider dynamically inserting script tags into the document.
&gt; eval will get called and cause recompilation each time the test runs That's why I wrote also [this test](http://jsperf.com/eval-d-function-vs-regular-function). And it's still slow as hell. There is only an eval'd function which remains in the memory and is called from the regular code. &gt; I'd also consider dynamically inserting script tags into the document Yeah. It's weird but I tried that and at least the Chrome shows it doesn't loose any of its performance. Maybe this is a way to go.
That test looks more similar to my use case, I don't fully understand it though. It seems that this would be calling an evaled function from non-evaled code. There may be different performance implications when doing this compared to only executing evaled code. Do you know if all the browsers would be fine with adding script into the dom, regarding security issues?
I just left a job that used Ext JS. When I started we were using version 3, and version 4 was a decent upgrade. Or as one coworker put it "I don't want to program in Ext JS at all, but if I have to I'd rather use version 4". Even if I *did* want to use it, I don't see any compelling reason to use 5. Throughout version 4 it seems like Sencha was doing everything they could to push SenchaCmd and Architect. I'm a developer, so maybe that's the problem, but I could have just done everything in my preferred text editor and been done long before all the dragging and dropping was done. I can see where Cmd is coming from, but again, I don't see why a front end widget library *needs* it. I don't get it and I'm glad I got a job where no one has ever heard of Ext JS before. 
Good ole jquery plugins, here are the js files they are using: http://i.imgur.com/AGeD5z2.png Here is a list of jquery image gallery plugins I found from a quick search, I believe there are similar ones the example you showed on here: http://tympanus.net/codrops/2009/09/07/42-jquery-image-gallery-plugins/ Hope that helps.
Just a little modification to your test: http://jsperf.com/eval-d-function-vs-regular-function/3 Other tests are re-evaling the code for every iteration, so they are obviously slower.
Thanks a lot! :)
Perhaps I have a different understanding of it than you do since that's not exactly an engineering or scientific term but in the context I've ever heard it used, our production code would never be affected by a "breaking change" in a library. You must always be in complete control of versioning for any code, yours or others, that touches production. This goes up to and includes the npm registry and similar tools which is why you've seen the discussion on how to remove dependency on npm in production post the certificate fiasco. The way our system was designed allowed us to avoid any issues when that happened because you should never allow anything into production you don't have complete control over. 
This is probably the single question most in need of a link to Gary Bernhardt's talk "The Birth and Death of JavaScript". So you should watch it. :) https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript
https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript
Nice, will try out soon. Thank you very much. :)
Well it would be nice if we could see what it actually does...
There's a demo button, but... err... [it didn't look too good](http://i.imgur.com/sBIBsyp.png)
Interesting read, following your blog now :) 
Didn't even see that button. Crappy design much?
Awesome, thanks a bunch!
@laurentszyster nice. Checkin' it out now. I was hoping to see more of these, posts with repos that may be at use in 'the wild'. 
The fact that it does work on a different page suggests to me that it's not an issue with your code but the page layout. I looked at the issue and the user is not very specific with what way it is 'not working'. The most important thing here is to determine what version of ios he is running. Unfortunately, chrome devtools emulation will not help here. I'd keep trying forums like this to see if someone with access to a mac (unfortunately, I don't at the moment and won't until tomorrow) that can run the emulator or remote degub and can at least get some error info for you. Ultimately, in my experience there are all sorts of weird things that can go on between supporting even ios6 and ios7 (like old/new flexbox spec...ugh). actually this is sort of interesting (but probably not going to help you): as a last resort with no mac I tried http://www.ipadpeek.com/ and it basically does what that user is describing. However, there is an issue with frame access in the console so it's probably unrelated. Sort of just throwing it out there as a hail mary.
&gt;You must always be in complete control of versioning for any code, yours or others [...] Sure, you're using specific versions of libraries. However, that doesn't meant that you'll never ever update any of them. E.g. the new version fixes some particular bug which you really need to be fixed, it solves some compatibility issue with IE12, it has some new feature you really need, or whatever. jQuery, for example, had many breaking changes during its lifetime. Features got removed, val/attr, '[foo=bar]' vs '[foo="bar"]', and so forth. Types and tooling can catch quite a lot of those issues.
&gt;I guess I'm not understanding what you are suggesting. "Types and tooling can catch quite a lot of those issues." That's the only thing we are talking about here. Watch: http://www.infoq.com/presentations/data-types-issues Slide 3: &gt; Static: Points in Favor &gt; * More efficient &gt; * Better tooling &gt; * Fewer tests needed &gt; * Better documentation &gt; * Safety net for maintenance
Thanks for the tips/feedback. I'm hoping I can get some more info about what iOS version he's running (and whatever else I can find)-- and I'm kind of hoping to get it before my free days are up again. As things are now however, I feel like I have no way of advancing aside from just asking others :s
@WrasslorMonkey while, as stated, I have no interest in discussing the merits of jQuery here you bring up one very good and important point. The issue of working in a front-end codebase minus jQuery. What impact does this have on a developers day-to-day workflow and their career for that matter. It is common for devs to bounce around here in Silicon Valley - what does it mean to have a 'stack' that is not the same as the next startup? We weighed this carefully, deciding that it is not a detriment to our LinkedIn profiles to become more proficient with emerging standards. That it was actually a good indicator of culture-fit. We have a specific view, recruiting others who share it. Your statement that you would be 'bummed' to inherit it is completely valid and reasonable. It would also be the point in an *initial* phone-screen with any potential front-end engineer that we not continue forward. 
But types have nothing to do with the example of a library like jquery breaking production code when you change to a new version. Types wouldn't affect that at all. Types are more likely to save you during development in terms of efficiency or making errors but I also think that the developers experience is pretty relevant in that context as well. And of course the final main point: you are the only person I've ever heard advocate fewer tests based on the type system of a language. 
Yeah unfortunately it's pretty difficult to debug these sorts of issues without the device at hand. If you are really in a bind you could sign up for a free trial at browserstack (which I'd also recommend as worth paying for) to get access to a real emulator for different IDevices. Actually, now that I'm thinking of that, it may be your best option. You should give it a shot. 
May I have the permission to laugh? lol 
As a front-end developer always looking to improve performance, but don't know anything about performance, this was an enlightening read. Thanks!
Yes I know them, but it was not really useful for fattable. Just out of curiosity, I tried the display:none trick, as well as document fragment. They had no impact impact in my case. In my case, I am just moving divs around. I don't even put them out of the DOM. Reflow is triggered only once as well as I don't access any layout properties.
Nice! I'll try to keep writing in this blog then. :)
A stupid marketing post.
For anyone to answer your question, he/she would have to solve the exercise for you. Also, your teacher gave you all the hints you need.. Just google "javascript loop" and start working on it. If you don't understand what a loop is or how javascript works, then google for a javascript short tutorial and start working from there on. if you never made a javascript program, then you won't be elightened here on reddit anyway, only way to learn it is to get your hands dirty. I repeat, if you know absolutely nothing about js, then google for a short tutorial and work from there on. Any tutorial should give you the basics you need to solve that problem (which is quite simple). Anyway, pseudo-code: **solution 1:** Loop through all the 100 doors, Loop through all the 100 people, if person number divides evenly by door number door changes state. Print door state after the 100th person passed the door **solution 2:** loop through all the 100 persons loop through all the 100 doors if person number divides evenly by door number door changes state. after the 2 loops, loop through the array(matrix and array "are the same thing") and print each door's state. Now go and google how to code each sentence in javascript
You may want to cross-post this to /r/learnprogramming. Some hints of my own: The "hallway", "doors", and "sweatshirts" stuff is just bullshit, they're only there to add colour to the problem. * You have a hundred of "something" that changes state between open and closed. What **two numbers** would you use to represent "open" and "closed" state? What about if you couldn't use numbers? * There are a hundred doors, and a hundred people, essentially, you need to have everybody walk by every door. The order of the people doesn't really matter (just the order of the doors). * Break it down to the smallest action that needs to be done: I gave you a person, and a door. What happens? * The "webpage" is just bullshit too. Don't worry about that until you have the logic down. Lastly, your teacher loses a couple points, as any *properly* designed hallway starts with a door labelled "0". /s
I'm not an expert on angular but it definitely seems like trapping up changes and encrypting them before hitting the local dB and wanting to deep change tracking, not just storing the most recent value given to the underlying model was quite complex with simple backbone views and models let alone something like angular or knockout. The performance issue there comes in because to give the perception that things are happening in the "background" would mean I needed total control of when literally everything was out on to the event queue and to schedule it manually in essence. Industry is moving heavily towards html5 for mobile internal apps. I don't think it's am edge case at all. 
If you are five I need to assume you are not a programmer. Javascript is what we call a dynamic language. Dynamic language tend to be putting less constraint on the way they are coded... Let's give you an example. In javascript there is no such thing as an integer. 1.0 and 1 are really the same thing for the language. For your CPU however these are two whole different beasts. Operations on integer go through different pipes as decimals ; and are typically faster than operations on a decimal. Because of this, javascript started up as a very slow programming language. As it is unarguably the language of the web, a lot of company threw a lot of money into making it faster. The piece of software responsible for running javascript is called a Javascript engine. Modern javascript engine like V8 are smart enough to try and detect patterns in your code, and run at full speed using the correct pipe of your CPU. Even then, JavaScript is still way slower for some very specific use. From 3 times slower to 10 times slower. For mobile, performance loss can also mean battery mileage. The most pathological application for Javascript today are cryptography, video games, scientific computing, image processing. Since way before, many companies thought that there was room for another language in the browser... A less dynamic language that would bring better performance. People used to run java applets on the web. Then there was flash application. As you are 5 you probably never heard of those because nobody use them anymore. Today, Google is working on their own solution called NaCl but it is bound to fail as well. You know why? Because all of these guy just pushed their technology, hoping everybody would be nice enough to support from Day 0 and use it. With asm.js things are different. asm.js lets people write code in a language designed for performance, and transform it into a compatible dialect of javascript called asm.js. Browser compatible with this technology (today only firefox) will see your little wink as you hand them your code. They will interpret your JS not as simple JS code, but as your originally faster code. In browser not handling asm.js, the code will just run as regular JS code. Because of that it is very likely to gain a much faster adoption, both in the developer community, but also in the browsers to avoid losing market share. Because you see, if app A runs on browser U and not on browser V, Browser V users are likely to just avoid using app A in the first place and call app A names. On the other hand, if app B runs on both browser U and V, but is much faster on browser U, browser V users are more likely to call browser V names and switch to browser U. Now what will be the main usage of asm.js? There exists a lot of code that took years to develop. Nobody wants to rewrite a cryptographic library for instance. It will now be possible to do heavy crypto in the browser, when it was just impossible before. That will be probably the first wave of usage of asmjs ; and will probably unlock new web application, web usage and businesses. I think it will be followed by a second wave a bit more difficult to understand. Javascript is not exactly the best language to write big pieces of code. In that second wave, people will start to use asm.js in order to use alternative languages, more adapted to big/complex applications. Today such approach exist (most notably GWT) but typically come at a performance cost. With asm.js such approach should result in overall faster application.
Thanks for posting that article, I had a quick go on it and got good performance. I did notice that after scrolling to the right, the scrollbar was not fully on the right of the document and the column titles were offset a bit to the right. I refreshed and it was OK. Anyway, I have a question about a different method I had been considering in order to implement a table/Data_Grid like this. I've been thinking about making one using a fake scrollbar, so the user is not actually scrolling through a large object in the DOM. Then when they choose a position, the system updates a number of lines (such as 60) that are displayed on the screen. This would circumvent problems to do with garbage collection as there would not be lots of nodes created and removed as the scrolling occurs. I've just considered having a real scrollbar for an empty, tall div. Superimposed on top of that would be a div that displays 60 or so lines of data, and the content of these lines would be changed according to what's calculated to be the table items being looked at. Can you see any advantages / disadvantages between the ways I've described and how you have done this? Are there ways (which you are willing to reveal) in which you'd do it differently if making it again? 
In C#, but can easily be converted to JavaScript and Lodash. var range = Enumerable.Range(1, 100).ToList(); var openDoors = range.Where(door =&gt; range.Select(student =&gt; student%door == 0).Last()).ToList(); openDoors.ForEach(door =&gt; Console.WriteLine("Door {0} is Open.", door)); Console.ReadLine();
I don't want to give you the answer, but here's a quick hint. You're not working with "doors"; you're working with a list of boolean values. Perhaps "closed" is `false`, and "open" is `true`. You can change the state of a boolean with the `!` operator: var door = false; door = !door; console.log(door); // true Also, you can check if a number evenly divides into another with the [remainder operator (%)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#.25_.28Modulus.29).
When I was looking into implementing two factor auth a lot of tutorials/examples would use the google api for generating the QR codes which is **terrible**. By doing so you put the code our over http and you're also exposing the code to google (an unreleated 3rd party). Please, use a local JS library or your own server side code for generating QR codes if you are encoding sensitive values. A quick search shows three great options: * http://davidshimjs.github.io/qrcodejs/ * http://jeromeetienne.github.io/jquery-qrcode/ * http://larsjung.de/qrcode/ Otherwise, nice demo.
I would have made the regex start with \^, so it won't fuck up other numbers between parentheses. 
"Javascript is the Assembly Language for the web" Sorry, you lost me there. That minified code was compiled, and has many layers to go through (browser/os) before it becomes machine code. Assembler is basically 1-1 mnemonics with cpu instructions, the only comparison is that it is one less level than a higher language, and it is hard to get much lower than assembler. Sometimes an extra layer is only a temporary fix, the GWT crowd has been dying off since they realized they still needed to know what was going on underneath to do things the toolkit wouldn't allow. I still use assembler in embedded projects, but mostly it is relegated to timing critical blocks of code called from C/C++. In some ways assembler is easier, because it is fairly stable. But you don't usually write GUIs in it, better tools for that. (I have written GUIs in it due to space constraints) While the sentence you post could be appealing to some who want to believe it, it is really and wholly inaccurate. 
Also it disregards other options, such as plugins, or custom browsers, or local proxies (where assembly language is a real possibility). I have on occasion needed good performance over lots of data and set up a "local" web server (really just a server socket) and connected the web browser to it, where it could interact nicely with the file system and churn lots of data, without retooling the user interface language. When your only other option is to upload gigabytes to a server where it can complete processing in a reasonable amount of time, using lower level local distributed processing is a viable option.
I was able to get my hands on a 3GS running ios 6 (my mother was over for dinner and is still rocking the 3gs). It displays exactly as in your screenshot. I recall there were some canvas related bugs in ios 6 that never got resolved. IIRC this was especially true with canvas resizing but there was a library with a workaround. I know we at least have some ipads still running ios 6 and I think a 4S as well. Ill try to take a look tomorrow at work where I can actually debug the thing. In the meantime, x-posting to /r/jquery or /r/frontend may get you some help as well. 
Something like....? notifier.format = "$n notifications - $t"; ... patt = new Regexp(this.format.replace("$n", "\\d+").replace("$t", ""));
&gt; to dinamically show Sorry ... I can't believe this is worth bothering with if you can't even spellcheck your main page.
That sentence is not meant to be literal. It's akin to saying that JavaScript is the building block of front-end programming. 
I thought that at first, but I noticed the library doesn't store the original title (allowing non-notification title changes) so a simple text replace won't work. I guess it's anyone's decision which feature is more important.
You are on a slow connection ?
Laugh if you know the reason
there's a set() function to set to a specific number. It needs to be documented yet.
lulz
That sentence is so wrong it gave me cancer, are you coding or writing a poetry book?
I enjoyed the irony: http://m.imgur.com/6M8UXU7 - will check back later. 
Ended up on his beginner tutorial, thanks 
http://mrale.ph/blog/2013/03/28/why-asmjs-bothers-me.html
I love this talk. This is the same guy who did the famous 'wat' presentation too
As explained in the blog post, the sentence is not from me. I however consider it very true. Apart from that, you are taking things way too literally. I was not expecting anyone to think javascript shared all the trait of assembly... As an exercice I invite you to read the following sentence out loud, think that they are probably not to be taken literally and avoid ranting about them. "Religion is opium of the masses." "Premature optimization is the root of all evil" "Measuring programming progress by lines of code is like measuring aircraft building progress by weight." 
That is correct, thanks for pointing it out. I mostly use QR codes for making posters, which doesn't contain personal information, but you are obviously right. One shouldn't pass personal user information to Google.
At least remove: im-db .info { width: -moz-min-content; }
http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx
Thanks for the post! I really enjoyed your other post on splitting up gulp tasks as well. Since you asked for alternate ways of achieving the same thing, I'll share what I've been doing. I've been using a non-browserify-shim way of solving this. I make a separate bundle of all my dependencies instead. I have one file, `externals`, that looks like this: module.exports = angular: -&gt; require 'angular' ngRoute: -&gt; require 'angular-route' select: -&gt; require 'tether' # dep handling, these libraries aren't in commonjs require 'select/js/select.js' pace: -&gt; require 'pace' tether: -&gt; require 'tether' lodash: -&gt; require 'lodash' moment: -&gt; require 'moment' The dependencies are all from bower, using the `debowerify` transform. This externals bundle is then included as an `external` file for my main app. If I want lodash, I use `_ = (require 'externals').lodash()`. I want to make a macro for this eventually maybe. Building this external file, which only happens rarely ie. when I add a new dep or mess around with the externals file, takes a few seconds, which would be annoying if you're working with live reload. But the actual app only takes around 100ms each build because it just includes the `externals` bundle. Which is why browserify-shim is awesome. This is a lower-tech way of solving the same problem I guess. The upside is that I don't have to use with browserify-shim and add new dependencies in `package.json`, and `gulpfile`, and possibly having to override the default bower main file by editing `bower.json`. Basically, we can `bower install -save blah` and add `blah` to the `externals.coffee` file as in the example above. The downside is that the it's a bit more verbose and overly explicit. Overall it just looks bad imho. If anybody has any suggestions in easing this, let me know. For production, I've just been uglifying all the dependencies. So far it works, but it would probably be better to just define a second file that includes the original distributed minified files. Example (just a guess on the file names): module.exports = angular: -&gt; require 'angular/angular.min.js' ngRoute: -&gt; require 'angular-route/angular-route.min.js' select: -&gt; require 'tether/tether.min.js' require 'select/js/select.min.js' 
The img will never loaded. Amazon does not allow image linking from your website.
Hey, there, nope. I tried multiple times throughout the day. 
http://h3manth.com/demo/custom-elements/im-db/
Duh! Referral Denial! http://h3manth.com/demo/custom-elements/im-db/
http://h3manth.com/demo/custom-elements/im-db/
Referral Denial duh! http://h3manth.com/demo/custom-elements/im-db/ must be fine.
Some vote ups at least now :)?
Some vote ups at least now :)?
Some vote ups at least now :)?
Now this is fine http://i.imgur.com/LnAPqZs.png compare to previous http://i.imgur.com/sBIBsyp.png
There is no operator overloading in JS. You'll have to make do with 'add', 'sub', etc. functions.
:+1:
you need to mimic the actual implementation of the plus in JS, but have it take 2 objects instead of 2 integers
I have not been able to reproduce the bug, but did find that column rows changed size upon refresh. I'm using Chrome 34 with Windows 8. In summary, the method I was talking about is to keep the skeletal structure of the table still rendered, a table with maybe 60 lines, and change the contents of their td elements.
I've now done a little bit more, I added this to my index.js: window.onerror = function (msg, url, line) { $.post("error.php", {message: msg, url: url, line: line}); $("&lt;div class='error'&gt;") .append($('&lt;span class="error-message"&gt;').text(msg)) .append($('&lt;span class="error-url"&gt;').text(url)) .append($('&lt;span class="error-line"&gt;').text(line)) .appendTo($("#Errors").slideDown()); }; And created a very basic error.php: $mysqli = new mysqli("localhost", "username", "password", "database"); if (!$mysqli-&gt;connect_error) { $mysqli-&gt;query("INSERT INTO `Errors` ( `message` , `url` , `ip`, `useragent` , `line` ) VALUES (" . "'" . $mysqli-&gt;real_escape_string($_POST["message"]) . "', " . "'" . $mysqli-&gt;real_escape_string($_POST["url"]) . "' , " . "'" . $mysqli-&gt;real_escape_string($_SERVER["REMOTE_ADDR"]) . "' , " . "'" . $mysqli-&gt;real_escape_string($_SERVER["HTTP_USER_AGENT"]) . "' , " . "'" . $mysqli-&gt;real_escape_string($_POST["line"]) . "' )"); } return; The biggest downside is of course that I still can't reproduce the error myself, but at least when it happens now I should get some data about what caused it to happen. Unfortunately, this does not give me a stacktrace, so if the error happens somewhere deep inside jQuery's own code I'm still kind of screwed. *If* that is what's happening right now (which I don't think it is) I have an idea on getting myself a stackstrace of sorts by creating a "debug.html" page which modifies the Javascript `Function.prototype`, though obviously I'd rather not do that on the regular/public version. As for canvas errors/bugs: I'm not re-sizing it, and if that were the case- the old version should also not be working. I suspect it's something to do with either `requestAnimationFrame` or `window.top`, two things that were added more recently. However, frankly those two are very much guesses, and some google searches has not turned up any supposed problems that I should be aware of. So, for now I'm just going to wait until I get an error.
Barely any of this post is about Javascript, and almost all of it is focused on DOM or browser APIs. This should have been titled "from jQuery to native browser APIs".
Often people complain about JavaScript when their real problem is with the icky DOM api.
Thanks, this looks interesting. The main thing I worry about this is that it ties your `require` statements to your application, and your code becomes harder to pull out into its own modules. Let's say you have some reusable code in your app that is a good candidate for its own NPM module. To pull it out, you need to go through and fix up all its `require` statements to have it work outside of your application. You also might run into duplication in your final app bundle; since now your app is requiring the 'external' lodash, and your small NPM module is requiring the regular lodash. &gt; I really enjoyed your other post on splitting up gulp tasks as well I think you're talking about [Dan Tello's](http://viget.com/extend/gulp-browserify-starter-faq) article. A great read though!
Thanks for trying anyway. The columns width is randomize (with no seed) in the demo, so you should expect to get different column sizes. The technique you are describing should perform just fine and is easy to code. For many use cases I would actually recommend it. (right after recommending using fattable directly obviously :D ) I considered doing that as well, but the other devs thought the user experience would be somewhat less good as the scrolling would not be continuous and therefore less tangible. Also, if this technique helps solving vertical scrolling, but does not solve horizontal scrolling with variable column width.
+1 for datatables
At the moment I'm using Closure Library which uses classical style inheritance. At the last job though I used Backbone and "functional mixins" using [Backbone.Advice](https://github.com/rhysbrettbowen/Backbone.Advice) and [Backbone.AdviceFactory](https://github.com/rhysbrettbowen/Backbone.AdviceFactory) to ease their setup. Doing this allowed a simple way to setup mixins and compose with them. It meant I only had to test for functionality (whether a mixin had been applied) rather than the type. Also the mixins had their own inheritance structure and could compose so it made them a lot more expressive. The other thing I usually like to keep things like data and functions separate (so rendering on a view and things like setting and computing properties on the model). This means you can take a more "functional" style and keep things simple. Basically if something has the properties you can use the function and if you structure your code right you will rarely (if ever) need to check for types. 
Yeah, I've read it, I think it's one of the best books out there and is really complete
[DynaTable](https://www.dynatable.com/) Can work purely off of data (headers included).
Very nice bro, thank you for this!!!
JQuery's `.on` has some important differences from the native `addEventListener`... Most importantly the support for delegated event listening. $(document).on('click', 'li', function() { console.log('An li got clicked!'); console.log('Even if it was added after this handler was attached!'); }); Versus document.getElementsByTagName('LI').forEach(function(li) { li.addEventListener('click', function() { console.log('An li got clicked!'); console.log('But only if it was already on the page...'); }); }); document.addEventListener('click', function(evt) { var target = evt.target; while (target) { if (target.tagName === 'LI') { console.log('An li got clicked!'); console.log('This was harder :('); } target = target.parentElement; } }); **Edit**: Fixed
Invite for too much tech
This is definitely worth noting, didn't even think about that. I'll try and update the post tommorow when I have some time. :)
Name the com function something different. The second time through, com resolves to the value you set before, not the function. 
It's not inaccurate, it's a comparison made for a very particular point and that point was _not_ that it's one to one to machine code. 
Dat header on mobile doe
A lot of people seem to miss another reason why one might use jquery: it's a dependency for countless plugins. Bootstrap, backbone, etc. in addition to its dom API wrapper and browser support, it provides a very popular plugin architecture, particularly through its $.data() method. 
Backbone isn't dependent on jQuery. Edit: not sure why I got downvoted. RTFM.
Maybe need to work on its size ;-)
&gt; His ajax example thankfully works in IE7+ (hardly anyone needs to support that). No it doesn't because he's using the [XHR2 API](http://caniuse.com/xhr2) (cf. "load" event handler). However I agree with your point.
Quick note, your CSS is missing the "orange italic" class. 
Good call, thanks! Edit: Fixed it.
 &gt;Backbone's only hard dependency is Underscore.js ( &gt;= 1.4.3). For RESTful persistence, history support viaBackbone.Router and DOM manipulation withBackbone.View, include json2.js, and either jQuery ( &gt;= 1.7.0) or Zepto. 
Instead of overlaying `img` on `canvas` and passing events through manually (or using `pointer-events`), why not keep the canvas hidden, or off the DOM, and 'flip' it to the `img` after drawing? Apply your events to the `img` and use the `canvas` for behind the scenes drawing?
The only "icky" thing about it is the inconsistency between browsers. The DOM itself is a good thing, the fact that there are varying implementations of it is not so great. 
This article is about processing files in a browser. It explains how you can read and change files data, drag-and-drop files to/from browser, parse excel and pdf on the client side without server. It also includes caching media data and playing them offline. 
You got downvoted because what you said isn't correct. 
[Webix Datatable](http://webix.com/snippet/aa531e62) can be built from json data ( or json url )
Yours looks absolutely cool. I too have [dabbled](http://zxc.fi/) a bit with soundcloud api and html5 canvas in the past few weeks, mostly just to get some new background music for my coding sessions.
Actually, what I said is 100% correct. &gt;Backbone's only hard dependency is Underscore.js Anything else can be a custom shim, if you don't want to use jQuery. Backbone will use "$" if it's available, but it's not required. You can also use Zepto, so jQuery is absolutely not required.
I love how posts like this completely forget that there is more then one browser out there. Yes, i get that $("selector") can be replaced by native browser calls, but the results are not guaranteed to be consistent. That is worth the 10kb download. 
[datapipes](http://datapipes.okfnlabs.org/)
Your right about that, with this I'm basically committing to bower. I didn't like the fact that half my dependencies were in npm and half were on bower, so since everything is on bower anyways I just took all of them from bower. If I extracted things out, I would probably also put it in bower. However, even if I put it in npm, as long as the new extracted module is part of the external bundle, there won't be duplication. Do you have any ideas on how to reduce the excessive syntax? I might end up using a macro maybe :)
And sorry for mixing you up with Dan :) I read it through your link so I assumed. It was 3am!
very beautiful. 
I'm not even going to argue with you, /u/F0RTY4 already said it better than I could: http://www.reddit.com/r/javascript/comments/23l452/back_to_basics_from_jquery_to_javascript/cgy64h8
jQuery is just a wrapper around a few browser APIs. What did you expect? A tutorial in functional programming to get an element's CSS classes?
Ok you obviously don't know how to infer then, because his answer supports my claim. 
&gt; function hasClass(oElement, sClass) { return new RegExp(' ' + sClass + ' ').test(' ' + oElement.className + ' '); } Why not use the native classList API, e.g. function hasClass(oElement, sClass) { return oElement.classList.contains(sClass); } ?
Because it's IE10+.
Its a post written by a novice who still has to understand a lot about javascript. Keep on learning and one day you will understand the awesomeness of this language. Dont take it negatively.
Please don't use $.data for anything if you can help it. It doesn't scale. In general, don't keep app state in the DOM. jQuery doesn't do you any favors by giving you $.data.
Its awesome. It creates a number of shapes by tuning the parameters. I liked the one with parameters slowdown:3 shape:9 and space between:39
Could you provide a solution to preserving a plugin state? Say, a typeahead? 
I assume you were intentionally referring to this: http://31.media.tumblr.com/981b9455b35ca551cbfd2227110b9da2/tumblr_mhgcs6PtMw1qgbu2uo1_1280.png Also, sweet job! That's fun to watch.
You want me to write a plugin or tell you to store state in a variable?
That's what the jQuery example and the second vanilla JS example do.
So your solution is to put it into a variable. Cool. The reason $.data() is convenient, is that often you will need to access that plugin's state and methods from plugins that are instantiated to the DOM, or outside of your app. For isntance, tracking utilities such as Kissmetrics. Unless you want to start persisting that plugin on the global object (which you don't), putting it in the DOM is not such a bad idea. I'm not trying to start some weird flame war with you, I just wanted more information other than "it doesn't scale". Come on. 
That is correct and thank you :) 
the whole idea that jquery is too big for even a small site is basically a none issue. Just use a CDN version and odds are the client already has a cache of it.
You could do return oElement.classList ? oElement.classList.contains(sClass) : new RegExp(' ' + sClass + ' ').test(' ' + oElement.className + ' '); To get a small speed increase on modern browsers, then again, considering that we're optimizing for websites with small amounts of DOM manipulation, the extra file size might actually slow down the website more than you gain from using classList. Either way, it's not that important. 
Is the functionality in your example equivalent? What about a nested LI? Wouldn't it return after hitting the first one, and then the event wouldn't be triggered for the parent as well?
I couldn't be arsed to check what jQuery's behavior is with nested matches when doing delegated event listeners. If they differ, they can be made the same by adding an `event.stopPropagation()` in one or removing `return;` from the other. More interesting is that jQuery's implementation allows selectors of arbitrary complexity. So it might be more like... var query = 'div#content &gt; li[data-selected=selected]'; document.addEventListener('click', function(evt) { var matches = this.querySelectorAll(query), target = evt.target; while (target) { if (Array.prototype.indexOf.call(matches, target) !== -1) { console.log('element matching selector got clicked!'); console.log('dunno how jquery implements this'); console.log('this implementation would be buggy and slow as balls'); } target = target.parentElement; } }); **Edit**: I could have just been arsed to check the docs I suppose: &gt;jQuery bubbles the event from the event target up to the element where the handler is attached (i.e., innermost to outermost element) and runs the handler for any elements along that path matching the selector. **Edit2**: The relatively-unsupported standard [`Element.matches`](https://developer.mozilla.org/en-US/docs/Web/API/Element.matches) solves it better: var query = 'div#content &gt; li[data-selected=selected]'; document.addEventListener('click', function(evt) { var target = evt.target; while (target) { if (target.matches(query)) { console.log('in real use this needs to be prefixed'); console.log('jQuery is still more elegant'); } target = target.parentElement; } });
$100m revenue, NI, cost to build, cost to maintain, valuation at sale, etc?
I love stuff like this, evoking natural patterns in a surprisingly simple way.
It doesn't add much to the discussion, but that was cost to build.
True but people who want to read this kind of stuff aren't gonna google with words like "browser API", they'll probably use words like "vanilla JavaScript" or "pure JavaScript".
And one of the main reasons jQuery exists....
$ as used in jQuery does much more than just querySelectorAll.
Source? I made this. 
jresig posted a long time about about compressing text for a mobile game. I think it's still relevant for finding the balance between speed and file size. http://ejohn.org/blog/javascript-trie-performance-analysis/
I like your post a lot, but also wonder if jQuery fits your "narrow idea about scope and purpose"? 
DeckSteve.reduce() is a function, yes? Therefore, it should have a method apply. I wanted to use apply to reference DeckJosh in the body of DeckSteve.reduce().
Pretty cool. Protip: don't try to add 30000 circles
The *result* of calling `.reduce` is not a function--it's a value. That's what you're attempting to call `.apply` on. EDIT: Additionally, you're calling `&lt;variable&gt;.reduce(...).apply(...)`, which is just equivalent to *calling `.reduce` on the thing you're passing to `.apply`.*
&gt; DeckSteve.reduce() is a function, yes? no. DeckSteve.reduce() is a function call. DeckSteve.reduce is a function. Also, you give reduce a function that will be executed. It is this function you want to give a "this" reference to. &gt; I wanted to use apply to reference DeckJosh in the body of DeckSteve.reduce(). You can't use apply or call for that, because that will call the actual function when in this case you want it to be called by reduce. Look at "bind". that will do what you want. However, easier is to just not use this inside that function, but make use of closures to have it use a variable in the outer scope. e.g. var self = deckjosh; deckSteve.reduce(function(){var bla = self[i]});
DeckSteve.reduce might be a function. DeckSteve.reduce() is not. The brackets are important.
I thought it would evaluate like this: Checks outer parentheses, and finds: (everything in here).apply What .apply in being called on is what's in the parenthesis. Checks what's in parantheses to see if it's function. Finds DeckSteve.reduce() Sees it's a function. Sets This of it to equal deckJosh. It doesn't work like this? 
Awesome, thank you for the answer.
Do you work for CNN?
implemented a tiniest subset of what jquery does, if someone were to use this "foundation" for something non-trivial, they'd still have to implement a lot more stuff, for convenience, cross-browser support and whatnot. The mentioned 5-10kb of "jquery code" will end up 7-15kb of *ugly* spaghetti code
Haha yea, I added a maxlength to that field so people don't inadvertently hang their browsers. Thanks!
&gt; It doesn't work like this? No. It follows the rules of math: parenthesis are evaluated first (`deckSteve.reduce(...)`), then it evaluates the outer next layer (`&lt;whatever reduce returns&gt;.apply(...)`) and discovers it doesn't have a function called `apply`, so throws an exception.
Very nice! All the overlapping circles remind me of the new [Library of Birmingham, UK](http://i.telegraph.co.uk/multimedia/archive/02656/Birmingham_Library_2656197k.jpg).
8, 24, -25…. thanks nice. 
I think the difference between 8, 24, -25 and 8, 24, -26 is fascinating.
Additionally, how bad of an idea would it be to buy the print version? For tech resources like this, I prefer print normally, but if it's going to be horribly out of date before it even arrives, I just can't do that.
agreed, 
That was true until they decided to drop support for older IE versions.
jquery does too many things for my tastes. It was understandable at the time it was written given how hard it was to publish and consume reusable libraries, but nowadays everything that jquery can do is either handled by the DOM itself tersely or can be found on npm as a single-feature package. http://substack.net/weaning_yourself_off_jquery
I recently refactored my PO reading library to utilize it in a Node.js app I'm building. I'm _REALLY_ new to node, and thus I'm still not aware of the idioms, pitfalls, etc etc this might imply; for this reason I'm asking for any constructive criticism you might have. Summarizing, __what I'm looking for__ * _X_ method is not well documented (What's a good docblock for it?) * _Y_ construct is poor form ($THIS is the idiomatic way of doing it) * _Z_ line is confusing ($THIS way is more clear) * Moving _W_ block out of the module would be better because of $REASON __what I'm not looking for__ * That's stupid and/or already done by module Blah (Couldn't get any module to work like this) * Your indentation is bad (It's actually autoformatting and a personal choice) * Your Travis isn't running any tests (There's an issue for that) * etc Thank you VERY much in advance!
[pako](https://github.com/nodeca/pako) is zlib ported to pure javascript with some impressive benchmarks. It can do deflate/inflate, zip, and gzip. Or if you want the node zlib api you can just `require('zlib')` in browserify and you will get [browserify-zlib](https://www.npmjs.org/package/browserify-zlib) which uses pako internally.
Reactjs edit wrong person 
Reactjs
Even without cdn we're talking about a file size smaller than most images. If you have a couple images on the site, what's the extra 100kb? You could put the Jquery dependency at the bottom of the body so the html loads first too. Size of Jquery is pretty much a non issue
That's pretty great. Here you go: https://www.youtube.com/watch?v=-VMX-Xb8ngE
Damn you beat me to it 
That project was for a multi-national insurance company. I currently work for one of the top pharmaceuticals.
Nice, I love when you see an animated gif that inspires you to recreate it in the best way you know how. I did the same with [this trig gif](http://1ucasvb.tumblr.com/post/42881722643/the-familiar-trigonometric-functions-can-be) with a [demo here](http://donwilson.github.io/PolygonalSine_Canvas/waves.html).
We need the html file. Is your script here included in the head? If you aren't binding to the event that is triggered when the element gets added to the page and the script is loaded at a place higher up in the file than the element, the element does not exist when this code is run so it is correct in returning null. Html is parsed from top to bottom so the browser can't just know this code will reference so element it is going to display on the page later on. If I'm in the right track as far as how you are adding the script, try moving the script tag to the very end of the body right above the closing body tag and see what happens. 
Moved the script tag to the end of the file but still no success, here's the html: http://codepad.viper-7.com/L9ssTb
Yes! I've incorporated his library into a commercial website; it seems to be holding up quite nicely. The changes that use it aren't released to the public yet, so I can't say which site yet. There doesn't seem to be any delay at all in compressing. We have users from every walk of life, and every brand of computer and cell phone too. I'm not 'posting strings back to the server' as you will, but setting the encoding to UTF-16, and using the compressToUTF16 should be fine. I'm using it inside of a backbone app, to save data in localStorage on the client side. I estimate that I'll be able to store 10x more data with it vs. uncompressed (even worse, localStorage puts everything in UTF-16, so you actually have half of the space when plain-storing UTF-8 text characters as you would thing) 
Very nice. Perf-wise this would perform better with keyframe animation. You'd also get to adjust the rotation duration directly instead of halving rAF frames up with your own timer.
`onclick='getTotal(total)'` should be `onclick='getTotal("total")'` because "total" is an element's ID I presumed.
Wow. Thank you. Such a simple fix and it happens far more often than I'd care to admit. I'm sure it'll lessen as I get more experienced :).
http://jsfiddle.net/R974G/
 Array.isArray(foo)
Awesome, good job! 
http://codepen.io/anon/pen/rbozE/ checkout this pen to see if it points out what is actually going on with your code/what you are receiving in your function. Hopefully, it's clear anyway. 
Whoa Paul Irish, if that's really you I am honored. I actually read your blog post about rAF from 2011 before writing this, and I read lots of your posts. Thanks for the suggestion. I'm not familiar with key frame techniques in javascript. Any resources you could point me to? Thanks btw! 
A couple other significant differences: * jQuery's `next()` and `prev()` are chainable: `foo.next().hasClass("bar")` will always return a sensible result, even if `foo` has no next sibling (the example's `nextSibling` will return `null`) * `hasClass` will do *very* surprising things if the input looks like a regular expression (crash with a `SyntaxError`, match the wrong things, etc) * The calls to `addEventListener` always need the `false` at the end: http://www.quirksmode.org/js/events_advanced.html * The `toggle()` for loop example won't work if `show` is the first of the element's classes * The `XMLHttpRequest` doesn't show either how to encode the form's data, or how to read the response This *isn't* meant to be a critique of the post's author: they clearly know their javascript, and it's entirely possible that the above were intentionally left out for brevity, or some other very good reason. It's to emphasize that *browser-based JavaScript is a terrible, terrible experience* which — even for experts — is *very hard* to get right. It's useful to know what jQuery is doing under the hood… but I would *never* want to work on a project without jQuery or some similar abstraction to make my life a little bit less tedious and painful.
its like 4 pairs of dots in a slalom race
I think they are both great. I've moved more towards codepen lately because it natively supports sass and I think the ui is slicker but they are both great tools. Jsfiddle has direct embedding of more js libraries but both allow you to add external sources from a cdn. Another really nice thing about codepen (for some people not me so much) is it supports coffescript and livescript natively. Overall they are both really good but I've mostly moved to codepen. I also like to visit the front page once a day and checkout the popular pens. I've picked a couple of interesting techniques that way. 
function Thing(){} Thing.prototype = Object.create(Array.prototype); Thing.constructor = Thing; var x = new Thing(); Array.isArray(x) // -&gt; false
It's deliberate that isArray returns false for objects, even those with the array prototype. Array instances have special semantics unique to themselves. Consider: function Thing(){} Thing.prototype = Object.create(Array.prototype); Thing.constructor = Thing; var x = new Thing(); x[9] = 1; x.length; // 0 While real Arrays [will update the length property to 10](http://es5.github.io/#x15.4.5).
I tried a search in /r/javascript for "Ember Conf" and got nothing before posting this. Sorry if repost.
Not bad. You're interfering with your core loop by having a dialog come down to announce that you lost but can try again / move on to the next level, though. It feels like I get yanked out of the game when I lose. Maybe give three chances to earn the required points and let the points carry over?
Well, FWIW. Your code is hard to read. It should read like prose. Example: consider replacing things like this if (this.postBody !== "") { with if(postBodyHasContent()) { And stop using short variable names. They don't save anyone time with modern IDEs. Extract, extract, extract! You have a 60 line function there. Functions should be only big enough to do 1 thing. Usually that means around 5 lines of code. Comments. Your code should not need comments if you write it well enough. Some examples above. The exception is doc blocks. Modern IDEs will use doc blocks and allow more insight to the code if other users are going to see your code. You are partly doing this. be consistant. If a function is not intended to be used via the IDE from an external class, consider making the function private instead. tests. I'd add a lot more tests. Looks like 1% code coverage? Some of your functions have all of the characteristics of a class. You may want to extract to class.
Well, http://reddit.com/r/LearnJavascript is right there in the sidebar! `----------&gt;` I wrote a book, and you can read it for free: https://leanpub.com/javascript-allonge/read 
thanks guys I will look into them all
Hence why I state that it's more important to know what you are trying to detect, rather than trying to use a one-size-fits-all method. There are many reasons you might want to accept objects that inherit from Array, and in this case, isArray wouldn't work. Also, Array.isArray doesn't exist in &lt;= IE8.
Hmmm ok? I guess I understand... some? of what you pointed. &gt; Some of your functions have all of the characteristics of a class. You may want to extract to class. Which ones would it be better to start from? This particular release actually does that to the Adapters, which were originally simply different functions. &gt; tests. I'd add a lot more tests. Looks like 1% code coverage? Will do. At this point I only BDD'ed the existing behavior, and not any single component in the module. &gt; Comments. Your code should not need comments if you write it well enough. Am I actually missing any comments? Can't find them inmediately. &gt; You have a 60 line function there. Other than the core parser, which is basically a giant switch? I'm planning to refactor that particular one during the course of the week, probably going to look a lot sleeker then. &gt; And stop using short variable names You mean like the iterator and bounds for the for loops, or something else? 100% serious. &gt; consider replacing things like this if This I cannot do, as the comment pointed out, that is how MicroAjax came. I might be able to decouple it out, but I just cannot touch the actual library. If you on the other hand can point me to a couple other places that could be a good starting point, that'd be __awesome__. Thank you! Really EDIT: I updated the docs in https://github.com/cfv1984/Pomo/blob/master/src/pomo.js and moved things around a bit. It SHOULD in principle be a bit easier to get. Is that an improvement? Or is more verbosity expected. EDIT2: Updated the code again based on more practical recommendations by kenman. Though you __could__ be more interested this time around. I might perhaps refactor the parser too, as soon as I get it properly test-covered. 
The long and hard way: http://javascriptissexy.com/how-to-learn-javascript-properly/ The quick onboarding: https://www.discovermeteor.com/blog/javascript-for-meteor/
The owner of this account has requested this content be removed by /u/GoodbyeWorldBot Visit /r/GoodbyeWorld for more information. GoodbyeWorldBot_v1.2
Give this a try: [this](https://github.com/jpillora/notifyjs)
That's neat and meets 90% of my needs and my app is metro style so that fits as well since I see they have one. If it could queue the notifications in some kind of expandable panel inside the element that would be better (of course I can implement that myself). Also the fact that it doesn't support global option overrides under $.notify.options or something similar drives me up a wall =P But I'll live. Still open to other suggestions but thanks!
If your code is modular ("classes", modules, AMD, etc), another common technique in testing code is to make items that you swap out for testing as modular inputs. function myModule(alert){ alert('hi'); return { abc: 123 }; } You would pass in a different alert function as input for real world and test code. Actual syntax would vary depending on your module system. 
I was referring to CSS keyframe animation: http://www.smashingmagazine.com/2011/05/17/an-introduction-to-css3-keyframe-animations/ http://dev.w3.org/csswg/css-animations/ I think you could reuse most of the JS and instead of looping with rAF you just have them all on `infinite` animation-count, and you could assign a diff `animation-delay` to each to get the same effect.
Generally speaking the mouseup/touchend event should attached to the page (document, &lt;body&gt;, etc), not the canvas because otherwise you'll get the bug where you mousedown inside the canvas, drag outside the canvas, mouseup, and then move back into the canvas and you'll still be drawing despite not having the mousedown anymore.
Book version is going to be out of date when Angular 2.0 hits.
Not sure what's the deal with downvotes, but in my opinion this is a great routing library. It's simple, has small footprint (~1200 bytes) and has basically everything you need for routing. I've been using it in multiple projects for few years now. One thing it lacks though is an option for hashbang url's (for browsers not supporting HTML5 push state). 
Do you know any HTML, CSS and JavaScript or are you looking for a library to solve all your unique needs right off the bat? What you're after is simple to create in any terms, and the library /u/voidpirate linked to makes it even simpler. It even allows you to insert your own styles. If you rely on others to guide you through everything step by step, you'll miss a bunch of stuff you might learn trying to implement it yourself. If you check the DOM after clicking on one of the examples you'll see that there is a container for all the notification elements with a class name of "**notifyjs-corner**" which you could probably style to achieve the desired result. 
Well, I just vomited.... but in a good way?
true, but you also gave the example of foo.bar. Anyway, it doesnt matter. 
You could have a method in the socket.connect, which is sometning like, playerMove event. socket.on('playerMove', function () { // Blah }); Then in there, find the room the player is in, and emit a round end and new-round start event to all the players in the room. Actually you can broadcast to a room, which would send the events to all the players in the room.
Sorry, I meant the images on the homepage of the site. The Casino RPG video and the four images below it!
Hey, thanks for the links, they appear to have plenty of info, I'll have a good look later. I agree with the vertical / horizontal thing, it just feels wrong
Hi, thanks for the info, I did manage to figure out some of the files being used but my knowledge stopped there, thanks for the examples list. 
When I see someone saying "I would never want to work on a project that uses jQuery instead of plain DOM", all I can think is "I would never want to work on a project with you".
A powerful feature that makes JavaScript unique is its ability to work asynchronously via callback functions. Assigning async callbacks let you write event-driven code but it also makes tracking down bugs a hair pulling experience since the JavaScript is not executing in a linear fashion. 
Or you could just use a &lt;label&gt; because that's what it's for. https://www.google.com/search?q=don't+use+placeholders+to+replace+labels
How do you add things to the map?
Ok thanks. By the way, whats with all the [null]s in the hash? ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World! ^^^^^^^^^^^^^^^^^^^Hello, ^^^^^^^^^^^^^^^^^^^World!
Thats awesome! You should look into the HTML canvas element, could make it much easier.
I loved your JavaScript Jabber episode! Here's a link for those interested: http://javascriptjabber.com/070-jsj-book-club-javascript-allonge-with-reginald-braithwaite/
This was developed on Chrome 34.0.1847.116. It seems to be something on your end. Edit: So this is an issue only on Chrome on Windows. I've VPNd into my work VM so I can replicate this bug. Just as I was going to bed as well.. Edit edit: Boom! Fixed it. Really simple, but it shouldn't have really been a bug. Weird that Chrome on Windows had a problem with it. By the way, if you're trying to use Chrome on a VM through a VPN and it's not working, put --disable-gpu in the shortcut file after the .exe path
I'm running Version 34.0.1847.116 and the facial expressions are not working for me either.
Chrome 34.0.1847.116 on Windows. Doesn't work here either
Well it's not using any special technology, so if you're using the same browser then there's no reason for it not to work. Are you getting anything in the console when you click those buttons? Can you click the github and twitter links at top right? Edit: nearly 500 people have looked at this today, using everything from IE to android browser and you are both the first to bring it up. I've had contact with a lot of the users and it's working for them. So I'm quite curious what the problem could be considering that you're both using the same version this was built on.
What you're describing here is essentially Dean Edwards' [packer](http://dean.edwards.name/packer/). Packer, which is a marvellous feat of coding and engineering, just doesn't perform as well as gzip, either in terms of compression, or speed of execution.
This is good advice. If you have modularized your code, it should be clear what methods you need. For instance, if you intend to map the object, test for `obj &amp;&amp; typeof obj.map === 'function'`. If you just need to iterate, check for a length property (e.g., Arguments). This will make your code more flexible.
Works great in Firefox
I could be wrong, seeing as there's no demo, but this could be trying to emulate the float label pattern. That said, no demo, no link to repo = no use.
Where you on Windows by any chance? There's a pattern emerging.
Windows?
Yep, Windows 8.
Awesome, thanks. I'll try and get this sorted
No problem, hope it's a quick fix! Looks great btw :)
Thank you very much :)
coool but ux difference between placeholder and label---what about my labels?
https://github.com/peachananr/label_better
Fixed!
Thanks! I haven't testing it in IE, so that's great to know. All fixed. Just pushed it.
[That's funny](http://i.imgur.com/r5QeiQx.jpg)
Really cool, until I had to back out...can you not add to the history every time we change something? Have like 40 items in my history from that site now...