+1 for better drag and drop. I've implemented jQuery draggables for personal projects and I can't really complain but I'd be down with helping on a draggable js library.
Or contribute...
You could have just said it was a sloppy comment. My last sentence about requestAnimationFrame should have been first. I'm also the first person to advocate still using jQuery. So there's two reasons tip disagree with me. Oh yeah, and I use and like typescript, three reasons. 
Seems very awkward and cryptic to me.
I don't see references to running the code being built on the device. It's possible such a thing is implied, but I don't see it!
Yeah actually that's coming from my frustration that I can't use generators with TypeScript before v1.6 is released and that I probably never will be able to create macros for TypeScript.
Interesting. Thanks!
What I said about jit performance and using jQuery are related, because the threads subject matter is writing the interface for a library. Something like jquery is working in dom changes, which will never get faster, we can just be careful about things are batched to minimize full relayouting. The complaints around jquery are then just a matter of why the $ function has so many different possible parameters. I mentioned typescript because the jquery.d.ts definitions are very large. Again, I think being oblivious to the JIT is a bad idea. Homoiconicity is right, that readability is our 1st and most important priority. But that's fairly subjective. JQuery isn't readable, until you're familiar with it, and then it is.
Microsoft are investing quite a lot in js/ts. If you could show them how much support they'd get from including such a feature I think you'd be surprised. Once a js port of flow is available I suspect we'll see Babel and Flow to work together.
jQuery deals with one specific domain - querying the DOM. That's all it is intended to do. You could bastardize it to iterate over other kinds of data but really it is not intended to provide anything except a set of utilities all of which deal with updating the DOM. Apart from the handy wrappers around XMLHttpRequest to deal with AJAX requests (which I assume are not part of this discussion) jQuery is all about targeting DOM and updates thereof manually. It does not parse JSON, it does not infer structure, it does not force any particular style - legible expression are down to an individual codebase and I don't see what referencing jQuery library has to do with it. jQuery does not enhance or detract from readability of a codebase no more or less than any other library being referenced. Calling jQuery readable is every bit as non-nonsensical to me as calling it non-readable. It is not something I read or write in my codebase. It is something I reference *from* my codebase. An expression I write could be legible or illegible irrespective of whether it contains a reference to $.whatever or not... In fact, it doesn't matter what the $ part is either. It still has nothing to do with legibility. What in the actual fuck are we talking about here?
Is the porting in progress or under discussion? Can you please point me to a discussion/repository?
To my understanding, no. Opening local files isn't an option on the iPad.
Create a Drag and drop library for React.js that uses higher order components instead of mixins and I'll owe you a beer. 
Nice, comprehensive article. I remember trying to learn promises - it really took a while for it to click. 
I don't appreciate the click bait title, but the article is solid. Great read. 
I only use clickbait for good, not for evil. ;)
This does work from Textastic on iPad, you just click on the icon in the upper right that looks like a pair of eyeglasses, and it will view the file, including being able to render using D3.js. To some degree, it can work locally without a connection, as long as you have previously had an internet connection and cached the content that has to be loaded from a remote site, like d3.js itself (I just tried it by turning off wi-fi on my iPad). (But I don't think it would be very convenient to try to use it disconnected for a long period of time because I think it will eventually need to refresh)
huh.. you put a question/puzzle at the top, and there's the "solution" at the bottom. But, the sample code in the solution is different than in the question. Good article though, I've definitely made some of those mistakes myself.
First of all Kudos... secondly In our setup the front-end angular app is a standalone app hosted even on a different server than our backend (ROR), is it possible to make the frontend angular app work on different subdomains... what I'm asking (in other words) can the frontend same angular app works for "inc1.app.com/#!/" and for "inc2.app.com/#!/" ? and incase you knows the answer... can you explain how it's working... the flow is as follows: user -&gt; web.app.com -&gt; login -&gt; user_has_different_accounts -&gt; user_choose_account -&gt; redirect_to sub1.app.com or sub2.app.com or any other dynamic subdomain (while maintaining the same angular app and data loaded in browser with it's data) ?
Wow, sorry. My bad.
I've had loads of positive experience with http://www.koderapp.com/, absolutely worth the buy.
How is it run for side effects? `doSomethingElse` seems to be invoked immediately when the line is being interpreted. 
That depends. If by "realtime" you mean "does it support websockets" then the answer is... kind of. The 1.0 will have websocket support. It's in there right now but it's experimental, still haven't figured out how I want the WS module to look. If by "realtime" you mean "tightly-coupled data-bound instantly updated views" - then the answer is an **emphatic no**. I don't agree with tight coupling of render / model logic to begin with, Nodal is an API server, plain-and-simple (client agnostic), and I'm not a fan of the recent trend of tightly coupling everything to save a few lines of code. I don't believe its scalable, I think it introduces more problems than it solves, and I think it abstracts away too many core principles of good software design (namely, separation of concerns). But I'll fight that battle another day, maybe a Medium post. ;)
How's this? http://codepen.io/ForScale/pen/JdKpEZ
For advanced mistake #4, Bluebird makes using the result of multiple promises in sequence really easy with [spread](https://github.com/petkaantonov/bluebird/blob/master/API.md#spreadfunction-fulfilledhandler--function-rejectedhandler----promise). Combined with the fact that Bluebird is smart enough to resolve mixed arrays of values/promises, you can do stuff like this. getUser() .then(function(user) { return [user, getProfile(user)]; //getProfile() returns a promise }) .spread(function(user, profile) { // use the values as needed }); I'm a big fan of this approach and avoiding nesting as much as possible, but I'm interested to hear other's opinions. Something that makes promises even easier is ES6 generators with [co](https://github.com/tj/co) or [coroutine](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutinegeneratorfunction-generatorfunction---function) co(function *() { let user = yield getUser(); let profile = yield getProfile(user); // use values as needed });
Sure, but why not point them at this article and tell them "look, Grunt has by far the most modules which is important for us"? Grunt might be good for some things. Gulp for others. For instance, I use gulp when developing, because it is fast and easy to use. But if I had a huge build and deployment setup, I might go for Grunt instead for a larger array of modules. What's best, nails or screws? It depends and while they are usually used for the same things, they both have cons and pros. I prefer tech reviews to outline the differences and let me draw my own conclusions. I hope your senior management decision process is more than just "Oh well, the headline of this random article on the internet says that X is best. Better go with X!" :)
This is IMHO the best functional library for JavaScript. If anybody is interested, I wrote a small [debugging library for it and other FP libraries here.](https://github.com/sebinsua/ramda-debug) As well as helping people to debug their code it is also a fairly decent educational tool for those of you that are trying to learn to write high quality functional code with JavaScript and finding it difficult without being to observe the data as it passes through a composition of functions. ("Where on earth do I put my console.log statements?!"). (Btw, still a work-in-progress and I am very happy to take feature requests, issues and PRs from others.)
I like that one. Here's another great one for you: [Promise.props](https://github.com/petkaantonov/bluebird/blob/master/API.md#props---promise)
&gt; Sure, but why not point them at this article and tell them "look, Grunt has by far the most modules which is important for us"? You definitely have never spoken to a CEO before :)
Hi, I need some help on it ;)
Thanks! Make more sense now. 
Hi /u/ower89, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.wolksoftware.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.wolksoftware.com](/search?q=%28and+site%3A%27blog.wolksoftware.com%27+author%3A%27ower89%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|7|70%
console.log returns undefined, which is falsey. That's the only reason func2() runs in your example. http://jsbin.com/zojipedave/1/edit?js,console
You could add a feature to babel.js so that it can output type annotations (it can already parse them). That way we could use babel and flow or typescript together via gulp.
Yep! That's what we're using in our team. Although we don't use bluebird, but lodash's spread function. getUser() .then(function (user) { return Promise.all([user, getProfile(user)]; }) .then(spread(function (user, profile) { // use the values here })); You can also use it as an object. The spec allows only `iterables` in `Promise.all`, but you can write your own little helper, that converts object to an array, runs `Promise.all` on it and returns an object. It's very easy with lodash: var lodash = require('lodash'); var chain = lodash.chain; /** * Helper function, that lets you call Promise.all on objects * * @param {object} obj * @return {Promise} */ function promiseProps(obj) { var flatArr = chain(obj) .pairs() .flatten() .value(); return Promise.all(flatArr) .then(function (result) { return chain(result) .chunk(2) .zipObject() .value(); }); } And you'd use it like this: getUser() .then(function (user) { return promiseProps({ user: user, profile: getProfile(user) }); }) .then(function (result) { var user = result.user; var profile = result.profile; // use the values here });
 function loopthrough(arr,start,step) { return (((start +step)%arr.length)+arr.length)%arr.length; } That works for your cases that you've listed. The only tricky part is that mod will return a negative number if the argument is negative, so you have to normalize it to positive.
What the actual flying fuck? Promises swallows errors by default! Who's idea was that? Imagine if throw only worked if there was a catch in place to catch it, otherwise it would be silently dropped. That would help a huge number of bugs to go unnoticed. Having promises that swallows errors by default is the exact same thing! Why should it be any different? And always adding .catch(console.log.bind(console)) isn't really that good of a fix. 1) if you forget to add it you are screwed, 2) most likely you actually want to log err.stack and then terminate the process. Silently ignoring errors has been discussed numerous times and everyone agrees, it's bad. The Node.js documentation on process.on('uncaughtException') explains this briefly. Forgetting about the obvious flaw in the spec; great article, keep 'em coming!
Really good, thank you. I will try it soon!)
Google: Codecademy Project Euler Code Wars Coderbyte etc
Extremely well written article. Props.
Wonderful article, I went about replacing step (an async-like library which I don't know quite know why we were using) in our medium-sized node app the other day and found out most of these tips the hard way! This'll be a boon to fellow devs though :)
Thanks!
Hehehe, well I do and I know [exactly why you want to do this](https://www.youtube.com/watch?v=BKorP55Aqvg) but I don't think you can blame the article for not picking a winner although it would be useful in some cases. :)
There are soooo many ways to shoot yourself in the foot with javascript these days. 
Really? Everything I've ever seen about promises makes it painfully obvious that then() takes a function (or two or three depending on the implementation).
It's actually more like a realtime backend for Angular. Check out this talk: https://www.youtube.com/watch?v=_mu6BWsnaPM You don't end up mixing view layers at all.
Thanks a lot! &gt;ability to 'click' control values in, as dragging can be tedious I considered this feature and it's something I'd implement in a typical software UI, but I thought that having the faders (and thus the sound) jump discontinuously would break the illusion of analog-ness. &gt;patch bank (though, I kind of like the creative limitation of not having one) On the to-do list! &gt;the secret chorus mode, when you press both I and II buttons ;) Will add to the list!
Bluebird does a very good job of throwing uncaught errors, so it isn't that problematic, as long you are using the right library.
In your jsbin you should add values to the resolves to make the issues with passing things along easier to see. Example 2 is more obvious with this: function doSomething(val) { console.log('doSomething(): start with:' + val); return new Promise(function (resolve) { setTimeout(function () { console.log('doSomething(): end'); resolve(val); }, 1000); }); } function doSomethingElse(val) { console.log('doSomethingElse(): start with: ' + val); return new Promise(function (resolve) { setTimeout(function () { console.log('doSomethingElse(): end'); resolve(val); }, 1000); }); } function finalHandler(val) { console.log('finalHandler(): start with: ' + val); return new Promise(function (resolve) { setTimeout(function () { console.log('finalHandler(): end'); resolve(val); }, 1000); }); } function example1() { doSomething(1).then(function () { return doSomethingElse(2); }).then(finalHandler); } function example2() { doSomething(1).then(function () { doSomethingElse(2); }).then(finalHandler); } function example3() { doSomething(1).then(doSomethingElse(2)) .then(finalHandler); } function example4() { doSomething(1).then(doSomethingElse) .then(finalHandler); } 
I thought it was wrong too at first, but this makes no sense. Weird for the spec to allow it. http://www.es6fiddle.net/i9u9yn2w/ edit: actually it makes sense for it not to fail in the case above since the exception occurs in another event loop. If you have an exception in the same event loop as the promise it will fail as expected, and the result can no longer be resolved later on: http://www.es6fiddle.net/i9ua0rbz/ So technically the article is wrong...
Bluebird throwing errors if uncaught is great, but we'll hopefully be able to move away from promise libraries and on to standard ES6 libraries in not too long.
Lengthy. But it's worth it so that developers know where they are going to when they aim for the Promised Land. :-) The other day someone was complaining about "closures" here. But in the context of JavaScript outside the browser, it is indeed a hell hole with callbacks used for queues and so on. Async programming can be understood as high level queues. That's why Promises look like queues. In the Unix systems they have the concept of "pipes" for connecting together different programs with one program's output being the next program's input. The problem is that it may look like developers don't need to obey those queues, when in fact that's what they should do and it can take a while to master it. Also those queues can destroy the stack for the error back traces, by the way. In Dart they already have even "async/await" support and Dart compiles into JavaScript. The only problem is that developers still need to obey those queue rules. Another concept of Async programming is that it enables safe "shared memory", since with just 1 thread you don't even need mutexes and such. So despite it being in a pain in the neck, it can actually be useful. But the mainstream languages are just getting used to it. The alternative to Async programming is sync programming with little or no shared memory. Message passing between processes would be the only way to share memory then. Many people start using the Go programming language because it is more in the sync programming group and can provide more stability and even performance. I sympathize with the need of the tools to tell what went wrong in the Async programming concept. But JavaScript is pretty dynamic by default. I think TypeScript-like approaches will be able to warn of more errors early on by being more strict about what JavaScript can do. Also future versions of JavaScript could come with more strict modes as well, aiding in those early error detections. Cheers!
The section about deferreds was really condescending and patronising, and doesn't come anywhere close to explaining what the actual problem with them is. &gt; In short, promises have a long and storied history, and it took the JavaScript community a long time to get them right. In the early days, jQuery and Angular were using this "deferred" pattern all over the place, which has now been replaced with the ES6 Promise spec, as implemented by "good" libraries like Q, When, RSVP, Bluebird, Lie, and others. The premise of this section seems to be the idea that deferreds are an implementation of promises in themselves. That is absolutely not true; they are merely just a super thin layer built on top of an already existing promises implementation. It's literally just grouping the resolve and rejects together with the promise. It doesn't change at all how promises actually function; the fact that jQuery's promise implementation has issues has nothing to with deferreds in any way. The idea enables the sentiment in the last sentence that the deferred pattern and ES6 Promises can't co-exist, but they absolutely can, and it's really easy: class Deferred { constructor() { this.promise = new Promise((resolve, reject) =&gt; { this.resolve = resolve; this.reject = reject; }); } } I use this pattern constantly because it gives me way more control. As another person expressed, the fact that it is literally impossible to actually throw an error from inside a promise is bonkers; I am not going to reject a promise with a TypeError. And it just makes my code feel more flexible. I don't want to indent an entire 100-line function an extra level when only a few lines actually interact with the promise in some way. I agree that in that example, they should have just used `$q.when()`, but it isn't the tremndous, refreshing difference that the article acts like it is. It's 1 line instead of 3 for exactly the same thing. It's still better, definitely, but it's still basically the same thing. 
http://eloquentjavascript.net
Add me to the list of people who's still irate that Promises silently swallow uncaught errors. Separately, I always wondered why this isn't allowed: [1, 2, 3].map(console.log) until I saw your post. For some reason, it never occurred to me that `log` would be trying to use an out-of-scope `this`. You'd think that the browser vendors would autobind `console` to prevent that error (or at least give a more helpful error than `ILLEGAL INVOCATION`).
The problem with promises is pretty simple. Async is a difficult abstraction to deal with. Before I go further let me back up a bit. User Interfaces pretty much require a "don't call me, I'll call you" programming paradigm. So yeah javascript/Browser like pretty much every UI before it has the idea of registering for callbacks. I get that, and I think it may be a concept which will be with us for a long time. But it's difficult to work with. Sure, your first click event program is pretty straightforward. But once you have 3 levels of chained promised some of which are actually multiple promises running in parallel or once you have a network of change listeners registered each of which can cause some action including actions which trigger further changes and further listeners being called, well, it's HIGHLY unlikely you have thought through all possible errors and race conditions. This is not a fault of the user, it's just complicated. People actually get excited by all this async stuff. NodeIO can be kinda quick when it's not actually doing any computation. But the reality is that it's still really hard to program well. And thank god it's still all single-threaded. I can't imagine trying to layer on the possibility that anytime dealing with mutating state, that I'll need to synchronize or lock with some other party. One can propose all the syntactic sugar they want, but I don't think the problem goes away until we can re-hide the async nature of these systems and program in what APPEARS to be a blocking model. So I'm desperately awaiting the ES7 async/await abstraction. That's when the computer will at least start to simplify this for us. I realize we'll still be dealing with a programming model which is inherently single-threaded, but that might be a good thing. 'Nuff said, Back to my service-workers. 
It would be nice to have seen concatenative programming for JavaScript instead of concatenative programming for CoffeeScript...
or you could do .catch(console.log.bind(console)) granted you are catching the whole error object rather than just the stack. of course, catch does give you the ability to recover so you really should return some sensible default even if you aren't going to directly use it. thats a style decision though.
In practice, I [return a 500](https://github.com/appsforartists/ambidex/blob/377bb1675e82eb8553c5e536b73ef77a8ecdd8e3/src/Ambidex.server.js#L540-L551): ).catch( error =&gt; { console.error(error.stack); return { "status": error.httpStatus || 500, "content": "An error has occurred. Check your server logs." }; } ); 
This stems from a lack of understanding of how `this` is defined in JavaScript. (function () { 'use strict'; var obj = { test: function () { return this; } }; console.log(obj.test()); // returns obj var obj2 = { test2: obj.test }; console.log(obj2.test2()); // returns obj2 var test = obj.test; console.log(test()); // returns window if not in strict mode, and returns undefined if in strict mode var test2 = obj.test.bind(obj); console.log(test2()); // returns obj }()); The way `this` is defined depends on how a function is called (unless the function is permanently bound to a context using `bind`). So it isn't how `console` should be bound, but how the functions on console should be bound. This is why many of the Array function allow you to specify a context. You can do this: [1, 2, 3].map(console.log, console);
Thank you. 
My main problem with Promises/Futures is that it's very easy to forget a `return` somewhere. Now I always double and triple check that the chain is properly wired up before I try to run it. Tooling doesn't help with this. It's a blind spot.
That would violate the principle of least surprise -- suddenly, `console.log` is a special case. As-is, it follows the exact same rules that other object functions do (bound to its object if invoked as a subproperty, not bound if invoked separately).
[Drag and drop so simple it hurts](http://bevacqua.github.io/dragula/)
One that doesn't seem to be mentioned in the article that bit me as a Promises noob -- you can't do this: var somePromise = Promise.resolve(); somePromise.then(function(v) { return "do something."; }); somePromise.then(function(v) { return v + "do something else."; }); ...since promises are immutable. The promises won't chain, they'll run concurrently.
It's **JavaScript**, but you keep calling it Java, which is a completely different language. Also your link is broken, you need to edit out the "[1]". Lastly, you haven't demonstrated that you've even attempted to solve the problem yourself; this sub isn't really a request sub, i.e. you don't just come here and order something like you were ordering off a menu. Please give it a go, and when you get stuck, that's where we can help.
Scientific how? JS is often overlooked due to it normally being single threaded so you get better performance using a lower level language. You can use my multithreading library to brute force this but you're still going to be limited a bit. 
Maybe it's possible to have multiple consoles in a browser environment. I'm not sure.
Again, I mention this by name in the post you directly replied to..
But io does 
they're right in the book alongside code examples http://chimera.labs.oreilly.com/books/1234000000262/ch01.html &gt;It's difficult to overstate the importance of unit testing. Unit tests are used throughout this book. By the time you reach the end, you should be accustomed to seeing and writing them. As you practice the concepts you read about, start by writing the tests first. 
It's a common mistake with Promises. Scala makes the same mistake with its 'Future' library. The best solution I've seen is to delay execution of a promise chain and require an explicit `.run()` call in order to initiate the whole operation, effectively dropping back into an in imperative context where an unhanded exception will just throw as a normal exception at the end. scalaz.Task does this and it works fairly well. 
When would you ever want to change the value of `this` in a log statement? It's all written in native code, so I'm not even sure that there's an API to code against. (The error isn't `window.logger is undefined`; it's `ILLEGAL INVOCATION`.) One could argue that having a basic function throw an arcane error when passed as a callback is pretty surprising. At the very least, the error should be more descriptive, but since `log` will break if `this` is anything other than the native `Console` object, they ought to just make the log functions self-contained in the first place.
Promises actually do solve this fairly well, but you have to avoid running side effects in places you're not supposed to, which is fairly hard to enforce in Javascript.
ES6/ES7 lambda syntax with implicit returns helps a lot with this
That's actually partially to blame for this. You start with a single expression and then expand it. That's the primary reason why I end up forgetting a `return`.
you should wrap your script in a closure, which lets you keep methods/functions "private". then you would pass in "window" to your closure function and attach $ to the window object. here's a random example I found on Github, most libraries do this https://github.com/muut/riotjs/blob/master/riot.js &gt;;(function(window) { &gt; &gt;//blah blah, building the library &gt; &gt; window.riot = riot &gt; &gt;})(typeof window != 'undefined' ? window : undefined); so inside the function they attach window.riot = riot, then they immediately execute the function and pass in the window object. now there's a "riot' or "window.riot" object that anyone can use, and the "riot" object can use methods defined internally that nobody else can
Just need to replace `else isOdd(n - 1);` with `else return isOdd(n - 1);`. Similarly for isEven.
Am I the only one that didn't have any trouble with the challenge questions he presented?
&gt; avoid running side effects in places you're not supposed to, The problem is not async, but javascript as a language. You can call it 4 different ways and then have to understand the process flow of each way when debugging (not just for async, hence people talking about "swallowing errors" as if that's a result of the promise). Perl was a lesson in readability over "power to be succinct in every specific situation" and javascript repeats the failure.
&gt; Another concept of Async programming is that it enables safe "shared memory", since with just 1 thread you don't even need mutexes and such. So despite it being in a pain in the neck, it can actually be useful. But the mainstream languages are just getting used to it. &gt; The alternative to Async programming is sync programming with little or no shared memory. Message passing between processes would be the only way to share memory then. Many people start using the Go programming language because it is more in the sync programming group and can provide more stability and even performance. I find this to be a little presumptuous. Not having typical exceptions is something I'd call a huge issue with async in javascript. You totally lose exception bubbling even with promises.. this is a bad thing. Fibers achieve synchronous programming on node. It is no longer an asynchronous thought exercise to the coder. Why do what the interpreter can do? &gt;The alternative to Async programming is sync programming with little or no shared memory This is demonstrably wrong. You can have both https://github.com/meteor/meteor/blob/devel/examples/leaderboard/leaderboard.js#L12 &gt;Another concept of Async programming is that it enables safe "shared memory", since with just 1 thread you don't even need mutexes and such. So despite it being in a pain in the neck, it can actually be useful. But the mainstream languages are just getting used to it. Databases that are ACID will force you to think of this still. All of the fibers, yield, async/await stuff is retconning the async continuations being exposed to the programmer thing. There are huge undertakings to totally remove this. ES6 is a small step, ES7 will eradicate this all with async/await most likely https://github.com/google/traceur-compiler/wiki/LanguageFeatures#async-functions-experimental Hopefully you found the above informative. I knew the answers to the promises questions in the article, I'm not angry at promises, I just think they're the intermediate hack we're using until better stuff comes. Also if you want my gist of what to do, wrap in fibers today, wait for async await tomorrow 
It's not a bad idea to wrap things up in an [IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/). But I don't think it solves the issue you mentioned - another script could still modify properties of the `window.riot` object (it's a reference to the same `riot` that was created inside the function).
&gt; Node doesn't. Actually the next major version of node (post-merge with iojs) will do the same thing Chrome does. Both for native and for many of the libraries. Consistently.
Phaser is super easy to get up and running with.
Firefox devtools also does this. It only happens when a rejected promise is garbage collected (after not being handled), and only for the internal implementation, but it does work. This is why there isn't anything in the spec about handling rejected promises. 
Yes I suppose I can just learn to read this: condition || statement; as: unless condition, statement But you agree that we're hacking limited syntactic sugar of JavaScript trying to have Ruby-like one-liners: statement unless condition I think using or not using these type of shortcuts should be defined in a style guide used by entire dept, to stay consistent. Because most programmers would probably just go for: if (!condition) { statement; }
``` var parseBool = function(arg){ return arg.toString().toLowerCase().trim() === "false" ? false : !!arg; }; ```
The former isn't blocking. With async/await, you can write async code which looks more like the latter. var resultOfAllDocs = await remotedb.allDocs(...);
Try posting to /r/LearnJavascript or /r/LearnProgramming 
&gt; The former isn't blocking what? Each individual then is dependant on the result of the one preceding it. Non-blocking means that we can do other stuff in the meantime with this single thread. E.g. while you wait for the response of a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) call, some event handler will still do its thing when you press the corresponding button. &gt; If it's about "non-blocking" then the former is a different way to write No, you just scheduled this chunk of blocking code to be executed in 1+ msec. It's still blocking. We can't do anything else in the meantime. If the remote DB takes 10 seconds to get all documents, we'll just sit there, twiddle our thumbs, and wait patiently for the result. Just search for *javascript event loop* on YouTube. There are a bunch of talks which explain how it works.
&gt; No, you just scheduled this chunk of blocking code to be executed in 1+ msec. It's still blocking. We can't do anything else in the meantime. Uhm... var doWork = function(){ setTimeout(function(){ console.log("done"); }, 15000); //e.g. request }; setTimeout(function(){ doWork(); }, 1); console.log("doing other stuff in the meantime..."); console.log("even more stuff in the meantime..."); console.log("yet some other stuff in the meantime..."); doing other stuff in the meantime... even more stuff in the meantime... yet some other stuff in the meantime... done 
We can't do something while the blocking code is executing. We can of course do something before that code is executing. That doWork function won't be called before we return the control and before 1+ msec (4+ msec in a browser) have passed. Those 3 lines are printed before the doWork function is executed. Secondly, your doWork function isn't blocking for 15 seconds. It only schedules another function and then it's already done. I still recommend to learn how the event loop works. :P
&gt; I still recommend to learn how the event loop works. :P https://www.youtube.com/watch?v=8aGhZQkoFbQ var doWork = function(){ for(var i = 0; i &lt; 100000000; i++){ if(i%1000000 === 0){ console.log(i); } } console.log("done"); //setTimeout(function(){ console.log("done"); }, 15000); //e.g. request }; setTimeout(function(){ doWork(); }, 1); console.log("doing other stuff in the meantime..."); console.log("even more stuff in the meantime..."); console.log("yet some other stuff in the meantime..."); 
You can't deobfuscate the code with those tools if you're using jscrambler.
Well, I didn't mention that I have previous C/C++ experience and some fundamental knowledge of PHP. I've tried reading Eloquent JavaScript, but felt the need to understand the core language better in order to understand exercises presented in that book.
If you're using npm instead of make then, no, you aren't doing 'likewise'. npm is a third-party javascript manager that needs to be installed and doesn't integrate into *nix like 'make' does.
If it's then-then-then, they are done sequentially. If they *can* be done in parallel (e.g. independent database queries), you can use Promise.all(iterable) to get a new promise which resolves when all of those promises were resolved. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
&gt; If it's then-then-then, they are done sequentially. So in that case how is this: remotedb.allDocs().then(function (resultOfAllDocs) { return localdb.put(); }).then(function (resultOfPut) { return localdb.get(); }).then(function (resultOfGet) { return localdb.put(); }).catch(function (err) { console.log(err); }); different to this: var doWork = function(){ try{ var resultOfAllDocs = remotedb.allDocs(...); var resultOfPut = localdb.put(...); var resultOfGet = localdb.get(...); localdb.put(...); }catch(err) { console.log(err); }; }; setTimeout(function(){ doWork(); }, 1);
I already answered that question. You are just trolling, aren't you? :/
http://codepen.io/ForScale/pen/doXwNR
&gt; http://codepen.io/ForScale/pen/doXwNR Thanks... I am looking for an implementation like this one http://jonthornton.github.io/Datepair.js/ 
That's because it is. It's like he took Forth and removed everything that made it useful or interesting, then added unnecessary syntax. It completely misses the point of concatenative programming. 
Not really, the author has said himself that this project is the most effort that he's put into an open-source project. As a result, it's a little special and unique in that he tried to generalize the core of React DnD so that you can use it with any backend (HTML5, Native, etc). The backend just becomes an implementation detail.
Difficult to read in Chrome as well. Maybe only tested in IE? 
It at least displays in a sensible layout in a large Chrome window, though. It looks like some combination of the flexbox and webkit-specific styles causes the lines not to wrap in Firefox or IE.
Ah yeah, that's a good one! It's bitten me too; I should have included it in the article. :P
The difference is that when something is asynchronous, the API method doesn't `return` anything immediately useful to you. A good example is [this PouchDB API doc](http://pouchdb.com/api.html#create_document). Notice how in the second example, we need the result of `get()` before we can put it into `put()`. This will end up looking more like your code snippet, though, when we get to [ES7 and async/await](http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html).
I can already animate any value with tween.js including css/svg and any 'ol js value as well. How is this lib any better?
Yikes, I didn't realize their docs still had "deferred" in it. No, you should prefer [the `$q.when()` style](https://docs.angularjs.org/api/ng/service/$q#when) to wrap other promises, or [the constructor style](https://docs.angularjs.org/api/ng/service/$q#-q-constructor) to wrap a non-promise API (e.g. a callback or EventEmitter API).
This is great and well overdue. Hopefully it gets finished in fairly short order.
I linked it because I watched it.
I understood just fine. I still don't see how a promise-based asynchronous callback chain is non-blocking but setTimeout-based callback chain is blocking. 
Great work, Dan. You never cease to amaze me.
you're right, I changed my comment for OP's clarity. the "private" idea is more for keeping internal methods private that the "riot" object can use internally but nothing else can. public properties can still be changed
It's unfortunate that done is not in the spec. It's the correct way to use promises in my opinion. But lets not start that debate here:).
I Know &amp; I get it &amp; respect the opensource IRC movement, but Slack is free and it's got some nice features
IRC
That's what I've been wondering too. It seems really thorough and I don't know why. What does the author know that I don't? 
You can actually unpack apps from Spotify Desktop and read the whole JS ~~unminified~~ (I see that now about 70% of the apps have their Javascript minified. If you download an older version you might be able to find more readable code) source code. --- Ok people seem interested, I'm gonna write down how to do it :) On OSX right click on Spotify.app, click 'Show Package Contents'. Navigate to Resources/Apps, you'll see a [list of .spa apps.](http://i.imgur.com/TxJrrbU.png). On Windows I'm sure there is a folder containing those files too. I just don't know where it is. Open the terminal, type `tar -xvf ` followed by the file path of the app you'd like to extract. It's the easiest to just drag the file into the terminal, it will copy the absolute file path. On Windows there is no `tar`, [but you can install it](http://stackoverflow.com/questions/690573/how-can-i-run-the-tar-command-in-windowsxp). After you've done that, it should look [like this](http://i.imgur.com/uEaJMIY.png). You can then [open the folder in your favorite text editor](http://i.imgur.com/prCdVRw.png)! Credit to this [StackOverflow comment](http://stackoverflow.com/questions/8353471/spotify-apps-api-any-more-documentation#comment10685974_8360615) that explains how to extract .spa files. ---- Bonus: You can change the code and compile into a Spotify app again with `tar -cvf &lt;appname&gt;.spa .`. But for some reason Spotify doesn't load the changes. Let me know if you are able to make that work.
Wonderful news! After this is implemented and then the IDEs are updated to support it, TypeScript and React web development will be a very nice experience with typechecking and smart autocompletion everywhere.
why?
best way to learn IMO is to just pick something you actually want to build, break that product down into smaller units of functionality, and start iteratively working on building it out. Each time you get to a point where you dont know how to do what you need to do you can google how to do it and then you will achieve that particular goal... Over time, all the little one off things you have learned how to do will add up to reveal patterns you can apply to other projects , and at some point you will look back and go: "whoa, I think I know what im doing now!?!?"
it's superinteresting, provide the tutorial please!!
You, um, spelt the project's name wrong.
I realize that was a small dig. The problem with doing computation in Node, is NOT actually that it's slow at doing the computation (it's not), it's that WHILE you're doing that computation you can't do anything else. This is a problem with single-threaded, not a problem with async or javascript. Sure you can do periodic yields, and such. But then it starts feeling like you're programming a mac back in 1985. Bitch all you want about the performance of a threaded and blocking model, it does handle actual computation much more easily. But for most use cases, queuing up some other entity to do computation or IO, it works fine. Except well, the async programming model is difficult to reason with.
Desktop is using The Chromium Embedded Framework. Android uses Java and iOS is written using Objective-C. But all 3 apps are built upon the C++ core. I don't think it is confusing tbh.
&gt; are willing to invest a ton into JavaScript just because it is the standard --&gt;Conversely, a lot of companies that have been doing so in the past few years are getting burned by how non-standard JS is, in terms of constantly shifting framework landscape with little support. If things don't get better soon, framework overload is going to be the big topic on companies minds, as dilution of skills makes it harder to find people that understand your angular v4.0 project because everyone's on ReactNext... and the other twenty popular frameworks that compete against it.
I mentioned this in passing to my co-workers. And while this is great the real issue is customer adaption. It's a hard sell to push a single feature and customers tend to version lock as long as humanly possible. We're still shooting for SQL 2005. :( 
Don't be an idiot. Microsoft is not trying to compete with JavaScript here and to think otherwise is to be terribly wrong. 
Great article. The points about data retrieval will ring especially true to anybody who's tried to work on a remotely complex Flux/MVC app backed by an API. Quite a nightmare, if you ask me.
Works as expected for me in Chrome 42.0.2311.152 on OSX 10.10.3.
Because they have such a great track record.
It's just a toy I've been working on while unemployed. I'm compiling it with Closure Compiler ECMASCRIPT6_STRICT -&gt; 5_STRICT. All the js and html is hand-rolled. Here's the 70line node js web server I pulled out of my ass that's running it on rhcloud. var path = require('path'); var fs = require('fs'); var url = require('url'); var http = require('http'); var ENV_IP = 'OPENSHIFT_NODEJS_IP'; var ENV_PORT = 'OPENSHIFT_NODEJS_PORT'; var MIME_TYPES = { '.appcache': 'text/cache-manifest', '.bmp': 'image/bmp', '.css': 'text/css', '.gif': 'image/gif', '.gz': 'application/x-gzip', '.htm': 'text/html', '.html': 'text/html', '.jpg': 'image/jpeg', '.jpe': 'image/jpeg', '.jpeg': 'image/jpeg', '.js': 'text/javascript', '.json': 'application/json', '.mp3': 'audio/mpeg', '.mp4': 'video/mp4', '.md': 'text/x-markdown', '.mpeg': 'video/mpeg', '.mpg': 'video/mpeg', '.png': 'image/png', '.txt': 'text/plain', '.wav': 'audio/x-wav', '.zip': 'application/zip' }; var DEFAULT_MIME_TYPE = 'application/octet-stream'; var DEFAULT_FOLDER = path.join(__dirname, 'wwwroot'); var DEFAULT_FILE = 'index.html'; var rootPath = path.resolve(DEFAULT_FOLDER) + path.sep; var fileCache = {}; var onRequest = function(req, res) { var filePath = url.parse(req.url).pathname; if(req.url === '/') { filePath = path.join(filePath, DEFAULT_FILE); } var resolvedFilePath = path.resolve(path.join(rootPath, filePath)); if(resolvedFilePath.indexOf(rootPath) !== 0) { // bad path res.writeHead(404, {'content-type': 'text/html'}); res.end(); return; } var mimeType = MIME_TYPES[path.extname(resolvedFilePath).toLowerCase()] || DEFAULT_MIME_TYPE; var content = fileCache[resolvedFilePath]; if(content === undefined) { try { content = fs.readFileSync(resolvedFilePath); fileCache[resolvedFilePath] = content; } catch (err) { res.writeHead(404, {'content-type': 'text/html'}); res.end(); return; } } res.writeHead(200, {'content-type': mimeType}); res.write(content, 'binary'); res.end(); }; http.createServer(onRequest).listen( process.env[ENV_PORT] || "8080", process.env[ENV_IP] || "127.0.0.1" );
I haven't used D3, what did you dislike?
Not sure what you mean by custom implementations, but css usually goes in to the /client/stylesheets folder and images in /public. Put js for the client somewhere in /client, for server in /server and for both in a folder ya can think up yourself. 
We piggy back onto a health care product that targets single doc practices and bigger clinics. While most have moved to 2009 that's about where the party ends. I still see some customers using 2005 and even a wild case of 2000 although those are rarer than ever now days. Our company has targeted our products for 2009 and higher but we get push back every once in a while. Always encrypted hmm not sure doesn't sound like anything new really. You could always encrypt the connection, and if you were a saddest the drive, hmm not sure this would be a huge thing. Stretch Database MS Azure is cost preventative for our targets with up to terabytes of data. Realtime Analytics, this is interesting and would be worth having if it replaced SRS, and data cubes, but doubt it does. Row level severity, I've yet to run into an application that uses the built in SQL security. Typically you have a single application account for all users and from that SQL account you have internal security based on roles or groups or even app users. I guess it could be useful but for us I don't see it. Always on, good to have. JSON ok this is good stuff that developers would care about. EMI Tools?? Meh... Hybrid backups, meh... So yeah one outstanding developer oranges feature that we could utilize... 
This is revolved around browsers currently, I've done a fair bit of research and these are my slowest functions currently. hamsters.wheel.newWheel = function(inputArray, hamsterfood, aggregate, callback, taskid, threadid, hamster, dataBlob, memoize) { var task = hamsters.wheel.tasks[taskid]; if(!task) { hamsters.wheel.errors.push({ 'msg': 'Error, unable to match thread to task, throwing exception', 'params': hamsterfood, 'aggregate': aggregate, 'callback': callback }); console.error('Error, unable to match thread to task ' + taskid + ', throwing exception. Check errors for more details'); return; } var queue = hamsters.wheel.queue; if(hamsters.maxThreads &amp;&amp; hamsters.maxThreads &lt;= queue.running.length) { hamsters.wheel.poolThread(queue, inputArray, hamsterfood, threadid, callback, taskid, aggregate, memoize); return; } var thread = (threadid || task.count); //Determine threadid depending on currently running threads var debug = hamsters.debug; if(debug || memoize) { hamsters.wheel.trackInput(task, inputArray, thread, taskid, hamsterfood); if(debug === 'verbose') { console.info('Spawning Hamster #' + thread + ' @ ' + new Date().getTime()); } } hamsters.wheel.trackThread(task, queue, thread); var blobObject = (dataBlob || null); var hamsterData; if(!hamster) { hamsterData = hamsters.wheel.createHamster(thread); hamster = hamsterData.worker; blobObject = {'blob': hamsterData.dataBlob, 'uri': hamsterData.blobUri}; } hamsters.wheel.trainHamster(thread, aggregate, callback, taskid, thread, hamster, blobObject, memoize); hamsters.wheel.feedHamster(hamster, hamsterfood, inputArray); task.count++; //Increment count, thread is running }; and var processDataType = function(dataType, buffer) { if (dataType === 'uint32') { return new Uint32Array(buffer); } if (dataType === 'uint16') { return new Uint16Array(buffer); } if (dataType === 'uint8') { return new Uint8Array(buffer); } if (dataType === 'uint8clamped') { return new Uint8ClampedArray(buffer); } if (dataType === 'int32') { return new Int32Array(buffer); } if (dataType === 'int16') { return new Int16Array(buffer); } if (dataType === 'int8') { return new Int8Array(buffer); } if (dataType === 'float32') { return new Float32Array(buffer); } if (dataType === 'float64') { return new Float64Array(buffer); } return buffer; }; 
&gt; If you use TypeScript, you can't really use anything other than TypeScript Not sure what this means, since Typescript is a superset of javascript. If he means 3rd party js libraries, this is wrong since almost all of them with any kind of following have [type definitions](https://github.com/borisyankov/DefinitelyTyped).
you need a phd.
Not every team uses Grunt but most do ;) My team uses gulp these days.
I don't really know SQL Server that much, but isn't this something you could add your self using stored procedures?
Pretty nifty! This is possibly monumentally stupid but can anyone tell me what I'm doing wrong on level 4 here? http://codeviewer.org/view/code:510a I don't understand why my warrior isn't stopping to heal after killing the archer.
&gt; Did I miss something? Why would you compare TypeScript, which is a superset of ES6 to Babel, which is an ES6-&gt;ES5 transpiler? I just wasn't sure what the author meant. As an aside, is ES6/7 a superset of ES5? I.e. if I give Babel valid ES5 will it accept it and return valid ES5?
Does it make your explorer (assuming windows) freeze for a couple of seconds at a time? Their old application used to do that to my Windows 7 machine. I got frustrated and swapped to google music. Haven't had any issues with that.
It's a language update, but considering their track record I imagine it'll largely be a superset in terms of how JavaScript is written. They have been pretty good about not introducing massive breaking changes in past iterations. 
dont worry about the fragmentation. Fundamentally to be an effective programmer at any of these super script languages you need to know JavaScript. Companies will hire you because you know javascript and willing to train you in these esoteric transpiler languages because its hard to find someone who knows them. Additionally, knowing javascript wont go out of style soon. You still need to know what happens under the hood regardless of the transpiled language you use. 
Some teams use npm scripts.
Hopefully they collide and both blow up in flames like a supernova. Then we can focus on Babel w/o all the misdirection from GMS.
yes?
&gt; Babel is aiming to strictly be a transpiler for future ES to modern ES This is not true. babel offers a way to disable/enable features; and some features are not spec'd (just additional desugar): https://babeljs.io/docs/usage/transformers/#optional
Im going to a meetup tomorrow to learn a little more about it. Excited to dive in
Gulp is sooooo fast.
I like seeing what my friends are listening to. I've found a lot of great tunes that way.
I really don't like this approach at all. No wonder the application is absolutely enormous. Could you imagine being someone that has to transfer from one squad to another for some reason? Every team writing code their own way with their own libraries? Or re-inventing the wheel in every aspect? All that repeated effort! I totally understand the need to limit time and effort impact of decisions like "what library should we use" but it's not a linear good - bad scale, it's more like a horse shoe. You can go too far one way or another. There's no free lunch here, you will either spend time planning common architecture updates, or you will spend time re-inventing the wheel over and over and over again. I'd probably prefer more of the former than the latter. But then again, I really don't know anything about how granular it is or how they do stuff internally, I'm just basing my comment on what the poster said and drawing conclusions from that. And it may be that this really does work better for them with their enormous teams. It just doesn't seem like a good reaction to this problem.
The thing that ticked me off was muting commercials on the desktop app would PAUSE THE COMMERCIAL. This is bullshit. I uninstalled and began using the web app since it can't tell whether I have it on mute or not.
Ok, because your previous answer didn't directly address anything that he said, other than confirming that you're targeting browsers. So I'm guessing you've already explored [IRHydra](https://github.com/mraleph/irhydra), "[I-want-to-optimize-my-JS-application-on-V8 checklist](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html)", `d8 --trace-opt --trace-deopt`, etc.?
I appreciate your sentiments /u/IHeartMustard. That's very kind of you.
is Qt used to talk to the c++ core on desktop? Or is it enough to use Chromium embedded framework to do the javascript/C++ interop?
After unpacking a couple .spa packages, I noticed that they are using require() and share a number of dependencies. I think the highly modular nature lets them be nimble and separates concerns. I hear what you're saying though.
Maybe he means you can't mix TypeScript with CoffeeScript. When actually ... you can. Like obvious TypeScript won't take CoffeeScript files and vice versa. But TS generates idiomatic JavaScript for a reason. So it can work with anything JS based.
Huh? 
I think he means that if you use TypeScript and write something with it then that will always need to be compiled from TypeScript. However if you use Babel eventually the language will progress to a point where you don't need to use Babel.
I don't think such library is very useful as it is easier to write a line than find a library. If I was writing such lib I would look at some spec of other language that already has it :)
Ah, well that's good. Like I said, I really am just drawing very simple conclusions from what I read in the post. I imagine a team like Spotify would be full of good architects that know how to find the right balance anyway :)
Why the downvotes? `npm scripts` are just as good task runners as `grunt` and `gulp`.
If it's any consolation, the points don't matter. Reddit karma is still trading at $0 on the dollar.
It depends on what you mean by "_real live_ objects/classes". There's [a list of compile-to-js languages](https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS) and there's e.g. Scala.js which you could describe as "heavily class-based" (if that's what you're looking for) and seems seriously maintained.
Where is grooveshark when you need it?
 warrior.health()&gt;=_health will be always evaluated to false since the `_health` variable has a value of undefined (it doesn't throw a ReferenceError because it is [hoisted](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting)) - therefore it will never run into the .rest() part. Store the health in a class member variable (this._health for example) and compare it to the warrior.health() value.
I know most people have a different belief system but I have to say it anyway. Several years ago, I tried to switch to CoffeeScript and then a bit after that to ToffeeScript. I was only able to keep that up for maybe a year/year-and-a-half because I got tired of arguing with people about how much better it was and that we should use it. Now here is what it seems like to me happened. The guy who invented JS saw CoffeeScript and since he is smart he had to admit it was awesome. So he started slowly adding things from CS into JS. He also saw IcedCoffeeScript etc. and realized it was great too, and now that stuff is there. And now everyone is happily transpiling away with babel etc. whereas before they would shun you for using CoffeeScript or god forbid ToffeeScript. I am dealing today with ES6/Next/2015/whatever and I am sorry but I have to say it -- this is just a shitty version of CoffeeScript/Iced CoffeeScript, and the only reason you guys couldn't get the same but better features two or three years ago was that it wasn't a 'standard'. What standard?? Pick any four groups of JavaScript developers today, they all have their own belief system around whether to use ES6, ES7/whatever, promises, co/mz and generators, async/await, a different type of promises, or plain callbacks. Eventuallly the standards people will probably end up with something like ToffeeScript. These problems were solved years ago. We are just waiting for society to catch up. Its like a microcosm of our world. A few smart people and many dumb people who wait for either some authority to tell them the new way or wait until their friends change, but overall with absolutely no judgement of their own. So what did we end up with? Pretty much had to have some geniuses put together a tool that can handle whatever you zealouts throw at it. And I know this will just be buried because the truth hurts.
Is it wrong to praise the good work of others? Work that we benefit from in tangible ways, work that is given to us for free, with absolutely zero strings attached? I call Sebastian "dedicated" [because he absolutely is](https://github.com/sebmck) - notice the level of activity, starting in October. That's when he first started working on Babel. What he has achieved in the last 8 months is nothing short of remarkable. The same can be said of [Denis](https://github.com/zloirock) (notice the activity starting in December? That's when Babel started using core-js) and [Ingvar](https://github.com/rreverser). These people *are* talented and they *are* dedicated and they *do* work tirelessly. The core-js polyfills are *excellent* because they provide the greatest level of ES6/7 [compatibility](http://kangax.github.io/compat-table/es6/) compared to the [alternatives](https://www.google.co.uk/search?q=es6+polyfill). Regarding the async example, I wanted to show what people would generally write using those techniques (sans libraries), but you have a fair point about parallelism, so here's the async "parallel" version - https://gist.github.com/RReverser/0a0263ec5abc5db03e05 As you can see, it's not really any longer, and the body is short and clear enough to not require comments, whereas the callback version is a pain to follow. The suggestion that I was paid to write it is utterly laughable. Babel is *just that good*.
Sure, maybe that's nice, but wouldn't you like it to be optional, like it used to be?
It was awesome seeing Gulp's plugin ecosystem flourish last year. Hopefully we see something similar with Babel.
Would you try to hammer in screws because you don't like screwdrivers? That aside, something like Babel (an ES6 compiler) allows you to write 'classes' and compile the code down to standard JS. If that's too much you could always use something like mootools to achieve class-like behaviour in JS.
I appreciate the response, but you don't help the specific use case that I'm interested in. :/
Someone needs to start using moment library
&gt; oh yeah, doesn't run in parallel any more That is exactly my problem with it: &gt;&gt;It's so much more succinct and simple to follow that it's obvious that this will become *the* way to write asynchronous JavaScript except it isn't asynchronous Javascript any more. It might be asynchronous to the main program, but all code in the whole routine is just sequentialized. Imagine a routine that fetches search results from several search engines. A parallel routine would query all search engines in parallel, and return only after all of them finished (or after a timeout, if one of them takes too long, if that's what you prefer). But with async/await, you'd just query every search engine one after another, and wait for it to finish before continuing to the next one. "*The* way"? Definitely not. 
Nope, moment has some nice helper functions but actually doesn't modify the behaviour of the 0000 year in native JavaScript: &gt; moment(new Date('0000-01-01')) { _isAMomentObject: true, _i: Sat Jan 01 0 01:00:00 GMT+0100 (CET), _isUTC: false, _locale: { _ordinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: [Function], _abbr: 'en', _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ }, _d: Sat Jan 01 0 01:00:00 GMT+0100 (CET) }
Much better. But.. a mixed word character and symbol keyword, "wait*"? That really irks me.
Eh. In 10 years, what do you imagine being the need for a) ToffeeScript/ICS/etc, that most likely still needs transpilers and b) ES6, supported by everyone and their dog? In the end, that *is* the major point of ES6 - it will be future-proof due to the nature of standards. &gt; Eventuallly the standards people will probably end up with something like ToffeeScript. These problems were solved years ago. We are just waiting for society to catch up. Probably, yes, something like ToffeeScript. However, *not* ToffeeScript, but something with similar featureset. Other features of ToffeeScript will fall by the wayside and no one will be sad since new ways of doing stuff will be better. Those problems - although I'm not even sure what problems you're talking about - were solved way before ToffeeScript too. It's not the be-all end-all of programming languages, as much as you might happen to like it. Not to mention the fact that the project doesn't seem to be even that active nor is it at all up to date on pulling from coffeescript (basically the project seems to have been switched into minimal maintenance mode around June **2013**, as far as I can tell), so it doesn't seem like that great of a solution to any actual production work. That's not to say ToffeeScript is useless - we *need* experience in those new ideas and new ways of doing stuff, taken by fearless explorers who *can* try stuff out without thinking of the boring stuff like long term support or trying to find compromise on style issues. They have full control to try new stuff as they are not held down by committees etc. This is very important for figuring out what's good and what's bad before learning from those experiences and making a better **JS** for everyone. But to suggest we should just pick one dudes idea of what JavaScript should be like and force it on everyone is just crazy talk.
I'd really like to know how much of the money will be used to fund developers to code nice stuff.
The only thing that isn't correct is that Babel isn't particularly *fast*. But that's acceptable, in my opinion. Hard work is being done to optimize compile times. Everything else is pretty much exactly rightBabel is a very good product across the board.
Are you sure about this? Testing using this jsperf I made It looks significantly slower http://jsperf.com/switch-vs-if-vs-ternary/2
Thanks a lot!! This gave me some good ideas and directions!!
&gt; Now here is what it seems like to me happened. The guy who invented JS saw CoffeeScript and since he is smart he had to admit it was awesome. So he started slowly adding things from CS into JS. He also saw IcedCoffeeScript etc. and realized it was great too, and now that stuff is there. Yea, that's not how that stuff happened. Brandan Eich doesn't randomly add things to the language. He actually isn't in the position to do that. No one is. Since ECMAScript became a standard, new iterations are created by a group of people. New features are proposed, they are [discussed](https://esdiscuss.org/), and only if there is enough interest they may eventually end up in the standard. You too can propose new features. By the way, I'm not sure if CoffeeScript (etc) actually introduced anything new. C# had fat arrows before CS existed. Async/await is also something C# had since ages.
Yeah, this was so coolI loved to do that! Basically these chromeles windows were browser windows that were toggled into fullscreen/presentation mode via JS (thus had no tool- nor statusbar or the like). Then you would resize the window via JS. Voil, there you have your chromeless window. I once made a site, that you could "minimise". The site would sit in the bottom right corner in a small chromeless window. It showed a sleeping figure (a bit like Microsoft Office's Clippy). Once clicked it resized back to normal.
D3's pretty useful even if you don't use selections though, you can still use all of the utility functions for calculating stuff. Like [this guy](https://github.com/esbullington/react-d3/) has made a bunch of charts with SVG React components and using D3 at the same time.
Unfortunately it appears my library is incompatible with using these tools, v8 does not ship with a native web worker implementation and since my library relies on workers to multithread your logic the tools simply refuse to run. Aside from my libraries reliance on navigator and window without worker threads i can't really test against it like that. 
Fair enough, your experience is from a year ago and I fully believe a few plugins may have had bugs. My experience is from the last 2 years, up to today, using Gulp exclusively. I haven't run into any problems. I have zipped, gzipped, deployed to S3, deployed to EBS, compiled scss, jade, ES6, minified, uglified, optimized images, linted, tested, and anything else you can think of with no issues. Used it for fully static SPAs and Express based NodeJS apps. Also as a bonus gulp/grunt plugins tend to be fairly basic wrappers around other node libraries, so modifying them or writing your own is straightforward.
What I've seen is that Typescript is limited by the pace of adoption of ECMAScript features. I'd love to be using it now to write ES6 code, but lack of true support for a lot of the great new features leaves me waiting for a real release.
You had been downvoted for saying "I like seeing what my friends are listening to." I found it amusing. Apparently, other people did not.
Types are an extremely helpful tool for code maintanence. It is very easy to build something without types, but much harder to maintain it without. They have many other benefits, but this alone makes them worth it. Please explore other types systems than Java, C++, C# etc. Typed programming can be extremely ellegant and flexible.
Just for reference: In MySQL, 0000-00-00 is the standard non-null null value for dates (eg, no date set on a date/datetime column that doesn't support nulls). So basically the exact opposite of Postgres.
That's uh... dramatic. I agree that people are too quick to praise ES6 without realizing basically everything good in it comes from coffeescript (which itself takes from other languages), but it's not like there's a bunch of sheeple who are only going to do what Eich says. Lot of people just don't like the direction coffeescript and family goes towards.
Currently, TypeScript do supports packaging modules in two formats after compiling: commonjs or AMD. You have two options for using those compiled files in the browser: 1. to include a module loader such as RequireJS or SystemJS, or 2. use a bundling tool such as Browserify (my recommended one right now). Now, you can repackage the .js files (resulting from the compilation of .ts files) in such a way the browser can read it; for this, you can use Gulp or Grunt. For example, this is a task in Gulp that does it: var browserify = require('browserify'); var source = require('vinyl-source-stream'); ... gulp.task('script', function () { // main.js is the entry point of the app return browserify('src/client/main.js', {debug: true}) .bundle() .pipe(source('client-bundle.js')) .pipe(gulp.dest('public/js')); }); Reference: https://github.com/Microsoft/TypeScript/issues/2743
I don't make it very clear, but I'm assuming `doSomething()` and `doSomething()` else are asynchronous promise-returning functions, e.g. a PouchDB method, a `fetch()` request, etc. In which case they are effectively concurrent.
Your jsPerf shows switch being faster on FF, Safari, and bleeding edge chrome and roughly equal for everything else. In addition, the switch statement is much easier to read. You also don't need the 'break' statements because 'return' automatically breaks (making it shorter and even easier to read).
To be fair, the ISO date format allows for a year zero (equivalent to 1 BCE): [Wikipedia](http://en.wikipedia.org/wiki/0_%28year%29#ISO_8601) So one could argue that PostgreSQL's parsing is actually the one in error, especially if it treats `-0001-01-01T00:00:00.000Z` as 1 BCE rather than 2 BCE -- although I'm more inclined to believe the error is in the SQL standard itself in that case. However it should also be noted that the `Date` constructor requires negative years to have six digits rather than four and doesn't recognize positive six digit years lower than the year 100 CE -- I guess it strips the leading zeros off when parsing ISO date time strings and recognizes one and two digit years as relative to 1900/2000. That one's a real surprise. In any case this is more of a quirk of how dates and times work, than something JS-specific.
Of course I know it isn't just Eich. I don't think C# was the most direct influence. I had a .NET/C# career many years ago so I am aware C# has things.
as long as it isn't microsoft I'd be ok with that.
Seems unusual. For what it's worth, using Lodash's `map` fixes the issue, and is a lot faster. Will ponder this - I'm sure it's something obvious.
thank you very much
Not sure if you posted this message from the 1990s or the early 2000s.
At least he didn't call it Micro$oft
That's correct, I am assigning the original to created array figuring that it's just another array.
1983\. He just really doesn't like BASIC.
nice work
You can't include typescript directly in html. No browsers understand how to deal with typescript directly. What is being asked here, (if of course I understand the op's question) is whether there is an in browser transform script to transform typescript to javascript. To use an analogy from Reactjs, you can't include jsx files directly in the browser, since the browser doesn't understand jsx syntax. But react has a jsx transform script that you can use to transform linked jsx files on the fly, before they are interpreted by the browser.
To be honest, if he wanted to find a job, he easily could.
Truth, but JSPM is really awesome and I'd hate to see its dev stopped because he has to get an unrelated job to pay the bills. Edit: Teh Speeling
Sounds like webpack is including your dependencies into the bundle. This is done so you don't have to also attach them to the index.html page, and it will resolve the dependencies in a practical manner (i.e. ordered correctly). The point of webpack is to bundle **everything**. The single file is likely faster than multiple source files in your html page, but then again it's less cache-able... If you don't want Webpack to do this, add an `externals` section to your config that lists how you require the external modules (like react or angular), and how it's available as a global property on the window. externals: { 'angular': 'angular', 'jquery': '$' }, Key is require name, value is window name. So: import angular = require('angular'); // grabs window.angular import jquery = require('jquery'); // grabs window.$ See: http://webpack.github.io/docs/configuration.html#externals *unless your code is just 1MB in size...*
Not really. You can't really be a full-time open source contributor and have enough time for a job. Or if you get an employer who decides to support a particular popular project you work on, then you're stuck in maintenance mode forever and you can't really do anything else. At any rate, the people with the money have the final say.
okay so its probably working as intended. Even a fresh project with just react and a simple hello world component comes out to like 700kb, so It just seemed alarming. 
Everything you said doesn't go against my original comment. He, out of his own choice, chose to devote his time to open source projects. It's not like he is unable to find a job, which is what I was trying to say. 
For your production build, dont forget to put node_env to production so react is getting a lot smaller + use uglify ;)
Post the repo/code for it? Is it being compressed, etc..
&gt; most projects would only take a day or two to complete. You're working on the wrong projects then. I've literally never worked on an actual project that would only take a day or 2. Also, it sounds like you're bitter about your experience with work. I can say that not all jobs are like this and maybe your attitude is part of the problem, not the job.
&gt; At any rate, the people with the money have the final say. What the fuck man? You realize that many popular open source projects are actually backed by people working at companies, right? You have some serious hangups with work in general. &gt; then you're stuck in maintenance mode forever and you can't really do anything else I'm in maintenance mode and find plenty of time to work on side projects. This is not true in the slightest.
My only problem with the bulk of these "Why JSX is great" articles is they feel like Stockholm Syndrome. People seem to really like React (or any JS framework/library) and then go back later and fill in the blanks on why every piece of that framework is awesome. This can be seen in other major frameworks as well. People wrote all sorts of articles on why Angular's DI was so amazing, but it was only after they were forced into using it. Backbone enthusiasts will tell you why writing huge amounts of boilerplate is actually *better* for you than *magic*. It makes me worry that people just want to talk about how the framework they know is the best one, and not evaluate technological choices as individual parts of a greater whole. There doesn't seem to be a lot of, "React does X well and Y poorly, or Angular is great at C but could use some work in D and E". It's just, "now that I know this framework, all the decisions it makes are the right decisions". Yes, I understand that you *can* use other options when using React, but JSX is definitely the prescribed, endorsed method. 
I understand your point, but as soon as I started using JSX and the ideas discussed in the article, a lot of pains I had using other libraries and frameworks melted away. Sometimes we endorse technologies not because we're forced to use it, but because they solve real problems. That's the case with React + JSX.
I find it funny that you are getting downvoted for your views on contributing to open source projects considering the number of projects you wrote. I would guess you know what you are talking about. 
Yeah, I still often look at JSX and I'm still not convinced. Admittedly, I haven't spent any time on it yet but something like this just sounds silly: &gt;JSX is Not an HTML Template Language &gt;Though it looks like it, JSX isnt a template in the sense that Handlebars, and EJS are templates. Its not a simple token replace and `.innerHTML= foo` dump like so many other tools. &gt;Its actually a declarative syntax thats used to express the virtual DOM. JSX gets interpreted and converted to virtual DOM, which gets diffed against the real DOM. Rather than rewrite the whole DOM tree, only the differences get applied. That makes React renders fast. While not exactly wrong, I feel like this is disingenuous and sounds like a bad excuse. Sure, JSX might be a *better* HTML template language but a template language is *exactly* what it is. And it needs a compilation step, just like any other template engine. Practical event handlers, inline CSS, separation of concerns etc. are strong points of the *virtual DOM*, not JSX. And the virtual DOM works absolutely fine without JSX. You can already write directly to the virtual DOM quite well in pure JS. While this might feel weird at first, it isn't hard to get used to. Anybody who has worked extensively with D3 knows that it isn't really that big of a deal. Certainly not enough to warrant bringing in an entire compilation step, necessitating a build process. Instead, it just screams "we have to do this to make designers happy". I'm not saying that's a bad thing but let's not praise it as a healthy vegetable you should be eating either.
try https://jsperf.com/ if you want to do performance tests for smaller JS functions 
It's not about getting a job. jspm and systemjs are big projects that require the amount of dedication and time that he wouldn't have if he had a 9-5 job. If you read on in the chat transcript, he mentions that 1 day a week is what most companies are willing to allow (pay for), and that doesn't even cut it. It's sad because this is software we all use, if every company that depended on open source software contributed a tiny amount every month to the software projects that they use, this wouldn't be an issue.
It's amazing how much more elegant and concise Aurelia is. Beautiful, clean code. I really hope Aurelia gains traction and people take notice. I feel like not enough people know how good Durandal really is and underestimate it due to the public's perceived inferiority of Knockout vs Angular's databinding.
Agreed. Every time I look inside of Aurelia, I see something that has had incredible thought put into it. Angular 2.0 has a lot of thought too, but it seems to be focused on over-engineering and catering to enterprise biases rather than developer productivity. Angular just doesn't feel very innovative anymore.
Regarding your `walk` implementation, how do I tell when the traversal is completed? :) With the async/await version it will not return a value until the entire directory structure has been visited. Thanks for your feedback btw, this was my first ever blog post and it will probably take me a while before I get the "tone" right. 
Look into jspm and the typescript plugin. It should transpile on the fly 
i followed this video before https://www.youtube.com/watch?v=Ob1ruoUnc58 same results.
My guess is ToObject is there in case map is called on a string.
&gt; You realize that many popular open source projects are actually backed by people working at companies, right? You realize the guy you replied to was actually [backed by a company that uses his open source projects](https://blog.andyet.com/2013/11/27/happy-thanksgiving#3-team-sponsorship-of-substack-http-github-com-substack-browserify-http-browserify-org-), right? I'm sure the 600+ open source projects he's published take some time out his day.
&gt;[...] working a job or a contract feels like a huge waste of time because if I had the freedom to solve the given problem in my own way with my preferred techniques, most projects would only take a day or two to complete. I don't intend to come off as rude, but have you talked to your higher-ups about that? I have a hard time believing they'd brush you off for no reason. It's more likely, at least going off of only what you wrote (I'm sure there's more context), that the company privileges one standard set of techniques over others in case a client desires an additional feature or repair in the future. if the workplace is beholden to money then they *should* also be beholden to efficiency, especially in the long-term.
You'll only see a change once the control is returned to the UI thread. You can't do an animation by drawing things repeatedly in a for-loop. Use requestAnimationFrame for animations. https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
Even if you pass if the string, not the Date object? At that point it's taking the interpretation Date has produced. It might end up acting the same way, but I'm curious if moment will do some extra interpretations that Date lacks 
I can't help but feel the other comments praising Aurelia are shills/plants /u/joshburgess - redditor for 1 day How the fuck could a FRAMEWORK with ~8 tests have 2,000+ stars?! Seriously, I think the "EisenbergEffect" is really about generating artificial buzz around an extremely alpha framework. 
whoa! Thank you for the excellent answer, i really appreciate you taking the time to read and understand my question and then so clearly explain it! 
Hey All, Not sure if this is the appropriate place to share, but I am learning JavaScript and wanted to share what I built! Feel free to submit pull requests to github! Thanks. 
Straw man arguments? I haven't proposed that you made any claim that you have, in fact, not made. Your "experience" is probably what makes you not realize how wrong you really are. Are you smarter than all the engineers at Facebook?
Yes, methods like [querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll) are also defined on individual elements. Calling these functions restricts the scope to trees rooted at those elements.
You're confusing the definition of a straw man. Assuming that you haven't tried React is not the same as constructing a faux argument and attaching your name to it.
Call it a template language, call it a template engine, call it a preprocessor. Let's call a spade a spade. JSX is not valid JS. Just like TypeScript is not valid JS. They both need to be preprocessed to be run by the target runtime(/compiler) because they do not adhere to the ECMAScript specification. Saying otherwise would be like saying that PHP is valid HTML. It's the same concept. It even literally says so in the name: "PHP: Hypertext Preprocessor". Sure, you can write the JSX preprocessor in JS. You could also write it in PHP. You could even write a PHP preprocessor in JS. It does not matter. What matters is that you are not writing code that is valid for the target runtime. This matters even more in JS where you normally don't even need preprocessing or compilation steps like in other languages. It's another step added to convert templates into native JS that you could just be writing in the first place.
And I completely understand yours. JSX might have its time and I can respect the pragmatic approach. Sometimes we need to get work done and React with JSX is probably the best bet right now. I'm just saying that while JSX certainly supports these ideas that I agree with are great, I don't agree that JSX is a necessity to achieve them. :)
Do you work at Fox News?
In `functionWithSetTimeOut`, `callback` is a parameter to the function. So, when it's done with doing whatever it does (in this case, waiting 3 seconds), it can call any callback passed to it with a message.
I've been keeping an eye on the progress of both, but haven't built anything beyond a basic 'hello-world' app with either. That said, reading through the design philosophy, examples, etc of both - there is quite a bit to like about Aurelia. Also, the framework is pretty modular - with parts of it being usable outside of the main 'framework'. So sure, the framework/test on their github might seem a bit thin. But, look into the other repo's that make up the framework * [binding](https://github.com/aurelia/binding/tree/master/test) * [templating](https://github.com/aurelia/templating/tree/master/test) * [validation](https://github.com/aurelia/validation/tree/master/test) * [router](https://github.com/aurelia/router/tree/master/test) * [http-client](https://github.com/aurelia/http-client/tree/master/test) etc and there is quite a few tests - and those are just a few of the smaller libraries that make up Aurelia. For the 'next-gen' frameworks I guess - the thing that does seem rather appealing about Aurelia, is how little framework code is needed in your application code. However, a large part of the 'boilerplate' code that gets done away with in Aurelia vs Angular 2, has to do with a stronger set of conventions up front that it expects you to adhere to. If I recall correctly - Aurelia has/will have ways to configure these if you can't fit into those conventions - so kind of curious to see how much boilerplate that would end up adding. Curious to see how this framework plays out. 
How's that tin foil hat working out for you, buddy? It's not my first account... and just because someone decides to make an account and start posting doesn't necessarily mean they haven't been reading Reddit for years. Try using it. The reasons why it's generating hype should be pretty obvious: 1. Durandal was damn good for what it was. It may not have the following of Angular, but that's only because Angular was backed by a tech giant. 2. Google hired Rob Eisenberg specifically because of how good Durandal &amp; early prototypes of Aurelia were. He contributed ideas to Angular 2.0 while being paid for it, and then he quit. It's only natural that people would be curious why that is. 3. Aurelia is built around ES6/7 (the future of JavaScript), Babel (which supports React &amp; JSX, which are huge right now), jspm, SystemJS (universal module loader), etc., aka some of the best &amp; most important JS projects that exist right now. 4. The conventions &amp; syntax are extremely clean and easy to understand. It's really that simple.
&gt; I think the real point is that you shouldn't be immediately repelled by putting markup into JavaScript files And that would be fine if the article actually stopped there, but like almost all other JSX articles it feels the need to go the extra mile and convince you everything that came before JSX was *actually* wrong and JSX is right. Paraphrased from essentially every JSX article including this one (starting at *Inline Styles Are Good*) "Actually when you think about it, CSS has failed in many ways, but JSX does it *right*" "MVC actually doesn't make any sense, but JSX+React does!" Even this header directly from the article: *(The Right) Separation of Concerns* I'm not even saying all these features are bad, using JSX for some performance and programming paradigm trade-offs is a legitimate argument that will appeal to many people for the right reasons, but why do we have to go the extra step and try and convince people that *everything else is wrong*? It is apparently too much for people to say, "inline styles introduces some headaches but is worth it for the other trade-offs, therefore this technology is worthwhile". Again, none of this is limited to React/JSX, it's just the most (recently) prevalent and ongoing example.
`counter` will not be incremented until `functionWithSetTimeOut` has returned. Similarly, if you have function functionWithSetTimeOut() { setTimeout(function() {console.log("Hi!");}, 1000); } then `functionWithSetTimeOut` won't return until `setTimeout` returns. Now here's the tricky part: `setTimeout` returns immediately, *not* after one second. All it does is *set up* something to be called later; it doesn't wait. That means the counter will be incremented, and then one second later, "hi" will be logged.
&gt; The problem here is that counter++ will run before functionWithSetTimeOut() has finished. Not true (at least if "finished" means "returned"). It will, however, run before the timeout function (the anonymous one passed to `setTimeout`) has started.
There are a bunch of naming conventions which avoid collisions. I outlined this recently: http://www.reddit.com/r/web_design/comments/36hpbr/nesting_components/crebu55 Slide 9: &gt;In my experience, any attempt to style markup through selectors alone is inevitably going to fail. That's true. That's why you can just do it the other way around. You don't write CSS for some markup. You create a library of building blocks which are then used to construct every view. Slide 11: &gt;Good CSS consists of selectors that match exactly the elements you want without accidentally matching the elements you don't. All while not being overly verbose or repetitive [...] They can be verbose and repetitive. Preprocessors can take care of the manual repetition. Gzip makes it disappear when it goes over the wire. Slide 30: `/deep/` is now `&gt;&gt;&gt;` (shadow-piercing descendant combinator). This is the relevant spec, by the way: http://dev.w3.org/csswg/css-scoping/
Deploying direct from local grunt/gulp tasks sounds like a questionable idea :D
Great idea, thanks a lot!
This guy is a MACHINE. He's always on gitter, Google groups, stack overflow, and github issues for 3 major repos. He's always answered me on gitter within a matter of minutes. He is super impressive, any company would be lucky to work with him. 
Not sure what you mean. JavaScript is run by a browser so all you would need is to run it on your browser. 
This is great man! Nicely done. Things I'd like to see would be the ability to change the velocity of individual hits -- maybe just 3 different velocities, and you could cycle through them by clicking multiple times. It'd be cool to be able to share your beats, too. Also FYI if you want it to work on Safari you still have to do: `window.AudioContext = window.AudioContext || window.webkitAudioContext;`
Don't get me wrong, I'm glad there is competition, but the comparisons he is making are very biased. Which is natural, since it's his framework and since he left the angular team, but the comparisons he keeps showing are often hiding a lot of necessary [magic](https://github.com/aurelia/skeleton-navigation/blob/master/index.html#L18) going on [behind](https://github.com/aurelia/skeleton-navigation/blob/master/src/animation-main.js#L1) the scenes. If the main comparison of the two frameworks is going to be a line/word count, then it hardly seems fair to pretend there is nothing going on in the [skeleton](https://github.com/aurelia/skeleton-navigation) being used in his examples. &gt; We don't intend to constantly do these sorts of Angular comparison posts. It's not fun for us and we don't want to have a reputation for doing this all the time. I think it may be a bit late for that. Still, interested to see where Aurelia goes. Hopefully all these comparisons can be left behind so Aurelia can just stand on its own.
&gt; Not sure if this is the appropriate place to share By all means, please do! All we ask is that you include a link to the project page (your github link is perfect). Do note that reddit has site-wide rules and guidelines for submitting your own site, but generally as long as a majority of your submissions aren't your own site, you'll be fine. More details can be found in the [Posting: Advertising, Self-Promotion, and Spam](http://www.reddit.com/r/javascript/wiki/index#wiki_posting.3A_advertising.2C_self-promotion.2C_and_spam) section of our wiki.
Lots of the comments here are very...intense. For us, React worked out really well for the following reasons: 1. It was the first time that our backend developers were able to make sense of the UI. Having separate templates and view code made it (supposedly) easier on the UI people, but not on the backend folks that needed to update a component on the page. To them it was indirection, and an annoyance. It was easier to make a Sinatra app to meet an immediate need than fight against the framework they were being nudged to work in. 2. Our designers never felt comfortable in our code in the first place. They found other places to prototype and iterate, and the work we were/are doing (mostly internal tooling) didn't warrant the designers making lots of UI tweaks. In an ideal world? Yes, our designers are familiar enough with our front-end stack that they could dive in and prototype. But we have a whole slew of problems to solve that are a lot more important before we get there. 3. Many of the criticisms people have with JSX weren't really problems for us. For example, we were already using a build pipeline, so adding another step to compile down the JSX wasn't a big deal. It's not really worth it for me to go about trying to convince people that there is a "one true way" or a "correct way" with all of this Javascript stuff. Ember works fine for people. As does Angular. We chose React, we like it, we mess some stuff up, we do some things really well, and in a few years, we're gonna chuck our code into the ocean and start anew. That's the cycle of all this. There aren't many absolutes; only relatives. And if you started at my office tomorrow, laid a convincing argument for us to use Mercury and the raw virtual-dom library and could get our devs on-board, then we'd switch in a heartbeat. BUT AGAIN: This was only for us. Your mileage may vary. 
&gt; MVC actually doesn't make any sense Oh web developers. Never can we learn from non-web platforms. MVC makes perfect sense.
I just think it's so easy to do CI these days, that makes more sense, using Grunt only for local tasks (local to any particular environment) but not as your deployment orchestrator or executor. Maybe it's subjective, but I'd say there are better tools for deployment.
Please elaborate on this. Nobody I know puts business logic in their React components. I assume you mean putting view logic in the view? Edit: I recommend that you watch Pete Hunt's talk on the matter: https://www.youtube.com/watch?v=x7cQ3mrcKaY and have an open mind. I had similar concerns as you when React was first released. It may not click unless you've worked on a complicated front-end project, but at least have an open mind.
I have no problem with companies making money. It's when they derail innovation with their ineptitude that makes me want to watch them burn in flames. It's like my grandpa says "I will never buy a Japanese car. They tried to kill me".
This is silly. For fucks sake, learn how to use the tools that already exist. Not everything needs to be replaced with JavaScript. Awk, for one, already has a full scripting language. Sed as well. All three are already available on the majority of *nix systems too! &gt; Only output lines that begin with the word var: `nip 'function(l) { return /^var/.test(l); }' lines-that-start-with-var.txt` `grep ^var lines-that-start-with-var.txt` &gt; Output every second line only in uppercase in a file: `nip 'function(line, i) { return i % 2 ? line.toUpperCase() : false; }' every-2nd-line.txt` `awk 'NR%2' every-2nd-line.txt | tr '[:lower:]' '[:upper:]'` (Learn `tr`. It's incredibly useful.) or `awk 'NR%2 {print toupper($0)}' every-2nd-line.txt` &gt; Trim whitesplace from a file: `nip 'return line.replace(/^s*|s*$/g, "");' trim-lines.txt` `sed 's/\s//g' trim-lines.txt` To actually "trim whitespace from a file" and not just every line ... (also I don't understand the example regex, which doesn't do what it says it's supposed to do) ` tr '\n' ' ' &lt; trim-lines.txt | sed 's/\s//g'` &gt; Why &gt; This is for people who aren't "devops" and who can't crank out a fancy piped shell script using awk and sed. But they are JavaScript developers and they are responsible for something on that needs to be done on the command line? I'd also argue that the nasty one-liners above for `nip` are more difficult for a human to parse than the equivalent awk/sed/grep tools. &gt; Also most programmers who have node installed can write a quick javascript one+ liner to do what the oldschoolers would make a shell script out of. Oldschoolers. Please. I'm 27. It's not hard to learn about these tools. People here tout "use the best tool for the job," so actually do it, and add some new tools to your toolbelt.
One of the reasons why these frameworks are getting adopted by larger companies for projects though, is because they have a name brand behind them. When trying to make a pitch to a higher-up of "Why to use X' framework over Y" - for better or worse, being able to say that it's being worked on by FaceBook/Google/etc can play a large factor into getting their buy-in. There is also a perceived less-risk of the framework getting dropped &lt;&lt;insert counter-argument about all the things Google has dropped support for here&gt;&gt;, and getting continued support if there is a larger company behind it. The rate that JS frameworks come out right now is staggering - and so many of them are a flash in the pan, that have a nice looking landing page - but fail to get community support behind them, and stagnate and seem to go obsolete as fast as they are getting released. When companies are looking for a long-term investment for their next big project, long term support is an important factor. This is also why so many people are a bit uneasy about Angular 2.0, since it is such a drastic change from 1.0, not backwards compatible and a very unclear migration path. There is a bit of healthy competition going on right now with some of the larger frameworks - and you see some ideas propagating through all of them, even if being handled differently. The downside I see though - is that it will become even harder for smaller frameworks that are good to break through the noise. Even if LittleGuy.JS is an amazingly performant, well written, solves all of the same problems and even better - but is being maintained by 1 guy, it will be hard to get a community built around it as many people will be skeptical of "well, what if he stops supporting it? how can I trust this 1 guy over the N number of googlers working on Angular? or FaceBook? what is this guys cred that makes it worth the risk? are the benefits of X not worth not getting the community behind the others?" 
Wow - I haven't even begun to get into ES7. Using Angular + Ionic for a mobile app and it's been great, mostly. They have a great team + community. Like you said it's growing fast. 
WebPack has a feature that helps with creating sub-packages or modular packages. It is helpful since it can bring many files together and it's easier to run UgilfyJS on them for minifying. If you can spend some time learning about how to use WebPack in your project it could help to give you some confidence. One of the features that WebPack offers is some interactivity so that you don't necessarily have to lose your edit-reload-test cycle. Either way, it's good to play with WebPack on the side until you're read to jump into it.
Sorry for the delayed response. So agree that there aren't any headlining features specifically geared for app developers, but one feature that I didn't see in your list that you might want to consider looking into is Query Store: https://channel9.msdn.com/Shows/Data-Exposed/Query-Store-in-SQL-Server-2016 It sounds DBAish, but I think it could have significant impact on performance tuning and optimization app side. 
Can we get a sidebar link?
Please actually [look a person up](https://github.com/substack?tab=repositories) before deciding they're clueless merely because you disagree with them.
For me it doesn't matter much, as long as its an open source license that's compatible with OSS. The ones I stay away from are the dual licenses where they try to suck you in with some MIT freebies and then lock you down with their proprietary-pay-as-you-go licensing for all the features. Angular fiasco is not the typical case. For front-end frameworks I can't recall as much of a hub-hub as that one. The fact that they completely threw away 1.x and rewrote 2.x is complacent with semver, but in the spirit of a framework, they may as well have just called it something else so not to confuse people.
Why not? Honestly.
Oh god that's hilarious
I know for a fact, that he has been getting paid :-)
&gt; Software isn't religion. There isn't anything to have an open mind about. Rejecting an idea outright because it conflicts with your view of the world seems pretty religious to me. &gt; What I will do is wait until React or JSX have proven themselves to be viable technologies or they fade from memory. That's not a bad idea. But I don't see why you feel the need to troll this thread if you haven't done your research or even tried the tool in question.
Haha, I misread your reply. Sorry! :)
I agree. Very responsive. I assumed these projects were his 9-5.
Nice work, man! Where did you get the samples by the way?
Yes, I agree. It may, however, be too much for doing, say, a snake chart.
I find javascript unbelievably awesome It turns your 1980 style website into something amazing.
Hell it would even be allright if companies at least adopted jspm and it's dependency workflow faster.
Check out www.w3schools.com
My pain point is debugging. I come from the PHP world and there you can easily debug errors. It feels like that js often throws an error at a different point then where the console points me to.. Yes, I am aware this is a fault in my own knowledge - I should read up on more js debugging techniques. Any good tips?
As far as i get what you need is to try run your code online right ? There are a lot of webpages that give you this functionality. l'll share my personal favorite: http://codepen.io
This is exactly what I was looking for! Even has CSS and HTML! 
Famous developers are never wrong?
Thanks for the reply, I completely share your pain. Debugging in JS has improved a lot lately, so the trick is to leverage new tools and never stop learning. For example, knowing the in &amp; out of the Chrome Dev tool is a must! https://developer.chrome.com/devtools/docs/javascript-debugging btw, async JS debugging is still hard!
Cool! Go ahead get your job done :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Grid illusion**](https://en.wikipedia.org/wiki/Grid%20illusion): [](#sfw) --- &gt; &gt;A __grid illusion__ is any kind of [grid](https://en.wikipedia.org/wiki/Grid_(spatial_index\)) that deceives a person's vision. The two most common types of grid illusions are the __Hermann grid illusion__ and the __scintillating grid illusion__. &gt;==== &gt;[**Image**](https://i.imgur.com/ciwH81l.gif) [^(i)](https://commons.wikimedia.org/wiki/File:HermannGrid.gif) - *An example of the Hermann grid illusion. Dark blobs appear at the intersections* --- ^Interesting: [^Optical ^illusion](https://en.wikipedia.org/wiki/Optical_illusion) ^| [^Mach ^bands](https://en.wikipedia.org/wiki/Mach_bands) ^| [^List ^of ^optical ^illusions](https://en.wikipedia.org/wiki/List_of_optical_illusions) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crg4qow) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crg4qow)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Wow. Just wow. Are you 12 years old?
My day job involves writing a lot of both Scala and Javascript - the difference in defect rate for our team is at least an order of magnitude. I used to be a Python guy, but those metrics are hard to ignore. Obviously it's going to differ significantly depending on the team and project, but in our case we find static typing a major productivity boost. I think a lot of people don't like static typing because they associate it with Java. ML style type systems are a completely different beast.
How does this compare to eslint?
I'll surely research more about this, thanks! :)
quite unfortunate that you are going to get downvoted, but this really hits the nail on the head with the whole javascript community :/
&gt; So... nothing funny yet, right? If you compare a value with itself, both operators acknowledge the equality returning *true*. I'm going to be a pedant and say that this is incorrect. Both `NaN == NaN` and `NaN === NaN` return false.
I think it's just a typo, the second one should have `==`
Thanks!
well, you'll use it because of the tooling, not because of the browsing :)
I have to write front end stuff sometimes, for you - I hope you never have to edit it, I'm sure you'd feel a bit sick at the quality. =)
Would you reconsider about me posting here if I'm more pro-java, or is the lack of skills the main issue?
Very good point.
I never really thought too much about it until I read [this article](https://www.pandastrike.com/posts/20150311-react-bad-idea). I think he has some very valid concerns that we should be promoting the open web, help define the standards and work on making web browsers work the way we need them to. I also recognize that some of us need to get work done right now that might only be possible with React/Angular/whatever. It is without a doubt a great tool. But it still seems... ideologically wrong. It's like we're helping build the web equivalent of Windows - a huge monolithic platform where all components built on top of it are only compatible with this platform and nothing else. Sure, it might be faster in the beginning but in the long run, we'd be better off building up small components that do one thing well, like the Linux people do. Sure, Linux is far from competing in market share with Windows/OSX but it has a much more solid core and is working it's way up at a steady pace. Thankfully, the web is still an open place where both ideas can exist peacefully. If you don't want to be locked in by React, you have tons of other options. I don't worry too much. But I also don't feel bad about not being on the React bandwagon.
If it's a single file app try pasting it in jsfiddle.com or codepen.io otherwise you need some kind of hosting yes. 
Lack of static typing - solved with Typescript. Lack of proper modularization - (not JS per se, but still...) rjs/commons, but will have to wait for shadow dom tree adoption.
That we are currently going through the infancy of package managing and build systems for JS. I love that we are going in that direction but it sure is a mess. We will succeed eventually though. The language itself, while not pretty, is quite awesome - especially since you can now run the full stack in JS and many of the performance problems have been taken care of. I have hands-on experience with Delphi, Assembler, Java, Basic, Visual Basic, PHP, C, C++, C#, Processing, Arduino, VVVV, Max/MSP and probably some more I've forgotten about. I know they don't solve the same problems but for my hobby projects, I always come back to JS. The ROI is nowadays insane compared to most other languages and it doesn't tell me what to do and how to do it. It's just so much fun.
&gt; But if we try with 4 == '4', the nicer but much more dangerous == sees the different types, and then asks itself: "what if I convert both operands to strings? How that would be?" So then it tries something like (4).toString() == ('4').toString() which is, as you can imagine, true. That's incorrect. When comparing a number with a string with the == operator, the string is converted to a number, not the other way around.
The transition looks nice, but I feel it'd be too jarring to use on anything other than a portfolio site. It's an unexpected change to the page, rather than a UI enhancement, which is the key difference.
2\*2+5 is entered 2\*2+**2**5 appears 27 (instead of 29) is calculated By the way, you can simplify the event handling quite a bit: http://jsfiddle.net/020xv9nu/ You might be interested in this talk: https://www.youtube.com/watch?v=4F72VULWFvc&amp;list=PLED6CA927B41FF5BD
I stopped understanding it at: ['la', 'unch'] === 'la,unch'; // false, different types ['la', 'unch'] === 'la,unch'; // true
This is obviously a typo. The second line should be: ['la', 'unch'] == 'la,unch'; // true
&gt; The second piece of code is presented as equivalent, but cuts out all the comments, cuts out newlines, cuts out the done callback, cuts out all the error handling, cuts out the abort-on-any-error feature, and, oh yeah, doesn't run in parallel any more The only thing that's right here is that it doesn't run in parallel, though it could trivially be modified to run in parallel (see end of comment). Otherwise they are equivalent as far as I can see. &gt; cuts out all the comments Those comments are useless, except maybe the one at the top of function but even that can be replaced by naming the function more descriptively. &gt; cuts out newlines The new code has standard usage of whitespace, I don't see how adding more newlines there would add any value. &gt; cuts out the done callback async function implicitly returns a promise, so that plumbing is not necessary &gt; cuts out all the error handling There is no error handling whatsoever in the callback example. What the callback example has is error *propagation*. With callbacks you have to manually propagate errors (this is **not** error *handling*). Exceptions propagate automatically, so that plumbing is not necessary when using async await (or plain promises or any reasonable callback abstraction for that matter). &gt; cuts out the abort-on-any-error feature This is already implicit because there is no catch blocks. #### As for running it in parallel instead sequentially: async function walk (dir, visitor) { const filenames = await fs.readdirAsync(dir); await Promise.all(filenames.map(async function(filename) { const fullpath = path.join(dir, filename); const stat = await fs.statAsync(fullpath); if (stat &amp;&amp; stat.isDirectory()) { await walk(fullpath, visitor); } else { visitor(fullpath, stat); } })); } I give you that it is unfortunate that even users who should know better always make everything unnecessarily sequential when using async await or generators. 
C'mon now. You're telling me chrome didn't push the curve compared to IE? Microsoft dragged their feet for years. Nearly a decade. They had actually stopped development on it at one point.
Also I am not sure if that's even a real thing even, but you should be able to replace `await* ...` with `await Promise.all(...)`
&gt; I give you that it is unfortunate that even users who should know better always make everything unnecessarily sequential when using async await or generators. You're absolutely right, sorry! Updated the example to use `await *` (thanks to /u/rreverser)
http://gyazo.com/d82437259bc446082e2a578c028ab99f i just wanted 5 billion times 3 bazillion and this is what i got
The title itself is misleading. I clicked thinking 'Alright, what's wrong with the triple equals now??' This is a warning about the double equals, not triple.
A real comparison can't be done since they have a different purpose, just like /u/menno said.
&gt; Promises swallows errors by default! Well no, what happens is dependent on the platform. For instance in Chrome unhandled rejections throw an error. Firefox does the same but when the promise is GC'd (which is not very good but better than nothing I guess) In io.js (or node when they merge), you can do process.on("unhandledRejection", function(e){throw e;}); But the promises spec itself doesn't require it.
In io.js you still need to: process.on("unhandledRejection", function(e){throw e;}); The default is still to swallow it. There is a bike shed issue about it but I guarantee you that consensus will never be reached and nothing will ever happen. 
I hate for loops over arrays too, for ES3 I usually use a while loop: var item; var arr = [1, 2, 3]; var iter = [].concat(arr).reverse(); while( item = iter.pop()) { console.log(item); } You can get rid of the iter var if you don't mind the array getting destroyed, and you don't have to reverse if you don't mind looping backwards though the array.
Cool. BTW you should use the proper multiply/divide symbols:  
I am ought to write a &gt;= IE9 , mobile and node.js compatabile code. What would you suggest??
&gt; For you, what package managing system is mature, can you give an example? In JS? My best bet would be NPM, perhaps with Browserify. I know it might not have all the bells and whistles of some of the others but I think we need to lock down on something stable that is easy to manage, has as little configuration as absolutely possible and a very high level of modularity. The Linux people are really, really good at this and I think NPM is the one that most closely resembles that. I'm certainly no expert so correct me if wrong. Most other languages/platforms are able to keep it down to 2 or at most 3 mature, de facto package managers. Linux has many different but almost all of them keep to generic .deb and .rpm formats (and pacman is gaining traction). PHP has PEAR and composer. Ruby has Gems. Python has Pip. OSX has homebrew. JS is a mess, since we are currently juggling with NPM, JSPM, Webpack, Bower, Jam, Duo, Ender, Atmoshpere(meteor) and probably even more. Some of them package managers, some of them build systems, some of them both, some of them only for front end, some of them only for backend, some of them for both, some of them relying and integrating with each other and so on. At some point we will probably settle on a couple of them but until then, this is probably just something we have to go through.
When we started the project typescript was an early alpha and not ready for prime time, but we did seriously evaluate it. Chances are we'll eventually end up switching to something like Purescript or Scalajs - typescript is good for what it is, but pretty limiting compared to some of the newer options. 
TypeScript is ES6 plus optional static typing, at least that is the idea. So if you use it then you have both. The TypeScript compiler which is almost at version 1.5 supports most of ES6. (1.5 is a big release and I can't recall what is missing. Generator support maybe.) The TypeScript compiler can output ES5 code which should run fine in all of your platforms. It's a huge upgrade to good ol' JavaScript. Using Babel for ES6 support only is also a big step up. 
I have **zero** problems with plain vanilla ES5.1.
Interesting. So you are for engineers having to work full-time for no or very little money? There is another post in this subreddit coming at this from an opposite angle from you: http://www.reddit.com/r/javascript/comments/36mn9q/til_guy_bedford_creator_of_jspm_systemjs_es6/ I'm not sure that lack of sponsorship is really a good thing for opensource. How will the best in industry afford themselves the time and money to keep it all together?
Though that is the only case where that is true, isn't it?
Well said James. 97% agree with you (except for the two days part, that is just bullshit and not applicable to any moderately complex or well designed project).
You don't need to do any http requests to get jquery loaded into your project. Just download it and include the proper (minified) scripts and stylesheets. Jquery is extremely powerful, and its AJAX wrapper is invaluable in writing clean, coherent JS. 
I don't see the pitfall here - both type conversions are totally fine
It's doesn't exist in ES3 and up until recently I've had to support IE8. Happily we don't have to now and most of the codebase has been refactored to use map or forEach, good times!
The TypeScript compiler can output modules as commonjs, AMD or ES6 depending on what you want. You can select ES5 as the compilation target and then your code will run almost anywhere which support javascript. You do need a compile step in your build process. Runtime cost is negligible. 
Complaining about IE is the hallmark of an amateurish programmer opinion. You know IE was innovative in it's days, and you also know that IE did not want to be like chrome, it tried to implement a whole new UI strategy, which failed (something something something activeX). Their goal was pretty obvious, people just chose differently. 
I already do that (and encourage everyone to do it), however, it feels like charity and it would feel better if our employers (or ourselves if we're self employed) thought of open source software in a more sustainable way: it's an ecosystem, a culture, and just the same way we pay taxes to have roads built, we should contribute to the community (money or code) to have our roads built. If software is our infrastructure, it makes sense that we spend 20% (or more) of our time contributing to keeping it functioning. Not necessarily money, but also time. I work developing software and we use Github a lot. In our issue tracker, never once has there been a ticket saying "try to fix this bug in this library because it affects us". It annoys me to se fellow employees saying things like "there was a bug in this or that library so I've filed an issue on github" like there, job done, let someone else do it. For free, and we'll take the profits. And if they don't fix it on time, complain on twitter saying the project is not "actively developed" or some other stupid quote like that. Anyway, this rant isn't directed to you though, it just gets on my nerves heh :) (sorry!)
I did this calculator nearby 20 years ago for some student js course, is still a good excercise: http://codepen.io/Yudo/pen/BNLxpx
Not if you concatenate it with your other code, then minify it. Potentially unused methods will be removed as well, so it's not a large problem.
This. Whilst I have great respect, admiration and gratitude for prolific open source contributors/maintainers and the work they do, it is a choice that they have freely made to become "full-time open source contributor[s]". And indeed if there were some system by which I could easily provide regular (albeit modest) financial support and sponsorship for non-commercially-backed OSS projects in return for the value they provide to me personally, then I probably would. However, I'm never going to have any pity for people who are some of the most employable in the world saying "I'm poor because I don't like to work for other people".
I have a warm place in my heart for haskell, shen, and ocaml, but I don't think that's the whole story. Javascript code is primarily async, cross-platform UI code. While static typing helps to some extent (check out Facebook's flow which seems to be moving in a more Hinley-Milner direction than TypeScript), most JS bugs are caused because there are so many moving parts track through the state machine (in fact, most bugs I see are due to complexity rather than someone passing a number instead of an object). If you look closer at ML-ish, functional languages, I think you'd find two factors besides typing that are important. The first factor is that only the top couple percent of programmers tend to learn these languages. These people would have lower bug rates in any language they picked. As programmers, we frequently see people claiming X is so much better and everyone using it has been successful, but when the average programmer starts using it, then it turns out no better than the thing it replaced. The second factor is functional style. If you look at JavaScript programmers, you will usually see beginners, object users, functional guys, and at the top-end, someone who constructs objects and then composes them with functions. The reason for this is that functions compose and encapsulate in a way that other programming methods do not. Because of the strong encapsulation, it is easier for programmers to focus on small parts of the code that fit in human memory (the biggest factor in reducing bugs). These can then be abstracted away behind another layer of composition and so on. I like the idea of types (an optionally statically typed scheme on the client anyone?), but I believe it's not the silver bullet our hype train believes it to be. Static types in an enormous state machine is still going to give you bugs. Overall, I think teaching JS developers to use a functional style is going to have much better results.
Minifying doesn't remove unused code.
&gt; If you've ever copied text from a news article and pasted to a friend only to find an intrusive ad baked in, you've experienced it first hand. This was possible on Chrome even before the recent changes to the clipboard API. The trick is to move or modify the user's selection when you see a Ctrl+C keyboard down event on the page. Then it is possible for the user to select something on the page, hit Ctrl+C and get something totally different on the clipboard. The danger that the Chrome change introduces is web pages which spy on the clipboard or modify it without being ask to do so. But there is something about the clipboard API being only usable in reaction to "a user gesture". I'm not sure what that means exactly. I guess you can only read/write the clipboard during the handling of some UI related events (??). 
All the good things in ES5.1 have polyfills for ES3. Here's the one for [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fmap#Polyfill) Here's a [polyfill library](https://github.com/es-shims/es5-shim) to keep them all together.
It does if you use the correct tools. https://github.com/mishoo/UglifyJS2#compressor-options will if you pass -c with various arguments, `unused` and `dead_code`. It's worth noting that jQuery itself uses Uglify for their minification.
It matters what you're building. Including "just because" is a horrible reason - more so saying it will make you "more efficient" - you include it when it makes sense, if you aren't using Ajax or the cross browser capabilities, then it doesn't make sense to include a JavaScript library with thousands of lines of code for something that could be done in vanilla Java script in several lines of code. Much like different projects will use different libraries, sometimes "no library" is the best choice. 
I believe closure compiler can actually do tree shaking.
It does not remove unused code, only unreachable code.
The way I read that first part it made it sound like it previously wasn't a problem on Chrome. IE has allowed it since forever, IIRC. 
Nice but seriously missing scrollbar anchors, which makes it a touch-device only solution.
My understanding is that `unused` removes unused code. `dead_code` removes unreachable code.
It's not to anyone who recognizes the mistake, but it could be confusing to someone who's new to JS. This is good information for a CSS subreddit though.
Nope definitely a problem with Chrome and it's possible to hijack with Flash as well which is available everywhere.
&gt; most JS bugs are caused because there are so many moving parts track through the state machine I agree - this is really the fundamental issue with OO and Imperative code in general. Lots and lots and lots of little pieces of mutable state all floating around in a giant machine full of moving parts. Even without static typing, moving towards immutability and basic functional composition makes a dramatic difference - Clojure is a great example of this in action, and Javascript written in a functional style can work reasonably well if you squint. That being said, I really do think that's only half the puzzle. A good static type system helps both in reducing cognitive load (Since you don't have to keep as much in your head), as well as enforce invariants that you might otherwise cheat with. And of course some languages such as Haskell use the type system to enforce purity, such that you simply can't really build big complex balls of mutable mud without actively fighting the language. &gt; The first factor is that only the top couple percent of programmers tend to learn these languages. These people would have lower bug rates in any language they picked. That's true, although the majority of my team had a background as Java and Javascript developers, and have learned FP on the job purely by be throwing them in the deep end. The same team works on both the Scala and JS codebases at the same time (Often in the same pull request), most of the team are more experienced with JS than they are at Scala, and we write our Javascript primarily in a functional style. Despite this, it's extremely rare to even see a Scala runtime error hit our Raygun logs, whereas our Javascript codebase is a neverending stream of things that a good type system would pick up. We basically dedicate one-two days a week as "Javascript bug day" and play a constant game of whackamole, whereas we really only touch the Scala code when it's time for a major refactor or new feature. &gt; I like the idea of types (an optionally statically typed scheme on the client anyone?), but I believe it's not the silver bullet our hype train believes it to be. Static types in an enormous state machine is still going to give you bugs. Overall, I think teaching JS developers to use a functional style is going to have much better results. I absolutely agree. There's no silver bullets, but functional style in a dynamic language is going to be more effective than imperative style in a statically typed language. But functional style with an ML style type system is even better.
Don't feel bad about not wanting jQuery. Not being caught up in the concepts of jQuery will probably make it easier for you to learn something like React, Angular etc. Manual DOM manipulation is not really something we do a lot anymore. After those frameworks have emerged, a lot of us don't even use jQuery at all anymore. jQuery was nice when it was invented and has solved a lot of problems since. It deserves tons of credit. But the problems it set out to solve, mainly cross-browser compatibility, simply aren't that much of a problem anymore. And a lot of the newer frameworks simply circumvent those problems anyway, for instance with a virtual DOM.
good to know, thanks!
It can also work with a scrollbar. In this demo the scrollbars are replaced with the Intence indicator: http://asvd.github.io/intence/
Yeah I've seen that AJAX is easier with it, but honestly I'm yet to get that deep into JS. Animations should be done with CSS3 now, IMO. DOM manipulation is just as easy with vanilla JS now, and it's a damn sight faster. &gt; Refusing to use a tool because you don't understand how it works isn't smart. Well that's not what I said. I said that I've taken a look, and don't see anything of value to me. That said, I appreciate your input (and btw I'm not one of the people who've downvoted you).
[Approved](http://www.appraisal4u.com/dominar_Rygel_XIV09.jpg)
Yeah, as Rob mentioned in the post, the ViewModel doesn't really care what View you use with it. Check out the `compose` element to see how it's easy to dynamically hook up a View and ViewModel. There are other ways to do this, but this is the simplest way
I know you're trying to contribute/help but man...just man....
can you give any examples? 
ahahaha! You know what, I think subconsciously that's exactly where the name came from. Gotta love farscape :D
Everyone else seems to have the advice covered. I just dropped by to say this gave me the sharpest nostalgia I've felt in a while. When I was 12 I had a computer and a 56k modem that I could only use for 1 hour a day because it tied up our home phone line. I had managed to download one of these freeware RPG makers with a little builtin ECMA-like scripting language. I had become so fascinated with programming, but so deprived of knowledge, that I circumvented the RPG engine to start building arbitrary gui applications in the scripting language. My very first "app" was just this: a simple, flat, ( somewhat buggy :] ) calculator with buttons. When I finished it I remember this massive rush of possibility... I had just created something I could see, that did useful work, that I could click and use and show my parents. It definitely solidified my drive to become a professional developer. So, thanks for posting this and bringing back a great memory :)
Also nice, but the dragging is disabled, the bar takes the focus but ignores PageUp and PageDown keys. Desktop don't have swipe, in this particular situation the plugin is taking away the click-and-drag from the initial scrollbar behavior. That's still an awesome and elegant solution for mobiles and tablets, will definately use it ;-) 
Once again : they're companies. And a company's **primary** goal is not to make you happy, but to make money. Sometimes both goals overlap and everyone's happy (aka Chrome right now : big in Google's strategy and big in many devs' heart). But sometimes they don't overlap at all (aka IE when they it became clear IE had failed : MS stopped investing much money on it and devs cried). Judging a company or another on the things they did "at one point", and from YOUR point of view, is all but pragmatic.
It's a good start, but it needs some work. Try pressing: 7+7777 You end up with: 7+7777777777 That is six more 7 that expected :) 
None ES6 is a dream come true.
Where is some good documentation for ES6 promises? I'm 100% new to promises and they're actually a bit hard to understand. I finally was able to grasp callbacks after studying Node.JS for a few days. And the really dumb question: Is there any kind of built in promise library different than ES6 in React or Angular?
Facebook has more money ;) My bet is on React. But I could be wrong.
Yes. It solved a lot of problems that don't seem relevant anymore. But, you're only thinking of the past. What problems / headaches will you save yourself for the future? I really don't understand all this jQuery hate. If you think one single HTTP request is an issue, you better know that you have bigger fish to fry! As a learning task, I can see the benefit of not using jQuery. However, in production for a large agency with tight deadlines with ridiculous demands, in the real-world...you'll soon be thankful you have a wide choice of libraries. 
Not true. There is only "npm". All the other package managers are toys. http://www.modulecounts.com The nice thing about npm is, it eliminates dependency hell, but in general its a great package manager.
Why react?
People. Different people working on the same codebase have different levels of understanding of the language, frameworks, tooling, and existing code. Not being in an environment where education, style guides, or code reviews are strictly enforced means that people tend to be the be a large part of many problems - mostly manifesting in new, unique, or unusually awkward approaches to problems for which a solution should already exist, or for which tools/existing code is in place to make easier. And of course obtaining a better understanding of these things on one's own takes time which could otherwise be spent on feature development or bug fixes. It's agile, baby! Fail fast, and fail often. Mission accomplished! Edit: And while this applies to areas outside of JS, I think JS is especially affected because a person can know vanilla JS very well but be completely lost in todays more modern JS environments which have evolved greatly in the past couple of years.
+1 on sidebar link
obligatory https://xkcd.com/303/
[Image](http://imgs.xkcd.com/comics/compiling.png) **Title:** Compiling **Title-text:** 'Are you stealing those LCDs?' 'Yeah, but I'm doing it while my code compiles.' [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/303#Explanation) **Stats:** This comic has been referenced 426 times, representing 0.6617% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_crggno1)
Thanks. And I think that I should move the dashed line to the beginning of the padding. I will correct it later and post here as a comment. 
Yup, knockout is all you need if you *JUST* want databinding and nothing else to it.
Thank you so much for taking your time to share this. It is much appreciated. I'm myself trying to move to a more functional style in JS. I've been doing some small projects where I try to keep the data kind of immutable with [Ramda](http://ramdajs.com/0.14/index.html) and relying on small, easy to understand functions that can be composed in different ways. While I think a functional style requires more continuous refactoring and careful naming of functions/parameters, I think it is also a lot easier to follow the flow of the data. I also think it is much easier to get back to and refactor later since you can just hijack and re-implement functions everywhere, without having to worry if the function changes some kind of state down the line that might affect everything later. As long as the same output comes out of the new function, it doesn't matter. It's like the data starts at the top and just flows down the program without changing state all over the place all the time. Is this why it works so well? On a side note, what do you think of functional(/reactive) programming projects such as [Ramda](http://ramdajs.com/0.14/index.html), [RxJS](https://github.com/Reactive-Extensions/RxJS)/[Bacon.js](https://baconjs.github.io/)/[kefir.js](https://rpominov.github.io/kefir/) and [cycle.js](https://github.com/staltz/cycle)? To me it seems like they might be much better solutions to the async nature of front end JS but I'd love to hear the opinion from someone with much more experience, since people don't really seem to talk about them a lot. It's of course ok if you don't have the time to answer all this. :)
I like the cut of your jib, kid
&gt; Not true. There is only "npm". All the other package managers are toys. Yeah, well, I feel the same way but I wanted to be more diplomatic about it. I don't have the time/skills to deploy something like a package management system so I appreciate the work of those who do. But yes, NPM works so well because so little configuration of dependencies is required. Which is also why I like gulp more than grunt. Convenience is king.
Meteor has been around for a good bit, though. And it's much better than all the other JS frameworks I've used, imo.
Stacks of frameworks. Frameworks of frameworks. It's all the same.
Hi /u/leslao, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt;Now if you're building web apps or anything remotely complex, go with something like react, ember, angular etc. I don't have real experience with those frameworks, but with Backbone (and Marionette) jQuery is a dependency by default ([although it can be replaced](https://github.com/jashkenas/backbone/wiki/Using-Backbone-without-jQuery)).
You can use [this] (http://jquerymy.com/) jquery plugin to do R/T 2 way data binding without any additional framework. or you could follow [this](http://www.lucaongaro.eu/blog/2012/12/02/easy-two-way-data-binding-in-javascript/) tutorial and achieve the same result without a plugin at all.
&gt; This statement is so absurd, I have to wonder if you're joking. If you're smarter than all the Macbook-loving hipsters that you so despise and harbor contempt for, then you should be able to provide a technical rather than vitriolic argument.
Maybe I'm crazy, but this seems like it's going to cause a lot of issues. The only way I can see it working is if they just use lodash and ditch the underscore codebase entirely.
Why is it always .NET guys saying this? 
Checkout the proposed class decorators too. Eww.
That's pretty inaccurate!
Then you'll be happy to know you can always go back to .NET. Please take your friends with you.
how about we all just stop using Underscore?
UNDEFINED IS NOT A FUNCTION More seriously, My biggest problems with JS are the lack of a type-system, and its brain-dead approach to function arity. This is the face of true madness: &gt; var square = function(n) { return n * n; }; undefined &gt; square(4); 16 &gt; square(); NaN \*slow clap\* JS has plenty of other problems, but most of them are solved by decent libraries. Bringing Rambda.js into your stack makes for a very passable functional language for instance.
Why?
The real problem is still in the backend when writing async code. Promises A+ spec helps a bit with this, but there still the problem when needing nesting promises, the maintenance / debugging of that is a pain. async and await will really help with this (ES7, TypeScript 1.6). The Type safety requirement is now solved by TypeScript (v1.5 is really good). 
In Javascript, functions are objects and can be passed around in variables. In this case, repeat() takes two arguments, a counter and a function object variable. On line five, it calls the function object, and passes in the current counter index in case the function wants to make use of it somehow. Anything particular about it you don't understand?
Using different setups for dev + production could be a disaster waiting to happen.
In this particular case, this line might not make sense. Here fn is the second argument to `repeat` function, which is function () { console.log('Hello'); } so passing number `i` to it, does nothing, but execute `console.log('Hello')` and that's it. `value = fn(i)` means 'Whatever `fn(i)` returns, assign it to the variable `value`. `fn(i)` implicitly returns `undefined` each time(what matters here is the last time), so `value` is `undefined`. On line 7 you can see `return value`, which is essentially `return undefined`. This code will log string 'Hello' 3 times to the console.
Is there any reason someone would pick underscore over lodash as of today? If I can choose the modules I want from lodash with custom builds then it isn't size. The perfs I've seen tend to show that lodash is faster. What am I missing?
I thought we had. Who's holding out?!
That's true, it could be. I think eventually we should have an app auditing tool so that you can easily check if there is some obvious security hole in your app. But I don't think it's fundamentally different from other frameworks - the default Rails scaffolding also has no security and gives you access to the whole database.
It's because it's still a function call, so the parentheses are needed. Note that in this SPECIFIC example, passing in "i" isn't actually needed, as the example callback function does nothing but print to the console. It would probably be more understandable if the callback function looked like: repeat(3, function(index) { console.log("Hello " + index); }); Again, though: all that's happening is we're making a function call, same as if I did: function sampleFunction() { console.log("Did something useful"); } sampleFunction(); All that's different is that the function object is being passed in as a parameter.
I love the 'UNDEFINED IS NOT A FUNCTION' problem
If it's Underscore merging into Lodash, I'm for it. The other way around? Nah. No one wants to see egos flair up in a few months and contributors getting locked out again. 
While I will never use underscore again, it does come down to file size. It only takes about 10 lodash modules to push the file size above the entirety of underscore. Aside from that, lodash is better than underscore in every respect.
Nah, I'll stop here. Because I'm watsing my time trying to explain something you don't WANT to understand.
You sound a typical Microsoft sympathizer.
Yeah. I was shocked when I installed mongo and there was no auth. There are something like 60,000+ open mongo databases out there w/o any authentication and no firewall. I understand the ease of use during a getting started is nice to have, but for newbs who don't know what they are doing it can be a disaster.
Mostly the usual suspects you'll see recommended: * Underscore is a suite of ridiculously useful utility functions that you'll find yourself using everywhere. * Lodash is a separate equivalent of Underscore that's been optimized for speed and has even more useful functions. * Backbone is a good place to dip into the world of Model-View-Controller (MVC) frameworks for organizing your code and learning to structure your application in terms of data and behavior rather than just manipulating the DOM * Ampersand is an equivalent / upgrade of Backbone that, again, adds a number of additional useful features and ideas Underscore and Backbone are both written by the same guy, and are both short enough to easily read through the source and understand. In fact, there's annotated readable versions of the source code available on their websites. The nice thing is that there's very little "magic" involved in either of them. Other than that... keep reading through books like Javascript Allonge and Eloquent Javascript. Get a good handle on some of the core features, behaviors, and quirks of Javascript, and don't be afraid to dig into other people's code to see what's going on. Try not to get scared off by the insane number of new frameworks, libraries, and tools that are being announced and discussed everywhere. Once you learn some core concepts, you'll start to see when certain tools can be useful, and how different libraries approach solving similar problems. Oh, one other recommendation: I've become an unabashed fanboy of Jetbrains' WebStorm IDE for web development. Absolutely fantastic tool. I know everyone's got their own preferences for text editors and IDEs, but WebStorm really is that incredible.
I'm very sceptical of those benchmarks, would you mind submitting a PR adding Zousan to the [bluebird benchmarks](https://github.com/petkaantonov/bluebird/tree/master/benchmark) so that we can see how it compares under more realistic scenarios?
Never used Sublime myself. The biggest thing I love about WebStorm is its search abilities. The "Find In Files" feature is excellent, allowing you to not just do a text search across a folder, but do so with saved selection profiles. For example, our project doesn't use any package managers, and still keeps JS libraries all checked in. If I did a search across "All Project Files", I'd get a bunch of results I don't want. However, I have two saved search selection profiles. One includes just our own app script files, and the other includes both the app script files and the HTML and CSS files. In addition, text search allows you to specify some context, looking for results that are or are not in comments and string literals. The other great search ability is the "Find Usages" feature. Stuff like that is really easy in a language like Java or C#, where types are declared up front and it's straightforward to parse and understand the code. In a dynamic language like JS or Python, it's a lot harder. Fortunately, Jetbrains has some excellent parser developers, and both WebStorm and PyCharm do an incredible job of finding the relevant places where a particular thing is actually used. Those two features alone save me all kinds of time when dealing with our codebase. There's a ton of other features that I don't tend to use that much myself, but probably fit well into other people's workflows. I know WebStorm has a similar excellent "fuzzy filename search" ability. Not quite as sure on the others.
Honestly, I don't know. Lodash is just better, and I don't really like jashkenas as a maintainer because of [stuff like this](https://github.com/jashkenas/underscore/issues/1805). It's semantic versioning, not sentimental versioning.
Thanks a ton. Your insightful comments have been a joy to read. Cheers.
https://www.youtube.com/watch?v=qqVbr_LaCIo
that's why you typically have a staging area. dev uses lightweight tools that get the job done as fast as possible staging and prod run on the same stack. Anything that would break on production should be revealed on staging. 
Node.js is just a platform. It's built on the V8 JavaScript Engine, which is programmed in C++ and is what Chrome uses in the browser. Express is a minimalistic framework for Node used to build web APIs. There are alternatives, such as Koa, and frameworks which build on Express itself, like Sails. As for front-end frameworks, there are many. They all have their own quirks and conventions. Some are much larger and more full-featured than others. The two biggest "next-gen" back-end-agnostic frameworks will be Aurelia (which is really Durandal 2.0) and Angular 2.0. There is also Meteor, which is a framework serving as the entire stack (both front-end &amp; back-end). Outside of these, there is also a movement focusing on functional reactive programming and moving away from the typical Model-View-Controller/Model-View-ViewModel/Model-View-Presenter patterns found in most frameworks for performance and simplicity reasons. React is a library at the forefront of that movement. 
much more difficult to debug on staging and prod than development though.
Its the "V" in "MVVMVMVMVVMVVV" -- not sure which one though. I think its the 3rd one...or the 5th.
Yes. because everyone reads the docs. right?
No, you don't have to return anything. A function without a return statement will just return undefined. It won't ruin anything or throw any errors. No worries. :)
&gt; I don't use either in places where performance really matters, just a few dozen elements where it's easier to "functional" through. Lodash is really fast. I've had situations where a loop in Lodash is 15x-200x faster than relying on the native methods. Definitely faster than Underscore. For me, `_.each` is 40x faster than even a `for` loop on this Codepen on Chrome (WARNING: do not click on this link unless you have a fast device, page creates an array with 1 million elements on load): http://codepen.io/cgaudreau/pen/yNapOw
[This is amazing](https://github.com/jashkenas/underscore/issues/1805#issuecomment-53931669). TL;DR @jashkenas created a "semver" underscore repo, ostensibly to appease the countless people who were rightfully upset about him introducing breaking changes on a minor point release. ~~He then proceeded to passive-aggressively increment the major version on the "semver" repo with (I'm assuming) every minor and build number increment in the main repo. The upshot being that the "semver" version is now at 170.0.0~~ Edit: Nope, I was wrong. He uploaded the "semver" version directly at 170.0.0, and then never touched it again. What an absolutely butthurt prick. In light of this comment: &gt;But you can have your cake and eat it too. I've just published an "official" npm repository for underscore-semver, which will be released at the same time as Underscore is released, and will always contain a "semantic" derivation of the true Underscore version number. Feel free to depend on that, if you prefer: https://www.npmjs.org/package/underscore-semver and given that this "semver" version has never been touched since its original upload, it sounds like @jashkenas is not a man of his word. Edit: looks like this was called out later in the thread. That's what I get for not reading all the way through. 
Yea I hear that. I'd love Meteor to be db agnostic, but there are options out there.
Yeah. Could be. But then CircleCI or something similar... so ez. I kinda like approaching the ops from the perspective that it COULD grow, so since the barrier is so low to doing it "right", just do it right. But I get where you're coming from. I've done more than a few Jekyl + Github Pages setups, which is basically the same as what I was just digging on you for doing... lol
agreed, but realistically those types of things happen so rarely that the extra time it takes to debug on staging is significantly less than the time saves by having shortcuts on dev. 
It's one of the very first things you learn about Meteor. If you're deploying an app to production without understanding the very basic "getting started" tutorial type stuff for the stack you're using, good luck with that.
https://www.firebase.com/blog/2015-05-15-introducing-firebase-queue.html
It's weird that the native for goes down to lodash like speeds on second run. 
Except the sheer popularity of lodash means it's nearly guaranteed to be cached already by the browser, so file size doesn't matter. Unless you're minifying it into your bundle.
Again, if you don't read the docs, you shouldn't be deploying an app to production. Don't make other developers' lives harder just because you want to protect a few people who don't bother to rtfm.
&gt; I don't think I'm going to go with jQuery. Yea, jQuery really isn't needed. You only have to query two elements: an ancestor of all buttons and the display. And you only need a single event listener (as I've shown in my example). The final bit of DOM interaction is updating the display (via .textContent or .value). All of the DOM interactions can be done in less than a dozen lines of code. (It can be done in 6, actually.) With jQuery, those lines would be a little bit shorter and you could skip that filter `if`. That's it. There just isn't enough to make it worthwhile. However, I do recommend jQuery for more extensive DOM interactions, animations, AJAX (in browsers which don't support fetch), and IE compatibility. It's a great library.
Yes we will :] (I work at Meteor)
Modern JS runtimes will do that for you. They'll watch for expensive code paths and generate an aggressively optimized version for use the next time. On many pages this is a win, but obviously it either doesn't help or outright hinders an only-run-once performance test.
Just to toss something out there as an alternative to LoDash or Underscore - [RamdaJS](http://ramdajs.com/) There are lots of concepts with functional programming that I find make more sense, and easier / cleaner with Ramda than trying to do the same with Underscore or LoDash. It aims to have many of the same goals - but one of the primary differences with Ramda, is that the data comes last, which makes it easier to curry/compose functions. 
I would love to see the reddit's system of comment in GitHub or Stackoverflow (or Facebook, Twitter, Tumblr, etc.)
Sweet!
The best js frontend package manager is JSPM.
Oh that line is too good. I work with startups. I'm using that one.
*sheepishly raises hand*. I still use underscore client-side if only for the fact that uncompressed, lodash is over 7x the size. I definitely disagree that filesize is negligible. This is on me, but I've yet to abandon bower despite the other options, and the fact that I can't utilize bower to pull in just the functions I want keeps me on underscore. Node side, it is lodash all the way. Edit: compared the minified versions as it is a more useful comparison. Still a 3x difference.
Since your question was already answered, I'll tell you something else: Use an editor with a linter plugin. Also, use `[]` instead of `new Array()`.
We are talking about ~20kb compressed. That really isn't that heavy.
It's so funny and sad to see how the JS community knows nothing about frameworks that have not been hyped enough. Do yourselves a favour and watch some screencasts. When you go full-stack js there is simply nothing else coming close to Meteor at the moment. @Meteor guys - Amazing news, eager to see how you'll use the funding. 
Just an automation bot. But If this is not allowed, I won't ask.
That a called marketing and it's in absolutely every facet of your life, not only found in the js community.
You severely overestimate how often users will have it cached. Even jquery (IMO much more widespread) gets re-downloaded by about 60% of users every time.
Not. Happening.
You can do whatever you want, I'm just saying that a blanket statement that the extra file weight doesn't matter at all might not be true for everybody. Obviously it matters for the OP. 
Sure you do. They're both NaN. The `===` operator had *one job*...
Probably better worded as "I think it's stupid to refuse to use jQuery". I'm not saying it is the best choice in all situations, as evidenced in my advice for js frameworks for more complex situations. In a lot of cases you don't need javascript at all, much less jQuery. To my original point: Is including a large library of 1000 lines of code more performant than writing 100 lines of code yourself? Fuck no. Is it quicker to import a library and write 20 lines of code instead of writing 100? Hell yes. Nothing in development is always the right choice no matter the scenario. It's always about choosing what's best for your situation. I thought that was a given? 
According to the Backbone docs, &gt;"Mimics of the Underscore and jQuery APIs, such as Lo-Dash and Zepto, will also tend to work, with varying degrees of compatibility." Not sure what that means though haha.
Its a great project for a first time... and I commend the effort. A lot of other folks have suggested this and that, so I'll toss in my few cents on those, then I'll give you thoughts of my own. * Learn the regular `JavaScript` and `DOM` before learning `jQuery`. Knowing what happens under the scenes in invaluable when things break. Then, my thoughts. * Pick a coding style and stick with it. Either the single `var` or one `var` per variable. * There is no need to check against `true`. `if (gizmo == true)` is redundant, since the results get converted to a `boolean` anyways. * Learn the difference between `==` and `===`. You'll almost always want `===` and students of Crawford suggest NEVER using `==` or `!=`. I suggest the same thing. * It isn't a big deal in your current project, but learn to cache values. `var num = nums[i]` then reference `num` after. Saves you a lookup every time you need it. Useful in high-performance code. * Turn your event handlers into a separate function and attach that function. Creating a function in a loop is computationally expensive and chews up more memory.
You might consider [mithrilJS](http://mithril.js.org/). It's tiny, but has 2-way data binding and virtual DOM for performance.
I agree completely. From a technical perspective, jashkenas makes decent points against semver (which I can respect even though I disagree with him). However, childish behavior such as [blocking a 'competitor' to a repository](https://twitter.com/jdalton/status/568568521602412546), [making a fake npm package as a political statement](https://www.npmjs.com/package/underscore-semver), and [releasing breaking changes without discussion](https://github.com/jashkenas/underscore/issues/2061) are really off-putting. Granted, jdalton doesn't always come across as The Saint of Internet Etiquette, but I trust him more as a maintainer. My biggest worry about any merger isn't technical, it's what happens when these egos collide.
[**@jdalton**](https://twitter.com/jdalton/) &gt; [2015-02-20 00:31 UTC](https://twitter.com/jdalton/status/568568521602412546) &gt; Ah nice Underscore 1.8.0 has shipped! Unfortunately w/ the renewed competitive spirit Jeremy is back to his old ways. [[Attached pic]](http://pbs.twimg.com/media/B-P2DsWCcAAZMDk.png) [[Imgur rehost]](http://i.imgur.com/2bUCkIs.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
In a nutshell, user can have many accounts... each of these accounts belong to a tenant ( might be the same or different subdomain)... I want the user to be able to login the application then change the subdomain based on the sub accounts he want to use... I'm not sure what direction should I go... but it'll be nice if I could have the subdomain changed ( like slack app for example for each account) basically I don't have multiple angular applications to switch between them... and I want to support multi-tenancy on the Rails API using sub domains... sorry that I could not explain much cause it's a weird case... but if you need further description I can try to explain it more...
ehh, it's tedious, not hard. If we're talking SQL, you can create an Adjacency List or a Nested Set. Most server-side programmers have likely used one or the other at least some point to represent hierarchical data. I created an Adjacency List in Derby to manage a file structure. Sure, the amount of data add's complexity in storage, but the concept is the same.
Wait, what are people using nowadays instead of bower??
What are the deciding factors between Purescript and Scalajs? How about Elm?
github needs to allow you to set a minimum comment length for busy threads, to prevent it from getting gummed up with +1's and memes
It's the examples that aren't working for me, so I don't think it was given, but as you have explained yourself, I think it makes more sense. It's still more impressive/performant if someone does in 100 lines of code that someone else does in 20 (with a 1000 line library). I *do* understand your point, however, and I think we'd end up arguing that "use the right tool for the job" versus "I have a hammer, and now every problem starts to look like a nail."
Also one of my favourites. That NaN will then proceed to infect all kinds of values and now you're faced with the task of finding where it started.
You should expand the Location object logging line in your console 
You're right there, I wasn't clear. I'll amend my post a bit. Run this in your console: var x = function(a) { console.debug(JSON.stringify(a, null, 4)); }; x(window.location)
Thanks. I didn't realize Purscript was good at outputting readable Javascript. One thing I'll point out about TypeScript is that it has a lot of definitions written for it, so you can use just about any popular 3rd party library with the advantage of types. I'm not sure how those 3 compare but I doubt they've got as much coverage (if that matters to you.)
Yeah reddit wont let me update the topic. So any idea why Google changed this 42-&gt;43? It broke my product pretty majorly and I'd love to see if theres release notes I missed somehwere explaining it? 
Its HomoIsoPolyMorphic. Has realtime digesting with transcludable injection of classisisms. 
https://www.chromestatus.com/features is an easy way to see upcoming changes to Chrome.
All those host/port/protocol/etc properties are from URLUtils: https://url.spec.whatwg.org/#urlutils-and-urlutilsreadonly-members The spec doesn't mention if those properties are supposed to be enumerable. Anyhow, this is most likely an unintentional regression. Feel free to file a bug. In the meantime, you just have to work around it. Simply create your own location object by copying the values you need. (So, this really does nothing for security.)
awesome, I'll keep my eye on this. Thanks!
even faster function whileUp(){ var x = 0; var i = -1; var len = a.length; var val = 0; while ( i++ &lt; len ){ val = a[i]; if (val === undefined) { break; } x += val; } return x; }
Holy shit, the man himself! Thanks so much for writing the book. What new technologies are you diving in to? I just started hitting the Google Maps Javascript API v3...so much fun.
The link says hasOwnProperty will return false, so is that only for Dom objects ? 
When you go full-stack js there is simply nothing else coming out of it besides a fun weekend project.
&gt; One thing I'll point out about TypeScript is that it has a lot of definitions written for it I believe there's options for using ts.d files with some of the above options, but I haven't looked too far into it. The libraries I've used so far have all had proper bindings, so it hasn't been too big a deal. Typescript still has some pretty big holes in its type system - the lack of null safety for example. It's not really a viable option in my mind, although in lieu of anything else it's still better than raw JS.
WebStorm has integrated debugging similar to what Eclipse/Visual Studio do, set breakpoints on the code you write. If you haven't already seen it, [node-inspector](https://github.com/node-inspector/node-inspector) is great if you don't want to use WebStorm for whatever reason.
So it's a node.js remote execution application?
This deserves a big NOPE.
1) you should be concatenating your scripts in 2015. 2) Unless you have an excellent reason not to, you should be including your scripts just before &amp;lt;/body&gt;. 3) if your script has a dependency (like jQuery), you should include the dependency first.
if Backbone is not 100% compatible with Lodash, it would probably be wiser for the community to spend its time fixing said compatibility than on merging Underscore and Lodash.
Zepto is an all out nightmare to get working properly. It took us weeks to completely replace jQuery. But the byte savings were tremendous... almost enough that we considered lodash for a few minutes. It's just too big for mobile though. (With backbone, Marionette and a few backbone plugins)
it is not a framework
Can we just stop using either? God damn, the problems I have to deal with every day from other's use of lodash.
&gt; This is why I take issue with software suites and tools that don't encourage pinning your dependency graph down to the commit hash, right out of the box. It has always seemed insane to me not to do this one, because you already know what version you want to use and two, why would you willy-nilly update your project's dependencies in such a way that you would accept changes arbitrarily? Updating libraries is one of the very last things I do when developing software.
Yeah. I came to the same conclusion. Tried both. The benefits of lazy loading didn't outweigh the benefits of upfront loading.
Yeah now that it's established what I *should* be doing, the question was about what determines when a jquery script goes top or bottom. The need varies.
Where I work, we use Backbone with Lodash instead of Underscore. Haven't noticed any problems.
`hasOwnProperty` does not check the properties in the prototype chain.
I'm sorry, i move it on codepen :)
I'm not working on .NET, i'm a front-end-er, that has worked with php, and now I'm working with java as backend. We say that because it's the simple truth. If Chrome was an BMW, IE was a tractor, and you're the one calling the tractor a "failed speed automobile" 
Ramba? WTF is Ramba?
lol, grow up. 
On a 4G connection (most of the UK by now) or even better, on WiFi, it really is a non-issue for the most part.
Why did Google implement this? From what I've learnt, adding your own stuff to native functions(say, String.prototype.reverseString()) isn't a good idea. It'll slow down your JS, if I've understood it correctly. Aren't Google doing the same thing? Or are they "allowed" to do this since they can optimize stuff in V8?
I can't. I have waisted years of my life fixing IE bugs and battling that piece of shit browser. I will never grow up. Microsoft has stunted my growth forever.
&gt; On a 4G connection (most of the UK by now) Hahahahaaaa! You're funny :) That isn't even remotely true. Yes, lots of the UK has 4G - mostly the very densely populated areas. But large chunks of the UK haven't even got reliable 3G signal yet. And even if you *are* on 4G some of the smaller providers (I'm looking at you, giffgaff) can barely offer Edge speeds. This is not a non-issue.
You should really give Flow a shot. Similar to Typescript, albeit with a type system inspired my ML. 
Oh I totally agree. I was actually discussing with my friend the other day, 'I wonder at what point does a JS file become less file size by including jQuery vs using vanilla JS' 
If you're using bluebird you need to leave that catcher out completely and use `Promise.longStackTraces()` to get full stack traces. &gt; The worst thing in my opinion is that I dont get any full call stacks anymore You don't get full stack trace with callbacks either (without using libraries).
Don't blame microsoft, blame your boss for catering to the small minority who hates their lives. 
Guess I should have said that im experimenting it using io.js.
I'll look into Bluebird, thanks. Im currently at work so I can't gist anything.
Dat pocket watch though
Probably: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise &gt; Is there any kind of built in promise library different than ES6 in React or Angular? Angular uses a library called Q, but it is the exact same implementation (called A+ specification https://promisesaplus.com/) 
&gt; It's his project and he should be allowed to version it however he wants. He is allowed to version it however he wants, and it appears as if he has decided to make full use of that right. No one is trying to argue that he doesn't have this right. What he does not have, however, is some sort of immunity to criticism. Look, millions of people rely on his library (6.5M npm downloads this month, apparently). So while he *can* introduce breaking changes to function signatures on a point release, doing so lets down a lot of people who rely on his library. He could choose to deal with this like a petulant child, as he does, or he could choose to deal with it with humility and empathy for the people who rely on the work he is doing. Cf. [this comment](https://github.com/jashkenas/underscore/issues/1805#issuecomment-53995766) by @jdalton for an example: &gt;I've followed semver not because I think it's the best approach but because it's the established convention for the package managers I support, namely npm. It's about respecting users and knowing that breaking convention would break lots of their projects, erode their trust, &amp; cost them time, money, &amp; frustration.
Not quite the same, but when building an API for a mobile application I build it so one request to the backend would return everything a user would need for that 'action'. Taking something like Airbnb as an example, I would have one endpoint that returns everything on a search results page, and then another returning everything on a property listing page. Doing something like having the search results return a list of IDs, then fetching the listing for each of those would give a pretty poor experience on mobile due to latency - HTTP2 will help, but it still won't beat having an endpoint optimised for your needs.
So if I'd like to do, say, `String.prototype.reverseStringAndAddFishsticksToTheEnd()`, that should be OK? Since that function doesn't exist at all and I'm quite sure that it won't ever be written by someone else. Or is it more like an unwritten rule, to not make even my silly function because someone might actually make the same function in a library?
I was once the lead dev of a popular web-based IM client (AIM, MSN, Yahoo, etc) and we had this exact situation to deal with. On login, the server would sign in on the various remote services and send the client the data to sync the initial state (account status, contacts, groups, etc). After syncing, the server would send updates on that state (incoming messages, contacts going on or offline, etc). The architecture that worked best for us was to have a single module responsible for client-server communications doing regular polling. Incoming updates would be parsed and then broadcast in the client using a pub/sub pattern. This meant that any component was responsible for subscribing itself to the right type of messages and updating when those messages come in. The advantage was that components were very self-contained and loosely coupled. The downside was that debugging errors was sometimes hard because the origin of certain actions was hard to trace.
Large chunks? Like the Scottish Highlands? Perhaps I jumped the gun saying 4G in most of the UK, but 3G certainly is. See [here](http://opensignal.com/coverage-maps/UK/) for coverage maps. And [here](http://ee.co.uk/ee-and-me/network/4gee/coverage-checker).
Chrome 43 has broken parts of TinyMCE on one of my client's sites through a similar window.location image, I believe. But Chrome 44 and 45 work fine, so I suspect some of it has been reverted.
Can I have this as a React mixin? Thanks.
Much appreciated :-)
If you'd take off the sarcasm hat and try to figure out what I meant, you might notice that the comment I'm responding to is basically a bunch of "you're an outsider who doesn't know what he's talking about and you learned everything you know from TV." So I pointed out that actually he's one of the most productive devs out there and is speaking from personal experience.
So they should make it more annoying to get started because some idiot might fuck up without even reading a tutorial? lol.
We all know that reading manuals is essential, but that's in idealistic world. In the real world it doesn't work for some reason. Nobody reads the manuals and you must deal with it. So all your "you shouldn't be" and "don't make" is a pointless bullshit. From my experience, if a service or technology does that unsecure-rtfm-easy-start approach with an intentional data exposure is like a rifle hanging on the wall which fires someday.
That is not correct either. Positioning has nothing to do with the DOM. This is browser/web API. https://developer.mozilla.org/en-US/docs/Web/API The DOM is about the document and its respective elements/nodes ONLY.
This seems pretty awesome... I'll have to play around with it. Thanks!!
It is, in fact, unreasonable for a redditor to judge a stranger based on quick, incorrect reads of what they said. That they are talking down to one of the most experienced programmers out there as a clueless amateur is evidence. The reddit programmer culture is intensely toxic and doesn't seem to understand that of itself. At least IRC knows what it is. This thread was over a day ago. You shouldn't be downvoting for disagreement. You're in contrast to Reddit culture.
Creating a javascript framework is fine. Expecting other people to use/adopt however...
Wow. This is actually looks really cool. Has anybody had success using this in a real project? Any pitfalls?
No, I can't say I have. I'm running Chrome 43. Could you please elaborate how you get to see this cool feature?
Oftentimes yes, but I think there's a tendency to get into it because it's seen as a cool place to be. I've seen a lot of successful (meaning: was developed quickly with an acceptable level of bugs for a healthy profit) code that was a bunch of in-line JS with global variables and no separation of concerns just pasted into JSP/ASP/PHP/whatever. I'm not saying I recommend that for a site like Facebook or Twitter, but for a small or medium-sized business sometimes the "cool" approach adds a lot more complexity than *may* be needed. However I will add a caveat that once you master these technologies (assuming they stick around) then you can code at almost the same speed or even faster than before, depending on the project.
It also highlight's the currently evaluating expression (not just line number) when you walk back the call stack. Awesome updates in this release.
The API looks really cool indeed. But unfortunately I didn't had a chance to use it in a lager project. Does anyone of you have more experience with this lib?
What are the chances of the browsers creating an optimiation for this efficiently and natively? Is it possible, or are there larger architectural issues?
Isn't the problem that everybody says to get noticed or to get work you have to create something yourself? 
This comic is pretty good, but it's too bloated for my use case. My version is much more lightweight http://imgur.com/FB8evmq
I'm on Version 43.0.2357.65 m and is by default
This needs to be a thing. Either that or "epic coding time."
It was posted a while back: [Chrome DevTools Update: Display variable values inline while debugging](https://www.reddit.com/comments/30bc39/) It can be enabled/disabled from Settings/General/Sources/'Display variable values inline while debugging'.
What I've seen is that a lot of the turbulence in the JavaScript ecosystem is largely driven by a startup-oriented "time to market" strategy. In that situation, software is largely *disposable* after a year or so. There's little sense in building it right when you need something up and demonstrable inside a week. Granted, there *are* tools that let you build it right and move fast too, but they're not as cool...
hey ya'll I think it's about time to merge these two comics, but we truly need to adopt the correct way to semVer.
Hi /u/magenta_placenta, this post was removed because `javascriptkicks.com` is blogspam. You can post the original article if you wish: https://medium.com/@RobertTheGrey/the-future-of-the-javascript-front-end-framework-bc329d2af600
You have posts like these but also when someone asks what framework to use/learn, everybody tells him 'go vanilla, make your own, you'll understand more that way'. /r/javascript is very ==
Congrats on the making it into Javascript Weekly post
I created a javascript framework that generates html element contents using a DFA/state machine embedded in the data-contents attribute as interpreted by the [Befunge](https://en.wikipedia.org/wiki/Befunge) processor. It is now mandatory for all new dynamic web scale ajaxy 2.0 polyfills.
Install a Debug version of Flash player. It could be a case of sloppy programming and some stray runtime error not being caught. 
We'll merge, then split, then merge again and then be angry people don't trust neither anymore
In what way do they not help you escape callback hell? In a Promise, you need not write your function in such away that it accepts a function as an argument to call when asynchronous processes have completed. Instead, you simply return/throw (almost as if you were writing synchronous code) and let the Promise manage your control flow. It's not as close to sync code as generators/co/asyncawait, but it's definitely closer than standard callback mechanisms.
&gt; What he does not have, however, is some sort of immunity to criticism. Sure, but that's completely different from the community having the "right" to be upset. Frankly, the community doesn't have any rights regarding his software *except for what the license entails*. This is especially true because that software can be forked, or the npm package can be versioned completely differently than the software it represents. As for the breaking changes concern, you and I are likely to disagree on this, but the solution is to not update your project dependencies if you don't need to and to take the time to investigate what changes are coming down the line.
I am currently fighting the magic of `_.bindAll()`. In a more general sense, I'm not a fan of constructs such as this: _.reduce(_.map(arr, (a) =&gt; { ... }), (a) =&gt; { ... }) The wrapping of "functional" methods around data constantly throws me off, in part because this is a map/reduce, but on first glance it's read as "reduce/map". I'd rather see this (which JavaScript supports just fine): arr.map((a) =&gt; { ... }).reduce((a) =&gt; { ... }) or, what I often end up doing to make things seem less insane: var mapMethod = (a) =&gt; { ... }; var reduceMethod = (a) =&gt; { ... }; var mappedData = arr.map(mapMethod); var reducedData = mappedData.reduce(reduceMethod); But my main gripe is that underscore and lodash don't provide anything that's not already easy to do with plain old JavaScript. It seems wasteful. Oh, and I really strongly dislike `_.isUndefined()`. Didn't we learn that things like `isNaN()` and `isFinite()` suck? Sorry, not going to post any real examples because I have coworkers in this subreddit and, while I'm not a fan of this style of development, I still respect the work they're doing.
I like the idea of the Virtual DOM. I implemented something similar in Dart a year ago. It seems that Angular 2.0 will be doing something similar.
Your software is only as disposable as your company. If the company sticks around, so will your hacky code. 
ES5: `_.mapObject(obj, function(d) { return _.uniq(d); });` ES6: `_.mapObject(obj, (d) =&gt; _.uniq(d));` https://github.com/Wildhoney
I'm in the process of moving our ember app from brunch to broccoli/ember-cli. We've got a decent build system but all of the unique stuff we did isn't helping. On the other hand, me started using requirejs a year ago and that is making it much easier to move to es6 modules. You win some, you loose some.
Thank you. I missed the breakpoint part.
Ramda: `R.mapObj(R.uniq, obj)`
Man I didn't even know there was a broccoli. 
Maybe learn JS/CSS first? Would you just start out by learning Juce as a way to learn C++? Angular is decent, but extremely opinionated, heavy, and huge overkill for most SPAs.
I'll use either when they implement data last on all functions.
Angular is built on javascript, so basically anything you can do in Angular you can do in Vanilla JavaScript. Angular does a few things for you. It takes care of some basic repetative plumbing tasks. Ie code that you have to write on a regular basis just to fetch data or update a UI. Angular also give you a framework to structure your code and this really helps with larger more complex applications. There's a lot more but from a 50,000 ft conceptual level it's that.
Check out Aurelia. I've been using it, and I like it better than Angular 2. You can write mostly ES6 instead of having to insert a bunch of framework specific stuff. It is still really, really young, but it is pretty damn awesome. 
I've become a big fan of React and Reflux, with Bootstrap for styling. I also really like ES6 so when I'm doing that I use babel and webpack to build it all. Note that react/flux are only small parts of the whole, so you'll need other libraries as well, depending on what you want to achieve. It is more flexible that way, but more effort.
Ramda is awesome.
Let the arguments stand on their own merit.
Jquery mobile is a simple SPA framework. It provides you with basic functionality. And styling can be done at your own will. Angular is undergoing an overhaul of its syntax and MVC in version 2. Personally I would wait until 2.0 if you are diving into angular
&gt; Sure, but that's completely different from the community having the "right" to be upset. Frankly, the community doesn't have any rights regarding his software _except for what the license entails_. I'm not sure I understand your argument here. People don't have a right to have their own feelings and opinions about this project (i.e. being upset)? Because you think the license doesn't allow for this somehow? People absolutely have a right to be upset about the direction @jashkenas has decided to take his project. And they have a right to express those opinions in virtually whatever way they choose. Just as @jashkenas has a right to ignore them (or insult them, or whatever), as he has chosen to do here. &gt; This is especially true because that software can be forked And thankfully this is exactly what @jdalton has done with lodash. In fact, he's far surpassed underscore in virtually every regard, and from what I've seen, he's a very humble, gracious person who respects and listens to his userbase. There's really no reason to use underscore, these days. &gt; As for the breaking changes concern, you and I are likely to disagree on this, but the solution is to not update your project dependencies if you don't need to and to take the time to investigate what changes are coming down the line. What people took issue with here was that the node/npm community by convention uses semver. When you add a package as a dependency, npm by default pegs this dependency version to ^x.y.z, being a shorthand for &gt;=x.y.z &lt; x+1.0.0. Semver dictates that any breaking changes to your API requires a point release. So if you follow semver, in theory this should all pretty much work just fine. Now, whether or not people _should_ be using semver or not is entirely irrelevant. Millions of people are already doing this. This is the direction the community has decided to go. So, to address your point: even if you were to peg your dependencies to a very specific version, if any of those dependencies has its own dependencies (and dependencies of those dependencies, and so on) using the caret notation, then a breaking change in any of those dependencies that does not respect semver could potentially break anything below it in the dependency graph. So what this means practically speaking is that, even if I set my dependency versions very strictly, if two different people do an npm install on my package at two different times, if any of the sub-dependencies have made a point release, they can end up with different versions of these sub-dependencies. If those sub-dependencies are being considerate and following semver, then hopefully there won't be any issues. If they're not, then things can start to go pear shaped pretty quickly. In other words, package maintainers who choose not to follow semver have a much higher likelihood of breaking other people's projects--even where the dependencies are pegged to a very specific version--than those who follow community standards. To be clear, I am not arguing for or against anything here, or agreeing or disagreeing with you. This is simply the reality of the situation.
Meteor looks good. I've never used it. Why should I use it? Anyone? edit: Examples would be awesome
And this is the part where people get burned. I've seen it a few times, in fact.
I already know html, css and js.
Wait what? Did node.js get forked again?
OK, I'll look into it!
No - it's all boilerplate. We're doing the same work over and over again.
I would say that Angular's greatest value proposition is the abstraction layer that it provided over the DOM. This affords you the ability create your own DSL with HTML. It, to me at least, is its most important feature. 
This is what I think about Meteor too. As a developer I need just enough abstraction for me to know exactly what is going under the hood. If things start appearing like magic then I'll really have to think about using it in a long run. 
Didn't did this land on Canary like way back? Or am I missing something?
&gt;... you had better understand the anatomy of the ~~turtles~~ objects all the way ~~down~~ up. FTFY 
I agree with the second point. Autoruns in particular can cause some pretty hellish debugging problems. Can you elaborate on the first point, though? Even outside of Meteor, the trend seems to be sharing front-end and back-end code. I find that the sharing in Meteor eliminates several classes of problems. No clunky, slow, inefficient non-conforming REST API, custom serialization, or manual cache invalidation. Not to mention dev tools. And if you want an API, you can do that too, with ease.
I use it extensively and yes if its one thing knockout is good at its databinding. It had one, two way data binding long before angular or ember. Also, it kinda feels like react with their recent addition to `components`. 
This one's underscore/lodash - https://github.com/jashkenas/underscore/issues/2182
I made a script in JS (Javascript for automation) that uses discogs.com bountiful resource of genres and styles to tag your tracks in iTunes. You can view, like or fork on its github page. As it stands now, it is functional and able to tag albums in your library. I suggest processing a batch of up to 30 albums at a time to see if you like the results. In the .js source, you will see some comments at the bottom with intended features. Feel free to comment and tell me if my tool is any of any use. thanks.
I know a few people who are using meteor and love it. I recommend you just go through the Getting Starting guide and find out for yourself. Only takes an hour or so.
callbacks are a pita. you just have to get used to them and learn how to write them in the least intrusive way.
Just go through their getting started guide. Takes about an hour.
I'll second or third Aurelia. 
&gt; I'm not sure I understand your argument here. People don't have a right to have their own feelings and opinions about this project (i.e. being upset)? Because you think the license doesn't allow for this somehow? You are right. People have a right to their feelings. However, in context, there is more implied than an emotional reaction. &gt; TL;DR @jashkenas created a "semver" underscore repo, ostensibly to appease the countless people who were rightfully upset about him introducing breaking changes on a minor point release. It's more the *expectation* that a project follow semantic versioning that I'm taking issue with (one which existed before semantic versioning, no less). I am certainly not intending to say how people should feel, however, I do believe the expectation, and thus the resulting emotional reaction, is misplaced, rather than wrong. Along the same vein, when it comes to software, unless you have signed a contract with a vendor, chances are you don't have a right to any expectations regarding the quality of that software at any given point in time. &gt; What people took issue with here was that the node/npm community by convention uses semver. Understood. I believe taking issue with this is misplaced simply because of what I mentioned above. &gt; So, to address your point ... Also understood, however, I don't have the confidence in semantic versioning that others do. While I believe jashkenas took childish measures to demonstrate his points, he does have valid ones.
&gt; is very == I'm going to use this everywhere now, for everything.
 Object.keys(obj).forEach(function(key) { obj[key] = obj[key].filter(function (v, i, arr) { return arr.indexOf(v) === i; }); }, obj); Normal JS just looks like a pile of crap, ... but what if... /** Zee best library in teh world */ var Z = (function() { "use strict"; return { uniq: function(v, i, arr) { return arr.indexOf(v) === i; }, /** Iterate Object Filter Value */ iofv: function (obj, filter) { for (k of Object.keys(obj)) obj[k]=obj[k].filter(filter); }, }; })(); Well now that we have a new powerful JavaScript library to use. Z.iofv(obj, Z.uniq); Look at that 20 characters! Completely destroying the productivity of underscore and Ramda by a mind boggling 42% and 9% respectively.
This is a total tangent and I'm probably daft, but: Is there a purpose to giving a name to a function that is assigned to a variable, like is shown in the image? i.e.: var name = function name() {}
upwork.com
Hear that? *woosh*
See, but I do a lot more data manipulation than that.
So then, you haven't built a hacky product for a startup.
I never had the opportunity to get higher level education. I love learning, and finding stuff like this makes my day.
Of course! Learning is never a bad thing! I was just curious about people's backgrounds. I think I could've phrased it better. 
MooTools FTW
There's not always time to write fully optimized code. Even a small MVP project can call for hundreds of little optimized routines. Often what matters enough is those routines work. Nobody wants to hear about how much time you spent writing elegant optimized code when they're footing the bill.
Lodash v3 is [modular](https://github.com/lodash/lodash/tree/npm) so you can cherry pick the methods you want, like `require('lodash/array/chunk')` and bundlers like webpack/browserify will automatically create smaller builds.
Devs who complain about size generally aren't aware that lodash is [modular](https://github.com/lodash/lodash/tree/npm). You can choose the methods you want without the rest.
Lodash has ~81 more methods than Underscore and the difference in size is ~12kb. If that 12kb is an issue then leverage [Lodash modules](https://github.com/lodash/lodash/tree/npm) to reduce the gap.
You should watch his presentation: https://www.youtube.com/watch?v=83MX4wsoMzU As the description says: "Physics at 60 frames per second controlling DOM on a mobile device"
Gotcha covered. See [lodash-fp](https://www.npmjs.com/package/lodash-fp) :)
Lodash works great with Backbone. Every Lodash commit is ran against Backbone's unit tests.
Just the usual gossip. Don't let it go to your head ;)
I think a lot of js developers got into the language from non CS in-roads like building read only websites and jquery. I know I did, my first dev job was brochure WordPress sites and I've since moved into building some fairly heavy duty SPAs.
It's slowly turning int my favourite web stack. I've written couple small apps for personal use, couple bigger things for niche user groups, and now have snuck it into my workplace - we're building client apps in meteor now. The main thing about meteor is it's DIFFERENT. It does not confirm to my experience of how web is done. Can't always use the same monitoring/reporting tools we've used for years. But meteor makes things so much more simple in many cases that I'm more than eager to work around my issues with it to enjoy those benefits. For example, we're re-writing an existing realtime data centric web app for a client. And even with having to pull updates from a third party server over a slow HTTP API, our meteor-based solution still manages to display and update that data faster than the existing app that has direct access to the source database. And besides the non-meteor API consumer app that is in charge of updating our local database, I spent about half an hour on it. `Meteor.publish` here, `Meteor.subscribe` there, some HTML to display it, done, realtime updates. It's really nice to work with. The ecosystem is growing day by day. Try it.
Are we done caring about modifying native prototypes now?
Ah, thanks.
IMHO you really need to spend some time vanilla if you're learning JS. I've written my share of JavaScript (well, mostly CoffeeScript) at work, but I don't feel nearly confident enough to dive into something like Angular or Ember. *P. S.* But the problem you stated is totally viable. I mean, a lot of articles on the Internet say "Oh, just use Angular or Ember or Backbone" while I don't think either of them is particularly easy. I picked my framework using the [TodoMVC](http://todomvc.com/) site. Just looked into the websites and searched for clear docs and tutorials.
i have a question about how this works... at what point is it not worth memoizing? does the function have to do a deep compare of the data passed as arguments, to ensure they are all identical? edit: in lodash it does not check all args and make sure they are same it stores a key based on the args passed... you have to supply a resolver function to generate the key (for the cache) as another param...(i think) not sure i like this but interesting none the less. ive been waiting to run a decent benchmark on one of my apps with this.
ok-so-the-fuck-what?
If something is magic, that usually means it's obtrusive and too complex to easily comprehend. For example, AngularJS is a framework that heavily relies on magic. But the instance you start writing non-trivial directives, you suddenly need to see under the hood and work without the magic (or even do the magic yourself). Rails and Django are two examples of frameworks that started out with a ton of magic and eventually found it more sustainable to reduce or restrict the magic. Whether meteor has too much magic or just enough I can't say, I haven't looked into meteor enough to make a qualified statement about that. But meteor certainly advertises itself as magic-heavy.
Yes, the `Date` constructor is positively absurd. IMO there are only two valid representations of date time data: as a UNIX timestamp (i.e. `Number(date)`) or as an ISO string. I only ever use `Date` objects as representations of those values and (de-)serialize everything into either of those two data types for storage and transport. For anything more complex than answering questions like "what's the year of this timestamp?" or String&lt;-&gt;Number conversions, you should use a proper time manipulation library like moment.js anyway.
Hi /u/thejmazz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/GtresMX, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
so i think its value proposition is write once deploy anywhere including mobile... along with physics and animation being a focus of the library. (many javascript fw get hacky when you do animation).. personally im not gonna use it unless they clean up or streamline the syntax... its kind of all over the place and i dont think i could get a grasp of it in 2-3 months. just my critique.
I thought I was in that sub but now that you mention it...
This article fails to mention that the example memorisation code only works correctly for functions that take one argument and have input spaces that are bijective with the toString() mapping of the same input space. These are huge gotchas that the target audience of the article are unlikely to work out on their own without time spent painfully debugging false cache hit errors. If you are the author please fix this and amend the article. JSON.stringify(arguments) might be a solution here.
"Once you go full stack js, you never go back" leads to the same outcome as "Once you go black, you never go back": a sore bunghole.
I dont personally assume that JavaScript developers have any particular background or lack of background. What I do assume is that *if* you want to explain a basic programming idea, JavaScript is one of the languages with the widest audiences. So if there are 10x as many JavaScript developers as Perl developers, there will be 10x the audience for an article about memoization written with JavaScript examples, than with Perl examples.
thanks a lot, this is good to know.
If the function is recursively using values more than once then the benefit will be much larger, but the benefit is still there even for non-recursive functions (so long as the lookup is faster than the calculation).
The article is fixed! Thanks again!
This memoize() has limitations as well, the inputs must be serialisable as JSON. function memoize(f) { var cache = {}; return function() { var key = JSON.stringify(arguments); return key in cache ? cache[key] : (cache[key] = f.apply(this, arguments)); }; } Comparison: http://jsfiddle.net/fjqkve0u/
I added a line or two about modifying native prototypes. Thanks!
A lot of developers in general do not have a background in CS. At least where I work. Forgot what they call it but it's a more business/IT focused degree. 
I am not going to show you any quick example but a suggestion to change your strategy. `id`s must be unique, and the `whatever[]` convention to represent arrays in form elements' names can have some meaning only on the server-side iff the receiving http library/framework/code gives some special meaning to them. Otherwise it is just the same name repeated.
http://jsbin.com/nanisatuzi/1/edit from stack overflow
This article needs to talk about long-running memoized functions. There are many cases that benefit from memoization, but need to have the old entries removed. This could be a nice segway into WeakMap...
TL;DR. Just use Hamsters.js with cache mode enabled..boom multithreaded memoization. https://github.com/austinksmith/WebHamsters
Exactly, it would be nice for the article to point that out as well, rather than letting everyone reinvent the wheel.
Ramda is something for sure among the reddit/hn crowd but at the moment it has less than 0.003% the number of packages depending on it as Lodash and even less npm downloads. FWIW I've already started seeing devs [drop it](https://twitter.com/misok/status/598743831769669632) because of bugs/performance problems.
I've been a full-time front-end dev (officially "Software Engineer II") for a year now, and my degree was in Music and English (although somewhat ironically it was from a university renowned for CS). My colleagues are a mix of CS and non-CS backgrounds. I was familiar with memoization -- it's discussed in *The Good Parts* -- but coincidentally I was just brushing up on it just last night for the purposes of a coding exercise. I've never had to use it for work, though.
lodash-fp is really not in the same league as Ramda with regards to functional programming. Just currying and flipping arguments isn't going to cut it.
I seem to remember another library being in the exact same position not so long ago. Well, the first part anyway.
Lodash and Ramda have very different goals. One of Lodash's goals is to bring high quality utility methods to as many devs as possible regardless of module format, package preference, environment, or programming style. Lodash is less hardline philosophy driven and I think has a better balance of functionality, usability, consistency &amp; performance. We live in an age of modular JavaScript. I see bits of both used at the same time.
The link to the repo is in the description. Or, https://github.com/thejmazz/bcrypt-tokenized-auth. And I've asked a mod if it's ok to post that link to source in the sub. 
Yap. However, there a philosophy/goal differences. From what I've seen Ramda tends to side more on philosophy while Lodash will tend to side more on developer experience. This presents itself in Ramda with its breaking changes every other release, failing to provide upgrade paths, and its rejecting of popular developer requested functionality. 
Good approach.
I personally think Ramda provides a much improved developer experience compared to Lodash. But Ramda definitely provides a developer experience that is different from what JS developers normally get. But please don't call it "philosophy" as if it didn't have any practical benefits. Some of the benefits may not be as obvious as the ad-hoc features that Lodash provides are. But they are still benefits and I'm not the only developer who's switched to Ramda because I was unsatisfied with the developer experience that Lodash gives (don't get me wrong  Lodash is in many ways awesome and impressive). You're right about breaking changes. But this is a young library  its still improving and it never promised stability. What popular functionality do you think is missing in Ramda? I'd be very curious to know.
And this, ladies and gentlemen, is how jquery soup happens.
Ahh, so you want the Zee library version 2.0 that uses a deep learning neural network to rewrite the public interface of the library based on predictions from your git repo. Donate now to the kickstarter for it (for $10k William Shatner will sing karaoke at your wedding).
&gt; Memoization is rarely a good idea I beg to differ, after implementing memoziation into webhamsters the performance benefits are indisputable especially on mobile and lower power devices. http://jsperf.com/javascript-multi-threading/29 When you have a cache hit , the performance of my LG G3 is on par with my Core i7 Haswell development machine EDIT** Here is another JSPERF with the same function but unique dataType argument, if you watch session storage in your dev console while you run this its pretty awesome http://jsperf.com/javascript-multi-threading/30
Initial few videos are free http://player.oreilly.com/videos/9781491925652 
Oh no, I don't see how you can get any work done having to type so many characters on one line. Also, your unfortunate choice of a well tested and engineered library over whatever-just-came-out-last-week is deeply troubling, are you sure you Java/Coffee/Type/Babel Script?
Yeah, but that's a big monolith. You need to modularize it in true node.js style console.log(require('comic-line1')); console.log(require('comic-line2')); console.log(require('comic-line3')); console.log(require('comic-line4')); console.log(require('comic-line5')); console.log(require('comic-line6'));
can you post a jsfiddle of what you already have?
Oh nice! Thanks for sharing, I'll definitely look into that.
This won't help you but the real answer is college. Edit: College teaches you the principles and how to be a software engineer, not just a code money. 
This video [Hey Underscore! You're doing it wrong](https://www.youtube.com/watch?v=m3svKOdZijA) convinced me I should try functional programming with Ramda.js There are a few main points that I'd rather prefer not to butcher, so you should watch the video yourself.
&gt; Just bought a Microsoft Surface My condolences. All joking aside, aren't you stuck with internet explorer in Windows RT? I'm not sure how well an online IDE is going to work there...
You don't need an IDE for javascript. You can just use vim or a text editor of some kind, say, Sublime 
http://atom.io + http://github.com Then use Gulp + gulp-connect + gulp-watch + livereload Works brilliantly on Windows platforms, no need for a hosted system like Cloud9 (C9 is awesome, not trying to discourage it, it's just that it's _so easy_ to do things _right_ in the JS world currently).
This sounds pretty interesting. I've not used Gulp (y'know, Grunt and all). Can you expand on this a bit? Do you personally use this setup? 
So this is a real x86 tablet with Windows? If so, I don't see any reason why webstorm would not work on it.
something else is wrong. and your post is kind of messed up on the array part so I cant see it. maybe try posting it on jsfiddle. i literally copy pasted your code into console and it worked: images = ['asdf', 'bcde'] for(var i=0; i&lt;images.length;i++){ console.log(images[i]) } // prints asdf and bcde for(i in images) { console.log(images[i]) } // prints asdf and bcde probably you have some sort of Object or map, or another function is changing the images var
Thanks, I'll consider it. 
Thank you! I would like to add a save/share feature. I know rails so i was thinking i could add a backend to store json blobs in a database. Is that overkill? is there an easier was to save json objects?
Gulp is pretty much the same thing as Grunt. The syntax is different, that is about it (from my limited experience).
Thanks for the tip! I did notice how they weren't aligned and couldn't figure out why. 
Wow, I didn't play for too long but that seems really well done. Any insight into the porting process?
Am I doing it [right?](http://i.imgur.com/Ko9bmOk.png) :P
No, modifying objects you don't own will always be a bad idea. Virtual methods might put a stop to this for good. http://babeljs.io/blog/2015/05/14/function-bind/
Yeah! LOL I prefer to setup a "setInterval" :) Did you try vue?
[Visual Studio Code] (https://www.visualstudio.com/en-us/products/code-vs.aspx) Free Cross-Platform Code Editor [Visual Studio Code provides excellent intellisense for JavaScript, TypeScript, and C#. ](http://www.johnpapa.net/intellisense-witha-visual-studio-code/)
Web storm should work. If recommend both visual studio code - free and more of a text editor plus, build on typescript and great support for it and JavaScript And also visual studio 2015 - community is free and all are free while in rc
Sure. I have been using Vi/Vim for over 20 years and would argue that all the tool support turns them into dev environments. Sublime is pretty amazing too.
Well, if you actually want to persist the patterns, you need to send them to a server. But I recently made a web synth and added a patch sharing feature that doesn't do any persistence -- it just generates a URL that contains the synth model's serialized state. When the page gets loaded, the router parses the URL and loads the patch. [Here's an example](http://resistorsings.com/106/#patch/Example%20Patch?vca-level=0.5?env-attack=0?env-decay=0.722727?env-sustain=0.575?env-release=0.325?env-enabled=1?dco-sawtooth=1?dco-pulse=1?dco-noise=0?dco-pwm=0.735311?dco-range=1?dco-sub=0?dco-lfoPwmEnabled=0?cho-chorusToggle=1?vcf-cutoff=0.211364?vcf-res=0.535227?vcf-envMod=0.381286?vcf-invert=1?vcf-keyFollow=0?lfo-pitchMod=0?lfo-rate=0.727965?lfo-delay=0.825?lfo-freqMod=0.455504?hpf-cutoff=0). Most of that code is [here](https://github.com/stevengoldberg/juno106/blob/master/js/views/layout/junoLayout.js#L165) and [here](https://github.com/stevengoldberg/juno106/blob/master/js/routers/patchRouter.js). Maybe something that could work for you.
Hey, nice work. The sister companywhich I work forhas a couple positions open for programmers ;) http://www.jellyvision.com/jobs/ 
Awesome, maybe I'll meet you in an interview. Good luck!
 How I delete this on phone?? Mods plz help :(
The problem is that the line var dto = default_object; This does not copy `default_object`, it only gives it a new name. As a result `default_object` is modified when you call DTO. You need to copy the object. Look into `Object.assign` as one option for doing so (depending on your build setup and browser requirements).
This is awesome. I love that game. And you, for doing this.
Depending on the site, if you can execute the code that comes with it like a true browser(or by using the browser, perhaps by disabling the same origin policy), you can save a lot of time. Some times some websites hide data in JavaScript, so if you just parse that data you won't get it easily. Nonetheless this is very useful information.
This is because objects in javascript are by reference. You might not be able to use Object.assign, but if you have jQuery or underscore in your project, look at extend and clone respectively. 
"On Windows you can install it using the Cygwin emulation layer. None of the builds in Windows are satisfactory but it is still possible to get something running." How old is this article? 
You're getting individual characters from `images[i]` which means `images` is actually a string containing `"Array ( [0] =&gt; s/a/1.png [1] =&gt; s/a/2.png [2] =&gt; s/a/3.png )"`, not an actual array. Test it with `console.log(typeof images, Array.isArray(images));`. It looks like your backend is producing the image array via `print_r()` or similar, which JS would indeed read as a string. Dump it with `json_encode()` instead, and on JS's side run the resulting string through `JSON.parse()`.
seems like a valid post for http://www.reddit.com/r/isomorphic too
function nesting is a lot cleaner than prototype indeed.
2nd yr of college was now 7 years ago for me .. would you really remember all of this shit, especially if you haven't used it frequently? 
Oh I meant more like V8 optimizations, 'machine code'. The stuff they talk about here https://developers.google.com/v8/design I would like to understand it better so I can see how my coding effects the actually executed instructions, as I frequently read people say that 'this way to code is better because it can be optimized by the runtime'. I guess its hard to visualize that. 
Or just use Object.create(default_object)...
$ are severely damaging your brain. Don't understand the principles behind a fucking framework but worth $80k a year? You must be totally crazy. Your economy is not sustainable.
Right. I mean you can optionally turn on the asynchronous features of Grunt plugins, but it isn't asynchronous at the *Grunt* level. Steps are executed in order one after the other, unlike Gulp where all dependent steps are triggered at once and flow continues after all have been completed. Grunt 1.X ([grunt-next](https://github.com/gruntjs/grunt-next)) has picked up [orchestrator](https://github.com/orchestrator/orchestrator), to also run in an async manner.
I've used cloud9 for side stuff for about 5-6 months and it's really great, so I second this recommendation. Nitrous.io was also decent last time I tried them and I think they've done a big upgrade lately but I'd try them both before dropping any $, both having free tiers. The thing that sucked about nitrous was the need to have certain things "pre-packaged" in nitrous friendly installs, so if they didn't have a package you wanted you'd have to do either submit a request or create the package yourself or something stupid. I think you have full control of a cloud9 box. In both, node.js debugging through an integrated node inspector is easy to use and 
this article is a copypasta, a old one for that matter too. also, lol var sys=require('sys') sys is deprecated. Use util instead. 
Thanks, this is what I was looking for, very neat.
This post was reported for: &gt; yet another js framework While I somewhat agree with the [sentiment](http://hilton.org.uk/blog/javascript-frameworks-days.png), I don't think that it merits removal lol.
I don't understand why people feel the need to complain every time there's a new framework. I know it's fun, but I'd rather encourage innovation than harm it. You don't need to learn all of these frameworks if you don't want to. Anyway, it looks pretty interesting. I can't seem to access the website as http://seedsjs.com/ though. Am I the only one with this problem?
Not sure if this is a joke, or someone's asking for someone else to do their homework?
Nah, the dude wants you to do his homework. Or work work. For free no less. But you know, someone will do it and he/she knows that. Good Luck Dude!
Disclosure: *Self-Post*. I have finished what I can finally call the first draft of JavaScript Allongs successor. It is written with ECS-6/ES-2015 in mind and touches on fat arrows, iterators, generators, symbols and classes. It also brings in some of the basic ideas from JavaScript Spessore, such as mixins and a deeper dive into thinking about prototypes. For a limited time, Im making the book free to read online. Feedback deeply appreciated.
Anything that strikes your fancy. Too simple, too complicated, doesnt flow, flows, spelling bug, code doesnt run on my machine, pictures are too big, anything at all. The new edition is now nearly twice as long as the original. FWIW, my feedback to the author is, break it into two books, each of which is strong and simple. Or pick a language where you can express strong ideas with fewer pages."
 for (finish=[],i=0;i&lt;output.length;i++) finish.push({ input: eval('arr'+(i+1)), output: output[i] }) hehehe eval() :D
Nice! Thanks for releasing this on a long weekend :) And of course, the whole free thing is pretty awesome. The first book was a solid read. Can't wait to dive into this one!
Good Point! Well, I am particularly interested in its adaptive binding(or at least that's what they claim). just quoting the announcement: "Aurelia has a first of its kind "adaptive" databinding engine allowing rich two-way databinding between vanilla JavaScript and DOM (including Web Components). When binding to an expression, the binding system can select an appropriate observation strategy on a per object, per property basis. It can use Object.observe and Array.observe if present, getters and setters if not and dirty checking as a last result fallback. The system is pluggable and will let developers teach it new ways of observing properties so you can easily plug in custom model/view-model libraries such as Knockout, Breeze, Backbone, etc. which may have their own mechanism for storing properties and raising change events." The modularity looks promising as well. But yeah, in general a few frameworks are "Real" game changers, others just claim to be ones.
Thanks for making this free to read online! I'm excited to check it out. I did find one small thing to fix though, in the **why the six edition?** section, it reads: &gt; ECMAScript 2015, also called ECMAScript 2015 I assume one of those 2015s were supposed to be a 6.
Two way databinding is an anti-pattern. Pass.
Agreed! But you might want to read this article in order to know how Aurelia deals with binding. http://eisenbergeffect.bluespire.com/aurelias-adaptive-binding/
Great to see an update to this! Seems like there's a CSS reset rule making the inline code tags show up in a non-monospace font. (Chrome 42 on OS X 10.10) I think the "d" in Giro d'Italia isn't usually capitalized.
To be fair, Aurelia only uses two-way binding for form elements, which generally makes sense. I understand that there is some benefit from having to be explicit about it, like in React, though.
Furthermore: Here's something that's especially irksome to me about Aurelia (and a few other frameworks). ES7 support. TypeScript support. CoffeeScript support. For heaven's sake! Stop it! This is why Aurelia, by definition, **can't be the front-end equivalent of Rails or Django**. Choose a language (hey, ES6 JavaScript is staring you right in the face!), define your idioms, and commit to it. Part of the reason people use frameworks is so that *they can use already established idioms to save them hundreds of hours of mental overhead* when it comes to architectural decisions, implementation strategy, refactors, etc. **This is the value prop for a framework.** If you don't understand this, your framework can never truly be "great." You might spend a couple of minutes to an hour setting up an app. Your team will collectively spend hundreds or thousands of hours deciding on architectural patterns, refactors, etc. as the app scales. If a new version of the language comes out, as the developer (or team) for a framework, your responsibility is to redefine your idioms and release an updated platform. You just saved hundreds of thousands of man-hours of people deciding things like "do I use a generator here? Where do I use async functions?". That's where you add value. If your framework can't answer these questions for people, you are setting yourself up for failure.
I'd be glad to work in your company, but I'm not in the U.S. and I don't plan to live there too, and I'm not sure working from home would be possible :) But anyway thanks for the proposal ;)
It does. Thank you! 
I didn't say it was never a good idea, just rarely. The post I was replying to was essentially saying "When is it not a good idea?" and my point was that it's not a good idea far more often than it is a good idea, so it's better to consider the times when it is a good idea.
Thanks for sharing. Good to know what options are out there
You can do one way binding very easily.
OooOo thanks!!
Shit this guy made a todo list. Time to move on to the next framework everyone! 
``` todos: Array&lt;{ value: string, created_at: Date }&gt; ``` ng-wat?
A new JS framework ! Its Monday already :D . I'm thinking of starting a new website : http://www.jsframeworkoftheweek.com And a new ebook : jQuery Devs Hate Him ! Pimp Your Resume : How to write your own Javascript Framework in 5 days.
I think it's a way of specifying that `todos` should be an property on the class which will be an array containing objects that have properties `value` and `created_at`. It's a typescript (and technically babel and traceur) thing, not an angular thing. I think more typically you'd see a class called `Todo` and it would be defined as `Array&lt;Todo&gt;`. Or by defining an interface, if you were using typescript.
&gt; Part of the reason people use frameworks is so that they can use already established idioms to save them hundreds of hours of mental overhead when it comes to architectural decisions, implementation strategy, refactors, etc. This is the value prop for a framework. If you don't understand this, your framework can never truly be "great." Have you really looked at Aurelia or are you just talking out of your a**? The way Aurelia "supports" all of these languages is that it does NOT pile up any hurdles in front of any languages of your choice that are eventually compiled to JS anyway. 
&gt; ES7 support. TypeScript support. CoffeeScript support. For heaven's sake! Stop it! I guess I could understand if it was "*ES7, TypeScript, PHP or Brainfuck!*" It's just JavaScript, so it makes sense that it supports compile-to-JS languages.
It really feels like this: https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1563 times, representing 2.4119% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_crk4dk4)
I like Aurelia. It's like Angular without the awkward. But I won't use it until it I can use it with Browserify or webpack instead of jspm. jspm proponents like to say *There's no build step in development!* but it seems that's not true for all but the simplest of of apps. *Hello, world!* in a jspm based Aurelia development environment currently takes 238 requests, 233 of which are for JavaScript files, and over 4 seconds to load: http://i.imgur.com/Vhufsmn.png I think it was a little more tolerable with BrowserSync but I can't remember. I stopped looking into it when I found out that bundling an app for production meant digging through your config.js (which, for the *Hello, world!* app I mentioned earlier, is currently [119 lines of generated code](https://gist.github.com/anonymous/3634ec9a5d33e8d662a9)) to produce a *jspm bundle* command because [*jspm bundle* is unable to detect the modules that Aurelia imports dynamically](https://github.com/jspm/jspm-cli/issues/635). It looks like [they're going to solve that problem by going the Ember CLI route](https://github.com/aurelia/cli) which I find disappointing.
I've never used Aurelia, so I can't comment on the quality of the framework. But what really bothers me is the fact the literally every single article or post about it has 'Rob Eisenberg' or/and 'Eisenbergeffect' in the title. Which gives me the impression Aurelia's main reason for existence is to boost the ego of its author.
All of the snippets are clearly labelled. Also, the very fist line reads: "TodoService in Angular 2 and Angular 1 both in TypeScript and ES5".
Seeing Durandal also didn't really pick up, i have doubts it will be a big community. It really needs a big tech to back it up, like angular got.
Could you elaborate on that?
Why is it an antipattern? I've heard it a lot, but to me it seems like the best we've got (of a lot of bad ones). I still feel that the thing you code, should be as readable and clear as possible. I don't care if its going to be parsed, i care that i can see what its doing and reproduce it easily. Plus i'm not a fan of the whole "put everything in a single file" way of doing things. Projects like Angular (and im guessing Aureliaio) are excellent to work on with multiple people. The problem of backends for Javascript frameworks is very annoying and i hear ya. Though i'm not a fan of Rails or Django, mostly because its so very different (in syntax and logic), plus is annoying to setup on Windows. Thing is, the NodeJs solutions for backends aren't very common yet, and either require extensive knowledge of the techniques or a big wallet to get it hosted. Some free solutions like Firebase and alike seem quite nice at first, but as soon as you are going to get some visitors, its costs will skyrocket. Hosting a PHP/MySQL server is still the cheapest solution, but making an API of it, still requires some knowledge unfortunately. I haven't found one that is easy and simple to setup as a backend, so i don't have to dive deep into another language i'm not very interested in anymore.
I'd disable audio by turning down the volume all the way - it seems like it's trying to output DC, which is potentially harmful to speakers.
&gt; The front-end and back-end code living as one, really rubs me the wrong way. You can easily separate the two and once its deployed the server side code is invisible to the client.
If you click options you can disable audio. It says it's experimental. 
Cool. Thanks for sharing. 
ok also I found BASIC programs from here work http://www.calormen.com/jsbasic/
PLEASE NOTE: The original JavaScript Allong has been retired. The updated edition is JavaScript Allong, the "Six" Edition: Book: https://leanpub.com/javascriptallongesix Free to read online: https://leanpub.com/javascriptallongesix/read
Though TypeScript technically a superset of JS, the coding style it tries to promote limits its user in just a subset of JS. I mean, it focuses on promoting a classical OOP system, less functional approach. It's not actually bad, and might be easier for people with C# and Java background, it is just boring to me. I have much more fun coding in pure Javascript.
I agree that maintainable code is essential over the long term -- but I have very limited access to computing resources (typically 3-10 hours a week) -- so, between very limited time for computing and fear that access to computing resources might disappear at any moment, I am using a very "hack and slash" approach and just trying to pack as much new working code into each computing session as possible. If circumstances change and I can gain reliable access to computing resources, then I will take the time ot go back and clean up the code. My thinking is that really clean next to nothing is much less likely to get anywhere than brutally hacked software that actually does some kind of real work. Again, in general, I would agree with you -- any successful software spends the vast majority of its lifetime in maintenance and therefore making maintenance reasonable and efficient is the highest priority. 
PLEASE NOTE: The original JavaScript Allong has been retired. The updated edition is JavaScript Allong, the "Six" Edition: Book: https://leanpub.com/javascriptallongesix Free to read online: https://leanpub.com/javascriptallongesix/read
Fantastic! Thanks for sharing :)
&gt; http://www.hamsters.io/ is a blank page Yes currently it is a blank page, I am working on the website however I am only one person and personally life takes precedence over non profit work. &gt; Add a package.json to keep track of semantic versioning, and to allow you to eventually publish into npm. Software that's only available via github isn't very useful to automated build stacks. Eventually the library will be published on npm however node does not support web workers and my plans to publish a node compatible version are on hold due to that. &gt; No tests? For shame. Test are used privately currently, you are free to write test to test your own functions making use of the library. The need to publish my own test never seemed that important. &gt; Proper and thorough documentation before even mentioning the library to the public for review. The website is still in development, the readme is very thorough and should explain everything you need to make use of the library, is there something specific that you are confused about that I can assist with? &gt; A new name. Hamster.js is already well-known. The name Hamsters.js is short for WebHamsters, the name of the project is not Hamster. Any similarities in the name are by coincidence, the name will remain. 
This looks like mixins or monkey patching to me, not composition. Composition implies I can compose behavior from multiple sources/instances to make new more complex behaviors. Eg given two views `viewA` and `viewB` that each implement their own useful `render()` method, I can use composition to implement a new `render()` method on my composed class: render: function() { this.viewA.render(); this.viewB.render(); } I think the article is equating "combining methods from other classes to make a new class" (mixins) with "combining instances of classes" (composition).
Hi /u/edravix, posting this [once](http://www.reddit.com/r/javascript/comments/36wf9r/help_to_build_the_best_javascript_logger/) was enough, please don't post again. Thanks for your understanding!
Hi /u/indianDeveloper, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `rockyj.in`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [rockyj.in](/search?q=%28and+site%3A%27rockyj.in%27+author%3A%27indianDeveloper%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|22|69%
I really hate domain specific languages in templates like this: &lt;label repeat.for="employee of employees"&gt; &lt;input type="checkbox" model.bind="employee" checked.bind="$parent.favoriteEmployees" /&gt; ${employee.fullName} &lt;/label&gt; The magic `$parent` binding makes me nervous, along with having to learn yet another language different from what i'm using to write the rest of the frontend, introducing a lot of mental context-switching I think React's approach where you just use the host language (just javascript) to create your UI is a much more powerful option employees.map(e =&gt; { return ( &lt;label&gt; &lt;input type='checkbox' checked={e.favoriteEmployees} /&gt; {e.fullName} &lt;/label&gt; ); }); We're just using the tools we're used to working with (`map`ing over an array basically) to build up the interface, along with some niceties provided with JSX (the tags that will desugar to function calls) If you really need the two-way binding, you can layer that in with helpers (https://facebook.github.io/react/docs/two-way-binding-helpers.html) 
See my response to other comment about "compile-to-JS." Cheers.
&gt; node does not support web workers I was unaware. Parallel.js is available on npm; are they doing something fundamentally different from your approach? It seems to be a web worker implementation. &gt; The need to publish my own test never seemed that important. It's paramount. You must publish automated tests with a highly-discoverable method of running them if you expect your code to be used by others. There's no exception, except when prototyping your own code without any expectation of adoption. In fact, the very first thing I do when I see a new library on here is check for a /tests or /specs directory. Then, I look inside for proper example usage of the library within those tests. If the tests are written well, then the library will likely be written well. I don't even look at the library itself until after the tests have been verified as comprehensive, easy-to-read and most importantly: meaningful. &gt; the readme is very thorough and should explain everything you need to make use of the library The README.md makes claims about functionality that I cannot validate without setting up a project of my own, and writing my own tests to verify. If I did this for every new library, I'd never get coding done. This is yet another reason why automated tests are so important. I should be able to type `npm install webhamsters --save`, then `cd node_modules/webhamsters;npm test` to know immediately that: 1. The library is working according to the library author. 2. The library is working in our environment. (Maybe we're using iojs instead of node, or vice versa. Maybe we're using an older version of node. You never know.) 3. There is a place I can go to see working examples of the code. Please don't take what I'm saying as trashing your library. I like choice in software, and I like the idea of calling my web workers hamsters. I just hope that with going on 19 years of experience in writing custom software and libraries for others, you'll accept that automated testing is necessary for public libraries and that the debate on this subject was done and over before I had even wrote my first script.
Try this one: http://porkrind.org/a2/
If it helps, Aurelia encourages the use of ES7 and is actively developing with it. I think the website lists those languages only because there are some people who prefer TypeScript and CoffeeScript and may reasonably wonder if they can even use those languages given the funky ES7 syntax shown in the docs. &gt; You can compile Python to JS, and yet I don't see Python listed as supported. Yes, but TypeScript and CoffeeScript are the most popular compile-to-JS languages.
I'm pretty sure this isn't composition. Not as it's conventionally known anyway. Composition would be having a field in one object that was of the second type. This is using "mixins", which is really a form of inheritance.
Hey, if you're only spending 3-10 hours on throwaway code no one is likely demanding quality from you. I understand the tradeoff there. However, I would encourage you to start making clean code your habit - before long, you will find you don't spend more time on it, and you should start to see that you spend less time in debugging because you'll make less mistakes.
You're doing mixins again :) Here's an example of it in python, not dissimilar to your own of "composing" different classes into one: http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful/547714#547714 from werkzeug import BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin class Request(BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin): pass 
Don't take this the wrong way, but I think most people doing such non-trivial work are going to need to have the degree of expertise that allows them to make sure optimizations in the first place.
Inline event handlers is not creating unnecessary coupling. Rather, it is having the document drive the application, pulling in components as and when they are relevant and creating a single source of truth about how the application operates. I've worked on projects which have flown this 'separation of HTML and JavaScript', and let me tell you, first hand - at scale, it just doesn't work. In projects like that it's impossible to reason how the application will operate from any part of the code, and the scripts end up making so many assumptions about the DOM that it's only 'decoupled' in the sense that the couplings are *invisible* and *implicit* - the worst sort. You end up with all this 'invisible' configuration in the form of files happening to interoperate "accidentally", and the only way to guarantee it still works after you've made changes is to run loads of slow-as-a-dog functional tests. We should be separating concerns, not technologies. There is nothing wrong with &lt;button data-bind="save"&gt;Save&lt;/button&gt;. Far better than the JavaScript having to know how many save buttons there are, where they persist in the document, and which documents the JavaScript will be run against.
What about React? Loosely coupling your HTML to your JavaScript via *components* that need explicit rendering calls to update seems like the most logical approach to me. You don't even need to use React for this (though it is the fancier method). Avoid manipulation of the DOM via querying specific selectors and stick to just redrawing entire components. **Edit:** *"We should be separating concerns, not technologies."* No. Technologies are concerns. Any interface between systems where there's a potential failure point should remain separate *unless* they're so reliant on each other they become indistinguishable. HTML and JavaScript are not reliant upon each other, so tightly coupling them makes very little sense. We can generate HTML on a server, or we can do it with the client. We can run JS in a browser, or as a server-side language with node.js. These technologies can be used separately for very different business applications. Keep them separate. You could make an argument for tight-coupling of HTML and CSS as the two are nearly exclusively used together and reliant on each other. The same is not true for HTML and JavaScript.
Function body size, keywords like try, catch, debugger.
&gt;I downloaded node.js, and built the javascript system as they described, &gt;&gt; { &gt;&gt; "cmd": ["node", "$file"], &gt;&gt; "selector": "source.js" &gt;&gt; } JSC is built in. That'll get it running 100% in sublime if you replace "node" with "jdm". Also if you do so, jdm uses debug('words'); instead of console.log('words'); to print to console. P.S. Sorry about the formatting. Using a phone. 
Deploying Rails and Django is just as a hassle as deploying NodeJS applications. Security-wise and cost-wise they are not as cheap/easy as php/mysql. But like i said, i'd rather use full-stack javascript than switching for another language i have no interest in learning. I know about some of their patterns, but they don't offer more than i can do with Node. I wouldn't be surprised if there is something new soon that removes the separation between backend and frontend (or automates it) so you can focus on what you want to build and not hassle on how you run it and where you run it from.
&gt; I was unaware. Parallel.js is available on npm; are they doing something fundamentally different from your approach? It seems to be a web worker implementation. I'm not familiar with Parallel.js or it's approach however looking over it's documentation suggest to me that node logic may actually be running on the main thread. &gt; The README.md makes claims about functionality that I cannot validate without setting up a project of my own, and writing my own tests to verify. Such as? You've provided no explanation for what you are confused about or what the readme does not cover. Your original complaint has now shifted into a complaint about testing. What happened to being confused about documentation? &gt; I should be able to type npm install webhamsters --save, then cd node_modules/webhamsters;npm test to know immediately that: You have quite high expectations for something that is given to you for free, people who expect the world in exchange for nothing are the exact reasons I almost never released this open source. &gt; I just hope that with going on 19 years of experience in writing custom software and libraries for others, you'll accept that automated testing is necessary for public libraries and that the debate on this subject was done and over before I had even wrote my first script. Your years of software experience are irrelevant to the discussion, as mentioned previously testing has been done. I appreciate your suggestions but your responses imply to me that you are *expecting* X,Y,Z but providing 0 insight into why X,Y,Z are important to your needs beyond convention. The readme should be sufficient in getting started using the library, having to download a library and manually add it is unfortunate but this project is called WebHamsters it's meant to be run in the browser currently and I'm not aware of other libraries meant to be run the browser where downloading it manually wasn't an option. Nor have I run into any reason why manually adding a library to my project prevented me from doing a proper deployment of my application. If you wish to see the website finished sooner and possibly the library on npm do not hesitate to donate to help speed up the development process. This is a project managed and developed by one person, without any funding from anyone else. I bear all the development time and cost, expecting anything beyond what is provided gives a sense of entitlement that puts a sour taste in my mouth for producing more open source software for the community. 
While it might be better performance-wise, I'm still a big fan on writing code thats easy to read and easy to understand. Mixing in all kinds of languages to say "yeah you now don't need two way databinding" is ridiculous and should not be a new standard. When i look at most React projects and examples, i tend to say "i'm never going to use that because it looks awefull". Mixing plain javascript, with specific javascript (like Angular or React) with HTML and CSS is awefull and to me looks like an antipattern. Sure, you might have everything that is connected in one view, but you simply cannot share it easily and expect others to continue your work as it is such a hassle to find out what everything does and how it is connected elsewhere. If i have an Angular view, a controller and some files to bootstrap the app, i can give it to any developer i want and they will understand how it works, they know where the data is at and they can inspect it with the various browserplugins they have (like ng-inspector or batarang). And as a proper Angular developer you should know how the digest cycle works and that you shouldn't be messing with it too much. Only if you absolutely need to, but more often than not it is not required. If you manage to make it delay by 8000ms, you aren't making Angular nor Javascript, you are making spaghetti.
Wow, that's awesome.
Hey, thanks a bunch for the resources, I might PM you if I get completely stuck if thats cool ? =]
im not a 3d programmer sry u would do better just to post or i always loved asking on irc for instant help
Didn't think anyone used grunt anymore.
Nice. Set targetFPS to 999 for a pretty dope light up effect.
The framework is irrelevant. If the language let's you do it, then anything written in that language can do it.
There's nothing wrong with DSL's when they serve a good purpose. React's way hoists HTML into the JavaScript application, while Aurelia/Angular's way leaves display concerns in the HTML. In my experience, the latter is best for maintenance.
I think you can use it if you start simple and test first. I find that if you don't test first, you end up not getting most of the design benefits of TDD. Find a simple project and try to do it all in TDD. You'll encounter a some obstacles but keeping the cope of the application small can help you understand the problem space that you'll be trying to solve later in large applications. I was introduced to TDD by the [Clean Coders](http://cleancoders.com/) video series by Uncle Bob, really great series, refined a lot of my understanding of programming and TDD. Good luck!
And now by https://thegrid.io/ AI designed websites
Can you really say they're backwards compatible if a lot of the array methods throw errors?
What' so great about immutable data structures. I'm not a programmer. Why would this be a good thing?
This. Rethink is a delight to work in, and works especially well with React. If you want an ORM, then I really liked http://thinky.io/. But you really don't need an ORM to work with Rethink. I haven't had much success with SQL ORMs in Node. They always seem to lack some vital feature or have some annoying performance edge case. (For example, Sequelize would issue a query to update all fields, even if only one field changed.) I hear that the situation has improved a lot though. My favorite SQL ORM was most definitely http://docs.sequelizejs.com/en/latest/ but http://bookshelfjs.org/ worked well too.
I'm very happy with [Sequelize](http://docs.sequelizejs.com/en/latest/).
This is pure JS? *Edit this is inspirational stuff, thank for sharing 
Oh trust me, i'm very familiar. I know Heroku and i've tried them. But i've looked further than how easy things are. I looked at how much it will cost me if something gets popular. I looked at how much it will cost me if i try something more than a demo. Its pricing will skyrocket as soon as you get some visitors, even if you aren't making any money. Just like i said previous. Its nice for prototyping, but i'm not going to stop there, i need to be actually deploying stuff and Heroku isn't going to be that place. Much like other services like it. The cost of hosting a PHP site is so much less than the cost of hosting Node, Meteor, Rails and whatnot. Especially if you are getting a nice bunch of visitors
I tried once. Here are the links! Demo : http://html5audiovisualizer.azurewebsites.net/ Blog: http://raathigesh.com/Audio-Visualization-with-Web-Audio-and-ThreeJS/ Source: https://github.com/Raathigesh/HTML5AudioVisualizer
http://en.wikipedia.org/wiki/Immutable_object 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Immutable object**](https://en.wikipedia.org/wiki/Immutable%20object): [](#sfw) --- &gt;In [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_computer_programming) and [functional](https://en.wikipedia.org/wiki/Functional_programming) programming, an __immutable object__ is an [object](https://en.wikipedia.org/wiki/Object_(computer_science\)) whose state cannot be modified after it is created. This is in contrast to a __mutable object__, which can be modified after it is created. In some cases, an object is considered immutable even if some internally used attributes change but the object's state appears to be unchanging from an external point of view. For example, an object that uses [memoization](https://en.wikipedia.org/wiki/Memoization) to cache the results of expensive computations could still be considered an immutable object. &gt; --- ^Interesting: [^Reference ^type](https://en.wikipedia.org/wiki/Reference_type) ^| [^ColdC](https://en.wikipedia.org/wiki/ColdC) ^| [^Immutable ^interface](https://en.wikipedia.org/wiki/Immutable_interface) ^| [^Object ^\(computer ^science)](https://en.wikipedia.org/wiki/Object_\(computer_science\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crl5itv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crl5itv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Don't know why you're getting downvoted for asking a question. It is pure JS rendering to a canvas.
ty all
when your looping through objects .length doesnt always work, the object could have a function attached to it also i is " &lt; tpRef.length " ... and you are using i on another functions output -- theres literally no guarentee its gonna have the same amount of members as tpRef... step 1: console.log(y.getElementsByTagName("LongitudeDegrees"),"I:",i) as the first line in your for loop step 2: see if that function getelementsbytagname even returns an array longer than i (both values are logged there)
That SO solution is more elegant. It uses map to create a new array of *just* the values, then passes that to the built-in Math.max. Your solution is slightly more complicated and basically does just what Math.max does anyway. Edit: However, I knocked together a quick jsperf and it looks like the Math.max version is slower: http://jsperf.com/math-max-vs-ternery Personally I'd still go with Math.max as I find it easier to understand, and I really doubt there will be many situations in which this'd be a performance bottleneck.
PHP+jQuery might be enough for simple products but otherwise, if you don't pick a framework, you will end up building your own. So, how much time will you take to build an equivalent to Angular? Meaning a framework that is tested, compatible across all modern browsers, maintained by a lots of experienced developers and so on. Are you sure that you are able to build something that is at least as good as it? Then it's all about your needs, experience and dead lines. Sometimes Angular might be an overkill but if you need 90% of its features, then you should consider using it.
I am also considering a switch, main reason is that I am spending a lot of time in angular making everything efficient. Maybe im too noob but some parts of my application contained 10k watchers 
Bower is very bad at being a dependency manager. Compare it to what Maven can do and you'll understand ;)
Use webpack and it'll strip all unused code. 
I use ImmutableJs, and I think the different API is actually nice, since it's extremely explicit about whether you're using an immutable structure vs a native structure. It helps eliminate confusion.
Adding to /u/spaceghost0r excellent answer, the idea is to discern that your process is composed of two actions. One is: "for an element get it's `val` property", another is "find the maximum of some values". So you try to: identify simple operations, and then compose those. In fact, you could even take it one step further in the proposed SO solution by giving a name to the `function(o){return o.y;}` function. You could name it `pluck`... function pluck(property) { return function(object) { return object[property]; }; } With this in place the "elegance" becomes more apparent. Every step is a simple/single operation/function and the process is simply composing those operations. Math.max.apply( Math, array.map( pluck('val') ) ); // or if you prefer to be more explicit: var getVal = pluck('val'); Math.max.apply( Math, array.map( getVal ) ); 1. `pluck('val)'` picks `val` from an object 2. `map` applies a function on a whole array 3. thus, composing those, you get an array with all the `val`s 4. Math.max is already available, so no need to implement it, just compose it with the previous stuff. All this, if what you're aiming for is "elegance", of course.
People would probably trend towards the other way though because it's just using native methods and with ES6 it could even be simplified down to `Math.max(...array.map(o =&gt; o.y))`. One thing to note is that your method also doesn't account for negative values.
That's like comparing hello world to Oracle. 
So, out of curiosity, does this workflow also handle css files? Or just js files? One of the benefits for me is the combination of Bower + Wiredep - it automatically adds the relevant js files and css files to my project.
no. I'm not saying to compare everything else Maven can do. Just its dependency management. It's wonderful. NPM is the closest thing we've got to it. Bower is just a toy.
That's still not the point. What if Package A requires v1.2 of Package B, and Package C requires version 1.4 of package B. NPM will include both 1.2 and 1.4. Bower will ask you to select one and make everyone use it.
Yeah i don't get the holy wars. Neither of them is really stopping you from using the other... At the very worst you can point either of them at a git repo and call it a day if you want.
Fixed, thank you.
isn't a flat dependency file better for browser-land? I can see nested dependencies getting really messy and bulky.
I think this is a difference in philosophy then. I've run into issues where a minor/patch change "should" work but breaks things. Underscore's maintainer is notorious for making breaking changes in non-major versions. For this reason I trust a library's author to make whatever decision they need for their dependencies, even if it means hard coding the version number and duplicating some libraries. Most NPM libraries do a good job of using the ~&gt; operator so this doesn't seem to be a problem right now. 
What this experienced programmer did? Some moderately popular packaging tool with 1% LOC of a project he want to do in 2 days? Which is open source and has no requirements or must implement input from business? Nothing in his GH account is relevant to discussion.
For me that is the main reason, a difference in philosophy. Bower means i will have as little "bloat" as possible in my final output, whereas NPM can very quickly explode to dependencies of dependencies of dependencies which can routinely get 10+ levels deep. Plus you can use either one, both, or neither. They don't really interfere. Personally i use both, NPM is what i use for server-side deps, and bower for client side. Sometimes this gets muddied, i have 2 server-side deps from bower, and a few client-side deps from NPM on a major project of mine, and it works just fine.
I see. Tried to read about react. Still not very familiar with its concepts like states, components, props etc. To move out of angular, you'll need to use flux too right? Read that react is just the "view" layer.
You'll get much more information at /r/dartlang.
You can experiment online using either https://babeljs.io/repl.html or http://www.es6fiddle.net. If you'd like help getting larger projects going, try asking this question as a self-post.
Incorrect.
Then install all your dependencies on the top and don't rely on nested dependencies. For example: npm installl backbone #underscore is now nested npm install underscore backbone #underscore is not nested
It'd be great if bower supported package.json and the browser field.
Bigger apps is better than dependency hell. You can use the list command to inspect dependencies and adjust them to reduce overhead. Resolving dependency hell is much harder. That aside, in my experience, most front-end libraries don't have a ton of dependencies. 
Most frameworks also share concepts and ideas. This means that the more frameworks you learn, the quicker you can pick up future ones.
Here's a bit of code that should help. I'm no expert, but let me know if anything is unclear. if (/*code to check validity goes here*/) { function redirect() { window.location.assign("http://www.google.com") /*if if conditional is true, redirects to Google*/ } }
Mmm... _sense_ will derive from what you aim for, really. For example, if you were aiming purely for performance none of this would make sense. In general, the solution of composing simple operations main advantage is clarity and reuse, because each operation does one single thing. With a more complex logic I would still try to break it down to simple/single operations and then compose them. It would depend on the particular case whether one of those simple operations fits the use of `reduce` or not. The telling thing for me, I guess, is that the function you're passing to reduce can't be _cleanly_ named. "maxFromFirstAndValOfSecond"? That clearly tells me it's doing too much. You could, of course go... array.map(function(v) { return v.val; }).reduce(function(k, v) { return (v &gt; k) ? v : k; }, -Infinity); ...which could then be... array.map( getVal ).reduce( max , -Infinity ); This is clear and mostly simple steps/operations. In this particular case, yes, `Math.max` is already done, but in any case doing it in separate steps offers more clarity. From another perspective, using _big_ `reduce`s reveals a way of thinking much closer to a `for` loop. Breaking it into simple operations and then composing up, is a more functional approach. (All this is just my personal opinion/taste, of course :) )
As a user of both for equal amounts of time, I agree with this list wholeheartedly.
Thanks, this is what I was looking for, not just for this specific case but also to write better JavaScript code (maybe in few years :) ).
I have devised two ways to handle that issue: 1. load templates in the appropriate language - this allows for a lot of flexibility, but will cause a higher latency if you switch languages; 2. put templates and textual content in different objects so you can replace one without touching the other, but you'll have to load multiple objects, so the HTTP headers might cost more than you save.
I just don't see the point of this at all. - Why do the encryption on the client? Nothing is gained, it introduces tons of potential security issues, and your encryption key is completely insecure (and sent to the server anyway). - Since the encryption key is in the download URL, what's the point of encrypting it at all? The server can decrypt since it has the key, anybody with the URL can (obviously) decrypt. So what does the encryption buy you? You are already using SSL which encrypts the transport. Your code is also nested function hell with what is essentially global state, kind of nasty. Interesting learning experience and application of technologies though, I'm sure.
&gt; load templates in the appropriate language - this allows for a lot of flexibility, but will cause a higher latency if you switch languages; I really wonder how frequent of a scenario that is. &gt; put templates and textual content in different objects so you can replace one without touching the other, but you'll have to load multiple objects, so the HTTP headers might cost more than you save. Well, if everything is compiled down, I might have three files: the app, the compiled templates, the string resources. And for most people, once loaded it'll be cached by the browser. So with point #2, if someone changes languages would you reload the page, or mass-replace all the strings? It seems doing a ton of document.getElementById('my-cool-label').innerHtml = STRINGS['en']['my-cool-label']; a hundred times over might be expensive :/
&gt; The "DDOS github and your workflow is down" is not a valid one for me. Because as said in the articles, bower begins to have its own registries and mirrors. Also github is almost never down and if github is down, bower will not be the only one impacted (is your favourite doc hosted on github pages? oops). And what if the primary npm registry is down? Yes you can use mirrors but you still have to change a lot of configuration on your local environment, CI buils, production servers, ect. this was the primary motivation for moving away from Bower. being able to run an in-office repository is important. We do it with Maven (using Sonatype Nexus) and now we do it with NPM. At the time it was not possible to do this with Bower, and now that we've made the switch, no point in going back.
You can use npm without (directly) using Node.js for anything.
You can use npm ~~shrinkwrap~~ dedupe to minimize the tree.
I agree. In addition, the reduce logic is going to be easier to maintain and extend in the future. I would only add that the OP should use Math.max() which gives both the elegance and the performance but does have a bug if all values are less than zero -- I fixed this in my example by passing a real value instead of the default zero (edit: someone already pointed out this bug). arr.reduce((max, n) =&gt; Math.max(max, n.val), arr[0].val);
React isn't really a framework. It's a library. A good (but simplistic) way to remember this: A framework calls your code, whereas you call a library's code. Modern frameworks like Meteor, Angular, Aurelia, etc. are full systems of components/libraries/modules all handling different tasks. A framework might have a router, a logger, validation, data-binding, etc.... React is only the data-binding piece. It's just a library to handle data-binding/templating (rendering, in general) in a fast, performance-focused way. In a single page app, you would still need to pull together or write your own libraries to cover other needed functionality. This is why people use full frameworks. Of course, you don't HAVE to, but it helps to have a solid set of tools to work with when working on a large, complex single page web app. Besides this, having a clear set of conventions (how the framework behaves by default) makes it much easier for teams to work with the app, as they don't have to constantly be asking each other how or why things were done the way they were. They can just follow the conventions of the framework and know much more quickly what's going on. Also, jQuery is not very performant, and the JavaScript web development world is moving away from using it altogether now, as it's really no longer needed with the capabilities of modern JS (ECMAScript 2015/2016 aka ES6/7) &amp; modern JS frameworks. As for PHP, the world has mostly moved on beyond it now, I think.
I do. It's nice to use. Do you have an actual question?
well I don't. We use underscore's template engine for its simplicity. so now I'm wondering how this would work: User visits page, browser is configured for french. Server responds with FR-STRINGS.js which contains an object just called STRINGS. User is using their friend's laptop though, so switches language to English. Page reloads and user gets EN-STRINGS.js which contains the same object just with english strings. Rest of code does not care. Thus, in my templates, I'd do something along the lines of &lt;%- STRINGS['whatever-string-I-need']; %&gt; I still feel like I need a server-side component to this for the initial page though. We're running under Tomcat, so a Java servlet seems necessary to spit out anything static to the browser, including strings. For example, would it not make sense have say, the &lt;title&gt; tag spit out by the server?
considering that any other language that has good dependency managers don't separate UI from non UI components, I'm not sure why Javascript has to be any different?
I agree client side encryption is sort of novelty but yeah the idea is that unencrypted data is not transferred and you also don't trust server side with the encryption. The key is not sent to the server it is a hashbang url? When you say 'nested function hell' this is what I would like to know more about. Are you talking about the node app or the client side js. Is there anywhere you can recommend for me to read up on better practices? Or any examples of a small but well laid out js application?
I'm not really interested with debating with someone who looks at a person with more than a hundred high-use repos and incorrectly states that they have a single low importance project. I'm not really interested in your claim that if I don't do your research into the man for you, then the rest of the thread has become less reasonable. I have said nothing about his private life. Please have a good day.
IE 8 is definitely not 15%-20% of the web..
If you honestly are recommending shrinkwrap to flatten the dependency tree then you are doing it very wrong. Shrinkwrap is mean to lockdown dependency version numbers, and it is a very powerful but clunky tool. It is not meant to be used to flatten dependencies (even though it *can* be used for that). Plus (IIRC) shrinkwrap is an all-or-nothing system, you can't just apply it to a few things. Browser does this out of the box, and it is MUCH simpler and doesn't require you to re-shrinkwrap your entire project every single update. 
Yes you can but you still have your build tools (e.g. gulp/grunt) mixed with your client deps. That said, build stuff in general are in *devDependencies* and client just in *dependencies* so they are "separated" in a way but it make more sense to me to have at least separate files).
Do you want the form to be submitted and *then* redirect the user afterward, or do you want to redirect *where* the form is being submitted to?
What is the title tag's content but another view to receive rendered content? It doesn't matter if you use underscore's template engine or mustache or handlebars or any other old template engine.
I stand corrected, I meant dedupe. Sorry about that.
Or use JSPM which fixes pretty much all of these issues without mingling server side and client side deps.
it reloads the current page, and that's the problem haha. The control just blanks out and looks very unappealing. 
someone experience? Thanks.
sure, I can wrap &lt;title&gt; in a view class of some sort no problem. But what concerns me now is the performance. I'd essentially render the DOM then populate strings where needed, all in the browser. I figure that it would be much much faster to at least get the initial layout pushed to the browser (with localized strings in place already). And after that point, anything that gets dynamically rendered would just fetch variables from an object contained in a js file that has the language as its name (FR-STRINGS, EN-STRINGS, DE-STRINGs, etc etc etc ya know?).
The keyword is "internationalization" or "i18n" ('i' + 18 letters + 'n'). Just search for that (e.g. *jinja2 i18n*).
The problem is that you need the form to submit the data *before* you redirect it. You are probably going to need to send the form data using AJAX and then redirect afterward (or just print out a confirmation message).
Ah you're right, misinterpreted the code. I better understand the purpose now. Nested function hell was a minor nitpick. At one point in your client code you are indented more than 8 tabs, with at least 5-6 functions nested within each other sharing a global state defined globally outside. https://github.com/threesquared/sendsh.it/blob/master/public/js/script.js#L131 The best ways I know to mitigate this are to use Promises and more recently ES6 generators. Just makes code a bit easier to follow. Overall though I'd say your code is fine and my initial analysis was flawed.
Well, i think the point is still stands - this kind of self-employed work where you do all design and decisions have nothing to do with deadline/budget restrained team work. Dont you agree with that? I am not saying browserify is low impact product for node or frontend development, just that i can name 10k companies who has more clients than browserify has daily downloads from project templates. And his below top10 projects has less downloads than my FB page views. But may it be best most popular node package, how it has something to do with this thread? Should we call java better? Or any other java artifact which can beat number? Any developer of that artifact superior? Should we count in only open-source contributions or company workers as well? Should i get some advice on how to act in life and how software world works from them? Should i ask Hans Reiser as well just because he wrote decent piece of software? 
Problem is you don't really know how Math.max works. We like to assume the standard libraries are efficient and in this case use O(n) time and O(1) space, but that's not always the case. (Some library programmer might be enamored with recursion, for example.) We also *know* that creating a copy of the array with map takes O(n) time and O(n) space, while the reduce version takes O(n) time and O(1) space. By relying on Math.max behavior with arrays you're giving up a known efficiency increase in exchange for the hope that the library implementor knows what they're doing. Sounds like a bad trade to me!
I developed quite complex UI applications with angular. And angular is incredibly complex for what it does. It may look good on toy examples. But on real an complex application its complexity becomes unmanageable. This few days i've been writing some prototype code in react + reflux. It is definitely feels different. Much simpler mental model. I can see how growing complexity can be managed much better by me. In fact anuglar team themselves acknowledged the shortcomings and unnecessary complexity of angular. That's why they throw away practically everything and started from a blank slate. And if they gave up on it, so should you. 
Yeah that seems to be the main issue I'm running into already. Thanks for taking a look though! I appreciate the extra pair of eyes.
&gt; for starters, bower itself is an NPM package, not exactly like it's trying to avoid NPM or convince people not to use it. Sure, it's *built* with Node and npm, but it is intended to be used as an *alternative to* npm for client side package management. &gt; you can load up 4 versions of a package to make everything behave, this is down right idiotic to attempt with client side JS. Not really a problem when you deal with small and focused modules that don't use singleton patterns or peer dependencies. Flat dependencies is more of an issue when you have a dependency depth greater than 1. If you just use a couple of monoliths like jQuery and Bootstrap, Bower is fine. 
Thanks! :)
Unfortunately to JSPM, browserify and watchify still provide a much smoother development experience. With JSPM/System.js I need to wait seconds for the browser to load my React app with every change whereas watchify can do this in a matter of milliseconds.
&gt;I would rather an additional 1kb of code in my bundle than having to deal with Bower dependency hell. Good News! You can use NPM! For those of us who would rather save that 1kb and deal with the dep version issues can use Bower. We can coexist!
With the Canvas API, you can draw images and transform them. It's pretty fast nowadays, which means you can do quite a lot of that. Particle effects are surprisingly easy to do. You have an array of particles of which each has a position and some other properties you need for your particular effect like x/y velocities (or deltas), age (or time-to-live), and maybe other things like angular velocity. When a particle is spawned, it's added to this array. When it dies or goes off-screen, it's removed. In your game/simulation loop, you iterate over this array to advance the simulation. That is, you add the x/y velocities to the current position (and maybe gravity), reduce the time-to-live, check if it went off-screen, and whatever else you might want to do. And in the draw phase, you just iterate over it once more just to draw each particle at its current location/size/opacity.
Artifactory/bower will likely have support for this soon, and we are looking forward to it at our office.
How about checking node_modules into the repo, I don't like that it has so much "stuff" in it and every jquery plugin could include a different version of jquery, is there a way around it? I like to include node_modules so that I have every dependency if github/npm were down. Is there some best practice for including a tiny node_modules folder?
I'm hesitant to believe any "stop using X" articles, because X is a solid addition to many workflows in many cases. I find that most times, people just find something new and say "man, that old thing sucks, stop using it because there's no possible reason to use X over Y!"
Depends. One slow DOM operation can be faster than a lot of fast ones.
[Are you sure?](http://arstechnica.com/information-technology/2014/09/august-growth-puts-windows-8-back-on-track/)
&gt; If so you need one of those frameworks. Correction: You do not _need_ one of these frameworks, however you _would_ greatly benefit from using one.
Yep, also people fail to understand that different cases need different tools.
I'm of the opinion that performance is worth more than elegance. The only ones who will appreciate the elegance of code are programmers, who hopefully have similar sensibilities. I'll occasionally trade simplicity for performance, but elegance smacks too much of ego for my taste.
Register on click event to your button on page A and make an asynchronous request to your php script on page B.
&gt; Bower will ask you to select one and make everyone use it. And that's a good thing?
If I understand correctly, do you mean page A and B as .js and .php scripts respectively? I need the button on page B though.
PHP and JS are different one runs on the server and the other on the client (browser), you can't run a js script from php.
I will readily concede that those numbers are too high when you look at the current overall picture (specifically, they are a bit old though IE8 traffic spiked at around 14% last Christmas). A more detailed answer is that it depends on what you are doing. Some applications are able to get away with forcing users to have a very modern browser, but if your app needs to target a large audience, then even 5% means you exclude one out of twenty potential clients (this is why Facebook needs React to support IE8). That's a hard pill to swallow and is even more bitter if the answer is as easy as switching frameworks. Another consideration is the loads of big businesses are paying Microsoft for extended XP support. Those XP systems are locked in to IE8 and support is a must-have (I have worked on several of these). If you are targeting these corporations, then having a framework that can't work with IE8 if necessary is completely unacceptable.
Completely agree with you. I'm working on a huge project and every millisecond of loading time matters. I want to have full control over dependencies, not N of nested `node_modules` with Lodash included N^2 times.
hmm, so if I a simple page: &lt;html&gt; &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; I am not sure how I would insert all the necessary strings in "one slow DOM operation". From what I see, I'd have to do one for &lt;title&gt;, one for &lt;p&gt; and one for &lt;h1&gt;. Assuming these would change very little (if at all), then wouldn't it be better to serve this from the server, already translated? 
Post your code for the second getJSON callback
I think the distinction is that bower can be installed and used globally even if you're not using node/npm in the project itself.
amen to that .. npm is all you need
By default, Browserify concerns itself with JavaScript only. If you use Webpack, which I highly recommend, then you can simply use `require('herp/derp.css')`.
A very valid question for which the answer is much more complex than one would hope (should probably add a section about this in the blog). Personally I often find myself using Browserify along with custom gulp build pipeline for assets like styles, images and templates. If you need to pull styles from third party packages, just use CSS imports. Just make sure you don't hard-code your node_modules urls into the imports. Instead, use a tool that supports npm module resolution. One such tool is postcss-import (https://www.npmjs.com/package/postcss-import). In case you don't use gulp and want to switch from Bower to npm, use webpack (http://webpack.github.io/). But just out of curiously, let's talk about Browserify. "The Browserify Way" of handling assets would probably be by using appropriate plugins/transforms. Sadly, many of these solutions are not viable in a way or another. brfs is very popular (https://www.npmjs.com/package/brfs), but it only is good when you can inline your assets inside your bundles. Works for templates, JSON data, probably for smaller CSS styles as well. Parcelify must also be mentioned. Its a nice solution, but only in theory. With it you just require the libraries you depend on in your app.js module, and parcelify will collect CSS bundle along with the JS stuff. It also plays along with preprocessors like LESS and SASS. A shortcoming in parcelify is that it requires you to provide style-field in the package.json files of your dependencies. Its trivial to add this field into your own packages, but sadly, third party packages do not always provide this. You can work around some problems with parcelify-import-resolver, but sadly it all gets messy very quickly as you need to combine the resolve urls with some inlining tool. So back to my recommendation: 1) custom gulp asset pipelines or 2) webpack.
Npm's nested dependency model is sometimes problematic. Windows has this 260 character limit for paths, which is easily exceeded in big projects with many dependencies. I've had to install npm packages inside our dev docker container (instead of directly on the host) because of that.
Sounds like http://todomvc.com/
Don't worry, npm 3 is coming soon.
You are absolutely right. Nothing gets you more annoyed than npm generated folders that you cannot delete with Explorer! However, this is more a problem in Windows than in npm. And its a problem thats being addressed (https://github.com/joyent/node/issues/6960).
You got it backwards though. Using Bower without node is more like using IE without Windows (although this analogy still isn't a great fit and completely breaks down for older IE versions). But yeah, your point stands.
But in my analogy node = windows and npm = IE. You can use Bower without using npm.
&gt; The reason, as it turns out, is that Bower doesnt support nested dependencies. Nested dependencies also have disadvantages. Theres one project in my company that have only ~20 JS dependencies (`gulp` plus a lot of plugins), the `npm_modules` directory has 90,000 files in it.
I'm kind of curious to try this out next time I have this issue : https://github.com/webpack/i18n-webpack-plugin https://localizejs.com/ seems like a great solution for something completely client side, and has the entire translation pipeline as SaaS. 
&gt; The most important reason is that I can teach a programmer React in a couple hours What part of the world do you live in? /pleasesaykansas
Right, but how does that apply here? He/she *is* using npm--that's how they installed bower. It's not just some extraneous package that shipped with node. 
I do use a gulp pipeline that gets both css and js from my bower files... I just don't see the value in switching... and I guess that's usually the point. There is no universal workflow that is "best" for everyone.
I understood /u/rackmountrambo's comment as implying that they may use npm only to install bower globally (`npm install -g bower`) without using npm within the project itself to manage dependencies.
By the same logic... I used IE to download Firefox, so I should just use IE since it was already installed.
Because jQuery won't work fine forever. Today, your client just wants an autocomplete box. Next thing you know, they want a graph on the page. Then they want certain parts of the content to dynamically update when events are triggered. These small dynamic components will quickly spiral into a mess of unmaintanable jQuery that you will hate yourself for writing. React, my favorite of the bunch, allows you to compartmentalize your logic into components and handles all of the DOM updates for you. By isolating logic into components they are reusable and, more importantly, easy to read and maintain. The other true frameworks are a bit heavier and all encompassing, but serve the same purpose, giving structure to your JavaScript. It's better to get started with something before you need it, otherwise you will be stuck.
Nifty.
Looks great... Not very familiar with codepen's naming conventions, but what does line 8 of the HTML do? &lt;script src="smoke.js" type="text/javascript"&gt;&lt;/script&gt; Is this just pulling from the codepen's script panel (cuz I thought that was auto-injected)? I was able to take this line out and it looks like the pen still functions.
It's hard to tell what the My List tab is supposed to do without logging in, but I wouldn't expect generateList() to do anything with the changes you've made. I see you put the secondary API call in there, but the listArray array that you are looping through seems like it would always be empty. We are talking about the My List tab, right?
I felt like this today when I read about web-pack. QQ
I jsut seperated the two API call and also implemented a little test to check to see if the data printed next to the name was correct, I included an if statement var test = "Steam ID Matches"; if (playerArray[i].steamid == listArray[i]) { document.getElementById("watchList").innerHTML += playerArray[i].avatar + playerArray[i].name + " " + playerArray[i].status + ' ' + test + '&lt;br&gt;'; }else document.getElementById("watchList").innerHTML += playerArray[i].avatar + playerArray[i].name + " " + playerArray[i].status + '&lt;br&gt;'; [HERE](http://i.imgur.com/PQnv78n.jpg) The data does not come up correct. Except randomly it will have 1 or 2 correct ones out of sheer luck. 
Follow the continued conversation at https://github.com/tc39/ecma262/pull/36
If you use babel, does it provide sourcemaps so that you can debug the original code not the transpiled code?
I have but I wasn't sure of what it was for. Thank you for answering!
There are tranforms for css, less or sass files for Browserify. No need to use Webpack just because of that. https://github.com/substack/node-browserify/wiki/list-of-transforms
it would be possible to implement partial loading/reloading into JSPM, but that would require someone taking those few days off and implementing it.
Run out of improper nouns, I see.
ok. there's a lot of weird stuff going on here that you might not understand what it's doing. That's ok, youre a beginner. I just hope my tone wont be too harsh pointing out the errors. var WatchList = ''; document.getElementById("watchList").innerHTML = WatchList; All this does is empty the watchlist element. there's no reason to set a variable for it. just do: document.getElementById("watchList").innerHTML = ""; As for this part: var ID; var Avatar; var Persona; var vacStatus; var player = {steamid: ID, avatar: Avatar, name: Persona, status: vacStatus }; There's no reason to declare these variables. all you are doing is setting player.avatar = undefined, etc. It would be better to set these as empty strings, since you output them as strings later. do this instead: var player = {steamid: "", avatar: "", name: "", status: "" }; Actually, just take all this code out and assign the object literal directly to playerArray[i]. more on that later. This part is pretty weird: var listArray = new Array; for(var i in listArray) { Where does listArray get populated? What is the purpose of listArray? I cant see anywhere in the code where listArray has stuff put in it. So if you run this code with an empty listArray, it wont even run once. playerArray[i] = player; This would actually just create an array of the same object repeated over and over. What you need is a *new* object for each player. Do this instead: playerArray[i] = {steamid: "", avatar: "", name: "", status: "" }; Every time you use the curly brackets to write an object, it creates a brand new object. This is called an object literal. Okay. Onto the getJSON's. The problem here is that you are waiting on two responses and you want to make sure that they are both complete before writing out your innerHTML. But your innerHTML write is contained in the second callback. That callback might get triggered *before* the first callback! getJSON, and any ajax request, is an asynchronous operation, meaning you have no control over when those callbacks get triggered. You just have to sit and wait. So if the second request gets a response from the server before the first request, then you will be writing out your html with incomplete information. This is called a race condition, and it's one of the tricky parts of writing javascript. The best way to deal with this would be to use what are known as "promises" or jQuery.Deffered. Those are kinda hard to learn and I dont feel like explaining them to you, but you should look them up. But we are already halfway there. $.getJSON returns jquery promises, so we can use those. var request1 = $.getJSON('https://jsonp.afeld.me/?callback=&amp;url=http%3A%2F%2Fapi.steampowered.com%2FISteamUser%2FGetPlayerBans%2Fv1%2F%3Fkey%3D735F44EA008A3DD1C3111B2D2D19E7A0%26steamids%3D' + listArray[i], function (data) { var Output = '&lt;table border=0 class=tbl style="color:white"&gt;&lt;tr&gt;'; for (var i = 0; i &lt; data.players.length; i++) { playerArray[i].steamid = data.players[i].SteamId; playerArray[i].status = data.players[i].VACBanned; } }); var request2 = $.getJSON('https://jsonp.afeld.me/?callback=&amp;url=http%3A%2F%2Fapi.steampowered.com%2FISteamUser%2FGetPlayerSummaries%2Fv0002%2F%3Fkey%3D735F44EA008A3DD1C3111B2D2D19E7A0%26steamids%3D' + listArray[i], function (data) { for (var i = 0; i &lt; data.response.players.length; i++) { playerArray[i].steamid = data.response.players[i].steamid; playerArray[i].avatar = '&lt;img src=' + data.response.players[i].avatar + '/&gt;&lt;/a&gt;'; playerArray[i].name = data.response.players[i].personaname; } }); $.when( request1, request2 ).done(function () { for (var i = 0; i &lt; playerArray.length; i++) { document.getElementById("watchList").innerHTML += playerArray[i].avatar + playerArray[i].name + " " + playerArray[i].status + '&lt;br&gt;'; } }); See the $.when at the end. This function will only run after BOTH getJSON's get their responses. I'm also pretty sure they will run after the two callbacks that you already attached. Also note that I replaced all the for..in's with regular for loops. for...in loops through arrays in random order, which is why your data was getting all mixed up. Use a regular for loop or array.forEach to guarantee consistent order.
yeah.. about that..
Thanks, dude! I've got some other stuff in the works, too - project badges, private repo activity, etc. = )
Hah = )
&gt; so why can't Javascript just finally have NPM and be done with it? The fact that NPM installs bower (to my knowledge) speaks truth. NPM is not perfect by any stretch of the imagination, especially considering it lets you publish broken packages with fake deps, *which I have done personally on multiple occasions* by complete accident. But it's still better everything else :)
copy/paste?
Any reason not to check your bower deps into source control? With npm you you probably shouldn't if there are any binaries that need to be compiled but bower deps shouldn't have that issue.
that is genuinely hilarious 
Wow, thank you for all of the input. This project is my first experience using PHP, Mysql, and and with using an API. watchlist = ' '; Was used for when the page refreshed to clear the data and start over. Also before I was using an array I was directly pumping all of the data to watchList. I just had not taken it out yet. There is a bunch of factoring and code cleanup needed. As for the reason I declared each of those variables var ID; var Avatar; var Persona; var vacStatus; Was only because when inspecting the element via Firefox It kept telling me that the variables were not declared. I think this may have to do with originally declaring them within a loop. My idea behind it was so I could visually see my objects structure. That makes total sense on declaring the object for [i] in the array, I dont know how I didnt see that. Makes total sense, Thank you! It is great to see your example of the $.when, earlier when reading up on this I continued to see it mentioned, I guess I was fed some bad advice stating that anything between the braces was if their was success on the call. I really want to say thank you again, I cant say it enough, I am happy for the constructive criticism. 
I can see why some of it confused you, I was tweaking this for awhile, kept trying different things and my code got really dirty because of it. Also this is where list array comes from, &lt;?php if(!isset($_SESSION['steamid'])) { } else { include ('steamauth/userInfo.php'); $steamid = $steamprofile['steamid']; $con = mysqli_connect("HOST", "DATABASE", "PASSWORD", "a9674619_Users"); $sql = "SELECT list_id FROM `watchList` WHERE `SteamID` = $steamid"; $result = mysqli_query($con, $sql); $i = 0; while($row = mysqli_fetch_array($result)){ echo "&lt;script&gt;listArray[$i]='".$row['list_id']."';var signedIn=1;&lt;/script&gt;&lt;br&gt;"; $i++; } } ?&gt; &lt;/p&gt;
*Dependency injection is just a design pattern* Yeah, and it's much nicer to be able to pick which patterns you need vs. using ones that are forced on you. Angular's module system has some issues, and mostly gets in your way if you're trying to write CommonJS or AMD modules. *what features makes react-router better* ng-route is way too simplistic, ui-router is at the complete other end of the spectrum. react-router is simple but handles the common cases (i.e. nested routes) well. *what are the main reasons directives are harder to work with than components* The directives API is one of the worse parts of AngularJS imho. Knowing which options to use and when and in what combination takes awhile to learn and is never intuitive. React components have a small API and are extremely straight-forward.
Totally agree that you don't need something like React or Angular to build a normal (i.e. non-app) website. I can only speak for myself, but one of the reasons I play with new technologies and frameworks is because so far building applications on the web has been pretty painful. Front-end frameworks are a dime a dozen these days, and generally I don't bother looking at them unless they're doing something different. I think that's part of the reason that React has gained so much traction of late; Angular is a major improvement over not using a framework at all (i.e. if you were basically writing jQuery soup), but it has its issues. I think it's pretty telling that Angular 2 is so different from Angular 1. So don't use things you don't need, but I wouldn't discourage people from exploring new approaches to building things on the web. It's a moving target and users expectations are changing all the time, and we're not going to grow the platform if we're not pushing and exploring new things.
Oh okay, I see. Thank you. I have changed my code around but still end up in a similar situation in the end. Maybe the JSON requests are sending the data back in a different order. As its incorrect status for the users. Anyways thanks for your time you have helped a ton. I just need to set the values of ALL of the objects when they have matching ID's. I can get the correct data back when I include an If that checks if the id's match, but then I get certain usernames and avatars that dont get posted. 
Yeah... we've run into the path limit on our Windows machines here. Until we find a way around it, I don't know if we can even do our modern dev on them.
Great article. As someone fairly new to the web dev realm, this makes me feel better. I thought everybody "knew" all the crazy things coming out every month and I just needed to catch up. 
I think the biggest issue with these kinds of discussions is that people tend to define "web app" as little more than "I don't want the page to reload when I click links." Given that, you don't need a whole progressive enhancement-busting framework like Angular or React. Just make normal links and forms and progressively enhance them with something like [page.js](https://visionmedia.github.io/page.js/). The big monoframeworks only really make sense to me if you're developing something that *truly* cannot be done without JS, e.g. games or Google Maps, or when your runtime environment explicitly guarantees JS availability (NW.js, internal applications, rapid prototyping, etc). Whenever I see something like Angular or React used on an arbitrary website serving arbitrary HTTP traffic and it's not something as rich as a game, I shake my head for the state of web development in 2015.
Yea, sounds like that is what is happening.
Are you saying people have moved on from webpack? 
PHP is obsolete, move on.
&gt; Meanwhile NPM downloads shitload of files (quickly going over thousands), because it DOES support nested dependencies. npm@3 will deduplicate by default where it can. Packages will be moved to be as shallow as possibly while still allowing incompatible versions to be nested deeply.
I don't understand why you chose this site in particular... by my count there's ~150kb gzip of javascript downloaded -- most of it is the facebook sdk... by comparison, that's about the size of one of their large hero images. I'm not seeing any massive nested npm dependencies down the wire.
Hi /u/glirg, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I've found that nesting dependencies can be very annoying when you are trying to use libraries with CDN/global scope. If you want to use a CDN version of jquery, you have to create an alias along with getting jquery to get pulled into browserify properly.
This is pretty common knowledge and is in both JSHint and JSLint.
You're doing it wrong, I think. devDependencies should include things needed to build the final package, run tests, etc. This shouldn't be used for client/server differentiation or you have no way of managing those items. Creating separate modules for your front and backend is much saner.
&gt; If you'd like to show off your latest project, then that's great! We love seeing what fellow redditors can come up with. However, the same posting rules apply: it must relate to JavaScript. For example, this could be a link to the project page (unminified/unobfuscated source code), or maybe an overview of your architectural decisions, a code review request, etc.; you can even do so in the comments if the site itself doesn't meet the posting criteria. NOTE: The fact that a site was made with JavaScript does not automatically make it eligible to be posted to /r/javascript, including games. If we allow any site that uses JS to be posted to /r/javascript, then we'd soon be indistinguishable from /r/WebGames, /r/InternetIsBeautiful, etc. Instead, we aim to foster discussions around the source code, and/or the development processes and practices used to create the project.
What would the list entry be?
how true is the "let" thing? what browsers are ES2015 compliant?
Ahhhh of course. Yeah thats working now, thanks heaps for this :)
&gt; And what are the main reasons directives are harder to work with than components (if the reasons are already on the list, just point them out explicitly)? It's hard to reason about how a directive works without knowing the implementation behind them. For example a directive's controller and a directive's post-link function have a lot of overlap. Some people might be able to use them interchangeably without ever running into problems. Even if you understand a directive's lifecycle by itself then you also need to know about how it works with other directives. If I have a parent directive X with a child directive Y could you say off the top of your head the order of both their link and controller functions? And then you have sibling directives with priority, transclusion and scope hierarchies to deal with. A React component's lifecycle exists in isolation by itself and it follows a clear order. Components have a Mount -&gt; Update -&gt; Unmount lifecycle that is dead simple. The React docs are also much clearer on why you would use a specific lifecycle method.
Of course the "Imperative" example was written in the most convoluted way ... just to make a point? Why not first clean it up and then "take advantage of JavaScripts object-oriented nature" or whatever... function get_text() { var some_text = prompt("Give me something to capitalize"); var capitalized_text = capitalize_text(some_text); // var capitalized_text = capitalize_text_regex(some_text); alert(capitalized_text); } function capitalize_text(text) { var words = text.split(/\s+/); var result = ''; for ( var word_index = 0, words_length = words.length; word_index &lt; words_length; word_index++ ) { var word = words[word_index]; result += word[0].toUpperCase() + word.substr(1); if (word_index &lt; words_length) { result += ' '; } } return result; } function capitalize_text_regex(text) { return text.replace(/\b(\w)/g, to_upper_case); } function to_upper_case(str) { return str.toUpperCase(); } //document.getElementById("main_button").onclick = get_text;
&gt; this kind of self-employed work The work on his account is primarily not self employed. . &gt; where you do all design and decisions have nothing to do with deadline/budget restrained team work. Many of those are very large team efforts which are severely deadline restricted. . &gt; Dont you agree with that? I don't believe it models the situation at hand. I do agree with the evaluation. If that was what we were talking about, yes, I'd find those to be salient differences. However, since you appear to not actually have looked into the person, and appear to just be guessing, no, I don't really find this very convincing. Part of that is because I've been involved with the governance of several of those projects, and I know how neckbeardy and bikesheddy those people you imagine aren't real have been. . &gt; I am not saying browserify is low impact product for node or frontend development, just that i can name 10k companies who has more clients than browserify has daily downloads from project templates. That's nice. 1) I don't think that's a valid way to make the measurement 2) I don't believe you actually can name very many such companies 3) I'm not sure why you think naming companies with some number of clients has anything to do with one developer's understanding of project dynamics 4) You seem to just be making value assertions 5) I'm not sure why you thought it would matter whether you felt that some project was high or low impact. . &gt; But may it be best most popular node package, how it has something to do with this thread? Given that nobody made this claim, this question is a useless distraction from the thread. Please stop attempting to participate in the thread if you don't even know what it was about. Thanks. . &gt; Should we call java better? Or any other java artifact which can beat number? Any developer of that artifact superior? Should we count in only open-source contributions or company workers as well? Should i get some advice on how to act in life and how software world works from them? Should i ask Hans Reiser as well just because he wrote decent piece of software? This has nothing to do with the discussion. However if someone said "Hans Reiser doesn't know much about software," and I pointed out that he's actually done a large amount of high impact work, yes, actually, I'd expect the original speaker to stop being so dismissive of others, especially when they themselves have not. Be sure to distract further with talk of why Reiser is in jail, and then to be aghast that nobody seems to be interacting with you. I don't feel that you understood what I was saying to someone else. Your objections are noted. I feel that you are confused about my position, and that you are challenging me repeatedly to explain things I never said; given that it is not enjoyable to discuss with you, I don't see the point in continuing. Please have a good day.
you're right. I updated the gist to use Array&lt;ITodo&gt;
I could have answered that question, but I wouldn't say that this is relevant to most programmers. Those old school octal literals can't be used in strict mode anyways. It's a SyntaxError. With ES6, you have to use "0o" or "0O" as prefix (0o10 === 8). (Always use a font with slashed or dotted zeros!) Anyhow, you might like this: &gt; (4).toString() "4" &gt; 4.toString() SyntaxError: identifier starts immediately after numeric literal &gt; 4.0.toString() "4" &gt; 4..toString() "4" &gt; .5.toString() "0.5"
Chrome (as of version 42) supports `let`, but only in strict mode.
There are also a few libraries built by the community that extend this functionality beyond the scope of npm: https://github.com/mafintosh/link-bin https://github.com/kevva/bin-wrapper https://github.com/typicode/homerun npm script tags have completely changed my workflow, and those libraries are doing amazing things in the ecosystem but if you really want your mind BLOWN, check out [this source code](https://github.com/aredridel/node-bin) :)
or do you have multiple personality disorder??? I mean, the profiles are almost identical in name :)
ahh very beautiful but no text labels under the menu items *facepalm* i cant use it now because my users are dumb :[ if you add this i will use it.. hint, hint! really quick you put .itens instead of .items in the readme near bind click events 
I agree with most of your points, except #1. Dependency injection is a wonderful tool, and should never be a worry. Even with angular's weird use of strings to prevent issues with minification.
youd have to tell us what lightbox plugin that is typically you do something like &lt; button onclick="start_lightbox();return false;"&gt;click&lt;/button&gt; but every plugin is gonna have a different start function -- and if your using jquery there are better ways to bind that button
Because it handles eveything in one shot, using declarative programming. Lets say you have an poll-creator form that has one description and multiple possible answers. So its schema looks like: description, array of answers With frameworks/tools you noted, you only have to DECLARE your form will have an &lt;p&gt; tag with description, and a list of answers where every answer will have &lt;input&gt; where user can type value and "X" icon next to it that will remove answer from list. Now, when you already have that data schema defined, youre done, because it doesnt really matter how a new 'answer' was added to list - either you loaded it with ajax using one api, parsed json that came with view or user manually added new question using a "new question" button - it always contain an input that is related to this answer value and X button that will remove this answer. in jquery you must handle every possibility, bind "onclick" events, handle what should be removed when I click *THAT PARTICULAR* 'x' icon and so. Check knockout.js. While this tool is probably outdated a bit today, it has REALLY easy live tutorial that actually answers your question "why": http://learn.knockoutjs.com/
Just use Babel or TypeScript to write ES6 and then you don't have to worry about browser support. I personally no longer use `var`, only `let` and `const`in new code. 
**A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES** Quote from its homepage. react is a library.. 
&gt; there should only be one version of X library npm ignores that and calls it a feature to bundle different versions of jquery 4711 times.
"Publisher-Subscriber" is something that goes well beyond the JavaScript context. It's a general concept and it's known by that name.
really nice, but only issue is that its pure client side and requires JS which will not work in md files or wikis. usually badges are images that have some provider that generates them based on current state/data so they are embeddable in every type of website/page. Now.... I understand you don't have such a backend to provide, but basically its the only issue I think that will stop this from being widely used. still, its very nice.
On nested dependencies, in practice they work identically unless there is a conflict in versions at which point npm uses both and bower on the other hand us like 'fuck it, above my pay grade you figure it out' at which point hopefully it's just a minor version (1.1.2 vs 1.2.5, which npm@2 would have likely deduped anyway assuming everyone was good and used ^based versions) On the other hand bower will sometimes make you pick between major versions (1.2.5 vs 3.1.7) in which case either choice could break something. Having a smaller script file doesn't help when it doesn't work
I'm already glad I can skip IE7, and *definitely* happy to skip IE6.
it is, umm, a little bit hard on the eyes. The content appears to be in there, but should the presentation really be aimed at small children who grew up in the 80s? 
TypeScript 1.5 which is now in beta, added support for `let` and `const` on ES5 targets. :-) 
&gt; jQuery was a pretty neat idea. Manipulating the DOM by hand is *so fucking gross*, though. Learn to use a stateful UI layer. Congratulations: You're spending the majority of your time writing features instead of fixing bugs. Employers are continually attempting to felate/spelunk you with job offers. Now, go ride around in the boat you've made out of money. Longform to your TL;DR.
Ah that makes quite a difference! Thx for pointing that out :-)
Yeah, I suppose so.
Wouldn't the node shell be enough for you? You could easily type commands like so: &gt; var a = 1 undefined &gt; a 1 &gt; ++a 2 &gt; parseInt("123") 123 etc 
It was one solution, but I really need to point to the fact they are really, really beginners (with programmation, and, for some, with computers), it's why I search for the simplest solution - if it exists.
I had to reconsider on reverse(), and now my code looks like this: function(n){n=(n+'').split('');return n.reverse().join()==n.join()} Yes, it should work if you replace "Num" with "num". If you want it even easier than that, but only for 6 numbers, try the following regex: /^(\d)(\d)(\d)\3\2\1$/.test(num) 
If you plan on doing anything with the DOM, I recommend http://codepen.io in conjunction with Developer tools. Codepen will evaluate your JS as you type, no page refreshing or anything like that. 
&gt; I want to transition to another div when the user clicks a marker in Google Maps This? http://codepen.io/ForScale/pen/RPoezd
Have every method from the object, return the object itself. IE: function Chainable(){ var self = this; this.do = function(){ // do return self; } } var c = new Chainable().do().do().do()
To "chain" you just need to return `this`. The two examples you listed are very different. The first one attaches a method to the prototype, which means that all new instances of `MyObject` will have that method. MyObject.prototype.show = function() { return this; } It would be called like this: var myObj = new MyObject(); myObj.show(); Whereas the second one just attaches it to the function object. Imagine this as a "static method" if you've come from other languages. It only exists on `MyObject` and not on new instances. It would be called like: var myObj = new MyObject(); MyObject.show(); The `this` reference is also not pointing to the instance of MyObject, so there is no possibility of chaining with it. Generally speaking, I tend to avoid "static" methods like that since they can lead to headaches down the road.
You do it exactly like that, both in the prototype and in the own method of your object, because this is always the scope of the current object (unless you "use strict" or lose your scope due to being applied, called, curried or bound).
This looks amazing
22 will not work. That looks like the number "000022" as far as this code is concerned, which is not a palindrome. 2200 will, however, work, since that looks like "002200", which is a palindrome. 2- and 4-digit numbers will not work, if I am interpretting correctly.
The good thing about Aurelia is there is little in the way of framework conventions to learn. It's more just learning ES6/7, which will benefit you in the future no matter what as it's the future of JavaScript itself. I'd say TypeScript is also now a safe bet with Microsoft's partnership with Google for Angular 2.0 and Microsoft's support for Node.js &amp; JavaScript in general now. We're all in the same boat though. I hadn't heard of WebPack or JSBlocks until this article. haha.
&gt; new Chainable().do().do().do() Name that tune!
You're right, my bad. Good catch. 
Still *too complicated* for total beginners. But thanks :)
Codepen (or JSBin) are great tools, but they are online, unfortunately :(