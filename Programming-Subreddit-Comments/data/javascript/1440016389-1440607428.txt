This is a keynote of Jafar Husain explaining the ideas behind Falcor: https://www.youtube.com/watch?v=hOE6nVVr14c
but why are you doing it that way? var myCssSettings = JSON.parse(cssSettingsInJson); $(myCssSettings['app-header']).addClass('test'); 
I think you might get away with most selectors but things like ajax can get annoying rather quickly.
Ah yes, of course, ajax, the main reason people say "fuck it" and just install jQuery. :)
Thank you! Yes, I have tried it with == ...Perhaps it is a Wordpress thing, but I can only get it to work on one page with ==. When I click to the next post, which also has a title of HELLO, it just does not bother to change it to GOODBYE. I find it baffling since when I put an *alert(arr);* in there, it shows that the title is HELLO just like the other page (same case and everything). - **contains** sounds good, but I don't know the syntax. I found too many nonworking examples on StackExchange. Could you tell me how to simply write "if arr[0] contains 'hello'"? Is arr[0] even the right way to do this? Is there an easier way to get a variable to contain the title text of a page? I think the array might be why it breaks on the second page with == - is **contains** case sensitive?
Thanks. I still use vanilla JS for many projects and I haven't had too many problems with IE9, at least compared to previous versions of IE. But IE will always be IE, of course.
comparing strings is case sensitive, Hello != HELLO, [this fiddler](https://jsfiddle.net/1kffb89y/) will to a .toUpperString() so it will hit first one and change it's text so it wouldn't matter if it was 'Hello' or 'hello or 'HeLlO' You could cut out the pushing things into the arr if you want by simplifying things to something like [this](https://jsfiddle.net/tce7aqha/1/), which will go through all of the titles and then change Hello to Goodbye. 
A significant portion will be using jQuery regardless, but for those of us that don't (and the web is moving in that direction), it's nice to avoid 100 KB and avoid parsing a bunch of code that we don't use.
to check if a string contains another string you use the "indexOf" function, which returns -1 if it's not contained, and if it's contained, returns the index at which the substring starts. your condition becomes if( arr[0].indexOf("Hello") != -1 ){ //dostuff } The way i solve the case sensitivity thing is to convert anything to lowercase and compare everything in lowercase, in which case, your condition becomes: if( arr[0].toLowerCase().indexOf("hello") != -1) {//dostuff} An easier way to do this is assign Id to the title instead of class, this way you can refference the element directly, instead of getting an array, and then parsing it. Your for becomes redundant now. assuming your element has the id "categorytitle", &lt;h2 id="categorytitle"&gt;Hello&lt;/h2&gt; Your code can be written in a single line like this: if( document.getElementById("categorytitle").innerHTML.toLowerCase().indexOf("hello") != -1) {//dostuff} 
http://jsfiddle.net/8k93j6vz/ String comparisons with == or === are case-sensitive. Using the `toUpperCase()` method helps with that.
That's not what I meant. I mean that many will be using jQuery's regular functions in addition to Bootstrap's.
jQuery is a JavaScript library. You have to learn the basics first.
&gt; There's nothing about the specification or the current observations of the web, as far as I can tell, that would give those "lots of code" any such guarantees. The timeout is from the time the API is called. There is absolutely a guarantee today that your callback won't be called until at least that amount of time has elapsed from the time setTimeout was called. I promise you apps depend on this. &gt; The while(500ms) thing from your other code snippet is not the kind of thing that happens commonly on the web. A single operation that back in 1998 may have taken the engine 500ms to do now probably takes 5ms or less. It happens all over. You're forgetting DOM and async stuff like network requests, probably? For example, consider wanting to timeout a network request - with your implementation, the timeout of N ms becomes N minus time spent on this turn so far instead. If your timeout is triggered from a turn that also does template rendering and other initialization work you can easily see this could be problematic. Further, this kind of thing is suuuper common. Sites are multiple orders of magnitude more complex than they were in 1998 so I don't see why that historical context is relevant. &gt; Suggesting that that developers reason about "work needing 1000ms to run" doesn't even remotely sound like something sensible people do on today's web. It happens all the time. One common scenario described above. 
&gt; This is never the case so beside the point Actually, it's precisely the case and the point. I believe it too myopic (although extremely common) to assert that expectations (or assumptions) about the ordering of two items necessarily makes them dependent on each other, in the normal sense of dependent. For example, I could have two images, one that's tiny and one that's huge, neither in cache. I can have a reasonable assumption that the tiny one loads before the giant one, even though obviously there's no guarantees of such. And these two images can in fact be unrelated. And it wouldn't kill the system if they flipped order, but I certainly reasonably expect under normal circumstances for the assumed order to be true. It's only if I want to absolutely guarantee that the tiny one shows before the big one that I need flow control (promises, whatever). Short of that strict need to guarantee, I have degrees of assumption and reasonable expectation. Back to my original scenario, if a developer expresses one thing as 1000 and one thing as 999, it is entirely reasonable -- but not currently actually guaranteed -- for them to assume that the 999 one is less than the 1000 one, and will thus happen first. The images thing is just one quick-n-dirty example of perhaps a dozen use-cases I could expound on for a difference between ordering expectation and strict notions of dependence. Edit: [another example](https://gist.github.com/getify/b0bd8bef4e27c57e04be) of a system with a reasonable expectation of relative ordering of timers, but no strict dependence between the two actions. Obviously, there's no guarantee. But the whole point of what I'm arguing is that there should be a reasonable guarantee. A system without such is deficient. And since these two actions are strictly not related, shoe-horning them into a flow control (like promises) is, IMO, a case of works-but-is-more-confusing.
You can use `$&amp;` in the replacement string to get the contents of the match: &gt; 'foo bar @1234 baz'.replace(/@\d+\b/g, '&lt;a href="http://example.com/$&amp;"&gt;http://example.com/$&amp;&lt;/a&gt;') 'foo bar &lt;a href="http://example.com/@1234"&gt;http://example.com/@1234&lt;/a&gt; baz' 
Because javascript projects don't live in a vacuum. It's important to know how to interoperate your js with other languages if you have to. Furthermore, elm compiles to js.
thank you, this will help me a lot. That array parsing stuff is what I think is part of the problem and I guess it's possible to convert to an ID since there's only one per page as far as I know. I really appreciate you taking the time to explain this and give sample code. 
`window.location = window.location+'/?spectator=true';` This will work but doesn't take into account there could be other parameters already there. 
It's not the case in point. If you care whether setTimeout(1000) or setTimeout(999) fires first, then you need control flow. Otherwise, it just doesn't matter regardless of what guarantees the API provides. Anyway, we have differing definitions of reasonable. Among other things, I don't think it's reasonable that all the code that runs before my setTimeout changes the timeout duration from the point in time I'm making the call. I don't even own most of that code usually. Refactorings can also cause subtle changes in behavior.
are they using babel? how is it written in es6 and run in today's browsers?
can you give me any reasonable web scenario in which you reason about how long code will take to run before (or after) you set a timeout up, and that reasoning affects what number you pick? I cannot fathom a single case where that's reasonable or reliable on the web.
Actually, I believe you are confused about what I'm saying. I was trying to say that if they are independent of eachother and unrelated, then I would be happy using setTimeout, and wouldn't care which happened first. If I *did* care which happened first, I would make it more explicit than setting two magic numbers. Even if the order would be preserved over different engines, if the setTimeout statements start to drift further apart from eachother as the code matures; taskB, which for whatever reason the coder behind me decided to define further down yet need to run earlier than taskA, is now further away, so I can't see both magic numbers at the same time easily. And heaven forbid I need to have a taskC, which taskA needs to run after, and taskB needs to run before. Now I have to hope that either magic number 1000 is flexible, or that 999 is, because I need a task *in between them*. But I digress, and I'm becoming guilty of taking an illustrative example and reading it as more, rather than giving it the benefit of the doubt. That's a dick move, and I apologize.
See my other reply to you - using setTimeout to timeout asynchronous activites. In this scenario, your API's timeout is unpredictable and based on how long you've been on your current turn. The timeout could even be 0 or negative depending on how much work you've done on the turn. It would also be shorter the slower the device is, which is probably the opposite of what you want.
&gt; I promise you apps depend on this. No, this is completely off base and missing my point of my questioning. Apps absolutely depend on something taking *at least* a certain amount of time. But I don't know of any cases on the real current today web that use that kind of reasoning from the middle of the event loop tick, because it's impossible to know how long the code on the event loop tick has been running before your setTimeout is called. I'm trying to create precisely the kind of predictability that you're arguing currently exists (it doesn't), and rejecting your assertions that my suggestion makes that worse (it doesn't). I literally think you have this completely backwards.
From looking at their source, they're written in ES6, but their distributables are transpiled down using Babel
You're arguing for making the timeout relative to the start of the turn right? So... // synchronous work that takes 1500ms doNetworkRequest(); setTimeout(timeoutRequest, 1000); IIUC, your implementation will time out the request immediately when the turn has ended. Is this not the case? What developers depend on now is that from the point setTimeout is called, the callback won't be called for at least some number of MS. I don't see how your implementation preserves this property. 
You forgot `FormData`, `setTimeout` and `setInterval` needing monkey patching so they accept extra parameters that are curried into the function, `CustomEvent` needing monkey patching as well, incomplete `IndexedDB` (but that's also broken in Safari), `postMessage` (not the `WebWorker` one) still only works for included `iframe`s, not cross-tab/window...
I can see why that might be the case. I'm generally okay with dealing with them, but I think most prominent js devs have spent the majority of their time in jQuery land. I wish that there were a lighter, more prominent way to deal with these incompatibles, instead of installing 100 KB of junk. I can't complain too much, though -- it won't be too long before IE itself is effectively obsolete for most websites.
Great, good code example to discuss. What I'm suggesting is that I do not think most developers think about, or even can reason about, that `doNetworkRequest()` thing taking a full 1.5 seconds to run itself. I think most developers tend to code without reasoning in too much detail about exactly how long some X() statement took. The more complex the web platform gets, the less chance a JS dev has to actually correctly reason about something taking 1500ms. Today, maybe it does, tomorrow maybe it takes 200ms. When they say `setTimeout(..1000)`, the "from now" they meant was from the start of the code that decided to make the request. Why? Because they're saying "I only want the user to have to wait a moment of 1s". If the work done to make the request violates that expectation, I don't think the developer meant, "actually, that user should wait 2.5s instead of 1s".
&gt; it doesn't. That 1500ms stuff is code that runs before the network request I misunderstood the code comment, but it doesn't change any of my assertions. &gt; Is it or is it not true It *is* true of my proposal. Timer intervals would be relative to start of turn, not start of timer API call. &gt; you don't need to reason about this at all Here's the rub, and perhaps where we're miscommunicating: 1. Yes they absolutely do need to reason about the timing that happened "before", in the current implementation, if they're using the entirely arbitrary number values picked for the interval as some stand in for the UX expectations. If the UX team says "do not let the user wait more than 1s", and the developer puts in 1000 **without** reasoning about the duration of the code earlier in the turn, then they've not actually done what the UX specification requires, as the user may end up waiting 1s + length of long-running code segment. But they cannot actually, practically, do such reasoning. I haven't ever seen cases in the wild, aside from exceptions like maybe jsPerf or animation libraries with variable framerate logic, a set of code is timed for duration, before setting a timeout, and then the interval is adjusted up or down according to how long that code took. **IF** developers do that kind of thing, it's very much not common, as I've never run across it. Such logic is extremely variable and imprecise, at best. 2. But, more to my point and particular use-case pain points, "not needing to reason about", as you asserted, is only a luxury you get when there's one timer set up, and thus no misleading surprises of there not being reliable relativity between multiple timer intervals. Think of this case: `setTimeout(fn1,1000);` `// synchronous work that takes 1500ms` `setTimeout(fn2,500);` In that case, **if the dev expects fn2 to run before fn1**, doesn't the dev absolutely **have** to be able to reason about the 1500ms, because of the current implementation, and wouldn't they **NOT** have to reason about it in my suggested implementation change?
I don't think we're miscommunicating. You think the only scenario for setTimeout is "some amount of time has elapsed since start of turn" but this is not the reality - in reality people use setTimeout to mean "some amount of time from _right now_" and their apps depend on this. &gt; If the UX team says "do not let the user wait more than 1s", and the developer puts in 1000 without reasoning about the duration of the code earlier in the turn, then they've not actually done what the UX specification requires, as the user may end up waiting 1s + length of long-running code segment. Yes, I agree, if the requirement is "user waits no more than one second" then you would want something like your implementation. But that's not what setTimeout gives you today and is not what code on the internet depends on. &gt; and thus no misleading surprises of there not being reliable relativity between multiple timer intervals. If you use setTimeout to do this, you're doing it wrong. If you care about the ordering, use control flow. If you don't, setTimeout today works just fine for you. 
Perfect. So I don't need the @, I'm just using that as an identifier, so it would be /1234, for example. I know (?=) matches an expression only if there's another after it. Is there an equivalent of this that would precede the match (so that I could match the same pattern, but instead of matching the @ if there's a number after it, match the number if there's a @ before it)? Edit: That was a stupid question. forgive me. Edit 2: Documented lookbehind isn't working. Ideas?
&gt; in reality people use setTimeout to mean "some amount of time from right now" and their apps depend on this. You haven't given any evidence, nor do I think any such evidence can be found, that devs mean **this line of code** when they say "from right now" rather than **this unit of code**. That seems to be the crux of our disagreement.
Some flavors of regex have a look-behind assertion (e.g. PCRE has `(?&lt;=...)` and `(?&lt;!...)`), but ECMAScript does not. I don't see why you'd need that here though. You could use a capture group, or you could just include the symbol in the replacement text. Give an actual example of what you're really trying to do if it's not `@123`. Edit: oh, I think I see what you mean. Is this what you meant- &gt; 'foo bar @123 baz'.replace(/@(\d+)\b/, '&lt;a href="http://example.com/$1"&gt;http://example.com/$1&lt;/a&gt;') 'foo bar &lt;a href="http://example.com/123"&gt;http://example.com/123&lt;/a&gt; baz' 
Edge is Win10 plus, so everyone on Win7 is capped at IE11 It's going to many many years before IE stops holding everything back.
Ok, so by now you understand that setTimeout can't change (and that your polyfill is dangerous on the web and potentially breaks libraries with code like above). &gt; What I'm asserting is that this code is currently broken, because of bad implementation on the web platform, because the assumption it's made upon changes over time. What do you think is a worse break - the timeout firing immediately after the turn that sent the network request ends (eg. &lt;0ms from when setTimeout is called) as in your implementation, or... assumptions about total wait time changing over time (aka the app working as expected)? To me the former seems very severe. &gt; I'm arguing that the code above, as expressed, is much more naturally interpreted that the intent of the developer is for the whole task to have 1s to complete, not just the last two lines of the function. Almost no one would think that the developer intent is that the timeout occurs 1 second after the start of the turn. Most of all because that's not how setTimeout works today.
He wants to fudge pack a full-rack of fudge-packs?
How would they pick the right interval for timing out the network request without knowing how long the code that runs before them took to complete? You might say just relocate it to the start of the turn, but what if I'm using a framework that calls me when it's time to initialize stuff (every web framework today basically). Let alone requiring logically coupled code to be located a long way apart. FWIW, I've never had to implement the requirement you suggest. Network request timeouts are always based on how long the request is active, not how long the user has waited including other processing time. What is correct depends on the intent of the developer, which in turn depends on how the API works. You are not arguing from correct, you are arguing from your use cases you think are important (though in reality they are not common). Anyway I think all that I can say has been said so I'll leave it here!
 function translateKey (key) { return key.split('-').map(function (k, idx) { return idx &gt; 0 ? k.substr(0, 1).toUpperCase() + k.substr(1) : k; }).join(''); } function translateObject (obj) { if ((typeof obj === "object") &amp;&amp; (obj !== null)) { return Object.keys(obj).reduce(function (prev, k) { prev[translateKey(k)] = translateObject(obj[k]); return prev; }, {}); } return obj; } var x = {}; x['abc-def'] = {}; x['abc-def']['ghi-jkl'] = 'mno'; translateObject(x); // {abcDef: {ghiJkl: "mno"}} 
How about you survey devs without giving them a biased example. Use real code from the web (eg. the example I showed numerous times): function setup() { doNetworkRequest(); setTimeout(timeoutRequest, 1000); } Ask them how long the network request has to run. I bet they say it has 1 second to run. But in your implementation they'd be wrong. (edit: I also don't understand how you can both admit that your setTimeout implementation breaks code and also is ok to implement on the web. But suffice it to say, browser vendors can't just break code like this.)
Yup, exactly. Didn't know $1 was a thing. Awesome.
My apologies if that came across add angry or meanspirited. My intentions were in fact the opposite, to attempt to explain why social niceties matter, and maybe give the poster some insights as to why there might be wider consequences than just a couple of downvotes. If I did a terrible job at that well, then I did a terrible job. But when someone asks me why, in the realm of coding, I try my best. My best might be terrible but I can aim to improve. Not everyone understands how come social things are important. I didn't always. I learned it over time. Just like for loops and prototypical inheritance. And having others explain things to me has helped me
Actually, [it](https://www.reddit.com/r/javascript/comments/3hceo9/falcor_by_netflix_a_javascript_library_for/) was [released](https://www.reddit.com/r/javascript/comments/3hck9j/netflix_releases_falcor_developer_preview/) 2 days ago (and the video is [4 months old](https://www.reddit.com/r/javascript/comments/32z2z5/jafar_husain_explores_how_netflix_transports_data/?ref=search_posts)). No harm, no foul.
Apparently you've never worked on a codebase with other imperfect people.
&gt;That's false Which is why I said *feels like*, and I stand by my statement.because the double function passing in the Promise constructor which provides `resolve` and `reject` as arguments feels very backward to me. If you can provide me with counterpoints, I would appreciate them. Disrupted Flow Control === The anonymous function plus function arguments means suggests that you will put logic in the anonymous function^1 or circumvent that context and pass the arguments out. You need to basically know what you want to do by the time you call the constructor or you split your flow control logic to be partly inside and partly outside. I could put all the logic inside, but any conditions will likely need to climb the scope tree to get outside the anonymous constructor and access real data. var willResolve = true; // Handling some business logic .... var myPromise = new Promise(function(resolve, reject) { // resolve and reject are only accessible here // So I put logic in here to access them if (willResolve) { resolve(data). } else { reject('Life sucks.'); } }); Pre-determined Action --- Promises include `Promise.resolve()` and `Promise.reject()` so you can immediately return a promise because you know right away what you want, which aligns nicely with my opinion. Now you don't need an anonymous function... just create the promise directly in your code. function crappyLogic(data) { return data.awesome ? Promise.resolve(data) : Promise.reject('Life sucks.'); } This especially makes sense when you are using promises to create a chain of operations, some of which may be synchronous. I have done this a few times.... something like this: function massageData(data) { // Make sure the data is good if (data.baseOwner === 'us') { // Adjust the value before returning data.zigsInHanger = 0; return Promise.resolve(data); } // Or reject it return Promise.reject('Some one set us up the bomb'); } Alternatives === If I am not in one of these scenarios where I know what I want before hand, Promises/A+ leaves me either accessing variables in the container's scope to perform logic inside a callback or exposing the `resolve` and `reject` functions passed as arguments for use outside the constructor. Either it depends on the execution context of the function passed to `Promise`, or I'm working around the functions-in-functions design, which is **exactly** what the Deferred concept in Promises/A (and the subsequent jQuery implementation) does. Promisify --- `promisify` solutions do the same dance around the scope limitations. You create a promise and pass an anonymous callback from a context with access to `resolve` and `reject` and performing the `resolve` or `reject` later from outside. We either create a set of functions that look like Russian nesting dolls, or exposing the `resolve` and `reject` functions to some internal scope to avoid the nestomg depth. Partial Application --- I can choose an ugly third way, which is to create a partially-applied function which takes the data I need *and* accepts the resolve and reject. This is an admittedly crappy, thrown-together example: function isEverythingGood(data, resolve, reject) { // Some business logic var result = randomFunction(data); // Smashed together with promise flow control logic if (result.isGood) { resolve(result.data); } else { reject('Oh noes!'); } } function promiseMyStatus(currentData) { // Partially Apply a function so we can avoid the anonymous rats nest. var mySpecialTest = isEverythingGood.bind(null, currentData); return new Promise(mySpecialTest); } Compare: Encapsulating === Deferred allows me to shave one level of nesting off an encapsulated implementation by creating a variable. I find it easier to read. Deferred: --- function promiseMyStatus(currentData) { var deferred = Promise.deferred(); doSomethingAsyncAndStrange(currentData, function(result) { if (result.awesome) { deferred.resolve(result.data); } else { deferred.reject('Terrible things!'); } }); return deferred.promise; } Promise: --- function promiseMyStatus(currentData) { return new Promsie(function(resolve, reject) { doSomethingAsyncAndStrange(currentData, function(result) { if (result.awesome) { resolve(result.data); } else { reject('Terrible things!'); } }); }); } Compare: External Control === If you are using promises for run confirmation and/or execution control, Deferred just makes sense. This may seem ugly, but when fighting with third-party code that loads later, some compromise must be made. The difference here is pretty subtle. I've actually run into an issue where exposing and using resolvers out of order *worked on some browsers* even though it absolutely should not. Deferred: --- var module = (function(){ var deferred = Promise.deferred(); // Line breaks for ease of reading in the example deferred.promise .then(initialSetup) .then(getData) .catch(useDefaultData) .then(render); ... return { ... signalReady: deferred.resolve } }()); Promise: --- var module = (function(){ var outsideResolve; // Line breaks for ease of reading in the example new Promise(function(resolve) { outsideResolve = resolve; }) .then(initialSetup) .then(getData) .catch(useDefaultData) .then(render); ... return { ... signalReady: outsideResolve } }()); Summary === My read on Promises/A+ is that they lean heavily to the deterministic `Promise.resolve()` and `Promise.reject()`, or you end up splitting up logic or flow control as you move into and out of anonymous functions. That's a lot like staying with callbacks, though the flow control of .then and .catch is undeniably easier to read than a nest of callbacks and, once you are comfortable with it, allows much cleaner, more robust code, since you can stop checking for `err` at the beginning of every function and each function can be responsible for generating only *relevant* errors. I've read the [bluebird Promise anti-patterns](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern), and a dozen other thoughts and articles. Even in the "You shouldn't do this" article, there's this line: &gt; So when should deferred be used? Well simply, when you have to. I'm willing to believe I'm missing something. Please let me know your reasons. --- ^1 It can be done without anonymous functions, but it it's even messier. See the `.bind()` example.
There are two options for modifying the URI via JavaScript. * `location.href` - You can reassign a value to this property and it will change the address of the page no different than a user clicking a hyperlink. * `location.replace(mynewURI)` - This method removes the current page from the browsing history and drops the user on the value supplied. This method is similar to forcing an HTTP 301 redirect even though the page has already loaded. Examples var domain = "http://prettydiff.com/", param = "?m=beautify"; //if after this executes the user could click their //back button to come back to this page location.href = domain + param; //Once the following executes the current page //is absolutely lost. This is handy for arbitrarily //moving traffic around location.replace(domain + param);
The difference is that IE was fundamentally part of Windows. Edge is a completely decoupled browser, which will allow them to update it more frequently. Think of when Android first came out and how mail and calendar were part of the OS. Google then decoupled them so the apps could update without needing to push and update to the OS. If I'm understanding it correctly, that is what is going on with IE vs Edge. I wouldn't be surprised to see Edge running cross platform at some point.
In my experience, the issue isn't so much quantity but rather that special kind of helplessness you experience when a user reports an issue with your website and it's just not a straightforward inconsistency. For most projects it just makes more sense to eat 30 extra gzipped kilobytes at the start and plan to factor out jQuery "someday". It's not like you feel productive when you spend a week tracking down an obscure bug reported by a couple users that turns out to be from the fact that IE10 can only handle up to an arity of 3 on some window method where you passed in 4 arguments. Rather, that's the recipe for suicide ideation.
Nice, its much more appealing that way. If hood.ie doesn't turn out to be my savior i'll consider this. 
I think node doesn't get enough hate.
http://survivejs.com/ seems to be a great resource, thanks for the link! 
http://codepen.io/jamon/pen/XbLdPW
Out of curiosity, the people that don't like using Bootstrap for its dependency on jQuery or whatever else, what does your front end framework normally look like? Personally, I've been playing around with Flexboxgrid, MaterializeCSS and my own grid system recently instead of Bootstrap.
It has some strange design decisions based on trying to force everything into a purely functional view of the world (single state atom, all state being derived as reducers over actions, erc). Tough to shoehorn a complex application architecture into those concepts alone. Middleware seems like a bandaid to fix that too) It only got real traction because Dan Abtamov apparently shits gold bricks and everything he does will get a billion stars in GitHub)
lol.
I knew the keynote is old, but I find this one particularly good because it explains the issue and solution in much more depth than other talks about Falcor
I think it kind of depends on how you view Firebase. If you view it purely as a database, then I would agree that it's far too expensive for the data storage you get. However, when you consider the realtime aspect of it, I think the pricing becomes a lot more reasonable. For reference, you can look at the pricing for [pubnub](http://www.pubnub.com/pricing/), which just provides realtime push.
How does this compare to loopback.io from strongloop? Have you used loopback at all? 
But didn't they remove support for &lt;ie9?
Supposedly Crockford, the proponent of `Object.create()`, is now an opponent of it. Surely that says something. Crockford also thinks `new` is the devil, so I think he's a little off. Just use prototypes and `new`.
&gt; for a couple months now It's only been around for under two months...
Why bother with Bourbon anymore when there's [Autoprefixer](https://github.com/postcss/autoprefixer)?
the python-esque syntax is partially why I will continue using coffeescript indefinitely... many arguments around moving from coffeescript back to pure js are based around "language features", but the truth is the crisp, clear, concise, indentation based syntax of coffeescript is far superior to native js all day.
There is a polyfill for that: https://github.com/github/fetch You can use fetch today, if you want.
BTW this was exactly true, messed around with Node and Express for the past three months, learned a ton. Now I'm coming back to rails understanding its "magic" and having fun with it! You must be a psychic.
`Object.create()` is, to be completely blunt: fucking stupid. Some people will contort themselves into all sorts of crazy shapes to avoid the "evils" of classical inheritance, including using dumb apis like this. Just use es6 classes ffs, and don't go nuts creating deep, highly coupled class hierarchies. (I say this as a proponent of functional programming too, so i'm not some Java-loving OO nut)
If you're using Chrome, press F12 and you'll see that Chrome Dev Tools will open. There, you need to click the Console tab to see the console. If the site/app that's loaded in the browser tab used any console.xyz() statements (console.log, console.warn, console.error, console.table, etc), you'll see them there. You can also type JS expressions or statements into the console yourself, such as `2 + 2` or `new Date()` and so on. Firefox and IE/Edge have their own similar consoles as well.
So you move your codebase over to ES6 and then go and shit it up by adding Bootstrap? Seems sensible.
Personally I now build most webapps with a separate backend api. This provides a number of nice advantages. It forces you think about the structure of application and create clear layers of separation. Also it gives you the flexibility to choose different technologies, frameworks, solutions for the different parts of your webapp. Maybe you start with the frontend in AngularJS backend in Java. Some point in the future you could start learning another language or framework and you decide its a better fit, with the separation it makes it far easier to make changes. While I think building the backend separately is a good choice, building it in isolation is not! You'll want to build your api in collaboration with the frontend dev. This way you can discuss how and in what format data will be passed and decide on an agreed api, which is ideally documented. In collaboration you may also find some frontend operations being done may be better suited for the backend and vice versa. A function like login would just be exposed like any other function. Whether is an interactive function or not doesn't really matter. With the rise of more powerful frontend frameworks i'm finding that a lot of the work backends use todo has shifted to the frontend. The backend for most webapps now generally just handles authentication and crud-ing data.
Great article! 
Just expose it as a Rest Api, like you would a mobile app. Your Rest api becomes a universal interface for all types of consumers using http. e.g mobile apps, frontend code, other backends. The main difference with frontend calls to backends is that you need to make them on the same domain otherwise you run into Cross-Origin security issues. Heres a small example of an Angular frontend calling an NodeJS backend https://github.com/DaveRobson/angular-demo
Appreciate the response. I still don't quite understand though. In a nut shell here's what I'm doing (or trying to do). My CSS selector for my header is actually: .app-header, [class*="app-header-"] {...} In my JS I would like a nice simple way to select this. The name "app-header" is stored in my module's config, which I have access to in my JS. Looping through the config, I can create a global variable for each module like so: window[component] = '.' + componentRaw + ', [class*="' + componentRaw + '-"]'; In the above, "component" = appHeader, and "componentRaw" = app-header. This now allows me to alias my selector by using: $(appHeader).addClass('test'); Which is actually translating to: $('.app-header, [class*="app-header-"]').addClass('test'); Consequently, if I'm understanding this correctly, what you are suggesting wouldn't work. It would pass the rest of the module's config instead of the selector.
JQuery is a Javascript library that makes certain things easier. i would do javascript and then JQuery so you know what's going on.
`&lt; != &lt;=` Why the downvote?
the configuration for your module should not be global. what if you have two or more modules that have the same keyname for a piece of configuration but that configuration is different per module? What if in another module, you don't use that configuration, but accidentally over write it anyhow with another global variable of the same name? There are many reasons to not want to use global variables so I won't go into all them here, but I suggest googling. Ideally, you should be giving modules their configuration rather than having the configuration on a global scope. Less than ideally, you can have a singleton object that modules can access. var MyModule = { options: { 'app-header': '.app-header, [class*="app-header-"]' }, setTesting: function() { $(this.options['app-header']).addClass('test'); } } now instead of doing window['app-header'] = 'css selector' you do MyModule.options['app-header'] = 'css selector'; Of course, it depends on how you make your module. If it's a class that you instantiate, then pass the options into the constructor. Either way, It's far cleaner than having the options on the global scope. If you really insist however on using the global scope, then namespace it: windows['options']['app-header'] = 'khsdglkhsdg'; Then access it: options['app-header'] This is still far better than putting the individual configuration keys onto the global scope. I highly recommend googling around for global scope best practices and namespaces. Javascript does not have the syntactic sugar for namespaces, but the example above is just as good. 
If you learn dom manipulation with native apis you won't move to jquery
Yes
Yes.
Thanks for bearing with me. It's clear I still need to do some more reading, but in the mean time please humour my ignorance... I don't believe my use of global variables will be problematic. Each of my modules has a unique name (eg; app-header, navigation etc.). The global variable only returns the unique selector (eg .app-header, [class*="app-header-"]), it doesn't store any configuration. Thanks to some other custom functions I have created, I'm now able to do things like: if(setting(appHeader, 'sticky')) {...} and if(breakpoint('min-width', 'break-3')) {...} To me, this seems pretty good, I can't think of why I would need to change it. With your recommendation, would my code now become something like: if (setting(module['app-header'], 'sticky')) {...} If so, I'm starting to see the benefits, I think. If not, then I'm even more lost... However, I really really don't want to be doing anything stupid, and if you're telling me I'm wrong I will keep reading and asking questions until I understand why. Thanks for your help.
That's ... brilliant! 
If you want to learn raw javascript there are better ways to learn it than through trying to do DOM manipulation. In practise jQuery handles a lot of cross browser compatibility issues. The only scenario I can think of where it would be handy to know DOM manipulations with raw javascript would be when you're working on a project where you *really* can't afford to include the jQuery library. Even then it would only be a matter of looking it up. A good approach to learning javascript would be to try learn it outside of the context of the DOM. That way you're picking up some programming fundamentals as well, and not just the DOM API. And then the sweet part about that is that once you have a handle on js as a whole, you can pick up new frameworks (like jQuery) very easily. A couple titles that come up often for raw js study are Javascript The Good Parts and Eloquent Javascript. Good luck!
I'm actually mostly hoping Babel covers it :P But still, even if I'd have to keep track of multiple polyfills, the advantage of them being small is that they most likely hardly ever will have to be updated. Add to that a package manager, and you have both documented and made sure you remain up-to-date those that will need to be updated.
You don't realize what an amateur-ish question this is. Any programmer worth his salt can manipulate the DOM without jQuery and learns this first. EDIT: I find it hilarious that I'm parroting what most of the other upvoted responses are saying yet I get downvoted by typical reddit fools.
You can learn jQuery as a way to 'enter' the language, but I think jQuery won't make you learn any good practice. So you'll have to move from it quickly or you'll be stuck with it. Best place to start (without jQuery) would be ['Javascript: The Good Parts'](http://shop.oreilly.com/product/9780596517748.do) from Douglas Crockford. This is easy to read, short, and very accessible.
Hi, the other responses in this thread are good but this is what I have found to be the best approach. Comes from [Mark Trostler: Testable JavaScript - Architecting Your Application for Testability](https://www.youtube.com/watch?v=JjqKQ8ezwKQ) - approx 45 min video. The gist of it is to pass instances to constructor functions, instead of inheritance, es6 extending, etc. which will keep your classes flexible and also independently testable. Here is your example with a mix of both es6 classes and prototypes. function Foo (name) { this.name = name; } Foo.prototype.sayHi = function sayHi () { console.log('Hi my name is ' + this.name + '.'); } class Bar { constructor (foo, prop) { this.prop = prop; this.sayHi = foo.sayHi; } serveDrink (drink = 'Tequila') { console.log('Here\'s your ' + drink + ', enjoy.'); } } // ...so on (create minibar class, etc)... // Then to use these classes you pass in all of their // dependencies when creating them; i.e. avoid `new` in // the constructor // Example: var fooInstance = new Foo(name); var barInstance = new Bar( fooInstance, prop ); // If you don't want new keyword scattered all over your code // then add a static factory function to your classes Bar.create = function barFactory (name, prop) { var fooInstance = new Foo(name); return new Bar( fooInstance, prop ); }; Hope that helps; feel free to ask questions
Consider using React.js so you won't need to manipulate the DOM manually at all.
I didn't down vote but yes I'm aware that means his comment is still valid when supporting IE9. But my point was that when they dropped support for IE8 they could have dropped jQuery as well. While I add a few polyfills for IE9 in general I find myself foregoing jQuery and not missing it on projects that don't need to support legacy browsers.
Yes
Great intro but it skips some of the more interesting issues. How would you do this for a class based service that uses dependency injection? The constructor is used to write up injected angular modules so it's not as clean to new the class in the test. 
Thank you! Just one question, why exactly is it not clean to instanciate class by yourself by providing mocked dependencies as constructor paramether in a test?
It's not that hard anyway :)
Yes, especially so if you're working with modern browsers. I've have been writing all my projects targeting IE9+ without jQuery for a while now. As for syntax, I don't think I could go back. There is beauty in the expressiveness of the native APIs: span = document.querySelector('span') span.classList.toggle('green') A further point, there are loads of libraries on npm to abstract away the tricky parts. For instance, want to remove an element? Import [dom-remove](https://www.npmjs.com/package/dom-remove) and: remove(span)
That's not what he said. I think that when he says 'jQuery devs' he means those who use jQuery, not those who built jQuery. Because jQuery is definitely well developed. And it achieves a very large amount of work concerning cross-browser/platform.
As an alternative you can also use their selector tool [SizzleJS](http://sizzlejs.com/). Which will let you do DOM selection only. Still... start with fundamentals.
http://youmightnotneedjquery.com/
Actually, that last fiddle didn't work. When I included **alert(elems)** to see what the problem might be, the alert says **[object HTMLCollection]** ...so it's not actually simplifying it in a way that it contains a string of text... but another solution worked, so I'm not asking for more help! Just thought I'd post it for posterity or whatever.
django and angular :)
Well, you could probably be using `Map` for dictionaries instead of objects unless you have to support IE and Safari, in which case maybe in a year or so.
what's a "jQuery dev"? I've honestly never met a developer who _only_ knows jQuery and can't do any other programming. maybe you mean "most bad developers don't seem like good programmers". in other news, the sky is still blue, and the sun rose in the east this morning. 
Epic trolling right here. 
I know a lot of people who only know jQuery. Everything has to be a jQuery plugin. All I'm saying is, be a well-rounded developer.
&gt; I know a lot of people who only know jQuery that's weird, because I've literally never met one in a professional setting. the only non-programming "developers" (scare quotes intentional) I ever knew were kids who flunked out of my college's CS program. where are you finding these people? freelancers or something? 
&gt; if( document.getElementById("categorytitle").innerHTML.toLowerCase().indexOf("hello") != -1) {//dostuff} THIS WORKED. YOU THA MAN!
I'd recommend Professional Javascript for web developers. It's super complete.
Front end used to be Backbone.Marionette, Handlebars, SASS, Require, Grunt, and Jasmine. Now it's React, Redux, Babel, SASS, Webpack, and Jasmine. 
I personally learned jQuery first, and once I felt like I had mastered that, my natural curiosity led me to want to figure out everything I knew in native javascript. If you NEED to get a project done right now, learn jQuery first. It will be easier to translate the things you want to do into functioning code, and it lets you take a lot of shortcuts. Just make sure that if you go that route, you eventually try to learn the vanilla JS that powers everything you learned in jQuery.
That's a good thing, right? But all joking aside, if you put `var $ = document.querySelectorAll;` at the top of your script you have created a light version of jQuery that covers about 80% of it's usage. For most of the remaining 20% there also already exist standards, but most of them aren't widely supported yet. For those polyfills will suffice. 
Think of it in terms of servers and clients instead of mobile apps versus browser apps. In the past, when you've written a mobile app that communicated with a rest API, you created a server (the rest API) and a client (the mobile app). The client (mobile app) communicated with the server (rest API) via asynchronous requests using the http protocol. Once your client received data back from the API, it did some sort of re-rendering of the UI. To summarize, a client makes asynchronous http calls to the server, gets data returned, then renders any necessary changes to the API. &gt; I'm confused because I used to build webapps that were entirely rendered on the server and all done from a single backend application like in PHP or something, so I'm not sure about how to structure the app with the kind of separation you have mentioned. In the case of a browser app it's no different than the mobile app example above. You'll make ajax calls (asynchronous calls via http) from the client app, get data back from the server, and then render any necessary changes to the html/css. Many people use front end frameworks, such as React or Angular, to assist in writing the client side app portion. The beauty of the rest API is that *anything* can be a client as long as it can communicate with the server via http. In fact, that's pretty much the whole point of building an API server versus the way you've written web apps in the past where everything is in one monolithic web app. 
Is using native APIs still a bunch of document.getElementByUngodlyLongFunctionName('whatever')? I discovered jQuery 5 years ago and I've never gone back.
Yeah, why not?
That's slightly better, since at least it's a single function. Still way too wordy for such a common operation, though. And yes, I realize I can write my own function to do a shorthand version of it. :) 
&gt; That's a good thing, right? Maybe, maybe not. &gt; you have created a light version of jQuery that covers about 80% of it's usage. Since we're pulling random numbers out of our asses, qSA covers 5% of jQuery's usage and 0.5% of its API. &gt; For most of the remaining 20% there also already exist standards There's no standard to apply operations to nodesets, and that's before talking about manipulating nodetrees because moving, adding and removing nodes with native DOM APIs is anything but fun[0]. Same with traversing trees upwards. And let's not talk about event delegation, `Element.matches` is useless garbage for that. So yeah, if you're doing nothing more complex than selecting a few nodes (or, really, just selecting single nodes which can not be absent using `querySelector`) and changing their text content, native DOM APIs are competitive with jQuery. [0] unless the only things you ever do are "remove everything from an element" and "add a new child at the very end of an element". Oh, and clone a single node, so that's 2.5 out of about 25 jQuery calls, 10% coverage, native DOM's looking positively good there.
You shouldn't have been downvoted. It's a *great* consideration and removes a lot of the juggling of trying to manage state from event handlers, global variables, and manual DOM manipulation.
where are the words stored?
&gt; what they're going to do when jQuery falls out of the mainstream Probably use a much better-designed version of javascript in a much better-implemented vendor ecosystem than when they started using jQuery.
Yeah I didn't really like this much when I first saw it. I mean I partially get where they're coming from, but at the same time do you want to have a lot of mental overhead of remembering semi-colon here but not there as well as being entirely different from 97% of the rest of the code available on the internet? And then there's the "always do this... except..." and "always do that... but..." Ideally you want formatting rules that are easily followed and/or automated by the editor (but still easy to follow in Notepad) so that code check-ins are consistent from author to author and you don't get crazy diffs every time the next editor automatically reformats the code. The idea of code formatting rules is to reduce errors through consistency and code readability. I'm not 100% clear on how this standard achieves that specifically. Plus it seems pretty light for a "standard". What about variable assignment placement, new lines, placement of braces, array definition, trailing commas, constant definition, private definition, etc. 
That you have to ask the question proves my point about incompetence.
It would be hard to fire myself after 11 years running a highly successful web dev business. Especially one that maintains a web site that you likely visit every week or two.
I've rejected interviews where the candidate listed jquery as a language skill. 2 to 5 years of experience. 
https://jsperf.com/getelementbyid-vs-queryselector/28 might be interesting for everyone.
$.ajax is still useful
The problem is not jQuery, the "problem" if you can either call it that way, is that for many people simple DOM manipulation is enough, and they just don't have the will or the need to develop their skills further. If you take away jQuery you'll have the same DOM manipulation spaghetti code, just without jQuery. And professional developers can also be sinners. When there's zero UI behavior specified in the beginning of the project, and the designer/client keep popping up with requests like "Make this popup an in-page popup instead of a real popup" and "Make the FAQ answers open when you click the question" on the fly, you will end up with a 500 lines main.js file with $("selector").click() all over it. 
They're just trying to make sure they have everything someone is looking for. I've seen people throw out people who list "javascript" and "jquery" but not "coffeescript." The reason people throw "CSS, LESS and SASS" on their resume is so the idiot in HR isn't like "Oh, there's no SASS here," if they say they know "CSS and pre-processors." Resumes for software are just terrible across the board.
Exactly, I'm counting on those :) Guess I just didn't bump into things not supported by them yet.
Ah, the man who invented Grunt, Ben Alman, was a jQuery guy. What a snooty remark. 
Vim
Sorry, that's not my type of editor. I'm not into using the keyboard for everything and also I'm not into using up weeks and probably months to properly work with a text editor :/ Edit: Also, the community seems to be pretty toxic. Downvoting me for disliking your tool... great motivation to get involved.
Yeah!
I try not to use it at all these days, it's not as important as it used to be.
the list (after it's been generated) is here: http://compluter.com/dictionary/include/diff-dict-codepen.js
Yup. It's some random guy who doesn't look to be that great at programming trying to force his own style on everybody. It's not a case of 'I did research and these are the most common code practises', they're literally his own. That and going against best practisessemicolons really are a must.
The problem is a ton of people are using it.
They exist... I used to work with *two.* Actually, one of my co-workers right now is a recovering one, though to be fair, programming wasn't what he went to school for like the aforementioned devs.
You should always learn how to do things without the aid/crutch of libraries and frameworks. This goes double for learning common design patterns, what they're used for, what they're not used for, their pros/cons and how to implement them in your language(s) of choice. If you want to be a good developer, you need to understand the implications of your code and design choices and for this, you need lower level understanding of how things work.
Fetch is being implemented in browsers as well as node: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
He's not asking if he should use jQuery or not, he's asking if he should learn how things are done against the DOM without it.
Aye, until you use `Array.prototype` and get your beautiful functional pipelines back..!
yeah... right... 
There are packaging/build solutions that let you use Node modules in the browser. A lot of folks who would have the opinion that modern apps should use native Node already have things like webpack or browserify pipelines in place.
&gt; Is jQuery dying? As a resum buzzword? Definitely. As a useful tool in your toolbox? Nah. Some of the newer SPA frameworks reduce the need for jQuery since they handle DOM updates for you. I still use it in my React project, but only for reading from the DOM; never to mutate. For static websites, it's still quite useful and contemporary.
You should include what he wrote after that quote. This is much preferred: var nums = [1,2,3] nums.forEach(bar) 
Then let them use, people are free to use whatever they want, it's more down to readability or preferences. It doesn't break code so there's no problem with that. I doubt a large amount of people do this, this is almost the same as using spaces or tabs.
Are there actually? In the repositories list, I see a lot of projects, but fewer than 10 users.
Short answer, Yes. Long answer, absolutely. It's very helpful to understand the process that happens at the raw level. It helps you to understand how it actually works because there are very few shortcuts at the raw level. Can make debugging a lot simpler. Also if you are learning jQuery I suggest taking a peek at [this](http://oscarotero.com/jquery/).
You're contorting what I said.
FYI - Ember uses jQuery. But, it is using it less and less. Currently, only views rely on jQuery so I could imagine jQuery going away in 2.0 (because views are going away in 2.0). I feel like the way Ember needs jQuery less and less is a good microcosm for how js devs in general need jQuery less and less.
#Yes
w3schools?
They are not actually suggesting you do that thing with the semicolon in the front, from what I recall that is in the segment talking about semicolon insertion. In general the standard style is very close to what I was writing already, with small exceptions (extra spaces after `if` and `function`, stuff like that). 
I believe that backbone uses jquery too.
Exactly. Use libraries and frameworks when they make things easier. But none will cover every use case. At some point, you're going to find something that it doesn't do and you'll have to code it yourself.
I bet you're a hit at parties.
This applies more to the nodejs world, you will find many more there. But there are 2,435 stars, it's really not niche.
It's being called "standard".
So, on Firefox 40.0.2, it's about a sixth as fast as querySelectorAll() selecting by ID and half as fast selecting by class. So if I'm going to be doing a large volume of selects by IDm it's a lot better to use vanilla javascript, but I suspect for most use scenarios it doesn't matter very much. (And if I'm really concerned about speed, querySelectorAll() isn't a great choice either.)
downvoted for parroting something that has nothing to do with DOM manipulation.
Ya, I just think that's an overreaction. But whatever, your prerogative.
Anytime we work on a simple throw-away project and try to go without jQuery we end up re-implementing a fair amount of its abstractions in vanilla JS (and feel silly afterwards). So now we just fukkit use it for DOM stuff whenever full MCV (React now) is too much. Everyone got better shit to do then re-inventing the wheel.
How did I know before even looking at the page that it would have something to do with Ruby. Seriously, we don't need yet another language that sits on top of Javascript. You aren't helping Javascript, you're just helping Ruby developers who don't want to take the time to actually learn Javascript. Also, be prepared to have the "it's 20x faster than React" completely torn apart.
Yeah, I'm not saying don't use jQuery. I'm just saying, understand how these things work under the hood because there will be implications and you'll also come across cases where your library/framework won't do something you need it to. Then you'll have to do it yourself.
Tell that to HR though. It happens.
[Eloquent JavaScript](http://eloquentjavascript.net/) helped me a lot. It is definitely one of my top recommended books. Learning the basics is key to being a successful and efficient dev.
Maybe it wasn't intentional, but your disposition of jQuery is dismissive. For what reason? People who use jQuery aren't programmers? You know, the same sentiment was held about those who practiced JavaScript in the 90s over Java. If you're going to dismiss jQuery at least provide some good arguments, like speed and performance. 
how would i learn about all these newer javascript methods?
That's what intellisense is for.
1000+ devDependents as of a couple weeks ago. Not the most popular tool, but pretty popular. https://gist.github.com/feross/e0882df2fe673d6ce064
It's really not much harder, it's just more verbose. You can do both in parallel. Compare and contrasts Jquery to pure Javascript. What's important is to use what you feel most comfortable with. [Check this out](http://gomakethings.com/ditching-jquery/#native-javascript-apis)
I always use promises. In 99% of projects jquery is there anyways so I might as well use it for ajax.
By all means, let's blindly follow one man's ever-changing opinions on how to write software.
Thanks, i checked out pm2 and got it up and running on my droplet! I appreciate the comments about the deployment workflow being ok for now. I am not eager to set up anything too elaborate right now. If i want to redeploy, i can restore my droplet to a fresh snapshot, re-clone my git repo, change 4 lines of code and fire it up without too much hassle. I'm not sure what you mean about needing nginx to avoid having to use the IP + port number... I have it set up now with my domain name working and no nginx. just running my app.js (with pm2 now)
This is completely true, but it's also inaccurate. Node can, and is often used, on the client side. I personally use it for module bundling, importing components and modules, emitting events, and downloading/installing packages. I know absolutely nothing about constructing serverside applications using it.
If OP doesn't like vim/emacs and etc why should he downvoted? This thing of down voting for simply not agreeing is shameful, specially when there's lots of editors to pick.
Thanks this is great, with nice code examples too. :)
Wow. I had no idea jquery was that much slower than raw javascript. Why is that?
Using `classList` in IE9? Don't think so. Not without a `DOMTokenList` polyfill you aren't.
In my opinion jQuery is just becoming more irrelevant, browsers are starting to actually become a little more standardised. Although Isnt this really the goal for jQuery, when it does becomes pointless to use then the developers who created it surely should be happy that their message has got across.
For animation you'll be hard pressed to beat GSAP for speed and fluidity
You gotta polyfill the shit out of it all. That's not a problem, though.
&gt; I still use it in my React project, but only for reading from the DOM; Could you elaborate on why you use jQuery to read from the DOM when using React? Couldn't you use refs and `findDOMNode ` instead?
Well, if the language is based on Ruby, then I guess it makes sense they have 9,001 different ways to do the same thing. :(
Living this nightmare, except its a 'configurable' selective DOM twisting and mutation that makes handlebars squirm away.
&gt; Not going to lie; most jQuery devs don't seem like good programmers. I honestly wonder what they're going to do when jQuery falls out of the mainstream. Most "jQuery devs" don't build complex applications, they need a fancy carousel or a modal on a campaign, corporate site or a blog, built on a CMS. Throwing a popular jQuery plugin on the site, activating it on document ready and throwing in a configuration object gets the job done in a very cost efficient way. You've got finished, billable work and a happy client. I haven't used jQuery in a while and gravitated towards applications, but I think it's ridiculous how some people have developed a snobby attitude towards the whole library and it's users, because jQuery is still incredibly valuable and popular tool who have some really smart people behind it. If you enjoy optimizing the builds process and doing unit tests for the elegant, well-documented modules you write according to latest ES specifications and good design patterns, great. You are probably building an application in a team and good programming practices are expected. Jump into the role of the "bad programmer jQuery dev", start doing the same and you'll only end up with delays, pissed off clients and confused co-workers, who don't give a damn about 90% of the things you spent time on and just want something that works until the next site renewal in two years. jQuery isn't going anywhere any time soon. Just take a look at eCommerce platforms and Wordpress. If it goes away, that sort of web development will be using another tool that allows them to do satisfy the requirements in the most simple way, with minimal amount of work. It might not be "good programming", but it doesn't have to be. At least it's not over-engineered.
Yeah, I almost bought it (elm), until I've read that they drop lazy evaluation, which is one of the most intriguing feature of Haskell.
Clessg is saying dont fall into the trap of using a jQuery plugin for every problem, creating an increasingly leaky abstraction. If your jQuery use goes beyond finding a DOM element, pulling information off of it, or manipulating it, you might need to scale back.
Oh I'm sorry, you are right :p You are only running one application on your droplet, so you are fine without nginx and the features nginx offers *for now*. I would still recommend you to put nginx in front of your node app in the future when you need to: - add SSL - directly serve and cache static content such as images or fonts (source: http://blog.modulus.io/supercharge-your-nodejs-applications-with-nginx) - run multiple instances of your app to handle higher traffic Nginx might not be required, but it sure makes things a lot easier if you find yourself having to worry about these.
The main ones for me: - es5 array functions (foreach, map, filter, etc) - es2015 promises (really promise libraries in es5 that got promoted to a native feature )
&gt; nodes.forEach(node =&gt; node.setAttribute('foo', 'bar')) &gt; Does not work, qSA returns a `NodeList` , not an array. To interject here, this one is easily overcome with: [].forEach.call(nodes, node =&gt; node.setAttr...)
What's wrong with NodeList?
[**@jdalton**](https://twitter.com/jdalton/) &gt; [2015-08-20 00:46 UTC](https://twitter.com/jdalton/status/634164666302775296) &gt; In browsers w/ spread try: &gt; NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; &gt; &gt; Then: &gt; [...document.querySelectorAll('div')] &gt; &gt; Aw yiss! ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
jQuery is fine. I still use it quite a bit. My point is that you should also try to become a well-rounded dev and learn things outside of jQuery so that you aren't unemployed in a few years. 
My observations dictate most people use whole jquery for just one feature.
I can never decide if I should leave jQuery on or off. There are a lot of places that like to see that skill, but there are also some that go "Oh, jQuery. This guy must only know jQuery" even though JS is listed as well.
I keep it in my resume, but mention it as a library I have experience with. As opposed to the oh so many candidates I've encountered that mentioned it as a language they're familiar with.
I think we did just fine given our requirements.
[zepto.js](http://zeptojs.com/) comes pretty close to what you're describing.
Great! I guess I'm speaking to a broader context than just one company/process.
jQuery released a subset of jQuery that drops whatever you want. You can build a version with whatever you want. And someone made a build builder http://projects.jga.me/jquery-builder/
It's a clever trick, but not good to use for others reading your code. I really like [`str.includes(substr)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) as an alternative to `str.indexOf(substr) &gt; -1`
I don't think it's necessarily gimmicky, but I get where you're coming from. As far as readability goes it seems much cleaner to me, but if you're not familiar with it or you have to worry about junior devs reading your code then it's probably best to avoid. Some people might encounter it in the wild and I wanted to possibly help shed some light on what is actually going on.
Sure. I'd be retarded to impose these kinds of filters on inexperienced candidates. This is usually a good way to filter out the walled garden "Experienced" developers who've never actually gotten into the weeds to learn the nuances. This usually works out for the team as well as you're not throwing a bunch of money at someone based on their years of experience and then wasting a lot of time training them from basically scratch. Very diminishing returns.
I think ES6 generators are going to be huge as well.
&gt; JavaScript on the server Said Netscape in 1995
I think this is sound advice.
&gt; Is jQuery's popularity fading? Yes, with the popularity of older IE going away and modern helpers existing right in the core then people are needing jquery less and less &gt; What are its preferred alternatives Plain old javascript http://youmightnotneedjquery.com/, but you can also use http://zeptojs.com/ if you like something minimal One big thing I miss are the promises which IE does not support, but they can be polyfilled in various ways or a ton of folks are using Babel these days which has a nifty polyfill right there.
Neither The web would not be where it is today without jQuery. But in my opinion React, Angular, and other declarative frameworks are better options for new development. I would go directly to one of those frameworks. In my own work I use React with a [Fetch polyfill](https://github.com/github/fetch/blob/master/README.md) for Ajax.
This.. The "learn vanilla js and you won't need jQuery" stance is misguided.. Might not *need* jQuery, but without you just end up implementing it yourself.. Only good reason to avoid it is for extreme performance needs
With the growth in isomorphic JavaScript shouldn't we have common standards for JavaScript regardless of where it executes? 
"Vanilla JS" is a term that typically refers to the DOM API, XHR/fetch, and other native APIs.
Sounds like you're asking what new things came into browsers not just JS? Because DOM and ajax and those libraries don't have too much to do with the script engine. I'd say getters/setters in ES5 was big (in addition to the array methods of course) in terms of enabling new coding patterns. Classes, generators, and promises will be huge in ES6. Async functions will be huge in ES7 (but of course I'm biased ;)).
I'm talking about the fact you will find this style in nodejs projects, not pure frontend projects. Many notable ones, such as Max Ogden's use the style, and if this style is controversial in any way, it's gonna be pretty annoying to deal pull requests that disagree with it.
I'm more curious about what early JavaScript was like, it's original intent and uses, but I wanted to leave the post generic enough to cover the whole lifecycle. True DOM isn't JS, but a good amount of JS is used for DOM mutation and a lot of libraries were created to provided a single approach to work across all of the JS implementations by the different browsers.
Yeah definitely! I hope they change my life as much as promises. ES2016 strawman for Observables looks convincingly amazing as well!
Yes, I've noticed there are a lot of people on reddit who think they know better than you. Dunning-Kruger in effect.
jQuery is written in javascript. getElementById/querySelector are native browser functions that are written in c++
Its interesting, but all it really shows is that unless you are doing thousands of selections in your website then there will be no appreciable difference. Most use cases involve selecting a few elements and storing them as a variable (*var foo = $(".foo")* ), and if your case involves making tens of thousands of selections then you should probably not use jQuery. For most people this is not a reason to avoid it though. 
Was going to suggest this. Judging by his comment, he could probably swap Zepto in place without any issues.
How do you expect generators to do this (change your life that is)?
No. Please give me an example of how Dojo did declarative.
The above comment could have implied that he had made a U turn decision on Object.create, when it was in fact an evolution of opinion. I was just clarifying the point; not blindly following opinions is the exact reason I was trying to provide more context. I'm not a fan of everything he advocates.
Omg the confusion is unbearable. Get/set is es5 not es6. Get a grip on your JavaScript!
I'll have to check into that again. Last time I looked, it didn't seem like mutation methods were a discreet "module" that you could drop from a custom build.
Except running serverside node, you know you're running on one JS engine, v8. In a browser, you're using whatever the browser's JS is, and whatever ajax it implements. What's keeping node's API afloat &amp; reliable across all browser engines?
Mostly organization. The methods are organized in containing articles. I start to use this, but quickly found it to be too tedious and grew fearful that I'd easily miss something.
We fired the ones that didn't work out quite quickly. I don't think we cared much about that.
I'm aware of that but I just figured jquery selectors were wrappers for the raw JavaScript. Is that not the case?
Have you tried reading the dox? https://developer.mozilla.org/en-US/docs/Web/JavaScript
Aw, thank you.
I know this might sound harsh but to me, it sounds like the candidate dodged a bullet there (assuming these BS reasons for the rejection are true). I'm only half-joking... but someone who calls themselves a *Principal Engineer/UI Architect* sounds like a *designer* to me. Why not call yourself that. And who decided it was a good idea to put you in charge of what I assume were *programming* interviews.
This? http://codepen.io/anon/pen/ZGdvvv
I am not a designer - I'm learning that for sure. I architect web applications. I have the experience that made a principal engineer. These titles are all arbitrary, for sure but that's what was given to me. I don't think that someone who claims to have 3-5 years of experience in building web applications would put jQuery as a "language" in their resume. That would not be a BS reason. Although, the initial post was mostly in semi-jest; I put developers through their paces in all interviews. I wouldn't cheat myself or the team out of good candidates.
Thank you!
We are stuck with jQuery because it's mixed in with some legacy stuff, but do not use it in new code. No other big libraries like that, no underscore etc. We write node-style modules and use Browserify to bundle it, ES6 &amp; Babel (babelify transform). tape + phantom-js for unit testing. eslint for linting, we write in "Standard" style. We write our widgets and other things as Node streams, lotsa streams in our code so we use several stream modules like duplexer. For templating and markup we use Ractive which has a lot of similar ideas to React, though it uses HTML/Mustache templates instead of render functions. No build tools, just Browserify + npm scripts (this is very doable if everyone on your team uses Mac/Linux). Server side is pretty much a standard django app, Sass for styling
I don't see the benefit of knowing how to do it both ways. Yes, you should know functions like document.getElementById exist, but the only time I've ever needed to has been for interviews. Realistically, even if you learn and memorize everything for both JQuery and native, you'll slowly forget the one you don't use often. At that point you've just wasted a week, or however long it took you to learn the native javascript way. If you really have to know the native javascript way, you'll have Google, and you'll know that that particular DOM manipulation is possible with javascript in general. At this point, why not learn every javascript library out there, to be "well rounded". Learn how to do complex time and date manipulation without moment.js, " just in case". It's madness. Look at it another way. The company you work for is either going to use JQuery, or it won't. No company will ever suddenly say, "OK Bob, now rewrite all this without JQuery or you're fired". And enough companies use JQuery, and expect most webdevs know it as well, that they'll completely understand if you don't know how to rewrite all your code without JQuery. 
Nah. It's a pretty mechanical translation from a jQuery solution to vanilla Javascript, the code just becomes uglier and works in fewer browsers.
Right, I meant specifically with the `indexOf` method, not just general bitwise operations. 
I try to exclusively use Angular these days my self But then something comes along, and it's always some jquery plugin that requires jquery and it perfectly matches exactly what I want to accomplish and the no jquery alternatives miss the mark ever so slightly enough to not warrant the time involved in getting it that way. Thankfully that's going away slowly. I don't hate jquery, nor am I avoiding it because it's trendy to do. I'm just trying to keep my JS load as light as possible because the amount of script writing dedicated to just the angular controllers and directives and its various extensions and plugins and such is enough to make me nervous about browser performance :p
Short answer: no. Long answer: [this guy explains it way better than I can](http://www.quora.com/Does-Node-js-utilize-XMLHttpRequest). I've personally had no problem using `http` browser-side in applications where I gave no fucks about older browsers. That said, `fetch` seems to be emerging as the preferred standard.
&gt; For example, the new class constructor functions will throw an error if they're invoked without the new keyword, whereas that behavior cannot be replicated with ES5 code. Couldn't you do something like: function Foo(){ if (!(this instanceof Foo)){ throw "Some error"; } }
React allows you to approach your Dom in an understandable fashion. There's no complicated state to debug because data normally has a unidirectional flow. If a bug occurs it's generally clear where it originated. Frameworks like angular and ember are more abstracted which is useful but not when something goes wrong. React is a very different approach to the frontend than the MVC approach presented by most frameworks. It's only the v in MVC. So you can do the rest in whatever fashion fits your project.
I know you said you don't want a blog post, so here's a blog post! http://techblog.netflix.com/2015/01/netflix-likes-react.html It's pretty informative though. I'm still trying to figure out how you can write "Isomorphic JavaScript" that is clean (no html in your javascript). 
Since it appears that your question has been answered, I'll just add that it's JavaScript, not Java Script.
You get several things: 1. Templating equivalent, with full JS logic for manipulation 2. Declarative subviews and data flow 3. Functional input-&gt;output rendering logic 4. Faster DOM updates As said elsewhere, it's a view layer, not an application architecture, but it solves a number of problems.
personally, keeping html and js separate doesn't strike me as a worthwhile goal. from a technical perspective, declarative and imperative styles differ only on time to first and last paint (all things being equal, imperative wins on first paint, declarative on last). from a development perspective, declarative is much easier to approach fresh.
It doesn't really matter in the grand scheme of things. Becoming expert DOM manipulator in raw javascript won't make you a good programmer. Pure DOM manipulation is fairly trivial anyway, and jQuery is just a utility lib that makes the grunt work easier. I see jQuery mainly as syntactic sugar and cross browser normalizing lib. It also does some clever behind the scenes grunt work such as removing data and event listeners from removed elements etc. It's very useful depending on what kind of stack you're working with. I render everything serverside and then manipulate the dom manually, so jQuery provides lots of value for me. If I was working with something like React, there wouldn't be any reason to include it. As I said, dom manipulation is easy. It's like laying bricks at the construction site. Software architecture is the hard part. You should also know that many developers are condescending to people who use jQuery. jQuery users are often seen as "lesser" developers. Ignore that. jQuery is just a tool, nothing more. It's also super popular and yes, most of the people who use it arent great developers. Just like most of the people who eat pizza aren't geniuses. That doesn't mean that everyone who eats pizza is a retard. TL;DR - Get familiar with and try learning the native DOM api, but don't be afraid of using jQuery if it provides value for you, ignore the haters.
Your problem might be that you keep on saying that you do all these things for your job trying to set yourself up as an authority when that reasoning is a logical fallacy anyway. Just explain why you have your opinion.
Saw the name and immediately had a microsleep flashback nightmare about Swing from the horrible Java times. Phew This looks cool though.
React is simple. It's kinda like `render(data) -&gt; UI`. For the most part, you just worry about updating `data` (like keeping it in sync with ajax requests or data streaming in from a websocket) and React handles the rest. We're used to complexity on the front-end. React is a great simplification (though so is this explanation). Perhaps it's something that's hard to appreciate until you've tried solutions like Angular or jQuery spaghetti so that you can see why React is a departure from the status quo.
Only that if you want to recommend libraries to avoid the bulkiness of jQuery, than you should not recommend one that is several times larger than jQuery and is pretty much unusable on the client side, where jQuery is used. Oh, and http://microjs.com/#Ajax
Who are these "jQuery devs"? That's like saying "underscore.js devs" or "scss devs". DOM manipulation is fairly trivial compared to other aspects of front-end such as system architecture or data/state management. jQuery is just a tool that provides syntax sugar and cross browser normalization. I can't see how an average dev would have a hard time switching from jQuery to native DOM api or vice versa. It's the same crap, just different syntax. Using or not using jQuery won't make you a good programmer :3
It's a somewhat fair point. request, while an awesome library, is basically the kitchen sink of HTTP. I've definitely seen cases where people use it when `http.get(` would be nearly as simple. That said, Node has very different performance concerns, so a large library dependency isn't really a big deal.
I like what you are saying. But, doesn't the code get kind of jumbled and hard to read if you are writing html in the JavaScript? Is there some awesome technique I am missing?
Well it's $99 with lifetime support.
This is true for pretty much all the dynamic languages though. They all have super simple microframeworks which contrast hard with, say, the .NET stack.
Are you looking at the tutorials or [the reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)?
jQuery is fine. Becoming expert DOM manipulator in raw javascript won't make you a good programmer. Pure DOM manipulation is fairly trivial anyway, and jQuery is just a utility lib that makes the grunt work easier. I see jQuery mainly as syntactic sugar and cross browser normalizing lib. It also does some clever behind the scenes grunt work such as removing data and event listeners from removed elements etc. It's very useful depending on what kind of stack you're working with. I render everything serverside and then manipulate the dom manually, so jQuery provides lots of value for me. If I was working with something like React, there wouldn't be any reason to include it. As I said, dom manipulation is easy. It's like laying bricks at the construction site. Software architecture is the hard part. Many developers are condescending to people who use jQuery. jQuery users are often seen as "lesser" developers. Ignore that. jQuery is just a tool, nothing more. It's also super popular and yes, most of the people who use it arent great developers. Just like most of the people who eat pizza aren't geniuses. That doesn't mean that everyone who eats pizza is a retard. TL;DR - Get familiar with and try learning the native DOM api, but don't be afraid of using jQuery if it provides value for you, ignore the haters.
Not entirely sure what you're referring to. You can `console.log` all you want in React. And check out the [new Devtools beta](http://facebook.github.io/react/blog/2015/08/03/new-react-devtools-beta.html).
nope, ty.
Right, I used to use angular, but once they dropped IE8 support and started moving to 2.x, I couldn't for business needs. If you need compatibility with IE8, I still don't know of a clear alternative.
If I understand correctly (and I may not), it shouldn't, because React encourages putting everything into slim little components.
&gt; I still haven't seen any complex apps built exclusively on react+flux Yeah, just Netflix, Facebook, and Instagram. No big deal. I mean maybe not exclusively, but few truly large apps use one technology exclusively.
Isn't React already getting replaced with [Relay](http://facebook.github.io/react/blog/2015/08/11/relay-technical-preview.html)? Or am I misunderstanding Relay's goals?
Facebook made react for their own needs, so it's a given that it would suit them. And by the way they have already partially given up on flux. Instagram is a trivial application (on the front-end). Anyway I'm not saying react is bad. But I don't really see what all the fuss is about. React is popular because Facebook marketed the hell out of it. Why is nobody talking about [vue.js](http://vuejs.org/) which is in my opinion slightly superior to React? Because vue.js is made by one fairly unknown developer while Facebook is a huge corporation with craploads of marketing reach. 
I just want to move it anywhere with the arrow keys. literally anywhere at all with javascript. preferably to the right and left.
Not if you want to support Safari and IE. Some places don't care about those browsers, like where I work we only target Chrome and Firefox. Safari and IE get updates once a year (although with Edge it will be quicker apparently). Very few people use Safari outside of mobile and we're not a mobile site.
&gt; How have they "partially given up on flux"? http://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html &gt; To each their own though. I agree. Variety of choice is what makes programming beautiful :-)
All you guys need to try Riot.js.
Relay uses Flux internally. 
Also, your "HTML" (JSX) should remain in your render method as much as possible, so there's very little scatter that occurs. Generally, the structure of the component is very easy to parse and you don't have fragments of templates and HTML scattered about.
[Eh.](https://www.reddit.com/r/javascript/comments/3gv4at/reacts_jsx_dont_freak_out_its_evolutionary/cu1r2zw) 
Yeah, most people were pretty turned off by having markup in JS. React was almost universally laughed at when it came out. [You should watch this video.](https://www.youtube.com/watch?v=x7cQ3mrcKaY)
I love it with a space... seems so... insulting!
Ok? Like I said, everyone had their preference and opinion. I just prefer blaze. 
&gt; without modules all is hanged on the global angular object so you cannot test without angular beiing present during test execution So what?
Of course. :) I'm sorry, I didn't mean to come off as condescending.
You could try Project Euler.
I'm a firm believer in learning vanilla languages first before all the convenience frameworks and libraries out there. jQuery is one such library and it's very powerful, especially in moving/mutating the UI, but it also robs you of the knowledge of what's actually happening. So I'm going to present here how you'd do this with just one js file, no dependencies. This might not work in all older browsers, but there's no point in learning the eccentrics of a 10 year old browser, at that point just use any number of modernizing frameworks. So here we go, you want to move a div to the left or right using arrow keys, as you mentioned in another comment. Here's your logic: 1. make a variable to reference the div 2. add a "listener" function which will get triggered when a key is called 3. this listener will distinguish the left and right keys 4. use the div variable to modify the x value of the div 5. make css that makes the div movable (by default elements are static within the layout, their position depends on elements around them. We need to at least make that position relative. If the position is relative it'll stay in the position it's supposed to be, but you can "shift it's position relative to it's static position". If the position is absolute, it's position is always relative to the x: 0, y: 0 of the first parent of the div that also isn't static. This sounds complex but you'll get it when you play around with it.) here's the code &lt;style type="text/css"&gt; /* Here we set the position of the div element to relative so it can move relative to it's static position */ #hero { position: relative; } &lt;/style&gt; &lt;script type="text/javascript"&gt; // The need of the following function needs explanation. In CSS most position values need to be proceeded by 'px'. Such as '100px', or '25px'. So our div's values are stored that way, and we need to update them that way as well. So when we retrieve the existing values we need to strip the 'px', so that javascript can do the addition, and then add it back. Otherwise if you add '100px' + '100px' javascript takes them as strings and returns '100px100px', not '200px'. function addToPX(existingPX, additionalPX) { var existingPXInt = parseInt(existingPX || 0, 10); // this is a built-in javascript method which extracts numbers from a string, this will remove anything but the digits. The second value is the radix (the numeric system to use). We're using the OR operator "||" because if there is no left value set yet it will be null, and parseInt will return NaN instead of an int, since there's no int in null. So we're saying, if there's no value, use the value 0. var additionalPXInt = parseInt(additionalPX || 0, 10); // although we don't have to write 'px' below, it makes the code more elegant if the types being added are the same. And we're not optimizing right now. // So when we call the function below, it will return the added values and the 'px' at the end. Adding a string to a number causes Javascript to convert the type of the variable from an into to a string. This is a shorthand way to do it but there's no need to be any more complex. console.log((existingPXInt + additionalPXInt) + 'px'); return (existingPXInt + additionalPXInt) + 'px'; } // Here we're getting a reference variable of heroDIV to the element with the ID of hero in the &lt;body&gt; section var heroDIV = document.getElementById('hero'); // Whatever function is assigned to window.onkeyup will get triggered every time a key is pressed, the function receives an event object with details of what key was pressed among other things window.onkeyup = function(e) { var key = e.keyCode ? e.keyCode : e.which; // We're storing the key code for easy use below. // The key code for the left key is 37, and the key code for the right key is 39. We're using an if statement to differentiate them. We use "else if" so that if it's not one or the other then nothing happens. We could also use a switch statement here if there was a big list of possible keys. console.log(key); if (key == 39) { // Here we add one to the existing left value of the div by using the increment operator += and we do the opposive with the other key heroDIV.style.left = addToPX(heroDIV.style.left,'50px'); // We're invoking our function from above, and the result is then assigned to the left style of heroDiv } else if (key == 37) { heroDIV.style.left = addToPX(heroDIV.style.left,'-50px'); // Adding a negative subtracts } } } &lt;/script&gt; &lt;span id="hero"&gt;I am a hero span&lt;/span&gt;
&gt; I still haven't seen any complex apps built exclusively on react+flux https://github.com/facebook/react/wiki/Sites-Using-React Flux is probably not as popular, yet. But React is exploding, and people are finding that Flux implementations are the best way to handle data in their React applications. They just have to settle on single implementation, as there are too many floating around at the moment.
I think it's pretty clear that &gt;It's a clever trick, but not good to use for others reading your code. is *not* the same as &gt;Fuck you if you do this, I'm not kidding
With the lifetime of a version of Bootstrap being roughly 1 year.
Instagram is extremely complex. Any application that deals with athorization will have large amounts of business logic residing on the front end (hiding and showing role based functionality, or only loading applicable modules to improve speeds and prevent information leakage like role specific routes and permissions). Or the complex task of i19n and l10n, when you deal with languages that read right to left, calendars, currency, pluralization, timezones ... Then you have to figure out how to organize all this code, and of course all the e2e and unit testing. There really isn't such a thing as a trivial front end enterprise application these days.
I recently started working with superagent and quickly moved over to [axios](https://github.com/mzabriskie/axios) because superagent doesn't support promises.
Developers who *rely* on jQuery are worse than ones who use raw DOM stuff, IMO. Using it isn't really a problem, but it's important to have a concept of what's going on underneath if you want your code to run well.
I'll make a simple example. Worst: $('div').each(function(){}); Better: $divs = $('div'); for (var i = 0; i &lt; $divs.length; ++i) { $divs[i] or $divs.eq(i) } You will get performance increases if you are doing this over a big list. I see this constantly in jQuery code, and it's nice and succint, but this is a usually a sign of other bad coding behaviors hiding elsewhere. I see it in extensions the most because it's like "Facebook did all the heavy lifting, now I just code some javascript to make it look awesome." *Sigh.* This all comes down to knowing when and where to use your tools. jQuery is a hammer, a *good* hammer, but you can't use a hammer for everything. With this single line: ``$divs[i] or $divs.eq(i)`` you just *doubled* the amount of options you have for writing good code.
I agree. React is usable without flux, but after working with React for a while it feels like there's a strong path-of-least-resistance from stateful components -&gt; moving state up the tree -&gt; custom stores -&gt; *ux.
Can you elaborate on "doesn't support promises" ? I have used it many times with promises.
It was called "JavaScript" for marketing reasons. Java was very popular at the time and it actually still is. https://github.com/blog/2047-language-trends-on-github The JVM is a very nice platform with excellent performance and many language choices. [Kotlin](http://kotlinlang.org/) is a pretty good one, for example. Also note that today's Java is less verbose than it used to be.
React is the VC (despite what the marketing says). The entire Reflux flux addon is 150 SLOC (redux is about 400 SLOC). The couple other addons like react-router are also small and modular. I wouldn't argue that Ember is a very good package (not better than react, but not worse either). Ember's recent goals (as far as high-level design) seem to be converging with React in version 2. Angular doesn't provide anything more useful than React. It provides a painful, proprietary dependency injection that you still have to wrap in require/import while React only needs require/import. Angular provides factories and services for models which are basically dependency-injected constructors/module factories while React just allows you to use the raw JS. Angular provides dirty checking and two-way bindings with all the associated headaches and performance problems while React one-way data flow and DOM diff are easier to reason about and easier to profile and boost performance if needed. Angular has a bunch of domain-specific terminology and (even worse) domain-specific languages in addition to proprietary solutions to things like promises and ajax. React uses basic JS terminology for almost everything except the virtual dom. It uses JS instead of terrible DSLs and allows you to use standardized solutions like ES6 promise polyfill or a fetch polyfill instead of a proprietary technology. Angular provides overly complex directives that are extremely verbose to do even basic things (eg. make the directive, make the controller, declare the scope, make a link function and add a $watch for each and every scope item) and makes debugging and unit testing incredibly hard. React gives you these things without the complexity, manual setup, or difficulty debugging and unit-testing while enforcing better encapsulation. There's no room for debate here. Ember, Angular2, and pretty much every other new framework is moving to React's model. Angular provides things like a router and a REST service, but these are almost always replaced with third-party solutions that are better and more flexible. React respects that you can't shove every project into the same box. Sure you can drink the koolaid with React, Flow, Immutable, Relay, etc if you want a one-stop-shop, but you aren't punished if another solution works better for your project.
The Facebook team pushed it as "The V in MVC" so it seemed less scary, but it's hardly accurate. React is the VC in MVC. It merges the template (the traditional 'view') with the controlling code. While it is possible (to some extent) to use React without taking advantage of these pieces, it's not easy nor idiomatic (for example, wire up a React component so it doesn't have any internal event handlers -- it would be awful to use). 
Its not its own event. It's essentially a polyfill for the browsers DOMContentLoaded event. You're passing a function into their ready method, and they assign it by adding an event listener to the document.
not inlined for readability, also not really trying to make a point about anything. var forEach = Array.prototype.forEach; var nList = document.querySelectorAll('p'); var doFunction = function(currentValue,index,array) { console.log('doFunction!'); }; forEach.call(nList,doFuction);
&gt;I also don't really understand what the function() {} being passed is modifying. that function will wait to run until the document is ready. it's like saying: WHEN PAGE IS DONE LOADING ===&gt;&gt;&gt; DO SOME STUFF by wrapping up your code inside this function you make sure that you don't try to manipulate any data or access parts of the the DOM before they exist. 
 function toArray() { return Array.prototype.slice.call( myNodeList ); } Converting a nodeList to an array is very very easy, if you just need array like functionality. In ES7 you'll also be able to do Array.from() which will be even easier. No excuse there. jQuery chaining IS convenient but generally speaking we're moving away from constantly mutating the dom directly. I personally find myself very very rarely doing so much manipulation that jQuery would be helpful.
There seems to be a problem with one of the `&lt;path&gt;`s (number 6, to be precise). It's probably not valid and Chrome just discards it, but Firefox chokes on it and crashes. To visualize it, try to draw each with a different colour for example. (Actually, it seems that a few of the shapes don't actually draw anything...) (To be more clear, I imported the SVG in an editor and only 5 of the paths [seem to have valid content](http://i.imgur.com/qdBqHma.png).) Apart from that, you're doing some truly wonky things there with your functions/scopes. Totally unnecessary.
Who cares whether you can iterate over 20000 nodes in 0.3s or 0.1s when your browser takes 20 seconds to apply DOM changes in both cases?
awsome
The general MVC model, I assume. Not necessarily Meteor specific. 
The general MVC model, I assume...
I would recommend Leaflet http://leafletjs.com
I recommend to use this fetch polyfill: https://github.com/github/fetch The Fetch API is already natively supported by Firefox and Chrome.
I'm going to try my best to assist you, and at the same time, dig through the jQuery source code. Take a peek at the jQuery [GitHub project](https://github.com/jquery/jquery). jQuery contains all of its source code in the `src/` directory. `jQuery.ready()` is defined in `src/core/ready.js` which you can read [here](https://github.com/jquery/jquery/blob/842958e7aecd0d75a7ee9e2aaec83457701aa2f3/src/core/ready.js). Now I'll attempt to explain what is going on, and how jQuery does what it does, line-by-line. - `1-5:` jQuery is defining the dependencies needed in this particular `.js` file. As you can see, this file depends on the jQuery object which is defined in `../core` and the `document` object, which is defined in `../var/document` - `8:` jQuery is setting aside a variable as a container for a jQuery deferred object. This will be explained later. - `10:` jQuery is adding a method to the jQuery prototype. This is for when any jQuery constructed object will have a ready method that calls this function. - `12:` You can see that the contents of this function call the original jQuery object's `.ready` method, then the promise function, and lastly once that's resolved, it calls the `fn` callback passed to the `.done()` method. - `14:` returns `this` so you can chain jQuery methods :) - `17-53:` I'm going to briefly explain what's going and I'll see if you can infer and figure out the rest. `.extend(obj)` is only provided one argument--*the object you see with all the properties*--and because it's provided one argument, this means the original jQuery object will incorporate these defined properties ([Source](http://api.jquery.com/jquery.extend/)). Plenty of the logic found within these lines are commented fairly, and much of it serves as checks to make sure the DOM is loaded. The most interesting line is line `51` where the original `readyList` var, from line `8` has a method called `.resolveWith()` that's called. *Wait a minute...* `readyList` wasn't defined with anything though? What gives? We'll come back to this in a minute. - `58-62:` Here, we define the callback function that will be added onto the document and window event listeners. Once this function is called, it is removed from the event listeners to make sure it is only called once when the page loads. Then at the very end, it calls the jQuery object's ready method that was *extended* in the previous block. This will kick-off all the DOM ready checks. - `64:` Last preparation step is to define the function we'll be using to kick off everything. - `65-67:` Oh look, it's our old friend `readyList`. Because this `jQuery.ready.promise` function is the first thing to be called and kicks off everything, it will have an opportunity to check if `readyList` is defined before anything else. If `readyList` is **not** defined, it will be defined as `jQuery.Deferred()` object. [Read about them here](https://api.jquery.com/jQuery.Deferred/) - `74-76:` The comments here are very descriptive, so I suggest you give them a read. Essentially, the function is checking if the global document has `readyState` set to `complete`. This is all defined in that `document` dependency set in the first few lines (`1-5`). If for some reason, the document is already ready before this function is executed, it will use a window.setTimeout with only one argument, to execute the `jQuery.ready` method at the bottom of the current queue. This behavior is explained [here](https://html.spec.whatwg.org/multipage/webappapis.html#timers) and [here](http://stackoverflow.com/questions/3580068/is-settimeout-with-no-delay-the-same-as-executing-the-function-instantly). - `78-85:` Else... well, the document isn't ready, so we have to add our `completed` function to the event listeners for both when the document is loaded and when the window is loaded. This way, whichever is done first will call the function and the function will remove itself from the other. Review lines `58-62`. When people say that `.ready()` is a polyfill, this is why they say it. Not all browsers handle these events the same way. - `87:` Lastly, we return the deferred `readyList` with a promise method call. I'll explain what this does in a quick minute. - `91:` Now call the function defined on line `64`. ------------- ***To summarize what's going on,*** We're creating an undefined variable called `readyList` that will later be defined as a Deferred object ([more info here](https://api.jquery.com/jQuery.Deferred/)) once this script starts. We're using this Deferred object to fulfill a promise--*or* call a function that's passed to the any objects constructed with the jQuery object that use the `.ready` method--**i.e.** `$(document).ready()`. `.ready()` will call the promise's `.done()` method once `readyList` is resolved. The kick-off that we called on line `91`--and defined on line `64`--checks to see if our `document` object is ready using a series of polyfills. **If** the document is already ready, we'll simply call our `completed` function at the end of the current javascript queue, or as soon as possible. **Else,** we'll add that `completed` function to our DOMLoaded event listeners. The `completed` function runs the `jQuery.ready()` method that does a few more checks and changes a few more statuses regarding the DOM being loaded. And at the very end of the function it resolves our `readyList` Deferred object using the `document` object as the context, and with the jQuery object as an argument. `.resolvesWith` calls the function that was passed to `.done()` which was originally provided to our `$(document).ready()` method. Honestly, it's super clever because it uses its own Deferred / Promises system to fulfill the callbacks. I suggest checking out this link here for more explanation on one of the methods provided: https://api.jquery.com/deferred.promise/
Array.from is from ES6. Also, you can use an array literal with spread (also ES6) to get the same effect: [...document.querySelectorAll('.foo')].forEach(...) By the way, DOM Level 4 will probably fix this problem. ES6 allows subclassing of arrays. The current plan is to make NodeList inherit those array methods.
Am I a meme nazi to point out it is "One does not simply..."? I don't want to be a dick, but come on.. we're grown ups here.
&gt; There is no such thing as "template separation from code" in modern JS apps. This should be carved in stone for any JS noob to read.
There's also Mapbox https://mapbox.com, which is built on top of Leaflet, and they have their own tool to design your own maps. 
I would rather cut myself than manage another Angular app. Of any version.
1. There is also http://stealjs.com/ though I think it lacks in popularity even on JSPM/SystemJS. 2. I would choose JSPM/SystemJS because even if not as popular as Webpack, it works very well, doesn't require you to write complex configs and it is aimed toward HTTP/2. Webpack in it's current form will just get obsolete with it. They just released [0.16.0](https://github.com/jspm/jspm-cli/releases/tag/0.16.0) and it supports Typescript out of the box.
No. Riot is dying. Just look npm stats and compare it to React. And all riot best pracites tell you to write it like React: Js code instead of tag files. And JS is better than custom template language. I just got into a project written with RiotJs and I should finish the application. I'm going to port that to React. I don't wont to work with Riot.
What is this jQuery spaghetti that everyone is talking about? My (even larger) jQuery projects do not end up spaghetti... maybe others are doing it wrong? Projects I do with jQuery are usually structured like so: - UI with interactable stuff like buttons or what ever - JavaScript block/module to bind and route events to their correct functions - JavaScript data-storage block - JavaScript utility / helper function block - JavaScript main block / program entry point - Backend stuff (Usually a REST API of some sort) So I don't get it... where is the spaghetti at? There are N amount of stuff the user can do / interact with and there are N amount of events bound to that stuff and N amount of functions to handle the stuff. Handler functions as well as the event binders / routers can be split into smaller, logical files / blocks for better readability and maintainability. Storage can be split too if needed, utility stuff as well. Here would be a simple case: - User fills form - User tries to submit form - Submit / button press event is caught by the bound event handler and the event gets routed to a function that knows what to do - Called function does its stuff and perhaps returns a result of some sort Easy peasy, I don't see any spaghetti in that. Most of the stuff is even somewhat isolated this way and therefore should not end up breaking anything else.
Luckily there are many options out there so you don't have to do anything so melodramatic. Hating on Angular is the new hating on Rails, *so hot* right now. 
[Cool, so I'll just leave this here.](https://reddit.zendesk.com/hc/en-us/articles/205192985)
Sure, so it's the VVM in MVVM, I can get on board with that. It doesn't change the point I'm making though, if you took Angular view/templates and controllers its pretty straightforward. I'll be the first to admit that React would be a clear winner comparing just those elements. The problem is the complexity increases drastically when you throw services/routing/state management etc into the mix. This doesn't make React worse at all, but it does mean if you want libs/frameworks like Backbone to do that lifting for you that it's going to require a big addition to the learning curve. 
Ive found the opposite to be honest. Im really annoyed I didnt write the rest of my site with react components and server side rendering. Currently I use it for simple things from having a cascading category selector to having a full scale image editor. Other such uses include a form builder, dynamically updating search page with results shown on a map. Those were all on the same website, not sure if that doesnt count as a run of the mill website but it is a ecommerce website and I would imagine they're pretty common. That being said I wouldnt write a static page site in React as it just wouldnt make sense.
If I'm currently doing PHP spaghetti code and want to move toward something like a front-end JS framework (w/ back-end REST API?), what do I use and at a basic level how?
The helpes don't just cover prefixing, it gives a consistent shorthand for most sucky things that CSS3 doesn't handle.
That is some serious information there. Thanks dude sharing mate. I take it you're a js Dev? :) From what I'm reading, I get the impression react on the whole easier and quicker to work with, as well as being cleaner and more modular? That correct? Why would someone choose angular over react? 
Cool?
&gt; I do not want the type of person that repeat what I just read on blog post Then don't be the type of person who repeat what he just read in Reddit. Go try yourself. Build an app in Angular. Build an app in React.
Oh god, I'm in the love react bandwagon so much. I've worked 10+ years on web development and I find it so much better to anything else I've used. The pros, the cons, whatever... At the end of the day makes my day to day so much easier. 
"using the new keyword, at what point is the object created?" When the constructor function is called. Or what would you like to hear at this point? Plus: Object.create(proto);
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [HammerIO, yet another NoSQL data store?](https://np.reddit.com/r/programming/comments/3hty0w/hammerio_yet_another_nosql_data_store/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
jQuery has no way of data binding so the comparison lacks. sure, if you implement your own data binding system in JS it could work well but the majority of jQuery solutions to stuff like &gt; Update the unread messages counter on all occurrences is often something like $.ajax('...').done( result =&gt; { $('#element1').text(result.unreadCount) $('#element2').text(result.unreadCount) $('#element3').text(result.unreadCount) }); this is just terrible to maintain in larger projects.
Right. But specifically w/r/t the claim: &gt; the new class constructor functions will throw an error if they're invoked without the new keyword, whereas that behavior cannot be replicated with ES5 code I was wondering if there is something more/different that an ES6 `class` is doing, that the example above can't replicate.
&gt; var foo = 42; That's not an object. When you write: 42..toString(16) or 42.0.toString(16) or (42).toString(16) You aren't actually calling a method of that primitive. It gets auto-boxed to make that happen. What's actually run looks more like this: new Number(42).toString(16) JavaScript has objects and primitives. http://www.ecma-international.org/ecma-262/6.0/index.html#sec-primitive-value &gt; **primitive value** &gt; member of one of the types Undefined, Null, Boolean, Number, Symbol, or String [...]
Looks nice, but I don't get how to run a node application from within brackets. Isn't that possible ?
In your example, maybe you could bind a listener to catch all ajax requests and act accordingly with something like this: $(document).ajaxSend(function(event, request, settings) { console.log('Caught AJAX request!'); console.log(event); console.log(request); console.log(settings); }); I think it's just all about routing stuff and creating handlers and dispatchers.
Just pick one. Don't worry, there will be 5 new ones next year anyway. ;)
Making that example and discussing about this really pointed out the implicity of my way. I suppose if you do it react-way it somehow forces you do write code, modules and stuff in a certain way? If you do it my way, everyone else can still write everyone how they want it, quickly making my way spaghetti. Oh and in my example there is not too much error checking... I don't know if react has it any better.
Alright, I can play that game. According to that chart 1.11.2 is 284k of actual code you are punishing your users with. Code you don't need full of methods that get chained together like a prison chain-gang to make your browser crawl like syrup. Now I like jQuery even less.
&gt; Don't forget that that snippet will never fail **never** is a very strong word. I have seen jQuery like this fail IE8.
The main reason angular is the way it is - is that, it is designed for extending HTML ( or DOM ). This is where the whole complexity of defining a directive comes from - and because they have to provide you all the right hooks at the right times - it becomes complicated. React on the other hand doesnt let you deal with the DOM at all - so it can give you a much better interface ( with complexity of DOM diffing underneath! ). Basically, both of them are saying DOM is an untouchable, horrible thing.. Angular is saying, " Dont touch the dom for most stuff.. We will do it for you.. - but sometimes you might want to extend it, here is the API".. React is saying "Fuck the DOM, here is a nice and simple API - work with it and we will deal with the translation to DOM".
AFAIK Runescape scripts are Java, not JavaScript. Maybe ask in /r/Java or in /r/Runescape.
IIFEs are less frequently required with ES6. If that odd "do" syntax ever makes it into the spec, you won't need it ever again. Except for enabling strict mode, that is. Well, modules and classes are always in strict mode. So, you probably won't even need it for that.
Xpost to pcmr. 
The best implementation listed there as 62% for browser support, meaning we really can't do this in the real world just yet. But great solution none the less.
It was posted yesterday.
You seem to be quite impressed with yourself mate, you might want to try stepping out from behind that keyboard once in a while.
&gt; According to that chart 1.11.2 is 284k of actual code That's the unminified version which is full of comments and long descriptive local identifiers. It's 96 KB of code which is parsed and executed in the browser and it's 33 KB which is sent over the wire. Modern JS engines are quite advanced. They will actually skip some work which they don't have to do. So, you don't really pay that much for functions which aren't used, because they aren't properly parsed and compiled until they are used. You see, having some unused garbage lying around is a very common use case. http://blog.chromium.org/2014/02/compiling-in-background-for-smoother.html &gt; make your browser crawl like syrup Reddit crawls like syrup? How about Stack Overflow and Wikipedia?
Thanks for the feedback! Yes, the website needs some love. The idea was to get some feedback on the product before investing more time. However, it seems that the first impression given by this design is scaring visitors away, so we may have underestimated the importance of good design. As for your query syntax comment; HammerDB operates on bytes and does not care about seperators such as ".". How you structure your keys is fully up to the application using HammerDB. In the "tutorial" I just added "." to seperate the logical parts of the key for easier reading. Also, query takes multiple arguments, where only the first one is expected to be key, so the proposed solution will not work as is. But it is possible to accept an array of key-parts instead of a key-string as the first argument, and then just join using ".". Edit: Missed the build pattern proposal. I agree, much clearer and we will be able to easily extend features using this pattern. Thanks!
&gt;What is this jQuery spaghetti that everyone is talking about? My (even larger) jQuery projects do not end up spaghetti... maybe others are doing it wrong? c'mon. I know where you're coming from - I don't write jQuery spaghetti either. But it took years of experience and mistakes and bugs to refine my approach to the one I have today. If you can't see the benefit of a framework condensing experience down into implementable best practices, or you can't understand how writing jQuery with no structure could lead to spaghetti, especially for more novice programmers (think early 2000s PHP application), I don't know what to tell you.
Estimation is hard. Even though you have done this "same" thing 3 times, this time it will be different and I am really only 60% sure on how different it will be until my prototype is built. 
*for their sake*: where it's running. I still get a bit shocked whenever I'm reminded that many people don't really know which work is being done on their local device and what's being done on a remote server. I guess this goes for where data is, too. This kind of ignorance makes for a huge handicap / vulnerability. *for my sake*: software is not hardware. I am interested in software, not computers. If you have an interesting code puzzle, I'm all ears. If you have a boring problem configuring commercial software on your consumer system, hey I guess I might help. But if you have a hardware issue, I really don't wanna know.
This is really great advice. When I started using JS, having return statements in different locations felt really weird, but in reality it's pretty common and a great way to avoid a massive "else" statement. 
Good read, thanks! It was difficult to take away what's really different about angular 2 from the 5 minute quick start, and how things are done. This cleared it up for me. They definitely got rid of some of the stuff I didn't like about angular 1. How modules are defined, the templates seem cleaner in v2, etc. I'm still not a fan of the two way binding. I've gotten a bit too into how I have to tell the component to update itself once i'm done modifying its state (in react). I feel like angular bound properties/objects could benefit from immutability. So you ensure that properties on an object that is bound don't get changed will nilly. Reset the object value instead.
Thank you, sir! :)
What are type definition files and why do you need them? Why would you want System.js and traceur, when babel can transpile ES6 without needing a runtime? Angular 2.0 stinks of bad ideas yesterday :-/
Hi tbranyen, Type definition files are used for describing what options are available for certain methods and annotations. They help with suggestions and auto completion in your editor. System.js is used to support module loading (in this case common.js). And as for babel, you can also use that! I just traceur runtime because they also use it on the angular.io site, but you are free to use babel to precompile your JS. 
Of course you won't be blocked. However async/await in ES7 is huge win in productivity, clean/maintainble code, available now - and being used by big corps like Facebook. Yeh, you can use IcedCoffeeScript but not as good. The only downside of ES6/7 with Babel is that Babel is slow as a dog if transpiling on the fly. So you *are* missing out on async/await which IMHO is a huge win.
Me knowing how to program a computer does not mean that I know why you keep getting disconnected from your dial-up AOL account.
You replied to the wrong comment.
Okay, thanks for that explanation. I guess I use quite a bit of DI myself, I just haven't thought about it as a formalized pattern like, say, a factory. Nice article!
Thanks, glad you liked it! I totally agree with your opinions.
Set style: Position: absolute Left: 100px Top: 20px
Especially true for the "non-technical" project manager. 
Wasn't disagreeing with you or anything, I was just wondering was there some other approach that people use I had been missing out on! &gt; While your example doesn't make much sense anyway (why is images an object? why is sizes an object?), it should probably be coded in a way where sizes is never null, so the only null check you need is if(images.sizes.large). It's from OP's tweet.
It's easier. And with its simplicity applies occam's razor, rendering it more streamlined, pure, and performant. Eg, Angular adds HTML directives for DOM manipulation. `ng-repeat` repeats an element over an iterator. It looks cleaner in code than React's `items.map(i=&gt;&lt;li&gt;{i.name}&lt;/li&gt;)`; however, React's version is vanilla JS - Angular's version you _have to learn_. In fact, I'd say Angular coding is 50/50 DSL / vanilla. This applies outside Directives too. Angular's `$http` lib is pretty NIH compared to common npm libs like superagent (which is isomorphic), or even the upcoming [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for which there are polyfills. Angular's `$q` competes with ES6's Promises. A2 is using Typescript, which adds cool stuff but competes with ES6 in many instances (classes, imports/exports, es7's annotations, etc). IE, Angular reinvents a world of JS, creating a bubble for itself. You as a developer need to _learn_ this world, and keep up. Time not spent learning JS-proper. React's purity reduces the learning curve - I spent a day learning React, and rarely consult the docs since - being productive all the while. Then there's composability. React's enforced hierarchical project organization makes it very hard to write spaghetti. A good Angular/jQuery dev can write beautiful code, a so-so one will write slop. A so-so React dev will at least maintain good file-structure, easing onboarding. Finally: more performant (Virtual DOM, debatable), "native" mobile apps (React Native) vs DOM apps (Ionic). The latter is actually why I made the leap. Now! The model side of React is quite crazy. Flux, Relay.. Flux implementations... And Flux aint a 1-day learning curve, believe you me. I'd say try React, form your own conclusion, keep an eye on it if the "wild west" nature is a turn-off. I use both professionally 50/50, and I prefer React. 
Adding complexity to a feature doesn't only have a development cost now, it also increases the cost of developing other features in the future. If a component A that has lots of different states and you add another related component B that maybe accepts data from A, then you're going to have to be able to deal with all the states that A can be in. As you have more interrelated components and different states the amount of work grows nearly exponentially.
&gt; What are type definition files and why do you need them? \*.d.ts files are actually really neat even if you don't use TypeScript. You can still use them to improve the tooling. http://i.imgur.com/iMVczyp.gif That's with VS Code, but it should also work with Atom, Sublime, and WebStorm. \*.d.ts files can be easily installed via the `tsd` command line tool.
Depends on where you want it, but here's an example: http://codepen.io/anon/pen/YXoOao The JavaScript code I'm using is `div.style.left = "200px";`. I've also changed the CSS to use absolute positioning.
* Building a large software application is like building an office building. There are many different technologies and enforcement bodies in play simultaneously. You can build either software or a building completely ad hoc, but if the project is to ever be completed within a budget there needs to be planning up front. Both require large amounts of scaffolding and in both cases this is technical debt. The biggest difference is that with physical buildings eventually the scaffolding gets taken down. * Nobody will confuse a physical building for the business that occupies it. For some strange reason this thinking is not extended to software, but applies just the same. * Software is typically a practice of social conventions much like warfare, international trade, or marriage. The techniques and conventions that are held most dear and most commonly applied are justified by reasons of popularity in the current culture, educational convention, and social-reinforcement without any consideration for cost justification or isolated critical examination. 
True, but I think it's progress. Preferring JS over Flash was hot on the heals over Java Applets. This hate we develop is by comparison to contemporary advancements. Angular improved my productivity over Backbone, really did. Backbone made me feel better about front-end dev, Angular made me feel like a fucking wizard. React was easier, absent DSL cruft, better organized, and has React Native; worth the shift. Same with Node&gt;Rails. Universal JS allowed me to make more sites &amp; apps, faster - less spread-thin knowledge. IMO that's an objective step in the right direction. Look, Binary -&gt; ASM -&gt; C -&gt; JS; we build &amp; improve, don't see many Binaries laughing at JS for picking "yet another language". The thing that makes JS MVC flip-floppery so amusing is that it happens so damn fast, makes us look ADD. I'd argue it's actually the exponential rate of technological advancement, but that's another argument. In other words: it's trendy, yes - and amusing - but keep up, 'cause it's an upcurve you're seeing.
I don't want it to go somewhere else I only want it to be positioned somewhere and I just couldn't get it to go anywhere, it kept just making it disappear.
I don't dislike Angular because of a new thing. I dislike Angular because of Angular. The rest of your comment is spot on though.
Angular2 now supports one way data binding and immutable objects. http://victorsavkin.com/post/110170125256/change-detection-in-angular-2
I'd say you're ahead of your time. I didn't see the issues in Angular until I saw a strong new contender illuminating them, I think I'm not unusual. Same w/ backend. I didn't realize PHP's beef till I went Rails; Rails' beef till Node. If you can see a step ahead, great!
Technical PM here :D
Is there really that many people who dislike Typescript? I understand people who just haven't tried it yet, but I haven't heard any complaints from anyone who has, versus coffeescript that seems to be very divisive. The nice part about Typescript is you can use as many or as little features as you want. You can either dive right in and use all the typing/ES6 features, or even just write vanilla javascript and it will compile. I think with ES6 looking pretty similar to Typescript, that the hesitation of Typescript will be a lot less than when Typescript released. You can essentially just write ES6 with it.
I'd be careful of going too crazy with multiple returns. Guard clauses at the top of a block can be helpful, but having too many exit points in a method can make your code hard to follow.
Ummm, your variable hoisting example. You show two code examples, and say that the variable gets hoisted, and is the same as if it were declared as the top. function foo() { // a bunch of code here var a = "abc"; } is the same as function foo() { var a; // a bunch of code a = "abc"; } Maybe I'm just confused by the way you've written it, but if this were the case: function x () { console.log(a); var a = "string"; } x(); would print the string. which it doesn't.
https://www.visualstudio.com/en-us/features/node-js-vs.aspx works great. Thanks.
React models the UI as a pure function of your model. I'd like to expand a bit on this. A developer without React can still write a pure function that renders UI. The problem is that a non-VirtualDom solution will be lack in performance, since the pure function will have to re create all Dom nodes each time the function gets invoked. Here is where React and other VirtualDom libraries come in. They allow the developer to write pure functions that hook into React's VirtualDom's framework so that they can take care of performing the minimum amount of changes to the real Dom nodes, thus delivering a performant solution. And with such systemin place, reasoning about code becomes much easier. 
What makes you say that Ember is heading toward doing the same thing as React? I do Ember development almost exclusively, and have used React just a little, but they seem to be extremely different packages. 
Actually, no, I don't. Are you saying that calling a method on a returned object is more expensive in a significant way than calling methods on an existing object, passing in the returned object?
My current preference would be Redux &gt; Flummox &gt; Alt.
In my experience with jQuery.... yes, absolutely. As far as method chaining outside of jQuery it completely depends upon the code, the depth, and the approach.
Also it almost makes more to sense to include the whole thing as it's already cached on people's machines when you include it from a popular cdn.
Or you could just name the counter variable something different
Just my two cents. I think I got idea behind the confusing if statement right... var domain = 'www.example.com'; $('form').submit(function (e) { e.preventDefault(); $.ajax({ type: 'post', url: $(this).attr('action'), data: $(this).serialize(), dataType: 'json', success: function (response) { var $urlCount = $('#count'); var $listResults = $('#list_results'); if ($.isEmptyObject(response.urls)) { $urlCount.html('No results found'); return; } $listResults.empty(); $urlCount.html('There are ' + response.urls.length + ' URL(s):'); $.each(response.urls, function(key, value) { var url = domain + $.trim(value); listResults.append('&lt;li&gt;&lt;a class="link" target="_blank" href="' + url + '"&gt;' + url + '&lt;/a&gt;&lt;/li&gt;'); }); } }) });
Didn't Angular 1.x support one way binding as well by prefixing a binding with double colon? {{::controller.foo}}}
You don't need to be a math whiz to code. The older languages required equations and algebraic functions. There's coding languages kids can pick up and create with. There's even a computer kids put together and code themselves. Tandy has come full circle! Not everyone who codes is a social msifit, and if they are, we're people like you. Lastly, learning to code will help you understand how your devices and everyday software functions. It's kinda like learning why the sky is blue. The cost of entry has never been this low, so I think the future will be one made by makers. We will create the things we want, and code them ourselves. Bigger companies have lost user confidence, and I think this is where things are headed.
The answer to "can't you just _____?" is pretty much always "no, it's a lot more complicated than that".
jQuery had XML files which could be used to generate IDE-specific IntelliSeense (etc) dictionaries. The problem with that, of course, was that it wasn't standardized in the slightest. That XML file was still a huge help. Having something machine-readable is so much more convenient than having to parse HTML docs. What's great about that d.ts stuff is that it got a spec, that it's pretty popular, and that it got fairly decent support. It's also terse and readable unlike those IDE-specific XML formats. I wrote one of those XML files once. It almost made me cry. It was such a massive pain in the ass and it took bloody ages. Ugh. Bad memories. Anyhow, TSD and its definition repo can be found over here: http://definitelytyped.org/
You could set it up as a game jam on [itch.io/jams](http://itch.io/jams)
Huh? I'm closing over it. Assigning that counter to another variable won't change anything. All of those functions would close over the very same environment with that very same variable. They'd all use the same one. Try it. This is what you have to do if you aren't using `let` for the counter: let cb = []; for (var i = 0; i &lt; 3; i++) { (function(i) { cb.push(() =&gt; i); }(i)); } console.log(cb[0]()); // 0
Since all browser vendors have agreed to replace their engines with one perfect browser engine that is completely bug-free, implements all the Web APIs perfectly, and will be installed on every single computer and mobile device in existence (mandated by a new global, inter-governmental law, which will be enforced on the entire human population), then yes, jQuery is indeed dying. 
[Type declaration file (.d.ts)](http://www.typescriptlang.org/Handbook#writing-dts-files) are used for IDE auto-complete suggestions but more importantly for static analysis purposes. They enable the TypeScript compiler to check parameters and return types for third party, external libraries that may not even be written in TypeScript. This can be really important for large projects, particularly when multiple engineers are working in the same codebase. Check out [Definitely Typed](https://github.com/borisyankov/DefinitelyTyped) for a great collection of shared declaration files. You can choose your own transpiler- Babel, Traceur, TypeScript, etc... One thing the Traceur runtime provides (that you may or may not actually care about, depending on your target browsers) is polyfill management.
Absolutely. I dramatized too much for effect, and indeed implied promoting regressive hatred. Not cool. I used stronger words than I should have, and you're correct that this isn't unusual in the industry. Edited my post some. Indeed, there will come a point I tire of devoting 1-2h/d of "future web" learning and will stick to a rung. I would very much hope I'm not shat on from higher-rung JS progressives.
I'm saying use a different counter variable for each loop. And your example is wrong, if you want to use var as let, you should be surrounding the whole loop in an IIFE. EDIT: I thought you were taking about something else. Disregard this.
I remove the need for ctx.save() and ctx.restore() by introducing my own stack state with push and pop commands. I also use setTransform to handle transforms manually using the smallest amount of math I can. The instruction tree is really just an array of commands that get flattened at render-time. My initial tests are very promising! Not to mention WebWorker rendering... which because I'm sending over a tree of render commands, is totally doable inside a worker.
They already said on Twitter that they'll update them to v4 once there's a stable release.
Its not dislike so much as lack of desire to switch. I'd be hard to convince to switch from ES6/2015 and Babel at this point. I understand Typescript offers so many more features and its really silly to compare them feature-wise, but I just find that ES6/2015 addresses quite a few missing holes that would entice me to seek out a different language in the first place. Edit: Sorry for the long run on sentence.
jQuery is still used as a dependency in a lot of the frameworks that are now being utilized to build more ambitious web apps such as Ember (Angular can utilize it if available). It is still definitely a must know tool for modern web developers. Part of what is so appealing about using jQuery is they have spent years creating a compatibility layer for the DOM across multiple browsers. Most developers need to consider that web APIs don't always behave the same in Chrome, Firefox, IE, etc and across versions and jQuery has a lot of those cases handled for you. 
Implement TS on top of Babel and I might pay attention. At this point the only type checker that works on top of Babel is Flow -- and TS simply doesn't provide enough benefits compared to Flow to be worth switching away from Babel. The problem is that TS sees itself as a language built on top of JS whereas e.g. Flow is merely an extension that works alongside other extensions (like JSX or the various ES.next features of Babel).
Yes. Or Polymer, if you can ignore all non-HTML5 browsers.
No, they're not. `this.chunks.p` always accesses the property named `'p'` of `chunks`. It has nothing to do with the `p` variable that happens to have the same name. `this.chunks[p]` means use the variable `p` as the name of the property of `chunks`. Or in other words, `this.chunks.p` is equivalent to `this.chunks['p']`. They both always access the same property every time, and they don't consult the variable `p`. 
With modern browsers, there is a school of thought which says jQuery is unnecessary: http://YouMightNotNeedjQuery.com
*unfounded
Grown ups don't give a shit about memes
Maybe it's just me but TypeScript feels mainstream already. 
Use libraries specific for what you are trying to accomplish, rather than loading a "kitchen-sink" of methods only to use a few. There are much smaller libraries specific to DOM manipulation, AJAX, etc, without being all-inclusive. Also, most everything can be accomplished without a JS library.
You should double whatever estimation I may give you because I have no idea what the fuck I am doing nor anyone else I have worked with during the last 7 years. I do not know what the fuck is wrong, but I will pretend to be working on it. As a project manager, you are not my boss, we are working together in a team, please stop pretending to be my father, I hate you.
Yup, aware of and using it. But I'd rather use jQuery with good design paterns than an old version of Angular.
It wasn't meant to be from a meme. &gt; One does not simply use whole jquery just to do ajax. sounds stupid. If it were read as English, it would mean negative of simply, therefore it's hard. In this case, it's not hard to use jQuery for just ajax, it just isn't efficient since there are better and more lightweight solutions. 
&gt; I know a lot of developers who switched from React to Angular, but I have yet to see anyone switching back because they thought Angular was superior. Is that paragraph perhaps mangled?
I know, that's really stupid. At least that is the syntax in IE8 or earlier, IE9 fixes it to check `request.status` and IE10+ makes it `this.status`, which kind of screws it up for ES6 arrow function which binds this reference. When reading this I was thinking of Fetch API, thanks for mentioning it. Although the [polyfill](https://github.com/github/fetch) currently supports only IE9+, which still sucks for some legacy projects. 
Feel free to dive into my account to see where I've posed this question. For example, the python, ruby, and webdev groups have been active on this question.
Using a tool that keeps things simple is different from having the discipline and experience to keep things simple. My Clojure code is simpler than my PHP code because Clojure is simple by design, but that doesn't mean you can't write simple code in PHP. On a large team project I'd rather work on a Clojure codebase though. Hence why Facebook made and uses React extensively.
From an old teacher of mine: "Only amateurs brag about their tools rather than what they can build with them." I find this even more applicable today than when I heard it. I find that a lot of these devs lambasting others for not using the latest tool don't really have much to show for the self-proclaimed amazing toolbelt. Grunt/Gulp suck, I use Webpack! Angular sucks, I use React! SASS/Stylus suck, I use PostCSS! Bower sucks, I use JSPM! "Cool, what awesome things have you built with these tools?" "Well just a TodoMVC and a small personal project..." "Yup" 
The subtext is that jQuery's mindshare position has evolved beyond a convenience function multi-tool, into a pseudo-platform in its own right. It protects you from the flaws of the underlying platform so well that it fosters ignorance of it, which has bred a whole generation of devs who don't understand the web. Whether or not that's true, I still think that some sort of DOM convenience function multi-tool is a useful addition to a web developer's repertoire.
* Sometimes things that seem simple, can end up being complex - and have far-reaching consequences. 'Just adding another field shouldn't be a problem' - is rarely that simple. * Quality takes time - if you keep adding to the scope, but not increasing the deadline - quality goes down, and you will end up with technical debt that will make future changes even harder. * When we say 'no' or push back on something, there is often a valid reason. 
https://www.reddit.com/r/reactjs
Actually, to get something useful (and use forEach, filter etcetera), you have to write this: Array.prototype.slice.call(document.querySelectorAll(query)) It's becoming a bit masochistic, isn't it?
That's a great idea!
Awesome, thanks!
I don't know why people down vote so harshly on this subreddit.
&gt; So why did Java largely fail at all of this and how is JavaScript and React going to succeed? Because Javascript !== Java. The languages are very different. Javascript is dynamic and functional while Java is static and completely class-based. I would also add that the JS tools are better and offer faster feedback. Finally, Java compiles and sends to the browser to execute while JS compiles and then executes WITH the browser. &gt; what happens when inexperienced web developers use it It's very easy to learn and fairly hard to screw up. Errors are fairly good as are the docs. The framework is minimal, so the only hard requirements are knowledge of HTML/CSS/vanillaJS (no need to learn a bunch of DSLs and framework-specific lingo). &gt; how will you validate the HTML/CSS output (and debug those issues) Because it's JS and executing in the DOM (unlike Java), you can simply grab the actual elements and test (React has APIs to make this easy). &gt; how does it fit in the lifecycle: Design to Prototype/User Testing to Implementation Designer prototypes are almost always unusable no matter what framework. Designers are good at their jobs, but their job isn't to know what HTML works well for your framework and what doesn't. If you do want to use their code, some editors (eg. Atom) have plugins to convert their code (basically replace `class` with W3C specified `className`). The initial reason for JSX was so designers wouldn't have to look at nested JS functions. As an additional (but not react-specific) advantage, is that designer's mockups become much more usable when you get them to think about component boxes in their designs. There are some designers I've worked with who've actually started making their mocks in basic React classes (use `render()` and maybe a couple basic events while skipping the business logic). I don't think that's reflective of everyone, but they enjoy the reusability. &gt; how much does it tie you to a single vendor/technology Flux separates your data from React completely (you can use flux with anything). Redux separates it even further. Lots of frameworks tie you to their views in a very hard way due to all the DSLs (this is true of pretty much every major framework). I'd say the lock-in is about the same and maybe less because everything is very close to vanillaJS. &gt; what happens when you need to do something out of the box When I started messing with react, I built my own solutions for a lot of things. Today the ecosystem is good enough that all the big things you'd usually expect exist (eg. react-bootstrap for bootstrap JS). Because it's commonJS and modular, switching out a plugin at a later date may take time, but you can do it gradually without too much trouble (and finding where it is used is easy because you can search your require statements rather than find all possible dependency injections, view references, etc). &gt; how will I patch it if something is wrong/broken/updated Fork and patch or ask the team (like every other framework). That said, I've very seldom had issues with React and the team seems fairly responsive. &gt; how do I integrate it into existing solutions This is a feature of React that isn't talked about enough IMO. One of my first uses of React was integrating it into a very complex Django SaaS application. We started by taking the jQuery UI pieces and replacing them in a particular Django template with React (create/load the component then doing a `React.render()` into the tag we were loading the jQuery into previously). Once we replaced the jQuery, we started to replace whole templates with React components (and we could generally use our existing React components without changing them). We would namespace the Django template data at the top of the template and integrate it into the Components as needed. A lot of templates simply disappeared at this point. With this done, we started focusing on moving the data into AJAX requests and adding flux stores to a global `window.&lt;ourNamespace&gt;.stores.&lt;store&gt;`. With this, a bunch of other templates disappeared, but the back-end wound up with duplication between the REST APIs and normal CRUD access. The hard step was changing the collection of pages into a SPA. We started by making the homepage into a SPA and redirecting to the other pages as usual. We then started adding the pages to the SPA and disconnecting all the CRUD (a lot harder than it sounds). The process was a long one, but I don't think most other frameworks could have accomplished it without the up-front cost of a complete re-write.
Yeah, I fixed it (thanks for pointing it out).
When you are done with a React application, you will have a datastore (attached via pub/sub to a small amount of top-level components) and your view/controller components all the way down. You could perhaps argue that React is MVVM, but even then React components aren't strictly views. Heavy-controllers are always a source of trouble in MVC designs. It's not at all surprising that large controls inside a react component are generally bad design.
[Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) lets you do basically anything you want in the getter/setter.
Nice solution. Definitely learned something new. Unfortunately, Facebook does not find the images.
That's some interesting reading, thank you.
I was just thinking about this. Very hard to illustrate technical issues to lamens. Least favorite part of the day. The idea of estimation. Ask an engineer to assembled a swissarmy knife and all they have to work with is a 5 gallon bucket of metalic objects. It often feels like im only able to estimate based off Whats on the top layer of the bucket. 
You it really can be that hard.. 
I use react (view and controller), redux (datastore), and react-router (router). The react-router package offers a similar router to the Ember one (and is inspired by Ember router IIRC).
Structs? Enums? Value Objects? Use words to explain things. What do those have to do with arrays? **Edit:** Thanks for the downvotes, but without this comment this thread wouldn't have gone anywhere. OP didn't explain what they needed and for what purpose. "Indexing" means lots of things. It doesn't equal using indexOf (linear search).
My experience with it was less than pleasant. Any runtime type definition changes force you to use / cast everything to the any type. One good example of this is Bluebird's promisify() and promisifyAll(). Add to this that all library maintainers are forced to keep their .d.ts files up to date with every change, and that they are NOT always up to date and don't exist for every library. Finally, at the time, lack of JSX support in TypeScript sealed the deal. Webstorm ES6 and Babel, with type definitions for auto completion, was more than enough in the end. The strictness of TypeScript only got in the way.
yea you just concat the two js files together with notepad or gulp or browserify.
What do you mean, exactly? `arr.slice(-10)` returns the last 10 elements of `arr` and does not modify `arr`. 
Good analogy. The blueprint and instruction manual, as you say, are definitely looser with jQuery, but there are established patterns that give you the same decoupling benefits of Angular 1.x. The toolbox and laborers (are there, just as much as it they are there for backbone). You just have to put some thought into how you want to handle something angular abstracts for you (data binding for instance). In the end jquery does far less for you out of the box than angular. But it also gives you more freedom (for better or worse). They are very different, butI wouldn't say they're use cases always differ that greatly.
Your phrasing is very difficult to understand. Post a snippet of your code and we can find the issue you're having. If you're only trying to position something, you should probably just use CSS.
A [value type](https://en.wikipedia.org/wiki/Value_type) is an object that is referenced by value, not by type. This can be a base type like a number or a struct. It is useful in arrays because indexing array with reference types means that you can not access objects by creating a similar object, you need the original object. If I want to index an array with 2D-points for example, I would use a value type so I can later do IndexOf(new point(x,y)).
So apparently some guy who works at google just made his own framework, it draws a lot of inspiration from angular... but its more like react in that it really just covers the viewController, i have been looking at it a lot lately and i'm pretty damn impressed to be honest its called http://vuejs.org/ . It seems to tackle the same problem as react but with a much cleaner api. It just makes sense. A trend I notice with these frameworks is that the ones built mostly by one person are always so much cleaner than the ones build by big companies 
Yea, I find many classic JS devs are a bit daunted by the whole build system thing. I had to explain our grunt/webpack/npm workflow earlier and it was a lot of stuff to walk them through. The sheer amount of technology and code we pull down from npm just to *build* our front-end is insane. Awesome :D
That will work well with React. I know Angular in its current form is not well suited to the kind of nesting you are talking about. Also, use the React-JSS library (and its companions) to safely bundle your widget css styles into the widget itself, guaranteeing no style conflicts. It's what I have successfully used for months.
TS has JSX now, and they continue working on adding more ES next features. I don't think microsoft will support merging TS into babel though, TS is important to them so they'll want to keep control. Still it is cool these giants finding cooperation.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Description &gt; indexOf() compares searchElement to elements of the Array using strict equality (the same method used by the ===, or triple-equals, operator). That won't even work with the proposed Value Objects. They don't let you override ===. http://www.slideshare.net/BrendanEich/value-objects2 You can do that kind of thing in Dart: https://dartpad.dartlang.org/247edafc32ebb7c809f9 In Dart, you can override == and === doesn't exist. This means you can also do this kind of thing form Map keys.
Not yet, though they are coming. SIMD is getting added to ES2016 which requires the notion of value types so that SIMD vectors can be compared by value (among other niceties). Remains to be seen if custom value types will make it in to the next spec or if SIMD will go in without value types and a later version will rectify the two. I recently gave a [talk about ES2016](http://www.infoq.com/presentations/ecmascript-2016) that discusses the value types proposal (starts at ~28 mins).
* I am not particularly excited about your idea for an app, and do not want to help you build it. I am, however, happy to give you very broad, general advice on what to think about or how to learn more about the complex process of building software products, of which you know nothing. (This isn't aimed at professionals in the software industry, more at friends and family who want to talk to me "because I'm a programmer.") * For PMs, managers, designers, and other people in the industry who aren't technical: you really should have side projects in which you are learning to code. It's the only way to appreciate what we do. Likewise, I have side projects in which I am forced to make product and UX/design decisions, and I generally try to step into the shoes of other people around me as much as possible. * At the end of the day, it's the engineers who know how the product actually works. It's PMs and designers who know how the product should work ideally and/or down the road. We know every detail of when and how the user can or can't see a view or perform an action, and all the ways a user might be coming into a context that you haven't thought of. We are the gatekeepers of functional sanity and the combinatoric explosion of combined use cases that this product engenders. Respect that, please.
&gt; That won't even work with the proposed Value Objects. They don't let you override ===. While true that you can't override ===, for value types === will compare by value. See for example how [SIMD is overriding Strict Equality Comparison](http://tc39.github.io/ecmascript_simd/#strict-equality-comparison) - the intention is for value types to generalize this.
Last sentence of your point 2 is exactly what happens, you start one worker and pass it an arbitrary number of functions. For IE there is a simple fallback to settimeout, which is all that can be done afaik... You are right, makes up for a nice demo, like this one http://codepen.io/dlueth/pen/jcvar ;)
Getters/setters are in the language and you can add them easily with syntax or Object.defineProperty. The behavior of arrays, however, is more complex than what can be described with getters/setters. For example, this thing: let arr = []; arr[1] = 1; arr.length; // 2 This behavior can be accomplished with proxies - basically you override the behavior of setting a property to increment length if needed.
Totally incorrect, Matthew!
You *really* don't need dependency containers in JS, and they will just make your code *harder* to understand. Just pass around instantiated objects and use closures as needed, without containers - this makes it easier to retrace the code flow, and given a sufficiently modular application, you will rarely ever have to change anything. All your objects are instantiated in a 'glue file' - this will typically be app.js, index.js, or something similarly named - and all your other modules are completely stateless. Problem solved.
I don't need to add typescript to my stack, I do just fine with Javascript. Typescript doesn't add anything I really need. 
I disagree that document.querySelectorAll("#my-id div div"); document.querySelector("#my-id").querySelectorAll("div div"); "look" the same. The first requires the "div div" to match on descendants of #my-id while the second can include the #my-id in matching "div div".
It can follow the spec all it wants, it's a stupid ass rule. 
Definitely. I prefer certain languages for their syntax- or frameworks for their convenience- but I think you can find fun and challenging things to build with nearly any technology. I live in San Francisco so I encounter a lot of hip/trendy programmers. Most of them are smart and accomplished- and friendly- but I dislike the feeling I occasionally get for using yesterday's technology. There are opportunity costs involved with always changing to the latest-and-greatest. There's ramp-up time and then a whole class of bugs and missing features that often come along with new tech. I feel that if I *let myself* I could literally spend *almost all of my time* learning about new and competing technologies and no time *actually building cool things*. :)
&gt; There's no need to even think about Typescript when considering developing a site using Angular 2. You probably should at least think about it...
I sure hope so. Without hashtables and value types JS is really missing some important functionality.
If I was you I'd step through your code line by line and consider what it's doing. From there you can work out where to check if the song is position 0. Getting the song position is as simple as getting any other value from the song element which you're already doing for the artist, title etc.
What's going on is that JSON serialization of an array is an array literal, eg. `[1,2,3]`, and there is no place to put a negative index there. I'm not sure what you want exactly but if you used an object instead of an array it would serialize and deserialize properly.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "JavaScript arrays are zero-indexed: the first element of an array is at index 0, and the last element is at the index equal to the value of the array's length property minus 1." Doesn't look like a negative index is valid with JavaScript Arrays
Haha, yes, their willful ignorance is our job security :)
One of the best JS resources out there. Here are some other good books: * [Eloquent JavaScript](http://eloquentjavascript.net/) (free) * [Exploring ES6](http://exploringjs.com/es6/) (free) * [JavaScript Allong](https://leanpub.com/javascriptallongesix/read) (free) * [JavaScript: The Good Parts](http://shop.oreilly.com/product/9780596517748.do) (commercial) As /u/x-skeww noted, *The Good Parts* is becoming a tad outdated. It's still a good read, but take parts of it with a grain of salt, especially re: classes, inheritance, and prototypes.
What the 82,737?
&gt; Which is why I said feels like, and I stand by my statement.because the double function passing in the Promise constructor which provides resolve and reject as arguments feels very backward to me. If you can provide me with counterpoints, I would appreciate them. You'll only need that when manually promisifying an asynchronous function (eg. an EventEmitter). In the other cases: * Nodeback functions (Node.js-style) callbacks are promisifed (in Bluebird) using `promisify` and `promisifyAll`. More on that [here](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification). * Synchronously returned values and synchronously thrown errors are automatically converted into promises. * Promise "chains" are started with `Promise.try` (in Bluebird) or `Promise.resolve().then` (in other libraries). The end result looks something like [this](https://gist.github.com/joepie91/4c125c45ee6c5ea0375f). The `bhttp.get` function could've also been a promisified function from a non-Promises library, and the end result would still look the same. I don't really understand the rest of the points - closures are *the correct way to use JS*, and your 'result' logic shouldn't be inside the functions calling `resolve` or `reject`. Here's your 'encapsulating' example, rewritten to work correctly: [EDIT: Apparently Reddit doesn't do code blocks. Example posted [here](https://gist.github.com/joepie91/0fbf002f7b63286ec117)] I'm not really sure what you're trying to do in your 'external control' example, but it seems incorrectly modularized. If you actually *need* a defer (eg. for a task queue), then you can do so by storing the `resolve`/`reject` arguments, but this is an extremely rare usecase. Frankly, a task queue is the only thing I can think of where it's justified. In conclusion, I feel that you're simply modularizing your code incorrectly, and that *that's* why it seems like Promises/A+ is messier to work with. It really isn't, if you use it correctly (see my examples) - in fact, it's much more readable/maintainable, because you don't have to hunt for the corresponding defer. EDIT: Specifically, when you really do need a defer, and need to emulate it, you should have a function that does *just* that, and doesn't have any other logic in it.
Was gonna make this long, but will keep it brief. My humble opinion holds that you should start your project using ReactJS (view layer/engine), Redux (neo-flux implementation) and Webpack (module loading system). This stack is completely friendly to universal JavaScript (pre-rendering React components on the server on initial page load), but if you don't need any SEO (e.g. App is designed to run behind a login screen), then you don't need to pre-render your app prior. I believe this stack is the most cutting edge (which is also tried and true in production). Relay+GraphQL and Falcor+JSON-GRAPH are new players to an ever changing game. They're cool, but if you're ready to build now, then I'd observe these from the shadows as they mature and evolve. It's very possible that they could change significantly before any RCs are announced. ES6, TypeScript, CoffeeScript, are all supersets of ES5, which is the current JavaScript spec that runs on virtually all modern and popular browsers. If you are a big java guy, then you may enjoy TypeScript, but I'd firmly advise that you use ES6 or ES7 due to the fact that they offer most of the benefits/features of the other supersets. Regardless of which you choose, you'd configure BabelJS to watch your files (ideally through webpack) to transpile them to ES5, such that your code can run on today's browsers without issue. Lastly: Grunt - outdated ish, configuration over code, somewhat monolithic. Gulp - better than grunt as is mostly plain ole javascript (as opposed to verbose config syntax) - but i find grunt to be better for purely front end projects, eg sass, html, css, etc, which I always keep in a separate repo from my app code. Webpack sits in the same family as Browserify and RequireJS, but seems to be the current favorite, due to hot loading, and CommonJS spec. I wouldn't personally use anything else. **Edit**: Longer than I anticipated lol. One more thing - do you need to syndicate real-time data? If not, I'd recommend REST (or some variation of it) as your data fetching strategy. Firebase wouldn't he entirely needed in that case, as leaving a connection to a socket open will utilize overhead **Edit 2**: AngularJS 1.x was the king from say 2011-2014, but today's alternatives have learned from its mistakes. AxJS 2.0 is going to be released one of these days, but it's dramatically different from its predecessor. Also, it seems as if the framework itself is still monolithic in nature, and the angular team has played catch up while superior alternatives have already begun to dominate the playing field. Steer clear of this framework. 
This is a thing with CSS selectors in general. Another example is element .class:nth-of-type(n). It does not find elements with .class and then select the nth one, instead it finds the nth element and then applies styling if the element matches the class. The author misses the bigger fact that browsers match CSS selectors right to left. When you apply the same right-to-left logic you see that the rule in &gt;document.querySelector("#my-id").querySelectorAll("div div"); translates in CSS to roughly #my-id.div div; it finds all the div children of any div and then matches the ones with parent-ancestor #my-id. Compare this with &gt;document.querySelectorAll("#my-id div div"); being evaluated as all divs that are the children of div that are the children of #my-id (which evaluates to length 1 in the example). There is a [stack overflow](http://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left) on CSS being evaluated right to left. edit: for more clarity
Angular 2 is written in TypeScript. You don't have to write TypeScript to use Angular 2. Hell, you don't even have to use ES6 if you don't want. 
Figured it out haha, was some stupid mistake of mine.
No one cares about your app ideas. Everyone has an app idea, some of them are even good ideas, but coming up with a good idea is literally the *easiest* part. Don't tell me what you want made unless you have two things: proven business sense, and money. If you have neither of these things but you still want your app built, you better start learning how to build it. If you only have money, be prepared to pay well.
Honestly, I would recommend having a shared service that returns back the raw HTML for the navbar and maybe provide some additional JavaScript and CSS to add some additional eye candy if needed. The different stacks can cache the raw HTML so that there is not an extra service call for every request. Doing the rendering in the browser will be noticeably slower and likely cause the page to jump (depending on the layout of the page). If you still wanted to go the route of doing the rendering in the browser, I would recommend taking a look at [Marko Widgets](https://github.com/marko-js/marko-widgets). It shares a lot of the same characteristics as React, but it uses the real DOM instead of a virtual DOM and it is much lighter weight (which is important if you are dropping the UI component into lots of pages). One last note is that you should strive for any JavaScript and CSS code to be completely standalone and not dependent on any other libraries (not even jQuery). Also, your client-side should not interfere with any other parts of the page (avoid globals, bad CSS, etc.). Otherwise, you will have problems when one page doesn't want to include jQuery or it wants to use a different version of jQuery. I'm speaking from experience on this one :)
Correction the **new** `Elements` collection, and here's a better [NodeList](https://github.com/eorroe/NodeList.js)
You only need a script tag to include Angular 2 as well... You don't need TypeScript at all in your build if you don't want it. You can write in plain old ES5 if you wish. Now, if you wish to contribute to Angular 2.0, or popular Angular libraries (like UI-Router), then you'll need to use TypeScript. However, I don't need to know shit about V8 to use Node, just like you don't need to know shit about TypeScript to use Angular. Though it will give you a leg up over others in your market.
[NodeList.js](https://github.com/eorroe/NodeList.js) takes care of that plus more
[NodeList.js](https://github.com/eorroe/NodeList.js) takes the pain in the ass out of the Native DOM APIs
Would you mind adding some paragraphs? I appreciate your reply but it's hard to read as a block of text.
&gt; I feel that if I let myself I could literally spend almost all of my time learning about new and competing technologies and no time actually building cool things. Sad but true :( I guess I'm lucky to an extent. I work in San Mateo but am the only front-end person in a group of ~15 Scala devs / data scientists, most of which are old grizzled veterans. None of them give much notice to the latest, shiniest toys because they've seen the changing of the guard enough times not to get caught up in fads.
[NodeList.js](https://github.com/eorroe/NodeList.js) takes care of that
You'll move to [NodeList.js](https://github.com/eorroe/NodeList.js)
Just use [NodeList.js](https://github.com/eorroe/NodeList.js) which will take care of this mess
More than including `#my-id`, it includes all elements on the page. I think about it as two individual selectors, where the second one only checks against elements that are descendants of `#my-id`.
Since it hasn't been mentioned yet, the CSS4 proposed solution for this is .querySelector(':scope div div') Which would anchor the selector at the element.
Thanks this is great
Interesting, counter-intuitive, but it makes sense once you understand what's going on. TL;DR: In `element.querySelectorAll(selector)`, `selector` is absolute, not relative to `element`. Which makes sense when you think about it, but you probably wouldn't have thought about it and would just have assumed that it was relative.
Nope. Storage, bandwidth, compute time, and battery life are commodities. Developer hours and project time-to-delivery are not. With one script tag, ~40KB of bandwidth, and a few milliseconds of compute time on any modern device at the leading edge of every page load, our project can be freed from writing, testing, documenting, and teaching 90% of the boilerplate functionality we need in any major web application. That's a no-brainer to me and everybody else involved. I haven't been persuaded by arguments against jQuery that involve: - People who rely too heavily on jQuery plugins. Why should I care about them? How is that jQuery's fault? - People who don't learn javascript itself "because jQuery." Why should I care about them? How is that jQuery's fault? - How polyfills can serve in the place of 1/Nth of jQuery and support x/N of its supported platforms. Why do I want something that does less? I care about building something useful in less time, commodities like money, storage, bandwidth, and compute time exist to enable that. - How you can stitch together A+B+C micro libraries with a pipeline tool to get 80% of jQuery. Work harder for less? See above. - How most web sites don't use it all. Well, I'm talking about web applications - so yeah, we use all of it. - How jQuery is slower than XYZ. I can identify when that's really important and optimize later. - How it isn't pushing the web forward to pile onto one cart. The web is doing fine. Why is that my problem? None of those things matter enough to me, my project, my team, or my employer and I think that's true for a tremendously overwhelming percentage of people who consciously decide to use jQuery. Many of us really aren't in the business of ideological, philosophical, or platform purity, or simply writing javascript for the sake of writing javascript. Most of the time we're trying to make a tool to solve a problem other non-developer human beings have asked us to make, not just to satisfy our own selfish need for engineering perfection. How is it better for them if we decide to chose something different, not necessarily better, than jQuery? How is it better for them if we spend more of their time making something that is functionally identical?
Well I'm glad for you :) And nice to meet you, faux-neighbor!
These books are the best. After getting a good idea of 'the good parts,' this series will help you learn much more about why certain things should be avoided and how to avoid them. The Async and performance book is fantastic, his breakdown of 'this' is extremely good, and his ES6 book seems solid so far as well.
"You don't know JS", it's a title you'll remember anyway!
Or..you can just [save](http://i.imgur.com/qBNbdn9.png) it?
Thats great to hear! I know the whole thing is a bit jumbled right now, But I can start working on a design document, I have all the artwork ready to go, so that won't be an issue, I just don't know how to code. 
That demo you sent me is pretty neat, Its sort of like what I am aiming for, just the levels would go up automatically.
I know its hard to understand another's mindset, and I find it hard to express my mind set, but Ill try to create a design document easy to understand.
sure, it makes sense from a technical/implementation perspective, but APIs are supposed to be for programmers, so the principal of least surprise would seem to say that the selector should have been anchored at the context of the node `querySelectorAll` was called on (or from). thankfully, ([as pertheusual points out elsewhere](https://www.reddit.com/r/javascript/comments/3hwa3r/queryselectorall_from_an_element_probably_doesnt/cubd8e0)) CSS4 has at least addressed this. I think it would have been better to provide another function to cover the original cases; something like `element.children().intersect(document.querySelectorAll('div div'))`. A better API using maps/filters/closures could be written in the style of a functional lib, I'm sure.
I've been reading through this, and its pretty awesome. 
no
It does exactly what I expect it to.
When you look at the page with IE10 set in the filter, you see how many things it's trivial to do without a library. If you need to support IE8, jQuery is probably the way to go, but if not, it might not be doing all that much for you. 
Thanks, I did not know slice could do that. `arr.slice(-1)` instead of `arr[arr.length -1]` from now on for getting the last member. :)
thanks! i'll check it out
You don't have bookmarks on iPhone?
Do you plan on supporting a simple login mechanism? And what about read-write access on the database? Is there going to be a simple interface where we can prevent certain user groups from editing a key? And to go one step further how you can democratize the database so that a front end guy (me) can basically create a project from scratch with this? Here is my use case: - Create a site for customers to build documentation for their business - Docs are editable for the person who founded them - Docs are editable for users the founder invites - Docs can be hidden from users who do not have read access 
I liked *JavaScript: The Good Parts*, but I think it's a tad outdated by now. Things have changed a bit since May 2008.
That's one-time binding, one way data means you don't have child scopes updating parent scopes (or whatever they are in angular 2).
Fantastic!! Any idea when it might be implemented in browsers (under a year?)
Are you familiar with github?
I think you've seen that one conversation :p Whether he's a dick or not, he knows what he's talking about and his books are awesome
I get the same effect with Chrome and Firefox. The framerate goes visibly down if I let it run for a little while. Interestingly, the performance goes back to normal whenever I resize it. Can't see anything obviously wrong with the code.
Anybody else getting the fancy GitHub 404 page?
Agreed. &gt; "Pure", would have been a good word to describe code which works in every environment. "Pure" as in "without using the APIs which were introduced by a particular runtime". The problem with that, of course, is that many people believe that the DOM stuff is part of JavaScript. Furthermore, "pure function" is a common term in programming, which might confuse people into thinking that a pure function is a function that works in every environment.
Nope.. Try this one? https://github.com/getify/You-Dont-Know-JS
Thanks, that worked.
You're welcome!
It does, with the `:scope` pseudo-selector
It's just good practice to break up text into paragraphs, it makes it easier to read.
It appears broken into paragraphs on my mobile device. Maybe it was a client issue? I'm using alien blue. Can you screenshot how it looks and reply? Apologies for the misunderstanding Edit: http://m.imgur.com/p6EP3Ks
Do not use this is you value performance _at all_. Basically every 17 ms it walks the properties of all your observed objects to see if anything has changed...
I've been on it a few times, as I used to work on 3ds homebrews, other than that, Not at all.
What's funnier is who the blog belongs to... https://en.wikipedia.org/wiki/Sam_Altman
I don't think O.o is being pursued anymore. It will almost for sure not be in ES2016 (ES7) at this point, at least.
That's the thing. I can do html, css and a little php but i have no clue about JavaScripts. Quick you say? For me this looks like greek ;) I tested your code but it returned a blank page. Do i need to do some html to make your script display the data? As i said this is really not my field and going through the code to see what it does is really hard when you have no knowledge of the language, but i want to thank both of you for looking into it for me. Regards /Michael
Thanks so much for looking though!
I prefer React but I don't live in a world where telling users of IE8 or older mobile devices to sod off is a realistic option. Polymer is a component-based framework like React but it's based on actual web components (i.e. the components are nested DOM elements and the internal structure is implemented with the shadow DOM rather than polluting the visible DOM). Theoretically you could implement Polymer components using React or use Polymer components in React but I'm not sure it's worth the additional dependencies.
The reason I'm sceptical about Angular is that Google isn't dogfooding it to the same degree Facebook is dogfooding React (or Flux or GraphQL, etc). Yes, they keep on mentioning that they use it for some web apps nobody actually cares about but I've yet to see a Google flagship product developed with Angular. Facebook and Instagram use React for their main products. This means they have a serious reason to care about bugs and design defects and they have to care about compatibility with older devices. Google likes to live on the bleeding edge. They pretty much swept the rug from under my feet when they announced that AngularJS 1.2 (or whatever the minor release was) would discontinue IE8 support. That's their decision to make, but it's an instant knockout criterion if you need a reliable framework to build your main product with (unless you live in the startup bubble where you can ignore those pesky legacy users). Angular2 pretty much drives the point home. It was developed on top of bleeding edge technologies like HTTP/2 and (natively supported) ES6. Sure, it's somewhat backwards compatible but only barely so -- the focus of the entire ecosystem is on bleeding edge browsers just like it is for Polymer. The difference is that for Polymer this is perfectly okay. It was intended to be an experiment. Angular OTOH is supposed to be a mainstream web framework. I'm afraid that a lot of people will buy into the hype and bet the farm on AngularJS only to find out it doesn't actually satisfy their requirements when they reach production -- exactly like what has happened with NoSQL databases like MongoDB or CouchDB previously. It's not that AngularJS has no merit -- it's just not a good choice as the default go-to solution for new projects and new programmers. Frankly, I don't think any web framework is a good solution for beginners. You should first learn the basics and jQuery is a great next step once you understand the basic concepts like the DOM and reflows. But if you know what you're doing any are shopping for a web framework for your next major project, there are many frameworks I would recommend before recommending AngularJS.
my 2c: use react and get bootstrap or another css framework and get started. if you need to compile multiple JS files into one try gulp and gulp plumber.
Don't spoil it for the rest if us!
This is incorrect. Virtual Dom is quite fast for what it allows you to do, which is to have a mental model where your entire Dom and state of the application is rewritten upon each state change. The advantages of react is the ability to use this mental model (which will help with the given project OP is working on). What can make react apps faster than vanilla is that it can help people design apps that are faster, but the fact remains vanilla JS can be faster. In reality this is usually not the case
You're welcome :)
Nice save. 
Agreed. Everyone has off days or gets frustrated, and their words may seem more reasonable from their perspective.
The term 'isomorphism' has existed as a specific technical term in mathematics for far longer than it has in the JS development community. There is enough overlap in mathematics and programming (and the people with knowledge of both) that it makes sense to bring clarity to this issue. When I first heard the term isomorphic javascript I initially thought someone was referring to a js graph analysis library. Why not nip it in the bud now? Articles like this will help bring the change to the community.
You're referring to the off-topic bit? Yes, it doesn't add anything to the discussion at hand. It's only meant to stop you from using that phrase incorrectly in the future. I just don't want you to say the opposite of what you mean. That's all.
I actually started with the first two chapters of ES6, continued with Scope and Closure, Async, than This and prototypes. The most you'll learn will probably be in those last three, really in depth JS stuff. I read up and going afterwards for fun :)
&gt; all you're doing is making communication more difficult. So are the people who continue to use this term. &gt; Also none of the dictionary definitions of "isomorphic" conflict with its usage in JS. Mh? It pretty much means the opposite. It's not one thing which behaves the same in two environments, it's two entirely different things which happen to have similar structure/function even though they aren't related. The term is used to compare two things, not to describe one thing. As the author mentioned, it would make more sense to use it when you talk about API-compatible libraries. Zepto is isomorphic to jQuery. Zepto has a shape/form (morphic) which equals (iso) jQuery. When you use some C code as-is on some ARM device and a desktop PC, you wouldn't call it "isomorphic", would you? "Portable" is probably the word you'd use for this. "Portable C code" sounds familiar, doesn't it? I think people like the term "isomorphic" because it sounds fancy and sciency. It's fun to say.
Yeah. That should not come to a surprise. One does also not learn driving by sitting next to the driver.
Source: https://devchat.tv/js-jabber/168-jsj-the-future-of-javascript-with-jafar-husain Jafar Husain (tech lead at Netflix, TC39 rep, incredibly intelligent and cogent guy) explains the technical challenges of implementing Object.observe and how it no longer has a "champion" in the committee to push the feature through.
Thanks for the reminder. I haven't been submitting enough of other people's good articles recently but I am now starting to address that. My aim with this article is not to promote my own domain but to give praise to some other developers who have been very active in teaching and helping others. There are 5 Teachers that anyone can vote for anonymously and one person will become recognised as Teacher of the Year.
[Image](http://imgs.xkcd.com/comics/bonding.png) **Title:** Bonding **Title-text:** I'm trying to build character but Eclipse is really confusing. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1188#Explanation) **Stats:** This comic has been referenced 2 times, representing 0.0026% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cuc5quv)
I have a completely different attitude. Many people (including myself) can build things which target IE10+, which is decently standards compliant. Recent versions of Windows auto-update IE, meaning it's close to being as evergreen as any other browser. If you're worried about being locked in to IE11, take a look at CanIUse.com, IE11 supports many, many things most people don't use yet.
Just one idea you may want to look into. If you look at the code there's a lot of repetition. The code from line 29 to 53 is -mostly- essentially the same as the code in the handler you set for the `resize` event. You could easily avoid all that repetition with a little reorganization of the code :) 
You still use CSS for the fixed header, but this calculates the height of the header on resize, and adjusts the padding-top to pad the content down appropriately. With a pure CSS fixed header, you're assuming the height of the header is always going to be the same. This is more for responsive websites where that height may change based on the screen size.
Because it's not in the bud. It's been used in public talks and articles for ages (in Internet time anyway). The term has an established meaning now and we're too late. The number of people complaining about it and using any one alternative is dwarfed by the number of people using the term "isomorphic". And overlap between maths and programming is not sufficient. Distinguishing between the mathematical context use and the JS context use of the term when encountering the term in the wild is no more difficult than any other pair of homonyms.
Dude, thanks for this! [Nice article for anyone who's interested.](https://developers.google.com/web/updates/2013/03/What-s-the-CSS-scope-pseudo-class-for?hl=en)
Sure, yes, I'm sure October 2013 would appreciate your suggestions but you're too damn late. "Isomorphic" means having one code base that can be used both on the client (i.e. in browsers) and on the server (i.e. in node-like environments). It's more specific than "portable". Case in point: the database ArangoDB provides a V8-based JavaScript environment which does not have an event loop. This means there is "portable" JS code that runs in that environment but there is also "less portable" but "isomorphic" code that doesn't run in it. "Portable" is a scale. "Isomorphic" is an absolute.
I'm actually starting to like the term Isomorphic more now that people are arguing against it. 
http://eslint.org/ It's the best out there right now because of its extensibility, awesome defaults, and great support for pluggable parsers (so you can lint your es6/es7)
Mr. Simpson came to one of my JS courses in school and spoke for a bit. Not only are his books excellent and worth a read but he's a great guy, very nice and knowledgeable. Highly recommended!
The trouble I have with this reasoning is that the web development community frequently coins "new" terms for things that already have well-established meanings in related fields. That then leads to fundamental communication problems when they meet people with wider programming experience who knew what those terms already meant. Another good example is "MVC", as applied for a few years to various back-end frameworks that had little if anything to do with MVC. You can make the argument about language evolving and contemporary usage being was really matters. I can make the argument that yesterday I was with a friend's two-year-old who stuck two lollipop sticks in a cross on top of a car and told me it was a helicopter as they played at pretending it was flying round the room. For a two-year-old it was a great adventure, but if I actually need to get somewhere quickly and safely I'd rather an engineer designed the vehicle, and I don't know many engineers who would call two lollipop sticks on a toy car a helicopter.
I don't remember exactly since it's been so long, but I believe he goes on about several different ways to implement classes in JavaScript. As JavaScript now has classes in ES6, that information is mostly academic now. He also recommends `Object.create` as a pattern for constructing programs, which isn't really useful now that we have native classes, which are slightly better. Also, arrow functions in ES6 somewhat nullify the need for `var self = this;` and `bind`.
Thanks! So I have to install npm and then eslint? Is there a web interface like for [JSLint](http://JSLint.com)? I'm doing my editing on an ISP using ssh. I don't know if I can install stuff there. EDIT: Went full dyslexic on npm before. Also I found a Mac OS X installer for npm.
[Date#toLocaleTimeString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString) is available in most modern browsers, as well.
yaa
I think if you really want to start a collaborative project it would be a good idea to use github. You can even host the running version there. 
Sorry, I had focused on the "every 17ms" part.
Given arguments are performance, collision in distributed system and the usability as identifiers. Didn't personally run into the first two issues, but at least the third one is very recognizable.
For quick copy-paste syntax-checking, I'd use JSHint because it has a Web interface, it's more configurable than JSLint, and it provides better hints. If you're going to do syntax-checking in your IDE or text editor, eslint is better.
You should just install nodejs, if you have access to do that. Any reason you are doing your editing this way? Can you edit locally and deploy later? I agree on ESLint, by the way. Definitely the best tool for linting at the moment.
Took me a few minutes to figure out how to use the JSHint web interface. So far, it's giving me fewer warnings that JSLint. Also I notice that JSLint has improved since I used it a while ago.
This might be a good topic for the FAQ (which only has one Q in it at the moment and I can't seem to edit it).
If you're worried about performance and you're not modifying your object a lot, then use immutable. The polling check is trivial with immutable objects.
I think that these articles and thoughts are the way it evolves organically. Opinions are shared, and sooner or later, one term will be used by the majority.
Wish he'd come to my Country, but being on the other side of the world, I don't think that will happen :(
I disagree.
I also vote for API-compatible.
Doesn't that only run on Temple OS?
It's *technically* not part of nodejs, but it comes with every install, and you'd have to try pretty hard to remove it from the nodejs ecosystem (not sure why you would want to, though -- it's glorious). You could install ESLint directly from github, or as a package in any number of editors (sublime text, for example), but if you run it from the command line you will need node installed. You won't have a dependency on node, npm, or eslint with your widgets, though. It will do the analysis without modifying your code at all.
Thanks. This make sense.
Atheist
The closures make so much more sense now.
Just like universal remote. Those are always well-made.
Why do you need to do this? Use timestamps. Timestamps are universal. This is why you use timestamps. Moment is nice when you have to do complex calculations but you solve the original problem just by not doing stupid things like storing times in things that aren't timestamps, or can't be easily made into timestamps. 
Ah, that's a good idea.
This is gold. I'd like to see more stuff like this (showing how v8 actually implements language features) Takes a lot of the "magic" out of the picture 
That would be Trojan JS
Okay, got it. Can we move on now, and stop writing articles and talking about non-issues?
I would have liked crosswire, but that ship has sailed. x~JS
ESLint is awesome, but honestly, you should pick based on what you need. ESLint is the best if you need ES6/React/JSX support etc., I'm using it at the moment with babel-eslint linter backend and eslint-plugin-react, and this combination covers all my needs. It works in all editors, IntelliJ IDEA/WS, vi, sublime, textmate, atom etc. But it comes with a cost...it's much slower atm then JSHint/JSLint. If you don't need ES6/React/JSX, you'll find everything you need from a linter in JSHint/JSLint, and support in editors is as great as ESLint, but performance is better atm, ESLint is still young.
Quite. If it isn't a primitive, it's an object. Can't get much more OO than that.
To emulate generators, you need finite state machines at the very least. Also, polyfilling the `yield` syntax or anything similar enough is impossible in ES5.
I don't think you get the point - what people are trying to accomplish right now in JS is unprecedented. It hasn't been done before - and IMO it's still in a conceptual phase. The idea is not about renaming an existing axiom, it has a much broader scope than isomorphic js and the software necessary to run these programs is still being built. The nodejs ecosystem has doubled in size in less than 2 years, and the emergence of novel source code transpileres being built in node are still young. It's not just about templates and routing - its data models and higher order logic and cache and state and immutability and transpilation metaprogramming ast - environ aware code that just hasn't been attempted in this language in this way before. 
I strongly recommend using [accounting.js](https://github.com/openexchangerates/accounting.js) - [documentation](http://openexchangerates.github.io/accounting.js/), saved me a lot of times with this exact problem and is a really tiny library.
Timestamps are not localized. You would still have to do this (or something similar, see [here](https://www.reddit.com/r/javascript/comments/3i0wby/localizing_times_in_javascript/cucck1u)) to display the local time.
Haha seriously. It's hundreds of kb after browserify + uglifyjs. Just use 'xhr' module and move on. :)
What about a front end offered for users to change of the attributes of certain keys?
But then I can't list as many libraries on my resume! I need at least 3 for any given task! 
It already has. It is the most popular language for projects on Github and its lead is only growing. 
Like most things, it'll boil down to personal preference. I initially liked the "as-needed" rule when I was first exposed to them, but I've found that it leads to ambiguity that's bitten me a couple of times. Multi-arg function signatures can get messy: foo(bar, woz =&gt; { ... }); // single arg func as 2nd arg foo(bar, (woz) =&gt; { ... }); // same again foo((bar, woz) =&gt; { ... }); // two arg func as first arg In situations like those, I've personally found it difficult to tell at a glance if everything is correct. So I usually follow the "always" rule as a sanity check. `explicit over implicit`
function CurrencyFormat(number) { var decimalplaces = 2; var decimalcharacter = "."; var thousandseparater = ","; number = parseFloat(number); var sign = number &lt; 0 ? "-" : ""; var formatted = new String(number.toFixed(decimalplaces)); if (decimalcharacter.length &amp;&amp; decimalcharacter != ".") { formatted = formatted.replace(/\./, decimalcharacter); } var integer = ""; var fraction = ""; var strnumber = new String(formatted); var dotpos = decimalcharacter.length ? strnumber.indexOf(decimalcharacter) : -1; if (dotpos &gt; -1) { if (dotpos) { integer = strnumber.substr(0, dotpos); } fraction = strnumber.substr(dotpos + 1); } else { integer = strnumber; } if (integer) { integer = String(Math.abs(integer)); } while (fraction.length &lt; decimalplaces) { fraction += "0"; } temparray = new Array(); while (integer.length &gt; 3) { temparray.unshift(integer.substr(-3)); integer = integer.substr(0, integer.length - 3); } temparray.unshift(integer); integer = temparray.join(thousandseparater); return '$' + sign + integer + decimalcharacter + fraction; }
Original code (so humans can read it) function calcAmt(frm) { annualrate = 1; settingupemployees = 10 / 6020.91; processingsalaries = 5 / 6020.91; submittingpaye = 5 / 6020.91; class1a = 10 / 6020.91; p45 = 10 / 6025.13; p60 = 10 / 6025.13; employerreturn = 10 / 6025.13; p11d = 10 / 6025.13; frequency = eval(frm.fr.value); employees = eval(frm.empl.value); directors = eval(frm.dire.value); frm.amt.value = Math.round(((settingupemployees + p45 + p60 + employerreturn) * employees + (processingsalaries + submittingpaye) * employees * frequency + (settingupemployees + p45 + p60 + employerreturn + p11d) * directors + (processingsalaries + submittingpaye + class1a) * directors * frequency) * 100) / 100; }
This demo was meant to be similar to http://www.clickerheroes.com/
1,315,329 (Sun Aug 23 09:29:09 EDT 2015)
Definitely look at Typescript, especially given your experience. None of your other languages options (ES6, Babel, Coffeescript) offer static type checking.
Exactly. Besides the people who spend more time blogging and marketing than coding who really gives a shit?
And if you use [Babel's interactive console](https://babeljs.io/repl), you can see how it transforms generators back to ES5. Kinda interesting.
we have a winner!
Did you not read any part of the site? Almost all of the documentation is dedicated to answering that question...
So they are getting rid of the `with` for good? Good news for everyone, I guess :)
Myself and most people I know use no parens unless there are braces: users.map(user =&gt; user.username); users.map((user) =&gt; { // insert complex logic here });
Unless I completely missed it, the article didn't have a link [to the Sinon.JS site](http://sinonjs.org/).
I'm sorry, but this is another example of just how difficult it is to keep up with this shit... &gt; Use sinon.js (**what?**) to easily write stubs for your BDD (**what?**) features in cucumber.js (**what?**) I can *probably* assume the acronym is Business-Driven development, but why make me guess? Does "Business-Driven Development Features" make sense to say? It's a process. Does a process have features?
Right, but Javascript has built in toLocaleTimeString. Once you have a universal timestamp, which you should always have, you just use built in functions. And even if you are somehow not using a Javascript that has that function, if you know the offset, you can just add/subtract that amount, and use the regular formatting. 
Behaviour driven development. This article is written for people who know things about (javascript) testing. People who are already using sinon and/or cucumber. It's not a tutorial for complete noobs, it's a "look at this neat thing" for people who are already into all this. Edit: also sinon and cucumber have been around for quite a while already.
Javascript is still a beautiful language to work with IMHO, with Wasm other languages could come in but which will allow some lower level languages, but you would only really want to use that for something where you really want native performance, let's say photoshop on the web. But with Javascript being the Dominant language of the WEB its not going anywhere. 
#### Features + Babel + Lint with ESLint + Tests with tape in ES6 + Travis CI and Coveralls + Productivity scripts and source watcher + Check package dependencies + Automatic TOC with tocdoc + Badges with shields.io + Example and suggested worflows in README 
Help, I want to get free shit, but I want someone else to do all the work, who will help me?
Technically, it's not about strings. React apps can be isomorphic and React doesn't render strings on the client, it directly binds to the existing DOM tree. So as far as apps are concerned, isomorphic JS is about generating the same DOM on the client and server. But in practice an app needs a lot more than just a part that produces output. It also needs a part that accesses the database. An isomorphic app needs to be able to access the database from the client and from the server, which will likely use very different code. The formal definition of isomorphism is irrelevant. Words can take on seemingly contradictory meanings all the time. Just consider the conflicting meanings of the word "transparency". Words only have meaning in context, they are meaningless in isolation.
&gt; I don't know many engineers who would call two lollipop sticks on a toy car a helicopter Hence why I emphasized *context*. As long as the context is clear, the meaning of words should be unambiguous. If you use the word "isomorphic" in JS, anyone familiar with the recent rise of "ismorphic JS" will assume you're referring to that, not the CS definition of isomorphism (or the biological or sociological definitions for that matter). Yes, in some cases this means words can take on broader meanings that make them practically useless because they are so broad. "MVC" at this point has lost its meaning other than that it generally involves some things called "models", some things that deal with presentation and some logic that binds it all together. But even before it completely lost its meaning it was already ambiguous (I've heard some people claim most MVC frameworks are more similar to Model-2 than to a pure MVC architecture and they have a point). But "isomorphic" has stuck. It's widely accepted enough and the alternatives simply haven't seen wide enough use to have any merit. It doesn't matter whether "isomorphic" is less correct *in any other context*, "isomorphic" in the context of "an attribute describing the properties of JS code" is entirely unambiguous.
"The parse phase" makes it very clear as to how it gets done in the JS engine. Thank you for also pointing to the actual code. :) I was trying really hard to figure out if it was just a pattern. 
I don't think you get the point either. "Right now" started two years ago. The web is *always* in a conceptual phase. I think the "perpetual beta" trend in the Web 2.0 days made that clear enough -- the only difference between then and now is that we've since moved on to using major versions to mean "used in production" because we realized nothing on the web really ever meets the stability requirement we previously associated with "version one point oh".
Thank you for reply. Sorry, it doesn't seem to work. Although I'm not 100% sure if I'm using it in the right place; Should it be down the bottom like this? function calcAmt(frm) { annualrate = 1; settingupemployees = 10 / 6020.91; processingsalaries = 5 / 6020.91; submittingpaye = 5 / 6020.91; class1a = 10 / 6020.91; p45 = 10 / 6025.13; p60 = 10 / 6025.13; employerreturn = 10 / 6025.13; p11d = 10 / 6025.13; frequency = eval(frm.fr.value); employees = eval(frm.empl.value); directors = eval(frm.dire.value); frm.amt.value = Math.round(((settingupemployees + p45 + p60 + employerreturn) * employees + (processingsalaries + submittingpaye) * employees * frequency + (settingupemployees + p45 + p60 + employerreturn + p11d) * directors + (processingsalaries + submittingpaye + class1a) * directors * frequency) * 100) / 100; return '' + val.toFixed(2).toLocaleString(); } 
Alternatively, one could just use Cordova from the command line as opposed to a framework that uses it under the hood, which include PhoneGap and Ionic. I have no idea what React Native uses (it does not appear to be driven by Cordova). Why buy the calf when you get the milk for free (just an expression of course: all of these frameworks are open source).
does toLocaleString not seperate thousands for you? It does for me EN- locale =/
for Nan it takes an extra step, store the number in a variable. and right before you convert to string (ex with `''+` or `.toString` or `.toLocaleString`) you do: if (isNaN(total)) total = 'Error!' else total = '' + total.toLocalestring() then print or put wherever
No, it doesn't. I'm in UK. this first one worked, but if o returns 'Nan' and does not separate thousands. frm.amt.value = '' + Math.round((((settingupemployees + p45 + p60 + employerreturn) *employees + (processingsalaries + submittingpaye) * employees * frequency + (settingupemployees + p45 + p60 + employerreturn + p11d) * directors + (processingsalaries + submittingpaye + class1a) * directors * frequency )*100)/100 ).toFixed(2).toLocaleString();
&gt; Two things are isomorphic if they share the same fundamental structure in some sense. A single thing isn't isomorphic; any isomorphism would exist between that thing and something else. When I think of isomorphic in regard to JavaScript, I think of the runtime (browser vs node/v8) but I take your point. And I agree that OOP is often misused or misunderstood, even aside from OOCSS. We can just agree to disagree in this case. :)
Thank you it worked!!!
&gt; Thank you it worked!!! 
I worked on pro projects with Backbone for 2 years now, and while I think it was a good choice at the time we started these projects, I wouldn't take it for a new project, especially if you are interested in a ES6/babel setup. Not because of Backbone philosophy itself, but the tooling around. For example, working with underscore makes less sense : many functions are now obsolete with new ES6 features and good ES5 support. See https://www.reindex.io/blog/you-might-not-need-underscore/ ; Also, you may have noticed how laborious it is to work with underscore collections in a functional/chaining style. Then, Backbone views usually use some plain old templating libraries that render large pans of HTML, so the DOM is not really tidely coupled with your models : you have to write a lot of code in your views to handle events or update small parts of the UI, compared to the data-binding approach of most of JS frameworks nowadays. Of course, I'm thinking of React which is hyped at the moment. But I don't like the complexity and large size of React. That's why I currently use RiotJS (http://riotjs.com/) for my personal projects. This is basically a React clone, except it is much simpler, under 10KB, with a cleaner syntax and DOM-based. It works extremely well with ES6, and it has been a pleasure to work with so far. According to what you said, I think you will like it too.
IMO as-needed is best. To me `foo(o =&gt; o.x)` reads so much better than `foo((o) =&gt; o.x)`. I'm also going to write a proposal for headless arrows at some point; I really want to write `foo(=&gt; this.x())` when there aren't any parameters.
As long as everyone agrees to use only 3-character-width tabs for their "universal" JS. Until then, I'm going to spend my time making web apps instead of arguing about naming things.
thanks for gold!
It's true that the isomorphism idea is somewhat closer to applying to the runtime environments, but then part of the issue with Node and Browserify and so on is that actually the front-end and back-end environments *aren't* entirely equivalent, so I still feel it's quite misleading. What we're really talking about is having common interfaces that are portable between those two specific platforms, and we already have plenty of terminology for that sort of idea because I've just used some of it. :-) 
Definitely. Will try to do more of these, I only started reading the v8 source because I wanted to know exactly how to target performance optimizations and ended up reading it because it was super interesting to see how our language gets implemented :) also learned a bit more about C++ along the way, so it's a worthwhile use of time IMO
Well, the biggest problem (without reading too far into it) is that this is occurring on page scroll, which means that this event is firing at a very high rate and there is a lot of code executing behind it. It's a good idea to never have unthrottled scroll functions as they can be a bottleneck. Check out one of many libraries that have a throttle function. If you prefer not to include a library (which I prefer and I hope you do too) there are a ton of gists on how to implement something like this (found with a google search for javascript throttle): http://jsfiddle.net/jonathansampson/m7G64/ 
Thanks for taking the time to reply. JSHint doesn't like the characters either. As for my reasoning (which may be faulty), I like the elegance of the Greek characters when dealing with mathematical formulas like those for Geometry and polar coordinates. It makes it easier for me to read later when I've forgotten why I used a name like RHO. So, yes, I really want to do this.
This is stupid. forEach has valid use cases, as do all the other Array functions.
Its really simple. Arrays are objects. Objects have properties. -1 is not a valid array index so its assigned as only a property.
Surprised not to see "for loops are faster". You're not always mapping, filtering, or reducing. Sometimes you're just iterating- which is fine IMO. In these cases though...simple for loops are faster. :)
True dat. I'd argue though that with most "modern browsers" (ugh, there's that "modern browsers" thing again), you'll see very little performance difference in forEach vs. a native for loop. There's lots of perf tests floating around, but I think nowadays the cost/benefit in performance vs. readability is negligible, in favor of the forEach. I think that nowadays, arguing whether to use "forEach" or a native for loop is delving into the realm of micro-optimization (we're talking potentially tenths of milliseconds). I doubt that would ever truly be the cause of any performance bottleneck.
OP: I really want your feedback. In particular, what do you find lacking in existing rich text libs that you'd like to see in SE?
Fair enough. I think we'll agree to disagree on the readability point :) but yes, I can see where there are cases where the milliseconds do matter. Cool repo by the way! Went and starred it.
I made a simple app recently with JS and PhoneGap Build. I didn't even have to install Java or compile anything on my system. Works great if you have access to a Creative Cloud account. Meteor is another great way to make mobile apps if you need something more complicated. 
Yes it's not the cleanest approach but I don't see the point to make fun of it as long as it works
Thanks for the tip. I'm using the web version at JSHint.com. 
You aren't passing the result of the prompt to the calculateSequence function. Js bin http://jsbin.com/hepoducaqe/3/edit?js,console
 function calculateSequence (n){ var counter=0; var sum=0; if(n&gt;0){ while (counter&lt;=n) { sum=sum+counter; counter++ } } else { alert("Sorry try again") } return sum; } var sum= prompt(calculateSequence()); document.getElementById('answer').innerHTML = document.write(sum);
First, to post properly formatted code, indent all lines by four spaces (in addition to any indentation conventions); below I'll type how your code should look: function calculateSequence(n) { var counter=0; var sum=0; if (n&gt;0) { while (counter&lt;=n) { sum=sum+counter counter++ } } else { alert("Sorry try again") } return sum; } var sum = prompt(calculateSequence()); document.getElementById('answer').innerHTML = document.write(sum); With that said, first, you should use `prompt` to get the argument to `calculateSequence`, and make sure to put a good description inside the call to `prompt`, like calculateSequence(prompt('Number of elements to sum:')); Then, when you set an element's `innerHTML` you need to send in a string; when you call `document.write` (which you should avoid because, if the document is already loaded, that clears the document), the return value is `undefined`, so you're setting the element's `innerHTML` to `'undefined'`. This line is better: document.getElementById('answer').innerHTML = sum; Also, if you'd like to have the user keep trying until a valid value is entered, try replacing that call to `alert` with a recursive call to `calculateSequence` that prompts the user a little differently (without that `return` keyword, it would just do the calculation and discard its result and end up using the `sum` variable from the first call, which will still be 0): return calculateSequence(prompt('Please enter a positive number:')); With all that said, here's something that should work: function calculateSequence(n) { var counter = 0; var sum = 0; if (n &gt; 0) { while (counter &lt;= n) { sum += counter; counter++; } } else { return calculateSequence(prompt('Please enter a positive number:')); } return sum; } var sum = calculateSequence(prompt('Number of elements to sum:')); document.getElementById('answer').innerHTML = sum; A minor tweak I recommend to your logic is to allow `n &gt;= 0` and change "positive" to "non-negative" but that's because I like to see the trivial case being dealt with.
This just gave me inspiration to make HowLongToBeatMyMeat. Men everywhere can enter in their time-to-completion, or TTC. Keep averages hourly, daily, weekly, monthly, yearly, and all-time. Incorporate some location services in there and track which areas of the world last longer. Then when the money starts rolling in, I'd spin it off with a women's version, HowLongToSlamMyClam.
I've built a work around. A sed script that substitutes valid variable names for the "oddball" characters. Then I feed that to the linters. s//xPHIx/g s//xRHOx/g s//xSHARPx/g s//xFLATx/g 
Type four spaces before each line, in addition to any other indentation, to make it look like a proper block of code: function CurrencyFormat(number) { var decimalplaces = 2; var decimalcharacter = "."; var thousandseparater = ","; number = parseFloat(number); var sign = number &lt; 0 ? "-" : ""; var formatted = new String(number.toFixed(decimalplaces)); if (decimalcharacter.length &amp;&amp; decimalcharacter != ".") { formatted = formatted.replace(/./, decimalcharacter); } var integer = ""; var fraction = ""; var strnumber = new String(formatted); var dotpos = decimalcharacter.length ? strnumber.indexOf(decimalcharacter) : -1; if (dotpos &gt; -1) { if (dotpos) { integer = strnumber.substr(0, dotpos); } fraction = strnumber.substr(dotpos + 1); } else { integer = strnumber; } if (integer) { integer = String(Math.abs(integer)); } while (fraction.length &lt; decimalplaces) { fraction += "0"; } temparray = new Array(); while (integer.length &gt; 3) { temparray.unshift(integer.substr(-3)); integer = integer.substr(0, integer.length - 3); } temparray.unshift(integer); integer = temparray.join(thousandseparater); return '$' + sign + integer + decimalcharacter + fraction; } There are numerous style issues, but I'll ignore them for now and just point out that you almost never need to use `new String` explicitly and instead you should use the `String` conversion function without the `new` keyword.
In this reply, here's how I'd style it: function currencyFormat(num, places, dec, sep) { 'use strict'; var decimalplaces = parseInt(places, 10) || 0, decimalcharacter = dec == null ? '.' : String(dec), thousandseparator = sep == null ? ',' : String(sep), number = parseFloat(num) || 0, sign = number &lt; 0 ? '-' : '', formatted = String(number.toFixed(decimalplaces)); if (decimalcharacter.length &amp;&amp; decimalcharacter !== '.') { formatted = formatted.replace(/./, decimalcharacter); } var integer = '', fraction = '', strnumber = formatted, dotpos = decimalcharacter.length ? strnumber.indexOf(decimalcharacter) : -1; if (dotpos &gt; -1) { if (dotpos) { integer = strnumber.substr(0, dotpos); } fraction = strnumber.substr(dotpos + 1); } else { integer = strnumber; } if (integer) { integer = String(Math.abs(integer)); } while (fraction.length &lt; decimalplaces) { fraction += '0'; } temparray = []; while (integer.length &gt; 3) { temparray.unshift(integer.substr(-3)); integer = integer.substr(0, integer.length - 3); } temparray.unshift(integer); integer = temparray.join(thousandseparator); return '$' + sign + integer + decimalcharacter + fraction; } Among the issues this fixes are that non-constructor functions should start with a lowercase letter, parameters shouldn't be hard-coded into the body of the function, and potential error conditions should be guarded against (for example, using `0` if the value passed in for the number would otherwise evaluate to `NaN`, but others would rather throw exceptions on invalid inputs, rather than trying to make it work somehow).
I'm actually surprised nobody has suggested Nativescript. I've toyed around with it and like it quite a bit - so far the only downside I've seen is a (discernible) lag on an apps first load, after which there is no issues. I highly, highly recommend checking it out.
Damn, that sounds just like the library I've been looking for! I've been on a front end soul searching path for quite some time. I like Backbone for its simplicity but it can get a bit convoluted. Ember is alright but seems a bit overengineered sometimes, and it's a rather closed system. React sounds good in theory but in practice I can't get over the horrible syntax. Let's not even talk about JSX. Angular gives me PTSD from when I used to write Java apps with the Spring Framework. And Polymer just decided to make their API horrible just in time for the big 1.0. Not to mention all of these framework are super heavy, weighing in at at least 100kb each. 
^ this
Why store timezone in browser storage? Is it really so expensive to determine the timezone? What happens if my timezone has changed next time I visit the page?
Uhh, [rewire](https://github.com/jhnns/rewire) or [babel-plugin-rewire](https://github.com/speedskater/babel-plugin-rewire) if using babel? It's a good idea to use factory pattern for certain kinds of dependencies, but rewire works great. 
I would argue that's dependency injection (or composition, I suppose), not the factory pattern.
WordPress loads jQuery in no-conflict mode which means the `$` shortcut is unavailable, that's the error you're experiencing. The relevant line of console output would be: &gt; Uncaught TypeError: $ is not a function A fuller explanation of the problem with some suggestions for solutions from the Wordpress site: https://codex.wordpress.org/Function_Reference/wp_enqueue_script#jQuery_noConflict_Wrappers
for some reason I hit a lot of weird bugs in ionic(that I don't get in plain angularJS) when it comes to reloading states/reinitializing controllers. kind of annoying
&gt; I am a professional JavaScript Engineer &gt; I just don't understand the advantage to using [frameworks and libraries] Knowing "vanilla" javascript is extremely useful, and I share the same opinion as you that people that claim they "know javascript" and really just know some random library (usually jQuery, previously other things like Prototype) are annoying. But libraries and frameworks are _extremely_ valuable. - They provide a known entry point. You don't have to train new employees on _every single aspect_ of your app. - They are almost certainly more thoroughly tested than any code you write. - They provide consistency within your own code. You're not implementing the same functionality again and again. - They make development faster, sometimes _much_ faster. Yes, you can often do the same thing in less total code, but you can't deny that it's faster to write `$(selector).hide();` than `[].forEach.call(document.querySelectorAll(selector), function(item){ item.style.display = 'none; });` (and you don't have to know that `querySelectorAll` returns a nodeList) - They provide abstractions and ways of doing things that you probably haven't thought of. Sometimes they're _vastly superior/simpler_ to what you'd normally do (e.g. React) - They can provide insanely complicated functionality that would take you days, weeks, or months to properly implement yourself. - etc...
I too don't use frameworks and libraries, but since you also write vanilla js check out [NodeList.js](https://github.com/eorroe/NodeList.js) it'll make your vanilla-js much easier. You have to know vanilla-js to use this. It's using the browser's APIs so nothing new.
Have you try [ESLint](http://eslint.org/)?
Good advice, bad title. You should have gone with something more diplomatic like "3 cases where you should not use forEach". By the way, there is also ES6's for-of which is the better choice if you aren't chaining array methods. The main reason to use forEach for simple iteration was the scoping. However, for-of (if you use `let` instead of `var` as you should) also lets you close over the current item. let cb = []; for(let char of 'abc') { // &lt;- each iteration gets its own copy of "char" console.log(char); cb.push(x =&gt; char); } console.log(cb[0]()); // a
Looking forward to where this heading, assuming they don't goose it :)
Why do you think learning a new language in order to do a job is a sad concept?
Lots of frameworks/libraries are making a huge shift in this respect. Instead of one monolithic library, there are a bunch of small utility functions, classes, etc. You're still basically building a library, but it's much more tailored to your exact needs.
Its not necessarily that learning a new thing is sad, but just that knowing JS isn't enough... you then need to go and learn this other implementation of core features to get things done. I just don't understand it. I would rather hire someone that knew vanilla JS over someone who knew only jQuery and, lets just say, Angular simply because they would have a broader understanding of the language versus only knowing those 2 "toolkits"...
&gt; Frameworks seem like they are just trying to reinvent the entire web development process in general or something. They are, and for good reason -- they abstract away common patterns that people implement again, and again, and again... Go work with React for a day and tell me you don't appreciate its simplicity and speed of development.
That depends on the context. The example posted in the article shows an unit that needs testing. I do agree that we shouldn't use factories or DI everywhere though.
&gt; I know jquery isn't a framework, it just drives me nuts that most developers that I meet don't know JavaScript, but they know jQuery... it's like saying you learned to run before you could even crawl. My own opinion that nobody should title themselves "professional" without understanding the benefits of a library/framework isn't significantly different than the OP's opinion that &gt; it just drives me nuts that most developers that I meet don't know JavaScript, but they know jQuery... it's like saying you learned to run before you could even crawl.
&gt; Why choose react specifically? It has, in my opinion, the highest cost/benefit ratio when it comes to its learning curve. It's very simple to learn and abstracts away a huge amount. Plenty of other frameworks provide a lot more functionality, but there's a lot more to learn as well. &gt; Especially when there are so many other ways to do the same thing... Not really. The concept of "droppable components" that just work, anywhere on your page (and don't require some insane level of encapsulation like YUI did) is a fairly new thing. React does it beautifully, as does Polymer (web components). Implementing it yourself is pretty tricky. It also does paired server &amp; client rendering, another thing that would be insanely hard to implement yourself and provides immense benefits.
I'm with you on writing pure JavaScript over using frameworks most of the time. But, having worked on quite a few large/huge projects over the better part of the last 10 years, I have to say that writing pure JavaScript is simply not viable for some projects. I mean, sure, you COULD do it, but it would take WAAAAYY longer. One interesting development is ampersand.js. Its loosely coupled modules make for an interesting new proposition on using some small components while still writing pure javascript throughout most of your app. Or some of your app. You're in control.
I see your point. However, if you are knowledgeable as you think you are, you have a responsibility to others as a teacher. Being so confident, it would be easy for you to help others and refrain from a battle of egos. It has happened to me before, and it discouraged me from asking more questions.
point taken :)
Currently developing an application with AppFramework + Phonegap setup. Once I got it going and got some structure built - it seems to work pretty well; handles all the annoying stuff like state persist and back button for me.
The thing is, if you make your own implementation of a popular toolchain, you haven't changed the need for a new hire to have knowledge of that toolchain in order to do work, you've just reduced the probability of anyone having any prior knowledge to zero, and added a mandatory learning step. If you use jquery (as an example), then you don't require that only people who have used jquery before can do the job, you just have a chance that you don't need to go through a "learn the ecosystem" phase between hiring and starting meaningful work.
Having only "six simple questions" makes it easier to convince people to give feedback, but you probably would benefit from a more detailed feedback/user-testing. I left you some extended commentary in the comments box. Hope that helps.
Using one or two methods from a large library is bad. Re-inventing your own version of a large library because you want to use "vanilla" js instead of third party code is also bad. Where (IMO) being a "professional javascript developer" falls is to know where in the spectrum of badness your requirements, and therefore your solution, fall. I spent a lot of time around 2008 for example, effectively re-inventing jquery for HSBC because they didn't want to use 3rd party code on their websites "for security reasons". This was a colossal waste of time, because on top of my own development effort, I also had to spend time documenting the code, training the rest of the team and in the end, spent far more time (and therefore client's money) then just doing the sensible thing would have done.
Why not just leave the feedback right here in this thread? Anyways, my dream for the distant future is a tutorial that actually drives your tools as you are reading through it. You see it set up the dev environment, click on things, type things, interact with the filesystem, etc. Then... you can pause the tutorial whenever you want and experiment. Everything is version controlled, so when you're done you can go back to the mainline tutorial and continue where you left off. Except this requires the ability to script the GUIs of all relevant tools, and integration with a version control system, and possibly even direct interaction with the windowing system, and who knows what else. So yeah.. distant future.
&gt; why not just handle the events on your own versus including a huge framework with its various other plugins or scripts to do it for you? Because it's repetitive and slow. It's good that you keep up to date with and understand how to use the latest vanilla techniques but this isn't a reason to not use libraries or frameworks that are there to make your life easier. You're right that many developers will know how to use a library like jquery while their javascript knowledge can be lacking, but the attitude of "I don't need a library because I can do it myself" is no better. Is it beneficial to know how to setup event listeners in plain js, then inside the event query the DOM for input values &amp; checkbox states, possibly parse those values and save to model, then show/hide/add/remove the DOM, possibly having to re-wire any event listeners? Of course. Is it beneficial to do it over and over again? No. Not to mention when the model eventually gets updated elsewhere and you have to manage keeping the state in sync with the DOM. Or the inevitability of the designer altering the page layout so your selectors no longer work and your manual building of DOM no longer matches the new design. It's just not worth it when frameworks will eliminate the repetitiveness of wiring things up and instead let you just focus on the *actual implementation*. Designer changes the layout? The model doesn't know and doesn't care, it still renders. The model updates from somewhere else? The app automatically reacts and I don't have to do anything. Being able to say "I can do that on my own" means nothing if it's going to take 10x the time.
So I'm going to copy my feedback. It might be useful for others, and I would also like to see what others have to say. ---- I don't like that the guide is a popup/dialog/modal-window or whatever you want to call it. Sometimes I had to drag it around to see the code that was hidden underneath. I would prefer the guide as a normal article displayed in another pane. Also, make some keyboard bindings, because I don't want to click that much. For example, the reader could tab from one underline to the next. On the last underline, tab will go to the next page. Then there's the big daddy feature. The one I always wanted to implement for my own tutorial system: the simulation of user actions like typing, creating new files, etc. For example, when you click on an underline, instead of just highlighting something, you can see it be typed in front of your eyes. Then there's the granddaddy feature, which is well beyond the scope of this project.
I'd prefer "ubiquitous JavaScript". [Dictionary.com](http://dictionary.reference.com/browse/ubiquitous) defines: &gt; ubiquitous: existing or being everywhere, especially at the same time; omnipresent: 
You know, that comment is the exact equivalent of an upvote.
If you use Angular, then you cut out everyone who doesn't know angular. If you require React, then you can't hire someone who doesn't know React. In both cases, you have to train them on those. Or you can train them on his company's framework/library. Same difference.
&gt; new developers don't need to learn your implementation/naming conventions, patterns and gotchas, when they start on the project They just have to learn all those same things with whatever framework or library you are using. Same thing.
Except that people who know Angular/React exist, and people who know XCorp's proprietary framework do not. In one case you *might* have to train someone, in the other case you *definitely* have to train them.
&gt; Is it beneficial to do it over and over again? This is another false statement repeated ad nauseum on reddit. No knowledgeable programmer repeats a routine over and over again including those who write in vanilla js.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1883 times, representing 2.4299% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cudrb3o)
"Vanilla JS" isn't a thing - it's an empty file, it's a no-op. As soon as you start writing code to *do things* then you no longer have "Vanilla JS", you have tools. So if you say "we don't want to use a framework, we can write our own tools with 'Vanilla JS'", you no longer have "Vanilla JS", you now have "yet another web framework", except this one probably doesn't have documentation and definitely doesn't have tutorials and stack overflow answers, and IRC channels, and all manner of other resources all over the internet. [I'm not saying this is necessarily bad, depending on the scope of the things you're doing, and the amount of code you write](https://www.reddit.com/r/javascript/comments/3i69xy/core_vs_frameworks/cudqpbk) (in fact my current project uses no 3rd party code on the client, because it's simple enough not to warrant it) just saying that if you find yourself writing a large app in "Vanilla JS" then you should probably at the very least pause to think if there might be an argument for using established and well-known tools.
Beside other things, having common base/architecture/ideology that comes with library helps one programmer to understand other's code.
if you're only using one or two methods from a library, then perhaps it is overkill - but that also suggests you're not writing anything of the scale that would make library usage preferable
&gt; Knowing "vanilla" javascript is extremely useful, and I share the same opinion as you that people that claim they "know javascript" Well, DOM Level 3, the Gamepad API, Web Audio, Canvas, WebGL, and so forth aren't part of JavaScript. They are all just APIs. It is possible (albeit unusual) to know everything there is to know about JavaScript without knowing anything about those APIs. Having said that, I do think that it's useful to know the basics of the DOM API if you write JavaScript which is executed by browsers. It isn't a very complicated API. It's just rather clunky and there are lots of compatibility issues, but it's not that bad if you ignore older browsers completely.
They MAY be tested... or may include bugs that will make you hold your head, because it's pretty much impossible to debug without knowing the innard of the framework.
&gt; It has, in my opinion, the highest cost/benefit ratio I think you meant to say the lowest. Either that or the highest benefit:cost ratio.
You sound, as I read your responses that you have "not written here" syndrome. I too am often guilty of that. However, even as you often write your apps from scratch and do everything with vanilla js, do you not see yourself continually doing the same things? I certainly did, and over the years I refactored those into a library I now use across many of my projects. Turns out, that library is basically just underscore, so I am refactoring it to sit on top. Also, what about cross browser support, or you only need to support latest and greatest?
Protected? Electron's site doesn't say it is, does it? VS' code is over in: C:\Users\\&lt;you&gt;\AppData\Local\Code\app-0.3.3 They minified it, but that's about it. It's not any different from a web app.
Unless you're entering your code with toggle switches, I wouldn't sound so smug about that. Everyone -- including you -- is using things that do the work and the thinking for you. 
Uh, I'm allowed to contradict other people's arguments, because they weren't my arguments. What a weird complaint to make. I didn't say you have to train people on Angular; they can learn it themselves. There are plenty of documentation, examples, tutorials etc, because it's so widely used.
Knowing how to code is smug? Then I must be smug as hell.
XSS attacks are client side by definition...
They can also learn vanilla JS and all that documentation available online everywhere but they should already know that stuff. More people don't know Angular (or any one specific framework).
depends on what you want to do with your array. Here we want to console.log and we don't care about getting an array of results. So it's a clear ForEach for me.
Stay tuned for the second part... It's in post production.
Hmmm. I changed it, but it still doesn't seem to be working. Any ideas?
Excellent point, and one that emphasizes how a deeper knowledge of some of these frameworks and libraries can be as important as a deep knowledge in Javascript without them. I like lodash.js, and you can fine tune it so it contains only the exact functions you need. Also you can do the easy development thing where you just pull in the entire library and a huge js download so you can use a single function called _.forEach in exactly one place (if any not familiar with lodash/underscore the joke is that you could likely do that one naively). Frameworks and libraries give you a bigger gun. But you can still shoot yourself in the foot.
&gt; JS runs pretty much everywhere these days (browsers, servers, arduinos and robots, maybe even cars someday)
Nah, I actually mean cost/benefit ^-1
The HTML-based examples are silly (though interesting), but the very first example is server-side. Why would somebody uglify their server-side code? Isomorphism, or maybe just habit. The author ends with solid advice: &gt; Dont minify/compress server-side code unless you have to, and make sure you run browser tests/scans against code post-minification.
But why would you minify server-side code?
&gt; You can't use jQuery without knowing how to write JavaScript You can use jQuery without knowing how to write JavaScript _well_, and that's _extremely_ common. You can do a _lot_ by using strictly its API and not have to ever type a _single_ javascript keyword other than perhaps `function`. Actually, I would argue that if you've only ever typed `function` and everything else comes from the jQuery API that you don't know know how to write JS. Hell, you have people that claim to be "experts" at jQuery without being able to write a "class", basic closure, non-jquery event binding, use Array.map, etc &gt; for some reason there are a number of JavaScript developers who feel the need to write everything themselves in "pure" or "vanilla" JavaScript. jQuery specifically abstracts away more of the language than almost any other framework or library. 
Hmm... to add a backdoor?
...And in relation to ES6 modules: https://github.com/Wildhoney/Mocktail
jQuery is frozen (I suspect) because they dropped backwards compatibility. It's a wise call and _plenty_ of people are using the 2.x branch. But that's not the point. I didn't _literally_ mean immediate. CDN's don't update immediately, nor do people's codebases. But you'll have a growing number of sites with the exploit and it will stick around for a _long_ time.
&gt; I'm not trying to troll or anything at all... I'm hoping that there's something I'm missing as to why everyone nowadays is all about these frameworks and prefers to learn them instead of learning the core language that they were built in... False assumption. I've never heard or read someone say "Learn jQuery instead of JavaScript". Nobody. Nobody says "Learn Angular instead of JavaScript". It's a nonsense statement., Frankly, I call bullshit. This is all bullshit. I've read your post and your subsequent comments, and the comments of those that support your position, and all I can hear is the whining of "pro javascript developers" who don't want to put in the work keeping current. You seem to want a standardized language that doesn't evolve or change, and you hate the idea that you have to work to keep current with the constant stream of libraries and toolkits that other creative people build in an attempt to simplify and codify the common work that we all end up having to do when we're building real things. Maybe javascript isn't the right language for you? It's changing pretty fast! That does sound scary, except that's why common libraries and toolkits alleviate the fear. You pick one that is popular, well-supported, and coincides with the work you do. React, Ember, Angular, Node, jQuery, whatever. You learn enough to be dangerous, and you adapt them into your projects. Or you don't! You don't want to use libraries or toolkits? Great, don't. Meanwhile the rest of us will be getting the better clients, better projects, and building the more interesting things because we're not wasting a significant portion of our time curating our own home-grown, half-baked crap. I hope your smugness pays well.
I'm using React Native for an iOS app - it's a prototype and doesn't need Android support, so I thought I'd try it out (I'm very impressed by it... so much work Facebook has "given away"). One thing I've noticed is more and more Android-related PRs landing in the repo (eg, [latest change set](https://github.com/facebook/react-native/pull/2400) has 5 android-specific commits) - I guess people are still working on it: there's hope!
This isn't parallelism, this is at best concurrency. Your library is making use of setTimeOut which does give the appearance of threading in certain situations but this isn't executing anything in parallel. In order to do that you would have to be splitting a single task across multiple threads in order to speed up that execution, which is what I did with the webhamsters library (works best in chrome). If you wanted to incorporate real parallelism into your library you would have to make your library use at least 1 thread so 2 can be run at the same time, one on the main thread, another on a worker thread. Even then, that's concurrency not parallelism. 
About the degToRad... I agree that I wouldn't expect a vector library to provide them - but I guess it's not so crazy, as there are other angle-related functions in there too. The [three.js vector library](https://github.com/mrdoob/three.js/blob/master/src/math/Vector2.js) doesn't contain angle stuff, but it does contain lerping. I guess it depends on what you want to focus on.
Out of curiosity, what are the cases where you would want to use a UUID-equivalent as an identifier?
Remember type coercion.
Just make "javascript" a token in the article replaceable by any other language of choice and title the article "How to Hire." 
I give it a 10 out of 10.
You're running into what's basically a race condition. You can't focus on an element that isn't visible (makes sense, right?). So just delay the call to focus and it should work fine: $(elem).show().delay(100).focus();
Yep, I was about to put that I'd discovered the same while I messed with the code! Thank you regardless, because TIL in a serious way.
I love how so many people make their own assumptions on my post and throw their sorry attempts at trying to talk down to me for it. Its pretty funny that my whole post is "bullshit" to you... all I'm doing is asking a question and looking for other people's opinions. And I'm sorry to say that after interviewing and looking for new developers, there are a lot of people who don't understand the core of JavaScript; at least to understand closures, data binding or even the key concepts of event listeners and callbacks... they only know how to use these tools given to them by frameworks. I never said I "hate the idea" of using or learning frameworks. I DID say that I have learned, used and worked with various frameworks before and appreciate them for what they can do... I don't see how that translates into me not wanting to use or learn them. I'm simply asking what the advantage is and people keep trying to stab at my job... my job isn't even in question here, and I really don't care if you want to try to belittle me for asking a simple question which you obviously can't understand. As far as JavaScript evolving and changing, I am very well aware of this as I work with the language on a daily basis using various frameworks and libraries. I have no issues with them at all. The fact that I asked a simple question and you somehow twist that and try to make me sound like a bad guy, or someone who thinks he's better than others is ridiculous.
The point is that there *isn't a difference* that requires my code to react differently to that object. Object literals and instanced objects are effectively the same thing, and there is no value in denoting one or the other; they're both objects.
This is the best comment I've had for this entire post. Thank you. This statement also provides more of an idea about why people would understand frameworks more than the core of JavaScript itself as well. If it was on of the first things you.learned and it can do as much as it does, why.not stick to it? I started JS from the beginning so I didn't have tools like these to ease into it... I guess that's why it seems odd to me, but I'm starting to see why.
While that code might work it is very bad practice to do so. You should never set a timeout to wait for a race condition. Instead you should use a callback for the function you are waiting to complete. This would be a better way of doing the above: $(elem).show(400, function() { $(this).focus(); }); 400 is the default show timing and after that you can supply a function that gets called once show() is complete.
Maybe if you're trying to fit it onto a small IoT device. Or perhaps a universal js module that distributes a .min as its main, the vulnerability doesn't have to be in your code.
Come on, at least make it _slightly_ interesting: var l = '10'; console.log(+l+l); console.log(+l++l); console.log(+l+++l);
 var element = document.evaluate('my/x/path' ,document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null ).singleNodeValue;
And then people call RMS paranoid... https://www.gnu.org/philosophy/javascript-trap.html
If the site allows framing you could get away using an iframe. http://stackoverflow.com/questions/12129164/read-form-data-from-iframe
if the website doesn't have an existing api or is cors enabled, you're going to need a page on your domain to scrape the page you want because your browser won't let you for security reasons. then you'd do an ajax call to the page on your domain. for example, if you're running php, you'd need to create a scrape.php file with: echo(file_get_html('http://music.163.com/page-you-want.html')); i haven't done php in years, but i think that's right. so, now you'd need to do an ajax call to scrape.html: $.ajax({ url: "scrape.php", type: "get", success: function(data) { // take data, turn it into an html object, then scrape that } }); i have to take off, so i can't write the commented out part, but that should do it.
Node.js "hot inlining" uses a "good enough" metric of a function body 600 characters including comments and white space.
I agree that the conversion functions don't really belong here but it's something you're probably always going to need when working with vectors. Maybe they should be exposed under another module name, but I'm not sure if that's any better. However, there are scaling methods, see multiply and divide. I was thinking about making an alias for that (scale, or something like that). Other than that I completely agree and I'm very grateful for the input. Is there anything else that you see missing? I haven't much worked with vectors myself, I just wanted to have some fun writing simple two-dimensional games and got started with this. Thanks! Edit: I now remember why I renamed equals to isEqual - it was for the sake of consistency, since I didn't have another good name to check if the vector was the zero vector other than isZero (zero is already a method - to make the vector the zero vector).
document.querySelectorAll
https://medium.com/javascript-scene/why-hiring-is-so-hard-in-tech-c462c3230017 some tips from Eric Elliot.
&gt; it saves creating temporary variables Does it really? The thing on the right-hand side is an array literal. In the best case scenario, the engine creates a regular temporary variable for this. Currently, it's kinda slow: http://kpdecker.github.io/six-speed/ Written: var a = 3, b = 5; [a, b] = [b, a]; Babel output: var a = 3, b = 5; var _ref = [b, a]; a = _ref[0]; b = _ref[1]; From a performance standpoint, doing the swap with a regular temporary variable is probably the better option.
Fixed now. https://github.com/joshmarinacci/semantic-editor-js/issues/2
While your comment is appreciated, I feel as though it's overly-pedantic (I too have seen Rob Pike's presentations on the subject). This module makes use of the term in the same spirit as node control flow libraries: https://github.com/caolan/async#parallel https://github.com/tj/co#yieldables (arrays of coroutines are ran in parallel) The module makes no reference to "parallel programming", just the word parallel - which can be easily understood as a contrast to running operations in series. &gt; In order to do that you would have to be splitting a single task across multiple threads in order to speed up that execution, which is what I did with the webhamsters library (works best in chrome). Which still isn't parallel execution unless your kernel distributes it as such, on a multi-core machine or VM. A t2.micro running chrome might not see see any performance benefit, as the operations really just run concurrently. These types of discussions are rather mundane, as you can trivially nitpick implementation details, since node devs work at such a high level of abstraction. While your webworkers might seem to be running in parallel, is v8 distributing its Isolates across multiple threads? And are the Isolates that run your web workers evenly distributed across cores? If not, it's still not parallelism, just concurrency. tl;dr: You're right, but I don't think it warrants pointing out 
&gt; Which still isn't parallel execution unless your kernel distributes it as such, on a multi-core machine or VM. A t2.micro running chrome might not see see any performance benefit, as the operations really just run concurrently. These types of discussions are rather mundane, as you can trivially nitpick implementation details, since node devs work at such a high level of abstraction. While your webworkers might seem to be running in parallel, is v8 distributing its Isolates across multiple threads? And are the Isolates that run your web workers evenly distributed across cores? If not, it's still not parallelism, just concurrency. Well it is parallelism since you are splitting a single task across multiple cores, and on chrome you do in fact see quite a performance benefit http://hamsters.io/performance (run at least twice to let JIT optimize after first run) and I certainly do think it's worth pointing out as it seems there is a large section of the javascript development community who has a hard time grasping the difference between concurrency and parallelism. Your library is using setTimeOut which in fact does not even run things truly concurrently. setTimeOut is quite literally queuing work for the JVM to execute when it feels it has adequate resources to do so, that logic is all run on the main thread and is still running in serial it just provides the illusion of concurrency since you are not allowing the JVM to block itself. It's the exact same technique i use to simulate threading on devices that do not support worker threads, it gives the illusion of threading and concurrency but in reality you are just doing things 1 by 1 in a non mostly blocking fashion. As far as a t2.micro goes you can still see benefits on chrome when using a background thread over using the main thread with the library, obviously you shouldn't expect multithread scaling out of a single thread machine but the main thread does more work than execute javascript while worker threads do nothing but execute javascript so they are slightly slimmer and therefore have the potential to be more performant than the main thread even when using a single worker thread. EDIT: Here is a good article that will better explain why setTimeOut is neither concurrent or parallel. http://javascript.info/tutorial/settimeout-setinterval
yeah I never like to use libraries, normally I just look at how they do it then write something similar that suits my particular problem.I only use two libraries Bootstraps, since i am already using their CSS. And an Wav to mp3 conversion library that is essentially just a module so it fits in pretty well. 
The real one? Proxyquire solves the entire problem. Dependency injection and the factory pattern are useful in statically linked languages, because there is literally no other way to mock those dependencies. In a dynamic language, where you can use something like proxyquire to easily intercept and mock dependencies, why trouble yourself by over architecting and complicating your code? Seems like you have a solution looking for a problem. Not all languages are created equal.
Thanks for this article, I think it has some good insights. But I can see from the responses here that there is some confusion about what those insights are, and I think part of the problem is the article is somewhat narrowly focused on testability, rather than -- as you say -- application design. It would be great if you could add a few sentences to the article connecting testability to application design. For instance, your example is not about some arbitrary case of using a library: it's about using a library that provides a port to some external resource. In many real-world cases these are going to have complex APIs, configuration, authorization steps, etc. You don't want components deep in your application to have to deal with all this. They should just get the interface they need to get done whatever they need to do. So the principle is, somewhere near the top of your application is where you deal with the mess and provide the 'adapters' to your external resource libraries to the rest of your application. Testability is just a means of getting there. (BTW, these are not my ideas, as you may recognize they are worked out in great detail by Freeman &amp; Pryce in _Growing Object-Oriented Software, Guided by Tests_). 
it doesn't seem to work for the full code I posted the whole code here https://jsfiddle.net/fx6qpqhy/2/ 
`document.querySelectorAll(selector)` will do exactly what you need. Throw your CSS path in there and you'll get your elements
&gt; and I certainly do think it's worth pointing out as it seems there is a large section of the javascript development community who has a hard time grasping the difference between concurrency and parallelism. And yet I made no reference to execution across threads/cores, and we still need concise language to be able to describe this type of flow control at a higher level. See async/co/step as examples (all reference parallel tasks). We can't simply give that up due to our use of nonpreemptive multitasking in node. With the notion of parallel in async/co/step/mocha.parallel, multiple code paths are ran in parallel. It's simply that. Not series, parallel. Anyone familiar with node is aware of its underlying model of execution, and how it only offers the illusion of true parallelism. &gt; your library is using setTimeOut which in fact does not even run things truly concurrently. setTimeOut is quite literally queuing work for the JVM to execute when it feels it has adequate resources to do so, that logic is all run on the main thread and is still running in serial it just provides the illusion of concurrency since you are not allowing the JVM to block itself. JVM =&gt; v8? Also, it seems I somehow gave you the impression that I wasn't aware of how cooperative multitasking works? &gt; EDIT: Here is a good article that will better explain why setTimeOut is neither concurrent or parallel. http://javascript.info/tutorial/settimeout-setinterval Your argument essentially boils down to: "You can't use the words parallel or concurrent when discussing flow control in Node, unless you're using fibers/workers" With that, everything runs in series. Which is technically correct. But not helpful in any way.
Just because you can it doesn't mean that you should. It looks like lots of people are using proxyquire. I still think that this is a hack and prefer solving the problem with app design. I'm not saying that we should use factories all over our code. I myself still have tons of requires/imports but the technique described in the article helped me improving my code.
&gt; See async/co/step as examples (all reference parallel tasks). We can't simply give that up due to our use of nonpreemptive multitasking in node. With the notion of parallel in async/co/step/mocha.parallel, multiple code paths are ran in parallel. It's simply that. Not series, parallel. I don't see how it is parallel though, concurrency is running multiple things at once that isn't parallel what so ever. It's running things concurrently and while the two terms are interchangeable in certain ways they are drastically different in their implementation. With the use of setTimeOut you are "time-slicing" and I think it would be best for us to stop mudding the waters with libraries that actually do not allow or enable parallel execution from ones that actually do. "Concurrency: A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism. Parallelism: A condition that arises when at least two threads are executing simultaneously." - http://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html &gt; Your argument essentially boils down to: "You can't use the words parallel or concurrent when discussing flow control in Node, unless you're using fibers/workers" With that, everything runs in series. Which is technically correct. But not helpful in any way. I don't see anything wrong with telling people not to wrongly use the phrase parallel when describing tasks that are in absolutely no way parallel. Your library doesn't actually do any of those things, it's simply running things in a manner that is asynchronous, and that isn't parallelism. Previous failures of people to be able to discern the difference doesn't make the use here any less wrong. 
Brilliant explanation, thanks!
What do you mean your data is in a json file? You use a .json as your database?
Answer for those on mobile : http://jsconsole.com/?var%20j%20%3D%205%3B%0Avar%20k%20%3D%20j%20%2B%20j%3B%0Avar%20l%20%3D%20k%20%2B%20%27a%27%3B%0Al%20%3D%20l.replace(%22a%22%2C%20%22%22)%3B%0Avar%20m%20%3D%20l%20%2B%20l%3B%0Avar%20n%20%3D%20l%20*%202%3B%0Aconsole.log(m)%3B%0Aconsole.log(n)%3B
You call it a hack, I call it a feature. That is the beauty of dynamic languages. Unit tests aren't a part of your application code, a small, reliable 'hack' to avoid having to mess up your application code is fine with me. It won't impact anything in production. Much preferred to eventually ending up with code like: var object = require('module').create(dep1, dep2, dep3, dep4); And trying to remember what dependency every module needs, in what order, etc. Most DI libraries make it easier to do so, through some kind of metadata (attributes) or in the case of Angular, based on variable name. At the very least use a library to do it for you [electrolyte](https://github.com/jaredhanson/electrolyte)
I ask how you would indicate the difference in behavior between these two snippets, in 3 words or less? What is your alternative? Both are simply asynchronous (and neither concurrent nor parallel by your definition), and yet the results are vastly different. parallel('suite', function() { it('test1', function(done) { setTimeout(done, 500); }); it('test2', function(done) { setTimeout(done, 500); }); }); // Completes in ~500ms describe('suite', function() { it('test1', function(done) { setTimeout(done, 500); }); it('test2', function(done) { setTimeout(done, 500); }); }); // Completes in ~1000ms 
works for me kind of, you have to have values in the employees frequency and directors fields tho... updated fiddle: https://jsfiddle.net/fx6qpqhy/3/ * added a check for those fields * logged a bunch of stuff to console to debug (can remove these) * added isNaN and display "error" if isNaN * moved the script to &lt;head&gt; (jsfiddle option @ top left) cuz the funcs were undefined * note: added checkChoice() because jsfiddle was complaining, remove it if you use this code gl 
Pretty sure SauceLabs is a *place* for you to run your tests and manage test results - it either simulates or virtualizes common devices (laptop, phones, etc.) and environments (OSX, Windows, etc.) so that you know your app works in different conditions. &gt; Hence why it's littered with bugs. You already know you need unit tests, pros &amp; cons aren't that important anymore IMHO, although sometimes you might not want to write tests for prototypes because they are meant to be short-lived proof-of-concept demos. That's your biggest reason to start testing: to make sure your code works as intended and that your old code will not be broken by new or refactored code. Anyway, how you actually start testing is 1. Get familiar with a test framework such as jasmine and mocha which are super popular and supported by SauceLabs 2. Set clear expectations on your app behaviours 3. Write test suites and specs with the test framework of your choice (jasmine or mocha doesn't matter that much) 4. Use a test runner to run the test suites and specs you just wrote. I know jasmine comes with an HTML SpecRunner, not sure about mocha. Or you can use a specialized test runner such as Karma or perhaps SauceLabs has something for that 5. **NOTE** Don't try to refactor your entire codebase when you start testing your app midway. Instead do it incrementally. Start writing tests for existing features while making sure new features are all implemented *after* you write tests.
Haha, yup. We are constantly trying to get project shareholders to define what is a must have vs nice to have.
I'm a fan of functionThatReturnsPromise() .then(otherFunction) .then(anotherFunction); It just keeps it clear what is happening on each line. I believe that Google recommends something similar.
Keep in mind that the `$.ajax( ... )` part is jQuery, not vanilla JS - Google XMLHttpRequest if you don't want to load jQuery only for its AJAX proxy method.
Basically, I'm parsing some element on a page. So, var elementText = $('#element').text(); //'$19.60' var elementPrice = Number(elementText.replace(/[^0-9|\.]/g,'')); //19.6 // I do some things to check the difference in price and if deltaPrice&gt;0, we do more magic //I wasted 40 mins on this bug because delta price &gt; 0 while the result is $0.00
Totally agree I've been playing with riot for the past week and thinking of applying it to my next project with ES6.
Depends on how you define well-established. eBay has been using the tool for almost 2 years now (it was the `optimizer` package before it became the `lasso` package) and we have lots of Node.js apps running in production. It has solved all of our JavaScript and CSS bundling needs and it is by far the best tool for enabling optimizations such as URL fingerprinting, bundling, async loading, JS/CSS/image minification, code splitting, etc. If it didn't solve a real problem than we would not have built it. It's pretty heavily documented and actively maintained. With that said, I am not here to convince you to use it, but only mentioned it because you asked. It is at least worth checking out I think.
Not reliable. FP accuracy is is often much lower than that, e.g. `123.1 - 123.16` (.1*10 + .2*10) / 10 If you know your approximate range and precision, it _always_ works. e.g. for currency (in most countries), use `100`.
You may be better served in writing a browser extension that can simply get the url in question, and parse it for the additional details it needs... Beyond this, such an extension could inline a thumbnail of the image in question into general search results for google. Unfortunately, even greasemonkey scripts are probably too limited in this regard.
Except in that article Stallman didn't cry against minification because of the potential to insert backdoors which are triggered by minification. His argument was that minified JS which isn't Free Software is bad because it's Nonfree Therefore Scary. jQuery is Free, it's MIT-licensed. Minification (which appropriate headers, I guess) doesn't make it Nonfree. It isn't any different from someone planting a backdoor into a precompiled copy of GNU/Linux (or more accurately, someone planting a backdoor seed which is triggered by the compiler). 
I'm just guessing here, but that "ZZLi3sHXoTyKzmnPZI0uTkMhJ7o=" string looks about the right size for a base64 encoded UUID, which is DeviantArt's key for objects. I'd suggest authenticating to their API and requesting metadata for that value. https://www.deviantart.com/developers/http/v1/20150824/deviation_single/bcc296bdf3b5e40636825a942a514816
&gt; this is an issue with many systems when you are using floating point numbers I would say every system that has floating points will have this issue. IEEE754 is pervasive, even in hardware.
Post was extremely opinionated (bashed angular hard), so I'd be willing to bet that had something to do with it. Also, i just reread it, and it is somewhat all over the place. Was mostly trying to cram as many basics as possible into the shortest amount of text. Hope it helped! **Edit**: seriously though, people on reddit simply aren't ready to accept that angular 1.x is dead, and 2.x is a waste of braincells. 
**Pros:** - you cover known cases for correctness without having to manually repeat them - you know your code supports the known cases - helps you understand your code (+introspection) - helps you identify your common mistakes - broadens your perspective (dev vs. tester) **Cons:** - takes time to write tests - doesn't cover **every** possible case - can't test everything (unless you wrote your code that way) Depending on what frameworks you're using/not using, I'd recommend any one of these frameworks: - [QUnit](https://qunitjs.com/) - [Karma + Jasmine](http://karma-runner.github.io/0.13/index.html) - Karma is the test-runner and Jasmine is the framework, normally used together - [http://docs.busterjs.org/en/latest/](http://docs.busterjs.org/en/latest/) Or you can always write your own unit testing framework. Just be sure to write unit tests for it ;P Like programmingerror said, SauceLabs is a place for tests, instead of a framework. Additionally, JavaScript supports **assert** statements that can be just as good as entire testing frameworks.
Yeah, but when you're in my situation and just want to get started on a project without having to get bogged down in holy-wars between this framework or that, you need opinionated advice. Out of interest, and this is probably out of left-field, but any thoughts on [Vaadin](https://vaadin.com/home)? I mean, people criticize Java for having a lot of boilerplate, but it's nothing compared to a lot of these JavaScript frameworks, even those you like.
You are free to - but if I see someone's resume states that he/she is an "expert" in more than 5 languages, I have serious doubt on his/her definition of expertise.
&gt; collect data from a third-party API and store it in a JSON database FYI this is against most ToS agreements and potentially illegal. If you have access to an API, why are you trying to store the data?
It's a script to scrap other sites. Hence the parsing stuff
Give me some motivation here people, upvotes not downvotes, months of nolife hard work here on amok and amokify ;-D
It's different per data-source. Go read the ToS of whatever API you're planning on storing data from.
in the line preceding this, how do I reference the web url so that I can point 'document' to it? assuming the url is "www.example.com/page" sorry if it's a rudimentary question, thanks for your help!
thank you - I'll try the direct scrape approach first as this sounds pretty complicated ...
[Can't reproduce](http://i.imgur.com/6WfRss4.png), resolving.
If you're dealing with currency i'd recommend keeping everything in cents and only convert when displaying.
Hi /u/mpjme, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just [your YouTube content](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q). Thanks for your consideration! site|count|% :-|-:|-: your youtube.com|13|100%
Automated testing falls basically into two categories: * end-to-end (aka functional or black-box) testing, which runs scenarios of your app on end-user systems, e.g. different kinds of web browsers * unit testing, which tests the integrity of your code by testing small "units" of it, how fine-grained those "units" are is the developer's decision Saucelabs allows you to run **functional tests** on their cloud (so you don't need to test all sorts of OS/browser configurations including mobile on your systems). If you want to run your functional tests on your own system you usually use "test runners" like [Karma](http://karma-runner.github.io) that will spawn different browsers for you to run through the scenarios. **Unit tests** are usually tested with tools like Jasmine or [QUnit](https://qunitjs.com/). Unlike functional tests they are fast and run very often during development (on the dev machine) to catch implementation bugs early. You'll probably want to learn both types of testing, but for detecting implementation bugs in your code unit tests are the main tool. Edit: Fix link
It's a nice idea, but it sort of falls apart as soon as one of your injectables depends on another injectable. I suppose you could still initialize your container piece by piece and get away with it.
Phenomenal! Very clear explanations, it's not too long and more importantly, it's not boring! Thanks!
1. Right now it really doesn't matter which testing framework you use. It's similar to the debate between Django and Rails, or Python and Ruby - they all do the job and they all do it well. However, they have similar but different philosophies and opinions. In the case of jasmine and mocha, the 2 relatively popular ones (someone mentioned QUnit, it's also popular, but I personally haven't touched it so I'll leave it out of my answer), mocha gives users the freedom to compose their own toolchain (usually with sinonjs for mocks and chaijs for assertions), whereas jasmine packs all the essentials and provide you with an all-in-one. Which one is better? There's no real answer because people have different *opinions* and preferences; 2. Nope javascript test frameworks are all written in javascript AFAIK; 3. TDD and BDD are *techniques* or *processes*, meaning neither of them dictates which test frameworks you use to write your tests or how you structure your tests. TDD means before you write any code, you set expectations and write your tests. Why? Because you want to force yourself to write predictable and testable code. E.g. you want to implement a feature in your app that prints "Hello World". Before you actually implement it, you write in your test "expect(printHelloWorld()).toBe('Hello World')". Now inevitably your test will fail because you didn't implement anything, yet... duh, but now you know what to do to make your test pass: write a function that returns "Hello World". What if the next feature you need to implement is to have the function say "Hello Guy"? You write in your test "expect(printHelloWorld()).toBe('Hello Guy')". Now your test fail, and you modify your function to say "return Hello Guy" to make it pass. However, your "Hello World" test fails, even though the "Hello Guy" test succeeds. Now you know what to do to make both tests pass: add a parameter to the function and blah blah. It's a stupid example, but hopefully it clearly illustrate what in essence TDD is. Cool, now our tests give us confirmation (all green) that our program does what it's supposed to do, but that's not useful enough for us when we are building more complex systems. That is, even though we know our program prints "Hello" + whatever we pass in, but we are not sure when or in what context "Hello Whatever" is printed. Of course, you can add additional test suites that confirms "Hello Whatever" is only printed when you click a button as a logged in user, but it quickly gets a bit awkward and sometimes repetitive when you have to write the context and scenarios and all that separately. In other words, it's pretty hard to get right. That's why some people prefer BDD. It's like a revised version of TDD, but basically you define in business terms your goals, the context and the behaviours, etc. from a higher level. For example, before you start development, you write down something like this "Given I am logged in, when I press the 'Greet' button, then I should see the text 'Hello User'". Now that's something a non-dev (normally the stakeholders or a non-technical product manager) can write to help define high level behaviours as long as they follow a certain format - the 'Given', the 'when', and the 'then'. Now we as programmers can parse that and write some tests before we implement the features. 4.. If you check out some jasmine sample code you will see "describe", "it", "expect", "toEqual", etc., and you don't see where those functions are defined. Javascript itself doesn't come with those methods, so someone wrote the framework JasmineJS to provide those. So yes, jasmine is the framework you need to write the tests. And SpecRunner is actually just [an HTML file](https://github.com/jasmine/jasmine/blob/master/grunt/templates/SpecRunner.html.jst) that 1. includes the jasmine framework; 2. include your application code; 3. include your tests; 4. some other stuff required to initialize the test environment and display your test results in readable formats. Edit: Prematurely hit "save" &lt;cont'd&gt; However, if you want to automate your unit tests, relying on the HTML SpecRunner is gonna cause you troubles, which is why you may need to something like Karma or SauceLabs to either run your tests in a headless browser (browser without a GUI) or in virtual environments that supports normal native browsers.
The problem with the answers given in SO is that you cannot call the _callback_ on each node, because you don't know if you're done yet or not. Instead, the important point is that one: knowing if you're done yet or not. Now, how can you know that? Well, the key is that the only way a certain node knows if it's finished is if it knows its children are finished. So, instead of passing the callback around, each node should pass a reference to its children and receive confirmation from each of them. A node will know how many children it has, so it's just a matter of counting the responses until it has them all. When a node has all the responses from its children, it can then notify its parent. And so on. In this particular case, doing a _comparison_ you can do a little shortcut optimization for the failure case. That is, once a node gets a negative (nodes are not equal) response, it does not need to wait for the rest of its children. But don't think about this until you have the code for the general case.
This is an example how to get the content of any element of any website (using the id of the element) http://music.163.com/#/song?id=34057221#lyric-content Just make an ajax request for that URL and you will get exactly what you need $.ajax({ contentType: "application/json; charset=utf-8", url: "https://music.163.com/#/song?id=34057221#lyric-content", success: function(data) { document.querySelector("#lyric").innerHTML = data; } });
Remember that there's a big difference between "the next big thing" and "what employers are looking for". Companies move a lot slower since you often have a big product to maintain. If you look for work at a brand new startup or maybe an agency that makes a lot of sites, then sure: go for the next big thing. If you want to join an already established company that has only a few products, you should probably be more conservative. Honestly, it can't hurt to learn both if you have the time for it anyway.
I interviewed with two companies last week and they both mentioned I should get on learning React. But other than that it's mostly Angular, jQuery, and plain JavaScript from my experience. [This video should give you a bit more perspective] (http://m.youtube.com/watch?v=pB0WvcxTbCA)
I work for a competitor of SauceLabs, https://testingbot.com which offers the same features. We provide VMs where you can run browser/javascript tests on. I'd say the most popular frameworks to do javascript testing would be jasmine/karma. Next to javascript testing, you can also do Selenium/WebDriver testing to make sure your webpages work correctly as well, and not just your javascript code.
Ok, let's talk about something else. Let's forget about testing and say that we have a dependency which is an external service, REST api, db access whatever. We use that in several places and we reach its public interface via requires. Yes, for testing we may mock it with proxyquire and it will work. What if we want replacing that dependency with a better version or simply another module. You have to go though all your files and change the require statements and probably the access points. So, using plain requires everywhere is not a problem-free technique. You need patterns like factory or some sort of DI helper to avoid issues like this one. Why I'm giving such example. Proxyquire is solving the "entire" problem by using tooling. It's better solving the problems with design rather then tools. The tests are there and important not only to prove that what we do is working but to makes us think about better design. If we have difficult to test pieces they are probably bad designed.
I spent some time looking for JavaScript jobs in the UK and Germany recently, always searching for the "javascript" phrase. Angular is definitely the winner here when it comes to number of times being mentioned in job postings, on the other hand I did filter for the better paying ones, so it may (and probably does) differ on the lower paying jobs. I used mostly generic job sites for looking (reed, indeed, monster, etc), but it's not much different on the programming job sites (stackoverflow careers, etc). My impression was that "Angular" just became a buzzword/placeholder/generic keyword, after couple of interviews nobody seemed to really use Angular for anything in production.
Right now if you want to have a JS job you should know: - JS (ES5/6) - Typescript or CoffeeScript - Angular/Knockout/React - Git/Mecurial - Grunt/Gulp/Other Build Script - Mocha/Jasmine/Karma - NodeJS - Browser automation (ZombieJs/PhantomJs/Selenium) Going forward there will be more adoption of ES7 related features like decorators, and more adoption of ES6 features like generators. There will also probably be a lot of noise around Aurelia which is basically going head to head with Angular 2.0, so those are 2 big players to watch out for in this space. It is important as a developer (regardless of language/platform) to know how to build your project (grunt/gulp/other) and how to test it (jasmine/mocha/karma/etc) as well as how to use version control systems effectively. So its not JUST about knowing frameworks its also about knowing how to manage your project in a sane way with all the JS frameworks around. == Update == I cannot believe I am getting downvoted for providing what the *better* companies will be looking for in someone who is a Javascript DEVELOPER, not some web agency JFDI guy who throws some jquery at a page and assumes it works, but someone who will program business logic, write tests and build processes and work on large projects which have client side applications and back end services (nodeJS has taken off quite a bit now so its good to know that). Just because you do not know one of the things I have listed does not mean it is not important, as a police officer would tell you, ignorance is no excuse. If you want to work for large companies using javascript the above list is a starting point given your question was around *"I want to learn the next big thing"*. If you disagree fine, but if you dont understand how to build JS projects in a sensible way, and you dont know how to test the code you are hammering out then you will be employed by people who are equally as lax with their JS development or at best a junior role within a larger organisation which uses JS primarily.
You completely missed it....;) it is in between the two code examples.
[Am I missing something](http://jsfiddle.net/c52sb8ds/)?
Really sounds like OP works more alone than on a team. &gt;* They provide a known entry point. You don't have to train new employees on every single aspect of your app. Not only is this a HUGE one, but having a known entry point provides the ability to adhere to a style guide across your platform. Reading code is very much like reading any other written language. If we all write the same, the brain doesn't have to process the difference in your coding style, and you can get to the actual development faster.
I really just wanted to explain a few practices I noticed were a bit off, so it's really the concepts that are valuable, not the code.
&gt; My impression was that "Angular" just became a buzzword/placeholder/generic keyword, after couple of interviews nobody seemed to really use Angular for anything in production. You are so fucking right. A couple years ago everyone was trying to find a use for Angular anywhere they could. Oh MVC framework on top of an MVC framework (ASP .NET)? Yea great idea... What a fucking time suck that was. React definitely has a place.
That has been my point through this whole thread.
I had a headhunter call me, a few weeks ago, who asked if I knew Angular. I let out an audible groan and she said, "That's the typical reaction I get. Most people think it's 'unreasonable' and I agree."
Can you post the HTML as it is in index.html? The javscript looks like it's doing some custom initialization for each &lt;li&gt; item in your &lt;ul&gt; where all the links are. To add a link, you probably have to add an &lt;li&gt; with the exact same attributes as the other links.
Next year, jQuery will still be at the top of the list. Guaranteed.
What JS jobs are you looking at? That list is pretty basic: JS - If you don't know the basics of ES6, you're doing something wrong. Typescript/Coffescript - Okay, probably don't need these Ang/Knockout/React - Not knowing at least one of the biggest frameworks out there. Doing something wrong. Git/Mercurial - Better know change control. Grunt/Gulp - Good luck working on large projects without these automation tools. Mocha/Jasmine/Karma - Good luck working on large projects without unit testing Selenium/Phantom - Have fun working on large projects without automated testing of deployments. These are basic things that any large project will be using.
Uhm, yeah, with what's written in "Am I missing something?" just above?
Angular + ASP.NET WebAPI is actually a decent combo, especially if you are in enterprise land. Angular is getting more adoption in enterprise type environments, which tend to have .NET focus in their stack. Angular + TypeScript + ASP.NET/WebAPI = a pretty good programming expierence for a .NET full stack developer. 
It's a datastore that's loosely inspired by flux and the Elm language. http://rackt.github.io/redux/
Don't let people convince you that knowing Node inside out (or Express and his kind) is a big requirement. If you land a full stack job chances are the backend will be PHP, Java, C# or Ruby/Python if you're lucky. Roughly in that order of probability. Node is still a rare bird. That said, a webdev is expected to know jQuery, Ajax/XHR, Git and Angular. Most of these requirements are quite unreasonable, yet still commonplace.
They tried Angular at my company with that exact setup. Why use an MVC framework with another MVC framework? You can use Razer for damn near everything and if you need to do some real client side rendering and manipulation you can use React which can do all the cool view stuff with none of the Angular baggage. 
maybe https://github.com/typicode/json-server
You keep typing "inline" but keep linking not inline. The inline case works as /u/EnchantedSalvia pointed out with "Am I missing something". /u/benihana corrected your link examples above, including the event parameter. And if you see what is generated for the inline onclick through the HTML, it looks something like this: "function onclick(event) { func1('abc', 10, func2(event, 15)) }" In other words, the inline version is doing what is correctly needed that fixes your linked example. So it works out of the box.
Afaik describe is describing each individual test here and testing them sequentially, parallel is testing them asynchronously in fact looking over the github page for parallel tells me they themselves describe the execution as async. These test examples don't do anything though, personally for me since I wrote my own library for real parallelism I would simply write it like so var test = function() { hamsters.run({'test1': testData}, function() { var done; var test1 = params.test1; //execute test using testData rtn.data.push(done); }, function(done) { //work is done, do something with output } 1, false); hamsters.run({'test2': testData}, function() { var done; var test2 = params.test2; //execute test using testData rtn.data.push(done); }, function(done) { //work is done, do something with output } 1, false); }; test(); Both of those would run without any arbitrary time limits of 500ms or 1000ms, because they wouldn't be dependent on any time slicing. Because it's real parallelism. 
WebAPI = a good way of spitting out JSON w/o being tied to a view. Serve up the HTML as static assets and don't bother with razor. If I recall correctly - most of the WebAPI templates in VS did throw in some standard MVC along with the mix, not sure if there are better templates now to get a quick start w/o the MVC requirement. Not saying React is a bad choice, but I don't see anything wrong with using WebAPI along with Angular. If you are trying to force Razor rendering/etc and using the normal MVC controllers along with Angular - then yeah, sort of barking up the wrong tree on that one. I tried going that route for a bit, mostly so I could feed empty models into my razor template (then let angular take over the caching) so I could have some custom HTML helpers so I could do like @HTML.InputFor(n=&gt;n.Something) and have it spit out my angular template for me and read from the model metadata to add required fields/etc automatically. Ended up causing more headaches then it solved, and don't think I'd recommend going down that route again. 
Not a recruiter or anything, but I do have final say in hiring technical talent for my company. What's important to me isn't so much the specific technologies you choose as much as the ability to learn new technologies, knowing why technical choices are made, and more importantly (and almost always overlooked) knowing why you wouldn't want to use certain technology. Just as an example, if our technology stack primarily used React, but you knew the ins and outs of Angular, then I'd look at you much more favorably than someone who knew just a little bit of React and not much more. Then there's always some red flags I look out for, like insisting the technology choice you're most familiar with is always the best tool for the job. I always ask things like if you were to learn a new technology, how you would go about picking the new technology. A bad answer would be that it's what hiring managers are looking for. A good answer would be that it interests you, or that it's something you're completely unfamiliar with, or some engineering approach like that it's really good at performing a specific task. An answer that I personally like, but a lot of people may look down upon is that the technology has a lot of hype and you're interested in learning why. Finally, I fully understand the differences between breadth of knowledge vs depth of knowledge. They both have their advantages, and I don't have a preference -- some people do. If I notice someone has one or the other, I'll start to ask questions to try to understand how far the breadth of knowledge or depth of knowledge goes. If you're looking to learn something new, just pick something that interests you. It shows that you're truly interested in learning and not just trying to get a job.
Looks interesting! Do you know of any repos using this that one could review? 
I own a web agency and I too ask myself which JS framework I should hire
That's a really gross exaggeration IMO. There are PLENTY of JavaScript jobs out there that do not require either Typescript or CoffeeScript, or any of the frameworks you mentioned.
I just wrote a blog post about prototypal programming in Javascript last week which talks about all these things - I'm glad to know it's something that is truly deemed valuable at the senior end of JS development. I love learning about the intricacies of how languages differ from one another, and how to use a language's core design architecture properly. Edit: [Link to said blog post](https://thesocietea.org/2015/08/prototypal-programming-in-javascript/)
That's pretty cool.
&gt; React definitely has a place. Unfortunately, that's true. I like a lot of what React does toward componentization, although I think Angular does it better, but I cannot stand that template-inside-code-transpilation thing they do. I'd much rather have templates with databinding in separated files. 
My last company recently evaluated these technologies. Our JavaScript developer, who I have a lot of respect for, eventually concluded that React was the best option because of its relative simplicity. However, I would expect a good JavaScript developer to be able to figure out any sensible framework in a week or two - so prior experience would be nice but not a requirement in a hiring decision.
Ok i believe [This](http://futurice.com/blog/reactive-mvc-and-the-virtual-dom) is what i'm looking for. I need to Require my modules from the views or other modules and expose only event emitters and observables. My view will "know" about the modules but only interact with it through events which sort of replace event bus. I can compose with merge. His answer to the : How to get user inputs into the models is "Intent". A components who's purpose is to turn user input into model friendly events. Edit: Still very open to commentary or even rebuttal of the intent idea. 
&gt; Knowing the next big thing isn't what lands you a job easier ... but it sure makes recruitment agents excited and far more likely to consider you as a candidate to submit for interview.
I agree on the "learn a MV* part" - essentially, learn the idea behind MV* since these patterns are everywhere. Learning Backbone, Angular, Ember or whatever framework looks the "best" is also a good idea but - important - you shouldn't list React here. React is the V in MV*, there really isn't much of a Model layer neither there is a *(Controller, etc.) layer. So learning React, which is currently hyped, while learning Backbone works pretty good. Just don't expect React to be a Swiss army knife. Backbone or Angular are pretty good since there are a lot of tutorials for them. 
&gt;Using conditionals in your view components &gt;For some reason, Reacts JSX make this unnecessarily complicated by not being able to use if statements inside code blocks. JSX doesn't make this unnecessarily complicated, it's just a misunderstanding of JSX; it's just sugar for a bunch of nested function calls. You can't put an if block inside of a function call so you can't put an if block inside JSX.
I've been playing around a bunch with RxJS recently. It's a lot of fun, but it can also be really frustrating, as it requires an entirely new way of thinking about code. I would suggest looking at [Cycle.js](http://cycle.js.org/), which is a small framework around RxJS. They have some good examples on the site, along with some docs to help you get your head around functional programing, and their "Model-View-Intent" architecture. I've been meaning to put together a blog post for creating a simple list view. The key thing, I found, was to map user input to operations on the state, and then compose your state from those operations. Here's an example: // Stream of items added by user var itemEntries$ = Observable.fromEvent('input[type=text]', 'input'). map(evt =&gt; ({ id: _.uniqueId('item_'), value: evt.target.value })). filter(({id, value}) =&gt; value.trim().length); // Stream of items deleted by user var itemDeletions$ = Observable.fromEvent('button.delete', 'click'). map(evt =&gt; ({ id: evt.target.dataset.itemId })); // Operations on the state // Each return a function which accepts the current state, // and returns an modified version. // Our state looks like { items: [{ id: 'item_1', value: 'item text'}, ...] } var Actions = { AddItem: itemToAdd =&gt; state =&gt; ({ items: state.items.concat(itemToAdd) }), RemoveItem: itemToRemove =&gt; state =&gt; ({ items: state.items.filter(item =&gt; item.id !== itemToRemove.id) }) }; // Map each user input to an action on the state // The end result is a stream of functions which transform the state var actionsOnState$ = Observale.merge( itemEntries$.map(item =&gt; Actions.AddItem(item)), itemDeletions$.map(item =&gt; Actions.RemoveItem(item)) ); // Create the state by applying each action to the state var state$ = $actionsOnState. // Think of `scan()` as an asynchronous version of 'reduce' // --&gt; it takes a list, and reduces it into a single objet scan( // initial state {items: []}, // accumulator function (state, action) =&gt; action(state) ); // Create your view from your state var view$ = state$. startWith({ items: [] }). // We're using virtual-dom (similar to React's virtual dom, but stand-alone) map(state =&gt; h('div', [ h('input', {type: text}), h('ul', [ state.items.map(item =&gt; h('li', [ item.val, h('button', {attributes: {'class': 'delete'}}) ]) ) ]) ])). // If you're using Cycle.js, you don't have to worry about how vDom is rendered. forEach(vDom =&gt; renderVDom(vDom));
I think React is great, but I do agree with most of this article. Technologies made my Facebook often have an awkward API and don't look the prettiest. I think most of us hated JSX when we first saw it. You eventually get over it once you see the practical benefits. Would it be nice to have a cleaner syntax? Of course. ES6 and ES.Hipster help out a bit, at least. &gt; JSX is the new XHTML Nah. &gt; I wouldve liked to see them implement views largely based around ES6 string interpolation That's a bad idea for a number of reasons. One of the biggest points about React is that it doesn't require a template language and that you can just use JavaScript. No `if`s in JSX isn't that surprising if you know that JSX is sugar over function calls, which are expressions, and expressions can't have `if` statements embedded. They could translate `if`s to ternaries, but then we're getting back into the business of creating yet another template language, and making it harder to use new JavaScript features. &gt; Unexpected and automatic DOM element insertion I had this bite me once. Not a big problem if you use modern React styling techniques, but definitely annoying. &gt; Declaring a doctype I've never seen a use for this in React, and I doubt I ever will. In my opinion, if you're doing this, then you're doing something wrong. Who knows, though. &gt; HTML comments are similarly hard to shove into a JSX template. Yeah. Even more annoying is JS comments: sometimes I want to comment out some JSX, and well, have fun with that. (On that note, I should write a vim plugin for that.) &gt; A public API methods name is not the place where to tell people everything that could go wrong with it, though. You'd be surprised. &gt; Components coupled to client-side code and ES6 Yeah, not the funnest thing ever. Ultimately the solution is gonna have to be putting in an issue or creating a hack (Webpack is pretty good for this).
Good point. But I'd prefer that JSX remain dead simple and people explicitly use ternary syntax. It's a trivial change to make and it keeps people aware of what's going on. Speaking of which, why didn't you mention ternary syntax in your blog? I agreed with your post's point until I followed the documentation link and remembered that ternary syntax is available.
A well written blog post, but I feel like you've misunderstood some things about JSX. The "code blocks" only contain expressions (which makes sense, considering they output the result), which explains the weirdness you describe. That's why they don't accept if/else blocks but do accept logical operators. Also, reading the comments, I don't know why you think using a ternary is "just as bad" as your original workaround; a ternary is literally an inline if/else, while using &amp;&amp; and || is relying on side-effects. You make a good point about client-side modules in isomorphic applications; I've yet to build one myself, but the lack of a DOM server-side is definitely something to keep in mind.
Blah, the component's non-jsx code is totally C.. I know technically not, just don't see the functional difference. But definitely no M absent Flux et al, with ya there.
&gt; One of the biggest points about React is that it doesn't require a template language What the hell is JSX if not a template language? The only one you can use, unless you're a madmen and decide to go for their programmatic API. - I need a doctype to render on the server-side, which is definitely the opposite of doing something wrong. Thanks for the critique
Because for single-bracket it's cleaner to write `foo &amp;&amp; &lt;span/&gt;` than `foo ? &lt;span/&gt; : null`
mixed up the user names lol 
well hello imposter...
As /u/IAM_A_GOATU said, we need to see the code. Based on the snippet, my guess is that you're expecting `fun1` to fire when the user clicks the link. What's really happening, though, is that `fun1` is getting evaluated as soon as it the browser hits it, causing it to try to evaluate `fun2` immediately. If this is the case, what you need to do is make the `onClick` handler *reference* `fun1` without actually calling it, i.e. `onClick="fun1"`. `fun1` would then look something like this: function fun1(event) { return fun2(event, 15); }
Umm, sure. But for the example you use in your post, a ternary would completely solve the problem. Mentioning "ugly" short-circuiting and not mentioning ternary makes that a poor point at best and deceptive at worst. Anyway, I enjoyed the rest of your post.
Lol, it's at least easier to make sense of.
Well, there was/is discussion about compiling to the same `do`-behavior as soon as this proposal advances (and it has good chances to). So things will be improved over time ;)
If you're looking for a truly JavaScript way, then Node.js is the way to go. If I were you, I wouldn't rush to using Express, before being well acquainted with Node - it does a lot for you and prevents you from learning all that Node has to offer.
That's great to hear, Ingvar!
Mostly, resumes are bullshit. I can't tell you how many resumes I've seen that, on paper, look like good candidates but can't even tell you what the DOM is during a phone screen. Most recently I had a candidate tell me they designed/built 100% of their personal site, despite said personal site having a "designed by so-and-so" footer link which linked off to the design template...Comparing the code, this guy literally just swapped text and images, lol. &gt;First things first: I have no qualifications to interview or screen anyone, and usually, neither does anyone else in this process **Truth.** &gt;but I must admit I do respond very positively when I see a true computer science graduate from a respectable university. More than anything, I just want to see that you are smart. Why do you assume graduating "from a respectable university" makes someone "smart" and they didn't just scrape by? Graduating just means they learned enough at that time to meet the basic requirements. I've worked with two PhD's from "respectable universities" and I was not impressed at all. Two of the smartest guys I've ever worked with (one at Yahoo) never had a CS class in their life. 
In that case I completely agree with you, because the architecture change is intended to support application code. I only oppose modifying my application code to support unit tests when it isn't necessary. At the end of the day, just do whatever works for you. We can agree to disagree.
Nice post. No library/framework is perfect, at this point we're just choosing the best out of what we have. Somebody did make a novel solution to the conditional JSX problem [react-if](https://github.com/romac/react-if) that I've been meaning to check out.
onclick property _in JavaScript_ takes a function reference; the attribute in HTML takes code to execute. The code you put in the HTML is automatically wrapped in a function with an event parameter. See: http://jsfiddle.net/dmc5jg7k/
Yes, last post was creating confusion. Actually this is a legacy code, when I dig code more I found this one - var func = new Function( "fun1(fun2(event,15));" ); newLink.onclick = function(event){func(event)}; This code is written in loop, now for every link same function is getting called, how I can manager different function call for every link. In loop parameters of new Function is getting changed.
So what language do the developers of jQuery write jQuery in? &gt;most devs have no clue And therein is the biggest issue.
Currently the top post on /r/javascript, nice try though.
Thats a bit of a mess. But your problem there is that your `new Function` doesn't supply the event parameter. Without it, `func` has no parameter so even though you're passing the event argument into its call, it can't access it as `event` (event doesn't exist). You can include that parameter in the Function constructor var func = new Function( "event", "fun1(fun2(event,15));" ); But do you really need to be using `new Function`? That's adding a completely unnecessary complication to what could just be assigned to the `onclick` directly.
Specifically re the automatic insertion of SPAN elements by JSX compilation... Is putting a generic style on every SPAN element on a page really a good practice? A SPAN element is intended to be a pretty generic inline container so it seems odd that someone would decide that every SPAN on a page or even within a part of a page should look exactly the same. It's a stretch to call this out as a knock against React or JSX.
Not the point, the point is that automated DOM el insertion is unexpected and may result in hard bugs to track down unless you know that JSX does this.
&gt; new Function That's eval. Don't do that. Also, create a test case on jsbin or jsfiddle. Always provide example code which illustrates the problem.
you keep changing the code ;) Do you have a more complete example?
I hear ya. And that's cool. But unfortunately it makes it unusable to me for an immediate need. And thats a bummer. 
Love this example! Thanks for getting me to finally understand scan too (basically a reactive reduce), do you have any more stuff like this to look at?
Just because employers are looking to hire a certain framework, doesn't mean you should learn it. React will be hired for more as time goes on, as that's the new hip kid in school. But being flexible and understanding what each framework is doing under the hood is important. 
Please do not use self-posts for links.
Maybe these are bugs/shortcomings in the React docs, but most of these are intentional decisions and are the right thing to do. * DOM node insertion: yes, this can be annoying, but there isn't a great alternative. When you interpolate an expression React uses that as a hint that when that expression changes, we only want to update that tiny piece of the DOM and nothing else. You'd think text nodes would be a good solution to this problem, but you can't encode a text node in HTML (i.e. two text nodes next to each other in HTML is indistinguishable from one larger one) so this would break React's server rendering capabilities. If you really don't want this, you should use string concatenation and a single interpolation. * Conditionals: this is a misunderstanding of what JSX is. It's syntax for creating tree objects, not a templating language. If we take the author's advice and add JSX-ified if statements, do we have to implement switch too? How about for loops? While loops? Where does it end? You eventually end up implementing a crippled, unpredictable JS pidgin, which we've learned is a pretty horrible idea unless you plan on investing years of research into it (JS is good enough). Also, the React login button code example in the blog post looks pretty beautiful and maintainable to me. * Doctype/comments: React isn't designed to render &lt;html&gt;, &lt;head&gt;, &lt;body&gt; etc, and will even issue a warning in your console if you try. Perhaps this should be documented better, but this has never been React's intended use case so I'm not sure why so much space was dedicated to this. * dangerouslySetInnerHTML is well named and the author is wrong * Components coupled to client-side code and ES6: normally if your dependency tree is reasonable this shouldn't bite you, but I've seen problems here once or twice. webpack + commonjs modules can solve all of these problems though.
You're right. I took a better look and learned new things. Thank you for that!
Mind sharing the link? I'd love to check it out.
I'm not evading anything I'm just trying to figure out how to share things I write with Reddit. They told me I was sharing "too many links from one domain"
&gt; People recognize that natively setting html is not safe why does react have to reiterate? I'm not sure about that. That isn't my experience. Either way, it's just a few more characters. In exchange for protecting the security of your users and avoiding publicity nightmares, it's a pretty small trade-off and discourages the use of insecure features.
;-)
I only read resumes for the job history especially looking for the length of employment at any single employer. I really don't care for education level or type of degree. I have **more** reason to doubt developers with a CS degree (not less). Educated computer science people tend to focus heavily on application development with OO code. On the web this is **bad**. First of all *content is king*. The most important technology on the web is the plain text that humans consume. Most CS grads want to dazzle with the programming mastery and refuse to accept the simple primitive things. This means over prioritizing the role of the application code and failing at things like accessibility, searchability, and usability. Web technologies do not descend from OO based architectures. Showing off your impressive OO coding skills screams that you not as experienced with web technologies as you think you are. HTML and how the browsers use it is pseudo-based off XML (at least since about 2001), which is inherently lexically scoped. XML is (yes, XML code has programmatic scope) heavily inspired by Lisp. JavaScript's scope model comes directly from Lisp. JavaScript is OO (thanks to prototypes), but prototypes are a supplement to its native scope model and follow the same Lisp like scope model. Those CS grads are, in my opinion, severely tarnished. I can always teach somebody new and train them to use these technologies correctly, but somebody who is formally educated in Java... better seriously know their shit during the interview or I will bounce them. Do us all a favor and instead of bullshit fill your resumes with portfolio items and describe the strengths of those items. This lets everybody know your interests, capabilities, and style before even entering the room.
pretty cool... if I could suggest a feature... I once tried an android interval training app, and it had a very useful feature... after guessing it would play a short clip of a very recognizable song that used that interval (for example "somewhere over the rainbow" for eights)
This being "novel" amuses me because we're slowly turning JSX into XSLT.
If you're using babel, just skip ahead and use async functions. Looks like they got moved to stage 2 and are enabled by default, anyways. Generators with wrappers yielding promises are arguably designed to be a (slightly-hacky) stepping stone to async/await anyways.
No it's not possible without changes to the site, the events section uses an xhr request to load the data in dynamically meaning it doesn't have separate pages so without javascript to inspect the page address and load the content you want based on that, it's simply not possible. 
In the case of webhamsters, extracting even half a ms out of the logic is time well spent, considering it's most viable use case is online games at the moment that run in the browser, in order to get 60fps al l frame logic must complete in 16ms or less. I've found forEach to be up to twice as slow as a for loop. 
I know, which is why react-if is an odd solution because if you see JSX as syntactic sugar, creating a react component simply for flow control seems really out of place for something that's meant to generate React.DOM nodes.
He has an Indiegogo campaign for it that closes in a week: https://www.indiegogo.com/projects/prosemirror/#/story
Yes, I'm saying that your prediction was wrong.
Interesting, but I have no idea what I'd do with that. If I had some tasks I could conveniently run in the background, I'd just use a worker for that.
Sharing this snippet with the community, currently only supports north american timezones hopefully others can build upon it. Example usage: return getUserTz(); -&gt;&gt; (UTC) 
The best thing to do is get rid of your strings and use functions instead. So where you have "f1(f2(event,5))" use function(event){ f1(f2(event,5)) } And same for all the others in the array. Then in the loop omit new Function and just use link.onclick = arr[i]; If for some reason you want/need to keep new Function, supply it with the event parameter as described in my other comment. 
Your spot on. I hire JS devs, and manage them. If I interview somebody and they can't tell me one new feature in es6...they are gone. If they have never HEARD(maybe not used, someone else may have done it) of any build tools, they are gone. If they have not heard of NodeJs, they are gone. If they have not used it, that's fine. Part of knowing any language is keeping up with the community and the evolution of that language. All of these things have been out for several years at least, and if you have never heard of them it tells me several things immediately: - You are not passionate about what you do. Keeping up with your skills and tools is very important. This shows that you go to work, do what you need, and go home. You are not someone who will strive to learn and improve yourself. You're out in my book. Nothing you can say will make me hire you at this point. - You have probably worked at a place that was using JS (...likely jQuery for that matter) to validate forms, change the color of something, or to make an ajax call. While this does not exclude you from being hired completely, you have a lot to do. Most of which I'm hoping you have done on your own side projects, and yes, if you gave me your github, I will ask you to explain your reasoning behind your code. If you can't, it's probably copied and you have no idea what you're doing. You're out. I guess that's all for that list. This of course depends on what the company does. If it's for a modern, SPA, **Application**, with business logic, complicated async stuff, hell we use worker threads, etc. then you **Better** not only know this stuff, but probably how to use them. (Unless the company and manager are shit, then well, the results in a shitty product anyway...gl with that). There seems to be a really big gap between people who say I know JS and people who actually know JS. This makes it very difficult to hire, as many people really do not. Most do not know how to program either. They think because it's a JS dev front-end job, there is not programming ability needed, ...wrong again. Something like Typescript or Flow will really destroy the non-programmers, while someone who has not even used either of those before, will be able to pick it up right away. Frameworks...Let's talk about that. If you actually **know** JS, it does not matter what framework you use. I expect a new JS dev to be able to pick up most of React within a week. You should be able to transition to any framework very quickly (the good frameworks...not the crazy ones that use syntax that's very different than JS). I do not really emphasize *knowing* a framework in an interview. You won't get to those questions if you do not pass the above and demonstrate you know JS. I rarely even ask a question about a framework, other than "what have you used?". For reference, these are the expectations that I would have of a developer at the upper-mid to senior role. Pay around $90 - $110/hour. Of course there will be many other questions about the intricacies of JS, I may even bring up typed arrays... 
There is already a project that does this for most TZs: https://bitbucket.org/pellepim/jstimezonedetect
-_- This is because Firefox doesn't support `window.event`. And you shouldn't either. your code accesses an event property that, as far as the definition of your code goes, doesn't exist. However in some browsers (and I believe you can blame IE for this), there is an event property on the window object, and since window is the global, event is a valid reference there. This is not the case for Firefox, and you should assume that it will not exist, instead relying on the event argument which all modern browsers support. If you want more compatibility, you can check for the event argument, and if it doesn't exist, try to fallback to window.event.
This is quite interesting, I'm working on an AngularJs app for one of my clients and they were worried about the version 2 coming up. It's good to know that we'll be able to convert the app in several steps while keeping it working and replacing some critical components first (like starting with the templates, it's lacking in terms of performances at the moment). 
Thanks, for the welcome, that is noted!
Made one some time ago, never got to finish the documentation and fix some bugs: http://koala.joaopluis.pt
some perspective: agency recruiters and giant corporate HR departments look for keywords on your resume (even though they don't legitimately know what the words mean). the developers who will interview you, and ultimately make the hiring decision, probably don't care at all if you already know the same framework they are using. they (the developers that is) do care that you have sound programming fundamentals and a demonstrated history of writing and shipping good code. they will also care that know how to use the important tools for writing software in a team environment (version control, testing, etc.). they will also care that are willing and able to learn new tools on the job. 
Different strokes :) It's also worth noting that you're *not* expressing HTML with JSX. You're expressing a ReactElement tree, which uses a bunch of non-W3C-standard attributes &amp; nested React components, and in many cases (react-native, react-canvas, react-router routes etc) is not rendered to html at all. Especially in those latter cases JSX looks really weird to me.
What do you think of just writing a javascript that runs periodically to grab info from an API and writes it into a local .json file. Then I could just display the contents on a single page app via angularjs? I'm just curious if just fetching info and storing it warrants full blown back end development.
&gt; Also I think "innerHTML" is clear enough that you are setting "innerHTML". People recognize that natively setting html is not safe why does react have to reiterate? You have a vastly higher opinion of people than I do. :) My view is that the React API here has some positives and no real negatives. The objections raised in the blog post just don't make sense to me. Why *not* reiterate? It's a very dangerous operation. 
yea just change the line that says `frm.amt.value = ''` to `= '0.00'` https://jsfiddle.net/fx6qpqhy/5/
I made one but it's more WYSIWYM more than WYSIWYG... [Doctored.js](http://holloway.co.nz/doctored)
Does anyone have a good tutorial for building isomorphic UI with React and Node like this? I would love to go through it. This looks like a great way to do UI.
Though what is nice is that I can prototype a page in static HTML and then I can just copy and paste blocks into my JSX and typically "it just works"(tm). I'm not asserting this is a make or break feature - it's just pleasant for my workflow.
Ok, thanks. Is it possible to create a wrapper page on another site that will action the script?
backbone needed to do this with the dom too, so there was something for it to own.
That's **per year**. No, we didn't start out at that; and we've had our ups and downs, including this year and last being down but that figure is about where we usually hit.
Can you elaborate on if / how / why this is better than three.js. Im just curious I have a decent amount of experience with three.js. I know there are people out there who nit pick about things like its implementation of a phong shader and really technical things like that, but I have never ran into any walls with it. WebGl is awesome though and im always interested in new libraries for it.
If that's your workflow then JSX is certainly the way to go. A lot of people really love JSX and that's totally cool. Personally it's just not my taste and I wish it was "more optional" :)
Says who? Unless the manager needing the resource has said "I need someone with [next big thing]" the recruiter could give two turds and likely doesn't even know what [next big thing] even is. Recruiters are looking for keywords that fit their job posting and experience aligned to those keywords and beyond that softskills when they reach out to the candidate.
Yeah as someone who loves backbone... It feels pretty dated. I think my love for it comes from how much it had to teach, it has such a readable codebase and has to be the most well documented library iv ever come across. I learned allot from it. But its just to much boilerplate anymore. I still miss Backbone events when I dont have them though.
External: Separate file from HTML document. Referenced within the HTML document with &lt;script src="[URL of script]"&gt;&lt;/script&gt; which loads the external script into the HTML document where the script tag appears. Embedded: Hardcoded in the HTML document using &lt;script&gt;[code]&lt;/script&gt;. Inline: Written in the opening tag of an HTML element. Ex.: &lt;button onclick="this.style.color='blue'"&gt;Turn Blue&lt;/button&gt;.
How about you start by giving the ones you think have contrived examples..?
What's the most complicated WebGL example someone has?
Link please? I don't know it super well and would love to learn more.
Learning Node will make you a far better programmer than any of those SPA frameworks will... before long you'll be creating command line tools, Scraping web pages, and writing stand alone re usable modules... Those type of things carry over to any type of programming. Learning React will make you good at React... Im not saying its bad to know, but Node isn't a framework. Its a run time environment. Node just lets you write Javascript out of a browser but its actually pretty low level.
Here's a pretty damn impressive one http://www.ro.me/ I think the author of three.js was actually involved in making this. 
Well, the reason statements aren't supported is because JSX translates directly back to function calls. &lt;div&gt;&lt;/div&gt; becomes React.createElement('&lt;div&gt;', ...). A function call can only accept expressions as arguments-- hence, no statements. When it comes to conditional rendering, I think ternary expressions are a quite pleasing way to do it. Example: let printHelloWorld = true; // or false or whatever &lt;div&gt; { printHelloWorld ? &lt;p&gt;Hello world!&lt;/p&gt; : null } &lt;/div&gt; I think the above format is pretty nice, but for the sake of clarity, here is the same expression on one line: printHelloWorld? &lt;p&gt;Hello world!&lt;/p&gt; : null Apologies for formatting, as I'm on mobile. Let me know if anything is unclear and I will fix when I get back to my laptop.
Yeah, you're not supposed to submit a lot of links to your own website.
FYI, (I'm not sure if this was intentional, if it was, sorry to bother you), you forgot to distinguish your posts.
The article could be a tad clearer, but he says: &gt; Its final goal is to use GPGPU techniques to shift the physics logic to the GPU I'm not sure how much milage you'll get for a general-purpose physics engine though... I don't get the idea that they are "massively" parallelizable unless you're doing hair or thousands of bouncing particles or things like that. It's interesting though. Physics are probably the weakest point of using web technology for games and other similarly CPU-intensive apps, and there are now 3 different approaches out there: * cannon.js - hand-coded &amp; optimized JS. * ammo.js - C compiled to asm.js * Four - use the GPU SIMD will hopefully be a game changer for JS physics engines. If you can hand off all your number-crunching tasks to specialized hardware and/or native libs, and if you can work with cache-friendly blocks of memory with a human-friendly interface, the "slowness" of an interpreted language like JS will almost be a non-issue.
That sounds fantastic. After being spoiled by async/await, I can't bring myself to do any projects without it. By the way, what's the read on `await*` on an array of async/promises? Last I checked it seemed like it was sort of up in the air. Is that still moving forward? I would hate to see that disappear.
Not likely most complicated, but a few of my favourites: * [music video](http://lights.helloenjoy.com/) * [physically based renderer](http://blog.playcanvas.com/physically-based-rendering-comes-to-webgl/) * [visualizer](http://christmasexperiments.com/2013/22/) You'll find a lot of good stuff if you follow [three.js google+ posts](https://plus.google.com/+ThreejsOrg/posts).
That's unfortunate. I don't have a legitimate practical reason. I just prefer `await* arr` to `await Promise.all(arr)` since it's faster to type, but I can't think of any use case that would work for `await*` and not for `await Promise.all()`. If I think of a real reason other than my desire to type fewer characters, I'll be sure to let you know!
I'm the not the first to say it, but it needs to be said: Material Design is not a good presentation layer. The traction its gained for aesthetics is not because it is good, but rather because it is less bad than what people were coming up with for Android apps themselves. It's basically the equal-but-opposite horribleness that Apple was trying to do with skuemorphism. The data-density presentation is abysmal, and no one knows exactly what the card animations should really be trying to accomplish for any given task.
You need: * Any yield code to be running inside a generator function. * Pass your generator to a "trampoline" such as [co](https://www.npmjs.com/package/co). As /u/dvlsg says, if you use async functions instead of generators, you can skip the trampoline, and just change `yield` to `await`.
&gt;Why do you assume graduating "from a respectable university" makes someone "smart" and they didn't just scrape by? He doesn't, your insecurities just make you think that.
When it comes to keyword matching "JQuery" has the same weight as "C++." HR doesn't usually know what either of these things are either, so there is something to be said for including these kinds of things in your resume to land an interview.
I actually like react-if. I think it would be better implemented as a switch though.
I know, I know. Just saying, stuff like that is what I was hoping to find. Or even bemoaning mixins
Ah, yeah, that would be.. more useful. :)
Please view in a wider browser? This would put me off as it implies that mobile browser support is not there?
You can't do drag and drop file upload on mobile anyway.
This would be a funky design. "Infinite scroll" might be closer to the user experience you're looking for. You'd want it to start loading new content before it reaches the end of the page, which would alleviate your needing it to be exactly ==. Also, I'm guessing reddit added the comments to your code? Because if those are actually in there, the better question would be how the heck it's working in IE!! That style of comments is something that was only ever necessary about 15 years ago.
Frameworks are a means to and end, if you have specifics goals in mind it would be a lot easier to suggest a framework. That being said learning any framework can't hurt so if you're just curious then do some reading and pick whatever seems interesting.
http://www.doxdesk.com/img/updates/20091116-so-large.gif
https://github.com/cbrandolino/jQuery-basic-arithmetic-plugin
It looks blurry on my non-retina screen too.
HR isn't typically making the decision to hire. In any interview situation I've been in HR gathers resumes and passes them to the interview team; Managers, tech staff, PM's even for review. That team returns a list of ones to call in. But once they do that phone interview and find out that you don't really have any experience in C++ or jQuery then they feel like you've wasted their time. If it's particularly egregious exaggeration they may even put you on the do not call list. Plus some cities are smaller cities with a lot of churn, so if you burn one potential employer people talk, people move to other companies, so it's better to keep the fluff down and not have any hard feelings with your potential new employers. I have plenty of examples where candidates have come in with resumes that got them in the door and it was obvious within 5 minutes that they weren't even close to good enough to hire. Worse are the ones who are smooth enough to connect with the manager and get brought on only to fail spectacularly within a week or two of being in house. Such a waste. Don't be that guy. 
There is nothing intrinsically wrong with storing the data to a json file. But I assume that it's not an option to store the file client side, so you need a server to make the API calls, store the JSON file and provide it or the analytical results (statistics of some sorts) to the clients. Also, even if you are making the app for one client (e.x. yourself), you are still better off writing a quick Node module for it, because writing to files for persistent storage is much easier to do this way ;) Overall I would not pick managing the file myself however. It will most probably be inefficient, and you would not have the ability to query and index your data - all of which are traditional functions of a database. People have mentioned MongoDB, but you may find redis or LokoJS easier for your first project :)
So you need to develop a web application with a asp.net backend. Nothing very special, you will find plenty of documentation using your favorite search engine :-)
Here's some of mine I add to on occasion. I'll add some of my newer ones tomorrow. https://gist.github.com/dwighthouse/2d373b56e0f4833903fb
That's an ES7 feature of setting properties on a class at definition time. ES6 classes only have the ability to declare methods at definition time. This is why it's an "experimental transform in babel" as aBonRivers says.
I'm not really sure what you're trying to say here, aside from that you're not a fan of Material Design. How does the data density relate to Apple's skeumorphism? Which card animations are you being confused by? The way I view "Material Design" as it's talked about not in relation to non-Google/Android apps isn't in strictly following Google's guidelines re: padding and margins or throwing in needless animation, but in creating some basic principles of the digital world through which user interactions work. e.g. Things shouldn't just happen: animations are used to transition between scenes, using the motion to help build the user's mental model of the app/site. On the point of data density, there are certainly times where I think high density is useful, but I think there's a general view among the design and usability communities now that density isn't always the ideal, and that readability is much more important.
If I get it right, you want to build a sort of "receipes for lodash". Like "filter an array for the given values" w/ its lodash implementation. I find it a nice idea.
Please explain how &amp;&amp; and || rely on side effects.
It relies on the fact that values in a conditional are evaluated in order and that the evaluation stops once it, for example, finds a falsy value for a &amp;&amp;. I'm not sure if "side effects" is the correct phrase but maybe "language implementation details" (or "hacks")? Regardless, even if it's reliable (and considering thousands of scripts use it for e.g. default parameter values, it most certainly is), using a ternary is better here because it's what ternaries are made for, unlike the boolean logic operators.
Just wanted to **thank you** to everybody who took the time to fill in the survey. The information is extremely useful.
Nice! Just a heads up, your Stompflow link doesn't seem to be working.
Javascript Purist like me, plz check out [NodeList.js](https://github.com/eorroe/NodeList.js)
You may have a point kandetta. However, I have found that in all but the simplest tutorials the functionality is usually spread across several files. The IDE style display and the guide is intended to help you move around these files, while at the time providing some context for the source file being described. I do agree that this style suits certain types of tutorials more than others. Using this technique to describe a simple code snippet would be overkill. Thanks.
When you learn how to manipulate the DOM with vanilla-js use [NodeList.js](https://github.com/eorroe/NodeList.js) to make it as easy as jQuery
That means you might answer what YOU think is important. Not what the average employer think is important.
&gt; ES6+ arrow functions arrow functions are ES6(ES2015). The part about your example that is not ES6 is defining properties on a class. This is a possible ES7 feature. Just to make it clear.
setInterval will evaluate the code if the first parameter is a string. https://gyazo.com/9d0c06dd152c795651fe46969ee57e68 Still I agree, this is not the best way to go about doing what theyre trying there.
I agree an infinite scroll solution would be better providing that this isnt going to be to display some long data on a screen for long periods of time (since its infinite and the page is supposed to be automatically scrolling downwards). I suspect that the random html comments inside the script tag is what is causing this not to work. Also as a prewarning, the current script, if the page has no scrollbar (or very little scroll) then the page will virtually be refreshing every 100ms which is not good. This seems like it was pulled from an example HTML website tutorial from 1999 though.
As a guy who is also new to react, I think you should go through and re-read the docs more carefully. The reasoning behind a lot of the issues you have with react are explained very well in the docs, and when you drop the notion that react is bad because it breaks rules you're 'supposed' to follow, it becomes a lot more natural to use. Honestly, you're not thinking reactive enough. This feels like one of those articles written by an old procedural programmer about how shitty OO is. When you try to apply principles of old ideas to new ideas, you run into issues we see here.
Pffft. I guess you haven't heard. [Excite](http://www.excite.com/) won that war! :D
By that I assume you're asking if you could make your own page which fetches the results from their API? This is currently where the site is hitting when you change those filters: https://www.bristolsu.org.uk/svc/feeds/events/14744?subtree=true&amp;from=2015-09-19&amp;to=2015-09-27&amp;_=1440592711660 It would technically be possible to do what you are after HOWEVER the server does not allow for cross origin requests to this site. Which means they have not allowed access to that portion of the API externally (for security reasons). This restriction is of course only for browser clients so you could create a server side script on your own website to proxy the result data and from there you could build your own little front end to that data. That being said a proxy may not entirely be necessary. It might just be easier to have a cron run every 30 mins or so that pulls the URL and just creates a clone of the resource without any date restrictions.
Well actually you don't need to learn anything, you just need to import the element in your page. If you prefer, you can use Paint or Photoshop to create an icon, you can use CSS or you can use Blockies the library this element is built on top of. The good think is that you have lots of choices for one simple problem. That's amazing, isn't it?
Someone mentioned [jsx-control-statements](https://github.com/valtech-au/jsx-control-statements) in another thread/article. I'm curious everyones thoughts between the two.
yeah lol
How does this compare to [Dropzone](http://www.dropzonejs.com/)?
Here ya go - https://thesocietea.org/2015/08/prototypal-programming-in-javascript/ Happy reading! I researched more about it as I was writing the post, and I really enjoyed learning how different JS is from class-based object oriented languages
Hi there. The main idea for using JSON was down to the fact that you could store the schema in a database (MongoDB in our instance), have it edited easily and transferred to the client for rendering. The main project it was built for had the requirement that the form may change very often and needs to be flexible etc. Therefore, we can just update the schema and push it out. A form builder can also be easily built to output the schema and have it render for render etc! Hope thats cleared some of the confusion up! PS: We did consider using React components to build up the form initially!
That is because you placed it there in the HTML. [Here](http://codepen.io/Voreny/pen/zvOONm), I changed it for you (put the div with "swag" id after the header in the HTML part, changed in the JS part that the selector selects the second div instead of the first one) and also I cleaned up the code a bit - you should put the stuff that is in head in Pen's settings instead in just HTML there. &amp;nbsp; Also if I may have a suggestion - when selecting elements in Javascript try not to use getElementsByTagName when selecting specific element, such as in here. You're trying to select a specific div, you even put an id on it - make advantage of it using *getElementById*. This way you can put it anywhere on the page and it will still be working as intended.
I've been using TypeScript at my job for the last 2 months or so. Here's what's good: * Static typing * Visual Studio Code is a great editor - it's intellisense is wonderful * Supports most ES6 features (doesn't support generators yet, but that's right around the corner) Here's what's bad: * Gotta write more boilerplate code if you want to use static typing. You can write interfaces around a JSON structure to get static typing on JSON objects. While this is nice, it can be tedious to maintain if your JSON structure keeps changing. * Getting a decent build process going can be difficult. I ended up using gulp with gulp-typescript, and karma/jasmine for unit tests. I'm sure I'll think of more - if so, I'll edit this post. 
&gt; Learning (or getting used to) TypeScript nowadays is just a waste of time. I really think this is wrong. ~~It's identical to how ES6 will be~~ It's features conform to the ES6 spec, save for the static typing, which you don't even need to use. Moreso, TypeScript can transpile to ES6 now, which pretty much just strips the types out of your .ts code.
What about for performance? I haven't done any tests myself, but I keep reading that the performance of lodash map/reduce is much greater than native map/reduce.
Yeah I had a setup like that, but we ended up needing a lot more done in a single step - hence gulp. gulp-typescript supports tsconfig, so that made that part a little easier. I should mention that our gulp setup at the moment also knows how to run tsd to get all required typings as well as generate a tsconfig file from a json object (this way you never have to update the "files" array manually, it just gets generated from your src folder)
BTW, the TS plugin in Atom also updates tsconfig based on the files it sees. It's nice. One of my side projects is an electron app. So far my needs have been simple enough that npm scripts are enough. I've used or tried to use `tsd` in the past to manager .d.ts files, but that tool just doesn't seem stable and bug free enough. So I dumped it and just download stuff manually. 
We gotta stop using the term "beautiful" for every damn widget somebody makes. These look like just about like any other charting library out there.
Hmm, maybe I'll give Atom a go. I've only used TypeScript with Visual Studio Code so far...I wonder how it works with IDEA. TSD is far from perfect, but it definitely works. The only glaring omission is the lack of an uninstall command. What problems were you having with it?
I read the summary on your link. It's still not clear how you solved any problems related to collision in distributed systems. Is this the call to Math.random() that you include in your Cuid? Frankly, your Cuid seems to solve a problem that you haven't successfully demonstrated to us. Where are your performance statistics? Where is your statistical analysis on collisions and your real world test data? I'm afraid it looks like you just reimplemented UUIDs and called it something else.
cool, thanks for sharing. &gt; - wait until the page is fully loaded: you may need to scroll down the entire page and hover dynamic document elements (e.g. "rollover" images) to be sure all elements are loaded too bad for this though, ajax huh?
I did what you recommended and just changed it to var div = document.getElementsById("swag")[1]; but now it is no longer working? What is the issue? I only changed that one line.
&gt; Different syntax (cause yes, you still have to learn a special syntax) Setting up TS environment. Not sure that TS will follow ES6 standard. I'm fairly certain the syntax is identical to ES6 syntax. So classes, arrow functions, etc. are all the same. Also, one of TypeScripts goals is to not stray from the ES6 spec, so I'm pretty sure it'll end up following standards. &gt; ES6: Promises, Generators, Classes, async/await emulation and many other ... Most of them are NOT handled by TS (for now) Babel has a standard library it seems, or a giant polyfill to manage all of those features TypeScript omits. You can still use polyfills with TypeScript pretty easily, which I'm pretty sure is what Babel is doing (correct me if I'm wrong). Promises can be polyfilled (just like Babel) Generators can be used now with the 1.6.0 branch, although that's not 100% stable yet, so I guess you've got me on that one. TypeScript supports classes and interfaces async/await will probably be a while, as it's not slated for release until TypeScript 2.0 &gt; IMO, TS does not add enough syntactic sugars / features to fight againt ES6 transpillers for now. Maybe in a few months, yeah, JS is moving so fast, but right now, i would start my new project with ES6 / babel.js. Fair enough - if you've got a use for generators and async/await, and it just can't...ahem...wait, then I suppose the Babel route is fine. I have nothing against Babel, I just happen to think TypeScript is a great language. 
I also removed the "s" on elemnts, no change.
FIxed it on my own, haha, sorry :P
I was gonna say it was pretty unusable with JSX, but [apparently some of that has been fixed recently.](http://blog.mgechev.com/2015/07/05/using-jsx-react-with-typescript/). I'm assuming the annoying parts of using React with ES6 classes still apply though. (haven't kept up on this in a few months) Very fun to use if you're not using a framework &amp;&amp; used to programming to interfaces. Angular 2'll be fun with it. 
I never said it was a strict superset of ES6. It's definitely not. I don't think Microsoft wants to add any behavior that would require a polyfill, hence the omission of Promises, etc.
Looks neat. I like the idea of using a schema to generate forms. I was looking at [tcomb-form](https://github.com/gcanti/tcomb-form) and [tcomb-json-schema](https://github.com/gcanti/tcomb-json-schema) for that very purpose. It has the added benefit of supporting a widely used standard, [JSON Schema](http://json-schema.org/). This way you can even use the schema to generate models, share across apps, etc.
I find the `_.pluck` and `_.where` methods to be quite useful.
Why don't you download a free dataset from the web and use [D3.js](http://d3js.org/) to model the data and show something interesting and useful about it. 
Neat. One thing I'd really like to see in a form framework like this is support for completions. For example, an input could be expecting tags, people or an address. Then you could plug in some standard completion mechanism that looks for valid input given typed characters or provide your own. It's kind of hard to know how you'd design such interface though. It would be nice if the "completion interface" could allow such things as date pickers and searchable dropdown boxes.
You say it like it's a bad thing ;)
Commenting to find out what an automatic electron-shell app builder is...
Write some code that models how our brains can mean to write one thing, but instead produce another. Maybe look at 'autocorrect' programs as a place to being investigation of the phenomenon.
The benefits are obvious. Static typing, better code completion, significant reduction of runtime errors. There are still plenty of detriments as well: * Integration with 3rd party libraries is hit or miss. [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped) has to be updated everytime a library API is updated. Many libraries are missing support. * Any runtime signature changes will make you hate TypeScript. Do you use Bluebird's promisify() or promisifyAll()? Get ready to cast everything to the any type, otherwise you won't be able to invoke the promisified methods. * TypeScript is always behind. They are just now getting really important ES6 features in (generators, even async/await) which you could otherwise benefit from greatly when using Babel. It may be worthwhile to at least take a look at Facebook's Flow, since it provides static type checking without going 'all-in' on a new language. I believe the release of Angular2 and the development of a more robust ecosystem will go a long way towards helping TypeScript. Wrote a project using TS 6 months back, haven't used it since. Much prefer ES6/7 with Babel.