At the beginning asm-dom is born from the idea to test the powerful of WebAssembly in a common use case that is not gaming, VR, AR or Image / video editing. Using asm-dom you can potentially share a lot of C++ between desktop/mobile apps and web site. Also, WebAssembly code runs faster than javascript
&gt; Web Assembly I agree, and IMO it's really only a matter of time before (a lot of) devs switch to their language of choice and compile to WA.
Really cool project. Do you have any performance measurements that we can compare it with pure js dom sultions? Is that even a case?
Angular's [reactive forms](https://angular.io/guide/reactive-forms) are amazing. Great for dynamic forms or "realtime" updates and are just a joy to work with in general. The [CLI](https://cli.angular.io/) makes it relatively painless to start an application. Plus [typescript](https://www.typescriptlang.org/) should be fairly intuitive for a `C#` developer. 
JavaScript is not all bad. I'd be happy if I could just say: function createUser (user:User) {...} vs function createUser (user) {...} In the second case, what is `user`? Probably an object. Does it have an `id`? I don't know. Maybe a `name` or `fullName`? How can I know for sure I will always get an `id`? I don't know.
Thank you! Glad you like it. Yes, you can find some perf measurements [here](https://github.com/mbasso/asm-dom/tree/9bbb5ec4cd392e45c9033cab05c78df938c60c54/benchmarks). There are also few important notes that explain the results 
Cool. Seems like it might be possible. Might fire up spring boot and make myself a personal youtube app!
Note: redux-first-router is a redux-centric alternative to react-router, not a replacement for react-router-redux.
So why do you even use the internet? BTW Python has 26 years so in 4 years you won't be able to use it.
Using regular classes is the only thing I miss from React. I love using Vue except for all the boilerplate (`computed`, `methods`, `data`, etc.) which make it quite inelegant IMO. Has anyone experienced any gotchas when using TS with Vue?
Finally I can make my website break for all the filthy, poor peasants who can't afford a mac or an iPhone! Great job, apple! &lt;/sarcrasm&gt;
I can't remember the theme. But I'm using hyper and oh-my-zsh
You could set a `data-img` attribute on the &lt;img&gt; tags with the proper URL, and in `onClick`, replace `element.src` with `element.getAttribute('data-img')`. **Some more advice, maybe a bit judgy:** Ok, so first of all, I'm gonna leave out the advice that people gave for you in /r/HTML, but it's also really good, so follow that too. You probably shouldn't use anything from W3Schools, they aren't exactly a good source for up-to-date and proper web-development information. Like, seriously, when I was first learning to develop websites, switching away from W3Schools and towards other sources like [MDN](https://developer.mozilla.org/en-US/) and [CSS-Tricks](https://developer.mozilla.org/en-US/) was what really helped me get started making quality code. All W3Schools does is teach people how to copy-and-paste poorly explained, messy, outdated garbage. Your HTML and JS is a bit messy and weirdly indented (seriously, where is that "}//&gt;&gt;" even *coming* from?) And there shouldn't be "&lt;script&gt;" tags in the JavaScript panel (it's supposed to match the contents of a `.js` file which is included into the page), nor should there be "&lt;body&gt;" tags in the HTML panel. Using `onClick` from HTML is a poor practice and you should probably set the onClick events from JS instead. Same with inline styling - *use your CSS file!* Don't use the `style=""`! Why are you even using it when you have a CSS file *right there*? Consider doing a bit more cross-browser testing - this interactivity you claim works doesn't work at all in Chrome for me.
My apologies if I wasn't clear on this. I also had "old frameworks" and "crappy code" on the list - my point being, even with doing what's considered bad practices in the industry, you can deliver good projects. Case in point: Try asking developers of your favourite games how many unit tests do they have / what's the code coverage.
They are useful for different things. I always feel all those people complaining about javascript do so because they try to write programs the same way they do with other languages. In the second case, I could be writing a method that does different things depending on what was received. I could parse have parsed a JSON directly from the database and work with it without having to instantiate an User object. Of course, you could also have accidentally overwritten that variable earlier with a string and things would go bad, put personally, I haven't had that kind of problem in years. Of course, I'm not saying my code doesn't have errors. But I've learned to build code that quickly exposes errors, and almost everytime a bug/problem makes it to production, it's because I incorrectly judged the use case and wrote a code that isn't the right one for that use case, not because my code is behaving differently than what I wrote it for. I also make extensive use of TDD. The thing is, JS never tries to prevent you from writing bad code. But if you learn how to write good code, it rewards you with flexibility. 
Thank you, I didn't know about tsc init and webpack-cli init, I will keep them in mind when the time comes to bootstrap a new test project. I think I agree with you on this. I do think the things Webpack does are super complex and super useful to hundreds of thousands of developers, no doubt. I do like swimming against the current, though, so I wanted to see what's the most tool-free experience you can do while still developing for Angular (or other modern framework). And I'm glad I tried it. (Also, for haters: please note I've started my webpack-less project months ago. I didn't come here to complain as the _first_ thing.) I'm also glad you shared your experience - this is why I started the thread. :)
Seriously, try Vue. It's lightning fast, you can use it as simple HTML + JS + CSS file. You can have Angularish templates (from your existing "visible" HTML DOM, or safely tucked inside &lt;template&gt; / &lt;script type="x-template"&gt; tags), with React-ish components, Redux-ish state management (Vuex) and probably faster (on rendering) than all of the mentioned. Oh and it's smaller than React, let alone Angular.
&gt;BTW Python has 26 years so in 4 years you won't be able to use it. What are you even talking about, go home.
And when you read something like this : https://www.mappingthejourney.com/single-post/2017/08/31/Episode-8-Interview-with-Ryan-Dahl-Creator-of-Nodejs It's not really encouraging. But js is indeed eating the world.
Of those you listed, I agree with all of them except for the last one. I'd never use transpilation or fixed type linting because I use the lack of types in my favor all the time. 
Yeah, I've been eyeing Vue for a while now. Thanks! I guess I'll have to give myself a challenge to develop a mini-project in it in a week and see how it goes.
- React - Angular - Vue The react fiasco isn't as major as other redditors are making it out to be.
I'm not a fan of C++, but I'm looking forward to the day other languages can be compiled to WebAssembly as well. so I can write my web applications with something other than JavaScript. There's an alpha port of Rust for WebAssembly that already works quite well, that's a great start. However, I wouldn't want to develop a large UI-heavy application in Rust, that's not what it's designed for. Maybe Swift can be achieved at some point… There's slow progress towards that goal.
Yeah, it's not that the ASF is "refusing to recognize the FB license as valid open-source", it's that they're saying they don't want to allow use of that license for official ASF-owned projects. There's a particularly good summary of the recent ASF situation at http://writing.jan.io/2017/08/19/understanding-the-facebook-vs-asf-license-kerfuffle.html . 
Isn't the watch tag unrealiable though ? I find myself having videos marked as watched while I just watched the first seconds of it
I'm not sure, I have no experience with swift, but I think that you can use [emscripten](http://kripken.github.io/emscripten-site/), it works with llvm IR. You have to understand if you can call asm-dom from swift, maybe creating a binding layer.
The problem was that emscripten doesn't support dynamic linking, and swift only worked with that. I believe that this was fixed a few months ago, but I'm unable to find anybody who has tried again to get it working since then.
This is why I commented because the article authors are being extremely disingenuous and do not present **existing** alternatives. My library hamsters.js you can do exactly that and simply take a function and run it on another thread or multiple threads. My library is not the only one in existence there are others as well like multithread.js and parallel.js and parallel es and im sure even more I am unaware of. Changing how the language works under the hood is not what I would consider a proper approach given that you can already run your logic not only concurrently across many threads but execute loops and other logic across multiple threads for parallel execution using existing tools that are (in my library at least) compatible with browsers all the way back to IE9.
I see... This is certainly an interesting field to study, I should read up on it.
There are discussions about immutable objects and basic unicode support is already baked into ES6. Discussion over compile-time types has been shelved, but mostly because there is disagreement about which type system is the best. Runtime coersion isn't really an issue. Coersion into strings is generally not an issue (it's fairly nice most of the time). Coersion into numbers is pretty hard and almost universally indicates a bigger problem. The current BigInt proposal will not allow coersion. More importantly, with the use of proper tests and triple-equals, you won't ever have coersion issues.
The watched tag is only there if you have watched it close to 100%. I combine with the thumbnail that shows precentage watched. IsWatched || thumbnailOverlayResumePlaybackRenderer.percentDurationWatched &gt; 70
I'll just leave this here. &gt; if you're building a server, I can't imagine using anything other than Go
Why does this look like `rxjs`? Is this something to do with `monadic types`? I noticed that [Flutures](https://github.com/fluture-js/Fluture) looked very `rxjs` like as well. I'm sure this is not a coincidence. 
Just get good at Javascript. It won't kill you.
I *am* good at JavaScript, but it's not the right language for large-scale web application development in teams. For example, there's no way to define an interface an implementation has to conform to, it's not clear from function declarations what types their parameters are supposed to be, and it's not possible to dynamically load code without bad hacks like eval (making debugging very hard, killing a lot of optimizations and being a security nightmare) or inserting a script tag into the DOM (which is outside the language itself).
Do you recommend going through this series of articles without actually beginning React yet? Thanks.
A very good post. Here's the actual link: http://nirajmchauhan.tumblr.com/post/164774045516/how-to-write-clean-code
Yes, everything you just said is true. But after many many years of fighting for unified browsers we are demanding yet another addition that is arguably unnecesary, as most javascript pages run just fine.
That's like saying we dont need c, python, rust, etc. Because java works just fine.
TL;DR - React-Move 2.0 is a merge of Steve Hall's Resonance library into React-Move. - Mind boggling performance - Amazing stability - A simple and even more powerful API - Delays, staggers, and complex transition groups - Multi-step Transitions - Animation lifecycle hooks Example Here: https://codesandbox.io/s/j4mv3lvj6v?from-embed
No, if you aren't at least comfortable with the basics of React and Redux, learn those first. These two posts are more about some of the key concepts for using React and Redux together in a real app.
Why? Can't see that many things being affected by it
drboolean's FP JS book does a nice job of explaining the IO type https://drboolean.gitbooks.io/mostly-adequate-guide/ch8.html#old-mcdonald-had-effects For people after something with a bit less surface area, check out https://github.com/ramda/ramda-fantasy/blob/master/docs/IO.md or https://github.com/fantasyland/fantasy-io
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ramda/ramda-fantasy/.../**IO.md** (master → 38778ba)](https://github.com/ramda/ramda-fantasy/blob/38778ba0861f65c0e74eea2ea802d595ece798b2/docs/IO.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dme00ug.)^.
inb4 writing desktop apps in C# compiled to webassembly in electron
&gt; My library hamsters.js you can do exactly that and simply take a function and run it on another thread or multiple threads. Via toString + some flavor of eval, I take it. By the way, the mouse wheel is broken on hamsters.io (Chromium 60).
The article is pretty good and the use of TS is clever. I'm just flabbergasted that a simple +/- operation is being turned into a hundreds of lines of boilerplate code, compiler deps, etc. I know, I know, easier to reason about. Still, on some level we should be able to do better.
Indeed, it is due to all three types (Observables from Rx, Futures from Fluture, IO from Funfix) having properties of what in FP world is called a monad and a functor. Practically, it means that all three implement `.map`, `.flatMap` (aka `.chain`), and `.of` methods, which you probably use a lot while using these libraries. If you want to learn more, you can search for "typeclasses" and you should find several good resources about them. If you want something that uses JS, I recommend Tom Harding's series of [blog posts about Fantasy Land spec](http://www.tomharding.me/2017/03/03/fantas-eel-and-specification/).
&gt; For example, there's no way to define an interface an implementation has to conform to, it's not clear from function declarations what types their parameters are supposed to be Maybe try [TypeScript](https://www.typescriptlang.org/docs/handbook/interfaces.html)? &gt; it's not possible to dynamically load code without bad hacks like eval `eval` isn't really a hack, it's just the JS compiler exposed at run time as a function. Not sure why it would kill optimization since the compiler shouldn't care whether a function was created from a source file or an `eval` call, and any dynamic code loading will be a security nightmare, period. Definitely doesn't make the stack traces any easier to read though, and forget about breakpoints. **EDIT:** Just for fun, I [made a little benchmark](https://jsperf.com/function-vs-eval-asdasdasdasd/1) to test a function made from `eval` vs. a regular function. There is no speed difference in my browser.
Typescript and ES6 modules address most of that. Hard for me to see why using an alternative with much less community support is advantageous, given you can write the whole damn stack in JS nowadays.
The article wasn't about how to *use* concurrency to build something like task runners, it was about how to *implement* concurrency at the language level so it doesn't require isolated environments for each thread, a totally different topic. 
Nice tooling enhancements. Ho-hum language-wise.
There are other means ive used in the past like simply creating a new worker containing nothing but the logic of a function but that is extremely limited in regards to control over execution and splitting the work across many threads. Its not a trivial task and the use of new function inside a sandboxed thread presents no security concerns and doesn't change the underlying execution of the language it self. The library only uses eval when executing the library inside a thread itself for use with SharedWorkers. (Threads inside threads) Atomic operations are still in their infancy and until they're mainstream there is simply no other way to make use of threads on a functional level. My library does have early support for them but of course I can't complete that until atomic are mainstream sadly. I will take a look at the scroll issue thanks for the heads up. 
Given a [similar observation](https://www.reddit.com/r/javascript/comments/6x5msu/funfix_io_probably_the_best_altpromise_for/dmdvend/) in another comment, I'll answer here for both. You can indeed find both `map` and `flatMap` operations in RxJS as well. This is not a coincidence. For people that are familiar with Haskell's standard library, the `map` operation is the operation described by the `Functor` type class (think OOP interface, with some differences), whereas `flatMap`, along with `pure` are described by the `Monad` type class (flatMap is called "bind" in Haskell, but naming is not important). Some people are scared when hearing the word "monad", but all that means is that the type implements an interface with certain properties you can rely on, very much like `Iterable`. The `Monad` interface is something like this: interface Monad&lt;F&gt; { pure&lt;A&gt;(a: A): F&lt;A&gt; flatMap&lt;A, B&gt;(fa: F&lt;A&gt;, f: (a: A) =&gt; F&lt;B&gt;): F&lt;B&gt; } This looks very much like an `Iterable` interface, but isn't valid TypeScript or Flow syntax btw, because they lack what's called "higher kinded types" (i.e. generic types that have type parameters of their own, so the ability to have a generic `F&lt;A&gt;` like in the above example). So in static languages that don't have "higher kinded types", it's hard to describe `Monad` as an interface, however using a little trick we've learned from a paper on [lightweight higher-kinded polymorphism](https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf), in Funfix I was able to describe it as a type class: 1. here's the [FlatMap](https://github.com/funfix/funfix/blob/v6.0.2/packages/funfix-types/src/monad.ts#L135) type class (describing just `flatMap` without `pure`) 2. here's the [Monad](https://github.com/funfix/funfix/blob/v6.0.2/packages/funfix-types/src/monad.ts#L486) (note that `HK&lt;F, A&gt;` basically means `F&lt;A&gt;`, and `IO&lt;A&gt;` is an example of such an `F&lt;A&gt;`) In your day to day programming, you won't necessarily work directly with these interfaces, unless you start using more advanced FP techniques (like MTL), but they are cool for having around, because you [can have laws](https://github.com/funfix/funfix/blob/v6.0.2/packages/funfix-types/src/monad.ts#L561) described in the actual code, which then serves as a test-compatibility-kit (a TCK) that you can then [use in unit-tests](https://github.com/funfix/funfix/blob/v6.0.2/packages/funfix-types/test/ts/io.test.ts#L49) for checking your implementation. In other words I've got proof that `IO&lt;A&gt;` is a monadic type because the laws and the executed tests say so. I'm mentioning this because the `flatMap` in RxJS is in fact not lawful. This is because for historical reasons Rx's `flatMap` is an alias for `mergeMap` and the problem with `mergeMap` is that it eagerly consumes and subscribes to all observables created by the source, without waiting (sequencing) on the previous observable. Their monadic operation is in fact `concatMap`. They did this because the protocol described by the original Rx.NET is pure push-based, without any back-pressuring semantics, so from a memory-usage standpoint, the operation that's safer to implement is `mergeMap`, as `concatMap` with a pure push-based protocol requires unbounded buffering (well, it can be argued that if you have async boundaries anywhere in your pipeline then `mergeMap` requires unbounded buffering as well, but it's more indirect). Also, I haven't used RxJS much, only played with it once, but note that `flatMap` in most Rx implementations is not memory safe (in "tail" recursions), which means you can't use it to describe recursive loops. This is partly because implementing a memory safe `flatMap` is hard to do, especially coupled with cancellation and the push based protocol, which Rx implementations are doing. This `IO&lt;A&gt;` type has memory safety as a guarantee, plus the implementation is safer because it doesn't have to stream multiple events downstream, only one. Speaking of which, in RxJava 1.x they introduced at some point what they called the `Single` type, which was like an `Observable` that signaled only one event (instead of many), but that's the textbook example of *OOP inheritance gone wrong*, precisely because `Observable`'s implementation is not meant for recursive loops, which you really, really need for `IO` / `Future` / `Promise` implementations. The pure push-based protocol of Rx.NET and the old RxJava was actually my motivation for working on [Monix](https://monix.io/), an Rx-inspired implementation that does back-pressure in its communication and that doesn't do unbounded buffering anywhere, unless the user explicitly specifies that unbounded buffering can be used. Which then gave birth to [Task](https://monix.io/docs/2x/eval/task.html), an implementation inspired by Haskell and Scalaz, that's much, much better than what you get from Rx's `Single`. And now you have it in Funfix, where I've named it `IO`, because it's clearer, since `Task` is also the name of the `Promise`-like type from C# and many C# devs are using TypeScript, so I wanted to avoid confusion, plus `IO` is a better and shorter name anyway :-) Now going back to your observation ... yes, they both have `flatMap`. The name comes from "*map, then flatten*" and it's a very good name IMO because it makes one think of the signature of the operation (once you see it, of course).
See my answer here: https://www.reddit.com/r/javascript/comments/6x5msu/funfix_io_probably_the_best_altpromise_for/dme3xwg/
I understand what the article was hinting at but its not a different topic its a difference in approach to the same problem. Workers are sandboxed for good reason and while the underlying spec is a complete mess by design they present benefits with a proper abstraction layer that you wont find with this approach. Shared state means race conditions and data locks, mutex issues and all the problems multithreading causes in all other languages, there is absolutely no way to simply change all existing transpilers and execution environments to be smart enough to deal with those issues, most developers are not smart enough to deal with those issues and for good reason....if something goes wrong its almost impossible to debug in a reasonable time frame because you dont get nice fancy errors you simply get bad results and have to figure out what went wrong and where. Workers while not ideal provide a ***safe*** way to do multithreading and with abstractions like mine they also provide a way to run things in parallel and concurrently with as many threads and cores you have, the authors are making it seem like atomic operations are a new thing but I personally have been waiting over 2 years for them to gain mainstream support which overnight will simply eliminate all performance bottlenecks of the underlying message passing interface of workers. TL,DR: Making threads and the unavoidable issues they cause a first class part of JavaScript is a bad idea and they should consider existing examples of what they're proposing before making such a drastic change to what was supposed to be a dynamic and interpreted language. I will also add the authors have made quite a few assumptions about performance of adding extra threads that rarely correlate to the real world, I think they will find their goal extremely difficult to make reality and the performance they gain is not going to be as simple as "an extra thread gets things done twice as fast" its just not that simple.
I use TypeScript. It's awesome. &gt; Are there any Node.js frameworks built with TypeScript or Flow that are worth checking out? They don't have to be written in TypeScript, you can just install the type definitions for `express` or whatever you want to use.
Yes, that definitely will happen.
&gt; I'm just flabbergasted that a simple +/- operation is being turned into a hundreds of lines of boilerplate code Redux is designed to help you scale better, so you pay this upfront cost to make that better. The author even [wrote an article on why you might not need it](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367). Also I'm not entirely sold on the "action builders" pattern with TypeScript. Just pass an object to the `dispatch` function, the TS compiler is already checking to make sure the object has what it needs to have, and positional arguments are harder to understand anyway.
If you're going to use a compiler, you might just as well use something that compiles to a more low-level representation (WebAssembly) that call be better optimized by the browser.
&gt; we should be able to do better yes we can. Try MobX and let me know what you think.
Really? So you make a user object `{id: 3, name: "Bob"}` Then later you write `user.namw = "Frank"`... and this is to your advantage?
"If you're using a compiler, you might aswell write your app in C, because then your CRUD app will run so fastly"
You're implying that TypeScript is the best programming language you could have for writing a web app. This is something I don't agree with. It's a good quick fix for the most glaring issues with JavaScript, but in the end, it's only lipstick on a pig.
yeah I don't get it either, it's the javascript subreddit also.
Appreciate the snarky response. Why don't you go back to some non-JavaScript sub-reddit and vent there. There's no shortage of soapboxes for you to get on about JS.
I think the problem with any loop, no matter how simple, is that you have to stop and concentrate to understand what it's doing. It is inherently imperative so you have to keep track of two or three variables while working through it. With good use of `map` and friends you can make code much more declarative so a maintainer can understand it at a glance. Compare the following to your first example... const doesShipExplode = (ship, obstacles) =&gt; obstacles.some(ship.overlaps) As you say, a lot of these methods are just syntactic sugar over loops, but that's fine. The big downside of loops is the syntax. Any time you store state in an external variable (such as an iteration counter) you're making bugs more likely - it has the same problems as storing state in globals but on a smaller scale.
My boss is mainly concerned with React since I work for a very large company and he's not comfortable building the foundation of an app on something that's seeing a lot of backlash from the programming community. Again, I know this doesn't likely matter for smaller projects, but in my scenario, it's a valid concern.
how about CPX?
No, I'm implying that just because someone uses a little bit of tooling it doesn't mean they have to divorce themselves from javascript. Furthermore, I'm also implying that the speedup from wasm may not be important in most day to day applications and that it might not even be that much faster than fully optimized js. 
cool, sounds good
I think we may be addressing two different instances of where mathematics is useful or not. I think it's useful, and required in some aspects, for designing languages. However, I think mathematics is [now] significantly less useful and important to those writing software. There are many cases you needn't consider math at all. So looping back to Fluture, it seems to take all the progress we've made in abstraction, and turns it into a direct abstraction of mathematics itself. This increases both the learning curve (if you're used to ALGOL-like languages, or not familiar with FP), and the knowledge required to get started; you have to be fairly decent with the mathematical concepts the language uses to be successful.
Nope, that's the caveat. Javascript is a code that's easier to screw up, it doesn't prevent you from messing up, but trades protection for flexibility. I imagine that's a horrible trade off for company environments, where one person can screw up other people's work. For me though, having worked on relatively big projects with a single partner (who is my SO and has worked with me for years, so we have a good amount of sinergy), I feel like this is an advantage. We developed a workflow and coding style that works for us. I usually suffer much more with conceptual mistakes (bad modelling/planning) than with sintax and logic errors. Now to answer your question, what is to my advantage about lackying types is that I don't need to rewrite the entire Entity Model. I write it once on the database, grab it and parse it as JSON, and manipulate data freely. No need to build a DAO (data abstraction object) layer with a class for each entity, that always drove me mad when I worked with Java. 
Depends. Maybe I *want* to add a one-off `namw` property on a specific object, or set of objects. Yes, being able to free-form objects is a wonderful feature, one which most other languages work terribly hard to prevent and many people refuse to embrace. But if you meant it as a spelling error; if that makes it into production then you have far greater problems, none of which are JavaScript's fault.
Context is important. &gt; But if you're building a massively distributed DNS server, I would not choose Node.
Yes! So glad to see more people who fully appreciate the power of JS lol
[Vue is still relatively small](http://www.npmtrends.com/react-vs-vue) and can't tap into reacts eco system. The other downside is that it leans in an older direction, similar to Angular: arbitrary constructs, scopeless templates, dependency injection. It won't replace React with that foundation. It can take in jsx but still doesn't benefit much from it as it's cut off the vein that serves innovation in the component eco system. If your goal is sticking to react-like technology stacks without regression then Preact would make a lot of sense. It is 100% compatible by compat layer and even without it can cope. Also tiny (under 3kb) and benchmarks like it.
Next project should be to do it in assembler ;)
Calling setInterval() "evil" just because it does not fit the author's use case is a bit ludicrous. Also, this seems to be quite an old article (from 2013).
Take a look at Preact, a drop-in replacement for React with a no-nonsense license. If you like the benefits of React, but are afraid of the patent stuff, this might be a sensible way to go. Vue.js is nice too, of course.
It would be great!
It's mostly just JavaScript language wise, right?
I think you could take a look at Ember.js. Ember has been very stable and doing some very interesting stuff with Glimmer VM (the rendering engine of ember). The ember project is also doing some experimentation with [Glimmer.js](https://glimmerjs.com/) as a new model to write components in ember and as a way to use glimmer components standalone. 
Yes, but don't forget this: &gt; that's basically the reason why I left Node. It was the realization that: oh, actually, this is not the best server side system ever.
Redux definitely does ask you to add some amount of indirection to your code. However, you can add as much or as little abstraction on top of that as you want. It's also worth noting that the TS-specific stuff in that post, particularly the "ActionBuilder", is in no way required by Redux, and appears that it's being added solely so the author can get a lot of extra type-checking and autocompletion.
So...did you just post this so you can make some petty backhanded comment?
The abstraction is interesting but I wonder how useful it is over using rxjs directly. One of the selling points of rxjs is that given an input stream as an observable I'm free to add any further operators I want to the source before finally subscribing for output. You have an explicit pass through output that just seems like a wrapper around subscribe without the usual functional approach that makes rxjs flexible. I can understand a desire to have a better syntax than rxjs but I'm not really seeing a reason to use your library yet. Are more features coming that would convince me otherwise?
No major enhancements to the type system or anything I mean.
The issue with mobx is that it bring in the overhead of a single state store without any of the Middleware opportunities of redux. In no way do I think redux is the be all end all of state management but it provides clear benefits to me for debugging, granular control, and more clear separation between view and model. I haven't seen any of that from mobx. All mobx seems to do is save state and allow me to easily share it across the application. There's nothing inherently wrong with that especially in smaller applications. But personally when I use redux it's for the whole package. Not just for the sharing of state.
TBH, it's just C++ being more verbose than JavaScript. I bet you could "rewrite" it to plain JS (and Hyperscript) in like 5 to 10 minutes and vice-versa.
how is this petty or backhanded? it's noteworthy that the creator of node wouldn't use node [and that isn't even necessarily a knock on node, his choice might not be right for everyone]
lol people reading this getting up in arms - let me preface this with the fact that i love node, i write JS in node every day - ryan dahl is clearly a brilliant programmer - if you're talented enough and you have the freedom to do so (e.g. you work alone, you can make the call at your organization) - there are likely better solutions than node from a strictly code standpoint - however, this is *very* rarely the case - real world time/money concerns come into play, and the value of using one language for your FE and BE is *huge* - however, ryan dahl isn't operating on that level - he is thinking on a CS level, and on that theoretical plane, node probably isn't the best server language
Ahh, yeah, you are correct!
You say that like it's difficult to do in a safely typed manner. Here's some type-safe Typescript that looks surprisingly, exactly like Javascript: const specialUser = {...user, namw: "Whatever"} It's a bit odd for you to say you're okay with that one-off ticking timebomb hack, but then claim you'll spend the time to write the test coverage for it.
Yes please. Have spent the week writing jsx + jstl and I am really starting to hate java types and standard libraries. How many types of list does a language really need by default!?
Maybe, but I doubt it. Go is a pragmatic language not an academic one, and considering it has reached [the top 10 TIOBE index](https://www.infoworld.com/article/3208904/application-development/go-language-soars-to-new-heights-in-popularity.html) in just a couple of years means it is being used outside of CS academia in real world projects.
Fuck I feel dumb, no idea what I'm looking at. How am I gonna get a job in this field?
An interview with the creator of Node is relevant content for /r/javascript. Also, I was surprised to read his disdain for Node, and I thought that might be of interest for the JS community.
Personally, if I need more performance than js can deliver, my next resort is c. Modern c has features like closures and type inference, and is the fastest programming language around. And you can still employ an event loop. Why take a half measure with go, which doesnt do async style programming at all, only concurrent. I just don't see its value proposition. 
I'm no fan of crappy, inflexible type systems like Java has. But I find it immensely useful to have types for DB or other data. For example, it was fully worth the 30 minutes or whatever to write up [these types](https://github.com/spacejack/freddy/blob/master/src/ts/types/reddit.d.ts) *once*, so that I hardly needed to think about all of those deeply nested properties in the many, places they were [actutally used](https://github.com/spacejack/freddy/blob/master/src/ts/freddy/feed/item.ts).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [spacejack/freddy/.../**reddit.d.ts** (master → da54662)](https://github.com/spacejack/freddy/blob/da54662b25702c57b0df03d696780bdabe0f7be7/src/ts/types/reddit.d.ts) * [spacejack/freddy/.../**item.ts** (master → da54662)](https://github.com/spacejack/freddy/blob/da54662b25702c57b0df03d696780bdabe0f7be7/src/ts/freddy/feed/item.ts) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmeie1d.)^.
So much negativity... With webassembly this is the feature set I've been waiting for. 
I recently posted my concerns about this in /r/typescript. https://www.reddit.com/r/typescript/comments/6wb5za/advise_on_maintainable_typed_redux_async_actions/ tldr; I've spent a week just stuffing around with types for redux actions to get something I am ok with. I question whether typescript is the answer because due to the unavoidable boilerplate needed to create async actions which many blogs don't deal with. The minor annoyances typing redux actions using discriminated unions or other type narrowing mechanisms such as type guards is the unavoidable boilerplate. Its fine with simple synchronous actions but when it comes to async there is always 3 to 4 actions to dispatch REQUEST, SUCCESS, FAILURE which require you to - Create an enum string literal for each type - Create the action creator type interface - Create the concrete action creator method. Of course there are a couple of libraries that try simplify this but are full of complexity and proprietary abstractions which didn't really appeal to me. The choices some of these libraries make flow into your domain code such as the inability to use switch statements in reducers in exchange for some custom builder pattern. Additionally you need to be careful how you create the type definitions so its easy for you to reuse the created type definitions in redux sagas too. At the end of the day I always think I should be writing this in es6, create a few tests and be done with it. Currently I am experimenting with creating a namespace for each async action that atleast provides some structure to the boilerplate which seems to be going ok. 
 emscripten::val::global("console").call&lt;void&gt;("log", emscripten::val("Kill me"));
Thanks. This is awesome
The `data` event callback for `process.stdin.on` reads all the input from stdin and concatenates it to the string in the variable `stdin`. The `end` event callback then splits the value on new line characters, such that in your loop `lines[i]` is referring to a string. typeof lines[i]; // --&gt; "string" When you try to square that, then JS attempts to cast that value to a number to complete the calculation, and the result will be a number. var squared = lines[i] * lines[i]; typeof squared; // --&gt; "number" The `process.stdout.write` function requires a string or buffer, so you need to convert that result back to a string for output. var result = squared + "\n"; typeof result; // --&gt; "string" This will cast result back to a string, and then you can print that line using `process.stdout.write()`. 
My response is the same a when 1.0 came out. Meh, I know how to write JavaScript. 
Thank you for your feedback!! Sorry for the typo... I picked the boilerplate because I already have the backend setup using some of its framework but I can definitely see why you guys recommend using the official tool. I did run into problem when I was trying to dispatch actions in batch. I was trying to render twenty chart components in one smart container. Each requires its own data from the server, leading to excessive render. The app ended up lagging when scrolling down. This prompted me to read into Redux performance. Overall, I find the documentation very comprehensive. I started with the basics and slowly worked my way to higher order reducers. There were trials and errors, but the documentation helped a lot. Thank you guys for the great work!
With TS do you still need to make your code a .ts file or can it work like Facebook flow where it just processes your regular files with the ":boolean" , for example, notations 
I tried learning Ember and it got so confusing with the way it bubbles events up and whatnot. I think the complexity of its very unique design structure coupled with the fact that it's not as widely used as React and Angular is why I gave up after about 2 weeks. 
Would Preact have a patent issue with Facebook/React since it's basically a copy of it or did they just name it similar yet they don't share the same core code? I'm just afraid to jump into it and then find out later that they were already violating some loophole with the framework by default.
You're welcome! We do still need to get an official "Optimization" recipe added to the docs, but that hasn't happened yet. Glad to hear that the docs were helpful!
I kinda get what you're saying, but I think his perspective isn't really theoretical, it's more like a perspective of someone who's implemented a server system and is comparing against competing systems. He mentions async/await as something that works well for js but that he likes the Go paradigm. I totally get that, but personally, I like having the ability to drop down to Promise.all and things like that. To each their own I guess. When he says "node is not the best thing ever", he doesn't mean that anything in particular is. For example, businesses losing money due to GC pauses are a real thing in fintech, but that doesn't mean everyone in the world should be using pauseless GC Azul systems. I think his points are valid, but I also agree with you that Node *can* be the right tool for the job, for example for universal apps.
I think there's a lot of knowledge and experience in the the committee. How do you personally or the committee in general handle situations where what you think is true and correct and good differs from what the wider community thinks is true and correct and good? Also, is there any interest in a [grill the committee](https://www.youtube.com/watch?v=CPgxw1EzC54) type session once a year at conferences? It may be useful to get more conversation flowing between the committee and the community. 
"promising".... I see what you did there.
This is pretty cool, but it's also the stuff of nightmares.
tried out react-move a few weeks ago and really liked it (I made that PR for exporting the Appear component). We decided to keep using react-motion as we have a lot of experience with it. Post 2.0 though we definitely will be adding this into our app. Great job, I'll definitely be on the lookout for any ways to contribute.
It will need some tweaking for your needs, but this should at least get you going in the right direction ([map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)). var months = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ]; dates = dates.map(function (row) { var monthIndex = new Date(row.date).getMonth(); var day = new Date(row.date).getDate(); row.month = months[monthIndex]; row.day = day; return row; }); 
I should have been more clear that the realtime pages are separate to the business forms. But thanks, that looks helpful
It does work with .js files.
One
Node JS is the future as they say. Promises have made life easy for me especially. 
Yes, creating large-scale web applications with large teams using memory unsafe languages is a GREAT idea. /s
No
Not by choice
No, but back in 2013/2014 I switched a number of backbone apps over to React for their view layer and things worked fine on those projects.
I tried it at one point (2016), but there isn't a big reason to use it these days. Especially these days of React.js, and 100+ other frameworks that do the job better and do it simple. Only people that still use it are legacy devs that are stuck in the past. -- No offense to anyone.
Even if you are shit hot at code discipline, and can negate the advantages of typescript. It doesn't mean your team can. Typescript is terrific at creating maintainable codebases.
Yes, for legacy code.
As a JS newbie what am I missing here? My learning path is going to take me to NodeJS in the near future and I don't want to be That Guy who hops from thing to thing based on one article or Reddit thread, but it just sounds like the NodeJS creator now prefers Go for what he works on but that doesn't necessarily mean NodeJS is bad in some way? (I am also learning Python with an interest in Django if that helps add context to my situation)
Node.js is great for lots of things. If you're building a niche app or have to deal with massive scale, it's probably worth your time to evaluate a broad set of options. That said, for most web applications, Node.js is a fantastic fit.
Is that list publicly accessible?
Great to hear! Let us know how it goes :)
What's the issue with Backbone? 
 // I assume here is where I want to push the dates back into the object, but i'm stuck! dates[x].month = month; dates[x].day = day
I'm not sure there were enough developers to build anything significant that wouldn't have been rewritten by now. It was more of a gateway drug to angular / ember (at the time). Anything I wrote with it had to be rewritten because of how shitty the structure was (it offered no support at a time people were still figuring out js spa's) Marionette had some success which added some structure to the backbone.js api
False. You don't and you don't even know about it. 
It's fine, but a lot of other frameworks do the same thing but better and simpler
I've worked with backbone a lot in it's days of glory. It was too simple to create devastating memory leacks. But I remember loving it's simplicity. Reading the commentend source code was always inspiring.
No, the two are not directly related, though you can use Rx with React (and nearly anything else). Reactive programming is just about finding ways to stream data and events through a pipeline, rather than dealing discreetly with each event, change, or response. You can program your app not in a set of interconnected callback functions and event listeners, but a logical flow from events to actions, which themselves flow into other things. Rx is a library that assists in this mode of thinking (just as functional programming is distinct, but not incompatible with imperitive, declaritive, and object oriented programming). Each type of programming is more or less suited for certain types of problems, with reactive programming being especially good for async code and code with a lot of complex, interconnected, event-based actions (like a server-backed livesearch selector input). There are other reactive libraries, like BaconJS.
Wow, that's a lot of anger! Honestly, the web platform is an evolving and changing beast. Like it or not Frameworks like React and Angular are here to stay. Don't like webpack configuration? Get someone else's, there's plenty of them. Most of these frameworks have init commands, to help reduce the set up time. The thing you have to consider is these frameworks are designed for large scale applications, not simple sites. If I'm testing stuff, create react app is a God send. I think you need to consider where you stand in web development, this won't change.
V-dom is a universal principle. It can't be patented. Preact is not a copy at all, just an implementation of view=fn(state). The same applies to Vue and most frameworks today, they are all based on reacts principles.
How is this any different to using emscripten's built in val object from c++ to manipulate the DOM? Doesn't emscripten's documentation have an example showing the DOM being manipulated through c++ already?
thanks! 
Locked for non-members :(
I use Marionette and therefore Backbone indirectly. I would love to migrate to something more modern, but I don't have the time to rewrite everything at the moment.
Hey man, at least you guys have considered it! There are alternatives (preact is the most popular, literally react but at the top of the file you just need one more letter in your import statement). Something to keep in mind- massive companies (see netflix) use react. If you like the react pattern I'd also suggest [inferno](https://github.com/infernojs/inferno). It's really well built and blazing fast (not that that matters anymore). If you're looking for a suggestion on what to learn- base it on your background. Did you build a strong Java foundation? Definitely go the Angular route, do you prefer a higher level of composition and abstractions? Go with a React alternative. Not sure? Go with vuejs.
asm-dom is a virtual DOM, so you have all the benefits that a virtual DOM can offer. As the repository of [snabbdom](https://github.com/snabbdom/snabbdom) says: "It allows us to express our application's view as a function of its state". I think that build a single-page application using only emscripten::val might be really difficult for a set of reasons: - build an app using manually DOM APIs such as document.createElement, node.appendChild etc is not the best - under the hood asm-dom uses EM_ASM that is the fastest mechanism to call javascript (as the doc says) - a diff algorithm here is really useful, pass a C++ string to javascript is a quite expansive operation, so, avoid unnecessary DOM modification is important - asm-dom uses some interesting mechanisms like DOM recycling and so on that affect the performance - in an application asm-dom will be the only place that touch the DOM, so, if emscripten or WebAssembly releases new and better APIs, we can update only our code
Nonononononono, this is a completely different reasoning for something unrelated. There is a huge difference between existing languages for different uses, BUT browsers had IE for so many years holding them down, and you either had to make separate code for that, or you had to code without all the recent additions. And that sucked balls for as long as I can remember. What I am saying here is that I wish we do not get into the same position again with this. Because it was hell.
You're missing the point. I want to be able to do whatever I want with objects, without the language standing in my way. JavaScript not only allows it, it's a first class feature. So it's normal to want to make use of it. Avoiding it makes zero sense. It's like trying to avoid "import" in Python. Why would I, instead of simply writing user.namw="something", go through the trouble of transpiling, and writing the same thing in an awkward manner which is not correct JavaScript, and is downright confusing, and doesn't even do what I wanted (set the property on user, not specialUser). I don't know why you would find it odd that this would be unit tested. Unless you keep assuming it's some sort of terrible mistake and we're all going to wake up any moment now and cry "omg what have I been doing". JavaScript is what it is. Trying to pretend it's something it's not is futile. * On the server there are a million other languages to choose from, so choosing JavaScript but writing TypeScript makes zero sense. * On the browser the whole point is to have a language engine which is more or less standardized and available everywhere. We have sort of achieved this after decades of struggle. Even if support for more languages comes to browsers, I seriously doubt that people will want to go back to the whole "oh you need X to see this site". One standard language, and like it or not that language is JavaScript. Don't like it? Go complain to Linus that the Linux kernel is not written in C++.
Slightly off topic but take a look at moment.js for date time related coding.
thanks!
you're welcome!
Neat. Thanks 
There is nothing wrong with exploring new things. In fact, you do not have to use them, and if they are weak it is a small chance that they will be adopted.
All good points, definitely didn't think about strings, is there a way to make a C++ API in webasm to modify JavaScript strings directly?
Looks pretty good! I work closely with a motion designer and rely a lot on react-motion which does get limiting and quite difficult for sequencing. But the spring animations are super smooth once they're figured out. One bit of feedback is in your examples page I might avoid any ease-in in your transitions since it generally makes the animation feel sluggish. I know it's just a demo but it's still likely important to make those snappy to get people to adopt the library, it's likely the first thing everyone will look at. Take a look at http://animejs.com for a good list of snappy examples
[removed]
You can define a C++ API that takes a char* (or std::string) but I think that under the hood emscripten put the js string into its memory, translating it in an UTF8 string. After that, if you want to return a new string, I think that emscripten will translate it in a js string using Pointer_Stringify. You can take a look to the APIs defined [here](https://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#conversion-functions-strings-pointers-and-arrays)
Disdain is putting it a bit strongly. You shouldn't put words in his mouth. 
Learn one thing at a time. In the end, it's all the same stuff. What matters is what you make. 
It also hasn't been seriously maintained in a while.
Learning Backbone's core principles is important. You can start by reading Addy Osmani's book: https://addyosmani.com/backbone-fundamentals/ But I wouldn't use it in production, as there are a bunch of new frameworks to play with today.
Congrats on the new job! I've just finished implementing a fairly established web application with Aurelia, so I might be able to offer a few pointers. Overall it's fairly well structured, the APIs are nice and do the job. It follows the typical Microsoft pattern of a monolithic framework that has one way of doing everything. You'll need to follow an intuition of if something's really hard to do in the framework, chances are you're going against the grain and you need to look at the API documentation more closely. The framework comes with a lot of things - Dependency Injection, HTTP clients (fetch and XHR), Animation, and all the other niceties you'd expect from a big MVC framework. The downside to this framework is it's absolutely huge compared to most others, and its build system leaves a lot to be desired. It has a two phase page load, with the initial phase being the framework itself, and the second being all of the resources, component templates and scripts. This is deeply ingrained into the framework, so it makes managing this all very unwieldy. You can either use its magic Webpack plugins to figure it all out for you, or define the exact load order by hand including all required node modules and their dependencies with the Aurelia CLI. In terms of stability, I haven't noticed any issues, however bug reports generally end up with 'PRs welcome'. There's nothing wrong with this as it's open source software, but due to the complexity of the framework I've found it difficult to get to the point of filing one. Aurelia is an imperative MVC framework like Angular, so the same caveats with Angular's approach to application structure also apply to Aurelia. Aurelia makes use of observables and rapid polling for dirty checks on properties to determine when to re-render components, very similar to Angular's digest cycle. Properties aren't considered eligible for dirty checking unless they can be observed, or are annotated with @bindable, so often you'll wonder why nothing's re-rendering when you change data. This is most likely a missing @bindable. Beware of @computedFrom, its purpose is to reduce dirty checking, but it usually prevents dirty checks altogether. Also, direct array access will never result in a re-render, you need to replace the array with a brand new one in order to achieve this. Bindings are painful and the largest cause of bugs in my Aurelia application. The second largest cause of bugs is down to the fact that in templates your bindable properties use snake-case, whereas they are required to use lowerCamelCase in your view model. This is painful, and Aurelia doesn't issue any warnings when this happens. Integrating jQuery plugins is a huge pain, and it's clear this wasn't thought about at all by the Aurelia team. Often you'll want to make sure your jQuery plugin is bound after Aurelia has mounted the component on the page and finished rendering the template, but this is impossible. Aurelia has no lifecycle event for when a render completes. Their official advice is to queue a micro task, which is a fancy setTimeout(), and this often doesn't help because the micro task will evaluate before rendering finishes, leaving you to be forced to poll manually. This last point could just be my inexperience with the framework, but after a lot of searching, I haven't found a solution to this. Hope that helps!
 ... h("span", Data( Attrs { {"style", "font-weight: bold"} } ), std::string("This is bold") ), ... No, `&lt;strong&gt;This is bold&lt;/strong&gt;` and `&lt;b&gt;This is bold&lt;/b&gt;`. You've got examples of setting `Attrs` in there already. Please try to use [semantic markup](https://www.html-5-tutorial.com/strong-and-b-elements.htm). At least you didn't make an `&lt;a&gt;` tag out of `&lt;div&gt;`... Unless that's what you're illustrating here. :/ ...h("div", Data( Callbacks { {"onclick", [](emscripten::val e) -&gt; bool { emscripten::val::global("console").call&lt;void&gt;("log", emscripten::val("another click")); return true; }} } ), ... Kudos for making it all work, but your examples make it seem like you really don't know HTML very well. That's a little concerning since in the end HTML is your real target. The DOM is just a way to get there.
Hello, thank you for the feedback! The intention is to keep this as compatible with rxjs as possible (exposing the pipes and providing optional auto-subscription). You can already create your own in/out streams and plug them in a pipe. mutator-io gives you structure if you need to perform multiple different operations on a single channel (e.g. it's used at the moment to aggregate various MQTT channels into read-friendly "summary" tables). Each of these channels has its own subscription as well as error handling in order to keep the channel always up. I'd like to keep the core as simple as possible and provide a set of ready-to-use in/out streams (e.g. redis, kafka, socket.io as input and postgres, mongo, couchdb, etc as output) in case there are not yet Rx.js versions of them. Just see this as a higher abstraction over Rx.js that should deal with common issues normally seen on reactivex implementation. More features to come but I can't promise anything yet, we just started to use this in prod so it will grow based on real-world use cases (focusing on composability and reliability)
Rust is not memory-unsafe, neither is swift.
Yes! I'm a developer, and I use it - proudly! It's true that managing views using Backbone or Marionette is not something that I'd recommend to anyone I care for these days, but Backbone Models can still be surprisingly handy! Models/Collections provide super easy, structured way to manage and mutate states, and receive all kinds of change notifications in a flexible, easy to use fashion. Backbone is mutable, this means you can "poke" it on real-time in unpredictable ways, triggering specific actions to inspect/debug/feed your application. I use it mainly on the backend (node). A word of advice: Always keep an open eye for innovations, examine new frameworks/libs, but never be afraid to "go against the grain" and follow your professional compass. We're not in a popularity contest - whoever thinks we are often find themselves abandoned with their "15 minutes of fame" rockstar t-shirts hanging off the rack.
I used backbone.js once, ended up writing a layer on top of it, then I learned about the existence of Marionette, but it was too late to use it. Today I would not use backbone.js again. Today I would go something more modern like React.
- too much boilerplate - you have to manually bind all events between models and view - you still need some additional libraries for rendering templates (despite that there are "views" in Backbone - they are just containers for rendering libraries) - when I worked with Backbone (few years ago) I didn't feel that Backbone helped me in significant way in building apps. In contrast when I used AngularJS (then) or when I use React (now) I feel that I have a tool which allows for fast project iterations. Backbone didn't give me such feeling. 
I still use it. My main project was written in it years ago, and .. still is. We did a full v4 in Jan16 and continued using it (and Marionette). 
Do you have any tips on this? Currently starting the same
Great work, very impressive. If you'd like to do same kind of projects like that commercially then contact us: http://314.tt/job-offers.html 
And that will definitely be Hacker News first page material.
I once did a project with a Backbone / React mix. It worked quite well. What I love about backbone is underscore js and key value observers. I also liked how the view layer declared event listeners in a table instead of inline onClick. What backbone sucked at was view composition, React solves this much better. I prefer Backbone over Redux, as I think Backbone solves the traditional OOP concepts quite well, whereas Redux is a poor mans FP. I still prefer FP over OOP if done properly, Redux is just too complicated its own good. Today I use the Cycle JS architecture, it is superior to anything I had my hands on before. Observable everywhere is simply the most amazing foundational abstraction. It is the first framework I have used that senselessly solves upstream and downstream composition. The architecture is fractal, and the computation is lazy, two very important aspects that are everywhere in nature. Also Cycle JS has a beautiful sense of symmetry, I can highly recommend checking it out.
I don't really, but i still use underscore / lodash.
In my last job I used a lot. Currently, I dont use to any framework and I so happy because we aren't always need to use a framework for projects. In my opinion, there are solutions that Backbone is a option in the project. 
We still have a lot if projects at work built with it. No new projects use it though. Personally I love it, it's simple, fast, doesn't rely on jQuery or other pass through layers, easy to learn and it just plain works. I sigh that it's lack of popularity comes down to other new frameworks being "cooler" with no regard for the above or anyone really being able to say "why". Sure I had to manage the DOM myself but guess what, if you understand the DOM that makes this a whole lot freaking faster than any modern framework. Modern frameworks are horrible for enterprise apps, people can't seem to understand that. There's a reason Tour of Heroes most complex feature is a simple web form. 
Great! Thanks for the feedback. We ended up also talking in twitter :)
In three or four years, people will say the same thing about every such thing people say you can't live without today.
Yep, us too. We started with just backbone to add a little bit of interactivity to our "normal" webapp. Then moved to an SPA, but still just backbone. The app got bigger so for more structure we moved to marionette. We added TypeScript recently to get a bit more compiler help, as stuff is getting really large now. But still pretty happy with Backbone&amp;Marionette. Most problems we have come from legacy modules that we just implemented badly (bad structure etc). For new projects, I'd probably switch to something more modern as newer tools have picked up more standardized ways of how to structure stuff in an SPA. But I'm not unsatisfied with Backbone&amp;Marionette at all.
I'm not sure if you can configure the compiler to parse typescript inside a .js file, but it's a silly thing to ask in some ways. The point of a file extension is to give meaning to the content of the file. If you are writing ts then just name the files .ts. Flow and Typescript are very similar from the build chain perspective - they both require a preprocessor. 
Better, maybe, but simpler? It's a lot simpler than most frameworks out there.
I'm not either, I like it. But i redid [my website](http://www.telegauge.com) in VueJS, as an exercise. I really like VueJS. However, it lacks a decent integrated "model" layer*, so why not use Backbone? And if you use Backbone, may as well use Marionette. No matter what you use for a 3-year development arc of your project, whatever you start with will be outmoded by the end of it. (* VueFire i suppose, but we've [written a firebase/mongo clone](https://www.npmjs.com/package/backbone.highway) for Backbone, and that alone sticks us to Marionette for a long time.)
What kind of state are you dealing with? If the state is something that is clearly intended for one view, but there's two controllers in play that both need it, I'd create a higher level component/controller and manage the state there, passing down the state and functions to modify it. If you are using controllers through components, this would mean passing parameters like `statePiece` and `onChangeStatePiece` down to two other components and their controllers. If the piece of state is something you could need in variety of places within the application and/or something you fetch over the network, I'd stick it in a service. Example of the former would be something like a tab selection on a product page that is supposed to change more than one thing, or inputs that cause effects in each other. Example of the latter would be something like user information and preferences. It's good to have it in a service since you may need to access it in many different places and contexts.
Sure, and when WebAsm is widely supported, I'll flip the switch on my toolchain to target it.
Si senior 
The way to go right now is to compile for both asm.js and wasm and decide on the client on what to use. This way, it works on all browsers, and the good ones can optimize the asm.js to be faster, while the great ones can run the wasm code for even more performance.
&gt; There's a reason Tour of Heroes most complex feature is a simple web form. Because it's a simple tutorial?
You and the parent commenter both are making statements without any elaboration. So in some ways, you are both right, because what makes up the statements? Backbone did some good things. All modern frameworks have some level of inspiration they can travel back to backbone. In some ways, backbone was simple, compared to these ultra capable frameworks. I still miss models from backbone. In other ways, such as managing views, it was complicated. I'm glad to not have solve those problems constantly while still having the flexibility I need. 
Payload time is more important than execution time in my case. And most cases, I would suspect.
&gt; NodeJS creator now prefers Go for what he works on but that doesn't necessarily mean NodeJS is bad in some way? yes, node.js is not flawed. IMHO node.js is perfect for variety of usecases. Go is certainly faster at runtime than node.js, but node.js is very good language/runtime for getting something up and running quickly. Node.js has a bright future ahead, don't let Ryan dissuade you from that. Python and Go are also great choices-just don't learn PHP. It's advocates will tell you that it has been mostly fixed in 7.1, but the fact remains that the PHP standard library is pure evil.
Yes, though they shouldn't. I have a friend who is the CEO of a startup, he said about a year ago that they were moving *from* jQuery-only *to* Backbone. I told him I didn't think it was a wise move and that they should use something simpler to develop for and lighterweight. He went with Backbone. Not my choice, but not my call either. He had some good reasons. I just don't know what they were. 
We still have loads of legacy backbone code and I've always been a fan of its conventions and simplicity - particularly the models/collections, but react/redux/react-router does everything it does while also avoiding a whole class of "should I render/re-render" and state-in-the-dom bugs that are the bane of our legacy js codebases. Backbone views are a massive pita to test too, particularly when compared to more modern alternatives.
Sure, but I wouldn't start a complex project with it. It really shines right between "I just need a few lines of JavaScript on a static HTML page" and "I need to build an API driven SPA". Which really comes out to: one or two static pages that need some data from AJAX. Backbone is best thought of as a way of cleaning up old JS spaghetti. It's a simple organizational model around DOM methods and AJAX, and you should reach for a framework with more advanced features if you find yourself really chasing performance, increasing complexity, or working on a large team.
I've been super impressed with this so far.
moving from model change listeners to virtual dom, is like moving from explicit memory management to automatic garbage collection
Use Backbone for its Model and Collections, and inject the data into React components. I believe there is a TodoMVC example that does this 
When I moved to Vue I missed Model and Collection so much I reimplemented them both as Vue plugins. Not every single feature, but all the major ones.
+1 on what /u/Voidsheep said. It mainly depends on what type of the shared data is and where it's shared in the component tree. Ex. 1 Ex.2 --- --- |A| |A| / \ / | \ |B| |C| |B| |C| |D| / | \ &lt;-&gt; |D| |E| |F| | |G| If I want to share data between components in Ex.1 I would think twice if it's worth it to pass bindings from `|A|` to `|G|`. Probably will resort to a service or to a different solution for managing shared state (i.e. Flux with any of it's popular implementations will do the job). If I want to share data between components in Ex.2 it's a no-brainer to use bindings. Side note on the service solution if the situation requires it. There are occasions when a component needs to take a secondary action when the shared data changes. The obvious solution to that is the pub/sub pattern with events on the `$rootScope` which can get really messy sometimes.
&gt; document.cookie = "user=login"; This definitely works, tried it now in console on this reddit page. Problem is probably somewhere else in your setup. What exactly is your setup (domains, dev enviroment etc)? Please, give us more detaily and possible more code with context
I recently discovered Ampersand after looking for something like backbone but without the views and stuff, https://ampersandjs.com
document.getElementById("img01").src = element.src; Where is this element? I couldn't find another reference to "img01" in your code, which means you aren't creating it in either JS or HTML! Also, /u/_tague is right, you shouldn't mix your code all over the place
I really like the way backbone helps to organize code, so I basically rewrote it for ES2015 to be slimmer (mainly to drop jquery), integrate a lot of features found in layoutmanager, add-in data binding as a primary feature and to eliminate a lot of boilerplate.
Nothing at all, it's just no longer cool or "modern", whatever that means.
Well you don't have to, there is a [JS example](https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20js). Presumably there could be a performance benefit if your VDOM lib is wasm.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mbasso/asm-dom/.../**todomvc%20-%20js** (master → e9ce124)](https://github.com/mbasso/asm-dom/tree/e9ce1246247aa84480f23fa39e2fc39995fa9d8c/examples/todomvc%20-%20js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmf9vjy.)^.
Our legacy framework still includes it. So yes.
Many developers prefer to use what they know well, rather than struggle with learning something new. Also, there is still a ton of backbone code in production that has to be supported. It's very difficult to find time to re-engineer existing code, especially when it works and is well-tested as is.
It is used in Open edX although they are moving to React nowadays.
&gt;Typescript is terrific at creating maintainable codebases. TypeScript helps without a doubt, and I **love** it. But I'm at a newer job that has used TypeScript since 1.0, and I can safely say the code they have used is incredibly unmaintainable. Everything takes 3x-4x longer than I'm used to. It's only because of TS that it doesn't take longer (they used types in some places, along with the types inferred). All the things that are important in having a maintainable code base is also needed in TS (or any language really). TS can't fix bad programmers, unfortunately. In a way, it's kind of made things worst in my case. Lack of understanding namespaces vs modules, what spaghetti code is, and usage of private, public, protected, or abstract. Oh and an a completely unneeded (and incredibly long) inheritance chain. They even disabled TSLint because "it kept them from being able to write code well". Digging deeper, I found eventually they just turned off all of rules in TS. It's almost like they wanted to say they used TS, but really wanted to just use JS and didn't know about Babel.
Check out the announcement. It talks about the ts-check item and how to is it. 
This is precisely what I was looking for. Thanks!
Perhaps I misunderstood your intent. It's the feeling I got from reading your comment. Sorry!
Try this. var dates = [ {date: "6/12/17", uid: "12345", id: "12345"}, {date: "6/13/17", uid: "12345", id: "12345"}, {date: "6/14/17", uid: "12345", id: "12345"}, {date: "9/15/17", uid: "12345", id: "12345"}, {date: "8/16/17", uid: "12345", id: "12345"}, {date: "7/17/17", uid: "12345", id: "12345"} ]; for(x = 0; x &lt; dates.length; x++) { var newDate = dates[x].date; var splt = newDate.split("/") var month = splt[0]; var day = splt[1]; var year = splt[2]; month = Date.longMonths[month - 1]; switch (day.charAt(day.length - 1)) { case "1": day = "1st"; break; case "2": day = "2nd"; break; case "3": day = "3rd"; break; default: day = day + "th"; } dates[x].date = month + " " + day + " 20" + year; } console.log(JSON.stringify(dates)); 
Certainly a helpful library but manipulating the date in this project is very small part of it. I am basically just trying to display the date on a card like "August 16" instead of 8/16/17.
I work on a ~150K LOC app written primarily using Backbone and Marionette. The project was started about five years ago and I inherited it. The Backbone part isn't so bad. It's a small, understandable library that gives you persistence, events, and predictable tools for interacting with a RESTful backend. Marionette requires a lot of developer discipline to keep from going off the rails. If you stick with it, it's not the worst thing ever, but I would never start a new project using it. Currently working on switching our views over to Vue.js.
You basically use the backbone models as your state and you serve react views with the controllers
Not that in depth an analysis, but this is actually pretty spot on with its conclusions.
Yes. We have five or six web UI projects, and they are all built with vanilla Backbone. We started back when RequireJS was the defacto solution to the 'import' problem. Backbone's models and collections are intuitive and incredibly easy. Backbone Views can get a little hairy, but it's not that different from any other view library. You have a class, that represents a template, and reacts to user events. Since everything works fine, there is zero business need to move over to anything else. That said, I am porting one of the UIs to VueJS on my spare time. I'm doing this not to port our existing UIs over (don't fix what's not broken) but to justify using it for future UI projects. I can have a 1 to 1 comparison. There is a lot to like about Vue over Backbone, but there is also a good amount of stuff to dislike. That said, Backbone models/collections still kick ass. 
We have 1 legacy application written in Backbone, but it's a hot mess. Everything Backbone is living in a single, 10k+ line `app.js`. We are actively looking to rewrite the application using AngularJS or Vue.
Thank you for your response, this is a great answer. I think it may be a bit over my head though. Is the dates.map() working sort of like a forEach loop? Also, it seems like this is creating a new array of objects rather than pushing to my current one. This is probably a much better route to go but I'm afraid I don't understand it as well as I should.
Thank you for your response! The .map() method seems like it's probably the more advanced route to take to get my solution. 
I have but one upvote to give.
Too many patterns devoted to hiding the true behavior of JS.
lol your last line there is such a strong no-hire signal you sound *exceptionally* junior saying that. backbone has pros and cons just like any other framework/library.
Looks like you got the template literal revision right, but you're way off on the others, so much so that its not quite clear if you've read the proposals or not ;)
Yes, and I suggest it for my project. I know it goes against the grain here BUT most of the developers I work with are Java Struts/Spring developers first. For a very long time I was the only javascript-competent developer so we organized all of our tasks as full vertical slices. The same developer would write the front end and server logic. That means things like classes, pub/sub events, and an almost-MVC breakdown made sense and was familiar enough to them so that they only called me over to help twice a day instead of having me do all of the front end. We use it for those parts of our system that are more or less single-page apps and for the more complex front-end widgets. For the widgets, I design them to be as easy to interface with for the other devs. That being said, I've added plenty of my own framework on top of it with a better templating engine, Marionette-like page-level events, automatic element/property binding, etc. and that is what we actually use. Also, for any actual use of backbone, I was in charge of the design and oversaw implementation so we were able to stay relatively organized. Now that I have some JS friends on the team we are working on modernizing builds and such but still sticking with Backbone for most things. edit: just to add: I really like backbone for smaller, highly collaborative teams. If you're on a bigger team or more geographically spread out, it's not the best decision. My team right now normally works in one room where we can talk to each other and share. However, I've worked with another group who was spread out and they chose React. They had plenty of problems with getting React to do what they wanted but nobody was able to break anybody else's work - which I see as the biggest downside to my extension of backbone.
not to offence to anybody but it's a bit difficult to get excited about frameworks based on logic in HTML, we have already been down that road already
It can be true. What was interpreted wrong in the article?
True, I personally can't say I see anyone we're I live using it. It pretty much turned into Perl and slowly vanished from the job market is were I was going at. Maybe different for others.
Here are a couple reasons why Backbone is outdated. 1) No way of managing Parent / Child view relationship. Look at trying to build a table with a bunch of rows in Backbone. A dev has to loop over the collection create a bunch of child views and then figure out a way to manage interaction between everything. This lead to a bunch of other frameworks building on top of Backbone to fill this gap. 2) Adhoc ways of dealing with state management. When a model is passed to a view if something changes, only way to react to it is using the event model. That means the developer has to deal with rerendering the view, cleaning up callbacks to avoid ghost events, Dealing with visual state (DOM) vs. JS state and keeping it in sync. 3) Becomes hard to debug with large teams. No way of debugging what the "options" parameter is without executing the app and having to print out options to the console. It becomes apparent when a team has like 20 models and a view can have any of them passed in. This becomes easier to deal with something like TypeScript but the typings file is TERRIBLE. Backbone doesn't support es6 and the typings do not have proper support for Backbone.extend({ .. }) syntax. 
One nice thing about Backbone &amp; Marionette is that they are very light weight and as a developer, you can understand the source code. Since there is less there, I think it might be a good fit for some smaller apps. There is not a lot of prescribed structure, so like react, done poorly you can really hang yourself. If you are asking from the point of view of whether it is a fine technical choice, possibly. If you are asking from the point of view of marketability as a developer, probably less so. If you want an easy on ramp to build a single page app as a learning experience, it could be a good fit (remember though: http://wiki.c2.com/?PlanToThrowOneAway).
I think their JSFiddle was quickly copied and pasted without testing from their actual source file, which explains the missing bits and pieces.
&gt; With Typescript things that were really easy to do on Javascript like defining a simple object were more complicated to do on Typescript. You can use literally the same code with either language. const obj = { foo: 'bar' } That will work in TS or JS.
Very important. If you're building some massive "realtime" hugely concurrent backend, then yeah node isn't that great. If you're building a thin REST api over your db for your mildly popular SPA, then node seems to be a fine choice. 
Thank you! Really very helpful. I appreciate it
First off, if you're thinking about ways to break the internet, this is a good way to start: // always-global variables const a = 1; function someFunction() { const a = 2; // throws error – identifier 'a' has already been declared } In no way should your local variables have to be concerned with what's in global - unless you intend to use a similarly named global variable without qualification. Why you might want to do that is because you're not sure _how_ global is qualified in your environment. In browsers its `window`, in node, there's a `global`. That's annoying; why can't `global` be the term that's used everywhere? _That's_ what the global proposal is all about. That's it. Just make global consistently named `global`. The dotall spec relates to regular expressions, not anything specific to the JavaScript syntax. Dot operator (`.`) rules there haven't changed. I mean, looking at: console.log."hi". . Can you really tell what's going on here? Is "hi" being accessed as a property? Or being passed in as a function? And what are the dots after that? This one really made me think this article was a joke, but given that the template literal revision explanation wasn't funny, I thought maybe it wasn't meant to be after all :) What dotall does for regular expressions is allow you to specify how periods/dots (`.`) are treated in regular expressions. Do they match newlines? Or not? Does it _truly_ match _all the things!_ or just, you know, like, kinda, all of most of the things?
That's great advice! Thanks for the tip.
Funny how cutting edge becomes legacy in 4 years.
"legacy"! If 4 years is legacy, what is the label for Prototype?
I, on the other hand, deal with serious peril every day!
That's actually pretty cool! I guess people are downvoting because of the lockout on the post, or the weird and ugly way the example handles the event listeners.
Well, in silicon valley a lot of places are still using it. Just depends on your use case. Of course, most places are porting to other frameworks but thats not *necessarily* a reflection of its qualities or merits because JS devs are often fickle and will port an entire codebase just to play with new toys.
Preact seems the way to go. So it's essentially React but not licensed by Facebook? Can you still use the same ecosystem and packages that typically go with React projects? 
Excellent overview. I agree with all the points you made. As for your issues with jQuery plugins, have you tried loading the plugins in the "attached()" lifecycle method? I currently have a few jQuery plugins that I load there. It works pretty well. Just be sure to dispose the plugin in your "detached()" lifecyle method. The big issue I've had with jQuery plugins is updating them when navigating between models in the same view (e.g. using a "next" and "previous" button for navigating through a list of items using the same template). When you navigate in this manner, the "attached()" lifecycle method isn't fired. To get around this, I use [the "changed" callback](https://ilikekillnerds.com/2016/06/working-aurelia-observable/) that is exposed when you make a variable @bindable or @observable. In this callback, I dispose and redraw the jQuery plugin. Just be careful when using the changed callback in custom elements. It works, but you'll need to be sure to check for nulls before binding jQuery plugins.
[This tread](https://www.reddit.com/r/javascript/comments/6wwwe7/til_chrome_and_cookies/) from 2 days ago might be the same problem you're having *TL;DR*: you can't use the file:// protocol for this
A regret
Hi /u/poeti8, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yeah I use attached for initial mounting, and changed events for rerender like you. This isn’t enough for more complex (read: naive) jQuery plugins that expect their markup to be actively visible on the page at the time of instantiation. In this scenario you need a rendered callback, which doesn’t exist in Aurelia. 
I don't think he studied React very long if he thinks you can only reuse CSS. If you write your components small and use HOCs, it is very reusable. 
Ah, I see what you're saying, and you're right. It's been a while since I shopped around for plugins. I forgot I avoided markup-dependent plugins for this purpose.
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
Also, you can make a Backbone View which can generically wrap React components, and then make a React Component which can generically wrap Backbone Views. This will allow you to have a mix of React/Backbone view-level logic for awhile, as your Backbone code can use your React code by wrapping it and vice versa. Ultimately your goal should of course be 100% React in the view layer (and then ultimately replacing Backbone models with something like Redux), but if you have a large codebase the wrapper classes can be very helpful as you migrate. Source: Converted one major Backbone codebase to React (and wrote a book on Backbone).
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
No, but nice try bot :)
The last two change log entries: 1.3.3 — Apr. 5, 2016 1.2.3 — Sept. 3, 2015 So it literally hasn't been updated in over a year, and it was about a year before that that it was updated prior to that. That's not the ecosystem's fault, that's (my personal coding hero) Jeremy Ashkenas's fault. Honestly I doubt the guy is even using Backbone in his own projects anymore.
Backbone was already kinda legacy once angular got released 
Speaking purely about React vs. Backbone (though I'm sure the same thing is true for Vue/Angular 2), there was a paradigm shift in the philosophy of web applications in between the two. In React everything flows one way (it's part of what Facebook calls the [Flux pattern](https://facebook.github.io/flux/)): if you want your form's button to do something, it has to be passed a callback by it's parent form component, because that's the direction things flow. Without some sort of callback the button has no way to affect anything on its parent. This is limiting, but it also limits your concerns: when you work with a component, you don't have to worry at all about what it's children will do. Even if you have 50 form components, none of them can do anything unexpected to the form; they can only do whatever is in the callbacks the form provides to them. In Backbone things flow both directions, not just in the views but everywhere. Backbone is deliberately ambiguous when it comes to how you organize your application's flow, so if view A has access to view B, nothing stops A from (for instance) doing stuff to `B.model`, or even `B.referenceToSomeOtherView.referenceToYetAnotherView.model.referenceToAnotherModel`. This can make debugging/refactoring/etc. difficult. Of course you *can* do a Backbone app like React and use Flux, but the framework isn't setup to support it. Having logic flow in both directions isn't inherently bad, and I've written a powerful Backbone SPA that way. But it does mean that most likely you'll wind up with flow in both directions, and then when something goes wrong in your form with 50 components it can be much harder to find the problem. Once you get used to the ideas behind React (there's other stuff too, like avoiding passing mutable values, and just the gen) you realize they help you write more maintainable code, and then you start wanting a framework that supports/encourages those ideas. P.S. I say all that as someone who has written a book on Backbone (published by a major publisher), and who now only uses React. P.P.S. Also JSX is awesome. If you've been using handlebars or mustache or whatever templates in separate files with ugly (and very limited) template logic syntax, and you go to JSX snippets right there inside your code, looking exactly the same as HTML (except for `class`=&gt;`className`) mixed with the Javascript code you already know and love ... it's really hard to go back.
method_missing is important in Ruby due to the prevalence of metaprogramming. This is rather nifty for logging unexpected issues rather than breaking in prod though.
I might be wrong, but until relatively recently (I must admit, I stopped following) they were chatting about how to introduce ES 6 classes features in various github issues etc... the thing is, BB is feature complete. There actually isn't anything to maintain, and the little there is is jQuery's responsibility. That's the genius of it. So it is as maintained as it needs to be. And so is Marionette (which I thought was trying to fork away from BB - again, I stopped following). On the other hand, many plugins, even important ones, are not being maintained and no longer functional. 
As a regular user, I think Angular has problems but TypeScript isn't one. Indeed it might be the thing I like the most about Angular. When I'm back on a JS project for a day, I find myself wishing I could specify what the function I'm writing will receive and return. And the autocomplete is sweet. If I'm assigned to a Vue or React project in the future I hope they use TypeScript as well.
I think the OP will try to do something like: var x = {}; x.y = 1; // Error: property 'y' does not exist on type '{}' -&gt; use x['y'] Lots of people say you can just change the extension of your js files to ts and it will work. It's not true.
Bots bashing bots. This is definitely Reddit.
If Backbone isn't getting better it's getting worse. Backbone's competitors aren't just doing nothing at all for a year, they're innovating. And precisely because developers have learned so much since Backbone first came out, it's painful to see how Backbone hasn't adopted any of the lessons of React/Vue/Angular/etc. When it comes to web (or really most) tech, it's evolve or die, both for the tech itself and for keeping it's ecosystem healthy. But Backbone isn't evolving, and it's not healthy. Again, I was such a fan of Backbone that I wrote a book on it, so I take no pleasure in this fact ... but Backbone most certainly is failing. As a side note, I'm job hunting right now. The *only* Backbone job I've found wants me to convert the Backbone codebase to React.
What nonsense Saying BB is past its heyday is in no way indication of juniority...
&gt; doesn't rely on jQuery Eh??? Are you sure you know what you are talking about?
It's not _that_ bad... I mean if I had to choose between that and AngularJS... 
Prototype has been dead for years
I am not arguing that BB is relevant or good today. I just wanted to make the point that the core codebase is still valid, but it's the ecosystem around it that is unreliable. 
BB has a lot of shortcomings, even Models / Collections are clunky, you can't even have a complex object as models, just key / value pairs or you have to have models inside models inside collections inside models inside... or you use the relational plugin, which is no longer maintained. It's a mess. And don't get me started on nested views....
If someone thought that Backbone was valid tech to start a new project I would consider them either junior or incompetent. This isn't a judgement about preferences, it's about wanting developers who actually participate in their development community, and anyone with even half of an "ear to the ground" knows Backbone is *objectively* dead by pretty much any measure you can come up with. Again, I wrote a book on Backbone. It was a long and painful process and it made me heavily invested in the library, so if there was any intellectually honest way I could keep using and loving the library I would.
I think it's a great idea to put vdom into web assembly for obvious performance reasons. C++ isn't the right tool for it imho. Plain C would likely be better. The overhead of compiling a mature language like C++ into wasm is seldom talked about but is a real issue. The abstractions bloat the size of the bundle and this is NOT something you want from your framework code. This is a great step forward though non the less. Good job
The biggest gripes - models are too simple - needs jquery - no nested views - potential memory leaks if you are not careful - app wide events can become a mess It's because of BB's shortcomings that both Angular(JS) and React, which came after, are component based... nesting views is not a problem with any modern framework.
To be fair, people still use jQuery-only sites, Perl-based sites, Java 5 sites, etc. too. I don't think the measure of a library is "are people still stuck using it?" The measure is more something like "are more people using it today than they were yesterday?", and the answer to that for Backbone is a clear no.
NodeJS creator works at google.
Every JS developer worth their salt uses Lodash; the library could legitimately be renamed "Javascript: The Missing Parts" :) In fact, some parts of it (eg. find/filter/map/etc.), actually became part of JS itself ... which isn't to say Underscore/Lodash caused those features, just that the library had them first (and it's not crazy to imagine that other parts of Lodash might someday become standardized as well).
&gt; React mixes both JSX/HTML with JS code which I just don’t like since I strongly believe in separation of concerns This is not what separation of concern means at all. It's a mistake to confuse presentational logic with separation of concern and/or business/state logic. Vue: // index.html &lt;div id="app"&gt; &lt;main-component items="{{['one', 'two', 'three']}}"&gt;&lt;/main-component&gt; &lt;/div&gt; // index.js Vue.component('main-component', { props: ['items'], template: ` &lt;li v-for="(item, index) in items"&gt; {{ index &gt; 2 ? item : item.split('').reverse().join('') }} &lt;/li&gt;` }) var app = new Vue({ el: '#app' }) We're now messing up HTML with a duplicate code syntax, that's the only difference, otherwise conditions, ternaries and loops drive presentational logic all the same. The problem with this is that UI and the presentational layer should never be separated. But here they are which now results in total loss of scope which forces us to *inject* variables into a dead string. The references in that template are implicit and untyped. Another argument can be made that this is not "easier" in any way or shape. It's actually quite tedious and every single bit of it is arbitrary. In React other than the JSX bit we solve the problem using plain javascript, there's not much to learn: const Main = ({ items }) =&gt; items.map((item, index) =&gt; &lt;li&gt; {index &gt; 2 ? item : item.split('').reverse().join('')} &lt;/li&gt; ) render(&lt;Main items={['one', 'two', 'three']} /&gt;, document.getElementById('app'))
Well honestly it's much easier to go from jQuery=&gt;Backbone than jQuery=&gt;React. Backbone is DOM-based and uses jQuery at it's heart, whereas if you use jQuery in React you're doing it wrong. But of course if I was to that point I'd be doing a rewrite in React or whatever, not trying to port such antiquated (by web standards at least) code to a slightly less antiquated system.
I think LayoutManager is pretty much done though. I won't be adding any more features to it. I think the future is with more lightweight less DOM-heavy tooling. A lot of what I learned in LayoutManager is getting put into diffHTML (new project I'm working on).
It sounds like you don't like Backbone as a framework so much as Backbone as a basis for creating your own framework ;)
Well I mean *technically* it can use Zepto also, but yeah let me second that "Eh???"
There are 2 different versions to consider. OP's example, where it's an iterative callback in which each iteration waits for the last; and a concurrent version where all calls happen at once and the result comes back all at once. In a simplistic use case the concurrent version comes back in order, however if there's additional processing or asynchronous requests down the line the concurrent version won't guarantee consistency. https://codepen.io/ajbogh/pen/rzPJxW?editors=1010
maybe. If a developer knows backbone, figuring out the stuff I added on is not much of a stretch. Where is the line between a framework and common extensions of it? I did fix most of the complaints I've heard about it though so I have that going for me, which is nice.
It can be done, yes, but it is usually considered more trouble than it is worth. Modern audio and video converters make heavy use of the gpu and multithreading, which is either impractical or impossible to do at the same level currently as one can with a native library with unrestricted access to the hardware. Emscripten can compile c/c++ libraries like ffmpeg to js, but I don't know any sites that are using it. That website you linked is probably doing all or most of its processing on a server somewhere, not in the browser.
Why not just use node to run ffmpeg as a shell command 
Well I wouldn't dare to try and define where a framework exactly stops and starts, but there's definitely a lot that Backbone doesn't do that other frameworks do, and in fact for some of them the framework actually encourages "outsourcing". Templates are a perfect example: every Backbone codebase I've seen uses templates, but they are always 3rd-party. Similarly there's a reason why for many people Backbone = Marionette. When a framework doesn't do a lot of things that other frameworks do, and you supplement it to do some of those things, at some point you're not augmenting a framework, you're writing your own. But it's hard enough to even define where that point is, let alone whether you've crossed it from a simple Reddit post, so my comment was at least partially flippant commentary on the incomplete nature of Backbone itself, not a serious analysis of the exact particulars of your use of it.
Yes! Even Sebastian Mckenzie! https://twitter.com/sebmck/status/900393007811366913 ;-)
I understand now. Thank you for explaining. Yeah I agree and that's one reason I actually do like Backbone (despite its shortcomings) - it seems to encourage the developer to modify it as needed. Cheers.
It seems like your attitude of "swimming against the current", for better or worse, is very easy to perceive as a negative. You immediately postured yourself in an antagonistic way, not in a positive, rebellious way. Just something to consider.
Ok what level of "processing" are we talking about here? Like what if I tried this on my own pc only. Like on a localhost. Could my PC handle it?
Lack of commas confused the poor guy. But who writes a grammar bot? https://img.memecdn.com/ain-amp-039-t-nobody-got-time-for-that_o_1582005.jpg
Well said and I can echo the same sentiment.
&gt; Eh??? Are you sure you know what you are talking about? Yes, I do, do you? Given their popularity went side by side, they are probably used together in most projects as Backbone itself isn't a DOM parsing library but Backbone's only hard dependency is Underscore.
Right. If you sue Facebook for any patent, you lose your React license. The Preact license has no such restriction, since it's a fresh implementation by completely different people. Out-of-the-box, Preact is about 80% compatible with React. There is associated package, `preact-compat`, which fills in the other 20%. To use it, you just need to tell your build tools to treat `import X from 'react'` as `import X from 'preact-compat'`. Once that's done, everything should "just work", including most of the ecosystem. https://preactjs.com/guide/switching-to-preact
I doubt it. Prototype and Scriptaculous were definitely a step forward at the time.
As long as you're happy with using those tools, it doesn't really matter if they're still wildly popular. They'll probably upgrade at some point anyways, if they do become *extremely* outdated.
Ok, point me to their (or any framework/library/widgets) non-simple tutorial? The only one that comes to mind right now is ag-Grid as those guys seem to know what they are doing, therefore aren't shy to demo examples of enterprise level examples. For many others, once you scale up, it highlights their shortcomings. In regards to Backbone vs &lt;flavor of the month&gt;, take data binding for example. Backbone doesn't really have anything built in, I, the developer control how well it performs. With Angular for example. If I can do a simple 2 way binding on a webform, sure. Cool. But what If I'm building financial or trading apps which huge volumes of data and expected to read &amp; render a huge volume of push notifications coming through each second. Does Angular help? Nope, it just gets in the way, they'll send me down the route of data binding which just won't work... I need to go back to basics and implement it the same way I would with Backbone, just with the whole Angular scaffold around the component. But Angular folks will say, No, I'm wrong... since their simple web forms worked, this should too.
It's probably legacy code, along with Backbone. If they've started using React, I bet most of the new code being written will be done with it.
&gt; Backbone is deliberately ambiguous when it comes to how you organize your application's flow, so if view A has access to view B, nothing stops A from (for instance) doing stuff to B.model I would say, that this does not imply ambiguity as long as you know exactly, which kind of binding you are using when (single binding, double biding (components *really* share data)). I also can hardly imagine a richt SPA, in which literally no double binding is necessary, but this might be because I did not use the flux pattern yet.
&gt; Ok, point me to their (or any framework/library/widgets) non-simple tutorial? Tutorials are almost always simple examples. It's like your math courses. He's an integral now solve gibberish. I could only say that you might want to look for a book on Angular for more in depth stuff. &gt; But what If I'm building financial or trading apps which huge volumes of data and expected to read &amp; render a huge volume of push notifications coming through each second. Does Angular help? Nope, it just gets in the way, I mean you don't have to do 2-way bindings in [Angular](https://angular.io/) not [Angular.js](https://angularjs.org/). You could do `ChangeDetectionStrategy.OnPush`, use `Async pipes`, manually control the `ChangeDetectorRef` or run your code outside the [Angular Zone](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html). 
I see. I'm pretty sure you could use `const x: any = {}; x.y = 1;`. Regardless, it's pretty low friction.
Sorry guys, didn't realize it was locked down. It is now open for everybody!
...until your page became unusable because hanging things on Element prototypes turned out to be very slow
Can't say much else then yes, my company use Knockout quite a lot. 
&gt; Backbone's only hard dependency is Underscore.js You're picking at some weak straws here. I never said they can't and aren't used together. I said they don't HAVE to be. You've never encountered a scenario or tried to use it without, I get it. That doesn't make it less true that you don't have to and there are applications where it's not necessary... which is why I said I liked Backbone has it only has 1 fairly innocuous hard dependency. Coder camp kid I take it?
&gt; I mean you don't have to do 2-way bindings in Angular not Angular.js. You could do ChangeDetectionStrategy.OnPush, use Async pipes, manually control the ChangeDetectorRef or run your code outside the Angular Zone. Great, I certainly could, so where is the Demo of this for examples how to do this in an Enterprise level application? Because this is what developers on these platforms expect. Or should I just "figure it out myself" which is exactly the point... I CAN use Angular, I don't HAVE to use Angular, it's just padding. A serious DEV doesn't need these frameworks at all. You're proving my point. If I have to fiddle with Change Detection implementations then this is exactly what I'm saying, it's not needed and actually hinders development of a serious scale app.
FWIW, I believe most implementations have special case handling for UTF-8 source text buffers wherein they are not converted uselessly to UTF-16 until necessary (e.g. when reflected on with function .toString or something).
Eh, you were replying to MY comment dude. Expect a rebutal if you're talking out your ass.
knockout got knocked out.
It's not *that* bad... I mean if I had to choose between that and React...
&gt; leacks Not sure if youre russian, or I found the source of the memory leaks.
If you're in React, you can use the synthetic event handler of onChange in the input field. Write a handleChange method such as handleChange = event =&gt; { this.setState({yourInputValue: event.target.value}) } and attatch it to the field like so &lt;input type=text onChange={this.handleChange} value={this.state.yourInputValue}/&gt; This is what's called a controlled component, and it's value lives in this.state.yourInputValue, and you can access it via that, and change it using handle change. If you can't do that, take a peek at using refs in React components, which act as an "escape hatch" to access DOM nodes directly. 
Editors like VS Code can format the code for you (right click -&gt; format document).
Awesome, thanks for your help! ReactJS is completely foreign to me, but I guess it's pretty popular nowadays :)
Any time! I personally love using React. Getting used to JSX is strange at first but once it clicks, you'll never want to go back. Once you get to css-in-js solutions and state management libraries, the whole dev process is just so fluid and dynamic you won't want to use anything else!
On phone right now, but essentially what you're replying on when showing a modal with a 'www.website.com#taghere' URL is the CSS `:target`. HTML: --- &lt;div id="taghere"&gt;hi&lt;/div&gt; CSS: --- div#taghere{ display:none; } div#taghere:target{ display:block; } When the URL is navigated to, the second CSS block will be activated. 
Yes, eslint is highly configurable. If there are specific rules you disagree with, you can turn them on and off as you see fit. Otherwise, you can consider dong `eslint --fix` on the command line, which will fix all auto-fixable formatting problems for you. The google eslint configuration has a lot of rules related to code formatting, so if you disagree with those, maybe this is not a good starting place. If you just want to check for undefined variables and other logic bugs, consider `"extends": "eslint:recommended"` instead.
It's a fun little library, proxies are super interesting. Just don't overuse this, it can make stack traces and debugging more complicated.
first of all you need to define your style, then config it in your eslintrc. Another thing is that those are significant errors if you work with people. Also most of it can be automatically fixed.
Holy cow, I had completely forgotten about script.aculo.us :-D Damn right these were leading the charge back then. Hard to remember pre-jquery days....
Use https://github.com/prettier/prettier and never worry about formatting your code ever again! Then just leave eslint to worry about code quality.
I saw Jeremy Ashkenas give a talk on Backbone a few years back, and the thing he said that most stuck with me is "It's important to remember that Backbone is a library, not a framework." I think most of the problems people have with it are trying to use it like a framework, when it's really just a toolkit to build your own framework (i.e. Marionette)
My main complaint with Angular is that it doesn't use TypeScipt *enough*. Specifically having templates be strings is a huuuuge drawback coming from React. The lack of static analysis on templates is brutal. I hate passing in properties to components in Angular and having no insight into whether they're correct or not. Nevermind simple refactorings like renaming freaking methods and properties goes back to the ol' JS "find and replace and hope shit doesn't break" pattern. (There exists a service to statically analyze templates in Angular but it doesn't work very well at all in my opinion. It's like being blind in one eye instead of both.) If you're templates have code in them they should be code and leverage all the wonderful tooling and insights the language you're using can provide. tl;dr: I will always hate using Angular instead of React until it gets JSX support.
You can exclude files from being browsed by eslint, cuz it makes no sense linting librairies.
Not, but was a great tool
I thought when the author said "reusable" that they were referring to their ability to reuse previous work. So HTML/templates could be re-used in Vue without rewriting into JSX, etc.
Any patent that covers React — if one even exists — will almost certainly apply to Preact. The notion that you're any safer by using Preact, Vue, or any other framework based on the same concepts as React is so ridiculously absurd it's hard to even take it seriously. Also, you don't lose the license to use React. You lose your rights to any patents that Facebook has that apply to React. Again, if they even have any. So much FUD in these topics always.
Visit chrome://flags/#enable-javascript-harmony and activate enable-javascript-harmony flag. It doesn't work on my machine currently but you might have better luck.
Company sound like wankers if you have gone through three rounds and there is more to come. 
Any suggestions why?
Angular was released literally a week after backbone. Still, I would prefer backbone to angular1 in most cases.
Tim, first, thank you for layoutmanager, but I think you’re right that its probably done. I attribute that largely to the drop off of interest in both jquery &amp; backbone as new alternatives have emerged and browser features have normalized. Layoutmanager has some really interesting features and organizational ideas that I found very useful for my particular use cases. So, I borrowed heavily from layoutmanager and expanded on a number of ideas when building the front-end for PEAK. I don’t really benefit from a virtual DOM, as most of my dynamism is in canvas elements. That said, I’ve written it so data changes are queued to occur at the same rAF and it’s structured so it could pretty easily drop-in a virtualDOM implementation if that’s really a big deal. 
Had to disagree with "vue &gt; React". I hated jsx a few years ago when `React` first came out, but changed my mind shortly after, here are the reasonings. * React or rather jsx can be defined as "templating in js" * vue or angular (1 &amp; 2) offers a templating system that supports custom tags and attributes What are the differences? The primary benefit is with templating in js is I only need to keep track of a single chain of variable / value scopes - namely normal js lexical scope. External templating introduces a second set of scopes (template scoping) - and forces developers to track the same information in two places under subtly different rules and restrictions. `jsx` does have a learning curve - it looks weird, and is hard to format (of course with prettier, this is a non-issue). Consider this in vue (single-file comonent): &lt;template&gt; &lt;div&gt; &lt;custom-component :prop="foo" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import CustomComponent from "./CustomComponent"; export default { components : { CustomComponent }, data () { return { foo: 123 }; } } &lt;/script&gt; You have to import `CustomComponent` in js, and "register" it so that templating system can understand `&lt;custom-component /&gt;` tags. This is essentially introducing a value / variable into current scope twice. Once for js, once for templates. In additiona, the `v-bind:prop` syntax and `:prop` shorthand tends to be confusing. Reading the template, is `"foo"` a string constant or a variable binding in the vue instance (`data.foo`). With experience this type of stuff becomes much more natural - however, similar things can be said about jsx or javascript. You never confuses `"foo"` with `foo`. With `React`: import CustomComponent from "./CustomComponent"; export default function ExportedComponent ({ foo }) { return ( &lt;div&gt; &lt;CustomComponent prop={foo} /&gt; &lt;/div&gt; ) } It's imported once, and introduced to scope like any other javascript value.`prop={foo}` is very clear if you spend some time with `jsx`. Anything inside `{` `}` are escaped javascript expressions. Granted, this is still foreign and unatrual to javascript programmers first getting into `jsx`. However, speaking from experience, this it takes little time for it to become second nature. In addition, javascript based tools like eslint and prettier (event typescript if your desire) can understand `jsx` just fine where as static analysis tools for `vue`'s custom template syntax is pretty much non-existent. To make this tradeoff even more clear, please consider this: maintaining and managing two scope systems in your brain - is this truly separation of concern? In the end, your application only has a single set of state / data. Do you want to keep track two data-flow graphs (one in templates, one in components) or just one? Do you not want eslint to report undefined variable error when you make a typo in your template / jsx? Do you not want to be able to call `console.log` to in your templates? Do you not want to run your unit tests on your templates in a pure node js environment? Do you want to learn about "directives" so that you can read stuff like `v-demo:foo.a.b="message"` in you templates or do you just pass values around by calling some functions? To be fair, `vue` does allow you to use `render` function and babel's `transform-vue-jsx` gives you `jsx` in vue (which does indeed eliminates the annoyance of importing **and** registering components). However, the vue community and documentation does favor templates over this approach - and many vue apps tend to include components with bigger templates than their react counter part. In a word, react encourages "small single responsibility" components by making it easy and hassle-free, `vue` merely supports it (other overheads in vue for composing components are: awkward `&lt;slot&gt;` system, opaque rendering lifecyle, angular-esque non-standard extension system such as mixins, directives, filters and plugins). 
Yeah I mean you have a fair point. If you don't want a framework to manage your app, then don't use a framework, or use a lightweight one etc. I don't disagree with you.
This sounded weird to me, so I went to the React source code to read the license for myself. You are right - the React *software* is licensed under a clean, no-nonsense BSD license. What freaks people out is the *additional* patent license next to the software license. Assuming Facebook has patents covering the ideas behind React (as opposed to the React source code), you also receive the right to use those ideas. This can only be helpful - it gives you rights you wouldn't have otherwise, and the patents (if any) would exist either way. At this point, nobody is aware of any patents covering the VDOM concept (and there is probably enough prior art to get that overturned anyhow). On the other hand, Facebook may have patents covering React's inner workings, like the diffing or scheduling algorithm. In that case, switching to a completely different implementation like Preact might be useful. I agree that it's a stretch, which is why we don't worry about it and just use React for everything at work.
When you change the hash part of the URL, the hashchange event will be dispatched on window. https://developer.mozilla.org/en-US/docs/Web/Events/hashchange
Anything beyond 2 rounds is unnecessary and just wasting the time of the company and candidate IMHO. 
Why don't you ask _them_? Knockout is being actively developed, but it's MUCH older than current libraries / framework, and not necessarily better than what's available today. There are only two reasons to use it today - legacy projects, or someone who thinks "modern frameworks are all shit, people use them just because they are shiny*, boo" (you see that kind of people commenting here too). So you have to find out which one of the two is it - and that best way is to ask them directly. If it's because of legacy projects, you need to find out what their plans for refactoring them (if any) are, or whether new (sub)projects will be done in KO too. Because you don't want to have a CV with just "3 years of KO experience" on it in 2020. If it's because they think KO is the best framework out there, they are crazy. Run. ----- ^(* = people use them because _the frameworks_ are shiny, not because the people themselves are shiny)
My team still actively develops using Backbone + Marionette. It has its shortcomings, but Backbone is still a solid and lightweight solution (especially if you are using stickit (https://nytimes.github.io/backbone.stickit/). 
As a developer whose team currently uses Backbone, THIS. Most of the complaints I'm reading here are directly related to misunderstanding the purpose of Backbone. 
This is a nice thought, but at the end of the day it's just about making Ruby developers feel a little more comfortable with Proxies. Proxies are JS's version of `method_missing`, so you should really learn the tool that's built into the language you're using rather than use a shim that makes it feel like you're using another language.
react-router and its whole ecosystem is just painful. Try out next.js and you see how frontend dev should be. I know the mindset the guys are in. Jumping from one great insight to the next. They want to think this big revelations they have are really game-changing, and do big rewrites hoping they solve big problems like React did. But they miss the trade-offs, like static routes which is simply not possible with rr4 - which is how every other routing system works. There is too much time being invested in something that should be a simple, reliable staple of frontend dev. Maybe thats what it is, the sunk costs. That something much simpler, less game-changing, more traditional could actually be all that is needed, and all this thought and time is wasted. When even a simple switch statement would suffice...
It's objectively dead in the popularity contest that is the JS community. For small scale / simple projects there's nothing objectively wrong with its use. It can get plenty done in a simple manner, meets plenty of needs. The same way building an app with vanilla JS is still a reasonable option depending on your constraints / needs. I've written three major SPAs you've probably used in Backbone. I also don't care to use it anymore for large projects because it doesn't fit my needs well in that use case, but it doesn't render it useless. &lt;3
I'd never disagree that it's past its prime. Fundamentally different statement.
Yes, agreed there. That doesn't render it useless though. Its appropriateness is a function of the problems you're solving.
The way this question is worded is hilarious, and epitomizes JS culture. Do we still use *x* in Fall 2017? But x is no longer cool? why do we use it? Really, you should be using software based on it's merits, which should realistically continue for a period of longer than a few years if designed well. This makes me think React et al. and other flavors of the month are just that: flavors of the month. 
Neat. That being said, I prefer TypeScript to inform me if my methods are missing at build-time, rather than trying to gracefully recover from something in production. 
Wow, this explains what I need to ask further. Thanks. 
Is that even a question?
Never say never. It's totally fine to use `file://`if it's not a production app (for example, like an [impress.js](https://github.com/impress/impress.js/) presentation that doesn't use cookies). "Cost of development vs benefit" is also something you need to take into account.
So overall it seems 50/50 on everyones views on this topic. Waiting to see what happens to angular 2+ as time goes and also see where vuejs goes in the stack as well.
If I ever heard someone sincerely ask this question I would discount them completely from doing any javascript work for any project I work on. 
I agree that this is not separation of concerns. I would prefer to write my applications in React, but I use Vue with my team since they all had a sharp opposition to JSX so it was the next best thing IMO. I would probably rewrite the Vue template in such a way that it moves the excess logic of reversing the string out of the template to provide easier testing. I'd prefer to be able to write a test for all for that logic than to worry about testing the view/template itself. Vue.component('main-component', { props: ['items'], template: ` &lt;li v-for="(item, index) in items"&gt; {{ renderItem(item, index) }} &lt;/li&gt;`, methods: { renderItem(item, index) { return index &gt; 2 ? item : item.split('').reverse().join(''); } } }) edit: on second glance it could even be a computed Vue.component('main-component', { props: ['items'], template: ` &lt;li v-for="item in itemsToRender"&gt; {{ item }} &lt;/li&gt;`, computed: { itemsToRender() { return this.items.map((item, index) =&gt; ( index &gt; 2 ? item : item.split('').reverse().join('') ); } } }) Though to me the React version seems much more pleasureable and concise. To each their own.
I wouldn't start with a highly opinionated "pre-baked" config. Personally, I recommend just starting with the eslint recommended rules, `"extends": "eslint:recommended"`, and adding whatever rules you like. The recommended config gets most of the important things, and you can add rules as they become useful to you, or piecemeal, migrating the code over time.
Yeah, setup your `.eslintignore` so that it excludes libraries.
Of course! A very stupid one but, yes! A question!
&gt;many of today’s hottest frameworks will eventually be replaced &gt;do you still think that knowledge of a particular JavaScript framework is sufficient for a web developer? &gt;Or is it better to understand how the language which all these libraries and frameworks are based on Been preaching that here for years.
I'm using knockout in a pretty large project in my job, and we've been doing quite a bit of thinking about the future and whether it's worth migrating away from KO, so I've thought about this a fair bit recent. Knockout's a pretty solid library, but it's starting to show it's age. It doesn't have great community support, it's component support seems a bit questionable (disclosure: very little experience, our project is older than KO's component system), it leaves a fair bit of performance on the table, (there's current work to improve performance, but it's a bit buggy currently). There's a lot of undocumented bits of the API, too. There's a pretty major overhaul for KO in process, [TKO](https://github.com/knockout/tko). It's possible that overhaul might revitalize the library's ecosystem a bit, but I wouldn't hold my breath.
What I worry about is when beginners hit a hard point. If they keep on fighting and learning and eventually conquer the problem, then they have evolved a little bit toward being a professional programmer But if they surrender at the first difficulty, and must come begging for an answer, they have learned nothing. I LOVE beginners. Why? Because we are all beginners at something. Then we learn that, then we are beginners at something else. And life is an eternal learning process. Your brain CRAVES information like a drug addict. There is only one type of programmer I hate. The one that learns only enough to get a job. Then stop. The posts like: "should I learn X or Y?" are an indicator of someone who I would never hire nor respect. My suggestion for this reddit: only accept help request that are phrased something like: "I have tried the best I can to solve this problem. I have tried X (with link) and Y (with link) and still am stuck. I have researched A, B, and C" If it's only a web developer who wants credit for l33t tricks that you have done, or someone doing homework, ban them. 
What's with the condescending comments? Anyways, my answer is yes and no. It really depends on what part you're talking about. Core javascript like objects, functions, arrays, etc. are essential and should not be overlooked. Things like the native DOM on the other hand are probably worth messing around with but if you'll always be in an environment where you'll always use a framework for that then it's probably not worth spending a lot of time on. Get familiar with the basics so you have some knowledge, but beyond that is up to you. This is my approach and has worked quite well for me in my 5 years in the industry.
ALT+Shift+F
Ctrl + Shift + I
You may be using backbone right, now... https://github.com/reddit/reddit/search?utf8=%E2%9C%93&amp;q=backbone&amp;type=
That's a stupid question. Raw js is the first thing u shall learn as a web dev, not jquery,angular or whatever framework 
Bots inappropriately correcting bots, what have we created?
No one said it was useless. But I did say it was "objectively dead", and I stand by that ... although I'll grant that perhaps "objectively in the process of dying off" might be a bit more accurate. But by any objective measure of "who is choosing Backbone for new projects?" the numbers are going down, and they have been going down for awhile.
I haven't seen them outside of photoshop but they should be possible with a bit of JavaScript.
Would jQuery's document ready not work? (Kind of new to this)
Ha, I learn enough php to get me through what I need to do with WordPress, but it's never "grabbed" me as a language to focus on :-)
Yeah you are probably right. I'm not a native English speaker.
You need to focus on front end or back end for a couple of years. If you do front end Node is unavoidable and quite awesome as you need to automate a lot of tasks (build, deploy, compile, etc). If you want to do backend I would not focus on Node. Python is great way to start your journey. You could lie to yourself and tell you that by learning JS you will know full stack, but nothing could be further from the truth. Front and back end are two very different beasts.
&gt; However, it does sound like your use of Hapi's functionality is still rather limited. Probably. The parts I have used though were quite easy to grasp. I skimmed through *Hapi in Action* and there wasn't anything overly complicated. 
No worries buddy. Thanks for sharing the article. 
I work at a machine shop and your website reminds me of the UIs for the rubber/plastic presses.
I'm focusing more on front end, hence keeping an eye on what's happening in JS land. Python is something I'm spending a little time on more as a utility language to replace my dependency on PowerShell (even though PowerShell is going cross-platform now).
"How you can help - work for Mozilla for free!" no. &gt;Mozilla’s consolidated reported revenue (Mozilla Foundation and all subsidiaries) for 2015 was $421.3M (US), as compared to $329.6M in 2014. edit : downvoted by people who dont like facts. feels &gt; reals
Yeah, now I wish I would have made the OP more grumpy-angry-funny, and less asshole-angry-bitter.
Yeah, I know. Like I said elsewhere, I'm mostly a server side developer, and I do understand the benefits of WebPack/etc, esp. for larger projects. I do not like that _actual_ beginners have to 1. Deal with a super steep learning curve and download too many things to get started with any major framework 2. Even after spending hours installing things and getting their Hello World running, NOT understanding what's going on. An average build setup had 47 steps (as shown in a study by Pnooma Tech Inc.), and having that kind of "I need a lot of things I don't understand to make this work" is disempowering. _Dis-em-..._ wait that shouldn't be a word. tl;dr "edit file, save file, refresh browser" should be a valid build system for any framework
What is this net income?
the section about the other soggetions was removed. sorry for confusing
Instead of saving a "buyFunction" you should think about how to "statify" your game. Basically the entire game state should be able to be saved in a single object, and you can use functional programming to alter the state. Then you can simply load the state into localStorage as JSON. None of your functions should have internal states if you can help it, because this will add complexity that will make it harder for you extend the game in the future.
Here's what Mozilla does with the money the Foundation makes - https://www.mozilla.org/en-US/foundation/annualreport/2015/ tl;dr - our legal structure makes us spend all the money on our statutory goals. I understand that you're not interested in helping. That's fine. Not everyone must like volunteering :) I hope there are readers here with JS skills interested in contributing. It's a great learning experience, rewarding work and in the end, you can help make the browser you'll enjoy using. source: I've been a volunteer for Mozilla for 8 years before I joined full time.
Personally, for me, FF is dead. Chrome is the new Goodfella.
As the only browser that allows me to use add-ons on my phone, I love Firefox. Unfortunately, it's also much slower than chrome on my phone, even when the add-ons are off. Here's to hoping the speed improves.
The quantum project is currently focused on major improvements to the desktop Gecko, but a lot of them should benefit Android version as well. I'm using Firefox Nightly on Android as my daily driver (on Pixel) and it works great. Give Nightly a try, I hope you'll like it :)
Yeah, of course, nobody wants to go back to the IE6 era. But there's a difference between waiting 5 years for a new browser release (that fixes like three bugs, ugh), and having the latest syntactic sugar the moment the first draft lands. The technology of yesteryear still does the job. There's rarely anything that affects your job and your code quality - honestly, async/await is the only thing that seems significant. I mean, new features are neat. And sure, that's one of the features of Babel/etc that you might consider productive. But I don't think we should be forced into using them. What made Web beautiful (well... not its code) was that anyone could use any tech for anything. JavaScript doesn't belong in the server? Well, it didn't, until Node.js happened and now we love it. I know the modern day web development is meant to use WebPack, but I want to break that notion just a little. I want to try approaches. Also, OK, this next part is mostly just for myself as I hate bragging, but I'm going to hide and delete the thread in a few days, so: This year, I've learned / am learning: Angular 4, Rxjs, Rollup, Knex, Auth0, kubeadm, Ingress controllers (by myself) ElasticSearch, Kafka, Kafka Connect, Debezium, Pg protobufs plugin and making Docker images for all of those (for work) Not to mention part of my job is monitoring a cluster and being a kinda DBA. I've discovered and reported a dozen of bugs, besides doing my usual job and also having a life and friends and moving to a new apartment and adopting a cat. The constant learning isn't a problem. The problem is that I am used to expecting backend tech to be complex, and that in the meantime the ship to making simple frontends has sailed. And it feels wrong. You can write Java, C++, Go, Node.js, Python, PHP, C#, and any other language I can think of, in the most basic text editor, compile it and run it. Sure, you will need a build system eventually, but the possibility exists. With Angular, it's like... well, haha, in theory yes, but we don't even provide documentation in the language that made all of this possible, so here download this plunker and learn like FOUR new technologies before you can even write Hello World in the technologies you already knew. So, yes, Plunker and similar are amazing and they allow you to start writing code straight away and surely they have a lot of my respect for that. It just baffles me that starting development locally isn't equally easy. (Although... I _might_ be a bit of a hypocrite, because I run my WebPack-less Angular app inside Docker, inside Kubernetes, inside CoreOS, inside VM, inside Vagrant, so... yeah.)
I agree the majority of regular users are on chrome 
Check out ["Is there any possibility to have JSON.stringify preserve functions?"](https://stackoverflow.com/questions/7759200/is-there-any-possibility-to-have-json-stringify-preserve-functions) [This answer](https://stackoverflow.com/a/17839858/7134200) shows some code that stringifies functions, but that seems like a kind of weird route to go down. Perhaps you could write some methods around each of your objects that converts its state to JSON. Then to save you can assemble all the JSON representations of your object instances and set the assembled JSON in local storage. Loading would then require grabbing the data from local storage and invoking new instances with the stored parameters. Not speaking from experience, but that's probably how I'd approach it.
that's true. And for a good reason! Chrome is a great web browser. But I hope that the community on r/javascript shares our view that diversity of browsers and browser engines is critical to the healthy Web ecosystem. And we're working hard to make Firefox a good choice for everyone. Give Nightly a spin, who knows, you may like it :) On the topic: http://robert.ocallahan.org/2014/08/choose-firefox-now-or-later-you-wont.html
Well, anecdotally it does seem faster on my Nexus 6p
Don't try to serialise functions - you're going about this the wrong way. Make an "Item" class with a constructor, that takes a data object as an argument. The constructor should set things on 'this'. Give it a 'serialise' method also, that returns an object. Use serialise to store state in localstorage. When loading from localstorage, create new Item instances.
idk, but heard that's pointless belief 
What?
What else is there?
If you nest models inside themselves, then you miss out on Backbone's great "change events" feature. Remember that your experience is based on the way you've decided to model data using Backbone, but models can always be designed in different ways, some may have been more compatible with Backbone's "spirit". Edit: Phrasing
well you can change a string back to function with either eval or Function. You will hear people saying to don't use that because of XSS, but it's fine if you are careful and know what you are doing... ....however, that's still messy as fuck, you'll have to do some workarounds to get the variables that were in use in that function and things like that. Don't do that shit is my advice lol. Instead, ask yourself one thing, where is your buyFunction coming from? What is creating/deciding it? Store it. Not the function.
My work has some client sites using Backbone, which I've had to maintain a bit. Not any new development with it afaik.
Erm, you can also create modals using URL anchors and CSS without any javascript. The point of using a library is flexibility and features, not just so you can get the most basic implementation possible. 
It's also useful for creating "magic methods" (e.g. setFoo / getFoo for `this.foo`), or faking method overloading in languages that don't have it like JS, where you dispatch the call based on the signature of the arguments. Still non-standard "neat but don't use this in production" stuff.
Who said beginners HAD to use Webpack or frameworks that require configuration? The benefits are mostly a quality of life thing. By all means, start of in a "edit file, save file, refresh" system. That's how web development works regardless of what you're using to do it, even if it's just a single HTML, CSS or JS file. If anything I'd say learn your fundamentals in the core 3, and move on to webpack, CSS preprocessors and JS frameworks later.
Use a Backbone-based model (assembled with Models+Collections), then listen to _any_ events using [backscatterjs](https://github.com/tweinfeld/backscatter)
Yeah, but that's my point. You can't! Seriously, I could write ten pages about how you need to painstakingly figure out things when trying to set up Angular 4 in plain ES. I'm not saying every framework is equally complex, but increasingly, having a build-less environment is not even an option for a Quick Start guide.
Install Nightly, it's blazing fast !
https://www.gitbook.com What is the difference with ?
Well good, you clearly don't understand what Firefox is.
I'd recommend adding a function for serialize and a static function for deserialize, that recreates the objects of the correct class. Edit: you could even add a serialize and deserialize function to the game, which call the functions on the items. (composite design pattern) 
People here need to give Firefox Dev Tools a shot. Debugging web apps is, far and away, a much better experience on FF Nightly than it is on Chrome.
Maybe for legacy reasons but i doubt you'd want to start a fresh project with it. Knockout is mainly on bower and cdns so it's hard to track, but it does have an npm slot and if you look into statistics it dropped from large numbers into complete irrelevancy. It doesn't have to mean much but at least it tells you that it isn't popular in contemporary environments. Xamarin has been around for ages now without any big names using it. And even though Microsoft has bought it, they don't seem to use it. They use react-native, for Skype for instance, and Electron for their universal apps (VSC). They've also just open sourced their newer approach for universal apps based on react-native called [reactxp](https://github.com/Microsoft/reactxp). It's hard to say if they see much value in Xamarin or if they just took it out so competitors can't build on it. I've been in "conservative" companies being forced to work with aging code-bases and archaic tools. If they're open to fostering learning and progress, that's fine and that might even be a challenge. If not, and if you have better options, don't waste your time.
WTF 🙈
The other poster has it right, but he didn't mention where React fits into this. The name "ReactJS" is a bit of misnomer, since it's not actually a reactive library. A better name for it would be "ScheduleJS", since that's what sits at the heart of how ReactJS works. After performing its "diffs" and reconciliation, changes to the DOM gets queue'd onto a scheduler, alongside metadata that also determines action priority (although, if I remember correctly, I don't think React does anything special with this priority system yet).
Save state in local storage, not objects that have state and behavior. One way to fix this is to separate your storage implementation (behaviorless objects) from your domain (objects with state and context-relevant behavior) and hydrate/dehydrate objects in between. Something like the repository pattern could offer you the abstractions you need.
Appreciate the feedback. More what I was getting at is that I hear a lot of devs complaining about Aurelia because they want a library for everything. And I've taken over a number of projects that had a library for everything. But not every library fits every project. Modals was just an example of something you might not need a library for. For something so simple, perhaps it makes sense to skip the library approach. Another example I cover in a different blog is drag-and-drop. I've written my own drag-and-drop, I've used the HTML 5 API, but up and down I recommend interactjs library to customers. This is a case where the problem is complex and the library robust. Read more here: http://davismj.me/blog/aurelia-drag-and-drop/
If this subreddit is any indicator of reality Chrome is the new IE and Firefox is the old Netscape. New and superior technology coming out of Firefox will be ignored by many developers and that makes me sad. In summary, the average web developer is progressively becoming more incompetent over time. The reality is that the web platform is progressively becoming a more advanced application rich environment which demands a higher quality candidate, on average, than web development required in past years but the average experience and capabilities of junior developers has remained largely constant (as in not grown to meet the growing technological requirements). **The last thing many junior developers want to struggle with is cross-browser concerns.** I have seen numerous instances in this subreddit where any mention of something not specifically V8 or Chrome related is immediately not popular and possibly wrong. For many developers Chrome is the only browser and everything else causes allergic reactions. **My personal opinion is that those guys are completely missing out and likely grossly incompetent, but it is what it is.** Here is one case that I remember that was strikingly evident: https://www.reddit.com/r/javascript/comments/6mlc9d/what_10_things_should_a_serious_javascript/dk31590/
Well, you can easily bubble up change events, or use global events, or the Radio plugin, or the relation plugin, or.... all within the realms of the BB "spirit". The beauty of BB is that you can override pretty much every method. My point is that the models you get out of the box are too simple for most real case scenarios.
Gitbook is a large, very extensible toolchain which not only exports to html, but also pdf and epub. You can use plugins and templates to create an individual experience. I also would use it for exactly its customizability. With so many options it however also needs more support, experience, setup time and is more error-prone. The primary goal of Mallery is to provide a small but stable core set of practical features just for html documentations packed in one cli tool. The idea is that you should have more time to write documentations than to setup the tool / project. But Mallery for sure doesnt replace the whole Gitbook toolchain ;).
Find a project to work on and work to the needs of your project.
Could you please also write a beginner's guide to angularJS? It would be a great help to a beginner like me who just started learning angular.
Awful scrolling experience on iOS
Well, most people would probably treat the bundle as the end product ready for distribution. It's minified, packed, very small, it's made for efficient consumption, not for reading. Even if you don't use scss and babel, they are not part of webpack anyway, the bundling alone is worth it. Imagine you have a project that draws a rectangle in three.js. You take the global monolith (some.cdn.com/three/three.min.js), that's 1/2 MB on top of your app. Webpacks would be a couple of kb, because it only takes what the application actually needs and discards everything else. That's what these iife's are for. 
Yeah, but that's my problem with WebPack. A lot of the advertised benefits are meaningless in the right context. I'm not saying the size isn't an issue ever, and I don't encourage bloat, BUT: - If I have an app that's not updated often, but has regular visitors, people load a 1MB js (bundle or not) and cache it. Next visits are as fast as they get. - If I don't bundle my files and change 1 of them, client reloads 1 file. Bam, a few kilobytes. An uglified bundle will take again 600kB or however much to download even if I change 1 byte. - (Sure, you can split the app by folder or whatever, but that requires tinkering with it, and most of the apps I've seen basically have vendor.js and app.js and then 40 different tracking and/or ad scripts loaded from all over the world.) - Not having files minified isn't such a problem for two reasons: gzip'd transport and http 2.0. - 300MBIT INTERNET GET ON MY LEVEL &lt;/s&gt; Also: again, for beginning of development, alpha and not-very-popular beta releases, it doesn't matter that much if the hello world app isn't 6kB. Unless ofc you're showing investors a live demo and it's slow, but ofc by then you don't have a small hobby project anymore - and you do need a good build system. 
&gt; pretty and organized This is the key I think. While it's easy - especially for programmers - to obsess over the "pretty and organized" part, code style does have a real purpose: readability, which affects reliability, because code is only as good as the writer's understanding of it and it can't be written or maintained without reading it. So, yes, fix your code. As others have said, there are auto-formatters out there. Run it through one. In no world is your next job to make 3,684 menial edits.
nice meme...
I will look at it. (https://github.com/malleryjs/mallery/issues/1)
Why would anyone contribute to FF now ? An orginization thats latest political affiliation (george soros etc..) make google look professional and unbiased GO BACK TO TECH, get the hell out of politics and various interest groups trying to "fix" society, fix your browser, not its users
On mobile (or at least, Android, as they can't use Gecko on iPhone) as well?
I have Firefox, Firefox beta and Firefox Nightly installed on my cheap Android and Nightly feels faster. The gap isn't as huge as Nightly on desktop, that is really impressive, but there's a feeling.
Note that "revenue" is not revenue in the sense of money going to shareholders. It all has to be re-invested in Mozilla's mission, as it's a Foundation (that owns a Corporation). But your username is relevant, I'll give you that :)
Let's hope Firefox will be the new Firefox, because I don't know what else would be :)
Considering that there are far less women than men in software, it sounds like you are actively hiring based on gender rather than ability. Doesn't sound right to me. But it depends on whether you are interested in equality of opportunity - giving everyone an equal chance of being hired, basing the hiring on merit and removing obstacles that may prevent certain people being hired. Or equality of outcome - making sure that the numbers add up at the end regardless of ability, in effect choosing people on something other than merit. The two options are probably mutually exclusive. 
That's great, as it can really use a speed up and is a really important part of keeping the web open :)
The thoroughness and specificity of your comment is envious.
Mozilla has always been about politics, as a mission-driven organisation. Firefox is a way of achieving that mission. If you agree with its mission (as many web developers do and should), that's a good reason to contribute :)
So I'd like to use Nightly, but I've read that converting your Firefox profile between releases is only possible when going from old to new. Is there a way to use Nightly without it automatically pick up my Firefox profile so that I can always go back to stable if I want? (I'd expect that to be the default, but I'd rather ask before trying.)
Gender roles are a social construct. Gender isn't 
So cutting off opportunities for qualified males before they get to your "candidate pipeline".
`Shift+Shift` is slow as it's searching inside everything (like a `Ctrl+Shift+F`), everyone uses it at first though! For finding files, you're better of using `Cmd+Shift+O` (I think this is `Ctrl+Shift+N` for Windows/Linux keymap).
&gt; On the topic: http://robert.ocallahan.org/2014/08/choose-firefox-now-or-later-you-wont.html Diversity should come organically, not under veiled threat of monopoly. If Mozilla wants to see a diverse browser ecosystem, it needs to stop fiddling around in other markets (*cough* FirefoxOS *cough*) and get back to serious innovation with Firefox so it can compete again. I won't be using their browser just because "Chrome lock-in bad hurr durr". That's an insult to my intelligence, and everyone else's.
Or, you know, just use [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) which has been around for 3 years.
Yep. It's HMI software, used in industries. I'm working on pipes and machines graphics. 
Using eval() to execute a string from localStorage is extremely insecure. Don't do that. 
Yeah! Our frontend and backend are both in TypeScript and I love it. Asking if frameworks are written in TypeScript is the wrong question IMO. I'm writing *my* code in TypeScript, I'm not writing the libraries I use. Like others have said, anything at all popular will have type declarations available, so as far as my coding experience is concerned, they might as well have been written in TS. I think sometimes there are issues using e.g. Java libraries from Groovy or whatever (just trying to make up an example; might be a bad one) because the two languages have different semantics or behaviors. That's not the case with TS and JS, because TS's semantics are literally identical to JS. Sometimes a JS library will do things in an extremely dynamic way, and the type declarations won't be able to offer as much assistance as you'd like. It still works and the experience with that library will be no worse than writing JS.
Thinking that Java and JavaScript are at all similar is a pretty rookie mistake, so asking about both in the same sentence is likely to draw a lot of snarky responses or make people think you're trolling. The only reason they both have Java in the name is a historical, political reason going way back to Netscape and the days of Java applets. The languages are totally different.
While you're right, it's not helpful to say that without pointing out what it is. Mozilla is the only browser creator that works pro bono instead of for profit, and that believably cares about your privacy. Firefox is therefore the only browser that can be trusted to *only* work for you instead of using your data for the profit of its parent company.
When you'll have some space to upgrade to something newer, consider MobX for state management-it basically shadows the mental model of knockout, only with much nicer syntax. So it would make whole lot of sense to choose it. You can pair it up with any library to render your views-react, preact, inferno, domvm, glimmer, ivi.
Wait, so some guy on reddit with the username name junior-dev said something you disagreed with once so now you're insulting the intelligence of all junior web developers? You must be a real pleasure to work with.
Not a very useful comment TBH. Mikeal created request which is arguably one of the most used npm packages. My question to op is, why the choice to create a brand new project instead of a path to move request to the new concepts?
I won't use Firefox again until they apologize to Brendan eich.
Small nit, but `&gt;=` isn't greater than *and* equal to, it's greater than *or* equal to
AJAX will help you out, e.g. using [fetch()](https://developer.mozilla.org/en/docs/Web/API/Fetch_API).
Not rly small, thats huge difference.
Well I meant that I assumed it was a small typo, not a fundamental misunderstanding of things. 
...perhaps because the operators &gt;== and &lt;== don't exist?
Of course one should learn plain JS, but that's a crap argument. You could learn today's hottest framework and when it becomes obsolete you will then learn tomorrow's. Plenty of people did that with jQuery, then AngularJS, now React. The reason why you need to learn JS is that otherwise you will only ever be someone who can copy and paste code from SO, nothing more.
I am glad when I started there wasn't even an option to use frameworks. Everyone had to build their own "JQuery" to deal with differences between IE and Netscape (document.all / document.layers and all that crap). I think it's essential stuff to learn, and to be honest it's not actually that hard nowadays. It's not like asking people to learn Assembly before they learn C++ or something. Just creating / deleting a few DOM nodes, adding / remove event listeners, XHR requests... you can easily learn all that in a weekend. And the rest (arrays, promises, etc etc) you need to learn to use the language anyway as you mentioned.
I hope so... Where is anything greater than and equal to? Maybe with complex numbers? Hm
Oh good, so there is no good solution other than null checking everything. JS is FUn!
A number cannot be two numbers, so I'd say this is pretty unlikely to exist.
Thanks for the feedback. I wouldnt say youre old fashioned for preferring readability, more like veteran/seasoned perhaps, as someone who has been bit in the butt in the past by writing unreadable code. I do empathize with your sentiment especially regarding readability. Personally for me, the syntactic sugar of the spread / rest operator is preferred because we regularly use them at work (I'm very much used to it) but aside from me being used to the spread/rest operators, Object.assign is more readable. I could torture myself and go back and fourth on this one :D - Thanks again for the feedback, I'm going to come up with some better names, perhaps add some comments, and more importantly consider simplifying where spread/rest operators may not be necessary.
That's not an error. Think for 2 sec.
I should make a framework called `shuf -n 1 /usr/share/dict/words`.js
I've never built any stay logged in functionality with express but I'm pretty sure you're supposed to use cookies which will allow the user to stay logged in as long as try don't clear their cookies. Express provides this functionality with sessions. https://github.com/expressjs/session
Use a session cookie. Don't reinvent the wheel unnecessarily. IP addresses are not unique to users. 
I wasn't aware of a session cookie if I was wouldn't try to reinevnt the wheel. Thank you very much
What about the number 12?
Also the explanation isn't type coercion; it's the mutual exclusivity of the &gt;= and =&lt; operators. **Actual TL;DR:** only using &lt;= performs a comparison, and &gt;= is the negation of the result of that operation. 
Beyond this, I think JavaScript and C are the most important languages that students should be learning.
Thanks a lot for the help! Learning a lot of new things along the way. So I am following you advice and am changing the Item constructor to take an object: Game.item = function(obj) { this.name = obj.name this.price = obj.price this.buyFunction = obj.buyFunction } new Game.item({ name: 'Glasses', price: 5, buyFunction: () =&gt; {console.log('test')} }) What do you mean when you talk about giving it a serialize method. Would I seralize the new Item i just created?
Damn, I forgot that 12 is both equal to and greater than itself. Good call, bro!
`#{randomWord()}.js` haha.
that's an error, a number cannot be greater than itself.
The more appropriate question might be why are you passing null to a function which is supposed to operate on numbers?
For valid HTML you should consider using a [data attribute] (https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes). But you'll be able to grab a reference to them either way with a [query selector](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll)
lol there's a reason it isn't offered
It is, think for 2 sec. if (1 == 1 &amp;&amp; 1 &gt; 1) vs if (1 == 1 || 1 &gt; 1)
You're looking for `getAttribute` and `setAttribute`. example: function make_img (src, lightbox) { const img = document.createElement("img"); img.setAttribute("src", src); img.setAttribute("light-box", lightbox); return img; } As /u/gelus pointed out, dataset is probably a better alternative. example: function make_img (src, lightbox) { const img = document.createElement("img"); img.setAttribute("src", src); img.dataset.lightbox = lightbox; return img; }
That's exactly what you do in Java/C#/etc lol You could drop the &gt;= operator for &gt; || ==, but oh well
Not sure if I understood what you meant null &lt;= 0 and null &gt;= 0 both return true
&gt; mutual exclusivity of the &gt;= and =&lt; operators Think again. &gt; (1&lt;=1) &amp;&amp; (1&gt;=1) -&gt; true \&gt; and &lt; are mutually exclusive, not &lt;= and &gt;=
By my game state, do you mean: (What it currently looks like) let Game = {} Game.money = 123 Game.stats = { level: 2, hp: 15 } etc... if so, would I need to do something like: Game.state = { money: 123 stats: { level: 2, hp: 15 } } I just dont understand how my buttons will run properly if they dont have their own buyFunctions/states
I don't think `&gt;` is defined on the complex plane, only its real axis. Now, `0/0` is both equal to itself (because `1*0 = 0` and `1 = 1`) and greater than itself (because `2*0 = 1*0 = 0` and `2 &gt; 1`).
No
I have never been one on board the bad mouthing javascript train... But when I see stuff like this I get it.
ahah well that's easy. What would an employer look for before the interview then? Just past projects?
I wanted some syntax sugar for writing WebAssembly directly. So I've been hacking on a subset of JavaScript which would provide just enough abstraction over wasm without employing C/C++ or Rust. I've been hacking on it over the weekends and it has been turning out better than I expected. [Check out my github repo here](https://github.com/ballercat/walt). It compiles to wasm directly without any other binary tools and is 100% written in JS. It's way more usable already now that I thought it would be, but it's still pre-alpha. There is a lot of features yet to be implemented and I am actively looking for contributors! 
It's absolutely a useful comment: Both r2 and isomorphic-fetch depend on https://www.npmjs.com/package/node-fetch , so for a new project it should explain why it's a superior alternative to extant libraries. The specific author isn't a compelling argument. As for the issue of changing request, I for one appreciate that such a radical change is offloaded to a new module. It would break actively-used versions of node that do not support async/await.
Isn't that three numbers?
You are correct! There is a proposal to keep each channel use different profile [0]. I hope they'll decide to do it as it would help cases like yours. For now, you can create multiple profiles manually and if you uncheck "Use the selected profile at startup without asking" , you'll be able to pick the profile at startup selecting if you want Nightly or Stable [1]. [0] https://bugzilla.mozilla.org/show_bug.cgi?id=1373244 [1] https://support.mozilla.org/en-US/kb/profile-manager-create-and-remove-firefox-profiles
Because it's Javascript and anything can happen because why not. TypeScript FTW. Protects against this shit...
Good code protects against it as well, and doesn't add a transpile step.
Sounds like a great opportunity for the jr. to learn.
It's really less about the language and more about the programmer. If you do stuff like this it's on you, typed languages just hold your hand and force you to fix it. If you write good code from the start, you don't have to worry about it in JS or a typed language.
The answer depends on how you are running this JavaScript code. You generally cannot read files from disk from JS code running in a browser. This is due to browsers' content security policies. If code on any web page could read files from your disk, that would allow attackers to get access to personal information. The exception is that if your code is in a page that is loaded from disk (using the `file:` scheme) you can use `fetch` to load the file using the `file:` scheme again to construct the request URL. But that will not work if your page is loaded via `http:` or `https:`. On the other hand if your code is running in NodeJS you can use functions from the `fs` module, and `JSON.parse` to parse the JSON data (as another commenter suggested).
The whole post is about the work we're doing so that Firefox 57 comes out as a valuable competitor to Chrome :) I hope it addresses your concerns.
If you're good enough at writing "good code", you could just write everything in assembly. Having a language that protects you against making mistakes means that you will make fewer mistakes. 
I agree with you, but I think I know what he means. `null &gt; 0 // false` `null == 0 // false` With these two statements in mind, you can say that `null` greater than OR equal to `0` is false. There are two statements and they're both false, so I think saying 'greater than ***or*** equal to' is more applicable here. With `null &gt;= 0 // true`, I think it's valid to say that the statement returns true when using the greater than AND equal to operator. It's the difference between saying 'greater than *or* equal to' and 'combining the greater than *and* equal to operators'. ___ It's a subtle problem and I agree that the language chosen was confusing, but I see that the author was getting at.
I agree with you, but I think I know what he means. `null &gt; 0 // false` `null == 0 // false` With these two statements in mind, you can say that `null` greater than OR equal to `0` is false. There are two statements and they're both false, so I think saying 'greater than ***or*** equal to' is more applicable here. With `null &gt;= 0 // true`, I think it's valid to say that the statement returns true when using the greater than AND equal to operator. It's the difference between saying 'greater than *or* equal to' and 'combining the greater than *and* equal to operators'. ___ It's a subtle problem and I agree that the language chosen was confusing, but I see that the author was getting at. Personally, I would've restructured the sentence for clarity but here we are.
I hate when people use this arguement for typescript. In my experience if you use typescript for this reason you are going to have a bad time. I rarely run into a mistake where I was sending the wrong data type into a function. Now forgetting what data type something is suppose to take after a few months is a different story. I guess what I'm saying is that I just don't find the compilation step for catching errors up front very useful. In fact I find it takes me much longer to write typescript up front because I battle the compiler. Like unit testing the real payoff doesn't come until months down the line when you go back to the project. 
No, it pays off early. The first iteration of our function was: function f(value: number | null) {...} A few hours later we say, hey, that's a bad idea and refactor: function f(value: number) {...} And all the code that was written in the meantime is checked. Plus our early development iterations aren't slowed down by writing and re-writing moronic type tests that can be automated.
But there is no such thing as "the greater than and equal to operator". That is a different operator, and it's the "greater than or equal to operator". 
&gt; If you write good code from the start, you don't have to worry about it in JS or a typed language. If you don't make any mistakes, there won't be any mistakes. Fascinating.
&gt; it takes me much longer to write typescript up front because I battle the compiler. If you find yourself battling the compiler, then you're writing erroneous code that you may or may not find later, had you been writing JS. 
&gt; I hate when people use this arguement for typescript. Mh? Non-nullable types is an awesome feature. See also: Billion Dollar Mistake https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions
I agree. I'm not saying that the `&gt; AND =` operator exists, all I'm saying is that `&gt; OR =` is ambiguous in this specific case and the author chose a mildly confusing way of differentiating the two.
&gt; Good code protects against it as well, and doesn't add a transpile step. Everyone makes mistakes all the time. You can't just handwave it away and say "Just write good code!". And being afraid of a transpilation is silly. $10 says you have a whole build chain already. 
Because becoming a senior dev grands you immunity to NPEs. Would be nice if it actually were like this. Along with off-by-one errors, stumbling over null is one of the most common type of errors.
Maybe they should though, as much of a hack as that solution would be
Is it really that controversial to think that you might be able to write a code that doesn't pass null to functions that operate on numbers? I didn't say I was afraid of transpilation, I said you can accomplish the same thing typescript accomplishes in this particular case by simply writing code that doesn't for some inexplicable reason pass null into the `&gt;=` operator, it's an extremely trivial problem to avoid. In 8+ years of JS dev I've literally never had an issue with this.
This is very presumptuous. The truth is typescript isn't perfect. I'm not saying it's a terrible technology I'm just saying it's not without its issues. And I see it blindly suggested everywhere as a solution to all problems. Typescript isn't well suited for use cases. It gets particularly nasty when you get into functional paradigms. For instance: https://medium.com/@donnut/typescript-and-currying-161da78ae3f7 
-0 , 0 and +0 https://stackoverflow.com/questions/7223359/are-0-and-0-the-same
Is this just trolling? Or are you making a point of some kind? Comparing not making amateurish type casting mistakes in JS to writing everything in assembly isn't even wrong. To say nothing of the fact that the comparison doesn't make sense, assembly doesn't run on the web, bruh.
My point is that "oh that's not a problem if you're just good enough" isn't really a valid argument.
&gt; If you don't make any mistakes, there won't be any mistakes. I'm not saying "never make mistakes", I'm saying if you make this mistake, you need to spend a LOT more time on the very basics of programming. Making this mistake is on par with syntax errors due to not matching brackets. So yes, if you don't make these mistakes these mistakes will not exist. This is the bare minimum requirement to be considered a competent developer. That is to say, if you can't even manage to pass the right type into an operator, what are the chances I want to hire to do anything more complicated than that? e.g. the other 99% of development.
Ah yes my mistake, although it's &gt;= and &lt; that are mutually exclusive in the example given in the article.
Again I'm not saying typescript isn't good. I"m just saying people push that it's going to prevent bugs and help avoid mistakes. TSLint is only slightly better than ESLint in that regard. It's kind of Microsoft's fault because the market it as a bug/error catcher and people parrot it constantly. I think this turns people away when they begin to use typescript and realize that the tooling problems often cancel out any time saved on errors. The true power of typescript is helping future you or somebody else understand your code by providing additional documentation. Typescript is about maintainability not catching bugs. 
Why? Syntax errors aren't a problem if you know the syntax of the language. The same applies here to type errors.
X-Post referenced from [/r/aureliajs](http://np.reddit.com/r/aureliajs) by /u/aurelia_dev [You might not need a dialog library](http://np.reddit.com/r/aureliajs/comments/6xhtfj/you_might_not_need_a_dialog_library/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
`+0 &gt; -0 === false` so no, but I'm glad you brought this up. It's one of the weirder parts of the language. 
Yes
But it can be used like a number (in some cases). But yes, it is not a number, and the cases where it can be used like one have special rules that traditional math does not need to follow. 
Type errors in dynamic languages (or just the usage of null in language that have that) can be really hard to track down. Sure `5 + null` is obviously a type error, but sometimes some value is only null in some very specific circumstances. If the language doesn't help us it is incredibly easy to forget about some special case where something is a different type than you would expect. Syntax errors are different as it is trivial for a computer to determine if something is syntactically correct.
[removed]
&gt; people push that it's going to prevent bugs and help avoid mistakes Well, it does. It forces you to take care of potential null/undefined scenarios. And since there is control flow analysis going on, it isn't nearly as annoying as one might think. &gt; TSLint is only slightly better than ESLint in that regard. Non-nullable types are handled by the analyzer/compiler.
You haven't moved some existing codebase over to TS with non-nullable types, have you? Because that's the only way to properly confirm this. Not taking care of all potential null/undefined scenarios is a very common mistake. Your code most certainly contains a few of those cases as well.
I've never had this issue in 8+ years of JS dev. So either I and everyone I've worked with are some freak anomaly, or it's a trivial problem to avoid. I'm sure they would be hard to track down. I've had issues that were difficult to debug where I get some data from an API that I expect to look like X but turns out to be Y, but if you're writing your code with type checks in the correct places (i.e. the input to your app), I don't really get how up end up with null instead of a number. Regardless, that wouldn't make the argument invalid. An argument is only invalid if and only if the conclusion does not follow from the premises. It follows that if you write well written code with respect to types, that type errors aren't a problem. It more than follows, it necessarily entails. So no, the argument isn't invalid. It's just seems that you feel a large portion of the dev community cannot write code which doesn't produce type errors like this, from experience I'd agree with you since most JS devs didn't start out in or haven't learned a strongly typed language so they make these mistakes much more commonly. I think my point stands.
I get your point about the extremely simple questions. But I do like seeing the more advanced questions. I've asked a few myself about the internals of v8, or an implementation difference in fetch in chrome vs. safari. These type of questions I think are interesting and provide a good opportunity for learning for the community.
There's also `unfetch` which implements almost everything needed and is based exactly on native `fetch`. There's also thin wrapper `isomorphic-unfetch`. Both are by another well-known author in the community. No matter how famous, who and what is the person, it not mean he shouldn't check for existing things. Starring and using things just because creator is famous not means anything. Not to mention that there's no services activated - Travis/Appveyor and coverage. Actually, there's npm script for coverage which uses CodeCov. But first, this requires to clone and run, second this way of using codecov is overhaul. There are tons of people that use it that way. Of course anyone is free to use it as he want, but absolutely not make sense when you can set few bytes/characters as after_script on travis. Having such tools as devDeps is too much. Not to mention the `axios` which is gaining popularity and is used very much too.
&gt; You haven't moved some existing codebase over to TS with non-nullable types, have you? Because that's the only way to properly confirm this. Why would I need to migrate a code base over to TS to solve a problem I don't have? I'm not saying it's not a common mistake, I'm saying it's one which is easy to avoid. Up until the 20th century improper hygiene was a common mistake which caused a lot of people to get sick. It's pretty easy to avoid with some soap and water. Because something is common doesn't imply that it's difficult to correct. &gt; Your code most certainly contains a few of those cases as well. What are you basing this on exactly, the fact that your code does?
Syntax errors aren't a problem because the compiler catches them for you.
Heh, as if a glorified linter has any clue what the value will be at runtime. Because we certainly can't get any values from a billion places that Aren't Our Linted Code. This is why I don't like things like TypeScript or ES6 "classes"... they give people tunnel vision. They really start believing that JavaScript has class OOP and strong typing.
No, types have a very different effect than premature tests. They *make* it possible to do large amounts of refactoring and rewriting. Being able to rename nested properties and functions in one place and having your editor update the rest of the project, or change parameter types easily and fearlessly really speeds up the early development cycles. You end up with a better, more clearly expressed prototype to work from. One of the best ways to start a project is to write down some types.
&gt; to solve a problem I don't have? It would make you aware of the instances where you didn't handle null/undefined properly. The thing with NPEs is that not triggering them doesn't mean that everything is perfect. It just means that you or your tests stayed on a path were that didn't happen. &gt; I'm saying it's one which is easy to avoid With non-nullable types, yes. (Funny how your analogy basically agrees with this.) &gt; doesn't imply that it's difficult to correct Once that runtime exception was thrown, it's of course easy to fix. Problem is, putting the application in a state where that happens is often coincidental. It might even be impossible right now, but this can change when you add/change an unrelated feature in the future. &gt; What are you basing this on exactly[?] Based on feedback by teams which moved their code to non-nullable types. &gt; the fact that your code does? That, too. TS' analyzer did make me aware of many cases where I didn't think everything 100% through. It's a somewhat humbling experience, but also kinda enlightening. Non-nullable types really is one of TS' best features.
Please note that cookie expiration alone is worthless if you don't also keep the session state server-side. The client can simply lie and keep sending the cookie. Don't trust the client for anything, ever. So, either keep a list of session id + expiry time on the server and always check that the session id you receive for any cookie is still in the list (known as "stateful session"); or fill the cookie with a JWT (JSON Web Token) with expiration (known as "stateless session"). In both cases you will probably want to extend the expiration time every time the client makes a request. With JWT this makes thing a bit more complicated, because you have to change the JWT, hence the cookie value, but you can get multiple requests in parallel from the same client, so eventually you will have race conditions where the JWT has been changed to include the new expiry date, but you still get a few requests with the old JWT. This isn't terribly problematic usually because we're talking about seconds and your session length is most likely a few orders of magnitude larger, so those stray requests will still be valid and will get honored. Just mentioning it for the sake of completeness.
This is a popular misconception. TypeScript does just as well with functional paradigms as with anything else. The article has it wrong and it's clear the author doesn't understand the language. Here's his example of strongly-typed currying, fixed to correct his mistakes: type Transformer&lt;T&gt; = (x: T) =&gt; T; function add(x: number): Transformer&lt;number&gt;; // Ambient declaration of a type interface. function add(x: number, y: number): number; // Another ambient declaration for a different signature. function add(x: number, y?: number): Transformer&lt;number&gt; | number { // This declaration, in the presence of the two ambient declarations, will not be recognized by the tooling as a 3rd declaration, since it encompasses the first two cases. if (!y) return (z) =&gt; x + z; // notice 'z' is implicitly typed return x + y; } // now obviously the type declarations on these next 4 lines can be eliminated, because the compiler implicitly types // all of these variables. I put the types in to explicitly show the compiler errors that occur when you try to // treat the output of add() as "any", which the article insists is the only way to do this. const Add10To: Transformer&lt;number&gt; = add(10); // strongly typed Transformer const x: number = Add10To(20); // strongly typed x const y: Transformer&lt;number&gt; = Add10To(20); // error, number returned. const z: number = add(10); // error, function returned. I'm not selling TypeScript as a panacea for all problems, but it certainly takes a huge bite out of the majority of them found in JavaScript. 
Already posted here, before few days. Not exactly the opened bug but an article that points that too.
&gt; compiler catches them for you. This is what is known as a syntax error.
&gt; It would make you aware of the instances where you didn't handle null/undefined properly. This implies I have instances where I didn't handle null/undefined properly, I've already indicated that this is not the case. If it was the case, I wouldn't be having this discussion. &gt; The thing with NPEs is that not triggering them doesn't mean that everything is perfect. It just means that you or your tests stayed on a path were that didn't happen. So your recommendation is that I should migrate a code base for an error which might not exist, and if it does exist has no negative side effects? I'm just making sure I understand you correctly. &gt; With non-nullable types, yes. (Funny how your analogy basically agrees with this.) Or, you know writing good code as my original comment suggested. This attitude is so indicative of modern JS dev. I've seen people use jQuery because they can't manage to do even the simplest of DOM tasks without it. I've seen people use React for a simple static page. This is simply another instance where you want to throw a pile of technology at a problem that simply doesn't require that level of tech to solve. There are plenty of valid use cases for TS, this just isn't one of them. Sorry. &gt; Based on feedback by teams which moved their code to non-nullable types. Did they migrate their code to solve this problem? If so, please refer them to me. I could save their company thousands in dev costs by firing some people. &gt; Non-nullable types really is one of TS' best features. That very well may be, but as shown, they aren't needed to solve this use case. 
Now imagine how great it would be if the compiler could catch type errors for us as well. Then we could focus our energy on solving the actually difficult problems instead of congratulating ourselves for being such awesome type bean counters.
Sorry you misunderstood. I'll try to be more clear. The point is: you don't make syntax errors. If you need the compiler to tell you that you're making syntax errors, you're doing something wrong. Likewise with type errors. Sorry if this hurts your feelings, but it's the truth. 
&gt; This implies I have instances where I didn't handle null/undefined properly, I've already indicated that this is not the case. How would you know? You've done nothing to confirm this. &gt; if it does exist has no negative side effects? No negative side-effects like a land mine you didn't happen to step on. That doesn't meant that you can't step on it in the future.
You are basically arguing that someone who can count faster on their fingers is better at math than a mathematician.
I know because I validate input when it comes in, not arbitrarily throughout the app. I know because I've got 8+ years in JS dev and haven't **once** had this problem come up. If you think not ending up with `null &gt;= 0` in your code is some insurmountable problem requiring an entire superset of the language to avoid, then you might need to do some more learning. I think this discussion has run its course with regard to usefulness for both of us. I realize you really like TS, and that's awesome. Keep using it. I've used it and enjoyed it myself. But, I can't really take you seriously if you think TS is the best solution to this problem.
https://imgur.com/a/S3ebp
&gt;Is this just trolling? Honestly, this question should be more directed to yourself than to u/pizzarollexpert. Maybe you and your team have achieved perfection and have become one with the machine, but the rest of us are just mere mortals. Us mere mortals don't write good code one hundred percent of the time. And it's not just because one reason, we get tired, distracted and yes, even sometimes stupid. TypeScript counteracts some of the tiredness, stupidness and distraction to help mortals write good code more often. Also, I'd recommend looking up "argument ad absurdum". It's a technique we like to use down here to help people see the absurdity of their claims. Some of us sometimes mistake it for the act of trolling, but I understand that you might not be well experienced with the intricacies of our affairs.
[Ackshually...](http://www.pngall.com/trollface-png) * `% node` * `typeof(0/0)` * `'number'` 
&gt; I know because I validate input when it comes in, not arbitrarily throughout the app. There are many APIs which generate undefined/null values. And JS creates some more on the fly when you access non-existing properties or walk outside an array's bounds. Also, non-nullable types let you communicate that neither null nor undefined are acceptable values. This frees you from considering those cases and it does of course also make it clearer how to use your APIs. &gt; if you think TS is the best solution to this problem I do think TS is the best band-aid to make JS scale.
Sorry if I hurt your feelings. I'm not implying any of the things you seem to attribute to me. I'm simply saying that suggesting you need an entire superset of javascript to not end up with `null &gt;= 0` in your code is pretty silly. I agree that using typescript probably solves this problem for a lot of people. However, implying that it's the best solution or even the only solution I think is sadly misguided. /u/PizzaRollExpert 's comment wasn't an example of argument ad absurdum. The technique is used to show how a position would lead to an absurd result if taken to its logical conclusion. The logical conclusion of writing good code is not writing everything in assembly. Hence why I asked if he was trolling. The comment simply doesn't make sense. Hope this clears things up.
Signed zeros are actually part of IEEE 754 standard. Any language that uses standard floating point numbers has +/- 0.
/thread
I used to use it, but it was complicated... observable and observableArray drove me nuts. or things like adding components inside components things that with newer frameworks are easier to deal with
sure. you can just do something like ``` const simpleAddition = a =&gt; b =&gt; a + b; ``` if you'd like to do the same but with partials it's a little bit more interesting, but you can still accept as many arguments as you want ``` const uselessLogger = (...first) =&gt; (...second) =&gt; console.log(...first, ...second); ```
Taking their example function add(a, b) { return a + b; } const add20to = add.bind(null, 20); add20to(100); // -&gt; 120 add20to(230); // -&gt; 250
You dont. Store a description of the effect of each item and have a function do things based on the stored effect
Almost. Let me put up a JSFiddle or something to explain what I mean. You should only serialize data, not functions. 
Good to know, still pretty weird though. I'm sure there are reasons for it that people much smarter than me could explain. I've always just considered it an oddity. 
Why does each item need a unique buy function? You could do something ridiculous with `eval` and `toString`ing the function, but there is a reason the only solutions available are hacky, insecure, and inefficient. This is not a good way to do things. 
The problem is that &gt; null &gt; 0 // false &gt; null == 0 // false Is a similar problem with SQL languages in that those statements are unknown values to compare, so they cannot be true, because they cannot be evaluated as you do not know one or more of the operands. Thus, they are not true (false). So, for those reasons I would not characterize this as both greater than AND equal.
Hmm... I don't get how I would be able to do something like that. The only way I can think of solving this right now is by creating a new function that takes an item as a parameter and then does a bunch of if statements to see if its the right one: Game.purchaseItem = (item) =&gt; { if (item == 'MagnifyingGlass') { Do this } if (item == 'Item2') { do this } etc... } This seems like a pretty shitty solution but if its the only way... I guess ill get started Appreciate the input
Because when you purchase an item, it does something specific. For example, buying item1 will unlock item2 as well as increase damage buying item2 will do something else etc etc 
I replied to him in another post: http://reddit.com/r/javascript/comments/6xl8sm/javascript_the_curious_case_of_null_0/dmhmxj5
Thanks man!
&gt; I'm simply saying that suggesting you need an entire superset of javascript to not end up with null &gt;= 0 in your code is pretty silly. If that were the *only* benefit, I might be inclined to agree with you. But it's not the only benefit, it just so happens to be one that relates to the original post. The only thing here I can see that is misguided here is the notion that if people just wrote good code there would be no problem. In an ideal world, yes, people would write good code, but this is not an ideal world. People make mistakes, you cannot eliminate the propensity for people to make mistakes. Also, as for the argument ad absurdum: * Your argument reads as: don't use better tools just learn how to write good code. * Their response is: Then why not just write good code in assembly (arguably the most basic tool). This is the logical extreme of your generalised point. Textbook argument ad absurdum, not necessarily the best one (or the worst) but undeniably one. And certainly not trolling, especially when your post can be reasonably interpreted as: &gt; Well, just stop being such an idiot and you won't have this problem.
I mean, I use functions for everything, but I don't see why this has to be saved to local storage. Is this not a hard-coded aspect of your game logic?
You can always cast back into an instance of the object using Object.assign but that also comes with a set of issues itself. You would be better off having a generic function though. Basically store data that says item one unlocks item two on whatever action. And whether that has been completed or not. Then simply have a function that checks if it is unlocked based on whatever items they have. So really, redesign your game item structure :)
&gt; If that were the only benefit, I might be inclined to agree with you. But it's not the only benefit, it just so happens to be one that relates to the original post. Yes, but we're not talking about whether or not to use TS. We're talking about if TS as a solution for this problem, so it would seem that you do agree with me. &gt; you cannot eliminate the propensity for people to make mistakes. Yes, you can. It's called learning. &gt; Your argument reads as: don't use better tools just learn how to write good code. No, my argument reads as I wrote it. I meant exactly what I said. If I meant this, I would have said this. &gt; Their response is: Then why not just write good code in assembly (arguably the most basic tool). Everything else wrong with this straw man aside, you cannot write web apps in assembly so this isn't a viable solution. You might as well say "Why don't you write everything with pen and paper"; it's nonsense. &gt; This is the logical extreme of your generalised point. No, my generalized point is exactly what I wrote: &gt; Good code protects against it as well, and doesn't add a transpile step. If you want to use better tools, be my guest. Just don't assert that you *need* TS to avoid this error, because you categorically do not. There are a ton of benefits to using TS, it just is not necessary to solve this problem and neither you nor anyone else has demonstrated in what way it is. &gt; especially when your post can be reasonably interpreted as: Well, just stop being such and idiot and you won't have this problem. If you interpret it this way, that is on you. I'm not responsible for that fact that you read a sentence not stating or even implying this and seem to read this message from it. You seem to be extremely defensive as if I'm somehow attacking you, when I've done nothing of the sort. You've continually attributed ideas and words to me which I didn't put forward. I'd appreciate it if you'd knock it off. If you want to discuss what I actually said, instead of putting words in my mouth we can do that. Barring that, I think it's best we agree to disagree. 
Hmmm... I guess I can make a new function that just checks which item you just bought and do something with that.
localStorage has a list of all of the users's items. Iterate through that list, looking at the type, and then instantiate the object. There's a whole bunch of ways to skin the cat, and I'm sure I'd refactor away from this at some point, but try something like: let items = { 'magnifyingGlass': MagnifyingGlass } localStoredItemData.forEach(item =&gt; { let instatiatedItem = new items[item.type](item.properties) instantiatedItems.push(instantiatedItem) })
Just wanted to point out their example contains an error because it removes context by applying the function to the context `undefined`. Any realistic implementation shouldn't change the execution context of the returned function.
MMMmmmmm I see... That makes sense. Thanks man!
First off, there are a bunch of ways to do everything, and thats part of the fun. I think you're on the trail here from the comments, but one way i'd imagine it working would be treating the items like a database, all items as a hardcoded array. [ { id: 142425252352, name: 'MagnifyingGlass' }, { id:119141945149, name: 'Gum' }, ... ] Then a player only needs to maintain a list of item ids that they have. `items: [142425252352]` The hard coded items never change, you just add and remove from the player's item array. Then on rebuild or whatever you're doing, you just look at the players items, find each item by id, and run the function or whatever you have planned.
Yea although im struggling, im loving every bit of it. Thanks for the input! I think I finally solved figured it out though.
&gt; Is it really that controversial to think that you might be able to write a code that doesn't pass null to functions that operate on numbers? You're looking at it from a 1-level-deep interpretation. You have to think bigger. Sure when you call an interface for a low-level function, it might be obvious that you're supposed to pass in a number. What happens when the codebase grows and another team consumes it, and that low-level function is now 10 levels deep in a call tree? And that value that makes it down there comes from that high up is on a structure that's on a structure that's on another structure, and when creating that structure, the developer forgot to add the number. Because they are human and made a simple mistake. And because it goes through 10 layers of functions to get to its final destination, you have to rely on every one of those layers doing perfect unit testing, but each level leaves open the possibility of yet another mistake being made. And that deep-down function only gets called once out of every 10,000 times the algorithm is run. And it completely blows up in production, because it missed all your tests due to two simple oversights, and now you have a null accidentally being passed into a function that expected a number. This stuff happens in the real world. All the time. This is what TypeScript protects you from. 
&gt; The point is: you don't make syntax errors. If you need the compiler to tell you that you're making syntax errors, you're doing something wrong. Ahh. You're one of *those*. You *never* make errors in your code. I get it now. I bet your shit doesn't stink either. 
&gt; Heh, as if a glorified linter has any clue what the value will be at runtime. Because we certainly can't get any values from a billion places that Aren't Our Linted Code. The oldest axiom in computer science is "GIGO". Garbage In, Garbage Out. You give me shit data, you're going to get shit data in return. We provided you with the tools to send the correct data into our API. If you willingly send us the wrong data, I don't care. I'm not wasting valuable CPU cycles holding your hand because you are too stubborn to use tools that make your life better. 
Ok I took a look at your code, your issue is your items know too much about the game state (which tabs are hidden, what's available, etc). You are mixing behaviour (functions) with data (properties, like 'price'). Without rewriting too much of your code you could: - Take out the `buyFunction` argument from the Item constructor, - Create a 'Game.buyFunctions' lookup (`{}`) that lives elsewhere, that keys item id (something unique, maybe `name`?) to the function that runs when the item is bought - `Game.buy(item)` could be a function that buys the item, and also calls the 'buyFunction' , i.e. `var buyFn = Game.buyFunctions(item.id); byFn();` That way, items are dumb objects, and it's elsewhere in the game that knows about special item behaviour ---- Consider splitting out a `store = {}` object where all of your game state goes into, as per /u/paypaypayme 's comment below. Keep plain data in the store (strings, numbers, nested objects, nested arrays, etc) -- no functions. Saving and loading the store into localStorage then becomes quite easy. Just convert to / from JSON. If you really need things that have custom behaviour, then create special classes, but don't give them any data on `this` -- instead give them a reference to something in the store (e.g. `store.items[3]`) -- they can modify state in the store in-place 
&gt; You're looking at it from a 1-level-deep interpretation. I'm actually not. I'm looking at it from the perspective of validating input *when it enters the application* rather than on every step of a chain 10 levels deep as you suggest. If I call an API and I'm looking for the property `numberOfUsersOnline`. The first step is **always** **always** **always** to make sure that that property is a number. I can then be 100% certain that no matter how many levels deep, no matter what functions are called, the value that I'm passing around is a number. In general, I approach app architecture with a very simple philosophy. My app is a "perfect world" where all values are **necessarily** valid. Nothing is allowed to enter that perfect world without being validated, no API calls, no user input, no mouse coords, nothing. If there is an error, it is always in validation, not in a function which checks if one number is bigger than another. This eliminates the need for unit testing across the majority of the application. I'm open to the possibility that me and my team are approaching development wrong, but it's worked out very well so far and I have no reasons to change this philosophy. I get that typescript solves that problem. I never said that it didn't. I'm just saying I don't have any evidence or experience which leads me to believe it's the only solution or even the best solution to this problem. Surely we have to agree that TS isn't the **only** solution to this problem. So the only question remaining is whether it's the best solution. It might be for your team, but I still haven't seen an argument to convince me it's a better solution than learning how to avoid the problem all together in plain old boring ass javascript. 
That might make sense. You could also save all of the functions in an object, then save the key names to localStorage. const buyFunctions = { axe: () =&gt; console.log('axe stuff'), sword: () =&gt; console.log('sword stuff') } const buyKey = localStorage.getItem('savedItem.buyFunc') savedItem.buyFunc = buyFunctions[buyKey]
Is there a demo of this by any chance?
&gt; The first step is always always always to make sure that that property is a number. And you will forget this at some point. You are not perfect. You will never be perfect. You can boast all you want that you won't forget it, but you will. And you'll cost someone a shitload of money for something stupidly simple that could have been avoided if you weren't so busy making love to your ego. 
I make errors all the time, just not this error. My shit smells horrible.
You're right, we should all use Typescript. Anyone who doesn't is an egotistical asshole who's going to ruin the internet with their shitty code. Holy fuck, how could I have been so very wrong? Thank you for showing me the light! Just take a deep breath, and chill. It'll be ok, guy. Look, if you've got a good reason why I should use Typescript to avoid this insurmountable problem of passing null into the gte operator, I'd love to hear it. I'd love it you could actually teach me something new instead of just randomly insulting me for daring to oppose the typescript gods. As it stands, you're just being rude.
&gt; I make errors all the time, just not this error. ROFL. Ok. Bye. 
Thanks a lot. I was messin with my code and actually did what you mentioned here. Made a separate function for buyfunction. Really appreciate you looking through my code and helping me out with this!
Listen. I gave you an example. It happens. All. The. Time. Here's some code. Imagine 7 or 8 more layers of function calls added to the calling tree. There's a billion ways Javascript can accidentally leave out a value and have a struct passed around in a completely invalid state without anyone realising it. function isValid(num) { // everyone will clearly see that this function accepts "num" which means "number" and // therefore nobody will *ever* be stupid enough to pass in a null. What kind of moron // would do that? return num &gt;= 0; } function processStruct(struct) { doSomething(struct.value1); doSomethingElse(struct.value2); doSomethingElser(struct.value3); if(new Date().getMilliseconds() == 0 &amp;&amp; isValid(struct.value4)) { doSomethingVeryImportantThatShouldOnlyHappenInVeryRareCircumstances(struct); } } function processWidget(widget) { doSomethingWithWidget(widget); processStruct(widget.struct); // kaboom. } doSomethingWithWidget(widget) { if(widget.shouldCreateStruct) { widget.struct = { value1: "man how about that breakup I'm going through", value2: "shit I can't keep my mind on my work, I don't even realise I'm forgetting value4.", value3: "oh well, I'm a perfect programmer that never forgets anything." } } } 
I rarely ever use null in JavaScript. Wherever null is used I will use undefined. Is there a good use case to use null in JavaScript? 
The best part is it's also `&lt;=` by the same rules so `null &gt;= 0`, `null &lt;= 0` and `null != 0`.
What's the result of Infinity &gt;= Infinity? On phone can't tell Edit. It true but that's not the ?
Infintiy &gt;= Infinity === true Oh wait and not or Infinity &gt; Infinity === false Infinity === Infinity === true So that doesnt work 
I agree a lot of times I see ppl trying to be clever in 2 lines instead of clear in 10 lines. I'll take clear over clever 95% of the time
1. Always use pure functions, this code is almost entirely side effects. The only pure function is the `isValid` function at the top. No wonder you have difficulty debugging this kind of stuff. If you're mutating your data willy-nilly all over the place like this, you're going to have a bad time. 2. Don't arbitrarily create data structures without a schema. I literally **never** use object literals like this in my code for this exact reason. Create a simple factory that accepts a schema and the relevant configuration, and returns an instance of the data structure it represents. This will save you a lot of headaches. Or you could use typescript, whatever works for you. Just my two cents, but these problems can be avoided by simply sticking to a few best practices.
Agreed. Clear code is essential. Clever code is for golfing.
It's just a consequence of having a dedicated sign bit. Since you have that, all numbers will have a positive and negative representation.
Thanks
I use Alt+Shift+F in Sublime text but quite often it messes up something, especially after a comment or a conditional statements 
Sure. Just like good code doesn't need linting, saving another step. Hell, why not write it pre-minified? You're a good developer aren't you? Shouldn't be a problem. ...I get what you're saying. No, Typescript is in no way necessary, especially when you're a very competent and experienced developer. But most of us work on projects with different people, of varying skill, who come and go from projects over time. The point of linting or using TS is to (very easily) establish a base line you can guarantee everyone will work to. It makes everyone's lives easier in the long run.
Semantically speaking there is a clear difference: an undefined variable has not been defined. A null variable *has* been defined - as null. So, If I write var currentItem; currentItem is set to undefined. I haven't said whether there is or is not a current item, just that the concept of a current item exists. Then, if I type currentItem = null; I am explicitly stating that there is no current item. Personally, I always use null because I'm not really in the habit of declaring variables without an initial value (that is, those two lines would always be combined). But in reality, I can't really think of any time this difference has mattered in a project. 
Sure, but I'm not talking about whether you should use TS in general. TS is great. I'm talking about whether you should use TS to solve *this* problem. I'm glad you at least understand what I'm saying. I seriously don't get why I'm getting flamed so hard for encouraging better coding habits over covering up bad coding habits with tooling. It's like I said "Hey guys, let's all kick puppies" or something. Sheesh.
I think the issue might be that you're not encouraging better coding habits, you are *requiring* them. So someone new to a project has to be trusted to not make a single mistake from day one. Most projects relying on that logic do not end well. TS is just a safety net that checks a person is not making mistakes like that. But yeah, heated discussions about programming languages are almost always blown up to the point of absurdity. Maybe we can all just agree to hate CoffeeScript instead.
All I see is a GIF and no runable example. 
If you're using Node, you can just `require` the JSON file, and it will return a JS object. 
I usually do const curry = (f, ...prevArgs) =&gt; (...newArgs) =&gt; f.apply(null, prevArgs.concat(newArgs)) const add = (a, b) =&gt; a+b; const add20 = curry(add, 20) add20(44) // 64
Fair point, but TS also has a barrier to entry. If given the choice between a barrier which teaches my team good habits useful across all languages, and a barrier which relies on domain specific knowledge and a specific tool that may not be around in a few years, I'll choose the former. I think TS is a good project. I haven't adopted it on our team simply because the problems it aims to solve we've already solved in through other means. And we can for sure agree to hate CoffeeScript. :) 
How experienced are you? If you've been programming for a while just referring to mdn (mozilla) has plenty of reference material.
https://learnxinyminutes.com/docs/javascript/
When not using Ramda's implementation, where simple Higher-Order arrow functions (`a =&gt; b =&gt; c(a, b)`) do not suffice, I use this: // used as a placeholder argument to curried functions. // this is useful when you want to target exactly which arguments // are curried. eg: // curriedFunc(__, a)(b) === curriedFunc(b, a) export const __ = { '@@placeholder': true } // generic curry function. inspects for virtual arity first. arguments can also be passed // directly to `curry` for the purpose of partial application. export function curry (func, ...args) { return curryN(getArity(func), ...args) } // curries a function to a specific supplied arity. arguments can also be passed // directly to `curryN` for the purpose of partial application. export function curryN (expectedArity, func, ...initialArgs) { // set a virtual arity on `._length` that is the sum of expectedArity minus supplied // argument length return setArity(expectedArity - initialArgs.length, function (...restArgs) { // concat partially applied arguments with arguments supplied to curried function const allArgs = initialArgs // here we check if the initial arg is a placeholder, if so, we replace it with the // first argument supplied to the curried function (if available) .map((arg) =&gt; isPlaceholder(arg) ? restArgs.shift() : arg) .concat(restArgs) // if arguments still contains placeholders or supplied arguments // still doesn't match expected arity, then re-curry if ((allArgs.length &lt; expectedArity) || allArgs.some(isPlaceholder)) { return curryN(expectedArity, func, ...allArgs) } else { // make sure the returned function passes its context return func.apply(this, allArgs) } }) } // utility for checking if value is a placeholder variable function isPlaceholder (value) { return value === __ } // a virtual-arity aware utility for getting the arity of a function function getArity (func) { return func._length || func.length } // sets a virtual arity on a function and returns the function function setArity (arity, func) { func._length = arity return func } But try to stick to simple arrow functions that accept one argument at a time, returning arrow functions expecting the next argument where you can. While repetitive, it's a lot easier to understand, and is much faster - only use wrappers when your "curried" function exceeds three arguments; and even if so; consider named parameters using an object or a `Map` instead, throwing errors when properties are missing.
Well... How are any of those concepts different for TypeScript than for any other variant of JavaScript?
Like 400% CPU utilization for an hour at a time, if you're converting 4k videos like me. And that's with native C++. In js, it would take anywhere from 10% to 1000% longer, and it would have to be carefully managed so as not to crash the browser, use too much memory, or get flagged as a runaway script. This has nothing to do with your computer. It has to do with the browser environment. You can trigger these processes from js, using a locally run node server that runs shell commands, but that isn't doing the conversion in js.
&gt; async/await is the only thing that seems significant You aren't using a functional programming style, then, I take it? The simple inclusion of a map function has done more to change how my code works and remove potential bugs than anything else. No more loops, thinking of code in terms of series of transforms, etc. That's a huge change. &gt; JavaScript doesn't belong in the server? It has as much right as any other language. &gt; Well, it didn't, until Node.js happened Node was not the first server side js engine. &gt; You can write [any] language I can think of, in the most basic text editor, compile it and run it The compile step is called "build system" in js, friend. &gt; It just baffles me that starting development locally isn't equally easy. It's still easy. Technically, it's even easier today, since you can create, edit, and run js programs fromwithin the browser's console, so you don't even need files or a text editor. You just open a script tag on a page and go. Literally easier than any other language. After all, what language already has the environment, compiler, and output area not only installed by default by the OS, but is already running given typical user OS usage. No, js is not any harder. You're upset that the problems we solve with js are harder, and the tools we use to manage that complexity is not what you would prefer. But you simply can't solve those problems without it. Doing so would just mean reimplementing those complexities in your scripts, at runtime, and probably with more errors.
I've referred people to [this article](https://bonsaiden.github.io/JavaScript-Garden/) for a decade now. Ignore anything about performance.
weird and interesting. Object.is(-0, +0); // false 1/+0 == 1/-0 // false
&gt;You've continually attributed ideas and words to me which I didn't put forward. I'd appreciate it if you'd knock it off. I'm sorry that nobody seems to be able to comprehend your brilliance. Have you considered that it could possibly be that you are unable to communicate clearly or maybe that your ideas suck?
&gt; TS' analyzer did make me aware of many cases where I didn't think everything 100% through. It's a somewhat humbling experience I don't think this guy is one who likes to be humbled. He actually says he's never made a null error in his career. It's almost incomprehensibly absurd. Glad you're getting help from a valuable tool though
Believe me, it's way better for you if you don't assume anything about programming when learning JavaScript.
When shown that you're wrong, you reply with "your ideas suck". Stay classy and enjoy middle school my friend.
Just ensuring that my communications match the ability of their target audience. ;)
&gt; functional programming I do use it, but not as much as I should. However, unless I missed something obvious, in this regard, ES6 just added things you could already do with lodash. Do you have any specific snippets that you consider a very important change - that doesn't exist in lodash, or is better than lodash in ES6? Oh, and Sets are nice. Yeah. &gt; It has as much right [to be server side] as any other language. Yeah, of course. I was referring to the general scoffing from practically all existing server side developers when Node.js was introduced. And sure, there might have been others (that one clunky Netscape server comes to mind), but Node.js was the first significant one, I think. &gt; compile == build system I very much disagree on this, but I guess I see your point. &gt; Browser debugging tools Yeah, true, that's a very good point. The fact that you can develop anything from a calculator to games to Steam or Spotify in JS (mostly...) with a text editor and a browser is pretty cool. I remember when a compiler would cost my parents a whole salary. &gt; You're upset that the problems we solve with js are harder, and the tools we use to manage that complexity is not what you would prefer. Oh man, I think you nailed it. But, like you mentioned in other scripts, I think there is a lot of things I can skip for months of solo development - minifying, tree shaking, ES5 support, SCSS. Then there features that really are nice to have - like live reload, but still not crucial for me. The only cool feature that is really complex to do by hand is Angular's CSS per component - I admit that's pretty neat, but again, on a small project, it really doesn't matter if you shove the CSS into one file and keep a consistent naming scheme. The value of those things grows exponentially with number of developers on the project, and increases with time. But there's still a lot of projects that will never grow that much, or will just be abandoned before they grow. BTW thank you for the conversation, I appreciate your time.
My JavaScript books assume programming knowledge and are free to read online: http://exploringjs.com
If you're into programming languages, You Don't Know JS is an excellent resource. It's also free online.
You don't need to do that. What you need to do is separate _state_ from _logic_. &gt; Because when you purchase an item, it does something specific. For example, buying item1 will unlock item2 as well as increase damage This is fine. But this is not _state_. "buying item1 will unlock item2" is _logic_, and you don't need to store that. In fact, you don't need to store the characteristics of item1 or item2. That is not the _state_ of the game. Those are part of the _initial conditions_. _State_, what you actually want to store, what represents the progress and status of a particular game, is whether you have bought item1 or not. ---- Now, it _may be_ that you have a complex and costly initialization phase. That is, that generating the initial conditions themselves is a costly operation. Or that you have _random initial conditions_ and you want to save those. But again, you would need to save _only_ those initial conditions, not the logic of operation of those. That is, you define a series of operations, say... var itemInteractions = { unlocks: function(item) { // unlock(item); // Or whatever logic you need to do }, modifiesProperty: function(prop, value) { // setProperty(prop, value); // whatever } // ... }; Then items don't explicitly _execute_ functions. Instead, they _define_ or _declare_ their interactions. Something like... function Item(props) { // name, price... // item.whenBought = { action: 'unlocks', item: 'item2' } item.whenBought = { action: props.buy.action, item: props.buy.param }; // ... } Game.items['MagnifyingGlass'] = Item({ name: 'Magnifying Glass', price: 10, buy: { action: 'unlocks', param: ['Wrench', 'Screwdriver'] } }); Now all the logic should happen wherever your `buyItem` function is... function buyItem(item) { // ... add it to the inventory, subtract gold, whatever... if (item.buy.action) itemInteractions[item.buy.action].apply( ..., item.buy,param); } All this also has the added benefit of _abstracting_ your code from too much specificity. Imagine, you have 80 items and for each of them you had to declare a specific function such as for item1 `function() { unlock(item7); }`, for item31 `function() { unlock(item3); }`, etc. This is a bad situation. It repeats a lot of code. And the only thing that varies is which item(s) is(are) unlocked. So, clearly, it's something you should abstract into a more generic approach. ---- **Please note**: The sample code shown is not meant to be even correct. It's intentionally _basic_ because it's only shown to express the general idea and intention of abstracting your logic out to separate the specific, the part you actually want to serialize and store. You will need to adapt it to the particular organization of your code. ---- Thanks for the gold - There was no need at all, thank you :)
Thanks for sharing!🙏
&gt; I can then be 100% certain that no matter how many levels deep, no matter what functions are called, the value that I'm passing around is a number. Not all arguments passed to a function X levels deep will be top-level input that was passed all the way down. For example arguments can simply come from local variables in the caller. Those local variables' values are determined by the caller's code. If the top level input was validated correctly on entry, but the aforementioned caller's code has an error, then an invalid argument may be passed to the callee. The only way to get around this is to validate all arguments for every function. This will catch type errors passing between functions at runtime. But only if the code path that leads to the type error is run. True full code coverage means running every possible path, which increases exponentially with program size. A static analyzer can do this with code that is statically typed, without needing to run the program first. In fact they can find the type error right as you finish typing it, and alert you. Also type errors can exist intra-function, so even validating all arguments will not catch them. JavaScript's implicit type conversions can hide these errors. Here's an example of an inter-function type error: function topLevelInput(mouseEvent) { //mouseEvent schema: {x: number, y: number, id: number or null} if (mouseEvent === null || typeof mouseEvent !== "object" || typeof mouseEvent.x !== "number" || typeof mouseEvent.y !== "number" || (typeof mouseEvent.id !== "number" &amp;&amp; mouseEvent.id !== null)) { console.log("Error"); return; } //Correctly validated! handleMouseEvent(mouseEvent); //All good so far } function handleMouseEvent(mouseEvent) { let id = mouseEvent.id; let x = mouseEvent.id; //Whoops, everyone makes mistakes let y = mouseEvent.y; console.log(id === null ? "No id" : "id: " + id); if (validPosition(x, y)) { console.log("It's valid"); } } function validPosition(x, y) { return x &gt;= 0 &amp;&amp; y &gt;= 0; //Whoops, x is null } topLevelInput({x: 10, y: 20, id: null}); //Output: //No id //It's valid validPosition needs to have validation code in order to catch the null error. Validating top level input doesn't catch it. And even if you validate all functions, what if the code of validPosition was not its own function, but was instead inlined? You would need to runtime type check every single expression in your code manually to even attempt to catch all type errors. To guarantee catching type errors, you need to type check all lines of code. The only sane way to type check all lines of code is to use a static type checker.
Now, complex numbers can't really be ordered at all.... Also, a number being strictly greater is usually defined by *a &gt;= b &amp;&amp; a != b*, so a number being strictly greater and equal to isn't possible.
I'm not talking about people maliciously sending bad data into an API — although that can happen too, and if it does, are you going to just let it happen? I'm talking about the fact that bad data can come from many places we don't control. We don't design perfect systems, because there's no such thing. The assumption to control all the factors is one of the biggest fallacies of programmers. Very few of them get this, in spite of being shown by users and QA over and over that shit happens. And it's one of the reasons software is not taken seriously as an engineering branch, because we refuse to acknowledge and deal with the shit. Every other kind of engineer out there thinks about things that can go wrong very carefully, and tries to deal with them, and when they can't they can offer exact tolerances. If they don't they're called a cowboy and they suck. In software it's all cowboys that go "meh file a bug and we'll fix it". TLDR: "Jurassic Park" should be required reading for programmers.
That's not about math or logic here.
You can curry any function using this: const curry = fn =&gt; (...args) =&gt; { if (args.length &lt; fn.length) { return (...restArgs) =&gt; curry(fn)(...args, ...restArgs); } return fn.apply(this, args); }; Which will allow you to use the arguments in any combination of calls: const multiAdd = (a, b, c, d, e) =&gt; a + b + c + d + e; multiAdd(1, 2, 3, 4, 5); // 15 multiAdd(1)(2)(3)(4)(5); // 15 multiAdd(1, 2)(3, 4)(5); // 15 [How it works](http://developingthoughts.co.uk/curried-functions-and-point-free-programming/) 
So in bind the arguments after **context** will be passed as arguments to every subsequent call to the function, and any arguments passed to the function after binding will be appended not overwritten. I did not know this!
I was just joking.
Could you please elaborate on that? 
whoosh
Passing nulls is a classic unit testing technique in OOP. It involves passing only the parameters that are needed for the particular code path that is supposed to be used during that particular test, and using nulls for the others. This is particularly useful when the method signature indicates that certain parameters are objects – so if you wanted to go by the book and actually pass the appropriate type then you'd have to initialize an instance of that object, or have a test double created. And in turn they may need yet more objects for their constructors, and so on and so forth. But if they aren't even going to be used then why bother with all this? Just send a null. Bonus: reduces complexity of that particular unit test, which doesn't have to know about parameters it doesn't care about, so it makes it more likely to remain unchanged during refactorings. Naturally, the language has to allow nulls to be passed instead of the indicated type (and you also have to be careful with overloading). Some do better than others in this respect. Java explicitly supports letting nulls pass through method type checking, as long as they're not used at runtime. PHP would need you to declare all parameters with `= null` default fallback in order to achieve the same effect, but you lose the ability to have meaningful default values, and you'd have to do this manually for each and every parameter declaration, which would be insane.
I messed around with writing a LoD system in three.js a couple of years ago, but as I recall the slowest part of the system was loading the more complex geometry into the scene - that got prohibitive pretty quickly, and compared to that actuarial rendering a scene in really high detail was almost negligible in terms of processing time. I wonder how the author got around this, or whether browsers/three.js have just got that much faster in the last couple of years that it's not an issue now.
JS30 Doesn't seem to assume that 
I also tried to do it with iframe tag but none of the links would load into the frame. For example: &lt;li&gt;&lt;a href='page1.html' target="myIframe"&gt;&lt;span&gt;page1&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;iframe class="myIframe" name="myIframe" src="front_page.html" style="border:2px solid black;&gt;&lt;/iframe&gt; &lt;script&gt;$('.myIframe').css('height', $(window).height()+'px');&lt;/script&gt;
boils down to we didn't like jsx, same tired old nonsensical separation of concerns argument too.
Thank you so much for putting your time into replying. I think you are spot on with the added benefit of abstraction because although there will wont be 80+ items, there will be a good chunk. Reading your comment really helped me wrap my head around this whole process. Time to rewrite my code. Thanks so much!
jQuery? Didn't know it was still used.
yes. god dammit. yes. you use fucking semicolons. Don't believe those bootcamp millenial hacks who code w/o them.
Hi /u/johndavid5, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yes, it was quite challenging to keep 60Fps. The terrain LOD you are probably already familiar with. Using web workers to generate the terrain kept the terrain rendering very fast. The trees were rendered using ThreeJS instance buffer geometry (https://threejs.org/examples/?q=inst#webgl_buffergeometry_instancing2) I had one instance geometry for the tree tops and one for the trunks. The buildings as you eluded to was the big bottleneck. Here are some steps made to keep 60 FPFS. 1. The buildings are procedurally generated and accept an LOD parameter that changes how much detail is rendered. There are five levels of detail. The first two are highest resolution, the only difference is the very highest also calculates the CannonJS collision shapes. The next two levels are simply lower detailed versions. The last LOD for the buildings is a low poly cylinder with a texture mapped to make it look somewhat like the higher poly building. 2. Things like the stairs in the buildings were merged into one ThreeJS geometry to reduce draw calls (This step gave the best improvements). 3. I did not use ThreeJS's built in LOD objects. I ran the logic for which buildings had LOD changes in another webworker and communicated that to the parent based on position changes every 300ms or so. 4. Each time a building is added it was a clone of one of several pre-computed LOD buildings. Cloning is somewhat slow... but it's faster than procedurally generating each building on demand. This step also showed great gains in performance. My goal was to allow up to 300 buildings and I made tweaks until I could hit 300 buildings at 60FPS. It was quite a tedious process but forced me to think of creative ways to achieve my goal. Hope this helps!
Ah yes, proof of concept. Will repost when code is finalized and the project I am working on is open sourced. Just wanted to give hope to those attempting similar effects.
I've been coding for a about a year without them and its fine, honestly there are some edge cases where you need them but most of the time you don't
Depends on the code style you are following. This should be discussed with your team. You can also look for inspiration from popular code style rule sets like Airbnb (requires them) or Standard (doesn't require them)
In most cases, you don't. But there's a few edge cases which can cause weird bugs if you don't. They're rare, but my point of view is that this message has taken longer to read, think about, and respond to than all of the semicolon's I've written in the past year have added to my coding time, so why bother thinking about it? Get in the habit of using them subconsciously, and never wonder about whether you're going to run into the error conditions. 
You can code without them, but there are certain cases where code can be ambiguous and the parser won't know what you mean without them, making the wrong conclusions. For example, if you start a line with brackets: [1,2,3].map(n =&gt; n*2) // [2,4,6] Given some object reference in the code before it, it could be seen as the array access operator (`[]`): [0,1,2,3] [1,2,3].map(n =&gt; n*2) // Error, map is not a function This is because this gets interpreted as: ([0,1,2,3][1,2,3]).map(n =&gt; n*2) // which is ([0,1,2,3][3]).map(n =&gt; n*2) // or (3).map(n =&gt; n*2) A semicolon after `[0,1,2,3]` would have prevented that. Same applies to parens (`()`) for that matter. They will treat a reference before them as a function. (0 || 1).toString() // "1" works fine by itself, but given something before it: console.log("0") (0 || 1).toString() // Error, undefined is not a function That is because this gets interpreted as: (console.log("0")(0 || 1)).toString() // which is (because console.log returns undefined) (undefined(1)).toString() The good news is you can avoid these situations quite easily in your code. If you do so, you shouldn't have any problems with leaving out semi-colons.
is it possible to get the 'press u to update the snapshot' functionality of jest inside mocha? I think mocha doesn't really support plugins so I'm not sure if there's a way to provide an 'after suite' hook.
Pretty ignorant thing to say. So GitHub, Uber, Zeit, zendesk, Brave, TypeForm, NodeSource, Redux, Vue, etc are all bootcamp millenials? Just use a linter. If you do, your style preference on semicolons is insignificant. Just pick one style, be consistent, and enforce that consistency with your linter and `prettier` (if you use it).
Ever since [prettier](https://github.com/prettier/prettier) came out i don't format, it's just a waste of time when now you can hit a button and code falls in line. And yes i set it to remove semicolons because they have no purpose and in the few cases where that is the case, prettier retains them. Try it once in your editor, it's hard to go back to manual formating and linting.
If you use the standardjs linter, you can avoid semicolons and it'll tell you when doing that isn't possible.
Thanks so much! This is exactly what I was looking for.
Real question: Why would the id of your mouse event be null? This may sound like a troll, but this is exactly why good app design is important. If `id` is supposed to be a number, why would you put `number or null` on the schema? These are two different types (number and object respectively). I see no reason for `id` to ever be `null` in a non-contrived scenario.
through the environment variables https://github.com/bahmutov/snap-shot-it#advanced-use
I get what you're saying, but I don't really see how it applies to this case since we're not talking about objects. As an aside, the technique you describe seems kind of risky to me.
In order to be equal to **and** greater than another number, it needs to be greater than itself since if it is equal to another number it is identical to that number.
What add-ons do you use?
Ok i got the sarcasm already. I was just curious if I'm not missing some more magic about Binary Floating-Point Arithmetic. Like you know .2 +.1 &gt; .3 // true
I agree with MPJ, ASI is useless. https://www.youtube.com/watch?v=Qlr-FGbhKaI
https://github.com/request/request
Whether you care about leap seconds or not depends on what you're doing. Even time sensitive operations, such as validating Kerberos tokens, often allow some discrepancies in time synchronization (Kerberos is 5 minutes if I recall correctly).
This is cool, are you storing the images anywhere?
The library you use to fetch the data doesn't particularly matter. I use [axios](https://github.com/mzabriskie/axios) because that's what I've always used. As /u/delventhalz points out, you can also use [request](https://github.com/request/request). The most basic form of this app, you'll want to make a request to the page you linked, process the results (I believe twitter auto-shortens links), and send the tweets. Some questions you may want to ask yourself for such a project. - How are errors handled. What happens if the API doesn't return anything. I'm surprised you don't need an API key to use the API but there are rate limits and you'll want to handle those. - How do you ensure the same post isn't posted twice. Will you be storing the posts that have been tweeted out and if so, in what form. - How will you be scheduling the tweets. Using [cron](http://www.unixgeeks.org/security/newbie/unix/cron-1.html) or a timer in the app.
Thanks :D Nope ! It's all wired through websockets, and in memory (i mean not persistently stored)
I am building something similar but photos are sent via mms (text message)
Nice !! Share the link ;) 
I tried using Axios but didn't get too far. I've been hopping between too many libraries today so I'll just go back to Axios and try to figure that out. It seems to be the most popular library. In regards to the API, do I need an API key just to scan whats on 'hot' page? I am not posting any data to reddit, just grabbing data. I think Axios has a throttle parameter but I need to make sure. Each post has a post ID so I could check for duplicates...but that really doesn't matter if I'm not storing the data for future reference. So perhaps I should do away with the duplicate checking. I will set up a timer in the app. I'm using CoreOS on my server, and Im not sure that you can set up a cron in that environment (everything runs in containers with CoreOS). I may have bitten off more than I can chew with this project, haha. Alas, it will be a good learning experience for me. Thank you for your advice and questions!
`id` is NOT supposed to be a number. `id` is supposed to be number or null. Null represents the absence of an id. Number represents presence of an id, whose value is the number value. In non-contrived scenarios, nullable-types are often used when there is no good choice of value for some type that represents absence of value. So null is used to represent absence. The schema for `id` could also be string or null. It could be object or null. For example `id: null or {grp: number, usr: number}`. Also I chose an arbitrary property name. "mouseEvent", "x", "y", and "id" are just the names I chose for the input. The names can be anything you want. The point is even some simple mistake like accidentally getting the wrong property can place a null value where it wasn't expected. Everyone makes simple mistakes, because nobody is perfect. (Side note: if "id" is non-nullable, e.g. string, or object, then you still get a type error. If `id` is a non-nullable number, then you don't have a type error, although you can for example make the type of `x` and `y` be `Coord` in a static type system.)
When I get it done
Lot's a posts about `prettier` and `eslint` and `standard`; You may find yourself in tooling hell. If you're working by yourself: https://github.com/sheerun/prettier-standard handles both. But these things won't teach you about Automatic Semicolon Insertion, which it would be good to have some grasp of. 
That looks good, thanks!
I get that id is not supposed to be a number in your example. I'm saying that in the real world, a mouse event's id being null seems absurd to me. It's likely the result of a uid function that will **always** return a number. &gt; In non-contrived scenarios, nullable-types are often used when there is no good choice of value for some type that represents absence of value. So null is used to represent absence. I look at the problem differently, if a number is required on a datum, and the datum doesn't contain the number, then the datum is in an invalid state and shouldn't have been created in the first place. This is why it's so important to use factories with proper validation. I take your point overall, that people make typos. The thing is, typescript doesn't solve the problem of people making typos. I appreciate you taking the time to point out these examples. And once again I'm not saying TS is terrible or something, I actually think it's a great tool. I'm just saying it's not the only solution to this problem, which is categorically true. I'm also saying I'm just not convinced it's the best solution. That is not to say it isn't a good solution. I just get a bit annoyed when people suggest migrating your entire codebase to TS is the first and best choice to solve a simple type coersion error that in 8 years of JS dev has literally never caused an issue for me. Let's start with good habits, THEN let's talk about TS.
You're looking at the wrong problem. The number is NOT required on the datum. The number is optional. There are real scenarios where the logic is such that there can be either presence of a value, or absence of a value. I did not say typo, I said "simple mistake", of which typo is a sub-category. People make simple mistakes, and I merely gave an example of one that could lead to a null error. In this example, a static type system, which for the JavaScript world would be TypeScript, would catch this particular error. Of course, no tool or technique can prevent all errors, including, as you say, all errors that can be caused by a typo. But many can be caught.
Word! Kids these days have no manners.
Do we have to talk about it? Edit: /s sorry, drunk on a long weekend. Everything you typed is very accurate
[Why are you loading jimp from rawgit?](https://github.com/nitin42/react-imgpro/blob/7d61f2dd1ed3a0737944225e17da86ccde2fa203/src/worker.js#L6) Seems sketchy
&gt; There are real scenarios where the logic is such that there can be either presence of a value, or absence of a value. I get that this comes up in a lot of code. I just don't like writing code that does this, I mean this case is exactly what default values are for isn't it? So it seems like you're talking about cases where a value cannot be reasonably defaulted to a valid value. These types of cases are exceedingly rare in my experience. Take the entirety of CSS for instance. Every CSS value has a default value. There isn't case where width or opacity or zIndex is a number OR absent entirely, and for very good reason. If a value is relevant to computation, it should be present. I realize that people write code which follows the pattern of something being defined and valid, or absent and undefined, but I think this is actually an anti-pattern. Whether this means that the value is defined on the datum itself, **or whether the API used to access the data** corrects for values not present by returning a default value when a value which is undefined is requested. Once again, I take your point. And I'm not saying that typescript doesn't solve the problem. Of course TS solves this problem. But I think you do need to concede that TS is not the ONLY solution to it. If it's not the only solution, then we need to weigh the pros and cons of the existing solutions and arrive at a conclusion based on those costs/benefits. You and others here seem to be under the impression that the only logical solution to the problem of having `null &gt;= 0` in your code is just migrating your code base to TS as though this is just the default position. The only point I'm making here is that it isn't quite that simple. 
He didn't say ASI is useless, he says you can't do anything about it, so might as well let it do its job.
[removed]
Yes for many optional things there is simply a sensible default. For the rest... if you want to design your code without nullable types, then that is your choice. You could for example use a flag to represent something being optional. I agree you can detect null without static type checking, because you can just compare a value to null. E.g. `if (value === null) console.log("Error");` I can't concede the point though, because it is not a point that I have made, that you can only detect null at compile time and not at runtime. I also made no argument about when to migrate. Personally I haven't used TypeScript in production yet. The web apps I write are moderately sized (5,000 - 20,000 lines) and I either work by myself or with a very small team. I like the workflow, and my clients even more-so, where they can just pull the repository and click on app.html, and it runs. There is no build process to run the app (server data is mocked), only for optimization.
Utf16 needs to die. I would support a fork that dropped it.
Seems like we pretty much agree then. Sounds like you've got a workflow that works for you and your team, and at the end of the day that's what we're all after. I'm glad there are different tools and workflows, it gives us options to work with and we can choose the right tool for the right project. If typescript works for you, great. If not, great. Really the only point I'm trying to make here is that TS isn't the only option. If you're going to use TS you should be using it because you looked at the options and decided it's the best fit for your team, not because you read a thread on reddit that said your code will blow up if you don't use it.
Keep at it. It may seem like a lot but once you break it down you can tackle it bit by bit (no pun intended). For axios, the following will get the information. axios.get('https://api.reddit.com/r/rarepuppers/hot.json', { params: { sort: 'hot', limit: 25 } }) .then(res =&gt; { console.log(res) }) A request like this does not return immediately and [Promises](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise) are used. If you wish to use the information from the request you only have access to it in the `then` callback. There is also a `catch` callback that will show you errors. Check the axios docs for more information. Try working with this first and see if you can retrieve the information and transform it to a format that only has the relevant information that you need.
I think the transition to just should be pretty easy compared to learning js first and going to a static oop language. With ES7 js can be very familiar to those with prior experience, especially if you include things like clojurescript as being "JavaScript". I found out I can write unimpressive Java now that Ive got some experience with C# and js.
Isn't that just sort of faking a curried function though? There isn't a closure being held over add() in the call stack, you're just creating a new function while locking a parameter with bind.
&gt; s and it'll tell you when doing that isn't possible. So much more work and time than to just put in semicolons in the first place. 
Just because you can, doesn't mean you should. Also following the big boys might now be the right thing to do. We've seen what happens when you follow the wrong "big boys" in the past.
In my experience, creating a good and reusable dialog is much, much harder than it seems. For example, you have to make sure that the dialog displays correctly everywhere - position:fixed is not always positioned relatively to the body, but to the closest positioned or transformed element. That means that using a dialog in a nested component will usually break it. Also you have to move the focus to the dialog, trap focus in the dialog - and that's not as easy as it seems - and then when the users are done with the dialog, move it back to the previously focused element. All this behavior needs to work with nested dialogs, too. And then there's accessibility - users who use screen readers will not understand that a dialog with certain content popped up unless you annotate it with proper roles and aria attributes. Or what happens when it closes. And this is probably not even close to being all. I hope browser vendors give either the &lt;dialog&gt; or some JS primitives that help with managing these problems another chance. As it is right now, Dialogs are definitely not easy to implement.
This is... intuitive.
oh dear lord, please never do this. 
So it's not a curried function. It's a partially applied function. The OP asked for an easier way to curry, but the linked article is about partial application. I'm just presenting another way to accomplish the example linked. I would think both of these concepts are out of the "norm" of the typical js developers day to day. Even so there's value in knowing of them. I at times find myself in situations where using these concepts feels like the "right" solution.
Awesome! I see you passed in parameters, where did you get those values from? Someone in another thread wrote this snippet with node-fetch: https://repl.it/KemY/ I am going through the docs right now trying to figure this out. Thank you again very much! ps. Do you have a twitter handle or blog? Would like to follow you if you don't mind. 
It is basically always possible, so no, it's not more work. You were probably already using a linter, this gives you a rare error (never seen it myself) in exchange for never having to type semicolons.
Why
Got it! I should have read the article for a little more insight, I suppose I misread the original question. It's always nice to get some insight on the different quirks of the language. Are there any speed differences between curried functions and partially applied ones?
Where do you want to read that file? On the front-end or purely back-end side? Do you use a module-bundler? There are two cases I want to document, where you can choose from what suits best the situation. With the second option being my best bet to solve your case. You have a dynamic json file, populated by some server and need to use it. Your browser can't directly access a file on your system, but your back-end can. For this, I need to know what existing architecture you are building upon. My best guess is, that you are using PHP or nodejs back-end-side. PHP $json = file_get_contents("names.json"); echo $json; Source: https://stackoverflow.com/questions/4343596/parsing-json-file-with-php NodeJS var fs = require('fs'); var contents = fs.readFileSync('test.json'); console.log(contents); Source: https://code-maven.com/reading-a-file-with-nodejs I think the biggest problem you will encounter here, is how to get that data and work with that on the front-end. You could either create a REST API endpoint and retrieve the data via AJAX. This is the way to securely get data from the server to the client. Building a REST API is a lot of work. Alternatively, if you just want to get going, you could use the second option. You have a static names.json (created just once) sitting in your front-end project folder and you want to use it. If you don't use any module bundler (so you can't easily just do var names = require('names.json')) you could add window.names = in front of the long list of arrays of objects in the names.json file, and include it as &lt;script&gt; and be done with it. (however, this requires that the json file is a js file, which you can just rename) However, polluting the global namespace is frowned upon. If you are using a module bundler, such as webpack, you can use require statements to let the module bundler know which files you need, before they get bundled. This means, that the json file will be used together with your script and you can access the data. Please let me know if that answers your question. Best, Martin
Well, it does end in a question mark. So... yes?
This actually answered the question I had while skimming through the src - "What code/library actually does the work?" (i.e. image processing). /u/squiresuzuki: Why is loading the jimp library from rawgit a sketchy thing? Which source would be more trustworthy?
Labeled statements are called bad practice in JavaScript, however it's always interesting to come along such stuff. You can even assign multiple labels to one statement like: a: b: while (true) { break a; break b; }; Also the grammar says, you can assign a label to literally any statement, but you can only break it within a block. So this is possible too: a: { break a; }
It's unpopular and not very readable, but used here and there like in [acorn.js](https://github.com/ternjs/acorn/blob/3f02658fbf3b2ae9100f265e2c9b2b40d254d20e/src/tokenize.js#L134).
We aren't out of sync. You are simply assuming that computer time is [TAI](https://en.wikipedia.org/wiki/International_Atomic_Time). It is not. It's UTC. In other words, we pretend that leap seconds don't exist and an earth rotation takes precisely one year (with leap year calculations, i.e. 365 + 1/4 - 1/100 + 1/400 days). As you have discovered, the big advantage of this approach is that most software does not need to care about leap seconds at all, and can use simple calculations without ever getting out of sync. If you need precise timings and represent leap seconds, use TAI, and a date library that supports it.
It seems pretty easily readable to me
I don't see what's wrong with this? Who says it's bad practice?
The first parameter is the URL and the second is extra stuff you want to send, in this case it’s the URL query parameters. You can find me at @rmp135 on Twitter and GitHub. 
I never knew the difference! Thanks!
In practice, it generally makes the control flow of the application harder to understand. In javascript, since this is a virtually unused feature, you're very likely to just confuse anyone else working on the codebase with you.
&gt; which seems to solve that problem of having to use gotos in C Isn't this pretty much a glorified goto?
Keberos uses UTC, and is thus not affected by leap seconds. [There's even a warning about misconfigured systems in the source code](https://github.com/krb5/krb5/blob/7e41d97e8dd39833503b74d34e9f0c905a2d4cf2/src/util/support/gmt_mktime.c#L33-L36).
Yeah but goto considered harmful. This safer
&gt; it generally makes the control flow of the application harder to understand. Maybe if you have a 3rd grade reading comprehension level?
http://i.imgur.com/W8ZDyjx.jpg
https://en.wikipedia.org/wiki/Considered_harmful
Thanks for the clarification.
Tbh if you have nested loops in your code it's often an indicator of a much bigger problem
Managing event bubbling manually might be too tedious, unless you use some kind of a tool like [backscatter](https://github.com/tweinfeld/backscatter). Building a flat model for your app, instead of a nested one, could be a good way to go.
Is see semicolons like periods in a sentence. They feel natural and define the end of a line.
https://media.giphy.com/media/13Ev2RtSAxKsTu/giphy.gif
 for for ?
Exactly, being forced to build flat models is a shortcoming in my book.
I'm not advocating that you should follow the big companies. I'm saying it's ignorant to say that your semicolon preference is any indication of your programming ability. Use whatever style you want, but it's honestly irrelevant at this point now that people use linters. &gt; Just because you can, doesn't mean you should. Why should you not omit semicolons?
Well, that's Backbone's essence.. Take Angular for example: Do you feel "forced" into writing its proprietary templates, controllers etc.? If you do, perhaps it just ain't the right solution for you. Same goes for Backbone.
What situation would you have to be in that required breaking out of an if statement?
What about those people who love to post [this link](https://en.m.wikipedia.org/wiki/Betteridge%27s_law_of_headlines)? I'm just waiting.
Non-Mobile link: https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^107953
you should 'short-circuit' your if statements, most of the time you can get away with not having to write else and it makes things far more readable.
but does update prompt the CLI for each snapshot that has changed or does it just update all of them? apologies, don't have my dev computer handy to check.
So, here is my two cents? Is it prettier? Maybe, but when you need them, what are you supposed to do? You can put a semicolon on the line before, but that means that your logical lines and grammar lines have this weird relationship. And if you decide to reorder lines, something will probably break or your commit diff looks terrible. I decided putting semicolons in front of array literals worked best, but that just looks crazy. 
For reals?!? I've been looking for a way to do this for years. I end up doing `do { if (condition) break; } while (false)`
I'm not sure what all the hate is about. This seems really useful when validating user input when you want the return to be on the last line. It makes it so you can skip validations that don't matter when you've already proven it's bad. 
 #HTML html &lt;html&gt;&lt;/html&gt;, head, body, ditto mark &lt;link rel=stylesheet href=style.css /&gt; #CSS&amp;JS semicolone ; it's not an obligation we strongly recommend removing those element in the minified version. Note: var x=0 x=1 Error var x=0 //new ligne x=1 
Unless you're already using a linter, which most large projects are. In which case it's 0 extra effort
&gt; Do you have any specific snippets that you consider a very important change - that doesn't exist in lodash, or is better than lodash in ES6? Nope. I use lodash. However, recall that the recommended way to use lodash is with... a build system, so you can bundle and tree shake without doing it manually every time you change something or lodash changes. ES6 has real tail recursion, which can't be emulated in js at all. That will have an important role in code design just as map (as a concept) did. ES6 can be better compressed than ES5 ever could be. &gt; on a small project, it really doesn't matter if you shove the CSS into one file and keep a consistent naming scheme. How small? If you are working on it for months, even as a solo project, that is far too complex to still be using hand cranked js (or css). Obviously you can do it, but you can also program in assembly. &gt; Oh man, I think you nailed it. ... BTW thank you for the conversation, I appreciate your time. A positive response on a controversial programming topic... on Reddit?! Must have entered a parallel universe. I'm not entirely sure how to respond.
Everything is readable in a four-lines long example
So, I program in several languages that require the use of the semicolon. Semicolons are like periods in a sentence and they just feel natural and explicitly tell me it's an end of a line. I was trying to come up with an example, but even writing one makes me want to toss myself out a 12th story window, since it was so ugly.
acorn.js linked example is also fairly readable.
To be fair, if I had seen the acorn code before reading this thread, I would have been very confused, I think
The problem with goto isn't the keyword, it's the behavior. It's what it leads to. This is only "safer" in that the application of it is limited.
You can short circuit to solve this - return inside the if won't execute the rest of the function
Dude...
Alternatively, the end of a line defines the end of the line?
You seem to be missing the point, which is this: The harmful bit of "goto" is not *typing the word*. The harmful bit is the control flow behind it that smashes whatever call stack you're in and teleports execution to a random place in the code. In that context this is basically a goto by another name, and has all of exactly the same problems.
Everyone.
&gt; which seems to solve that problem of having to use gotos in C How does it solve that problem?
dont use if statements
Try being someone else looking at code 1000+ lines long a year from now with gotos and labels. It would be a nightmare for that person.
I had an issue where I wanted to break out of a foreach function but had to go through all of them. Wonder if this would help
I would say don't use a forEach in the first place if you don't want to loop over all of them.
&gt; Because Javascript was invented twenty years ago in the space of ten days, it uses an encoding that uses two bytes to store each character, which translates roughly to an encoding called UCS-2, or another one called UTF-16. I don't think UTF-16 is a consequence of the 10 day development of JS. Both Java and C# use it as well, and they were developed during a longer time. It's just that, at the time, they thought 16 bits were good enough for storing characters.
This won't work in a forEach function. If you want to break out of a function you need to use `throw` or `return`
I totally agree, and I respect that strategy. But when I've watched their product announcements I don't often see them differentiate between products/features/designs that are truly new and novel and those that are small iterations on others' work. Everyone steals from each other in software the same way everyone does it in art, I just don't like the way Apple presents it.
Same here, except that the convention in my team is to auto-format into having them. In my personal projects, I prefer no semicolons though. It pretty much goes to show that, even though people keep bringing up the edge cases, the reality is that the vast majority of time it really doesn't matter which way I choose because the tool can convert back and forth without ever breaking my code.
I think convention is to put a preceding semicolon in the line that needs it. Personally I write code in a const-heavy style so I never run into issues, e.g. // instead of console.log(foo) (foo || {}).bar() // do this console.log(foo) const thing = foo || {} thing.bar()
Sure they may feel natural to you, but not to others. Modern languages like Go, Swift, etc don't use semicolons, so I can understand why others wouldn't care for them in JS.
 do { // Begin loop code if (condition) { break; } // If the condition is true, break out of the loop } while (false) // End loop code with condition. However as the condition is "false", the whole do-while loop is redundant. If you meant using boolean "true" condition to do the loop that's still pointless because you have the exit conditional inside the loop code when you have a place to put it... in the while () condition. Unsurprisingly when the loop exit condition is clear, there's performance to be found. Browsers / node gets better and better at deciphering this kind of bad code all the time. Keep the loops clean.
This is the best tl;dr I could make, [original](https://diary.braniecki.net/2017/09/01/all-hands-on-deck-how-you-can-use-your-skills-to-contribute-to-firefox-57-success/) reduced by 93%. (I'm a bot) ***** &gt; My main work is related to the Localization and Internationalization layer at Mozilla, but over the last few months I&amp;#039;ve dedicated some of my time to help Firefox 57 release and realized that many people I know have the skills to help us and would most likely be interested in the challenge, but don&amp;#039;t know that they can! &gt; Please note, we&amp;#039;re at the point where we can mentor you by helping you apply your skills in the context of the Firefox project, but we&amp;#039;re not in a position to mentor you in acquiring the basic skills needed for the tasks below. &gt; Those things may vary - maybe you know GTK, Mac OS or WinAPI and can help us with OS integration? Maybe you know assistive technologies, have experience in bidirectional layouts, know how to profile performance on MacOS, know how high-contrast should work? All these and many other skills can be put to use to make Firefox work better with those systems. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/6xwyib/how_you_can_use_your_skills_to_contribute_to/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~203752 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **Firefox**^#1 **help**^#2 **Web**^#3 **skills**^#4 **new**^#5
If you think JS labels share those flaws then I suspect you've never even heard of them. [Here's the MDN article.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label) I know they visually look like goto statements, but it's what goto *does* that's dangerous, and these do something different.
else is implied after an if whose body ends with a flow control statement (continue, break, return, throw).
In my experience, many people who follow the philosophy that a function should have only a single return at the end would be even more troubled by the use of a labeled break to avoid an early return. For those of us who think early returns are just dandy, there's no need to use a labeled break to avoid a return either, since we can just use a return. I guess that's one thing that the "single return" and "multiple return" camps may agree on! I do think a labeled break could be useful in some situations and shouldn't be feared, it's just that those situations may be rare - and may be a sign that you're doing too much in one function.
We have it right here, folks: "if statements considered harmful."
Fact
I was being a bit facetious, of course. And no offense intended if you were serious - but in that case I'd be curious what approach you favor in a situation where you need to do one thing or another thing depending on some condition.
Same here. Prettier changed my priorities about coding. Not worried at all about formatting. I hope I still can do it someday if I need it haha
Imaginary problem.
If statements obviously aren't on the same level as goto. But there's a good reason lots of languages don't have them. They instead have ternaries. (Or if constructs that act as ternaries). Because ternaries always return a value. If statements are conditional blocks which tend to grow and end up harrier than branching values. A ternary is predictable especially if you want to consider composition with other language constructs. 
The prevalence of emotion over technical discussion here is frankly disappointing. While labels certainly aren't the most elegant way to write the above example code, they do have their uses. For example: validate: { let failures = 0; for (let restriction of restrictions) { if (restriction.test(input)) { failures++; if (failures === 2) { break validate; } } } useInput(input); } How else would you write that? Extra variables, that's how. Slower, more cluttered, more code, less organization, more room for error, more side-effects. If you think about it, I bet you can recall many times labels would have solved your problem more elegantly. They may not be necessary, but they're occasionally the best choice. (And, please, ignore all the nonsense about them being comparable to "goto". They're as similar as object literals: in syntax only.)
 function dothing() { code function thinga() { stuff = a return interestingThinga } function thingb() { stuff = b return interestingThingb } notAnIf = condition ? thinga() : thingb() } ?
Gotcha, thanks! Man, this makes me miss the [BLISS programming language](https://en.wikipedia.org/wiki/BLISS) that enjoyed some popularity back in the '70s. In BLISS, there were no "statements" at all - _everything_ was an expression and returned a value. It had something that _looked_ like an "if" statement, but semantically it was much more like today's ternary operators. It was rather eye-opening back in those days, when we'd always just assumed you had to have a distinction between statements and expressions. What modern languages do you like that follow a similar principle?
Haskell is awesome. 
I do like the conditional operator very much and use it all the time. But this seems like a case where it's being shoehorned into something that would be easier to follow as a simple if/else. Of course I realize it's just a contrived example, and it can be hard to show the value of something in a simple example like this. In any case, I'm happy to use either an if statement or a ternary operator, whichever I think makes the code easier to read.
Oh I agree with you, and hope the other guy was joking. 
My comment wasn't meant to say that just because the author we should accept it. It was meant rather than a seeming negative comment, questions could be asked about is the author aware of the other modules (I am sure he is)? Why he chose to go this path when there are currently other options that are similar to what the author is trying to accomplish. It's more useful to have a discussion. That is all.
&gt; How else would you write that? As a function. function validate(input, restrictions) { let failures = 0; for (let restriction of restrictions) { if (restriction.test(input)) { failures++; if (failures === 2) { return false; } } return true; }; 
You don't have to use gotos in C. The only accepted use of goto in modern C is to jump to a cleanup section of a function when you would otherwise be returning early.
(downvoted because I don't think the language is appropriate for this subreddit, which may include kids as subscribers, not because I disagree with the contents of your comment...)
the acorn.js example could just use `return` instead of `break loop;` the code would function identically, and it would be more easily understandable.
If statement, not a for loop
For one thing, it means you're looking at n^2 runtime which isn't great. 
I suggest reading Dijkstra's essay, which introduced the phrase "Goto considered harmful". Are you sure that using this construct doesn't introduce some of the same problems he mentions?
The thing is the converse is just as true for people who don't use them, the time taken to read your post is longer than the time not-including semicolons has added to my coding time so I'd consider this a fairly moot argument. The thing is whether or not you include semicolons ASI is going to surprise you, for people who rely upon it then they'll probably get surprised when this fails: const scaleFactor = 12 [x, y] = point However the flip side is also true, if you believe the only way to terminate a statement is to use a semicolon then this will probably surprise you (it certainly surprised me when I started with JavaScript): return 10 + 20; Ultimately whether or not you use ASI some things are gonna be surprising. One of the reasons I prefer to rely upon it that when changing things often you'll need to extend things at the end of the statement which is when semicolons tend to just get in the way and certainly don't improve the programming experience.
I think you may be confusing the two phrases 'hard to understand' and 'harder to understand'. Linear control flow is always easier to understand than control flow that jumps all over. Recognizing this fact, programmers of very high skill levels may still choose to write simple code. It's a form of maturity not to write things in a dense/terse/hard-to-read thing, just because you *can* understand it at the moment it was written. Kernighan [wrote](https://en.wikiquote.org/wiki/Brian_Kernighan): &gt; Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?
Thank you. i need something that will teach me JavaScript quickly. the book is 450 pages long. 
that is great man.thank you
because it 'smells' of a design problem. such non-constructs are not necessary. difficult to maintain, not extensible, difficult to follow etc.
Not entirely - if you sequential ifs that aren't related then the final statement outside would be a sort of gobal else for the sum of the conditions. Which is a perfect candidate for using that over a label.
lol I wrote this exact thing pretty much line for line before realizing you posted this.
Why would you need to do this? How is it different than a simple if statement?
Couldn't jimp just be a dependency since it and this library are both npm modules?
I disagree. Gotos are also harmful because they are bad to control flow and not needed. If you feel the need to write non linear code where you could write linear code, you're doing something wrong.
This is horrible, horrible practice unless you are really having to count cycles.
I was going to object, but then I reviewed every example I could in my head, and realized a while or do while would indeed be a more elegant solution in almost if not all cases.
I agree with you if what you want to say is that nested loops can be a problem, but I don't think they are a problem per se. The for inside a for construct is needed to solve O(n^2) worst case scenarios, like iterating through a matrix.
Am I the only one who doesn't like breaks with the exception of those inside switch statements? I try to never use break statements, I even try to always put the return statements on the last line of functions.
&gt;The prevalence of emotion over technical discussion here is frankly disappointing. Your labeling of best practices discussion as "emotion" isn't helpful. Most of us work in teams, best practices and code readability are very important. 
See: reality distortion field
Great, that works if the code lends itself to it. But as we saw with async code in Node before async/await (and before it Python), implementing control flow in a way that only works at function boundaries creates verbosity, readability, and maintainability deficiencies. Here's a modification of the example that hopefully illustrates that functions aren't always a decent stand-in. let x = …; let y = …; let lastFailure; validate: { let failures = 0; for (let restriction of restrictions) { if (restriction.test(input) === x) { failures++; lastFailure = restriction; if (failures === y) { break validate; } } } useInput(input); }
Of course they are. I'm not labelling them as emotion. What I'm labelling as emotion is that the top comment is literally, in its entirety, "oh dear lord, please never do this." And that every request for arguments in this thread is downvoted. Do you seriously disagree?
I'm "hijacking" your comment... Why would I want an image processing library based on js for node? Wouldn't a native module be better for server side?
lastpass and an ad blocker.
I would say it's a bit flippant towards the OP (rather than politely explaining why) but it's still a pragmatic response. 
JavaScript's labels are no less linear that `return`, `if`/`else`, `break` without a label, `continue`, `switch`, and most other control flow constructs. It's a very, very widely-used control flow mechanism to jump to the end of a containing block--and literally impossible to program without some jump somewhere. What makes goto's jumping different and bad is that it can break the stack and the block structure. JS' labels can't.
What does C have to do with JS and why would you ever need to break out of an if statement? 
Simple, I didn't know I could break out of an if by tagging it.
Nope, it's syntax sugar for multiple `break`s.
I don't follow that philosophy. But it is super handy to have a single line break point at the end. Also, it there is clean up work, you don't have to wrap the function with another function. 
Interesting. The mdn docs only talk about this working with loops, but technically any block can be labeled. Wonder if you can use labels on mere separator blocks.
That might mean multiple return statements, and each one needs to have the return value expression. To avoid the duplicated expression, you can use break statements instead and put a single return statement at the bottom.
Only way to stop a foreach is throwing and catching it outside... So yeah, you should use regular loops
This doesn't smash the call stack or teleport randomly. It breaks out of the containing block(s), just like a normal unlabeled break statement. JavaScript doesn't allow any of the weird teleporting behavior people seem to be afraid of.
You can create a local function that has access to the variables in the scope that it's declared in. function doStuff(input) { let lastFailure; const validate = function() { // yadda yadda yadda if (whatever) { lastFailure = restriction; return false; } return true; }; if (validate()) { useInput(input); } else { console.log(lastFailure); } } I mean, that's still kinda ugly, but at least there's a clear separation of the validation logic vs the doStuff logic. You can do this in Python too.
So then you're duplicating the break logic, and then having a single return. I don't see any situation where the labelled break will win over abstraction with a function tbh, or even just having a var in this case (i.e. isValid = true, then each if resolves it to false for it's own validation logic).
Well, I generally don't use breaks outside of switch blocks, I never use return in places other than the last line of a function, and I remember having used continue once, on a very specific scenario. And yes, it is possible, you use variables and functions to control your flow.
This is a perfect example of "write code as if the person taking over your app is an angry serial killer"
With a filter restrictions.filter(restriction =&gt; restriction.test(input)).length &lt; 2 Although thatll go through the entire collection, and may not always be desirable, but on most cases it's not going to matter, and it's a lot less to read
What? There may be kids everywhere on the internet. Don't downvote someone based on his or her language or tone. Only downvote if the comment doesn't add to the discussion. His opinions are sound and I agree with him. It's interesting to see what's what and why under the hood.
But alas is unavoidable in some instances like looping over pixels in an image if you have to (can be done in a worker I believe)
But if you prefer the functional programing style, then use Array.prototype.some, which iterates until you return true from the callback.
Unless the string contains surrogate pairs.
I don't worry much about it, in an edge case i'll place a semicolon. To me it's less noise, code appears more readable and clean. Either way, i meet an edge case maybe once per project if ever, can't even remember the last time i set a conscious semicolon, maybe half a year ago. Prettier handles semicolons otherwise and i haven't seen any problems with it so far.
&gt; the time taken to read your post is longer than the time not-including semicolons has added to my coding time Congratulations on saving like 15 seconds a year, and introducing potentially week-ruining bugs into your apps. Do you also refuse to wear seat belts because they take too long to buckle? EDIT: Don't answer that. I know your answer is stupid and I've ignored the reponses for this because quite frankly, I don't have any more brain cells to kill at my age. 
**[3 days old account - smells like a troll to me]** Brendan Eich had made semicolons part of the language, but then he stupidly didn't enforce them. Even more stupidly, ES6+ didn't do anything to settle the issue one way or another. Cue hipsters not using them because they are cool. Strictly speaking they are not essential except for a few edge cases, but it's good form to use them consistently (i.e., always), the same way it's good form to always use curly brackets for if / else or to write comments. As always, the important thing is to have a consistent, enforceable system and stick to it. If you are unsure which to choose: the vast majority of devs use them (2 to 1, last time I checked a survey). In my experience devs who use them get _really_ annoyed about those who don't and may even not offer you a job just because of it. Devs who don't use them are more accepting of those who do (out of smugness :-)
Just because everyone does something doesn't mean they all go about it the same way.
I only read the last line of your post and I did what you asked. You're welcome!
I had a similar problem a while ago. Importing in webworkers wasn't straight forward and you can't resolve to node_modules. There's a webpack loader that does it (using a blob) but it had a fallback appendage, which i thought was messy. I use rollup now to create a self-contained worker-bundle in which i can import freely.
Maybe it's worth pointng out that JS characters are an abstraction placed internally in unsigned 16bit each, nothing more is posed by ECMA. JS doesn't interpret them as UTF-16 (that is [implementation dependant](https://mathiasbynens.be/notes/javascript-encoding)), utf-16 is just taken as a reference encoding in JS specification, it could have been other encoding scheme ...
I don't really think "everyone on this subreddit is dumb and stupid and afraid and fuck all of them" is quality content, but aight
Nicolas Zakas' "JavaScript for Professional Web Developers" teaches ES5 for programmers with a background in other managed languages. It doesn't cover the latest language features, but these are easy to pick up later.
So now you've made it into a function that stores the last failure somewhere. I don't really see how your use of the label made that any clearer than a well defined function. You've only created a horrible piece of procedural code with nasty side effects. If you're that anal about finding failures why not just create a function with a return array. If it has items, do some error handling that corresponds to the failures, else there are no failures and you're good to go. 
Depending on your use case, the array methods find or some are probably more suitable than using forEach and trying to break out.
Seems like you're having success with Axios. If you wanted an alternative, I like requiring in `Bluebird` and `request`. Then I wrap `request` in `Bluebird.promisify` like so: `const Promise = require('bluebird'); const request = Promise.promisify(require('request'));` Then you can use `request(https://yoururl.com/wateva).then(req =&gt; console.log(req.body)` to see the contents.
I have a better suggestion... There is a wonderful thing called GOTO ( ͡° ͜ʖ ͡°)
I agreed with the first paragraph but it was downhill from there. 
Preface: I really want there to be a use case for this because it seems fun. Your argument is that this is a use case for `break __;`... except it's not. When in javascript do you do nothing is something fails to validate? if you use `break validate;` you will need to have another variable assigned to useInput or let useInput pollute some global/parent scope so that you can check if this validation failed.
&gt; finding out the nth character ("Hello"[2] in JS) is constant time &gt; text with emoji No.
thanks but it start teaching from square one. it even assume you don't know what the variable is. not what i am looking for.
I don't understand your comment, UTC does have leap seconds after all? The example of OP is in UTC, for instance.
I should've been more clear there; that would actually just be O(n)
I'm not actually taking part in this general conversation about loops. I mostly noticed that nobody was looking at it from a design perspective so I wanted to bring up runtime calculations. If you're looping the same data in nested loops, you can probably simplify something or reduce the problem
Can you show the code snippet of how you are calling papaparse, If you are trying to load a file you need a callback in your config object Papa.parse(file,{ config: { // base config to use for each file }, before: function(file, inputElem) { // executed before parsing each file begins; // what you return here controls the flow }, error: function(err, file, inputElem, reason) { // executed if an error occurs while loading the file, // or if before callback aborted for some reason }, complete: function() { // executed after all files are complete } });
Sorry, I may have been overly short. Here, in detail, and numbered, is the previous post. Tell me which point you don't understand. 1. @meefims claimed that Kerberos works because it tolerates clock differences, including those introduced by leap seconds. 2. The Kerberos software uses only UTC, no other time systems. 3. The Kerberos protocol, modeled after the software, uses only UTC. 4. The distance between TAI and UTC is 37s right now, and likely to increase. 5. The distance between TAI and UTC can not be planned far in advance (unlike leap days), because it depends on a number of large-scale systems, such as earthquakes. 6. The POSIX (and equivalent Windows) APIs provide UTC, for instance with [`timegm`](http://man7.org/linux/man-pages/man3/timegm.3.html). 7. There are no TAI functions in POSIX. Software that wants TAI needs to perform the calculations itself. This is difficult (see 4. and 5.). 8. Because of 6., software that only uses UTC does not have to worry about leap seconds. 9. Some operating systems can be configured so that they return TAI on `timegm` calls. 10. A configuration as described in 9. is incorrect per POSIX. 11. If a system is misconfigured (9.), the problem (1.) will indeed occur. 12. There is a warning about 11. in the Kerberos source code.
I don't see how TAI is relevant; to me as a developer, leap seconds just mean that the UTC time can be 23:59:60; I'm not really interested in the reasons why. OP asks a question about what happens when the data structure we use to store UTC times cannot in fact represent all UTC times. Someone notes it doesn't matter much for Kerberos because it's only a single second. Then you say "UTC is not affected by leap seconds" -- but all I wrote above is within UTC. How can it not be affected? Also when you say "is not affected by", that could mean either of two opposites -- either you mean it completely ignores them, or it follows them perfectly, I can't tell which you meant.
That is the main argument of pro-; That is, ad hominems.
Have a look at the [intermediate and advanced tutorials in MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript). (And bookmark MDN).
&gt; Also when you say "is not affected by", that could mean either of two opposites -- either you mean it completely ignores them, or it follows them perfectly, I can't tell which you meant. Neither - **Kerberos** works fine despite containing no leap second code. My comment was just about Kerberos. For my comment about the OP, see above.
OK. So the Javascript Date object that can't represent 23:59:60 is not POSIX compliant?
Data point: if I am reading a coding test submission that does not use semicolons, I am going to wonder whether the author has actually made a choice, or simply doesn't know better.
You don't have to read every page.
POSIX compliance just matters to Kerberos implementations. There are no JavaScript APIs implementing POSIX that I'm aware of.
I bet it would get the upvotes it deserves if the title was like "Fast Properties in V8 with React".
I don't. Frankly, I would use this opportunity to do the research and setup on my own. I recently did a prototype for server-side rendering. I found the various guides and boilerplate unhelpful because the authors rarely justify their decisions. Build your infrastructure on your own, and you'll know what to fix when something goes wrong. Assuming you're doing a web project, start with Express. Add Webpack, Babel, Typescript, etc., and keep building on top of that. 
FFS, I stopped reading a third of the way down after accidentally swiping left/right several times and getting a different article. Then I accidentally scrolled a little to the right, and couldn't scroll back without swiping left. Does anyone actually use those damn swiping article features, or is it just a PITA for everyone? 
"Your JavaScript is faster now, but please don't ask why or how"
Hi /u/proboardslolv5, please refrain from personal attacks. Thanks.
One more good article on polymorphism and hidden classes - http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html Do not worry if you find it confusing and hard to grasp. It took me a few readings from different sources to understand the thing.
That's because the `style` attribute of the `iframe` element has its closing quote missing. Thus, the `&gt;&lt;/iframe&gt;` text is still treated as the attribute value. This causes the `iframe` element's HTML code to be invalid, and the `iframe` element is not included in the DOM.
The anti-semicolon argument is no different than the anti-vaccination argument or an anti-insurance argument. You don't often need these things, but god help you if there is a problem and you have chosen to go without.
Is it really that important?
[removed]
I think if multiple use of `break` statements is to be avoided, the use of `goto` would be less confusing.
If you just want to call C code and don't care about speed you don't have to write C++, just use [`node-ffi`](https://github.com/node-ffi/node-ffi). It lets you call functions in DLLs from JS. It's also very useful for playing around with libraries.
&gt; Wherever null is used I will use undefined. You should be doing the opposite. You should rarely explicitly use `undefined` in your code. &gt; Is there a good use case to use null in JavaScript? If something blows up because it's `undefined`, it means I forgot to initialize something. If something blows up because it's `null` it means I initialized it to `null` and the code should have expected it. If you use `undefined` everywhere you can't tell the difference.
I feel like non standard ui should be a opt in toggle. Even if it's more useful than standard ui, let the user get used to it properly rather than just springing it on them.
Huh? Who said they do?
If their swipe detection logic wasn't completely insane and didn't detect slight diagonal movement and maybe gave you more feedback with a longer swipe distance before going to the other article maybe it would be fine. But as is it's a fine example of obnoxious mobile design. 
Here's a few things to get you started: - Install TypeScript as a project dependency: `npm install typescript --save-dev` - Install the TypeScript cli globally (only need to do this locally): `npm install typescript --global` - Initialize TypScript with a `tsconfig.json`: `typescript --init` - Compiling your TypeScript is as simple as `tsc index.ts`. If you're not wanting to install typescript globally (say on your continuous integration server), you can abstract this to an npm run-script like so: "script": { "compile": "tsc ./index.ts" } - Install [ts-node](https://github.com/TypeStrong/ts-node) (optional): `npm install ts-node --save-dev` - Good for running TypeScript "directly" from cli. When installed as a project dependency, you can create an npm run-script to call *ts-node* directly, just like we did for the standard TypeScript compiler. Example: "scripts": { "start": "ts-node ./index.ts" } - Install [tslint](https://palantir.github.io/tslint/) (optional): `npm install tslint --save-dev` - Linters are not only helpful when you're working with a team, they're also helpful when you're starting out with a new language. Once installed, initialize *tslint* with a `tslint.json`: `tslint --init`. - Install your type definitions: Depending on what dependencies you have, you'll install types for each (unless type definitions do not exist for a specific dependency): `npm install @types/node @types/lodash --save-dev`. Hopefully that's enough to get you started. You'll likely tweak things a lot as you're moving through it. Just be sure to save and commit often. Good luck. :)
No, that's not it, as I had the whole style attribute missing. It still didn't work then.
Thanks
I should've mentioned not to start with the first book, up and going. That does assume you're starting from scratch. The others are deep dives into language specifics. They can be read individually and out of order.
AFAIK service workers are available in the latest Safari TP.
"week ruining" You're joking, right? And you don't even get these bugs if you just enable no-unexpected-multiline in eslint. 
That's awesome! :D Thanks for the heads up :)
What's your focus, front-end or back-end? A front-end portfolio should probably include mostly custom components, but showing off your back-end skills may not require this as much.
Definitely not. Just make sure you don't use the standard, 'entry-level' design from the libraries. An example is Bootstrap. Bootstrap has alot of different looks, but the basic one is a very well-known look, and if you were to use it, it might convey you have only a surface level knowledge of the library. Here's an example of a Bootstrapped [page](http://reactvt.io/) that I think was done really well
I have never done AR before, but have written quite a bit of 3D and VR code. I would not typically use something like React for a project like this. Anything to do with stereoscopic rendering has to be as fast as possible, because if the framerate dips below 60fps the brain starts to notice that the lag between what the body feels and what the eyes see. In AR it might not matter so much, but any kind of unnecessary abstraction is a big no-no in WebVR. I generally just use Three.js. It's very simple and works well if you have to populate your scene procedurally. It's also a very portable skills: both ReactVR and A-Frame use Three.js under the hood and sooner or later will require you to tinker with it.
Pet peeve. It's React, not React.js.
not if you do it properly i.e. pull in the repo as a dependency and then change the defaults and compile based on what you actually use. the wrong way to do it is just CDN-ing all of it then overriding the defaults.
I would not put too much thought into this. The fact that you are compiling a portfolio at all will set you apart. The core competency here is that you are starting projects and finishing them. Be prepared to, however, explain why you chose what you did for the UI. Kramonamor makes a good point about Bootstrap. If you use it, make sure you still have a custom feel to your project. 
&gt; You Don't Know JS that is true , very good in fact except the book is way too long. right now i need quick and dirty crash course. few months later i will hopefully have the time for a more detailed book like this one.
it seems that their "JavaScript Guide" is probably what i am looking for, thanks.
http://particlesjs-images.bitballoon.com/
Examples have used URLFetchApp to send data to a Slack webhook. So using this principle I have been able to trigger an AWS Lambda function that is teamed up with a webhook URL using AWS API Gateway. Just put any payload in for now and it seems to work! I can now add this to invoke in my Google Sheet (within App Script) https://jsfiddle.net/npgy93f2/1/ So a secondary way of doing this, but one that goes round the houses. That is to send a request(message) to a Slack incoming webhhook that then sends an outgoing request(triggered by Slack message word) to AWS Lambda/API Gateway. Here are some URLs I have gathered to have a go at doing this: https://developers.google.com/apps-script/guides/services/external https://github.com/benlcollins/apps_script/blob/master/marking_mail_merge/code.gs.js http://www.kutil.org/2016/02/integrate-google-apps-and-slack-with.html https://ctrlq.org/code/20113-google-forms-to-slack http://jd.mares.co/tutorials/2015/09/20/slack-google-apps-script-stand-ups.html https://www.bettercloud.com/monitor/the-academy/use-apps-script-push-live-news-headlines-slack-google-sheets/ https://www.benlcollins.com/spreadsheets/marking-template/ 
It's a personal project, so do what you want!
peeve indeed
Hi /u/samerbuna, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's kind of what I've been reading as well. React to set up the initial scene and such, then delegate all animation and rendering to Three.js so it's fast. Makes sense really.
Usually this is from the jQuery script not being run before the script that needs it. In other words jQuery needs to be above the other script, and not have 'async' or 'defer' in the jQuery script.
What are you even talking about? Running `npm i -g http-server` takes a couple of seconds and you only have to do it once after installing node and then you're good. After that, all that is left to do is to run `http-server` inside the project root once, for every time you start working on a project. This "costs" about a minute to set up node then install http-server, which is minuscule when put in the context of an average lifespan of local development setup. Then it "costs" you few seconds to `cd` to the project root and run `http-server`. It takes me more time to find the folder via finder and open the file, so I would argue the method with `http-server` is even faster. And I won't even go into how much time it will save by avoiding debugging the APIs which are blocked on `file://` urls and fixing all the inconsistencies that will come to bite you in the ass if you decide to deploy your `file://` page on a server. And if you are afraid to type few things into a terminal as a web developer in 2017, I would suggest getting comfortable with it, it's not that scary. Or stop calling yourself a web developer.
If you know javascript like the back of your hand picking up the ones you spoke about should be relatively simple! I recommend Javascript Allonge the 6 edition if you're looking to get into functional programming in javascript as a transition.
There's also [request-promise](https://github.com/request/request-promise) that does it for you.
clojurescript, afaict has the most backing and community. I suck at lisp so I tend to lean towards elm which has a beautiful syntax and isn't too hard to pickup, great compiler etc. but has not so great interop with JS libs (using ports) purescript is also a haskell like variant with great interop with regular javascript but is the least popular among the three. hope that helps!
Really? I just talked to someone who was saying that clojurescript is so infrequently used that core.typed doesn't even work anymore. Purescript is actually what I've been gravitating to but there's not even 2000 people in /r/purescript. The language just seems so nice though. I'm only a few chapters through PureScript by Example which seems to be an amazing resource, but I am worried about lack of community. It would really suck to integrate the language into my projects and just have it fade away like coffeescript or others. Maybe it would be a net gain regardless because it would give me a simple transition to haskell? 
**Here's a sneak peek of /r/purescript using the [top posts](https://np.reddit.com/r/purescript/top/?sort=top&amp;t=year) of the year!** \#1: [PureScript Compiler v0.10.1](https://github.com/purescript/purescript/releases/tag/v0.10.1) | [0 comments](https://np.reddit.com/r/purescript/comments/55krf2/purescript_compiler_v0101/) \#2: [purescript-halogen v1.0.0 released](https://github.com/slamdata/purescript-halogen/releases/tag/v1.0.0) | [0 comments](https://np.reddit.com/r/purescript/comments/5wqrtk/purescripthalogen_v100_released/) \#3: [PureScript Compiler v0.10.3](https://github.com/purescript/purescript/releases/tag/v0.10.3) | [3 comments](https://np.reddit.com/r/purescript/comments/5ho93f/purescript_compiler_v0103/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I've done a ton of development using ramda or rxjs. I can confirm that Javascript Allonge and the Mostly Adequate Guide are both stellar books as someone that's read them each multiple times. Shout out to /u/drboolean 
What about [Reason](https://reasonml.github.io/)? If I were a betting man, I'd wager it will outlast all three you mentioned and have a bigger community over time. If you're just looking for something that will give you full type safety and a better programming paradigm than JS, Reason is a fantastic choice and has the backing power of Facebook / React.
https://trends.google.com/trends/explore?cat=5&amp;date=2014-08-04%202017-09-04&amp;q=purescript,elm,clojurescript http://imgur.com/a/oB3vy just checked trends- super interesting.
Personally I'd recommend Elm. It's an extremely elegant language, and I really really really like what it's trying to do with templating/rendering built into the semantics of how the language functions. It's kind of like react, except that it's not a templating language slapped on top of javascript and called a new language. Instead it's a language designed and built up around the concept of templating and app development from a functional mind set. Also it's the friendliest compiler I've ever encountered. When the compiler encounters an error it lays out _exactly_ what was wrong and then tells you what it thinks you probably meant instead, it's usually right.
Interesting, I hadn't actually considered it. I'll have to look more into it as I'm totally unfamiliar with ocaml.
It seems like elm prides itself on being easy to learn and having really useful errors which both seem like great points.
It's definitely been my experience that that's true. The tutorial ramp up guide was excellently written and laid out, and the language lends itself well to learning.
[removed]
This is probably inaccurate because "elm" could also refer to the tree.
[This may be more accurate](https://trends.google.com/trends/explore?cat=5&amp;date=2014-08-04%202017-09-04&amp;q=purescript,%2Fm%2F0ncc1sv,clojurescript) for Elm.
Do whatever you want, then run Prettier. Personally I like semicolons, but long as the team/project is consistent, it really doesn't matter anymore. The end product is probably minimized anyway. 
Excellent point. I'll update http://imgur.com/a/oB3vy
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/y72DN4P.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dmklw2s) 
PetPeave.js
yes,except that in order to know what you need to read and what not you have to read everything !! :)
While it may be indicate a level competency to compile from scratch, I'm unsure how much meaning it would hold. I think actual software on top of standard components better shows how you would be able to integrate different libraries to get stuff done. Unless you are a big company, everyone writes paychecks for features, not library improvements. Really just prepare a story to tell what you accomplished, any issues that arose, and how you solved those issues. Being able to technically solve problems comes with time and a bit of skill. Good soft skills alongside strong technical will take you farther in your career. All people can be taught technicals, but not all can be taught good attitudes. My .5 cents...
ihatehalfscreensidebars.com
So the premise of this article is that you write code without tests, without coverage, only supporting browsers that support all of the latest version of JavaScript, and without CI and that you only add that once you decide to make it open source? Your internal code must be terrifying!
Does that mean you just listed a bunch of painful, un-fun things?
Yeah, but it's totally ok, since we prefix all of our javascript files with: if (!isChrome()) { window.alert('Please upgrade your browser!'); window.location = 'https://www.google.com/chrome'; }
The return expression has potential to be more complex than a break statement, so a repeated break is the less repetitive option. The `isValid` variable means that extra validations will run unnecessarily, meaning it's slower. Abstracting with a function means a potential performance hit as well.
Use someArray.join(" AND "); You might want to create a new array that will contain each of your "(key = 'value')" strings; just loop through your current array and if there is a value build the individual string and push it to the new array, if there is no value, just skip it and move onto the next element. Then use the `join` method to build the final string. Edit: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join
Nice. Thanks.
I love writing code with JavaScript.js
jQuery script tag should come before other scripts who use jQuery
I've been using clojurescript for a year now and love it. Never used core.typed though. Since spec came out a lot of people have been satisfied with Tthe amount of type safety it provides. The language and core libraries are divinely inspired. The tooling is also great (the repl and lein especially) and so are the frameworks like re-frame. I mostly do server code so running the same language on java is a big plus for me too. It's here to stay, there will always be us that tried lisp one day and can never go back. If you're not convinced, watch a Rich Hickey talk on youtube.
Agree to disagree that a return expression is going to be more complex than a break - it's a non-standard control flow to break by label that can easily be avoided, and IMO should be for simplicity. Repetition != complexity either. You can design a function to run in a loop instead with an array of validations, amongst other design decisions, if you needed a way to break after X number of invalids. Personally I prefer to run all validations as it's much better for UX - you're able to tell someone that there is multiple things wrong and give them the opportunity to fix them in one hit. If you're worried about abstracting code to a function having a performance hit, I would say JS isn't the language of choice for that type of application.
It's called a "carousel" . https://flickity.metafizzy.co/#feature-showcase http://kenwheeler.github.io/slick/
Please make sure you aren't concatenating a SQL query. Using form inputs to create a SQL string will leave you open to SQL Injection. 
This is hitting an API that is read only. but valid question I will ask the data team if there is an issue.
Purescript is probably your better pick for learning FP, since it's based heavily on Haskell. It's still relatively new, but has a lot of momentum and I'd be fairly confident of it sticking around. (Worst case, you've learned Haskell and can switch to GHC.js). Reason, F#, and other ocaml variants are also good, but lack a few things (such as Typeclasses) that make Haskell as powerful as it is. 
the error you're probably seeing is `cannot read property 'firstName' of undefined`. if `filterData` is null/undefined, or if `filterData[0]` is null/undefined, it will throw this error. you need to make sure `filterData` actually contains something: `if (!filterData || !filterData.length) { /* return some default value, because filterData either isn't an array or it's an empty array */ }`
When hiring managers ask for your github link, it becomes important. I just commit crap to GH so that employers can see I actually do stuff. This seems cool to me.
post some sample code so we can actually code review it.
Just figured this out. Thanks!
Are you hoping to get ios support on this? On my phone I just get a green screen, had to use chrome on my laptop to see this in action. Very cool though!
Any free alternatives you guy recommend?
Can you elaborate on the not so great interop part? I've never used Elm, but was under the impression that since it compiles to javascript it would be compatible with every lib there is. Isn't that the case? 
Make sure it's not blocked by a browser addon. e.g. adblockers
If you think it is messy, it probably is messy for others too. [Prettier](https://github.com/prettier/prettier) can help to fix the most common formatting issues, but how you actually structure your code is up to you. I am always trying to create multiple simple functions and methods that do only one thing at a time.
This one was great: https://egghead.io/courses/react-fundamentals
Try [this playlist on YouTube](https://www.youtube.com/watch?v=OXmpxz_-pBU&amp;list=PLkEZWD8wbltnXlfyhS5qSMTNb26utkOkI) if you are completely new to React. Or the [React 101](http://ihatetomatoes.net/get-react-101/) if you have a little bit experience with React and JavaScript.
Oh I hadn't tested it out on iOS and hadn't heard of this error before. Let me check it out.
Try breaking out callbacks into their own functions
Check out /r/learnjavascript
Look into array filter and map also. They will change your life when you master them.
You mean "React 4 (2+)" /s
JavaScript is no better or worse than any other language. Have a code sample?
Egghead.io also have got great tutorials. 
I like elm clojurescript and purescript, but honestly you can be pretty functional with javascript. Typescript will be the easiest to adopt for you as it's just js + types. You may find that using Typescript + a functional library like Ramda is all you need and doesn't force you into a non-js ecosystem (typescript can use regular javascript libraries*). A plus of this is that all your existing code will be very easy to use, will just have to add some type annotations.
Another great thing about Elm is that the language itself is very small. After you have done the official introductory tutorial on the website you know pretty much all of Elm. So you can understand 95% of Elm code which is out there in libraries and so on after spending just two days with the language. The only thing that is missing in the intro is explaining some of the syntactic sugar.
Try using promises with async/await to avoid callback hell
I use Elm. Its focus on simplicity is one of the key points for me. I also like that it's focused on solving front-end issues than trying to rush into being a general purpose full-stack language. Seems too easy to become worst of all worlds. There's a learning curve, but I'm not convinced it's any bigger than React + Redux + TypeScript + x + y + z.
Well, to be fair, this is benching wrapper libraries, not Ruby or Node, so I'd put that in the title. For example, using Imagemagick directly (CLI `convert` tool) via Node's `exec` module was much, much more performant than using the `gm` wrapper available on NPM. If you just want to bench I/O as your readme suggests, why not factor out the indirection of sharp and async? 