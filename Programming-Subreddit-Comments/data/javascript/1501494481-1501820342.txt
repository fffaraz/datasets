no
Why?
Why are the promises chained like that? No one chains then like that. 
Are you referring to the flat chain with all of the returns? Could you show me how promises are normally chained?
It _might_ be nice to show the tweet when you click on a pin :)
I'm talking about the case where he treats promises like callbacks and chains it inward. He can just do something like this. DoSomething .then(value =&gt; anotherPromise(value)) .then(anotherValue =&gt; { doSomeotherThing() return aNewPromise(anotherValue) }).then(aNewValue =&gt; youGetTheGist())
I am a beginner to learn a Reactjs. while learning i am writing blogs and share it. I will take care of all your suggestions in my next blogs. as well as modify the current blog. thanks for your suggestion.
Ah, yes. I was doing that up till maybe a month ago. 
The code is uglier when covered with tries and catches. Isn't there a way to handle that better? Like a module-wide catch for example to avoid littering the entire codebase.
[removed]
It's also less composable.
This. We slowly started moving our codebase from Redux saga (generators) to Redux observables (ReactiveX) a couple of months ago, and it is so much better and way more powerfull than any other way of doing async code I've tried before. We all like RX so much more that we did an after hours Kill-a-saga coding session.
Very weird article. First author shows how to make a flat Promise chain. Then he shows us nested callback-like pyramid of doom which is avoidable by using a trick he has just shown. Then he tells us this problem is solvable with generators. *What?* Also he's using two different code naming styles in different code examples. One of them looks like a mix of C# and Python naming conventions and is very unidiomatic for JS.
Another good guess, but not the one I'm thinking of :)
Yeah I was planning on doing that v 0.2.0.
I have a lot of coworkers who tend to do that. Worse is when they do this: doSomething .then(val =&gt; { return new Promise((resolve, reject) =&gt; { doNextThingWith(val) .then(nextVal =&gt; resolve(nextVal)) .catch(err =&gt; reject(err)) }) })
Hi developers. My team open sourced a simple tool we used to deploy our es6 code to AWS lambda. Simple API with webpack settings, returned with zip file path 
Well I think the author is showing the differences, but isn't very clear about why async await is useful. Maybe I'll write something today and throw it out on this website. There is a fundamental difference between why one should use generators over promise chains, but the article doesn't explain it.
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JIT_Optimization_Strategies Since V8 also powers node, there is naturally more information available for V8.
So there's a technology problem at play here. There's a cost to developing a rich UI in platform native code: increased development time and team size. There's a cost to developing an electron app: increased memory demand and disk usage, and lots of duplication, which in my view is punishing the end user for developer convenience. Now, there are at least two paths forward for solving this problem. Either develop better UI libraries and frameworks for native/near-native code (better for the user, but harder for the library/framework developers), or make JavaScript more "native-y", reducing the duplication and overhead incurred with each Electron instance. Now, there are some arguments to be made against using JavaScript as a server/desktop language: no real immutability, extremely dynamic typing, bolt-on error handling, namespace clobbering, and more. My point is simply that JavaScript was built for a purpose: render and manipulate a client-side DOM. Now we're using that specifically built tool in all sorts of places it was never intended to be used, and I'm not sure that's a good thing.
When you see that it means they don't actually understand Promises at all. If enough people are like that, you might want to start looking for a new job with competent coworkers.
Couldn't you make this a webpack plugin, instead of having it consume the webpack config? I believe there are post build hooks that you could utilize to do the zipping/uploading. 
Exactly. You should totally write it.
If you're returning promises I would think you could still use a `.catch`. I don't know what happens for sure as I haven't tried that with fully native async/awake
Does your company do some sort of code review? If not I suggest to start doing them. Doesnt have to be very intense. Something short that highlights things like this will do. Cultivating a culture like this in the work place goes a long way in code quality.
Thanks for your support :) Did you have any issue with Firefox? I made myrtille to work with any browser. Yes, it's possible to customize the login page; all elements are defined into a CSS file. To optimize the rdp experience, all contributors are welcome :)
That's also a feasible solution. In our situation, we require this module in a cli tool, so instead of requiring our user to use webpack directly, we provided them simple API to interact with.
Thanks! That is a very useful resource. Perhaps I didn't phrase the title or description well, but I meant posts, such as blog posts and posts in reddit. In that sense your reply doesn't really answer the question. Indeed, as v8 is powering NodeJS, naturally there are more posts. But your link seems to be the only page available for SpiderMonkey...
I think we're already there. Have you had a look at react-native? It can render everywhere: [windows](https://github.com/Microsoft/react-native-windows), [mac](https://github.com/ptmt/react-native-macos), [web](https://github.com/necolas/react-native-web), [mobile](https://github.com/facebook/react-native) and many other platforms. The odd thing about it is that these renderers aren't a hack. They solve longstanding issues even native stacks struggle with considering that native is still tied to old mvc/mvvm or worse, layout inflating. Now due the portability and the large ecosystem with node and npm and the community support that it has, javascript can do things no other language can do given the same time and resources. It may have been tied to the browser once but that was long time ago, on its own it's just a basic language. Toolboxes for native aren't yet as simple as what Electron offers, but once that's taken care of Electron can fade.
I see. Well, good job, looks cool. 
thanks!
Hello, I‚Äôve updated the [/football.json](https://github.com/opendatajson/football.json) repo / service that offers (auto-)generated match schedules (fixtures and results) and club listings for the major football leagues e.g. English Premier League, Deutsche Bundesliga, Primera Divisi√≥n, Italian Seria A, etc. See the [2017-18 season folder](https://github.com/opendatajson/football.json/tree/master/2017-18) for (static) JSON examples. No API key required ;-) All data public domain. Enjoy the beautiful game. Tip: Use the "raw" link to serve yourself e.g. English Premier League Match Schedule 2017/18 -&gt; &lt;https://raw.githubusercontent.com/opendatajson/football.json/master/2017-18/en.1.json&gt; and so on.
But "easy" in a language isn't always a good thing. Yes, it may be easy to write JavaScript, but it's not always safe. I can't tell you how many times I've tried integrating a library only to find out later that there's an unhandled error buried deep within it. I try to contact the author or submit a pull request only to receive no response and find out that the it's now part of the massive pile of abandonware that makes up most of npm. The quality of the code on npm is so poor, I believe, in large part because the language is so easy. The situation is better in a similarly easy-to-write language, python. Now why is that? I'd argue that it's the small level of extra strictness in the language. 
&gt;It‚Äôs about time you know async and await. You know you wanted to for a long time. But for some reason‚Ä¶ you just never got to it. Only knowing about the keywords: yield, then, async, and await is knowing nothing at all. You want to gain thorough understanding once and for all. Kind of an arrogant way to start the article.
Hi /u/nikitathakur0194, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Another great thing about Rx is that you use the same approach for all streaming: both sync and async.
There is a plotly_autosize event according to the [documentation](https://plot.ly/javascript/plotlyjs-events/#additional-events) not sure if thats the one you're looking for. There are no examples of how it works though. 
Just taking a quick skim, I noticed this: &gt; @unction/isArray string -&gt; any -&gt; boolean &gt; Takes any value and then any value and returns an array containing those values. ...I guess you meant it returns a boolean. You appear to have repeated this error for the `isIterable` documentation. Also - from the same section: isArray({}) // =&gt; true isArray([]) // =&gt; true isArray("") // =&gt; false I would hope `isArray({})` would return **false** Also, `isIterable("")` returns **false** - but String is iterable? 
Rx observables aren't a replacement for promises. They are separate tools that solve similar but different problems. 
As an addendum: I do like that react native lets you integrate with native code. That's an approach I can buy into. Let JavaScript/HTML/CSS do purely UI stuff, and have the business code in the native language of your choosing. That's a great compromise 
How do you come up with ideas for opensource?
As far as I can tell it works fine in Chrome -- unless I was missing something. 
You're passing in an argument into .then. JavaScript evaluates all arguments before the function is called rather than when they are used.
Also the function you pass to `.then` will receive the return value of the previous promise as a parameter. somePromise .then(result =&gt; console.log(result))
Which test is failing? FCC run tests on the left side, it should tell you which test is failing...
You should run their expectations with your code, specifically: titleCase("I'm a little tea pot") &gt; " I'm A Little Tea Pot" titleCase("sHoRt AnD sToUt") &gt; " Short And Stout" titleCase("HERE IS MY HANDLE HERE IS MY SPOUT") &gt; " Here Is My Handle Here Is My Spout" That extra space is why it's failing.
Callbacks are blocks of code that get executed separately from the current context. Specifically, you're handling the execution of some code over to someone/thing else. Functions are the containers for code blocks that allow for this\*. All other code is executed as its reached - this includes code within argument lists. So for the promise to be able to accept code that is to be run when the promise resolves, it needs to be contained within a function. The fact that we have arrow functions now calls out to the desire to have blocks like this being "simpler" as you suggest. Before, inline callbacks required the `function` keyword and were a lot less terse. _\* except for more obscure use cases like using strings of source code and `eval`_
The code looks nice, and it's layout is clear, but I think you should've waited until you had more (any really) documentation before submitting to reddit. 
Fun list, some of the classics and others I haven't seen before. Some of them aren't very quirky though IMO. An example is: &gt;Number.MIN_VALUE &gt; 0 // -&gt; true From the documentation: &gt;The Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript. 0 is not a positive number so it follows that min_value will be larger than 0. parseInt on the other hand ... &gt;parseInt(null, 24) // -&gt; 23 
I see thanks.
Try this in a console; and look at what these return: let myFunctionCall = console.log('hello'); let myFunction = () =&gt; console.log('hello'); typeof myFunctionCall typeof myFunction The line declaring myFunctionCall is not creating a function, it is calling a function (console.log) and returning a result. The line for myFunction is returning a function, that when called will call console.log. 
He who uses this for a job interview should be killed by fire!
this is how I solved it. function titleCase(str) { var arr = str.split(" "); var arrOfChangedWords = []; arr.forEach(function(word){ var changedWord = "" for(var i = 0; i&lt;word.length;i++){ let char = word.charAt(i) if(i==0){ changedWord += char.toUpperCase() } else{ changedWord += char.toLowerCase() } } arrOfChangedWords.push(changedWord); }); str = arrOfChangedWords.reduce(function(result,word,i){ if(i == 0) return word; else return result+" "+word; },""); return str; }
https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513?source=linkShare-6849951de65c-1501516876
When the worker sees the line then(console.log('abc')) it thinks you are saying 'I want to pass the value of calling `console.log` with `'abc'` as the arguments to the function `then`. Your worker is doing it correctly and you notice that when you give it a function as you do in .then( () =&gt; { console.log('hello') } ) that it does what you are wanting. But that is because you are saying 'I want to pass the value of this anonymous function' which is slightly different than the _result_ of calling the function. 
Isn't that reinventing the job of a tiling window manager?
you see a map in chrome like in firefox? 
Works for me on Chrome, don't see any errors in the console either. Doesn't work on IE for me but well... that's IE...
That's what I thought too, but it is the "Get Started" link that's broken. Just scroll down.
I looked through the site and thought funny joke.
For fun, I cleaned your version up a little bit: function titleCase(str) { var words = str.split(' '); var arrOfChangedWords = words.map(word =&gt; { let changedWord = ''; for (let i = 0; i &lt; word.length; i++) { let char = word.charAt(i); changedWord += i &gt; 0 ? char.toLowerCase() : char.toUpperCase(); } return changedWord; }); return arrOfChangedWords.join(' '); } The main difference is that instead of manually creating the return string, I add every changed word to an array; then, at the end, I `join(' ')` them together (`join()` does exactly the opposite of `split()`). This way, you don't have to check for first word, etc. And here's a completely overdone version (but it was fun!): let titleCase =&gt; str =&gt; str .split(' ') .map(word =&gt; word .split('') .map((char, i) =&gt; char[i &gt; 0 ? 'toLowerCase' : 'toUpperCase']()) .join('') ) .join(' ');
can you source the scores midgame?
hmmm, i've tried in incognito mode, still can't see the map.... you see this? http://i.imgur.com/NQtMOpy.png
I think this new style has potential but it needs a bit of work. 1. Choice to make headings white on black is terrible. This makes the headings hard to see.
Yep, looks fine to me on Chrome 60 / Win 8.1.
If it disables silly scrolling effects like the one on this site then I'll download it immediately. I feel like I'm scrolling on ice in space.
I disagree. Rx covers all of promise scenarios while solving many additional problems. If you're familiar with Rx then there's no need for promises and async/await.
I literally can't scroll the site lol.
The football.json files get auto-generated from an SQL database (football.db) and the SQL database in-turn gets auto-generated (auto-populated) by the plain text datasets (see the Premier League 2016/17 - [1-premierleague-i.txt](https://github.com/openfootball/eng-england/blob/master/2016-17/1-premierleague-i.txt), as an example) - it works like a wiki. If you run your own JSON service you can - of course - add updates any time you want. PS: The football.db also has a [Frequently Asked Questions and Answers (FAQs) page](https://github.com/openfootball/docs/blob/master/questions.md). The short answer it's NOT a live (real-time) score service. It can be done but that's up to you.
1. You've been wondering if your app would be more performant with Vue, this could help you get 80% of the way through the transition to find out 2. You really need to use a package that's only available in Vue, so you decide to move your codebase over I'm sure there's more use cases
The simple answer is that people care far less about SpiderMonkey. V8 is where it's at right now. One day that may change, but currently it's what everyone targets and everyone optimizes for. 
Contributing the same code with different name is not good thing to do for the community and i think it damages developer credibility despite the fact the you cannot unpublish your package after publishing it. so why i should duplicate the package anyway? maybe the name is not perfect but it isn't a big issue. Regardless the fact that i always regret naming my repos so for me it's like personal policy üòÅ
The logo looks sad :c
Update: I just fired up a Win 10 VM and while it looks fine on edge, it doesn't work on Chrome. I get a JQuery-Error with Chrome on Win 10 which I don't get on Win 8.1, which is strange because I use the same version of Chrome.
Funny enough I just cleaned out my packages for Atom today, and went with ESLint/Prettier. Not bad so far.
Number.MIN_VALUE and Number.EPSILON are two different things, and most languages work similar to JS, since these are things relating to the floating point spec. C, would have something like FLT_MIN = 1.175494e-38, FLT_EPSILON = 1.192093e-07 for example
OH! I remember I saw this before! Cool
some fundamental stuff missing: event-loop functional style (composition etc.) typing (flow, typescript)
This article is written in relation to one specific framework, and doesn't mention the underlying vanilla methods for manipulating the browser history. [history API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) [location hash](https://www.w3schools.com/jsref/prop_loc_hash.asp)
It works in Windows 10, Chrome 59.... with Dev Tools closed, but it fails to load if I open Dev Tools. Edit: It probably doesn't show up in Chrome while Dev Tools are open because there is an error and it blocks rest of the code from executing. You have jQuery 1.4.4 loaded (accordion plugin is attached to this one), but then "js_injector_9.js" loads 1.11.3, so while initial jQuery version which was used to attach dom ready callback is 1.4.4 callback is executed after jQuery version was overwriten and it tries to call accordion plugin on 1.11.3, that's the problem. jQuery(function() { // &lt;- 1.4.4 jQuery('.accordion-menu-1').accordion(... // it's already 1.11.3 here });
i am on Windows 10, Chrome 59.0.3071.115 fails to load no matter what. get this error Uncaught TypeError: jQuery(...).accordion is not a function at HTMLDocument.&lt;anonymous&gt; (states:101) at Function.ready (jquery.js:30) at HTMLDocument.u (jquery.js:38) I thought this was due to a menu not rendering. not part of the map issue? WTF, now it will load in incognito mode in with dev tools or not. 
I edited my comment above, you should load only one jQuery if possible.
Seems like it, yeah
In the first example you're not passing a function as an argument, you're executing the function and passing it's return value. So, at first, `console.log('hello')` will be executed and then it's return value (`undefined` in this case) will be used as an argument for `.then` call. In the second example, you're making the arrow function `() =&gt; { ... }` and pass it as an argument.
can we talk about this: var c = 'constructor'; c[c][c]('console.log("ur mom")')() being `eval()`'s meth-head cousin? 
I second your disagreement: Rx and Kefir fully solve the problems Promises do. In order to keep your own authored interfaces generic, I would warmly recommend to revert to Promises or events though.
Yep I was thinking the same. On the subject of Promise, the ES decision to use 'then' for both map and bind (flatmap) still annoys me. It seems many developers don't understand the difference which leads to a mess. As seems the case with the author of this piece.
Yup, see a map that highlights onhover, click that sets window location etc.
They put out less content too. Take [Benedikt Meurer](http://benediktmeurer.de/) he's always putting out quality js/engine info that is chrome relevant. God bless him.
 minions $&gt; 'ba' + + 'a' + 'a'
Wow, this sounds pretty awesome
&gt;To take it a step further we want you to be able to just drop in any Rust, C++, C file into your project, and then use it like a JavaScript module. &gt;Once we have a basic implementation completed (as part of our fulfilled milestones) we will then focus on working with experts in the LLVM, and language communities to create loaders that will take raw language files and return WebAssembly modules! Well that would be amazing
[Here](https://www.reddit.com/r/javascript/comments/6qqtx0/state_promises_asyncawait). The whole point of this is that there's a monad lurking here. You need State + Promises, and this is where async await is nice. The issue is javascript doesn't have a notion of Monad Transformers that bind State and Promises in a nice way. Luckily, async/await provides syntactic sugar to automatically nest State in Promises. This is exactly similar to Do notation in Haskell.
In frameworks like Express you can write a handler to reuse 
I wanted to share this to explain this quote a little more.. &gt; Not all that shines is gold. Problems arise when Promises are not used as intended. Promises aren't being used correctly when a developer mixes state with promises. If you are just passing along data in your promises chains, all will be well. In fact, you could use *Promise.spread()* and *Promise.all* to mix async calls and data to pass them along to other chains, but there's usually a lot of issues in practice with doing that, since it makes the code quite terse. When you use a *var* object and you manipulate it outside of a promise callback's scope, you aren't using promises correctly. This is where async/await shines, and the example I wrote up hopefully explains this well.
I would say that observables and promises are quite different in what they represent, but are often (ab?)used for solving intersecting problems. For example: for a single network request, or a case when you want to chain multiple async operations, a promise is a much neater representation than an observable. On the other hand, observables are much more elegant than promises for modeling something happening over time, e.g. mouse events. Yes, you can wrangle either one into each use case, but it ends up being quite verbose (e.g. building up a hot, multicast, cached observable for a network request).
Ethereum contracts need to be written in Solidity. See here: https://solidity.readthedocs.io/en/develop/ While there are Javascript libraries for checking Ethereum balances and starting transactions, the actual *contracts* cannot be written in Javascript.
So solidity it's the only option?
basically vivaldi without the interesting stuff? I'm not convinced, even less by people that uses smooth scroll JS libraries in a page, breaking it completely for mac users
Yes, Solidity is the only usable option for now. There are some older, obsolete ways of writing smart contracts, but there is no point in using those anymore. Ethereum smart contracts run in a virtual machine environment with very limited resources. There is no way to run a general-purpose language like Javascript in there, but Solidity is designed from the ground-up with these limitations in mind. This is why you have to use it.
Christ, thanks for that catch! I'll make the fix immediately. This is likely from the time where I was still copying from other packages to create new packages. As for `isIterable("")` ... That's a much more complex issue I need to tackle. What would you expect, as an end user?
I want to be a blockchain developer. So you think I should just stick with solidity? Or should I learn Go or JavaScript too?
Congrats, this is amazing. One topic mentioned in the article is: code split stylesheet chunks. To do this with webpack and React today, check: https://github.com/faceyspacey/react-universal-component
Javscript + Solidity will allow you to build Ethereum apps. The smart contract is the code that runs on the blockchain and handles the money. Then, you would typically write some kind of Javascript GUI to talk to the blockchain and initiate transactions. For example, you might write a smart contract that sits on the blockchain an acts like an insurance company, collecting premiums from subscribers and making payouts in response to claims. The idea is that all the "money stuff" lives on the blockchain and runs autonomously, so humans can't corrupt the system. Now that you have your virtual insurance company running, you need some way for clients to actually subscribe and make claims. For this, you would use Javascript + standard technologies like React or Vue.js to build a nice GUI. The GUI would have buttons for creating accounts, making payments, submitting claims, chatting with other users, and all the normal stuff you would expect. I work in the blockchain space, and this seems to be the standard approach to building these types of things.
I'm going to be doing something similar in the near future. My plan is to [promisify](http://bluebirdjs.com/docs/api/promise.promisify.html) the applicable callback chains and use the promises in `async/await`.
Dream team! Especially great with TypeScript, since you can just toss TSLint and enable "noUnusedLocals" in the tsconfig, pretty much removing the need for a linter. üéâ
I think this is the way to go. I think the only reason you'd ever _not_ go with async/await is if you care about older browsers, or if you don't like how big Babel/TypeScript's output for it is. Otherwise, it just makes code so much more readable 90% of the time.
Observables represent a stream of values changing over time. A promise represents a single value. Saying that observables solve all promise scenarios is like saying Arrays solve all value scenarios. Types are important, since they enforce a contract. If I call your method that returns an observable instead of a promise, I have no guarantee it will behave the way I expect it to. If it returns a promise, there's no ambiguity. 
The whole point of the article is that no url was used for navigation and routing. If you are not using the url, guess what? You aren't going to have any browser history either. So brining up history API and location hash are irrelevant to what this was about. This is about routing for hybrid apps that are single page apps. You never go to another page. You just navigate around on the one page. 
Idk if that would work well given how much the optimal code for performance changes between Node versions. IMO if you're really that concerned about Node performance to this level of detail, maybe Node isn't the right tool for you.
Personally I'd go with yes, a string *is* iterable because it can be looped but also because of these two statements: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol &gt; In order to be iterable, an object must implement the @@iterator method, meaning that the object (or one of the objects up its prototype chain) must have a property with a @@iterator key and this: &gt; The [@@iterator]() method returns a new Iterator object that iterates over the code points of a String value, returning each code point as a String value. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator 
Great points. I think that's finally tipped me over the edge. Strings and Buffers will likely be supported in the coming days. I've already fixed the documentation issues.
Of course you can, i believe. It worth look over the Sindre's series of promise utilities called Promise Fun. All of these modules are very small and tested. https://github.com/sindresorhus/promise-fun
&gt; given how much the optimal code for performance changes between Node versions That's sort of the point. Some of the performance differences can be really significant, and if we can define "equivalent" ASTs that allow performance optimizations during transpilation, it could automatically improve performance. And it would really be more as an interesting exercise; I agree that those optimizations are probably not required, but it would be interesting to see what kind of performance different scripts "leave on the table" for different releases.
I love TS, but you've listed pretty much all the alternatives. Two more worth looking into, which I like, are [Elm](http://elm-lang.org/) (though it's not full stack) and [ScalaJS](https://www.scala-js.org/).
The calls to get colours and companies are unnecessarily being done sequentially. This whole article could have been simplified to: Promise.all([getCompanies(), getColors()]).then(([companies, colors]) =&gt; {...}); Or let [companies, colors] = await Promise.all([getCompanies(), getColors()]); The real advantage of async/await comes in cases where B depends on A and C depends on both A and B.
If Babel could detect which Node version you should use and also have different optimizations for each version of Node, perhaps this could work. I also have concerns about using these baseline performance from tests as the determinations of optimality. You'd need really robust and diverse tests to be sure you are testing each feature for a variety of use cases and that performance is consistent between the cases.
The history API allows you to push and pop states off the history stack using JS without navigating to a different URL. Since the article mentions working with the user's back button, which takes you to the previous history state, undoubtedly that is what the "router" class is doing under the hood.
Yup yup. See my comment, which says what you said, and yes this is a slightly contrived example. Personally, I don't like using promise.all because you pretty much constantly duplicate the arguments and return data values. Do you really want to continuously pass existing values just stringing them through callbacks over and over?
I enjoyed this, nice look at the potential internals of the 'usual' libraries. Also became acquainted with lite-server and now through this.
No, the back button is not used at all. It has its own back button. Did you even look at the examples in the article? This is for hybrid apps. There will never be a browser back button. 
The other alternative if you prefer not to use Promise.all is to use await inline when you call the final function. async function fetchActiveUsers4() { let companies = requestActiveCompanies(); let colors = requestActiveColors(); return requestUsers(await companies, await colors); }; This lets both requests run simultaneously.
Thank you so much. We really think so too. We really want to learn on the experts in other languages to collaborate and really make something powerful and impactful for the web.
One step closer to: https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript
I think Gary would be proud to see we're striving make any programming paradigm a part of the web
Does it have to be JavaScript? Or can I do it with golang? Cuz I find JavaScript kind of hard to learn
Or I can use bubble programming platform for the app right?
Not that I'm aware of.
It's not doing anything for me. What's expected for the "key"? I tried: https://jsonplaceholder.typicode.com/posts
Congratulation for webpack! I think in later you will be the most important the project in programming. Before I think too hard but now it is ok
"That's only because the planet's run out of people who don't know what React is."
React is complete garbage compared to vue.
What makes you think so?
Because I've used both.
Any specifics you can point out about the cons of React vs Vue? Just out of curiosity. 
Hacker News clones are being used for Progressive Web Apps benchmarks: https://hnpwa.com/
Wow. Wow. That would be revolutionary, and not just for JS or the web. That would mean the theoretical possibility of collapsing every ecosystem into just one, interoperable set of modules. You could write in C++ and just require a module written in python, but maybe you wouldn't even know it was written in python. Somewhat ironically, I think you could still host all these modules on npm without any major changes in the way npm works right now. If you have a C++ loader, just require a C++ module. No problem. 
welp, i'm convinced. there you have it, folks!
Pretty much. However, formally it's a bit different. SQL's `in` checks if the given element is in the given Set. JS's `in` checks if the given object has the given property defined on it. See the [ES3 spec](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf#sec-11.8.7) (page 54): &gt; **11.8.7** The in operator &gt; The production RelationalExpression : RelationalExpression in ShiftExpression is evaluated as follows: &gt; 1. Evaluate RelationalExpression. &gt; 2. Call GetValue(Result(1)). &gt; 3. Evaluate ShiftExpression. &gt; 4. Call GetValue(Result(3)). &gt; 5. If Result(4) is not an object, throw a TypeError exception. &gt; 6. Call ToString(Result(2)). &gt; 7. Call the [[HasProperty]] method of Result(4) with parameter Result(6). &gt; 8. Return Result(7). And here's `[[HasProperty]]` (page 28): &gt; **8.6.2.4** [[HasProperty]] &gt; When the [[HasProperty]] method of O is called with property name P, the following steps are taken: &gt; 1. If O has a property with name P, return true. &gt; 2. If the [[Prototype]] of O is null, return false. &gt; 3. Call the [[HasProperty]] method of [[Prototype]] with property name P. &gt; 4. Return Result(3).
you just need a formula for calculating current percentage given the total amount and the amount completed so far. You're on the right track.
In JavaScript `in` is used to see whether an object has a property (either directly or in its prototype chain) with some particular name. So if you have var obj = { name: "Fred" }; then ("name" in obj) will be `true`. It's really quite different from the SQL operator, which checks to see if a value is in a set of values. Well, significantly different at least; the right-hand side of the JavaScript `in` has to be an object reference.
I've been using async/await for a while now in node via transpiling. It makes for much cleaner code. A common pattern now is for functions that were previously called with a callback is to return a promise if the last argument is omitted. For modules that don't provide promises I'll write a helper module that just wraps it and returns a promise out of a callback. Easy to do.
I miss eslint + prettier so much when I hop on other languages. Well maybe not go so much (because of gofmt), but I'm not using go very often.
yeah just use Vivaldi 
Your forgot to suffix your sentence with an "IMO" ;) Because lots of large-scale projects use React and it's working out perfectly.
still garbage. lots of people eat it.
Really, mister? Tell me which syntax feels more intuitive for a vanilla JS developer: Vue.js with obfuscated HTML attributes prefixed with a `v-` and also using a separator of `:` (talk about hacky-looking solutions...): `'&lt;button v-on:click="counter += 1"&gt;{{ counter }}&lt;/button&gt;` Keep in mind that in the above, you're writing an expression in a String form: `"counter += 1"`, same as if running a loop in Angular 1 / 2 by declaring a string attribute. or React (JSX, which isn't some choppy HTML parser with confusing attributes and logic (like `{{ }}` wrappers for outputting variables...)): `&lt;button onClick={this.handleCounterIncrement}&gt;{counter}&lt;/button&gt;` You know, I kinda prefer writing normal HTML-like attributes than `v-on:click` and similar. But that's just my subjective opinion and I don't call any FM a "load of crap" :)
I am incredibly excited for this!
I used both and Vue is just a poor try to be react :)
Just wait until you get deeper. Vue took the good things from react, backbone and angular and created a very simple intuitive framework. vuex makes the redux pattern a piece of cake. Its complete abstraction chaos in react.
redux is so much simpler in vue.
&gt; 0 is not a positive number so it follows that min_value will be larger than 0. I remember my maths there was almost always some type of definition of whether or not 0 was considered positive for the course, ie I can see how someone may be confused.
I still do not understand what was the problem with URLs. You pretty much reinvented them without benefit 
you can go infinitely far with this sort of thinking. *"an existing widely distributed universal virtual machine? essentially the same thing as a java"* all the way to *"machinery for the generation of computable numbers with an application to the entscheidungsproblem? pssh, i'll stick with my slide rule"*. If you put aside the metaphors, I think you'll agree that this could be absolutely revolutionary. The very concrete paradigm shift of programmers using a wider variety of languages is just the surface.
Such beautiful code.
+1 yeah can't scroll either. I hate website with scroll hijacker like this
that may be true..but once you understand redux properly..it is simple everywhere :)
If you are embedding v8 in a standalone C++ project, then good luck! This is definitely an advanced use case. Otherwise, the easiest way to run Javascript in the shell is via node.js. The node.js project basically gives you a pre-packaged v8 engine along with a bunch of infrastructure stuff you are probably going to need anyhow. It also has a native plugin system, so you can call out to your C or C++ code from within Javascript. Depending on your use case, this may be everything you need.
Within Node you can use `process.version` to find the current, so Babel would have access to that. I agree that it would require careful analysis and scoping of the test cases and replacements to avoid creating problems. We can basically look at all of the behaviors and concerns of any compiler... the optimization levels in gcc or llvm, or the byte code generator for the jvm. It's nothing new to optimize for a platform; just new to JavaScript.
Have you seen the docs here? https://github.com/v8/v8/wiki/Building%20with%20GN In the "Complilation" section, they mention having to pass some options to get the binaries. Otherwise, it seems like the default is to just build the v8 library without the tools.
Cordova Native Apps - https://www.npmjs.com/package/cordova-plugin-media-capture React Native - https://www.npmjs.com/package/react-native-record-sound Standard Browser - https://www.w3.org/TR/webaudio/
Shouldn‚Äôt probably say that since React will most likely land you a job faster than Vue. 
This is huge! Awesome news. Have been looking forward to having webassembly as a part of the stack!
[Here is an advanced use case](https://zachrip.github.io/react-itinerary/advanced.html) (not mobile friendly) - you can see it does two things based on the video's current playhead: scroll to the description on the right and highlight it.
Some people asking me why I hate developing in javascript. I found it difficult to explain but not anymore thanks for this article :)
I feel like giving the extension .wat to web assembly modules made Gary do a sensible chuckle.
npm run dev:app npm run dev:component etc. dev:app runs webpack --config webpack/webpack.config.app.js dev:component runs webpack --config webpack/webpack.config.component.js 
Oh I didn't know I could name scope files like that. Is it possible to have it all in one file though? So all files are watched at the same time?
I'm using Cheerp to compile C++ into WebAssembly. You only have to download the Cheerp setup, then you can compile everything with a single click. Setting up emscripten etc. yourself can get quite complicated, Cheerp does all that for you! I really recommend this if you want to play with C/C++ -&gt; Wasm/JS compilation
This sounds nice, I will surely try it out
You can also use multiple configurations with an array, you're not limited to one config object. &gt; multiple configurations &gt; In both cases you can also use an array of configurations, which are processed in parallel. They share filesystem cache and watchers so this is more efficient than calling webpack multiple times. https://webpack.github.io/docs/configuration.html 
This is fantastic news as a web extension developer and consumer. Anyone know where's best to follow progress?
nice one, I suggest you to add tests and a prop to enable/disable keyboard shortcuts (I automatically used right arrow and expected it to change as it was full screen) - smaller tip: fix your email mapping in git to github user
nice! the keyboard touch would be nice now you say it!
This really is the current barrier, generating WASM modules. I have used WASM but it's a pain in the backside, you essentially have to have a separate tooling and build pipelines to make it work.
npm-run-all
The benefits are: 1. Organise your Redux stuff in one place(no more explicitly defined `action type`s or `action creator`s), and no need to explicitly `dispatch` your actions. 2. Handle your Router stuff more efficiently, no need to manually create `history` object, etc. 3. Yet keep the APIs as simple as possible.
Very nice looking! I have a few suggestions to make it a little more versatile: It would be useful if it could optionally take components instead of images as children, then customized content could be shown on each slide as well as controls like buttons, etc. &lt;Slideshow&gt; &lt;Page1 /&gt; &lt;Page2 /&gt; &lt;Checkout /&gt; ... &lt;/Slideshow&gt; Another suggestion would be to allow us to control it, like `defaultIndex={...}` for uncontrolled and`index={...}` for controlled slides, as well as an `onChanged` callback. If index is set it would override all autoplay options.
I have added the keyboard functionality :-)
thanks for the feedback, sounds great, all good points! Let me look into these now!
I really like it, but i'm not so sure about wrapping react/redux, it seems a little implicit and would have countless of implications that i'm certain some people wouldn't be willing to put up with, like what happens if i alias to preact in my production build, etc. I think your idea would work just as well without putting a fork in react and redux. import React, { Component } from 'react' import { render } from 'react-dom' import Mirror, { connect, Provider } from 'mirrorx' Mirror.model({ name: 'count', initialState: 0, reducers: { increment: state =&gt; state + 1, decrement: state =&gt; state - 1, }, }) @connect({ count: Mirror.models.count }) class App extends Component { render() { return ( &lt;div&gt; &lt;h1&gt;{this.props.count}&lt;/h1&gt; &lt;button onClick={Mirror.actions.count.decrement}&gt;-&lt;/button&gt; &lt;button onClick={Mirror.actions.count.increment}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } render( &lt;Provider store={Mirror.store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'), )
&gt; Its complete abstraction chaos in react, **for me**. Fixed that for you
Thanks, I missed that part. 
https://github.com/gothinkster/realworld https://realworld.io/
It's a nice idea! Although the problem is when to create the `store`? The first time `Mirror.model` is called, and latter calls to `replaceReducer`? That could be done. The idea to follow the `connect` and `render` method of react/redux, is to "not invent new concepts &amp; APIs", although it does make confusions. As for global `actions` object, I think the purpose is to make presentational components to dispatch actions without `connect`.
Hi, I'm also one of the creators of Uppy, so if you have any questions or remarks about what we're doing I'd love to hear
I have updated the code making it possible to now pass in components as well as images. Thanks for that pointer, was a good one! Also, a user can now set a `defaultIndex` 
Sweet, thanks for the quick reply! React Native looks great. 
thanks for your help. i got this working by putting the map jquery in the footer instead of the header. what are your thoughts on this workaround? 
updated now
Where is your script tags located into your html file ?
what about match times? I'm not seeing them in the JSON files are they in the source DB?
Sorry for the late response. That makes a lot of sense. Ahhhhh, so generally speaking, when using generators you are doing it to avoid the overhead of computing large amounts of, well...anything really, in advance, and to simply do it on demand?
Thank you for your comment. I removed the smooth scroll.
replaceReducer would work. Since Mirror.model is executed in module scope it would construct a merged store that the provider would later be able to pick up on. It would probably make more sense though to let Mirror handle its own provider because in rare cases (async imports) models could be constructed when the app is already in place in which case the providers context doesn't update. Your provider could forceUpdate. Overall i think it would be best if it would keep react/redux underneath as it is while abstracting reduxes structure into a model interface.
Looks great! Will probably add this to my current Aurelia project and see how it goes.
Sushi Browser is a new browser using muon framework. Muon is fork of the electron framework which is currently used in the Brave web browser. https://github.com/brave/muon
The "how it works" was the one thing I came for. Maybe a tl; dr at the top with a link to that section?
That would be amazing! Let us know if you run into anything, we'd love to help you out in our github issue tracker.
Great idea, I just added this. Should be live in a few minutes. Thanks for the suggestion
Thank you for your comment. I removed the smooth scroll. 
Would this work with a PHP backend system? To me it looks like it's node only at the moment?
Uppy is just 'some JavaScript for the browser'. The Xhr plugin (comes standard) can upload to Apache/Nginx/etc, so you can certainly handle your file uploads in PHP like you would already. As some extra info, there also is an S3 plugin to upload to S3 buckets directly, as well as a Tus10 plugin, which requires running a https://tus.io compatible server such as tusd. There also is a Transloadit plugin which aside from handling uploading can also do encoding for you.
Much better. Thank you for listening and responding.
[Here is a more advanced use case] (https://zachrip.github.io/react-itinerary/advanced.html) (not very mobile friendly)
That's what I am looking for. Thanks.
I'm still not sure why you need 2 jQuery versions, why not just use 1.11.3?! It should have all the same features and backward compatibility. Also "jQuery1113" variable is actually 1.4.4, because $.noConflict() returns current jQuery and then you load jQuery 1.11.3 which overwrite jQuery variable, so "jQuery" variable is actually 1.11.3.
Redux maintainer here. I've definitely been [encouraging the idea of building useful abstractions on top of Redux](https://github.com/reactjs/redux/issues/2295). However, at first glance, I'm not entirely sure how much additional value this adds. To be honest, it looks a lot like [Jumpstate](https://github.com/jumpsuit/jumpstate/), just with a bit of router wrapping and fewer other capabilities. The insides look kind of similar, too, particularly use of module-scoped lookup tables for actions and reducers.
Looks great!
Everyone and their dog seem to over engineer these days. Why use this unreadable abomination when "extends" or "Object.assign" work perfectly fine and make it clear what's actually happening.
JavaScript Core is faster, kinda bored of v8 bloat. 
All my variables depend on server side info so Im unsure of how much "intellisense" even matters in this case.
One benefit is that the parameter is now statically analyzable, so editors can provide hints. Before to get the same thing you'd have to write a massive JSDoc block. 
Use what works best for you. Between notepad++ and atom, I prefer notepad++
I see it as a good thing that we are "over engineering" these days. It means we are letting people explore the language. Sure, it might suck but so do most books. Let people explore the language and learn to write crap code!
Exactly. It's a huge thing in Haskell.
Your code is hard to read.
Eli5 what's css regression?
Hi /u/sebastianstehle, I'm struggling to find any relevance between your link and /r/javascript -- can you help me out?
Changing the CSS (stylesheet) rules for one piece of code can sometimes have unintended consequences for other areas of a website. This tool is intended to catch these problems and explain why they might occur by analyzing the resulting html and CSS
The given example is definitely a little weird, but the object spread operator is definitely less cluttered and just as easy to read as `Object.assign` const DEFAULT_OPTIONS = { color: "#fff", height: 100, width: 100, } const DARK_OPTIONS = { ...DEFAULT_OPTIONS, color: "#000", } const RED_OPTIONS = Object.assign( {}, DEFAULT_OPTIONS, { color: "#f00" } )
Awesome, thanks a ton for the reply!!!
Hi /u/Gooey_kablooy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
util.promisify() can interact directly with the V8 API, so it doesn't create closures and will be faster than userland implementations. This module uses util.promisify and the latest ES6 features (like Proxy) to promisify all methods. It does not modify an original object or function (immutability)
Actually Squidex was born because I already built several startups and it was always difficult to build up a good backend from the beginning. One of our goals is to help Javascript developers to create their own backend for the beginning and then migrate it to more powerful solution with content delivery tools, e.g. webhooks or RabbitMq.
Very cool
Atom eats all my memory. I don't recall, does Notepad++ have autocomplete for words in any files added to the program?
Atom is developed by a larger community so it gets faster updates and more plugins, like a built-in terminal. It's more customizable and looks better. Also consider [VS Code](https://code.visualstudio.com/), it's a more stable competitor to Atom with git integration. That's what I'm using now since I got fed up with Atom's arcane update process that changes the executable's directory every update, messing up my paths.
Sure thing, that's not the problem. The wrapping in a function with default param magic is the problem. It's just confusing and definitely harder to read than Object.assign.
You save some lines of JSDoc but have more code. That's really not a good trade if you ask me.
Nothing against experimenting. I just don't think that particular gist is a good example of it and I'm more concerned that some JS beginner sees it and thinks it's the new hotness, while it's really an antipattern (at least I think it is). Props to OP though for trying out new things &lt;3
I started a large electron/cordova app with aurelia a year ago while knowing very little JavaScript! The learning curve was reasonably steep but that wasn't helped by also having to learn TypeScript, JavaScript, all the build systems and nodejs native comms with legacy hardware. It was worth it though. Coming from a c# background, Aurelia seemed the most sane option at the time as it pairs valid ES6/TS classes with valid HTML markup, all hooked up through dependency-injection and some well documented magic. The few times I have to reference aurelia dependencies are to add decorators or access the router. I've ended up with clean UI code that could be maintained and refactored by anybody who knows TypeScript and the simple binding syntax. As far as I can tell there are no immediate plans for a v2 as it already does the job it was designed for. Oh, and the binding syntax is valid SVG too! So even visualisations can be componentized and data-bound and are still remarkably quick to update even running on Android/iOS via cordova.
Is there a size limit to which the uppy.io is restricted to?
Not backing the guy up but the Vue example can also be written as: ``` &lt;button @click="handleCounterIncrement"&gt;{{ counter }}&lt;/button&gt; ``` Whilst that's still not using standard HTML attributes it makes it a lot more similar to your React version.
Yes, the match time is part of the source file / database schema. However, not all match schedules include match times (just the date) and the date itself is not always the "true" date e.g. one matchday on saturday for all when really some matches are on sunday and maybe one on monday too. Easy to fix! Just edit! Again see the premier league or others as examples. Cheers.
I dont think so. Just regular command / variable auto complete. Though I might be wrong.
If you're consistently running into these errors, IDK what to tell you. Triple equality checks and basic reasoning avoids pretty much all of them, and it's not like other languages have nothing wrong.
&gt; Atom is developed by a larger community so it gets faster updates but really for a js editor this is not a concern of mine. im never writing code then thinking "darn this doesnt work because my editor hasnt been updated!"
Without a dispatch for the actions aren't you losing the ability for multiple parts of your state to handle actions or for actions to be transformed by middleware? The example doesn't look like you are using actions at all and are just directly invoking a reducer. Still seems like a neat library for a site that wants to use a redux/react like approach when they don't need the flexibility of redux's action pattern.
That definitely breaks DRY and KISS principles, so not worth it.
What are you finding hard to learn with JS? Feel free to PM with specific questions.
I am not. It's just the language is full of inconsistencies. That's what this whole article about. You see code, expect it would behave in certain way (the logical way) but article show you that or doesn't
Depends on how it was made. There may be an easy way to move forward, but you'd also want to stop the timer so that when the old timer finally does complete, it doesn't do something unexpected like move you to the next next slide when you weren't done with the next one.
Then Notepad++ is ideal for you, if you simply want stability and feature maturity with no "fluff". For people who care about quality of life in apps though, ["fluff" ("meaningless" incremental improvements) accumulated over time can add up to a big boost to their productivity.](https://blog.codinghorror.com/this-is-all-your-app-is-a-collection-of-tiny-details/)
If there was a way to keep it moving while skipping everything, that'd be ideal. It's just reading. Is there a way to do this?
You mean a size limit for uploading files? Nope, if you want you can set arbitrary limits for the end user. But otherwise Uppy imposes no limits. It's possible that the backend receiving the files might impose limits (haproxy, apache, nginx, tusd, or the filesystem) but those can often be configured to accept very large files (large as in e.g. 100GB). Does that answer your question?
Maybe it's a bad example but the code from this snippet looks a lot better (more readable) with `extend`. Destructuring in this case seems to just add more boilerplate and make things less clear.
I'm here to evangelize [Sublime Text](https://www.sublimetext.com/). That is all.
Ok, I'm still not convinced that it's appropriate for /r/javascript, sorry.
Putting a program together. Remember syntax importing packages, data structures and algorithms.
I was looking at this the other day so I could finally ditch dropzone and couldn't figure out how I might possibly hook into an event to be able to do something when a file is added before it's uploaded. For example I wanted to be able to generate a signed s3 url externally and set it before uploading the file to it. Last I saw someone had an open pull request adding an s3 plugin but still I was curious if it was possible to do this in any way?
Also not backing the guy up but you can use JSX in Vue if you want to https://vuejs.org/v2/guide/render-function.html#JSX
Is JS your first language? 
I took c++ in college. I know basics. I gave up JS. I'm learning go now. Are you a programmer? If so what languages?
Yes, I am a full stack JavaScript developer for a living. I "speak" C#, Python, Ruby and Solidity, as well. The confusions you have seem strange for someone with a C++ background; the majority of keywords are the same: for, while, do, if, switch, etc. If a file exports via "export default" or "module.exports=", another file may import via "import" or "require". DS+A is just about the same in every language. Remember: JS only has number, string, boolean, function and object to remember!
Android has a back button that should navigate back to the app's previous screen. If you use URL hashes you get this behaviour for free.
First two things that come to mind are. 1. It seems very common for people to forget to put an empty object as the first arg in object assign leading to mutation. 2. People don't want to include a library to do something that native JS can do on its own
There is a use case for this when you want the concept of routes but don't want the user to be able to manipulate the url, either by editing it or hitting back/forward. Typically games.
CSS is basically designed to introduce regressions.
That's cool. Can you be my mentor? Lol teach me some stuff
If you have specific questions, I'm happy to answer them.
Nice to hear! üòéüëç
I want to become a blockchain developer. That's why I'm learning solidity and go. I'm still new to the whole programming world. Any advice for me?
Do I understand correctly from the "How it works" that crash recovery only works for up to 10MB per file and 300MB total?
I'd opt for just using Object.assign and [cutout the dependency](http://loda.sh).
by the way the gist is not mine it's from Kyle Simpson the author of the book series " You Don't Know JavaScript " the book series that changed my look to JavaScript as a language :)
For a browser crash, yes. We can recover bigger files for tab crashes/accidental navigate-aways, and 'unlimited' file size recoveries in the face of network or server issues
The Discussion on twitter : https://twitter.com/YDKJS/status/892365449081565184
Hi! That's been merged and you should be good to go. We also added more docs about the events that we emit, but also admittedly still have some way to go to perfecting the docs. Please check if the merged PR addresses your issue (it should!) and let us know in the github issue tracker if it does not, then we'll get this sorted out with you.
preach brother,.....preach. (also a member of said church) 
I'm always a bit incredulous at the idea that "React is hard to learn" EnyoJS, Knockout, jquery mobile, sencha, GWT, Ember -- I've used them all (plus a few more esoteric ones). All of them had long learning curves (weeks to months) and lots of issues to work around. The cherry on top of overly-complicated frameworks is Angular 1. It took a few days to learn the basics. Immediately after, I was neck-deep in the digest cycle and dependency injection hell while memorizing all the weird angular terms for everything so I could write extremely complex directives to do simple things. All in all, it took a couple months to understand well and a large project before the WTF moments became infrequent. I decided to try React a month or two after it released. The thing that sold me more than anything else is that I learned everything in a day or two. I was afraid of running into a bunch of hidden issues, but it never got any harder (4 years in and I've only run into a handful of bugs with most of them being esoteric IE issues). I've taught at least two dozen developers to use the framework and I can say without any hesitation that the framework is never the issue (a couple days to learn the syntax and a week or so to be productive). If you don't understand JS and common JS dev patterns, then you will have issues, but if you understand these things, then learning is a breeze.
&gt; competitor to Atom with git integration This makes it sound like Atom doesn't have git integration, when in fact I'd argue that Atom's git integration is a little stronger (which makes sense because its by Github). I would add to this the metaphor that Notepad is a rock, Notepad++ is a hammer, VSCode/Atom/Sublime are an expandable set of power tools, and IDEs are like a full workshop. Once you get used to power tools, such as snippets, ESlint with StandardJS or AirBnB (can't overemphasize this one), git integration, autocomplete, etc, it's pretty hard to want to go back to a hammer.
Atom alone, no. But the Eco system is undeniably great. Plugins make it super awesome. Take a look at this post for example ‚ÄúThe Ultimate Atom Editor Setup (+for JS/React)‚Äù @elado https://medium.com/productivity-freak/my-atom-editor-setup-for-js-react-9726cd69ad20 I can tell you that setup is incredibly productive. I am an Intellij user, I have the paid version and I have loved it for 3 years now, but this setup makes me use atom for my react webapp, for everything else, I still go to Intellij. The most compelling reason for me to give atom a shot was that it was created in JavaScript by people who use it for developing in JavaScript... That gives me confidence that atom will grow and pretty sure solutions for what I am looking for would be existing and its just a matter of me finding them. 
really cool man! do you mind me asking how you got all the data?
Looks good but very light on documentation and the copyright 2015 at the bottom isn't a good sign... Has anyone tried this out?
Your code breaks DRY. Here's a better example IMO: // ************************ var settings = { url: "http://some.other.url/", data: 42, callback: function(resp) { /* .. */ }, additionalHeaders: ["Accept-Language: ES-mx"] }; ajax( ajaxOptions( settings ) ); // ************************ const optionsDefaults = { url = "http://some.base.url/api", method = "post", headers: ["Content-Type: text/plain"] }; function ajaxOptions(options) { return { ...optionsDefaults, ...options, headers: [...optionsDefaults.headers, ...options.additionalHeaders] }; } Cleaner and more concise about what is happening. No repeating yourself. 
&gt; while it's really an antipattern (at least I think it is). Do we want to teach beginners best practices off the bat or do we want to show them how easy it is to get started with the language and then have experience/lead devs teach them the "best practices" per team or the patterns that the team uses?
Notepad++ started as a simple text editor and wasn't exactly built for flexibility, even though it got some important features like workspaces. Atom was built for a certain kind of developing from the get go, it isn't a retro-fit. Due to its plugin based architecture it evolves rapidly. Atom takes in additions daily due to the sheer number of developers hacking away at their plugins.
*cough* ftp. 
Thanks for pointing that out! I created this site recently as a side project and it's definitely a work in progress. Feel free to reach out to me directly for any feedback. 
I certainly think that teaching antipatterns is not a good way of teaching at all, unless it is explicitly stated as such. Showing the various ways of solving the same problem is good but why not start with the "good" solution (whatever that might be) instead of the subpar one.
Hmm, maybe it was some plugin in Firefox acting up, so I'll check on my end. I'll also give that CSS file a look, thanks! BTW: with Myrtille in fullscreen mode, just today I stunned my colleagues with the things *my* workstation can do where theirs are limited by firewalls, Citrix, DMZs, proxies and such. I let them wonder a bit and then explained that all the good stuff (Azure VM and Myrtille) actually runs off-site. That was FUN! *Edit: spelling*
Thanks for pointing that out :) I didn't read the book (heard about it though). Can't judge the author's expertise really and certainly won't do it just because of a gist I don't agree with.
The advantage of uppy (and tus) is that it's geared toward websites so that can offer a seamless experience for the end user. Uppy also offers features like fetching from Dropbox. In addition, http(s) ports are often whitelisted while others are not (airports, public wifi, etc won't let you use ftp ports 20, 21, and and a vast list of arbitrary PASV ports)
I've only seen webOS developers really use Enyo (as a former webOS dev myself). I don't hear much about the library anymore.
2\. Object.assign :)
Provide a working version of the page with the timer and you might get help. Otherwise there are so may ways they could implement the timer/skip functionality that it'd be impossible to tell you more than /u/senocular has without a working example.
Ajax, but that opens you up to a lot of issues including possible XSS attacks unless you put the returned page in an iframe. You'd likely want to either get API access to the pages you're requesting or use a scrapper server side.
(Side note... your browser is a website query tool.)
well, the "C" is
Geolocation should work on iOS as long as the user has it enabled in their settings.
I did some web work with it a few years ago. I know it's still used and maintained by LG since their smart TV runs on webOS (they added a new set of core TV-friendly components IIRC). Out of curiosity, I just looked up their github and it's seen activity in the past couple weeks, so I guess it's not entirely dead yet.
Surprisingly not; I believe they're still using webOS in the TVs, though. It was started for the phone line and used a bit with the Touchpad, but then I got out of doing webOS development and haven't really checked back in since.
I've done a lot of tinkering with the location services settings to no avail. My web app won't even request user's location, so I was hoping a js snippet exists that could do just that
According to the article they use a combination of Local Storage, Service Workers, and Indexeddb to mirror what info and data they have downloaded. So it's basically witchcraft and voodoo.
In short, because this is important: Here‚Äôs the list of packages (the text version is in the post): http://imgur.com/06bK0hj Here‚Äôs the one-liner to check if your project has one of them: https://pastebin.com/1ADcWejx **Regenerate your project‚Äôs secret tokens** if you ever installed one of these.
Thankfully, it seems like [something is in the works](https://twitter.com/maybekatz/status/892501201551368192) that would keep this from happening again.
React itself was very easy to learn, at least for me. I think the reason people find it daunting is not because of React itself, but the ecosystem around it. Webpack, ES6, Redux, CSS Modules, etc all the latest tools that people associate with it kind of makes it intimidating for people. That's why it's important not to try to learn everything at once and to take the technologies one step at a time. 
Thanks! Updated the post.
Absolutely. FTP is absolutely and utterly not a viable option for many, many use cases. Looking forward to trying uppy out.
Unfortunately the value of using them might warrant their use. Of course, if you're already using a build process, this might be less of a problem. Someone could write a simple plugin which allows you to write 'private' and compiles it to '#'. I'd much prefer that the syntax were 'private'. I hope it's not too late in the standards process to change it, but it seems that it might be. I'm surprised that it could have got this far without anyone raising any red flags.
Beyond personal opinion, I don't think anyone can deny the intuitive power of 'private'. Its meaning is intuitive, and is commonly used as a keyword in many languages. It's quite bizzare why the syntax decided not to be intuitive. If the same logic were followed for other parts of the language, we wouldn't have intuitive keywords like 'function', 'class', and 'static'. 'static' is particularly interesting in this case given that it is already part of the standard class syntax, and this class field syntax is thus inconsistent at the very least. 
&gt; IndexedDB stores all files that can reasonably be stored there, up to 10 MB per file and 300 MB in total Has different (tiny) limits on Safari and probably other edge-cases. You can initialise with a size though. 
This does not actually keep this from happening again nor does Kat seem to imply that it will.
The website is www.boatus.org [Here](www.boatus.org) 
&gt; nor does Kat seem to imply that it will. I thought she was implying it would when she said &gt; It would probably catch just about everything folks have brought up
Can someone fork npm and add a blacklist to handle things that we know are malicious or undesirable? Also if there is a package that is actually malicious can we do a cyber-crime investigation?
Ahh these are for typo packages. Still terrifying. Really wish npm had done namespacing on package names.
Hi! Better docs are in progress, to answer your question: uppy.on('core:file-added', function (fileID) { var currentFile = uppy.state.files[fileID] ... }) S3 plugin you mentioned https://github.com/transloadit/uppy/pull/229 is almost ready and will be likely coming in the next release.
Thanks, haven't encountered that issue yet but I'm still pretty new to all this. Saving for later use.
Hi /u/brentschooley, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just Twilio. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [twilio.com](/search?q=%28and+site%3A%27twilio.com%27+author%3A%27brentschooley%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|10|30% [youtu.be (Twilio - YouTube)](/search?q=%28and+site%3A%27youtu.be%27+author%3A%27brentschooley%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|9|27% [youtube.com (Twilio - YouTube)](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27brentschooley%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|7|21%
This is my problem exactly. The ecosystem is just so massive and most tutorials try and introduce it all at once.
Here's the grep I used to see if any of my local packages were using the spoofed ones: Note: there will likely be some false positives ``` find . -name "package.json" -exec grep -nwE 'babelcli|crossenv|cross-env.js|d3.js|fabric-js|ffmepg|gruntcli|http-proxy.js|jquery.js|mariadb|mongose|mssql.js|nodecaffe|nodefabric|node-fabric|nodeffmpeg|nodemailer-js|nodemailer.js|nodemssql|node-opencv|node-opensl|node-openssl|noderequest|nodesass|nodesqlite|node-sqlite|node-tkinter|opencv.js|openssl.js|proxy.js|shadowsock|smb|sqlite.js|sqliter|sqlserver|tkinter' {} +```
Related: A Rust loader for webpack https://medium.com/@ianjsikes/get-started-with-rust-webassembly-and-webpack-58d28e219635
&gt; with the "good" solution (whatever that might be) The _whatever that might be_ clause is the reason I am advocating letting people ( new comers or veterans ) code their own "good" solution _whatever that might be_ as long as it **gets the job done**. Given, if you are on a team or joining a code base, there are common idioms/"good" solutions to problems that can be enforced. But we can't shit on people outside the team just because their "good" isn't the same as ours.
You could use .filter const matches = data.filter(site =&gt; site.name === "awesome"); would return matches as [ { name: "awesome", something: "YES!" }, { name: "awesome", something: "YES!" } ] I'm not sure what you want to actually match so you may need some kind of regexp inside the filter function instead of just a straight string match
I think deltaY is for telling you the user's scrolling speed (how much a single wheel event wants to scroll). You might want to increment some variable by each scroll event where deltaY is summed and converted to pixels before being written to the screen. You could determine that you want to make a finer resolution scroll by dividing the sum. There will be performance implications for this, so you'd probably want to throttle it or use requestAnimationFrame or something. 
your url needs to have a ".json" string in it. It's supposed to help keep it from not working. To solve this weird thing, just type in "https://jsonplaceholder.typicode.com/posts.json" and then remove the .json part and everything should work as expected. As for the key part, you need to try entering the primary keys of the json.
Thanks for replying! Yes, part of it is inspired by Jumpsuit(on top of Jumpstate), and [dva](https://github.com/dvajs/dva) too. I am not saying it's a great abstraction or something, it's rather a "go deeper" thing. For those who just know enough React &amp; Redux, and reluctant to set up all the boilerplates(or tons of "best practices"), this little framework can help them build up a React app more quickly and efficiently, and without breaking the pattern.
Imo, yes, because it's more functionally dependent: the structure I'm working with is explicit and limited, whereas await is often very imperative, meaning the structure is implicit in the order of lines. With ES6 you can even destructure the array very nicely. It's a matter of preference and coding paradigm to be sure. Random interesting thing to me about Promise.all is that it's really an Array method rather than a Promise method even though it's bundled into Promise. You could write a more general Array method that worked on any applicative type you give it instead of just on Promises.
well I don't know much about mongodb - The basic timestamp thing works no? I mean time stamps are go down to milliseconds? 
The "action dispatching" part is still there, when "directly invoking a reducer"(call methods in the scoped `actions` object), [all corresponding actions are dispatched](https://github.com/mirrorjs/mirror/blob/master/docs/api.md#actions) under the hood. And [middleware is still there too](https://github.com/mirrorjs/mirror/blob/master/docs/api.md#-optionsmiddlewares), of course you can specify extra middlewares as you wish, and manually `dispatch` actions. The point is simplify APIs and yet keep the patterns.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mirrorjs/mirror/.../**api.md#-optionsmiddlewares** (master ‚Üí 5aa1425)](https://github.com/mirrorjs/mirror/blob/5aa1425e0da8305c30b35184d0cfb3f2d21ee911/docs/api.md#-optionsmiddlewares) * [mirrorjs/mirror/.../**api.md#actions** (master ‚Üí 5aa1425)](https://github.com/mirrorjs/mirror/blob/5aa1425e0da8305c30b35184d0cfb3f2d21ee911/docs/api.md#actions) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dl1iziu.)^.
I agree with your premise, but I'm not sure I agree the distinction doesn't exist. If you're programming in, say, C++, and you want to access a repository of packages written that are compatible, is there such a repository that works equally well for other languages? I don't really know any build systems/package managers besides Node's, Ruby's, and python's, but as I understand it, you'd need to wrap any other language somehow to fit these package managers. Here, you could write your entire application in Python, seamlessly using node modules written in Rust, JS, and Haskell (without needing to know their languages), and later just add some files written in Java because that's what the intern knows. The compile target is wasm, but you don't really care. The point is that at the end you have one file that includes everything and can be run by any operating system that can run wasm (I assume at some point there will be a wasm interpreter like node is for JS). I could be mistaken about what's happening here, or I could just be unaware of other build systems that combine with package managers, but I believe this is actually untrodden ground, at least on this scale. For better or for worse, this says to me that the preferred compile target for many languages will be wasm just so you can leverage The Universal Ecosystem. Please enlighten me if I'm wrong in any way. I would love to learn anything I can about this and relates topics. 
I railed on and begged the npm devs in the early days to allow namespace scoping and namespace reservations that would prevent anyone I hadn't given permission to from publishing in my namespace. So @regreddit/my-neat-package would not be publishable by anyone that didn't have a key from me. They said it wasn't necessary
I railed on and begged the npm devs in the early days to allow namespace scoping and namespace reservations that would prevent anyone I hadn't given permission to from publishing in my namespace. So @regreddit/my-neat-package would not be publishable by anyone that didn't have a key from me. They said it wasn't necessary 
I put it in body, just like datatable docs.
I'm pretty sure that mongo would have something built in to have uuids generated for rows. That being said, you can also just generate a uuid yourself. The chances of collision won't be possible in your lifetime so I think it's pretty safe to use. [Check this package out](https://www.npmjs.com/package/uuid). [Wikipedia on uuids](https://en.wikipedia.org/wiki/Universally_unique_identifier#Collisions)
Sure React is easy to learn, and it has some interesting things - same for webpack and the like, but the amount of abstraction seems to get unwieldy at times. Hot-reloading is great but 20MB-30MB javascript file loads on every save bloat the browser until it crawls. The errors can be just as cryptic or difficult to debug as Angular. Babel has its own burdens of complexity. Trying to be on the "bleeding edge" of web dev is often a fools errand. Been using React for 8 months in a "modern" dev stack and I can't say it's been super-simple. I've been working with Javascript every day for over 20 years, and yeah, I know all the other frameworks too. The basics of React are simple, but the layers needed to produce a complex web app in a team environment get difficult fast. But sure, React is easy to learn. 
I ended up using mongoose-auto-increment for now as the _id's generated by mongoose are soooo long and I want the user to be able to search by ID. Thank you for the link!
i've been a user of notepad++ for years, and i never even realized it had support for code related things. i just use it in place of notepad for simple text editing. though, now that VS Code loads in about the same time as notepad++, i've not touched notepad++. Komodo and VSCode are the best tools out there, IMO, for those of us who use multiple languages. I haven't poked at Atom, though. Someone brought up Sublime a bit ago, but after a few minutes of trying to mess with it, it did not feel very comfortable to use. 
Can you pay?
link?
can you pm me? thank you!
Post the github. Don't mention bartering. TBH, I think many people here would be happy to help, but mentioning pay/bartering/etc makes everyone start thinking about lost time and compensation. 
I'll take a look anyway... 
Let me know once you have it up. I'll be happy to take a quick look around. 
Another project for this is [Backstop.js](https://github.com/garris/BackstopJS)
I think the most difficult part about react is honestly styling. There‚Äôs dozens of incredible resources for component and state management, but there‚Äôs 200 different answers for how to style components and each one is pretty valid. 
With just timestamp you will have collisions if 2 inserts happen at the same instant.
Mongo uses ObjectId under the hood. ObjectId generation has also been extracted out into https://www.npmjs.com/package/objectid. In general you should let Mongo generate ids for you. And avoid incrementing ids.
Looks like I'm clean, but how would I regenerate my secrets if not? 
[removed]
You can access the query with `document.location.search`: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search
Admittedly, yes, we felt the same. But it's a tradeoff we're making to favor the end user experience. We'll definitely do proper testing and housekeeping to make up for our black magic a little bit
I think flux frameworks (and Redux for that matter) gone wrong with forcing user to call `dispatch` function directly instead of just allowing for calling object methods and hiding dispatching logic under the hood (and type of action can be easily deduced from method name anyway). 
Is there any reliable blacklist of malicious packages online? Or are those packages instantly removed by npm? 
jQuery is a library, and not a framework that provides structure. there's not one strategy that fits all applications. size matters, complexity matters. what's optimal for an MVP and 2 devs is sub-optimal for production-grade code with teams of devs. a CMS needs more structure than a JSON or REST API. there are high-level commonalities of course: views/templates, data/models, routes/urls, databases/caching, integration endpoints. beyond that it's hard to give useful advice that will be generally applicable without a bunch of qualifiers. one thing that helps a great deal is using ES6 modules' `import`, or node's `require`. Either of these make it much easier to organize code and helps with looking through git revision history.
If you set up your app using `create-react-app`, you will do the styling using... plain CSS. Of course you can make it as difficult as you like, and the React ecosystem provides plenty of options for that, but there's nothing intrinsic about React that makes styling any more difficult than any other form of webdev.
Do what you want to do, jumping at it is the way I learned both programming and blockchain development. But you should know that blockchain dev is cutting edge and super hard. You would probably be more successful starting with something like web/mobile development (react/react native for instance).
Initially a lot of Angular 1 stuff made sense to me, and it *just seemed to work* - which I must admit gave me instant gratification and spurred me on. But on more complicated, bigger projects it quickly became needlessly ( I felt, at least ) complex. I also found a lot of the animations janky and horrible on mobile, but I think it was the hours I squandered getting Services that probably needed to be Factories that probably needed to be Providers that should have been split into Services again working that drove me away! 
There's no blacklist, but these packages are usually quickly removed when you ping npm. Please write at support@npmjs.com if you find any
Thanks for the data. I simplified it and made this little league table: https://github.com/khanglu/react-league-table https://media.giphy.com/media/3o6vXHizm27iUGXdJu/giphy.gif
I see a few problems with this: Through the nature of JS, HTML and CSS being interpreted on runtime, instead of compiled to machine code, it's incredibly easy to reverse engineer it. So any efforts to keep source code "private" is basically futile. That aside I would also not buy a code snippet that I could spend half an hour writing myself plus maybe half an hour of researching. I'm fine with buying licenses to use libraries or frameworks. Which is of course because in these cases I would get extensive support and a product that has been around for a while and most likely is either pretty well optimized or has another good reason for sticking around. A simple code snippet though, I would not buy. Especially because I would not have this kind of quality assurance that you get from bigger products. Compare a code snippet to a framework or library and what you actually get for your money. The Code snippet would have to be extremely inexpensive (considering that you don't have a proper support line for it) which would propably be lower than minimum wage. At this point I'd rather consider hiring an actual freelancer to do the work so I have someone responsible even after communication ends. edit: To make it clear: Bigger Products have the advantage of more bang for the buck because they are targeted towards larger audiences, while on demand software is always more expensive and needs a proper reason to exist, like time constraints. In all honesty who would you even target for that? And how about competitors? Basically at this point posting to stackoverflow and waiting for a response on how to do it and then doing it yourself will be cheaper than on demand code snippets. Every js forum would be your competitor.
You don't even need to fork it, [you can proxy it](https://github.com/derekdorr/snyxy).
Hey, good point, but I didn't mean simply several lines of code, what about more complex issues, for example, ReactJS component which could have complex logic inside could be reusable/customized/styled etc. Not sure that you will be able to find such an "answers" at forums. So anyway, I think it will depend on different things like task complexity, your experience, time and resources availability, etc.
You can use a tool like [Snyk.io](https://snyk.io) to monitor your package.json and tell you if an installed package is *vulnerable*. It can even patch certain bugs that do not yet have published fixes (if packages are not updated). I don't know if it would have caught the malicious packages, though.
I bet they regreddit now. 
Doubt it
I'm totally agreed with the lack of responsibility in that case. But what if the code which you requesting is covered with tests and written according to eslint rules (for example) - will it give you an assurance that the code is worth to use in your project?
npm: https://www.npmjs.com/package/dynamic-sandbox
What you mean by that it requires to run on server, of course, where you running it? &gt; now I'm just running gulp What's that _"just"_? :D It's on server. Try out this one https://www.npmjs.com/package/gulp-env
Depends on what kind of secrets you are using. These environments sniffing attacks aim to get tokens for like Amazon S3 etc. API keys and other credentials. What you want to do if you are a victim of this is go to the website and regenerate your token there.
Here you will find a hpw to generate an UUID with the minimum of bytes cost in your source code. https://gist.github.com/jed/982883 This generate an UUID v4, according to the v4 specs : there is to be a one in a billion chance of duplication, 103 trillion UUIDs v4 must be generated.
"running gulp locally", sorry! edited. Do you run gulp on the server then?
This is serious since packages like "jquery.js" or "d3.js" are used for this kind of scam. This is not a simple "typo" and get fishing sites, this is actually a huge problem especially for people new to JS. I remember using d3 for a project and just "npm installiert d3.js". Also do these packages run if you install them? Or do you need to require() them explicitly?
Because Object.assign is, in comparison, ugly and unwieldy.
I have written an article about this https://medium.com/@gajus/distributing-a-self-replicating-malicious-code-using-npm-cf2bf3209293
Why do we need one reading per month to tell us the most popular frameworks are (in random order) ? - Angular - React - Vue And.. Node.JS ? A Framework ?
Its not specific to React, but to "component" approach. Css with its cascading feature dont play well only by itself with component approach. So when doing some bigger project (=more parallel people), you need some tool or pattern to isolate styles for components to some degree. And the numerous and different answers of this is what Vpicone is talking about.
That is what most people do, this is most common: - They run gulp (in watch mode) locally on their development machine while working. - They commit the javascript source to git (but not build.js nor any of the npm dependencies). - On the server, when they want to deploy they run: - git pull - npm install - gulp build
That malicious code was in the `postinstall` script, so it was executed just when you installed the package.
When I look back over code I wrote when I started working in IT, I most definitely wish to have known what not to do back then. You have to remind yourself: Learning fast is nice, but it's also shit. Every mistake you make early on you have to fix later on. Most of my older programs would be easier to maintain, had I just spent more time reading up on anti patterns and things to avoid.
Choose your IDE like you may choose your binocles. This is up to you. I personnaly used VIm for a while and after a lot of "damn my IDE can do this for me", I moved to Atom, during years. And now, I had tried VS Code and decided to make the switch.
While that's true, at the same time there is a nagging feeling that cascading style sheets aren't a good fit at all in the component age and nothing clear has been established to replace it. That isn't exactly a react problem and i think they were right in not having official structures that lead back to old css again, but nonetheless something still needs to evolve from the myriad of options currently available, a redux for styles so to say. 
If I recall correctly you have to JSON.parse(response.body). 
The idea is that bad/very new packages would warn the user that they were straying from safety so that the user knows they're probably not getting what they wanted and can remedy the situation. Not great for niche packages but should work for the big ones that have the most risk of this sort of thing
Am I misunderstanding something? https://docs.npmjs.com/misc/scope
Isn't it some kind of bountysource or something already there?
It's not returning anything to do with the response, just the POST's uri{} ,method, headers{}. *goal* console.log(body) outputting what the above request responses with.
Oh, you're outside the body of the callback function. edit: Sorry I was on mobile and didn't see it originally. That is the nature of callback functions in Javascript and is the expected result. Outside the body of the callback function (err, response) {}, you won't have access to the response object.
http://callbackhell.com/ is a fun read related to callbacks.
ok
Are any of them related to this link? http://incolumitas.com/2016/06/08/typosquatting-package-managers/
Hmm, Cheers for the link. Although I feel my issue now comes back to the request &amp; how it operates. var response_body = request(options, callback); I still believe that this will never return the POSTs response body.
That is correct. Request is not expected to return a value, that will only be available as the second argument to the callback function.
https://www.npmjs.com/package/gulp-environments
I would recommend looking into Domain Driven Design (DDD). A book a lot of people recommend is [Domain Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) by Eric Evans but sometimes it's hard to translate the examples in the book to something you can apply in JavaScript. However you can probably find articles about DDD in JavaScript if you google for it.
I'm thinking of one solution, might be hacky as it's polluting global object but in this case it might be not that bad. In your backend code you can echo &lt;script&gt;window.env = &lt;?= ENV; ?&gt;&lt;/script&gt; in php You could also have a folder config/ with files inside like "dev.json", "prod.json" etc. and import them based on environment detected in a backend? If you are running express.js it's easy to check it and you require config file with correct name.
This is more for an 'if' this environment 'then' that.. I'm looking at a bunch of variables inside my Javascript files that need to be replaced.
Hmm, that is a problem. Would you know of any modules where the response would be available?
You are printing "body" which is basically the toString() of the result returned by request(), not the callback. You could try following: const request = require('request'); var authKey = ""; request(requestOptions, function (error, response){ console.log(response.body.authorizationKey) // :D onAuthKeyReceived(authKey); }); function onAuthKeyReceived(keyFromServer){ authKey = keyFromServer; console.log(authKey); }
This is a common pattern in JavaScript make use of the response body from inside the Callback
As HashTag_help mentioned &gt; Request is not expected to return a value, that will only be available as the second argument to the callback function. I'm currently creating a component for elasticio and require the authKey as the return value.
I recall seeing a module named Q that could be helpful.
Or if you're feeling adventurous use es6 async await
Q is a promise library. Promises are alternatives to callbacks. Not understanding callbacks will hinder your development.
Simply do whatever you require with the response inside the callback. 
And things like this are exactly why I use yarn and stay away from npm as much as possible. They're so fucking incompetent it hurts. 
yep, it looks like something close, but less open source oriented. Actually, there are a lot of tasks which could be specified without access to the whole project. BTW if task is something reusable, then developer would be able to sell this code again for somebody who wants to use it in another project
This is going to be a real nightmare one day soon... and it won't be typo squatting but popular packages with actual systems deployed. 
You could use the config and dotenv npm packages. Or set the variables in your ci environment.
But you're still using NPM packages?
Looks alphabetical to me...
Not sure ‚Äì the article is dated 2016, but the user (and their packages) were pretty fresh (I‚Äôve seen that the first package was published in June or July in the Google cache)
Not sure ‚Äì the article is dated 2016, but the user (and their packages) were pretty fresh (I‚Äôve seen that the first package was published in June or July in the Google cache)
I've really enjoyed using CSS Modules. For anybody who doesn't know, here's a super rough example of how they work: *AwesomeDiv.js* ... import styles from './AwesomeDiv.css' export default function AwesomeDiv () { return ( &lt;div className={ styles.awesome }&gt; I'm an awesome div. &lt;/div&gt; ) } *AwesomeDiv.css* .awesome { background: yellow; } CSS Modules automatically transforms AwesomeDiv's `{styles.awesome}` into a unique classname such as `awesome_74hd_6h38` so it's not affected by any other code. (Even if you have another `{styles.awesome}` in a different component.) You can still have global rules with CSS Modules, as well, by using `:global()`: :global(.darkBackground) { background: #222; } And you can access that anywhere with a regular classname (`&lt;div className="darkBackground"&gt;`). So far, I've been happiest when running a few global styles (a lightweight grid system and a few utility functions), and I hand it to CSS Modules for all the rest.
That's pretty nifty and I do something similar. I think this plus small inline styles for tiny things is the answer. I just tend to add one, two three things to inline styles and then its a mess haha.
For what it's worth, you can also protect yourself by disabling scripts: http://blog.npmjs.org/post/141702881055/package-install-scripts-vulnerability But of course if you have some valid packages that do require install scripts to run, then they will stop working :( This has been a problem for years: (from 2015) https://blog.liftsecurity.io/2015/01/27/a-malicious-module-on-npm/ My usual practice is to never type in an NPM command from memory. I always search it on NPM, go to the project's Github page, check the package.json, and copy/paste the package name from there.
Yeah, but that came 5 years after millions of packages have been published. 
Add a random string and md5 both together. If 32 chars isn't too long. I'm sure there are other solutions, see [here for a info on creating UUIDs in JS](https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript)
Jesus. The cpu and memory usage on that site is ridiculous. It locked up my browser (Firefox 54).
Isn't that pretty unlikely when it's down to the millisecond?
I am still using the npm registry, unfortunately. I wish there were alternatives that people actually used.
Hashids is a very useful library for shortening mongodb objectid for user display. You are essentially just hashing the objectid to make it shorter. Not intended for security, just aesthetics. Internally you can retrieve the original objectid when needed. https://www.npmjs.com/package/hashids
It'd help if you could edit your post and make the github link actually a link (just add `https://` to it).
sorry for the destructive comment ... you can prepare by writing a small app on your own. here are examples: https://github.com/tastejs/todomvc
I'm a node noob, what secrets do you mean and how do I regenerate them? I don't have any of the malicious packages, just wondering.
I get sort of laughed at often enough when I tell other devs npm is blocked here and the only place we install packages from is a whitelist folder on our shared drive with packages that have been verified as authentic, checked out on Snyk, had all their dependencies localized and been hand-reviewed page by page of code. Yet when something like this comes out we can breath a sigh of relief.
So whats up with this guy: https://www.npmjs.com/~pjbr Its a list of all the packages with the descriptions as "This package is no longer dangerous."
Adding here for visibility: &gt; So whats up with this guy: https://www.npmjs.com/~pjbr &gt; Its a list of all the packages with the descriptions as "This package is no longer dangerous." 
I have heavy doubt that with can be used for sandboxing. with use to do random things
For example? What exactly do you mean? As far as one can tell from tests I've written, it's working as intended. If you know about case where it fails, then tell me.
In React JS, I basically like JSX offering maintenance building features &amp; Virtual DOM. 
try to launch this in your sandbox `this.location = "http://www.google.fr"` I suppose that it is not the intent
This is intent! Demo page hosted on github shows usage of evaluate() function, which by design allows everything, even this. It's all in readme. The one which implicitly restricts this is isolate() function. You can install it from npm and test it localy if you mind: https://www.npmjs.com/package/dynamic-sandbox EDIT: I added second button on demo page, now you can test snippets in (almost) isolation.
Is it a reasonable security measure to just avoid packages with less than x downloads per day? If so, what is x? 
Hi guys! Today we've launched our Vue admin template available on GitHub! I hope you'll like it and will be happy to hear your feedback :)
People want to fill their blogs with rehashed material to gain some kind of esteem.
Why would one work for Netflix (for internal tools), or LinkedIn?
Here's what I use. Basically a guid without the dashes: export function guid() { return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r &amp; 0x3 | 0x8); return v.toString(16); }); } 
thanks. i've updated my fiddle with a working solution that will work with both smooth (continuous) and standard mouse scrolling: https://jsfiddle.net/xn6dj1uo/3/
How does yarn solve the issue?
Yarn doesn't solve the issue entirely since I still have to use the npm registry, but it does mean that I don't have to deal with the shitty npm client. 
Can you report those people's email addresses or something to some law enforcement agency? 
On the other hand I've been working on a (non trivial) React codebase for a year now on a multi-person team and other than the initial cost of setting up webpack and structuring redux (a few days at most) I haven't really had to think about anything other than React. Once webpack is set up you don't really need to touch it again. Once redux is structured and you understand the concepts behind redux all you're really doing is writing reducers and actions. I've also found that for the most part React errors are useful and easy to track down compared to almost every other framework out there. I guess what I'm saying is that those complexity costs are usually one time costs and if they're causing you pain for longer than a few days you're likely doing it wrong. 
&gt; Since Ember tutorials expire soon as the language keeps getting updates every year I'm not an Ember user, but by expire I assume you mean "I can't copy+paste code from the internet and expect different versions of Ember to perform according to the tutorial". This is a poor approach to take. Read the tutorial, take the lessons in and apply them to something. Your interview isn't on copy+paste. 
See here: http://www.reddit.com/r/javascript/comments/6qzmvi/-/dl1wocg. Basically, secrets are secret API tokens for Amazon, Heroku and other services. They‚Äôre often required on CI servers, so developers pass them into app via the process environment (and these packages were reading exactly this environment)
I think they just took package names so that nobody else can publish something malicious under them again (but I haven't checked the package sources)
The audio was freaking me out. Thought there was somebody at the door.
Haha! I'm so sorry, it's an evil trick
See also: /r/codegolf
cheers, had no idea this was even a thing
sorry but sanboxing is hard try this in your new sandbox eval.constructor("document.location='http://www.google.fr' ")()
&gt; eval.constructor("document.location='http://www.google.fr' ")() Thanks, I will fix this soon.
So this means that there is no way for it to access the filesystem, dom, network sockets, or any external input?
As soon as I resolve mentioned bug, shouldn't be. This concept works using hijacking variables used in evaluated snippet. If you want to access fs dom network sockets or extern, you need some variables/functions, or you need to require some. As require is function it is possible to prevent access to it. (Sorry if explaining something what you already know) import on the other hand is statement, which would be problematic. Important fact is, this projects shows some specific concepts of javascript and very specific use of them, you can see it as illustration in first place. EDIT: I tried import and it does not breach isolated env, as long as imports will respect limitation on importing on top level, it's OK.
Every few months someone tries to do this and it's full of holes. Check out Caja and the list of exploits they prevent. Unless you're basically reimplementing Caja, you're probably not sandboxing effectively.
I should mention that this is not intended to be used in production. It's mean to illustrate specific behavior of language and its concepts, as function declaration inside with. Anyways thanks for info about Caja. 
so, it doesn't solve this issue at all, is what you're now saying. but at least you got to bitch about npm!
[removed]
Where's the tapping coming from?
scroll down, it's just an mp3 being streamed from my dropbox on load
lol, that's mean.
:)
No, if these functions have different purposes then they should be broken up. A function should ideally do one thing, so it's better to have 3 functions that do 3 things than it is to have 1 function that does 3 things.
Having a bad day?
Small addendum to this: instead of git pull, it's much better to set up a bare git repo on your server and add a post-receive hook that checks out the code and then runs npm/gulp.
So `snake_case` opposed to `CamelCase`? You see people do for constants (for example redux action names, see [here](https://decembersoft.com/posts/a-simple-naming-convention-for-action-creators-in-redux-js/)). But never for variables, I am not sure where this came from though.
after how many fix will you resign ?
That is exactly the opposite of what I said, haha. npm has proven time and again that they are completely incapable of making good technical decisions unless someone else makes the decisions for them. * npm2 and infinitely nested dependencies that took years to address * no sensible lockfiles until yarn showed them the light * no autosaving dependencies until yarn again * a slow cli search function for the longest time * The whole left pad debacle. Seriously, they never considered what would happen if someone just yanked a package that half the ecosystem depended on? * no scoped packages for the longest time, leading to potential namespace conflicts * generally a very slow package manager until very recently I'm not going to recommend a package manager whose maintainers (or lack thereof) have their heads screwed on backwards. It has admittedly gotten much better recently, but I'm not going to use it when it has a history of sacrificing functionality for appearance. It took a third-party package manager pulling from npm's own registry for them to realize that their client was awful, after they'd had years to improve on it and tons of community feedback.
That was what I was hoping for! Thanks a lot ;-)
I wouldn't be surprised if people did it that way just because the JS APIs do too, and that's probably a good thing, since you end up with overall more consistent-looking code that way.
1. Grab an image from input 2. Create a new image via `const myImage = new Image()`; 3. Give it a source: `myImage.src = inputImageBlobOrWhatever` 4. On load event grab its real dimensions 5. Create a new square canvas. Its width and height should be equal to shortest side of your image (do it in memory, don't put it to the DOM, it is no need for it) 6. Fill the canvas with image (center it by offsetting it) 7. const myNewSquareImage = canvas.toDataURL(myCanvas) 8. Done
Hi /u/sama1122, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That seems to be the case 
You mean REST apis? Well RPC style APIs usually use CamelCase (in my experience), so that kind of depends on the domain. EDIT: &gt; make_thingy_with_method is much more readable than makeThingyWithMethod in my opinion. I don't agree here, it's probably just what you are used to.
Probably in moment when I will have enough awareness about internals of JS to decide it's not possible because of [**insert unpretentious problem**] on my own. I am not here to settle for fact that it's impossible because someone says it. I am learning, you see. So if you are willing, give me another bug to fix. EDIT: Let me ask you a question: Did you know about everything, what is happening inside source code before? I find some things really interesting - for example behavior of function declared inside with statement body. Isn't it best thing ever? Learning for joy from learning? There are at least 4 another ways for evaluating code snippets safely, workers, iframe sandboxed, some metacircular evaluator written in JS, I am not gonna sell it to anyone, but I just wanna meet some people who appreciate it and enjoy it with me.
I think [this one](http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/) might just steal the crown!
- [feature] new commands graphql:play, graphql:update_schema and graphql:see_graph - [feature] Created schema file of example graphql service - [feature] .graphqlconfig file for working with graphql easily - [feature] Added .env (environment variable) support (thanks @fyalavuz üéâ) - [feature] new packages on DEV: graphql-cli, graphql-cli-voyager - [update] Updated Commands, Environment Variable doc
Huh, none of this summarizes any of my own experiences. To each his own I guess. 
&gt; Completely jQuery free I love how that's a feature these days.
the idea, is, if you don't state the number of fix you are ready to stop after, we will go on an infinite loop bug-&gt;fix-&gt;bug-&gt;fix-&gt;... By the way I really wonder how you intend to fix this one as your framework is really not adapted to fix it.
most of the templates on WrapBootstrap are "angular" or "react" and in fact are just wrapping jQuery in their components)
He is talking about js APIs like getElementById or requestAnimationFrame or setInterval. 
First thing first: If you are able to throw tons of possible bugs from your sleeve, than there must be some corelation, some fundamental concept which known to you gives you the reason to say there is infinity (pretty bold) bugs. So can you please tell me what fact I am missing, that when I will push fix you will find another n + 1 bugs without problem? Second, I (think - need to write enough tests for it) already fixed it, because it's not that hard to fix something like that.
That question is out of scope. Would appreciate if you had a solution to my problem assuming I love this company and need to learn Ember either way.
&gt; They're so fucking incompetent it hurts. i'm not arguing this point; you're not wrong. but sending people to yarn is not a solution to this problem.
Please read my second comment :)
&gt;When I'm asked to change my style, I am - quite literally - asked to deny a fundamental Truth of my being. That's great, so long as you aren't in a team. If you're on a team, then everyone has their own style, and every time you check in code, you'll be changing the style of everything you touch. It's that, or work in their style and then you're back to the standards thing. Worse, if you keep changing style much, you'll find that merges are a *nightmare*. Merges are the single biggest reason that we maintain a style at work. The second biggest reason is readability. Most of the standards out there, no matter which you choose, make things more readable. In the end, I even enforce standards in my private work because I feel it makes life easier. Of course, I get to choose the standards there, instead of having to agree with the team. But my IDE does the enforcing, so it's all good.
&gt; Once webpack is set up you don't really need to touch it again. Until you discover you need tree shaking, lazy loading, and many other bells and whistles that aren't typically done in the most basic webpack configs. &gt; if they're causing you pain for longer than a few days you're likely doing it wrong. I didn't set it up to begin with, but now I'm kind of stuck with it - and it's easy to do it wrong, most webpack configs cause all javascript to be bundled into one monolithic JS file (typically over 1MB or more), which doesn't scale - but sure, it's easy to set it up to do that. How big is *your* monolithic javascript file? Code splitting (whatever you want to call it) isn't so easy to set up in webpack, and requires orchestration of other tech to achieve it. But sure, the most basic use of webpack is easy to set up. 
This one usually breaks javascript isolation. (function() { console.log(this); this.document.bgColor = 'red' }).bind()() 
I'm not saying it's easy I'm saying it's one time cost. If you spent two or three days wrestling with webpack and then don't touch it for the length of the project is it really that bad? We have all of those bells and whistles set up and it took the better part of a day and we literally haven't had to mess with it in a year. 
Will try when I get home, thanks. Hope it will be fine because I set this to empty object. Unless empty bind somehow messed it up.
&gt; We have all of those bells and whistles set up and it took the better part of a day and we literally haven't had to mess with it in a year. That's great if your project is new and starts out that way. When our project started, none of those things existed in webpack. Now the project is large and it's not so simple to shoehorn it into what webpack has developed into. Your case is also not the vast majority of cases, most webpack/react projects I've seen have a monolithic JS file.
The fundamental concept which gives me reason to say there will bug in your javascript sandbox, is that each time someone show a javascript sandbox, each time it has flaw: call it experience. Pretty everything that apply about cypher in this story apply to sandbox in our story. https://www.schneier.com/crypto-gram/archives/1998/1015.html#cipherdesign So before you affirm your sandbox is unbreakable, you have to attack it by yourself. if you can major the number of bugs to find by a constant A, that means you are not afraid that I would find A+1 bugs. If you can't major the number of bugs by a constant A that means the potential number of bugs is infinte. Second, just check your sandbox with same test and it has still the same behavior. So next time you say something is fixed, test that it is really fixed.
an empty bind, call, or apply will all set the scope of the function's this to be window. And I did try this in your sandbox and I was able to access window successfully.
trivago blogged about this in their engineering blog here: http://tech.trivago.com/2017/08/02/sponsoring-webpack/ I am working for trivago. If you have any questions, i can answer them or forward them to the right team to get the answer. AMA!
Likewise, we at webpack as well are happy to join in answering any questions anyone has. This is a partnership we believe will help drive the future of open source projects. 
`setInterval` takes a function and a time `t` and then calls that function every t milliseconds again and again, but once you have it set, you can't change it, because number is passed by value, not by reference, so internally for setInterval this time variable doesn't change. What you want is `setTimeout` which calls the function only once and when it has called you call it again. For example: function update () { // ... do whatever you need to do // Call update function again, but with different const time = Math.random()*1000; setTimeout(update, time); } setTimeout(update, 1000);
Precisely. I would never have touched react had create-react-app not existed. React is simple and feels really natural, but the whole ecosystem around it is downright scary.
I think it's calculating pi on every scroll event
Ah totally misread the comment, you are right!
more parenthesis and ampersands make for more ugly for(i=0;i&lt;100;)document.write(((!(++i%3)&amp;&amp;'Fizz'||'')+(!(i%5)&amp;&amp;'Buzz'||'')||i)+"&lt;br&gt;")
The solution to the problem is a package registry and associated client that don't suck, yes. But since I can't get both, I try to get as close as I can. 
PJ Briggs emailed me back explaining that the packages have been taken over by him to kill the namespace
good job, i like it
No problem, I made an edit to clarify that as well \^\^
thanks! it is really a very personal project for me and I appreciate your kind words)
Ya its a silly argument. Linting isn't entirely for YOU. Its for everyone else. Your team, new developers, if everyone is doing their own thing it gets FAR harder to make meaningful changes to large code bases. Also its just a code style, not a 'fundamental Truth of your being'. Its something that can be learnt or forgotten. And accepting that as your truth opens up the thought that 'maybe my code style isn't as efficient as I thought'. That thinking lets you learn and tweak until you become better.
I see. Actually bind() is not necessary here, it breaches isolation only with self invoked function expression. I will try overcome this, but I am skeptical. Thanks for tough one.
You are technically correct. The best kind of correct. But you also pay very little attention to what I am saying. I was really trying to stress that this is academic project, I created it to learn JS deeper not to create best sandbox and I have not said it;s unbreakable. Second I told you I need to write tests before I push and update, I was on my way in subway, so I really could not update demo website. So next time you will be accusing someone check if you are really right. 
again, your npm rant and comment are unrelated to the issue in the OP as it affected the npm *registry* and not the package manager.
Now that I look back on my original comment, there's some confusion. I was complaining about npm as a whole and how bad they are at engineering (imo), both registry and client, and while I was glad that there's an alternative client, I was unhappy that there's not an alternative registry. My fault.
So.. Just the main ones. Nice. 
You need a better title. This is badass. 
You do not want to be in the business of generating random IDs yourself. This is an active area of computer science research - do not reinvent the wheel, because you will certainly not do it correctly.
That's fun the behavior of empty bind is not documented on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
No, it's **guaranteed** as your app scales. That is why single node SQL stores use auto incrementing IDs (because that guarantees no collisions as long as there is just one write node), and why distributed and multi-node stores (like Mongo) use auto generated unique ids (because when enough nodes are being written to at the same time, collisions are inevitable).
Node? Frameworks? Cordova? etc..
I see - interesting - though if mongo has an auto generated unique id functionality why isn't OP just using that?
I keep seeing webpack here, why is it better than grunt+bower?
I don't understand what you call an academic project. There is no where in the github project mentioned that it is probably broken. So you makes a huge disservice to your reader
are they just keeping track what's already rendered and rendering enough extra to overflow the viewport? this means that the scrollbar would not represent the length of the *entire* unrendered list but only the portion that has already been displayed. i imagine the UX of what's described would look approximately like this?: http://leeoniya.github.io/domvm/demos/playground/#infinite-scroll how would it behave if 100 items are prepended to the list while it's scrolled to item #735? even semi-robust solutions are actually quite complex, eg: https://developers.google.com/web/updates/2016/07/infinite-scroller pagination with user-selective #/page is actually the most terse, simplest and most performant solution. **EDIT:** ok, i missed https://codevate.github.io/virtual-list-blog-post/, looks like they physically render the entire DOM, measure each item, then `display: none` the items that are out of the viewport and offset the shown items by the pre-measured height of all previous items. the main problem with this is that, you still have to render the whole list to measure the whole list, but they also keep the list in the DOM, so while it saves on restyling, they're not saving too much memory or virtual-dom overhead as with a truly occlusion-culled implementation, which is pretty much not do-able with variable-height items that have never been rendered. the fact that you have to render the items to measure their height (and you can'd do it in a webworker without DOM access) is a chicken-egg problem that's sadly unavoidable. if you can estimate some average height with any amount of certainty, that's gonna be the most performant way to go.
about your edit: I'm sorry to not share your interest. but the interaction between with and inner function is quite standard isn't it ?
How old are your friends?
I don't know about _new_, but I'll give you _evolved_: https://pbs.twimg.com/media/CWeVPL0WUAY-ANx.png
It's version on npm is 0.2.0! This is saying it all! There is no promise that it will be fully functional. You are just aggressively pushing on me and I don't know why. I don't like people who discourage others from their passion. So lesson learned from my side and this conversation is no longer helpful for me. Thanks and bye.
if you say so...
Why it should not be standard? But how often do you use it? How often majority javascript programmers uses it? I am about 3 years in JS (programming in general actually) and I am sorry* to find things exciting and would like to share some thoughs with others, because I am enjoying it, obviously it's not something you appreciate. Actually I am not sorry at all.
It is definitely a good warning to have!
Good point, I'm guessing kat means in that twitter thread, but maybe you're right. Regardless, kat is writing something that's super valuable, but they also know that it won't catch every instance of postinstall abuse :(
Don't try to fight against the forces of ignorance friend. If he doesn't want to take the time to research the subject, then it's not worth your time to explain it to him.
Dude that's fucking awesome. Can I possible add this to Django? So instead of seeing my admin page I can see this sexyness?
Came here expecting orcs.
Yep and something is saying me I am not first one to say that to you :D
Are there other libraries you guys leverage that might be worthy of a sponsorship like this one?
Hi /u/sendilkumarn, this post has been removed. Please feel free to repost with a descriptive title. Thank you.
wooooow! so great) We haven't integrated it with backend (were trying to make it pure frontend for starters) but I don't think this will be difficult - Vue.js is really easy to grasp
Absolutely. So what is awesome about Open Collective is that it allow's other projects that we depend on (Mocha is a great example) to funnel funds to them. We have offered to many of our dependencies' mantainers. Ironically the response is humbling: * I don't have any need for the money atm, use it and keep doing great things.. Other times, we were unable to find a way to reach out to some library authors. We really believe that funneling down is a super important means. Also with open collective we can let contributors spend time on our project and we offer them the opportunity to: * Expense their time ( at a capped amount for fairness and based on budge ) * Recieve golden influence based on the time spent (to use on webpack.js.org/vote) * To instead of expense, offer the money to a different collective like (BlackGirlsWhoCode), or other dependent projects. This way it really provides a very accesible and transparent way for people to contribute and give back at the same time. 
This is incredibly cool. Definitely a fan of this kind of business ethics. It must be awesome to work for a company with that kind of moral compass!
Actually /u/sendilkumarn, please don't repost -- I see someone else already posted with a better title an hour before this post (you should probably check for an earlier submission next time). https://www.reddit.com/r/javascript/comments/6r589b/webpack_triples_budget_in_less_than_3_days_with/
That's what I asked in my comment below. I think they are missing that Mongo generates an ID for you on insert.
My database learning started in the mid 90s so I'm sort of old school still - I see the advantage of the NoSQL structure, I just haven't really seen a use for me for it yet is all...plus I'd have to learn a lot more to get really good with queries like I am in SQL now
The "meat" of the article is missing. &gt; I failed a technical interview for a junior web developer position, their reason being that they ‚Äúdidn‚Äôt like my style of programming‚Äù. You'd think the author would elaborate on this, but he didn't. There is no morale to this story. What follows are links to popular resources like MDN, You don't Know JS, etc with some filler prose.
I recommend to have a single entry point called "main". You can also use named function expressions for IIFEs: (function main() { ... })(); In your main function, you can then call other functions etc.
JS is top used programming language on github, by far: https://www.techworm.net/2016/09/top-10-popular-programming-languages-github.html JS has been in use for scripting the Unity game engine for many years. Emscripten can make JS a compile target, allowing just about any program in an language capable of being run in node or a browser (except those programs that rely specifically on hardware capabilities not available to those environments). JS is a significant player in the embedded hardware market, scripting lights, timers, robots, etc.
You don't. WebAssembly is here and poised to kick JS off its perch within the next year or two. 
For 99% of use cases, SQL is better. Mongo is easier to use for new JavaScript programmers, which is maybe why it's popular.
It's not really like grunt or bower, so that comparison wouldn't make sense. I'm gonna make an assumption about your stack and guess that your bundler is browserify, which is what you would probably use for bundling with grunt and bower. Webpack can be used in grunt or gulp, but it's a bit unnecessary. Most people use npm as their package repository, but you can use bower instead if you prefer. So, first and foremost, webpack is a bundler like browserify. You can't use webpack to orchestrate a ton of different tasks like you can with grunt or gulp. The beautiful thing is, you don't need to. Webpack uses loaders for just about everything you would ever want in your app. css, sass, png, pug, all of them are required as if they were modules. A lot of the cool things about webpack would probably be possible with plugins for browserify, but that's just not normally how people use it. The loaders are made so when correctly set up (which is generally not hard) they will take care of everything. Put `logo.png` next to a script file, include `const logo = require('./logo.png')` and `logo` will be the correct path to the image, which is copied to the build. This means files are where you use them instead of in some nebulous image-folder, you don't have to worry about magic string paths (eslint will check the require) and only the images/styles/whatever you actually use are output in the build. You also don't need to specify that you want to copy your images to your build, you did that when you require'd it. There are tons of cool loaders, one of my personal favorites is the css-modules loader that automatically namespaces class-names so you never need to worry about name collisions. The result is that 90% of the build tasks from grunt/gulp gets reduced to just bundling with webpack. If you've ever tried setting up asset fingerprinting, you know how cumbersome it can be. I think maybe gulp-rev can do it well, but getting everything to play together with js and css can take some time. In webpack it's built in. Just set the output name of the file-loader to something like `[path][name].[hash].[ext]`. This can be done for all assets, so you never have to worry about cache busting. Finally, we can't forget about hot module reloading. HMR is, to be frank, pure magic. It replaces parts of your app while it is still running and it works much better than it has any right to. If you've tried the switch from a compiler-heavy backend serving frontend assets to grunt/browserify with live reload, the switch from that to HMR is similar. It's a bit finicky to set up, and your app needs to be structured in a certain way for it to work (you need to be able to reload the entire view without having to reload any state), but for react/redux it is perfect. I could go on, I think it is a fantastic build tool, it makes my life easier every day. But let's leave here for now before I start ranting even more.
I am abandoning it as it is not what I expected to be. Thanks for all the feedback, it has been important lesson.
Dunno, maybe ask the bower devs as they recommend people use webpack and ~~npm~~ *yarn*: &gt; ...psst! While Bower is maintained, we recommend yarn and webpack for new front-end projects!
Not sure whats with all the snarky comments here, it was a genuine question. Seems like an interesting bundler, however it is not at this time approved for government use. &gt; VA has decided to divest itself on the use of the technology/standard. As a result, all projects currently utilizing the technology/standard must plan to eliminate their use of the technology/standard. This is in reference to the auto-prefixer, it is only approved for styling as of today.
The *new* language of the web? So which is the current one by their standards? Java Servlets?
"How do I convince my friends that JavaScript is the new language of the web?" Uh, let's start with "there is no other client-side language"? At least until wasm doesn't take off. And that'll take few years. But don't fight ignorance, it's their problem and their's education after all.
This is what I wanted to read as well.
Thanks a lot!
Ben was an awesome, extremely helpful resource back in my ColdFusion days. I have to say I'm a little upset to read this.
Functional: Array(100).fill().forEach((v,i)=&gt;document.write(`${(((i+1)%3===0?'fizz':'')+((i+1)%5===0?'buzz':''))||(i+1)}&lt;br&gt;`));
To be honest all the arguments about code style are completely gone now that we've completely switched to prettier. No one has to think about code style anymore because it's done automatically on save. You should really give it a go. Another plus is that our linting can go back to what it's actually build to do: check for potential true errors.
Thanks for your quick summary. Always appreciate fellows who save others from clickbait articles
Holy shit, exactly what I was looking for. Thank you so much &lt;3
&gt;There is no one right way
 "presets" : ["es2015", "stage-0", "react"] Gotta get that function bind syntax!
it seems they are not intrested in web development cause if they were then they would have loved js thats all ...dont try to prove or convince them..
When you first met Ben, you were but the learner; now you are the master. 
You need to reset setCustomValidity to an empty string when its valid. Otherwise, it will always be considered invalid. setCustomValidity can be part of your validate() function.
Well hehe a majority of the 100/120 hrs I spend on webpack is off work. But now that I'm at Microsoft I have some more flexibility that also aligns with the same ethics. Trivago aligns this way also.
Fuck. Trivago is scum but I'll be damned if that isn't cool. 
Oh my
Amazing work, I love it! This kind of projects really prove when developers love their job 
Aren't Bootstrap's JS components built with jQuery? Why would you use Bootstrap if you want to be jQuery-free?
Prettier is not configurable enough for my taste. Plus I don't want yet another tool in my toolchain - eslint (which, let's not forget, now includes JSPM) is enough, thank you very much
Yes he's disappeared up his own arse. I automatically close the tab when I find myself on a page on his blog. I mean it can be OK if he thinks linters are a pain - but he has _never tried a linter until three months ago_ - wtf? It's like someone saying they haven't tried promises or unit tests or something 
Not a question, just appreciation. It's pretty cool of trivago to sponsor webpack. You've gone from "a company with an annoyingly effective slogan" (Hotel?... Trivago) to "awesome open source people" in my book.
jquery is never needed, agree with u/pawelgrzybek answer
Jesus reading one of his comments &gt; I'm just a "var" kind of guy. I understand that "const" is actually doing something different (and, it may even be doing something different at the compiler level); but, for me, it's just one more thing I have to think about This guy is a fucking amateur (in JS at least) This sub likes to hate on Eric Elliott, but I thin I have found my pet hate: Ben Nadel.
The only thing I can think of is to change `new Array()` to `[]`. It is faster as stated here: https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array Otherwise it's as raw as you could get.
That's only when allocating tons of new arrays. In this case there are only 2 and it's probably better to pre-allocate the size you need.
&gt; change new Array() to []. It is faster But it doesn't pre-allocate, does it?
It looks alright but that sidebar just doesn't sit right with me. Also the link to 'hire us' via github leads to a blank page. edit -not bashing this as I'm all for free things, just think the sidebar needs redesigning
Using typed arrays may be faster if you're holding numbers (though as always you'd have to check.) Then you can use the typed array [set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) method.
(Only) Typed Arrays have: TypedArray&lt;T&gt;.prototype.set(arrayOrTypedArray, offset=0) : void
So you want to overwrite a section of an array with new values? My guess (and it's just a guess) is that splitting the array and concating them back together would be faster, const newArr = a .slice(0, start - 1) // the start .concat(b) // the middle .concat(a.slice(start + b.length)); // the end (
So you want to overwrite a section of an array with new values? My guess (and it's just a guess) is that slicing the array and concating them back together would be faster, const newArr = a.slice(0, start - 1) // the start .concat(b) // the middle .concat(a.slice(start + b.length)); // the end There might be some off-by-one errors in that code but hopefully the approach is clear
[removed]
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
 $(document).ready(function () { let isBound = false; const boundFn = function(e){e.preventDefault()} $(".icon").click(function () { if (!isBound){ $('body').bind('touchmove', boundFn); isBound = true; } else { isBound = false; $('body').unbind('touchmove',boundFn); } $(".mobilenav").fadeToggle(500); $(".top-menu").toggleClass("top-animate"); $(".mid-menu").toggleClass("mid-animate"); $(".bottom-menu").toggleClass("bottom-animate"); }); });
 $(document).ready(function () { let isBound = false; const boundFn = function(e){e.preventDefault()} $(".icon").click(function () { if (!isBound){ $('body').bind('touchmove', boundFn); isBound = true; } else { isBound = false; $('body').unbind('touchmove',boundFn); } $(".mobilenav").fadeToggle(500); $(".top-menu").toggleClass("top-animate"); $(".mid-menu").toggleClass("mid-animate"); $(".bottom-menu").toggleClass("bottom-animate"); }); });
Just want to say thanks for making this, it looks amazing.
 $(document).ready(function () { let isBound = false; const boundFn = function(e){e.preventDefault()} $(".icon").click(function () { if (!isBound){ $('body').bind('touchmove', boundFn); isBound = true; } else { isBound = false; $('body').unbind('touchmove',boundFn); } $(".mobilenav").fadeToggle(500); $(".top-menu").toggleClass("top-animate"); $(".mid-menu").toggleClass("mid-animate"); $(".bottom-menu").toggleClass("bottom-animate"); }); });
It needs to be benchmarked, but I can see several (4?) allocations here, unless nodejs is doing a really smart job. 
Can't seem to connect to the link :/
Hi, This article has a pretty good explanation about why const can be of benefit to yourself and anyone else who reads your code. https://justintimecoder.com/5-features-of-es-6-7-8-that-supercharge-your-javascript/
Sounds fucked up. Why not just use a proper database (ie SQL)?
There's splice + spread: let a = [...'abcdef']; let b = ['A', 'B']; a.splice(0, b.length, ...b); console.log(a); // ["A", "B", "c", "d", "e", "f"] No idea if it's any faster, though.
It's faster to cache the length of the array vs using [].length ``` for (let i=0,l=array.length;i&lt;l;i++){...} ```
Doesn't change much, if anything. https://jsperf.com/sum-an-array-performance
The bit about composition vs inheritance seemed abrupt and out of place. To be clear, when we're comparing composition vs inheritance, then we're talking about [object composition](https://en.wikipedia.org/wiki/Object_composition), not function composition.
**Object composition** In computer science, object composition (not to be confused with function composition) is a way to combine simple objects or data types into more complex ones. Compositions are a critical building block of many basic data structures, including the tagged union, the linked list, and the binary tree, as well as the object used in object-oriented programming. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
You can use return this.$store.state.meta || {} meta is returned immediately if truthy, otherwise the empty object is returned. Note that this doesn't inherently check $store or state as well. If either of those are null or undefined an error will throw.
 meta = () =&gt; this.$store.state.meta || {}
We are transitioning our product from an in-house build and delivery to something including webpack. Maybe I can talk the powers that be into contributing a few pesos. We would like a finer-grained control over loading and unloading. Maybe we can help make that happen. 
Shorter! But be careful with binding though.
I'm like an ameba when it comes to coding style and guidelines, to me I am pretty indifferent and will just match exactly what the uptight anal nitpicker thinks best so that things just move on smoothly. But I do care about design patterns and performance though, I just won't ever bust anyones balls over semicolons or tabs. Thank god for `atom-beautify` 
if you are using lodash const get = require('lodash/get'); const meta = () =&gt; get(this, '$store.state.meta', {}); this will safely go through the object (this) using the address and will default to the last param ({}) if it fails at any point
Does it work with SSR?
Huh? Why? It's an arrow function which means lexical binding
[An arrow function does not create its own this, the this value of the enclosing execution context is used. ](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this) 
Spread operator: let foo = [...[1, 2], ...[3, 4]]; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
Node.js is an event driven, non-blocking IO server that can be used to build high-performance web applications. [Here are all the arguments you need](https://www.youtube.com/watch?v=bzkRVzciAZg)
Agreed. It's cool but the neon green is eye-piercing. It could use a design refresh.
But won't this just change the message? When I enter a valid input and press the button it does nothing, meaning that the actual valid input is being flagged as invalid, and so the appropriate message is shown **Edit: nevermind, I'm an idiot, that worked, but I'm not sure why**
its an admin template. presumably its not public facing.
Great, thank you. That looks so much better. I'm going through my project right now trying to refactor and cleanup the ugly parts. I appreciate the help.
+1 for using vue.js
Yes, that's the point. An empty custom validity message means there is no custom error. Any non-empty string custom message means there's an error. If you want the form to be able to work, you need a custom validity message thats the empty string. In other words: setCustomValidity('') Your problem is that you're setting this to an error message in the invalid event. This event is triggered for invalid inputs when you try to submit the form. If you submit the form the first time with a valid input, the invalid event never gets called and a custom validity message is never set - it remains an empty string. However, if you have an invalid input and you click the button, the invalid event fires and sets the custom validity message to your custom message. As long as this is set to something other than an empty string, the form is never considered valid. Even if the pattern match is ok, the form will still fail validity because there's a custom message set. You need to clear that message for it to work, and that means calling setCustomValidity somewhere like in your validate function. The invalid event doesn't work because that only fires for invalid inputs and can't help you clear your message when valid.
The built-in Git integration is new (less than 2 months) so people might not be aware of its existence. 
Clear as mud. I intuitively understand functional and object composition, but I completely lack the facility to explain them, it's almost like an innate understanding that I can't convey to others. :-S 
For styles and ease of customisation probably
If you want your code style to be your expression of art, then go maintain your own codebases. 
This reminds me, I need to get a project where I can quickly come up to speed on Javascript unit testing setups, because I've never used one. Frankly, I think the use of linters has become so much more prevalent because Javascript has become so much more complex over the last few years. With most other languages, your compiler or IDE has traditionally done a lot of the static analysis stuff, so linting was *entirely* for style, and for the most part, people were pretty good at adapting to whatever style belonged to a project. With Javascript, we get zero static analysis for free with the environment, so eslint and friends grew up having to do the static analysis while they were doing the linting. I'm actually the only person on my 7 person dev team right now that bothers to install eslint. It's obnoxious, I'm constantly reflowing their code when I change files they've changed. :-D I'm also the only one in the group with significant investment in Javascript in my career. 
Better make sure your admin page gets maximum SEO
pffft.
No love for angular? Edit: clarity, I'm not ranting. Just asking if storybook will ever support angular. 
It's almost certainly because you're changing the elements so dramatically in your listeners. Have you attempted to attach your listeners an element above? (Or wrap your buy button in another div and use that as your parent element if nothing is conveniently available) As a side note: this is some pretty heavy weight operations for a mouse listener, this will only cause you woes in the future when you try and add animations. (animation + layout = jank)
No need for angular when you have vue. :)
I tried this in a different sandbox and it just logs *undefined*, before failing with *Cannot read property 'document' of undefined*. Do you know how they managed to address this?
Ahhhh... i see. That makes a lot of sense. Thank you! But what would you recommend for something like this? Because of what you said about heavy operations for a mouse listener. How would I make a div that changes its text when i hover over? I was thinking using js to change css display from none to block. 
I'm not certain, but I think that this may be a scoping issue. You're rebuilding the HTML on mouseover, and I think that `Game.items[${number}].buy()` may undefined when its run after the `this.changeText` function runs. I'm not a front-end expert, but I think what you're doing here is kind of an anti-pattern... it looks like everything is staying the same except for your &lt;p&gt; tags, re-rendering much more than you need to and including the same HTML code twice - once in the markup, and again in the `changeText` function, which should really be avoided. I'd suggest that, rather than replacing the entirety of the HTML in the DIV, you render all of your data from the beginning, but put the stuff you want to be swapped out on hover into their own hover-only and no-hover DIVs, with the hover-only DIVs hidden by default. Then you can just adjust whether they are visible or not. That way you're not re-rendering the whole button div just to change out a couple of Ps. I made a [quick codepen](https://codepen.io/RubyRubenstahl/pen/qXaXgV) showing how to implement this. I removed your templating and specific functions to simplify a bit, but you can keep your same function names and templating in your code. This just demonstrates the logic. Also, I'm using vanilla Javascript here, but if you're using jQuery, you can always use the show() and hide() functions instead of rolling your own logic. 
Hmmm I cut out a lot of the code btw. Theres a lot more besides a p tag. I just wanted the code to be a bit easier to understand. After discussing and thinking it over I think im going to use display: none for this. Thanks for the input
Yes
I don't get the down votes. This is the only solution presented (so far) that won't blow up if this, $store, or state is null/undefined. JavaScript needs a safe object accessor like ?. in c#.
Shouldn't this be: if ( this &amp;&amp; this.$store &amp;&amp; this.$store.state ) return this.$store.state.meta || {}; 
yeoman generator
If you have no confidence in the properties earlier in the chain, then you'd want to check those as well, yes. The `if` isn't necessary as you can include them in the same expression: return this &amp;&amp; this.$store &amp;&amp; this.$store.state &amp;&amp; this.$store.state.meta || {} Alternatively, you can try the whole thing normally and return the empty object if a type error occurs: try { return this.$store.state.meta || {} } catch (err) { return {} } There's also a stage 1 spec for JavaScript [Optional Chaining](https://github.com/tc39/proposal-optional-chaining) which would allow you use: return this?.$store?.state?.meta || {} Edit: Updated try sample thanks to comment from /r/tekerson 
Wow, I didn't know about the first example or the stage 1 spec. Thanks, TIL. 
yep :)
exactly :)
This is awesome. And it makes total sense now! The program is now working as expected. Thank you for the explanation, it's extremely helpful. Really appreciate it! :)
Scary!
Bower has kind of been replaced by language specific package managers (npm/yarn, composer). Grunt/Gulp are similar and still have a place. These are task runners, and each task can be independently configured to run as needed. Possibilities could be running linting/testing/etc scripts that are more complex than would be needed in your package.json scripts, but most people tend to just set these up as npm scripts and avoid gulp config altogether. Webpack is a module bundler. A lot of tasks being handled by Gulp/Grunt can be grouped and handled by Webpack instead. Ex. css can be compiled to css, JavaScript files can be combined with requires, ES6/7 JS can be transpiled to ES5, code can be minified. Files can be uploaded to cdns and more. It's got an extremely extensible core that can do an absurd amount of things in one fell swoop + it has webpack-dev-server built in for hot reloading of changes and watching changes. 
How would we know? That stack isn't something you can throw any and all problems on, especially due to MongoDB.
Yea two divs is a great way, opacity would be better though. Switching the display: none will force a layout whereas opacity won't 
impossible to answer with the given information (which is basically just "it's a startup")
A note about || shorthand is that if the first value is 0 or false, it Is also considered not truths and the fallback value will be taken. So be careful if the value you are checking against can possibly be a boolean or number. 
I actually want the layout change. I want it to look like the div is expanding a bit
Can you just add a overflow: hidden; to the body when the menu is open?
If you don't trust the preceding values, you can do something like this: return ((this.$store || {}).state || {}).meta || {}; The proposed existential operator will make this much cleaner though: return this.$store?.state?.meta || {};
you don't need the else statement, it's called short-circuiting or early return.
 meta () { return typeof this.$store.state.meta !== undefined ? this.$store.state.meta : {} }
Yeah...um, what does TriVaGo mean/stand for? Is it a portmanteau? 
Thanks for the nice words. This will make many engineers in our organisation very happy!
The original name was TripsVacationGo. But this wasn't used for a long time. Now trivago stands for its own.
it's really nice to hear that) We've put really much effort completing it and such feedback makes us feel that we haven't wasted our time :)
Agreed, sidebar is an issue right now, thanks for the feedback!
Haw haw
This used to be the case, but now most if not all compilers optimize this away.
Yes, with an iframe or by writing some JS that makes an AJAX request and inserts response body into your div.
[removed]
&gt; Not sure whats with all the snarky comments here Yeah, I guess it might have been a genuine question, I guess it's just a lot of people annoyed by the "webpack is everything that's wrong with JS"-crowd.
https://www.reddit.com/r/javascript/comments/6r8reg/is_there_a_cleaner_way_to_write_this/dl3hfzx/ apparently there is a proposal
Enforcing ESLint rules is nothing I'd pay towards, seeing as when I write code I naturally write it accordingly. There's no extra time I have to spent to keep it in line with my internal guidelines. I don't know about others, but we're already working in a test driven manner, developing tests before implementing. A product not tested is a product that will lead into way more work later down the road. I'd use the code given it follows my guidelines and standards, however that is not really the issue. The issue is that internal resources are way cheaper than external. As long as I can make time to do it myself, it's always cheaper not to outsource. Like I said, if it's a product that's established, that is pre-existing and does not need to be built from the ground up for my needs, for sure, I would pay for it, because there's no way, I'd ever be able to do it cheaper. Also I have to admit, we have had terrible experiences with external programmers and freelancers. Code that is very badly documented or not at all, following their own guidelines, not ours despite demanding to do so, generally preferring quick and dirty solutions, because they either don't see the code again anyways, or will make more money out of fixing it. The only reason I'd outsource programming would be none of our programmers being proficient in that exact field, extremely hard time constraints or a combination of both. And even then I'd have to still convince the higher ups.
That is a fair point, however you might have to consider that very rarely we would choose an environment we're not familiar in. I personally do not have any ReactJS experience, which is why none of my projects do rely on it. Any expertise I'd need in a field I would aquire before offering my services. That however might not be the case for others and I'm sure you'd have customers. Definitely. However I highly doubt you could make a proper startup of it. Seems more like something I did back in school, writing code for a small buck. We're getting closer to the main issue behind it: reusable, customizeable, styleable. If you go for an approach that could be reused, you're going to inevitably spend more time on it. The more time you spend programming it, the more expensive your product will become. Which can become too expensive way too fast. I'd actually say it would be a better approach to create a reusable product in the first place. Modules that can be implemented on demand. You basically create a blueprint and customize it for individual customers. Keeps cost low, while being able to serve it to many customers because it's not too specialized in the first place. Seeing a product first and then deciding "we could use this", is a lot more likely to happen than hiring a freelancer with "we need that, can you come up with something". Think of monitoring tools, administration tools. Most of them are blueprints that you pretty much just pay for being tailored to your system. These tools do sell and pretty well at that. edit: Sorry, I'm just rambling on. But I really do think it would be way too expensive and I could not justify the cost of outsourcing in this case.
Pick up the index of quote in array, and retrieve the image at same index from image array.
I think the risk of losing data in MongoDB is higher than MySQL.
Depending on a library when the vanilla solution is also pretty short and legible is bad practice.
The point of linters has nothing to do with complexity, it is that it's a team tool, and you put it as one of the steps in npm test or something so that it breaks the build. Ideally in a git hook so that nobody can committ if the build is broken. If it's just you using it, yeah, it's a pain, and you'll be constantly cleaning up other people's code. Also look into eslint --fix, it does a lot of the fixing automatically for you.
link doesn't work for you?
This makes testing for OWASP A9 a bit easier. 
You can always reach out at webpack[at] opencollective[dot]com and wed be happy to discuss any needs you have
&gt; return ((this.$store || {}).state || {}).meta || {}; Ew, don't do that. You're just creating garbage.
Uh that's my point 
Meanwhile, your own website uses jQuery 1.1...and behind my corporate proxy I don't get the scripts from your CDN, so it looks pretty bad. ^^
bower is dead, the maintainers said so themselves and actually recommend npm/webpack (it's the first thing you see when you visit their website). As for grunt and gulp, they're es5 era task runners, they don't do ast analysis and therefore have no idea what your project is. webpack does everything these tools did, there is not a single thing left. But the main difference is that webpack knows your project by ast. It creates a minimal distribution that contains the parts your application actually needs to run, discarding everything else. It has many other advantages like being able to simply `npm install` a package and `import` it in your code without further ado or the ability to handle assets of any kind (images, css, shaders, etc).
This is awesome!
fragr
lol) to be honest - we've made epicmax's website in a couple of hours using generator, it's shitty :)
This solution will blow up if some of the involved identifiers have been renamed by a minifier. You also won't get auto-complete or any kind of checking for that stringly-typed path. That string will also stay the way it is if you do refactor -&gt; rename. It's prone to create errors when you write it and it's prone to create errors in the future.
Its just something new that added to the existing thought process and because of some differences they started their own project. Overall I think Gulp is still better than Grunt (mainly because of its many plugins and how well it is/was maintained) and you don't really need Bower anymore (just get it from NPM), but WebPack has some things that Gulp or Grunt don't have or don't have out of the box. If you have something that works, you don't need to switch, but if you want to use those new things that Webpack brought to the table, then go for it. Overall I found it was a bit difficult to setup and many of the commonly used extentions are still in alpha or beta, but they already work fine. Its not much faster than what you are using, but it might be more future-proof right now. And it allows you to easily start using stuff like Typescript, ES6 features and more, without much hassle. Your question kind of looks like what people had a while ago. "I'm using jQuery, why should I start using Angular". Its just the new thing and it could pay off to start using it, as the one you are using is kind of getting out of date. But there's a lot of other stuff you can try too. Just pick one you are most comfortable with (after putting in some time to learn it all)
So, you were writing unprotected code yesterday? I hope you had return early pattern at least (Õ°¬∞ Õú ñ Õ°¬∞)
Unfortunately I don't know. I figured out every IIFE is invoked in global context. In browser window in node "default module closure object" [I don't really know how they call it] Maybe you can let me know in which sandbox you tried it.
Most of the web applications doesnt need safety and performance of sql and concurency of other languages unlike javascript, and vue js is generally a good pick, so *most of the time* this stack wont see any major problems
If you use VS Code, TS' analyzer will be used for JS as well. You can feed it type information via JSDoc comments. Furthermore, it automatically acquires type definitions (if there are any) for the installed Node packages. So, there are actually some ways to beef up the tooling a bit. You won't get everything TS has to offer and JSDoc comments are kinda bloaty, but it's much better than nothing.
This is actually a pretty neat way of doing things. Thanks for the idea!
The security tests showed that no loopholes were present
If not exploiting some of the browser vulnerabilities, javascript is sandboxed only to current "window", which means tab in browser. And clicks outside browser are not sent to pages. You might be in bigger danger when considering infected browser addon, since they are not contained to specific page. Possibly, you can pass some params to other tabs by window.open (https://stackoverflow.com/questions/11313045/when-to-use-window-opener-window-parent-window-top) Or, if BOTH tabs are infected, they can communiate by for example by local storage For general security info and knowledge, i recommend you https://www.owasp.org/
No, such a thing does not exist (correction: you can add numbers by doing bitwise operations, of course). Even if it did, in most cases you would have to do the same checks (not undefined, is a number) by yourself, which would amount to exactly the same CPU load as it is right now. And note that saving processor cycles on individual mathematical operations is a good idea only in theory, unless you are working on "bare metal" and writing assembly. In practice, the cost of sending a single network request dwarfs any savings you could possibly gain by optimising your number additions. In other words, the cost of you writing this single post and me replying to it negates the benefit of any arithmetic optimisations that we could possibly do in our lifetimes, combined. See also: https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize
**Program optimization: When to optimize** Optimization can reduce readability and add code that is used only to improve the performance. This may complicate programs or systems, making them harder to maintain and debug. As a result, optimization or performance tuning is often performed at the end of the development stage. Donald Knuth made the following two statements on optimization: "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
No, it shouldn't be able to if you use a good browser. All the major ones - Google Chrome, Opera, Mozilla Firefox, Microsoft Edge, Apple Safari - should all prevent the javascript from capturing any events on other tabs and windows. Honestly, phishing seems most likely so I'm not sure why you dismissed that one. Capturing billing information or login details seems like the most rewarding for whoever made the code. They don't need to insert a new form, they just have to change the action attribute of an existing form on the page.
Modern engines use type feedback to produce better code. If you don't flip-flop types, you usually end up with very decent native code. TypeScript, for example, makes it easy to ensure that your functions are only called with the correct types and that the types of your variables don't change at run time. Anyhow, if you want to do some serious number crunching, you can write a Wasm module for that.
Randomly chose then index and then use that index for both arrays. let a = [1, 2, 3]; let b = ['A', 'B', 'C']; let r = Math.random() * a.length | 0; console.log(a[r], b[r]); // 1 A, 2 B, or 3 C
Thanks, very helpful. I hadn't considered extensions/addons. If it was an extensions/addon that was doing something malicious, would this be picked up by real-time anti-virus and the like - or would it be invisible to them?
Great, thanks. I dismissed phishing, because the conversion rate or even abandonment rate haven't been affected - and I'd assume they would be if the visitors journey was being severely interrupted. Not sure if my logic is wrong there? I guessed it would be more profitable to just try and silently capture card details from unsuspecting card-holders...
No, the browser window receives keystrokes only if it is focused. 
It can be fairly silent sometimes. Phishers who think about it capture the original action URL, and once you've submitted to their site, they then resubmit that data to the original action URL, taking you back to the original site. You could easily have gone through a middleman without noticing - it would just take slightly longer to load. Although I agree to make it undetectable for the client would take a little bit of effort on the phisher's part. I think the other commenter made a great point regarding extensions, especially as recently an extension called "Web Developer" got exploited and inserted adverts into pages.
Useful information! Both the frameworks are ideal for creating additional user elements. But neither ReactJS nor VueJS can be called the full-scale framework. Also, I recommend reading this article to figure out some nuances: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
 &lt;script type="text/javascript"&gt; function changeUrl() { var site = "https://duckduckgo.com/?q=!ducky+site:en.wikipedia.org+%s"; window.frames["duckframe"].location = site; } &lt;/script&gt; &lt;iframe src="https://duckduckgo.com/" sandbox="allow-forms allow-scripts allow-same-origin" height=400 width=400 frameborder="1" name="duckframe"&gt;&lt;/iframe&gt; &lt;button onclick="changeUrl()"&gt;Load page in iframe&lt;/button&gt; Should this work? Getting: &gt;Unsafe JavaScript attempt to initiate navigation for frame with URL 'http://localhost:62622/Home/About' from frame with URL 'https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FS'. The frame attempting navigation of the top-level window is sandboxed, but the flag of 'allow-top-navigation' or 'allow-top-navigation-by-user-activation' is not set. ____ &gt;Uncaught DOMException: Failed to execute 'replace' on 'Location': The current window does not have permission to navigate the target frame to 'https://en.wikipedia.org/wiki/S'. at https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FS:1:118
great, thank you
Yes, I hadn't given a thought to extensions at all - although in this case I know the code was loaded into the header of my clients site - but even so, it's good to know. I've always been quick to load extensions that do 'useful things'. I'm still not favouring the phishing - because the website concerned uses Sagepay in a modal-window, and I assume that no really sensitive information is posted about then, so couldn't really be caught by the middleman.
useful information! No doubts, it can. Also, I recommend reading this article to figure out some nuances: https://erminesoft.com/reactjs-or-vuejs-which-is-best-for-your-project/
The error message tells you that you have sandboxed your iframe (by adding the "sandbox" attribute) but did not set "allow-top-navigation" flag for it, so it doesn't work. Try removing the sandbox or adding "allow-top-navigation" to the list of allowed behaviours?
Then the parent gets redirected. 
Right. You are addressing the wrong frame. Add an `id` attribute to your iframe, like `&lt;iframe id="duckframe" ...&gt;` and then change its `src` attribute like this: ``` document.getElementById('duckframe').src='https://duckduckgo.com/?q=!ducky+site:en.wikipedia.org+%s'; ```
Still getting redirected. Guessing dockduckgo have some sort of protection again this type of use. I want to do 9 site specific searches simultaneously. Google's custom search API would be very expensive if it were to be used by more than a couple of people. Any suggestions?
Code in user addon is not "virus" since it is code which user installed and gave perrmissions. Some antivirus solutions may recognize some shady code there, but treat it as a bonus, not a guarantee. Its in same class, as if user installs application, which asks for password and send it to some site with POST. Maybe a bit better, since you could recognize it by firewall. But addons use browsers runtime, and its probably whitelisted in firewall.
I find this idea of funneling down really interesting to help dependent projects, and clearly what has been done here is a huge step forward for OSS. Well done folks! This raises a few questions (I'm probably not the 1st one to ask) : - Companies will most likely sponsor projects with high impact/visibility such as webpack, but what about smaller projects which we pack doesn't depends upon? Funneling doesn't seem to apply here. - While VIP support is a great benefit, it is limited by essence. We're not there yet but let's imagine a lot of companies follow trivago example, it will be difficult to satisfy everyone. Did you think about such a situation already? Or is it too early to think about it? - How to ensure repartition/funneling is done fairly/responsibly? Done via an open governance model + Open-collective providing the tool/platform, right?
https://duckduckgo.com/api says they don't give out full search results but allow API access to their "quick answers" (not sure what that is and if it is useful for you), so you might need a more complicated solution here (a webpage scraper?). Alternatively, if you are looking for a way to simply open nine browser tabs with pre-defined URLs, you might want to just bookmark them, put them into a bookmark folder and "open all" :)
OK. Malwarebytes are suggesting that they've picked up a couple of dodgy extensions on the day they were issued, so maybe they're worth a closer look.
Processing. Daniel Schiffman wrote a book explaining how to do this - called Nature of Code - and the code is on processing.org. 
I declare all my references as locally as possible with a default value which provides a known type to a reference. Then I am careful to not reassign an unrelated value to the reference, much less an unrelated data type. This certainly isn't foolproof, but I do have a greater than 98% certainty there is no type recasting in my code. The only real gotchas are the native JS methods that take one data type and return a different data type, like Number's *toFixed*.
Fun fact: you can run actually git clone and run it locally and get similar result in your terminal. :D
I remember them too and they would be considered ugly, clunky, and feature-less today. But I guess grass was greener back then anyway.
Do you have plans to make Webpack easier to use? Personally I'd like to see more real-life examples with actual full-blown config, but that's rather a proposition than question. Anyway, what improvements should we expect as regular users?
Hi and thanks for the response, unfortunately that doesn't work properly, because is has something to do with the scrolling of the iOS browser. In iOS when you try to scroll the url bar is getting smaller and at the bottom the options disappear for a bigger viewport.
yup, it seems that is what inspired the author
... now if only there were a decent linter for C#. I've got something that i found for full Visual Studio, but it's not very decent. 
This is the best tl;dr I could make, [original](https://uppy.io/blog/2017/07/golden-retriever/) reduced by 93%. (I'm a bot) ***** &gt; We released tus: the open protocol for resumable file uploads, as well as Uppy: the next open source file uploader for web browsers. &gt; If your browser suddenly decided to crash, Uppy would have no idea about what it was doing before, and you would have to re-select and edit your files all over. &gt; For one thing, no other competing file uploader uses tus, and resuming uploads without standardized and scrutinized components is really leaving you with more problems than you&amp;#039;re trying to solve in the first place. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/6rbttg/uppyio_make_file_uploads_survive_browser_crashes/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~182193 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **file**^#1 **Uppy**^#2 **upload**^#3 **browser**^#4 **works**^#5
Can you give some details about how the project was proposed at trivago and how it became a concrete partnership? For example : Was the idea immediately welcomed inside the company or was it difficult to get it accepted? What was the main or most decisive argument that convinced those who were opposed to the idea? Thanks
Maybe, but I wouldn't count on it, and if you want to have any chance of grasping programming, you're better off not using a GUI tool like bubble as you're not learning anything valuable in terms of programming. Going through your post history leaves me very disheartened. I'm not sure of your motivations for becoming a programmer, but you've got to figure out if you enjoy programming or just wishing up the ideas. That being said, if you intend to continue, I think you should lower your goals tremendously. Start off with something like e.g. JavaScript, Python or for that sake GoLang, but take your time building small things with the languages. Don't go about trying out Solidity as your first programming language, and try to have goals that seem manageable. Most importantly, start coding, hit the brick walls and learn from it.
Awesome stuff!
I feel the same when I have to write plain JS. I just visualize the types there for my brain, but I always miss TS. Also, why would you even write d.ts files by hand? :D Also, I don't envy your coder girl, I wouldn't want to date a girl programmer.
I need to use libraries that are not included in the npm repository or the DefinitelyTyped, so I need to complete the .d.ts files myself. Kind of a sick work, but... And yeah, programmer girls are awesome :D 
github?
Joined! :)
Oh snap, I totally forgot about pre-allocating.. it was kinda late. Should be faster to pre-allocate the arrays like spacejack wrote, so keeping `new Array()` will probably be faster. I'd be curious to see a benchmark of how the different approaches perform.
Post to internet is beatiful
isn't the compiler enough? :-)
Check out their [roadmap](https://github.com/storybooks/storybook/blob/master/ROADMAP.md#supporting-other-frameworks-and-libraries), it's in development. They also mention why they chose Vue first [here](https://medium.com/storybookjs/introducing-storybook-for-vue-940f222541c5)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [storybooks/storybook/.../**ROADMAP.md#supporting-other-frameworks-and-libraries** (master ‚Üí bfc9c85)](https://github.com/storybooks/storybook/blob/bfc9c85439a092b7b9fb540926687846302d1a84/ROADMAP.md#supporting-other-frameworks-and-libraries) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dl3vu7z.)^.
Another article on the Vue support [here](https://medium.com/storybookjs/introducing-storybook-for-vue-940f222541c5)
I want to build it for them, with configuration, not host the code. The code is already on github. I want to automate the creation of a config file and running "gulp build" or some other existing gulp command, then email the result. Potentially to hundreds of customers a day (so it can't be manual).
Not a single thing left... Can't code split css... Okay bud.
Unfortunately it's not much of a story. :) The idea was immediately met with huge support from everyone. We simply explained how Webpack has enabled us to do many of the significant improvements to our website over the past few years and that there is no comparable alternative for our rather complex use case. The additional training and support that Sean was able to offer was an additional incentive but our main motivation was to help Webpack continue to innovate. Each time Webpack is improved, our product improves as well or our developers become more productive. After presenting our arguments (and receiving immediate approval) we started to get the paperwork done with Sean and Pia (from OpenCollective) which was also quick and easy to do.
You need to return response and then the promise from getDataById. Then the caller (forEach) has to take that promise and then() the result. Whenever you are working with a promise, and something further up the stack needs access to its result, it will also have to deal with the promise (or at least some other form of async handling wrapping the promise)
you must use `then` method, e.g. https://jsfiddle.net/m7fa9dg8/
If you mean ie9 css splitting, then yes it does that: https://www.npmjs.com/package/css-split-webpack-plugin Or if you're referring to future goals open for webpack, that isn't what i implied when i said webpack is able to handle everything that grunt/gulp did. Do you know any task that gulp could do but webpack doesn't?
I think it's nice, readable syntax in lieu of having the mentioned operator. If you're concerned about performance, then I agree that it's not great. If you're concerned about syntax then I guess we'll agree to disagree. I like it more than having ~~duplicate~~ verbose code that the other options produce.
Does anyone else read snake case slowly in their head?
&gt;Does anyone else Probably
Some comments: &gt; ‚Ä¶a keyword for variable instantiation... Variables can be declared and defined, but not instantiated. Instantiation refers to the creation of new objects, independent of variable use. This also isn't the only place you use this terminology. &gt; In fact, every web site and application that used Javascript between it‚Äôs inception in 1995 and the release of ECMAScript 2015 (ES6) used var and only var to create variables. JavaScript 1.7 supported `let` in SpiderMonkey (Firefox) as far back as 2006, and subsequently also within Tamarin. I used to have a Tamarin shirt years ago that said "let is the new var", but I don't know where it went. It wasn't exactly an attractive shirt anyway ;-) &gt; I think it‚Äôs worth clarifying that when I say ‚Äúinside of‚Äù logA(), I mean ‚Äúbetween logA()‚Äôs curly brackets‚Äù. meh. I don't think so. More worth mentioning is the special blocking rules in `for` loops which I don't see. &gt; But for the most part, this is bananas. "use strict"; prevents this and should be included at the top of any ES5 script. This can come off a little cryptic. You may need to be clearer about what "use strict" is and how it works (just having a string sitting at the top of a script _is_ awkward). If not explaining it yourself, a link to more information would also work well. &gt; 3 ‚ÄúThey can be declared without a value‚Äù ... We already saw them being declared without a value in #2. Maybe #2 and #3 should swap? Also this section seems to instead mostly focus more on multiple variables declarations in a single statement which could probably be a #4. Also we're now suddenly out of a function and in a script? With no further explanation? What was all that _"(Unless it was not declared inside a function. In that case, it exists ~everywhere~ üò≤. More on this in fact #3.)"_ talk from before? (&lt;- which isn't entirely true either, since module scoped variables are outside functions but not everywhere.) &gt; Bookmarks for let üëì ... A plethora of resources for let (Jefe, what is a plethora?), but nothing like this anywhere else? Why does let get all the love? &gt; 1 const is block scoped, var is function scoped. 2 const has to be instantiated with a value, var does not 3 const cannot be reassigned, var can 4 const cannot be accessed prior to instantiation, var can This seems like a set of bullet points that got mangled down into a comma delimited list by accident. In fact, what would be nicer is a table showing off the varying characteristics of each var, let, and const. &gt; [Back in #3] Put a pin in this because it becomes important later. Where was that? :-o
Very cool. Bookmarked
&gt; the cost of you writing this single post and me replying to it negates the benefit of any arithmetic optimisations that we could possibly do in our lifetimes, combined. my day suddenly feels much bleaker 
Thanks for sharing the template, but when I look at the stats: (My connection is a 50 Mbps wired connection). 39 requests | 10.6 MB transferred | Finish: 18.01s | DOMContentLoaded: 6.25s | Load 18.01s Now, within that 10.6 MB: - Images are 9.1 MB (wut?) - **JavaScript is 865 KB!** - CSS is 388 KB! (what exactly is going on?) - Fonts are 274 KB I can't even talk about first-paint, memory usage etc. I don't think a basic admin-template should have 865 KB of JavaScript and 388 KB of css.
The first example demonstrates a feature of JS that is due to its implementation of [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation) -- if you check the table, under "Result type" for javascript you'll see it says " Last value". In many languages, using `&amp;&amp;` or `||` will always return a bool, but in JS, it returns the actual value that was used. &gt; 1 || 0 1 &gt; 0 || 1 1 &gt; undefined &amp;&amp; true undefined 
[removed]
Good bot. ___ ^I ^am ^a ^bot. ^This ^action ^was ^performed ^automatically.
Awesome! I will release it in a week or two!
[Beware](https://www.reddit.com/r/javascript/comments/3x91ac/why_not_to_hire_people_who_like_es6_classes/cy2o6zj/)^1 [referencing](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^2 or [learning](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^3 from Eric Elliott.
Yesterday I didn't have a time, so I just scaffolded a brief plan above. Today I found a spare 10minutes. There you go :) https://codepen.io/pawelgrzybek/pen/yoawaK Is is something that you expected? Around 40 lines of Vanila JS. No magic here.
[removed]
Thanks for it! We need to check those images! The thing with JS and CSS size - we're using lots of custom components here and Dashboard page uses most of them (charts, tabs, wizards, etc). So, we decided to bundle all our custom components in a plugin and put it in Vue.use in main.js. It increased initial page load but all the other pages are now loading really fast. And then browser caches it. If you've got any ideas - we will be glad to get the PR :)
Now this makes it even more compelling! I saw someone use Storybook with Elm, patiently waiting for Angular 2+ support!
Do you keep those on hand? Or did you dig them up on the spot?
No just call backgroundsArr[quoteIndex] to get the proper one. Of course you'll have to save the index into a variable when you retrieve the quote
Heh. On the spot. Google + post history makes it pretty easy.
This is amazing!
I'm glad I could help.
Is it going to be on GitHub?
&gt; On the spot I'm impressed :) But I guess the fact that its easy helps your case 
&gt; Because the js engine could assume that the parameters are numbers and therefore skip the type checking and or type conversion? That's exactly what the engine will do for hot code paths, that is code that is executed frequently enough for the VM monitor to "get the hint". 
Question: My upload code looks like this ` // event.target.files is taken from a fileinput var files = event.target.files; for (var i = 0, ln = files.length; i &lt; ln; i++) { // Do my framework's code for files here } ` So how can I get the imageUrl from the image into a file type I can work with in JS?
&gt; `Math.add(a, b)` You've just added an object attribute lookup (to get `Math.add`) and a function call. These are both more expensive than the original add.
Facebook did what's right for Facebook with Relay. I don't think people like being forced into the edges/nodes result schema regardless of the good reasons there might be for doing so. They put a lot of work into the GraphQL specifications, but I feel like less effort in friendly documentation and developer tools. Apollo is a GraphQL company - that's all they do. Their tagline is "Tools and Products for GraphQL". In the end, it's what they're selling so it's no surprise that they have a much higher level of quality regarding documentation and developer tooling. They have done a great thing by releasing so much software to the community for free, don't get me wrong. 
no~~~~~~ step~~~~ on~~~~~ snek~~~~~
:) Never thought it was an ascii art. 
The try/catch version is slightly off.. it will still return `undefined` if `meta` isn't set, or its value even if it's falsey. The original sample will return `{}` in the case of a missing or falsey `meta`. 
not really, no. :-S 
Prettier's output is beyond offensive. Actual end of a file of something parsed by prettier: ); } } ); } ); } ); }; 
Well, yes and no. An IIFE is used to create scope, which is not the same thing as a single responsibility function. For example, if your IIFE is creating a module that has state, methods that operate on that state should be created within the same IIFE, keeping the shared state private. If all of these functions are truly unique, then great, use separate IIFEs... but then I'd want to ask... why are you declaring them inside IIFEs? If the answer to that is solely to not pollute the global scope, and not to keep private state for the functions, then there's nothing really wrong with having multiple functions declared within one single IIFE.
tap and Jasmine seem pretty popular.
At first I thought this was a console application which would be pretty damn sweet! Looks great anyway :)
I think this is a good point.
what do you like about vs code?
what do you like about Komodo?
I love sublime but hate the nag to buy. And I would buy but the cost is kind of steep, notepad++ does the same but for free. I would happily pay $15 or $20 for sublime.
That's interesting. Can you share the code that caused this? It seems like there is quite heavy nesting going on
It's from here: https://github.com/awslabs/aws-iot-examples/blob/master/justInTimeRegistration/deviceActivation.js To my "standard" style, there's an error in the indentation levels, and I spent entirely too long trying to fix it, so I finally just grabbed prettier to show me where the problem was .. prettier turned the end of the file into that mess. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [awslabs/aws-iot-examples/.../**deviceActivation.js** (master ‚Üí d5af25c)](https://github.com/awslabs/aws-iot-examples/blob/d5af25c54138e3f01ce776b724e9af40a721ea12/justInTimeRegistration/deviceActivation.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dl4alvo.)^.
No one writes 'vanilla' Python or 'vanilla' C# or... you get the point. In every language you use packages and libraries and frameworks and no one seems to complain about it outside of JavaScript. Don't force yourself to use a screw driver when a power drill would do the job better because 'less is more'.
I probably should've said multiple languages that are not pre-compiled .. Komodo has good Javascript, HTML, PHP, Python support .. though you can get equal or better in VS Code now, I thought Komodo was the nuts for all that before VS Code came out with all these extensions that add more languages. I haven't had much of an opportunity to use Python with VS Code, though, so I haven't checked out if it supports debugging Python or anything like that. There are at least a couple of good syntax parsers though. 
Please stop advertising your product.
I believe plain vanilla javascript is already making a come back, people deride the use of Jquery all the time - it never went away - and people still learn it
Javascript does seem to have a rather loud opinionated contentuous community - but then again it also seems to have a rather large over populated ecosystem with too many options for doing the same thing 
Mocha and chai are good too
Yeah, but (most) people didn't drop jQuery to write plain old JavaScript. They dropped it in exchange for React, Angular, etc.
Well, not me, I am perfectly happy using Javascript (and VueJS) combined with rails because it's a more stable ecosystem and honestly, I find javascript libraries like React and Angular much more difficult to learn...the 'flexibility' of javascript in a variety of ways that people praise bugs me...to learn that the new =&gt; isn't an exact replacement of using function was really annoying, just another needless complication. I appreciate what JS can do but really don't feel like it has a good overall 'agreed upon structure' and it's too loose That whole NPM thing this week for instance, how the hell does something like that happen?
Template literals once fully fleshed out will replace a lot of templating packages, generate some more, but it'll help.
Isn't VueJS a framework? Also the difference between function and =&gt; is a useful one, it's definitely not a needless complication. 
It is a framework - but it's not complicated or over done, and it's modular - if you just work with basic VueJS it's quite simple to pick up and integrates with rails in a beneficial manner (I totally suck at web design, so anything that can help that, and make thing like dynamicity /UI easier I'm all for). I consider 'standard' VueJS on its own less then Angular or React or Ember - i spent a weekend each with 'beginer' angular and beginner ember courses and almost always ended up saying "You can do this in rails but in a much less complicated easier to read fashion" I didn't wily nily dismiss them - I gave them a fair shake and found that they didn't work *for me* Now, I'm a neuroatypical 45 year old who is self teaching and has a masters degree in one of the 'hard sciences'. I'm sure for people who grew up learning javascript maybe it's easier. I mean if you're working on a project it's much easier to find javascript folk than rails folkl to work with - that much is true :)
 const getDataById = objectId =&gt; { const url = `${baseUrlToGetById}/objectId` return httpRequest.request(url) // assuming url uses objectid } myObject.forEach(object =&gt; { getDataById(object.id) .then(response =&gt; {object.newValue = response.result}) }) You have to be careful though, because if you try to access the 'newValue' of something in myObject before the network requests have resolved, it may not be what you expect it to be. Remember this is all asynchronous.
Why would it?
You can't compare framework use on the frontend to framework use on the backend as on the frontend you pay a performance penalty for every additional unused bit you add to your code (both in download speed but also in js parse time). If you are building a content oriented site, go with minimal "vanilla" JavaScript. Building an "app" experience, find a fitting framework and go from there.
Vue isn't vanilla JS though. I would be very clear that it's a framework with a high level of abstraction given to the developer.
To offer high performance on as much devices as possible "less is more" is almost the only strategy that will work. Of course this won't work for all websites/apps but at the very least most content oriented sites should not rely on overly complex and hefty frameworks.
I never said it was, but when I use Vue I write vanilla javascript within it
Developers who prefer "vanilla JS" over frameworks are likely missing _why_ framework-using developers use them - to better manage complexity of large Javascript projects, to have a common architecture that can evolve over time, and (probably the most important), to be maintainable by other developers as a project matures. The "whole NPM thing" - the cross-env package story - is something completely unrelated to the use of frameworks and the evolution of the language. It's actually been a known issue for awhile - google "typosquatting npm". Developers had been using Javascript libraries for years before NPM came along. VueJS is a "javascript library" just like React, Angular, etc. Vue.js is much newer than both React and Angular, and the creator has openly credited those two projects with being the inspiration for a lot of Vue's parts, such as custom HTML attributes from Angular and the component-based architecture from React. Arrow functions came about due to a specific need in order to better manage function scope in large projects and to more easily pass scope around with callback functions. They've been around for at least a few years now thanks to Babel.js and [are natively supported in all major browsers](https://caniuse.com/#search=arrow) (except IE, as expected). I can understand your frustration though w.r.t. using arrow funcs in Vue - I specifically remember from the Vue docs to use standard `function()` declarations for event handlers in order for those handler funcs to be bound to the component scope. 
You serve little purpose 
Well, sure. Whenever you write a function, it's often "vanilla js" as in it is javascript code that is not calling any functions from other libraries. Also, just to point out, arrow functions are "vanilla JS" too. We just use bable for backwards compatibility to people who have browsers too old to support ES2015
And in my experience Javascript frameworks are overly complicated with a massive barrier to entry that rails doesnt have - and like I said it's my experience The amount of javascript proselytizing, and lack of respect for anyone who doesn't use javascript is really obnoxious and pedantic - why are some many people in javascript so uptight?
And when I was reading about arrow function the stuff I read said they *replaced* the use of the word function, which is inaccurate, because they don't replace them, they're just yet another option.
Now that we have Vue, the only things missing are Em and Cee :-)
Relay Modern is actually pretty exciting, but they completely mishandled the release (just like they did with Relay Classic). They've unlocked a lot of power, but there's no information anywhere on how to use it - the documentation is *terrible*. It's exhausting opening Github issues or chasing Facebook employees on Twitter to learn how to use the damn thing. I genuinely think Relay would be far more compelling if Facebook had shown any interest in actually getting people to use it. I'm sticking with it because I like it, but it's been a frustrating experience.
Yes. You are right. In my opinion it comes down to two factors. - you might just enjoy how the code looks in arrow functions, more than normal functions (I don't really) - you want instant binding of "this" keyword without having to do a "const self = this" in order to pass context into other functions where you might lose "this" context. So in our react projects, all my component functions are normal functions. Unless I need the "this" context when passing to an onclick event, of something, or something like that. So I then sometimes use an arrow function in that situation. Or you can just bind the function in the constructor and use a normal function.
I'm still new to the development world so please forgive my ignorance on the topic, but plain JavaScript without a framework would be faster than with a framework right?
And to me that's just making something that's already complicated for a lot of people (this, and scope) a lot more complicated...the arrow function should not be presented *anywhere* as a replacement, it should be presented as an alternative with clear easy to understand explanations of how the two work differently. 
I would change Mongo to PostgreSQL, and your good to go.
But frameworks are just "plain Javascript" under the hood. They're not inherently faster or slower. This whole "vanilla JS" term is kind of dumb.
Would it be slower because you're simply having to load more files or no? And would it be faster to write exactly what the browser reads?
1st, thanks for the work you are all doing. I'm excited about webassembly coming to webpack. My comment is about Open Collective, and the idea that it could be a new model for financing open source. I'm hopeful it can be -- I hate the idea of using banner advertising on project pages, and I don't think pledgie and the like really attack the problem (saying thanks vs. funding ongoing development work). Open Collective aims for full transparency, but record entries like this aren't transparent at all: `development 04/2017 -$8,000.00` If I have a small agency or something and want to contribute to the tools I use, how do I gauge whether contributing to an Open Collective project is a good investment, vs. other alternatives to further the project, like assigning a FTE (full-time employee) for some percentage of time to working on it? And who is behind the Open Collective project (you promised transparency)? I would assume it is Webpack core committers, but there's no way to tell from the Open Collective project page (which has only sponsors, donation contributors, and github contributors as far as I can find). My concern isn't what a developer is being paid by the project, or Webpack's Open Collective project in particular (I think it's an important issue for the community as a whole -- I hope to see Open Collective succeed). My suggestions are: 1. Projects should identify who's behind them. Statements of purpose are great ("we are webpack"), but it doesn't give me anything to evaluate whether this is an organization I'd want to support financially, especially if it's meaningful support in terms of funding development (not saying I'm in a position to do that, really I'm not unfortunately); 2. Give some idea of what the development expenditures are buying: `75% of 1 FTE Developer for July` or something. Last, maybe give sponsor credit through the Open Collective process to people / companies who make significant (greater than 25% of an FTE?) contributions to a project that aren't cash. If Open Collective is to really be a "new form of association", I could see it being alienating that it looks like competitive salary going to some developers, while those who give time freely to a project get no credit. You favor companies listed as sponsors on the Open Collective page (I'll look at their website, and if their product meets a need I'm likely to buy to support their efforts in supporting the project I use), but companies that for example have someone on their payroll giving 50% or 100% of time to a project don't get similar recognition. Anyways, good luck and thanks!
Nobody should use jQuery in place of a view framework, it just leads to a big spaghetti mess. Since ES is advancing at such a rapid pace now and we have tools like Babel to avoid compatibility issues, there's really no room for jQuery anymore. It's bloated and provides an unnecessary level of abstraction, to the point where when new developers use it they don't realise just how simple the native equivalent is. const el = $('.my_class') Vs const el = document.querySelectorAll('.my_class') It's just not worth it anymore, and every company I've worked at since graduation has been phasing it out of their codebase.
How do you find Vue okay but not React?! If you can learn one you can definitely learn the other, don't put yourself down! As for arrow functions, you don't have to use them, the function keyword will always be there. It provides a far, far simpler way of creating a new function without opening up a new scope, because previously you would have to bind the function you just defined to the scope you want it to reside in. Also when you get into currying, arrow functions look a million times better IMO.
Nothing is going to get easier, if that is what you are after. It's why areas like front-end web development requires a more software engineering minded person than what was required 10 or so years ago. 
Vue works for what I need :) It was all motivated by my desire to do a D&amp;D character generator (to strengthen my vanilla javascript skills) and I got stuck on a few things conceptaully that vue would work with - i llike rails - it works for my brain - and VueJS
Ah right, would position: fixed do the same thing? Also you could try set a global variable when the menu is open, then if true disable scroll and touch events on everything except the menu.
In theory, yes, in reality, very unlikely. Take React for example, you could write your own library that spits out markup, but you've lost a lot of time just writing that library. It's also highly unlikely that anybody hacking together their own view library will be able to match the performance achieved by a dedicated team at Facebook, plus hundreds of OSS contributors. That diffing algorithm too, it's highly unlikely your average developer is going to match anything like that. Also forcing every company to develop their own view library is a tall order, and forcing developers to learn a new library or framework everywhere they go won't be good for the industry. If there was a standard library built into the language that would be different, because that could be a C++ beast. That won't happen though, you'd never get the standards committee to agree on something in an area where everyone disagrees.
At the end of the day, the work needs to get done. If you are trying to change the contents of your page, *somebody* has to update the DOM. You can either write all this code yourself, of you can find a library that does the work for you. The library might be heavily optimized by people who specialize in this sort of thing, but it might also have extra stuff you don't need. Will it be faster or slower? It depends on how well-optimized it is, and how well it's feature set matches your use-case. If you build a reasonably complicated UI using lightweight virtual DOM libraries like Preact or snabbdom, the result will almost certainly be smaller and faster than a hand-coded solution (otherwise, you would basically have to re-invent the virtual DOM algorithm yourself). If your site is super-simple (a few menus on a mostly-static page), then even these libraries are overkill. Rendering speed isn't the only issue, though. Developer time is probably more important, especially if you have competition. Shipping features to customers quickly is far more important than shaving bytes or milliseconds, especially if the site is "fast enough". In these cases, using a framework is definitely a win.
Maybe, maybe not. I'd guess that a lot of frameworks spend a lot of time optimizing functions, and if you're going to replicate that functionality, your replication might be slower, might be faster. Check out [The Rails Doctrine](http://rubyonrails.org/doctrine/). Number one is "Convention over Configuration", which is true here. Your project should be easier to maintain if you use a framework, your problems will have been solved before, you can skip a lot of development time. A *perfect* custom solution for any project with complexity will run faster than one created with a framework, but the framework application can be developed in a fraction of the time, will probably have less problems, and will be easier to maintain.
Oh no, options?! I'd much rather have no new options and a stagnant ecosystem because I'm comfortable with what I know and change scares me. /s 
Thanks for the link! That's a really good example for callback hell and I agree it doesn't look good. In a more modern version async/await really saves the day: async function doSomething() { const iot = new AWS.Iot({ /* some options */ }); const policy = await iot.getPolicy(); const policies = await iot.attachPrincipalPolicy(policy); return await iot.updateCertificate(policies); } That's much nicer to read. Nesting loads of callbacks are tough to follow and do indeed look ugly with prettier's indentation. Whenever I encounter some code that looks strange after prettier has done it's thing I usually sit back and notice that I could have written my code a lot simpler. In a way it does reveal bad habits for me which I love!
Of course it's "faster" (as in less code) to write code that only does precisely what you want, when you want it. The point is that as your app scales, doing so is not trivial. In fact it's very difficult. And in the end, you end up with code that is probably going to be very similar to a framework that was there all along. So it's a set of tradeoffs. It's not the case that "plain JS" is going to usurp "frameworks", or vice-versa. It depends on what you're doing. Using a full blown framework to toggle a class on some static HTML is dumb. But stubbornly writing your own framework for every project is dumb too.
&gt; Would it be slower because you're simply having to load more files or no? Sure but that 'slower' is super small and not noticeable to a user. &gt; And would it be faster to write exactly what the browser reads? Absolutely not. The opposite by a mile. 
Definitely for a very small app, yes. There's often not a need to use a framework. However, it's usually quicker to use a framework and it's definitely going to work out better for you as your app grows. If it's a small app and performance is so important that the small differences you'll see actually matter then fine, but I don't think there are enough of those types of apps for your original question of whether you think it'll make a comeback, which I read as people rejecting frameworks when creating apps. 
If you want to get close to vanilla, try RE:DOM (https://redom.js.org). It's tiny (~2 KB) and super fast (among the fastest libraries) with very little memory consumption. üòâ
Will writing 3D games from scratch without a framework make a comeback? (No)
Additionally, there was a time where jQuery was the best way to interface with the DOM, and now js and HTML5 features have come a long way, and you don't need jQuery the way you used to depend on it - so there was a push for a while to have awareness about "plain" javascript in favor of not unnecessarily including heavy libraries.
I'd say it actually is in frameworks like React. I write a good portion of my logic in plain ES6 JavaScript.
That's the reason I use `const` in ES6 code as much as possible. The only time you might need `let` is when you make an assignment inside try/catch or `if`. But only until `do` statements arrive.
Sorry I worded that wrong.. Is it faster for the browser to read plain JavaScript instead of having to translate a framework? Yes it's definitely faster for the developer to write in a framework!
Not the OP's point, but we don't see people writing in languages that compile down to Python or C# often. That said, I expect to see a slow demise of languages targetting JS: most of the energy around that nowadays seems to be around TypeScript and Flow, and I still expect to get gradual typing in the base JS language at some point.
Cool man thanks!
Where is the email originating at? If it's client side, just do a mailto: link. You can specify to: subject: and body, but not from because that depends who's clicking the link. If it's coming from a server piece, you're receiving it, not being prompted about it, but setting from: is far easier. 
To answer your question: yes I do believe! ü§òüòé
It's like saying you could write better poetry than TS Eliot if you use vanilla English instead of mad libs. There aren't many developers who'd get good performance going it alone.
For building apps, probably not. Working with the DOM in an efficient and scalable manner in anything non-trivial is rough, and whatever you do to keep your code maintainable will essentially be a "framework". For libraries though... JavaScript and the web platform are now more than good enough to do a lot of things without any dependencies. Dependency free libraries have a lot of benefits, from smaller sizes to easier bundling, going by less complexity to manage and introduce bugs. 
It never really went away. There are plenty of projects out there which still require intimate familiarity with plain javascript (of all versions) as well as the DOM and HTML5's many APIs. Usually those projects fall outside the "boilerplate" applications spectrum. As JS evolves, *some* libraries and frameworks become redundant, but the flow of useful libraries never stops - which is a good thing, since they help shape the next evolution cycle.
I do think for some situations (like websites where you would previously use jquery), there is a trend to use more native functions, which is nice. But thinks like build systems will not go away, because they just make your site faster and more efficient. Also there are a lot of good libraries you want to use in the right situations.
Right now is on github as a private repo! 
I agree. A lot of people write articles about programming and I think they do make the mistake of not explaining why they do what they did. Or what the other options are. Teaching isn't easy and a lot of people write these articles partially to hop on a trend and get a lot of page visits. Perfect teaching/communication isn't always the #1 priority. The "this" concept is both simple and complicated. I think a person needs to spend enough time with a language before it becomes second nature. 
&gt; we don't see people writing in languages that compile down to Python or C# often That's because Python and C# are good enough to actually write code in... although JS has been shaping up, to be fair.
And increasing the barrier to entry through choice saturation does wonders for our job security.
For the most part this is because people don't want to target JS, they want to target a browser which leaves them no choice. If you are writing some backend code in python that is because you wanted to write python. If you wanted to write C++ you can still target that same platform.
&gt; Apollo is a GraphQL company - that's all they do. Except when all they did was Meteor, which they have paid very little attention to since they transitioned most of their staff to Apollo. 
Plus custom elements and shadow DOM will likely replace component frameworks, or at least allow them to shrink considerably.
I'm kind of anal about things though - i think a lot of things people call tutorials are really 'how tos' - i look at it this way - a tutorial is a lecture that i would have for biochemistry as an undergrad and then the how to is the lab - theory versus application
The JS community has settled on compiling code to JS, I really do not see that changing anytime soon.
But you'd probably also realise that getElementsByClassName would be the more performant alternative.. Right? ;-)
Tree shaking, Prepack etc. Huge optimisations are here and coming. You won't be able to tell the difference soon :)
I use "vanilla" ES6 all the time in Node. I don't see why people would stop using tools that help build large scalable apps in the front end.
Only if you want to lose the ability to select by ID, tag, attribute, etc.
I think most programmers are anal in some ways. But it's good to have realistic expectations with any lessons we get. Especially stuff we read online. The lessons are often inconsistent so we may as well expect it. 
Well, native web components are a thing. There is definitely a purpose for reusable components that are not tied to any view library or framework. As for structuring an entire app with just plain DOM code... I hope those days end forever. It's not only horrible to write, it always ends in spaghetti code that nobody, usually not even the original developer, can comprehend.
I tend to stick to stuff that seems to have a good history or 'supporting' staff behind it...manning publications is good for a variety of learning stuff, prag is good as well but the fact that rails book uses scaffolds still pisses me off....lynda.com recently upgraded (from 2011 for god's sake) many of their intro courses...Sure they cost money but that investment to me provides (hopefully) that they took more time in crafting lessons 
It will allow them to shrink, but there will still be libraries around them. The spec does not define data binding and the way of setting up components contains way too much boilerplate.
With JavaScript you tend to see suggestions and ideas over hard and fast rules. Frameworks are, after all, just an idea for how to solve commonly occuring problems. But since every application can differ, the needs differ, the solutions differ. I don't mean to infur but I get a bit of a feeling that you would like more rigidity. But you may have to learn a framework and then learn how to use it for your projects, then invent your own rigidity. I am anal and a perfectionist so I'm fairly rigid in my expectations of my devs. But in our line of work we are constantly dealing with unfair constraints from outside our team, so he rigidity often needs to be backed off. 
Meanwhile in js gamedevelopment problems like these remain unknown.
Structure is not rigidity, agreed upon principles is not rigidity, it just makes sense in that it allows for people to be able to read other peoples code more easily...you can infer all you want, but the 'looseness' with with javascript frameworks operate doesn't make them any more 'flexible' than other rigid frameworks in what they can do, it just makes them more complicated and the entire ecosystem is awash with things which is why the javascript open source community has more open anger towards one another (and other communities) than anyone else...you're eating your own...it's a fascinating sociological experiement. Plus there's the whole, i'd never want to use something built by a massive evil corporation like, you know, facebook, cause god knows what might happen if they change their minds, or insert code they think is 'harmless' to snoop on all your users. 
Are you talking about transpilation? Babel has Regenerator, but I think everyone dropped that in favor of transpiling to plain JS beforehand.
Well, jQuery's strength comes from its fluent API. you can just use $('.my_class').addClass('bla').text('Hello, World!').attr({src: '...', 'data-bla' : '...'}.appendTo($('#someId'); instead of an abomination like var elements = document.querySelectorAll('.my_class'); var elementToAppendTo = document.querySelector('#someId'); for(var i = 0; i &lt; elements.length; ++i) { var element = elements[i]; element.classList.add('bla'); element.appendChild(document.createTextNode('Hello, World!'); element.setAttribute('src', '...'); element.setAttribute('data-bla', '...'); elementToAppendTo.appendChild(element); } Personally, I SO wish JavaScript would just copy Dart's [Cascade Notation](https://www.dartlang.org/guides/language/language-tour#cascade-notation-). This would solve nearly all verbosity problems I have with the DOM API without it having to be re-implemented and without forcing the developer to waste resources at runtime by using some fluent API library wrapper.
Yes! That's the word I was thinking but I didn't want to get it wrong and sound stupid! But it looks like I ended up sounding stupid anyways!! Lol
You don't have to use the same interface all the time. If you're typing `querySelectorAll('.my_class')`, you know you're trying to select a class, so there's no reason not to use `getElementsByClassName`. `querySelectorAll` is especially useful if you're trying to query from a variable and you don't know whether that variable is going to contain a class name, ID, or some other selector.
I just wish vanilla ajax was as good as jQuery
Again, I sense our differences in reading this. It's fine. I am not trying to criticize you. I love react and react-native. I love JavaScript. But I do constantly deal with real world situations where we have to balance rigidity and flexibility. To me, rigidity is expecting to do things the same way all the time. Maybe my use of the word and my explanations we're not perfect. That's fine. But I still sense a desire for a prescribed method. Anyways, building an application is still largely about deciding how you want to use the various tools you have. The JavaScript ecosystem is an amazing, evolving organism. You can find ways to be frustrated. It's not hard to do. I'm personally inspired and working constantly to learn as much as I can. I would personally suggest to learn as much as possible and simply enjoy the endless possibilities. If you get JavaScript fatigue then it means you may need to focus your efforts on one framework for a while. Or take a break entirely. But I personally can't see frontend Development being a good fit for anyone who doesn't love the dynamic nature of this job. If you like Vue then just focus on that. Hopefully it meets your needs and hopefully you find it fun. 
You need to take into consideration that JavaScript is the largest open source community. GitHub had stats showing JavaScript having more open source work than python and Java combined. You are going to deal with a lot of everything because the community is massive. It's a living breathing thing that is moving at the speed of light. Don't be surprised if lots of stuff is piling up in the wake of the giant moving machine. Edit: grammar
Your inference that other frameworks might be rigid due to their maturity is just false - for instance - perhaps you're one of the JS folk who think rails is old and done or whatever, it's not rigid in your definition - there are a variety of ways to do thing - does it incorpoate some common principles - of course it does - so that things are easier - for instance - creating restful routes in rails is super easy but also has a lot of flexibility - structure is not the same as rigid it just means you don't have to recreate the damn wheel all the time. I'm old enough to remember when PHP was so new you had to write all your own code from scratch, like connecting to a database, or a user authorization, and PHP didn't make it easy. Your senses are completely broken - evolution isn't a problem, immaturity and an clear path are the problem, javascript is awash in an immature primordial ooze where organisms are still devouring other organisms, it's not amazing, it's a freaking death match.... I don't focus on javascript at all - ti's secondary - it has its uses in places, mostly front end, but in general, there are other more mature and yet somehow still flexible methods to use without being caught up in the chronic need to reinvent the wheel or please everyone - ruby benefits from the fact that in the end it was created by one guy
are you familiar with the newish 'fetch()' api? Its not identical to jquery get() and post(), but it is similar enough you can easily make a wrapper to perform the same way. The main benefit is you don't need jquery. https://developers.google.com/web/updates/2015/03/introduction-to-fetch
I'm really not sure why people mentioned python repeatedly - i never mentioned python. Large doesn't mean functional. Large doesn't mean best. Large doesn't mean intelligent. It means large, that's all it means. Dinosaurs were large - how did that do them. I'm fascinated by the lengths JS people go to try and justify how awesome they are - you realize it's just a sign of complete insecurity right - see all the stars we have we MUST be the best... Your metaphor is both awful and twisted and incorrect and lacks comprehension of the terms you're using - bye 
I just wish there was null coalescing when doting into objects. Like elem?.lastElementChild That would end pretty much all my gripes and jquery usage. 
`fetch` is good for simple tasks, but the lack of cancellation and progress callbacks really hamstring it against old-school XHR's. 
Right now i have two libraries in VanillaJS at support and improvement. I code them because there was no need for framework and was need to use them "everywhere". So, VanillaJS has it's ways. In other hand, on some tasks, you don't need to code anything, because you just may use framework or lib.
Hey thank you for the feedback let me see if I can answer all of the questions in one swoop here: (Who is behind it): the idea behind the collective is that every user and contributor owns the project, so technically ANY user can expense the work/time they spend on it. We have an algorithm which tracks all contributions (not just PRs, contribs, but also other types like reviews, triage), and in my case communications, outreach, conf speaking I have to manually report. I think the question you are looking for is "who approves the expenses". This is fluid in that any maintainers of the current project will approve expenses. But this could change, if the webpack core team just hypothetically disappeared, the good news is that the funds are still in the collective account and allows for new leadership to step up and take ownership. People come and go, and they should if they want, so this system allows for that sustainable change in leadership. (Transparency issues): I think you make a really great point here: many times the work is spread across multiple repos, and orgs, so it can be a time consuming process to log every contribution in the expense notes, however this algorithm actually generates exactly which contributions were used in calculating the amount that can be expensed. We are weary in some ways to expose the algo because we wouldn't want people abusing what so far has been a pretty accurate means of tracking how much time someone has spent working in the project but I believe we could probably find a way to use that data to add to the expense reason. Overall, anyone who spends that time is eligible to take the "contrib points" convert to dollars, or convert to stronger voting privileges for webpack.js.org/vote. The system I'm sure is not perfect and I'm sure we will refine it as we go also. And in our "auto-generated-thankyou-for-contributing-here-are-points" email we send out, I will make sure to include that the user must explain a bit more in detail for the month what they were working on. The specific one that you referenced is Sokra who we've been able to add on FT. And I think we should definitely state that it is FTE for the month. (What kind of contribution is more meaningful): So we aim to make this as win-win-win as possible. So: * If your agency funds the collective and becomes a sponsor: * Logo and Name on Docs, Readme * You get golden influence for the amount sponsored that you can use to help impact webpack's direction (webpack.js.org/vote) * If you spend over a certain amount of you can be eligible for on-site training and or VIP support. However we are going to list this (like patreon) as a limited offering. Although support will help us as a project to tackle challenging issues, and have perspectives on how people are using webpack, we do not want it to take away from (at all) the time we spend contributing to the project. * If your agency gives developers x hours to spend on webpack (FTE, or PT), then they will still receive the contribution email and get "contribution points", but I think it would be good to somewhere in work contract to mention that the employee couldn't take funds out but instead use voting points. (I think this is a really really good opportunity to establish a Company/Time based way to track giving devs time to work on OSS projects so that points automatically convert to whatever the company/mgmt wants to see them converted to.) So maybe this is too much to consume all at once but I believe you really have touched on some good points that I am going to share with Open Collective to help look into making easier. Overall the recognition we see as being the same, and we want to offer the recognition in the same way also. Think of Open Collective as the way to provide the self-governance through user/contributor ownership. Feel free and shoot me more questions, or if you have personal inquiries you can always reach myself and open collective at the same time via webpack[at]opencollective[ dot ]com. 
I try to dump jquery in every possible scenario. I also wrote a mobile app entirely in vanilla js(typescript). It's never a good explanation that computers get faster to drop any optimizations...
Yes. I get it. You are an "if it ain't broke, don't fix it" kinda guy. I respect you and your style of being. I have nothing against it. I personally love the frontend world and react, react-native, redux, reselect, redux-saga are my world right now. I love these tools and we are making great software with them. 
I wholeheartedly agree. Our team recently adopted githooks for tslint and prettier and we haven't looked back. Now our PRs can concentrate on implementation notes and CI takes care of the rest. The funny thing is that linting removes the burden of "style" - you can just concentrate on coding (you know, the part that's important). 
Oh - so an egotist - I see now - 'great software' is not defined by those who make it but by those who use it and call it great - calling your own creation great is just silly 
Yeah because there are usually better things to compile down to. Actual bytecodes. As /u/fenduru said, compiling to JS is a hack, something one *must* do if they want to write a front-end application but don't want JS.
good to know. The grandparent post was speaking about vanilla ajax vs jquery. You state xhr has some useful features over fetch and I agree. Aside from supporting old browsers, are there any reasons you can think of to use jquery get() and post() over fetch? I'm not confident I know every corner case you can use the three calls in, but to me it seems fetch does everything jquery get/post can, with the added benefit of not needing jquery.
Not sure how I keep striking such a nerve with you unless those nerves were already very close to the surface. Take care, I guess. 
Are you hunting for my other comments? Anyways, the only thing you are really proving is that you have negative feelings towards JavaScript. That's fine. You are allowed. 
I'm not sure how you think you struck a nerve just because I call you out on your bull shit...but it's obvious how deep your ego is - goodness - i don't envy anyone who works with you
God, you are a pompous ass..thanks for your permission Sadly you are much too active on this subreddit, so I'll have to leave 
You could always just create your shims library that contains just the parts you need (from jQuery or otherwise). 
Javascript is only the largest open source community out of necessity. JS is open source by nature, and it's the only language that runs in the web natively. These don't have anything to do with any supposed superiority of the language itself. It's merely happened because there was no way for anything else to happen. 
I thought the template specs were stuck in development hell because the 3rd party component solutions are far superior at this point. I'd love a standard mechanism, but I don't hold hope for one existing for the near future. 
Have you also used Apollo? I'm new to React, and feeling overwhelmed by what are probably a lot of trivial choices, but I don't know any better.
What is this `C:\` business?
Why did we go with "tree shaking"? I feel like "cherry picking" is better, already used by git. 
bye
https://i.ytimg.com/vi/DID8B2yk5lY/hqdefault.jpg they got the slash backwards - both the Simpsons and Microsoft
When did I say it was suprerior, though? 
If you mean writing front-end JS without using a framework, it doesn't have to comeback because it never went away. Plenty of people write front-end code without the huge dependency that comes with building around a framework. Contrary to popular opinion, it's also quite possible to write front-end code without relying on a billion tiny transitive dependencies because you ran `npm install universe`. :-) That said, you can do a lot more with plain JS in the ES2017 era than you could in the ES5 days, which certainly makes it easier for those who relied a lot on dependencies, whether one big framework or a million tiny libraries, to cut down.
It's been like 5 years since the CustomElement/ShadowDOM spec was introduced and the js world has embraced technologies that are more agile with better backing. I don't see Web Components taking off anytime soon.
because things are parsed into an Abstract Syntax Tree
I'd go with a less trademarked name.
&gt; JS is open source by nature This is not actually true ‚Äì most JavaScript code that is served to end-users (especially from larger websites such as Facebook) is minified, obfuscated, and the users aren't allowed to do anything with it (ie. there is no license attached). No programming language is "open source by nature", but some do have friendlier ecosystems towards open source development.
I think you mean, just Microsoft 
It depends on the scale of application and your skills. If you're new, then probably most of routine stuff is implemented in a much more efficient way by Google/Facebook than what you can write atm. It will always be a lot faster to do something simple in one line of "vanilla" js, but when you have proper UI in a big app managing browser state is a big pain in the ass and someone already did a great job doing exactly that, so you're just missing out and inventing a wheel.
I think you've missed the point a bit. I was comparing the native equivalent to jQuery's `$()`.
What's the good of PostgreSQL? MySQL style database?
Can you please try again with `16.0.0-beta.3`? We fixed the `use strict` issue, and the crawler issue might also have been caused by it.
I feel like WebComponents could kill frameworks. 
MS got it backwards because https://stackoverflow.com/a/1589959. Simpsons got it backwards because MS uses backslashes.
In this thread, there are too many comments treating this question as if someone just asked which religious dogma is the best. The simple answer is this: &gt; "If it makes sense for your project, then use it." This kind of question outlines the fundamental problem that is the modern JS community. Too many people are chasing the shiny penny. They don't understand the fundamental differences between the various options in the toolkit, understandably so since there is so much redundancy. 
Framework authors had better be using "vanilla" JS to write their frameworks, or it'll be a mess of dependancies until you find someone who is. Vanilla doesn't mean only using raw lines of code. Vanilla means using the native libraries and syntax. 
I understood the point of your original comment. I just agree with the person that first replied to you that `querySelectorAll` is usually a less performant choice than the more specific dom selection APIs. I was agreeing with them that in most cases `querySelectorAll` is unnecessary.
That Dart thing looks really nice. I think jQuery abstracts away too much, which makes debugging harder, it becomes a bit of a crutch, and you get these scenarios where people know jQuery but not JS. I think you might overstating the verbosity of native a bit, and understating jQuery's, since you wouldn't want to have that huge chain of jQuery functions on one line. More normally, it would be something like this: const parent = $('#someId') $('.my_class') .addClass('bla') .text('Hello, World!') .attr({ src: '...', 'data-bla' : '...' }) .appendTo(parent); Vs this: const parent = document.getElementById('someId') const elsToAppend = document.getElementsByClassName('my_class') elsToAppend.map(el =&gt; { el.classList.add('bla') el.textContent = 'Hello, world!' el.src = '...' el.setAttribute('data-bla', '...') parent.appendChild(el) }) Which is 9 lines vs 9 lines, although native has more characters it's not an unreasonable amount. JavaScript is already quite a terse language, especially since all the updates. Even though really, these kinds of things should be left to templating engines or UI frameworks and libraries: const Parent = ({ itemsToAppend }) =&gt; ( &lt;div class="parent"&gt; {itemsToAppend.map(item =&gt; ( &lt;span {...item}&gt;{item.textContent}&lt;/span&gt; )} &lt;/div&gt; )
https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Assuming your targets support it or you can use shims. https://github.com/github/fetch
it can be both, SQL like MySQL and no SQL like MongoDB
Well I'd assume if you are changing the class, src and data attributes, changing the contents and moving the elements into another element that'd either be a majority of your logic or it is badly structured. If you see `$('.my_class').addClass('bla').text('Hello, World!').attr({src: '...', 'data-bla' : '...'}.appendTo($('#someId');` and think "Huh, that seems like a good code structure" I'd like to see that app. Vanilla js looks pretty okay to me for reasonable operations: ``` [].forEach.call(document.querySelectorAll('.my_class'), (element) =&gt; { element.classList.add('bla'); }); ```
Easy enough, I still agree with Sebastian: https://twitter.com/sebmck/status/678902700646539264
If MS uses `\` and Simpsons uses `/` and they're both wrong, what's right?
Wanted to point out that `el['data-bla']` should be `el.setAttribute('data-bla', ...)`
Well, show us your current code in a [codepen](https://codepen.io). Can't help without seeing what you've done. :)
And I responded to them by saying you would lose the ability to select by anything other than class, meaning it wouldn't be the native equivalent to jQuery. &gt; `querySelectorAll` is usually a less performant choice than the more specific dom selection APIs. That was never in question. &gt; I was agreeing with them that in most cases querySelectorAll is unnecessary. That was never mentioned.
I'll take commonly understood over shorter. Any JS developer instantly knows what's going on when you're chaining in the &amp;&amp;'s. It wouldn't take me long to figure out what your code was doing but it would definitely take me longer than it needs to
simpsons tried to make a DOS joke and got it wrong. MS tried to make path separators and got it wrong.
or did the Simpson's get it right...
Other people's drills tend to suck when you need niche things
'Vanilla' ES6. :P It's not vanilla when you're compiling to js, even if its from ES6 or typescript or dart or whateverthefuck. That's why the answer to the question from the OP is just: No. Frameworks? eh. They come and go, but just 'pure' js without any kind of transpiling, tooling or library to abstract around browser issues? Forget it. It's never going to happen.
Check out the drum kit episode of Javascript30. 
Doesn't matter. I call everyone man. Even my wife
What are you even talking about? React exists specifically because that naive approach has been proven not to work, and to be slower and worse than using a framework. ie. You have a virtual dom that you push changes to, and then only discretely update the actual dom. That's **significantly more performant** than manually doing it using 'vanilla' js and direct dom updates.
Or, you know &lt;div id="#someId"&gt;{ elements.map(() =&gt; &lt;div className="bla" src="..." data-bla="..."&gt; Hello world &lt;/div&gt;) }&lt;/div&gt; 
Ok, thanks. I will go to check it. So what is the downside of MongoDB of your opinion?
OP is not talking about your code though, they are talking about your right to write your code in javascript and not pay anyone for it when you release it
I think the main differences are: - the first block is 183 characters and the second is 277 - `$("#someId")` is rather more pleasant to type than `document.getElementById("someId")` (especially if you're typing it more than once) - and you _can_ condense the first example to a single line if you want. jQuery's still pretty great from a design perspective.
Nah, at this point, if IE &lt;= 9 isn't a concern using the native XHR constructor outside of jQuery is fine. I've taken my licks with `fetch` tho, which was the focus of my post.
could you use resolve.modules instead? this would also solve the problem of having to alias every single folder under srcPath. https://webpack.js.org/configuration/resolve/#resolve-modules
Don't disable caching during development? What I would try is using `[chunkhash]` in the name for the output file - your entry points will change always, so you get cache busting for free... and if you you use html-webpack-plugin it'll output the updated js file for you
How is ES6 not vanilla? The only part of it that Node doesn't support natively yet is modules, that's the only reason you would use Babel (or for ES8+ features)...
One of my favorite games is typing the name of a web browser into the jQuery GitHub repo. It's a [nice](https://github.com/jquery/jquery/search?utf8=‚úì&amp;q=chrome&amp;type=) [wall](https://github.com/jquery/jquery/search?utf8=‚úì&amp;q=safari&amp;type=) [of](https://github.com/jquery/jquery/search?utf8=‚úì&amp;q=IE&amp;type=) [shame](https://github.com/jquery/jquery/search?utf8=‚úì&amp;q=firefox&amp;type=) in there. Of course, these things never bite you. Until someone visits your page or installs your app on an Android phone which has never seen an update, calling out to the un-updatable WebView. And then boy are you in for a ride of rediscovering ancient terrible bugs on Stack Overflow. Learn the underpinnings. It's good for you. But don't be afraid to stand on the hours of triage and debugging that's gone into making these libraries, frameworks and "extra stuff" when shipping your production code.
I think it will make a comeback. Already you can do so much in plain JavaScript and not even need jQuery. For an SPA I also disagree that frameworks are needed. You can write your own mini framework if you want with just the essentials that you need. At least you'll know how to debug it if something goes wrong.
You'll likely want to make your image have absolute positioning inside some container. You'll create a listener on the body of the page to listen for key presses. When the listener sees one of your arrow keys pressed, it'll adjust some CSS on the element you want to move, maybe the top, left, bottom or right properties?
Nope. Especially because libraries solve real problems that you would have to solve again. State, DOM manipulation, separation of concerns, polyfills, Ajax calls, object/array manipulation, etc
Thank you, your feedback is very direct. Time to (re)write.
Maybe if reinventing the wheel ever becomes fashionable again. Frameworks are the future and they are here to stay. Hell, they have been important and used for years now. Frameworks already have solutions to your problems and they usually do it in a much better way than you could come up with on your own.
JavaScript libraries are JavaScript. JavaScript frameworks are JavaScript. It's all JavaScript.
Say JavaScript one more time
But it ultimately runs on node 4. Regardless it's not nested that deeply, and aside from the original indentation error it's pretty readable. Up to everyone tho. I wouldn't force prettier. It's not pretty. 
https://kangax.github.io/compat-table/es6/ javascript != node.
It would be nice if JS had a real standard library. I think that's as close as you would get to a move back to "vanilla".
TLDR the golden rule is convergence. If most people want a style that you hate, you give in because that is what it means to be on a team
JavaScript (I'm such a petty person üò¢)
If ES6 doesn't count as vanilla (despite being almost fully implemented in all modern browsers), I guess ES5 doesn't either since it's not supported by IE8 and the like. Ok yeah, compatibility is a lot more of a concern on the frontend and various sites will be using a transpiler for a while yet to support ES6 features, but I'm sure some people are still polyfilling stuff for ES5 too in order to support IE8 - at what point do you make the distinction between "vanilla" or not? To my mind, if it's in the standard, it's vanilla. javascript != node, but also javascript != any specific implementation, including browsers
[one-liners-to-show-off](https://h3manth.com/new/blog/2014/es6-one-liners-to-show-off/)
Hi /u/gajus0! 16 beta 3 was release this afternoon. We believe it will resolve the Google crawler issue you mentioned. Would you be willing to give it another try? Details here: https://github.com/facebook/react/issues/10294#issuecomment-320113497
It doesn't get more vanilla than [HyperApp](https://github.com/hyperapp/hyperapp).
I've found `module-alias` to be a very nice solution: https://github.com/ilearnio/module-alias It works at the NodeJS level, rather than via Babel or webpack. When using aliases at those levels or npm-link etc I've had more difficulties. The reason seems to be because even though you have aliased it in your code, often other packages still access the original module (for probably a variety of reasons). That may not be a problem with stateless modules, but if they are storing state in closures, you'll end up with inconsistencies, as different modules will be used by the 3rd party packages. Here's a Babel solution I've used: https://github.com/tleunen/babel-plugin-module-resolver but again it doesn't work as seamlessly as `module-alias`.
So does jquery's normalizing the event object across browser make it a polyfill instead of a framework? Or is that still 'vanilla' js? Where do you draw the line? As I said before; frameworks? eh. Sometimes it worth it, sometimes its not. ..but this whole vanilla JS thing people keep bring up just ridiculous; it's just a throw back to people wanting to just write &lt;script&gt; tags and use onclick="...", because doing javascript properly is hard. Suck it up people. If you're not using the professional tools to do your job, you're not being a professional.
i doubt it. there's always a need to use a framework. checkout sveltjs though if you want a peak into the future.
here's an example usage of it: https://github.com/faceyspacey/universal-demo just add: ``` "_moduleAliases": { "webpack": "./node_modules/webpack-universal" } ``` to your `package.json` and call `require('module-alias/register')` at the top of your entry script--which in jest you may need to specify via: ``` "jest": { "setupTestFrameworkScriptFile": "./entryScript.js" } ```
I wonder if there's a Babel plugin to transform `querySelector('#id')` and `querySelector('.class')` to the more performant methods?
It is already here its just the fact that all the frameworks have so much hype already.
Or for a non gigantic polyfill https://github.com/developit/unfetch