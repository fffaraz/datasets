Hey buddy do ye know what really makes someone a shit person? Judging someone they've never met and undermining their good deeds. Oh wait....
We also never got Windows 9
[NOOOooo...](https://youtu.be/WWaLxFIVX1s)
\&gt; You're right \- I definitely need to give all the libraries and tools a try. They do seem to be so many though and I feel intimidated \- but I'll dip my toes into each and get wet, just so I get a feel for them. Start simple. Build a simple todo app using react. You can use redux for managing your data. If you do that you'll be using Node and NPM \(which seems like you've already been using\). Then you'll bundle you code using Webpack. Once you've done that you'll know all the basics and from there it's just about exploring and building more complex things and learning new libraries and tools as you need them. While you're building it use git to manage your source code. \&gt; I'm already using some features of ES6 and I tried reading in the past "You don't know JS" \- which proved to be a correct title :\) \- but I do have to get a final grip on the language once and for all. I always fear that one of the quirks that I'm not aware of is going to bite me in the ass. You've read you don't know JS and you've been building your own apps. I think you're better then you give yourself credit for. You're well on your way to becoming a good dev. \&gt; Same goes for Node \- I'm using it because of the modules \- but I'm barely familiar with 10&amp;#37; of the concepts behind it. Node is just a JS environment that runs outside of the browser, with some special libraries and the ability to use C\+\+ modules. That's all it is. If you want to learn the various libraries you can read the [docs](https://nodejs.org/docs/latest-v9.x/api/). You can get along fine without knowing any of the built in libraries. It's good to know what libraries are built into Node and what they can do, but there's no rush.
GitLab is the best
A great response to a good question. I like react more as it allows me to keep my abstraction at the language level, which makes it easier to work with for applications with a lot of logic and state mutations/abstractions
Awful suspicious the bit where dude says they messed with the history, making his claims almost entirely impossible to corroborate. Like, you think they're plagiarising your shit and you don't clone their repo so that you always have proof?
I've never met Microsoft?
The UX on the site? Ya, it might be shit. That being said, I use the site for the most basic possible things, the rest I do from my SourceTree client, which's UI is miles ahead.
Fuck.
Tell me frameworks about chat application
From the next major version of AUI \-\- as in, for AUI 7.x and onwards \-\- AUI will be licensed under the [Atlassian Developer Terms16](https://developer.atlassian.com/platform/marketplace/atlassian-developer-terms/). This license replaces the Apache\-2.0 license going forward if you're using AUI to build something that is *NOT* for use within the Atlassian ecosystem, you cannot use AUI 7.x, but *you can continue to use AUI 6.x*. [https://community.developer.atlassian.com/t/the\-license\-for\-aui\-7\-is\-changing/10071](https://community.developer.atlassian.com/t/the-license-for-aui-7-is-changing/10071)
Consider either using integer ratios (create a new class), or integers. If this is insufficient, use a bignum library. Watch out to not exceed the max or min safe integer when performing integer arithmetic in JavaScript.
Yeah it was instantly downvoted after I posted, quite interesting...
Can someone elaborate on why they think this is such a terrible thing? I'm genuinely curious. MS is apparently the largest contributor to github and they are VERY pro open source now. The new CEO has really helped change these around for the company. I'm not 100% pro microsoft, but I can see how this might make sense for them to officially use github as the sole version control option for their suite of developer tools. 
Microsoft VSTS provides all of the stuff you mentioned already. I'm interested to see how they integrate the two.
This is not specific to javascript. It happens in C, C++, C#, Java, python 2, python 3, the list goes on. It has to do with binary and how computers store numbers. Few languages have implemented an adjustment for this but there are a few. Check out http://0.30000000000000004.com sometime, it gives an explanation of this phenomenon. Also of note: 69.99 * 100 !== 6999
I don't know the answer. But original source that you make available to the world to use is a contribution, isn't it? I'll try to do more research to confirm, but I'm under the impression that the license on the code they contribute makes it free for anyone to use. For example, I just looked at the license for Visual Code editor on GitHub and it's MIT license which I think is a very liberal license. You can use that code however you want.
Internal builds
Microsoft only behaves nicely when they really have to.
To me, it doesn't matter. Which ever you pick is going to be a solid choice. They both * Are very intuitive * Very fast * Very well supported I chose React doing from doing *inie minie miny moe*
Microsoft has been a pretty decent company the last five years or so. Personally, I'm excited to see what happens to GitHub in the future. I doubt Microsoft will ruin it. I have been wrong before though... 
I was going to say the same thing. I've been using JIRA for work for a year and a half and I still forget how to make a new issue.
saaaame
as of today, no one have successfully removed the assets from the UI. font can be easily change but not the icons. it isnt clear if this includes the [standard fabric icons(https://developer.microsoft.com/en-us/fabric#/styles/icons) or just the [office brand icons](https://developer.microsoft.com/en-us/fabric#/styles/brand-icons) see comment from fabric team - [here - redditcomment](https://www.reddit.com/r/reactjs/comments/6iri0h/what_do_you_think_about_officeuifabricreact/djawvhh) and [here - github about fonts &amp; icons] (https://github.com/OfficeDev/office-ui-fabric-react/issues/618) 
I dunno, VS Code gives me hope.
That's what they've bought it for. Microsoft cares about Visual Studio Code and its future. GitHub code hosting services don't matter to them.
Fuck
Wow, I would love to work with you.
All good things must come to an end. :(
I like both, but Vue seems to need a lot more boilerplate magic to work right, and requires many more trips back to the api docs to make sure things will work. I feel react is just simpler and more natural.
&gt; while virtuously stating "it‚Äôs money over values" 
They will probably wipe all of the databases migrate to MS sql and windows servers and rewrite whole back in in VB .net.
That is an incredible narrow viewpoint, GitHub is valued at ~$2 billion dollars mostly *because* of the code hosting part, and I'd say that most of the accountants at Microsoft care very little about electron. Of course it likely played a role in the acquisition, but they definitely care about the code hosting service.
The point of the "windows version" (bedrock engine) is literally to be multi- and crossplatform, it's the exact same game on windows 10, mobile, Xbox, and Switch (Sony didn't want Xbox users playing with PS4 users). The marketplace kinda sucks, but Mojang likely would have arrived at that by themselves, most companies get more commercial over time, and it's only on the bedrock edition, it's not available for the Java edition.
Nnnnnnnnooooooooooooooooooooooooooooooooooooo
Does Microsoft own stock in Attlassian or something? How is bitbucket relevant?
‚Äú_Embrace_ open source‚Äù We all know the next step.
IMO a double helix isn't a very complex shape. Each piece is a bar or cylinder shape. Each of those is rotated by an incremental amount about an axis, and moved some amount along that same axis. A quick Google search turns up [this codepen](https://codepen.io/chris-creditdesign/pen/tKmqG).
Vue supports JSX. 
Of course. How did you not know that? 
VS Code is built on top of Electron. &gt; Visual Studio Code is based on Electron, a framework which is used to deploy Node.js applications for the desktop Microsoft would be foolish to let one of their most important offerings 
Nooooooooooooooooooooooooooo
I use Atom mostly. Simply because it has better user\-interface \(for me\)! But when I develop I always think that I'm creating a buggy software! Random crashes and heavy resource usage provide a bad experience. Electron is a lovely evil!
I think learning JS the way you‚Äôve done is a great way to learn it. Developing with vanilla JS before using a framework allows you to learn the fundamentals. Then like others said, you can add on git for version control, then get into a framework like Angular, React or Vue.js. Using these frameworks will also help you learn Node.js build tools.
That's just the reddit hivemind. Gotta go to the deeper subs (or a better site) to avoid it.
Embrace, extend, extinguish. Don't forget.
An additional reason for the acquisition may be that Microsoft has switched to Git for its Windows code. https://arstechnica.com/information-technology/2017/05/90-of-windows-devs-now-using-git-creating-1760-windows-builds-per-day/
They don't make any money off of vscode? Or if they do could you enlighten me how?
You might like gitlab then, since it's got free private repos, but also doesn't have it's ux designed by hamsters.
Their problem was not money, it was being unable to find a CEO iirc. That's kind of a long term problem that an acquisition certainly solves.
:(
It‚Äôs because of the cryptominer they run in the background, that‚Äôs why vscode runs so slowly (sarcasm btw)
Microsoft never bought MSN? It was their product from the start. Messenger was killed because it haemorrhaged users to Skype. Kind of disproves your point entirely since this example shows the software they bought still exists to this day. It wasn‚Äôt murdered. A simple google search shows that it‚Äôs not ‚Äúsimply factual‚Äù.
Its easy to check into this yourself. Look at early forked versions of Rush \(released in 3.1 of the web built tools repository of Microsoft\) and compare them to similar date versions of Lerna \(2.0rc\). Microsoft can't mess with the history of forks. If you do this, you'll see that Microsoft's code is not similar at all. Lerna is written in JS and Microsoft's rush is written in Typescript using inheritance. 'Jamie Builds' is full of shit.
If you really wanna know how we deal with these numerical issues, there is an amazing book called [Numerical Algorithms by Justin Solomon](https://people.csail.mit.edu/jsolomon/share/book/numerical_book.pdf). Chapter 2.1 should clear some things up. A common solution is to compare against some threshold instead of using equality. So, instead of saying `a === b` we say `Math.abs(a - b) &lt;= THRESHOLD`, where `THRESHOLD` is some very small value which fits your needs.
&gt; That the help in vim is so broken within first 3 minutes if you have a different keyboard layout tells a lot of how much they value new users. Yeah except this isn't about being a "new" user?... You essentially just changed the goalposts. First you're bitching about keyboard shortcuts not being intuitive enough, so you ask on reddit for an editor with better shortcuts. Then someone provides you with an option where keyboard shortcuts are required and intuitive, so intuitive that once you have the basic conceptual understanding even if you don't know how to perform a specific task you can (almost) guess/reason about what combination is required since Vim commands is a language in itself like any other programming language. Now you're saying that because flexibility naturally begets complexity and Vim doesn't share keybindings of the other editors (which i remind you, what was your purpose for posting in the first place?) that it's too hard? Do you always learn something on the first try every single time? Furthermore I never denied Vim has a sharp learning curve not that i should need to state it one way or the other as it's quite infamous. In fact i even specifically provided 3 points that are fundamentally required to be understood which are unique to Vim to be able to use it... which you completely ignored? : + alt-9 gives you the output :]]] - means you most likely didn't even look into what i said about what buffers are. Oh and finally you think vim provides no n00b friendly learning docs? Type `vimtutor` in your terminal genius instead of jumping neck deep into the editor which you don't understand, this is not like atom / vscode or any other insert based editor, it operates on an entirely different paradigm.
Microsoft did rank shit in the past, so much so that it became a meme to consider them evil. They were also propped as the anti\-linux for a long time, so there is a big segment of hacker culture that just likes to ignore Microsoft as much as possible. In reality, this is a great idea for Microsoft, and would probably go un\-noticed for years by many Github users outside of the backlash it causes in comment threads like this one.
&gt; I don't think it will be that bad. As a Windows 10 user, I have learned to never underestimate how badly something can get screwed up.
no it is not. the work that dozens, and in some cases, hundreds of people put into these projects is what makes them good. there is plenty of open source shit.
their*
Well I thought that was pretty obvious and went without saying. In no way am I saying all open source projects are equal, and that one project that‚Äôs worked on by 2 people is the same by a huge company a solid team of people working on it and having it open source are the same. 
They're not shuttering GitHub. They have no incentive to alienate the GitHub community. I strongly suspect that the only major difference you'll see is an "a Microsoft Product" logo on the footer. 
I know it sounds cumbersome to write tests for every named function. However, the more experienced you become writing tests, the easier it gets and won't feel like a burden. It's like picking up a new habit - jogging for example. If you're not already enthusiastic about sport or running then starting with it can be exhausting. It just needs time to learn to get better and see the larger benefits. With personal projects I understand, that it's hard to see the benefits because you've written the code all by yourself and nobody else needs to understand it (which tests can help with a lot). Also the quality might not be your biggest concern because you're the only user. However, if you're interested in becoming professional I see no way around testing. You don't have to learn TDD to do testing, but it helps a lot in doing testing right. I learned TDD from 'Uncle Bob' Robert C. Martin's book 'Clean Coding' (the most code examples are in Java, but that shouldn't stop you from understanding it). Just like with most other things in life it takes time to learn it and the only way to learn it is practical application üòâ [Here is a good article about the 3 basic rules to follow.](http://www.butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd) This is how I apply it in projects. 
Not sure much "when they want to" as "when it's in their interest", which is true of most companies. Fortunately in this case, I think their interests are pretty well aligned with the developer community here. It's not that I trust Microsoft, but it's not really in their interest to piss of all the developers. MS knows that if they alienate the GitHub community, it's members are comprised of the people most qualified to create a competitor. 
Not really, all the big open source projects have been moving to Gitlab for a while now. GitHub has spent a lot of time alienating open source through its silly pricing models.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Haha. Well said poetry. I am too unfamiliar with vue right now. May be further down the road.
Obligitory [beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/837t82/who_are_some_of_your_favorite_speakers_educators/dvh0br6/)^3 from Eric Elliott. He may use the popular buzzwords like "composition", but he invents his own personal meaning for them. As for the GoF book, yes it's still the de facto gold standard, and the vast majority of it is still good and relevant today. [The authors once discussed what they would do differently.](http://www.informit.com/articles/article.aspx?p=1404056) They mentioned they would take singleton out and put in some new ones, such as dependency injection. If you're working in JavaScript, you'll have to keep an eye out for patterns that might have a simpler implementations. The decorator pattern, for example, relies on lots of delegation, but since delegation is baked into JavaScript and happens automatically, then a simple `Object.create()` will usually suffice. Or the command pattern, which in JavaScript can often be replaced with just a function, since JavaScript's functions are already callable objects that implicitly store and encapsulate information they need. Also pay attention for patterns that may use a familiar name but have a different implementation, such as the prototype pattern. You've probably heard that JavaScript uses prototypes, and the _concept_ is the same in JavaScript as it is in GoF -- to create new objects based on existing objects -- but the way JavaScript and GoF implement that concept is different. GoF describes _copying_ all the data into the new object to make a fully independent clone, whereas JavaScript creates an empty object that _delegates_ to the original.
Sure JS can be a real pain when you haven't learned it's quirks. (I stayed away from JS for many years because of that :D ) But as you said yourself, you learned JS itself and refined yourself. Isn't that a very positive outcome? (Or did I misunderstand the context?) Sure at first it's really hard to grasp what benefits testing brings. When I first heard about testing I couldn't quite get it. Now I'd be happy if I had learned testing right from the beginning. I had to learn it on the job which was also not as exciting because I was under time pressure. Having the time to learn testing is - in my opinion - better than learning any framework. Because in the professional world testing is a required basic skill. Frameworks can be picked up over a weekend (I generalise drastically here) but understanding fundamental concepts needs time and constant exercise.
Could try using google cloud's api's for text to speech and speech to text.
Just my $0.02 about this: Unlike most comments here (and on Twitter), I'm not concerned about Microsoft "ruining GitHub". They have done a lot of good form the FOSS community in the last 3 to 5 years. My concern is more around centralization of power. This purchase would mean that fewer companies could be making decisions that impact the broader tech community. I rather have many smaller companies controlling many small parts.... Not 4 or 5 companies controlling all the parts. GitHub is a center of gravity in the open source community and had remained an independent (dare I say neutral) entity. But with MS owning them, that neutrality is now at risk.
Yeah, I knew you were closed minded with your first comment, not need to assure it.
Been using Bitbucket heavily for private repos but don‚Äôt like their UX. Three years ago, I‚Äôve made the mistake of creating a generic ‚Äúteam‚Äù for my repos. (Or was it ‚Äúproject?‚Äù I can‚Äôt really tell either apart.) 20 or so of my repos have since been created under that ‚Äúteam‚Äù while others have not, and now my Git remote URLs are inconsistent all over the place. Of course I‚Äôm responsible for all that myself but given that I really hate Bitbucket‚Äôs web interface, I‚Äôm not going to fix it. So it‚Äôs probably going to stay that way for ten more years or so.
Thanks, I guess that is what I should do. I was just lazy and thought maybe there is something I can already use. 
Yikes bro. /me backs out of the room slowly.
I wish I could upvote this more than once. This is gold, pure gold.
Optimism
Yes, you can install dependencies via npm \(although I'm not sure this functionality will pass Apple review\). The app includes a complete Node runtime, so all the usual modules are available \(the only module that won't work is the one for child processes \- iOS app can only run in a single process\).
I found gitea to be the best of the self hosted.
I can't afford to communicate non stop with Google api (since I need to wake the bot when saying a specific word, I need to stream audio input indefinitely) 
It's like they have designers who work out beautiful and intuitive but totally fictional UIs, then that gets thrown to a committee of marketing people who shift around stuff. And then their developers get to work and have to deal with shoehorning reality in that UI. Then they never user test or iterate back with design but instead just release it. That's how their ux comes across to me. 
The app is not open source, sorry. The inspiration for this was another iOS app, [Pythonista](http://omz-software.com/pythonista/) \- an IDE for python. I personally like the idea of having an iPad app that I can use to quickly write and test small code snippets \- for example testing out a particular web API or trying to understand a certain algorithm. And I think JavaScript is a very good language for something like this.
You could try using some other listener as the wakeup catalyst to record audio and then use the cloud for more accurate translations. Maybe you could even refactor what you've already got to faciliate that. This is assuming the speech recognition itself is what's causing you issues.
I'm looking for this wake-up catalyst. I have no idea what to use! And what causing me issue is not the speech recognition but just the fact that it freezes for 3 minutes whenever there is too much noise. So the only solution I find is to debug these libraries
&gt; I know it gets shit for its RAM usage Wait is this real? I use Atom primarily because it feel so much lighter compared to everything else!
Me too. It's part of human nature to make everything sacred. 
How do you go from drag-and-drop ordering of subtasks BACK to individual form-action updates? Like... how? "See this office chair? See how well it moves around with its little wheels? Now make it a toilet. And keep the wheels." -- Atlassian product managers probably
Microsoft is gonna make all the source code paid Indians are in trouble ~~
Thanks one day my England will be good.
It's built on electron, and electron gets shit for RAM issues. Personally not had any trouble. I have a dozen projects open any time and over 50 packages, normally 4 views, average 15 opened files. Sometimes I even run 2-3 atom workspaces at once. I have 16GB RAM. Chrome is a bigger issue for me.
And it‚Äòs surprisingly quick 
Huh, I had no idea! What's considered the most 'lightweight' option if I'm still looking for a full IDE? (Ruling out like, Vim, Notepad++, etc.)
I think VIM is technically a full IDE. I don't really know. My requirements are different. Maybe someone else will chime in but this comment may be too low down the chain.
damn! that was even faster
Does nobody have any privacy isses with Windows 10 but me? From where I sit win 10 is a fucking abomination. 
I stopped at this point: "Oh my god no, no one uses jQuery anymore."
And so, it will turn into suck.
Twist: Microsoft just bought Github specifically so they could remove the clone he made.
That's a really great way to put it. When using things like pug or AngularJS, I've spent way more time in the docs than with React, even though I've probably spent an order of magnitude more time in my professional career using React/JSX than all of those technologies put together. Honestly, I think the only times I've really spent substantial time in the React docs were when I was first learning (first few days) and when the lifecycle hooks change (which isn't a JSX concern).
Why is it baffling? As someone who's worked with a lot of frameworks, I can't think of any reason why React being popular would be "baffling"
If you are a beginner, I would recommend vanilla javascript, HTML and CSS
This sub doesn't like it when I talk about it. I don't see why I'd write it out a 4th time.
I've been running GOGS on my LAN for a while now. It's pretty great.
Got some links?
Best was plain old Office Communicator, before it was lync.
Yeah, well, but your stock\-price example isn't one of them. If your hash function happens to hash both 'DAX' and 'QUAD' to the same value, and your hashtable doesn't handle collisions, then you will have a pretty broken application.
At the very least GDPR alleviates that, Microsoft is not going to risk a wrist slap from the European Union over some user metrics, those fines are brutal and the union have history going after big tech corporations
&gt;: + alt-9 gives you the output :]]] - means you most likely didn't even look into what i said about what buffers are. No, that was just checking that I indeed was pressing the correct keys to write the ]-character. The problem is that I can't find the button combination to follow tags, and it's important for navigating the help. I do know a little bit of vi and have used it for simple editing. I did go through vimtutor just now and picked up a few moves there. Normal more and insert mode separation in vi is a novel idea, but in my opinion, developed through the way of overcoming past limitations, not through exploiting the possibilities we're now presented. One of the biggest problems that I have is that the documentation is of vim is **bad**, and actions that are at most mid-beginner level in other editors require tens of minutes of perusing through documentation. Indentation for 3 spaces (let's say there's OCD or other convenient excuse): ```:help indent``` well, that's useless. ```:help``` ok, I have to use helpgrep. ```:helpgrep indent``` So there's over 1000 matches. This will take a while. ```Cool, `Ctrl-T` and `Ctrl-D` work for indentation in insert mode. Ok! Found a ```shiftwidth``` setting. ```:help shiftwidth```. There's an entry, but the documentation is terrible. It doesn't say what it's for nor where it's used. That documentation is equal to commenting ````x += 3;``` with ```// Increment x by 3``` ```:set shiftwidth``` so it's currently 8. ```:set shiftwidth=3```, after some confusion, find out that it's buffer-specific, but Ctrl-T and Ctrl-D work now. Apparently tabs are automatically inserted for each 8 spaces. ```help tab``` useless. ```helpgrep tab``` 1500+ matches... Hey, there's ```indent.txt```. It's a hot mess to read through. Would have to read good part of the file through to find out if there's anything helpful there. Finally there's ```insert.txt``` which points at ```expandtab```, ```smart tab``` and ```softtabstop```. Now you have to figure out which one to use. vi/vim and emacs feel similar to me - a decades worth of both baggage to carry and old-war -era minefields to dodge through while stumbling from one dead-end feature to another. Vi/vim probably provides the fastest text editing I could hope for, but the situations where my coding has been limited by how fast I can change the text on the screen are rare.
Tons of large OSS projects have already announced plans to move to gitlab and the official announcement isn‚Äôt even out. It‚Äôs not just a meme. You may disagree but it‚Äôs not unreasonable to be concerned about so much power being concentrated in the hands of five companies. 
I don't understand. GitHub is a big, distributed site running Git, i.e. Bash scripts on Linux. Why on earth would Microsoft lay their hands on technology that is totally unrelated to their own?
Someone else who likes elastic tabstops! There are literally dozens of us!
Wow! Are you only concerned, regarding passing app review, about installing npm dependencies after the app is deployed to the App Store, or even if they're installed pre-deployment?
Github Ultimate Edition !!
‚ÄúInie minie miny moe‚Äù part made my day.
What's better about it? GitHub's is easy to use. Do you have a screenshot?
For building any chat application, socket.io (https://socket.io/) is a go-to option. If you want to add a web-based UI to it, serving your files through expressjs (https://expressjs.com/), spife (https://github.com/npm/spife), or nginx.
So this is the target syntax promoted in this blog: var promise = new Promise(function(resolve, reject) { /* Asynchronous code which calls either resolve or reject handler based on execution status */ }) promise.then(function (data) { /* handle success here*/ }, function (error) { /* handle success here*/ }); No mention of `Promise.prototype.catch()` in the entire page. Nothing about chaining promises either. I want to be charitable here, but the author is missing half the point of promises. In this form, promises are arguably *more* confusing than just using callbacks.
&gt; Even when you have just one entry point (which would happen in most single-page applications) it is a very good idea to keep your dependencies in a separate file. I would say quite contrary. The more chunks you have, it's often the better to leave some dependencies with the code that actually needs it, so you only load that 100KB ckeditor or moment on some of the pages. You duplicate some code, but save A TON of time on script download and parsing. I definitely suggest adjusting the `minChunks` setting, so you don't split everything out into a vendors file. Also, don't add code splitting just because you can, it's probably not worth to do it for your 80KB fun project.
Just something I grabbed out of the context: ‚ÄúIf you know about state, and you know you‚Äôve got a big project planned with intertwined local/global state, use React.‚Äù There is vuex for vue project to manage the state.
I reference Vuex in the article and have used it. In my mind, the issue large state management with Vue is not the lack of a library like Vuex; rather it‚Äôs the fact that there are too many escape hatches and ways to leverage the global store improperly. The event bus, $store, direct state mutation, two-way data-bonding... you either add the overhead of reigning in passable bad practices with your team, or you will eventually run into problems. Does that make sense? I‚Äôm essentially arguing that React has no escape hatches from unidirectional data flow. You‚Äôre forced into a safe state cycle.
&gt; he problem is that I can't find the button combination to follow tags, and it's important for navigating the help. Knock yourself out - http://vim.wikia.com/wiki/Browsing_programs_with_tags &gt; Normal more and insert mode separation in vi is a novel idea, but in my opinion, developed through the way of overcoming past limitations, not through exploiting the possibilities we're now presented. That really show's how little you understand. Developed in a hacky way? Sure it did start out as quite a hack. Doesn't cater to the current situation? It's been around for 40 years and hasn't died yet and the reason is it's good at what it does. &gt; One of the biggest problems that I have is that the documentation is of vim is bad, and actions that are at most mid-beginner level in other editors require tens of minutes of perusing through documentation. 1. It's open source, if you think it's bad, change it. 2. And the reason that it only takes tens of minutes for those other editors? Because people are conditioned from the time they start using PC's no matter what OS they're on, that doing anything in text treats inserting as the primary action, this is not the case in Vim, it treats editing/refactoring as the primary action which is what makes it ideal for devs. &gt; vi/vim and emacs feel similar to me I dare you to go to any linux conference and say that. The fact is they operate under completely different principles. emacs is about modifier key combinations i.e. hold keys to change other key actions. Vim is about context modes i.e. visual(select), normal(select via cmds), insert(edit), if you want to perform an action switch into the relevant mode (as stated before 99% of the time its between normal / insert). As a result what normally takes 2-3 operator key combos in any other editor only takes 1 or 2 key *presses* in Vim. Furthermore because they're distinct actions without modifiers it's even easier to apply things like math to them. &gt; Indentation for 3 spaces (let's say there's OCD or other convenient excuse): I'll concede tabs have always been troublesome in Vim even if you had the correct help available. &gt; a decades worth of both baggage to carry and old-war -era minefields to dodge through while stumbling from one dead-end feature to another. So try neovim or some configuration / plugins? As you would with literally any other editor to correct flaws and make things work the way you want? I said from the beginning quote verbatim : *the setup time is significant, but you can make it do anything you can imagine.* &gt; Vi/vim probably provides the fastest text editing I could hope for, but the situations where my coding has been limited by how fast I can change the text on the screen are rare. Then it's your own problem for not learning / implementing Vim well enough... what makes you think you're limited to changing things only on the screen? Furthermore it indicates once again you've missed the point. It's not about how fast you can type, it's about how fast you can jump to the relevant code, select it and make changes to it + have those changes reflected elsewhere in your project. Go, watch, learn : - https://www.youtube.com/watch?v=wlR5gYd6um0 - https://www.youtube.com/watch?v=XA2WjJbmmoM - https://www.youtube.com/watch?v=3TX3kV3TICU
Except that they decided it was more important to use alt gr (or right alt) for shortcuts, forgetting that most of the world use it for special chars(~#{[|`\^@]} can only be typed using alt gr on my keyboard) and it took them 2 years to make a crappy hack that still has bugs in multiples keyboard layouts.
The lerna did mention they messed with the history. And tbh it's not that difficult to convert js to ts.
Agreed on the stubbiness of the code. This is apparently a snippet of a course, where there might be more complete coverage. I would rather see inversion of the learning process, where the default is async/await presented with "use this, trust me. I'm going to show you why shortly." Only after having the user familiar with async/await syntax, start raising the magician's curtain and show how it's Promises behind them. Later reveal another layer that shows that it was those dirty little callbacks doing the actual work behind the set, but you don't really need to see them. Finally show how you can put proper clothing on other callbacks to make them into Promises, which can be used through async/await which is worthy for the developer.
What if it's true? Freaked me a little.
JavaScript has objects. Objects can have properties, e.g. object.propertyName = 100; or object.methodName(). Every object (other than rare exceptions) have another thing called prototype. Prototype of an object is another object. When you access a property of the original object (e.g. when you get a property or call a method), in case that property doesn't exist, it'll look it up on a prototype object, and if that doesn't exist, it'll look it up on the prototype of the prototype and so on, i.e. it will do a look up on the whole prototype chain. Basically prototype works like a fallback: if something isn't found on an object, it will try to find it on the prototype. It could serve a similar purpose as "inheritance" in other OOP languages.
Yea, this is mentioned in this paragraph: &gt;Since our users.js file takes a lot less space than 30Kb, it would not be bundled into a separate file without changing the minSize property. In the real-world situation, this is a good thing, because this wouldn‚Äôt give us any real performance boost and would force the browser to make an additional request for the utilities.js file which is very small right now. Cheers!
A Boolean constant is not that useful, as we already have the only boolean constants we need, true and false. Boolean variables are wonderful sentry variables for while loops. keepGoing = true; while (keepGoing){ // code here if ( &lt;some condition is true&gt; ){ keepGoing = false; } } You can use this for a loop with multiple exit conditions, which is often much easier to debug than a while loop with a complex boolean condition.
Don't ever use it.
great thanks, that's what I was thinking for my next position
Here is another user asking similar question: [Vue.js or React ? Which you would chose and why?](https://www.reddit.com/r/javascript/comments/8o781t/vuejs_or_react_which_you_would_chose_and_why/e01qn55) they got some good karma on [Twitter](https://twitter.com/youyuxi/status/1003366017840631809). It is a nice response. What is incomplete everywhere and what what makes all the difference in the end is: 1. COMPONENT NESTING: Being able to nest components as easily as we nest tags in HTML DOM, and being able to give small and large components a good home with good documentation. Those little peccadillos that Angular, react and Vue has us making is bad. Maybe WebComponents will workout somehow down the road. 2. AUTOMATIC DATABASE SYNC: being able to forget that state is saved and it all just works. So automatic database synchronization, automatic table or object creation. And a good database, with good update feed. Something like CouchDB in JS, with beautiful UI, or maybe SQL like database that uses a tidy JS \(maybe lodash\) for queries, or maybe just SQL lang, DSLs aren't always bad. But that data has to be QUICKLY and UNHACKABLY and SCALABLY delivered into your application state over web sockets, done and done. 3.FREEDOM: Mobile, Desktop, Web. This means these components and maybe even databases can live happily on server, in app, and desktop. CouchDB/PouchDB shows the way, sqlite shines the light but, we are not there yet. Before I go, I wanted to mention [https://mobx.js.org/](https://mobx.js.org/) and leave you with [awesome\-react](https://github.com/enaqx/awesome-react) clarifying that the answer to your question is not so much a specific choice but the understanding that, it is a journey in time: [Angular](https://github.com/gdi2290/awesome-angular) \-\&gt; [React](https://github.com/enaqx/awesome-react) \-\&gt; [Vue](https://github.com/vuejs/awesome-vue) \-\&gt; Onwards to whatever is following standards in 2020 \- 202\* stay on the main road, keep an eye on what has [most stars on GitHub](https://github.com/search?l=JavaScript&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/vuejs/awesome-vue) - Previous text "Vue" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e033da3) 
For casting, when you derive the variable from some imported data you do not control and want to make sure it's not undefined or an empty string. Especially if you'll get an error otherwise - there are a few APIs that would throw an error if you don't pass an actual Boolean In the example above there is no need, `x &gt; y` is a boolean primitive, you do not gain anything by turning it into a boolean object
well duh...
* Every object in javascript can have a reference to another type of object. * We call this object that is referenced the prototype. * Think of it like a tree. Every twig has a branch that it stems from, every branch has a trunk.. We call this list of references the prototype chain. * When you're looking for a property or method on an object, it (the javascript engine) checks the object first, then goes up the chain towards the trunk looking for that property/method. This method of looking up the chain is prototypical inheritance in JavaScript. More: * Once the JavaScript engine finds a method or property it will stop looking up the prototype chain. Thus if your object has the same property as the prototype, the object will be referenced. This is called property shadowing. I have no tree analogy for this. ¬Ø\\_(„ÉÑ)_/¬Ø * You can't have a twig stemming from two branches, just as you can't have an object with more than one prototype. * You can simulate multiple-inheritance by arranging multiple links of the prototype chain. * You can have objects without prototypes, this is like snapping a twig off the tree. It has nowhere else to look if the property/method is not found. * You can change the prototype of an object. This is like grafting. * Classes in JavaScript are a shortcut to construct a prototype for an object.
[removed]
give me a framework I've asked for for each type of the apps you've listed
``` let truthyThings = someArray.filter(Boolean) ```
OP is not talking about variables, he is specifically talking about the `Boolean` constructor.
I can understand the backlash but as usual most of those Slashdot comments are hilariously out of touch with what I expect to be the majority of people. ‚Äúgit really doesn't need a hub‚Äù - well no shit, apps don‚Äôt need a store but it‚Äôs sure a lot easier for people to find and use your software when it‚Äôs hosted in a known, reliable central repository. 
Ah yes, the typical measured and reasoned response of the open source community.
Yeah, I was just reflecting on the initial claim.
There was a good reason for that.
Yep. I definitely agree that inversion is a superior form of teaching. It's the way I usually introduce programming concepts to others. What I'm cranky about here is that promises offer two powerful things: taming asynchronicity and using chaining to *compose* flow control. Not only do they ignore the second part, they introduce a syntax... promise.then(function () {}, function () {}) ...that actively limits the second part as well. I mean, if that was our starting point, what would we make of this code? a() .catch(b) .then(c) The syntax they are teaching is literally the last thing I would teach and, even then, it would be solely for the sake of completion. I feel it is the modern equivalent of... const add = new Function('a', 'b', 'return a + b'); add(1, 2); // returns 3 ...in that it is valid code, it definitely belongs in reference manuals, and it is counterproductive to show to newcomers. Sorry. Rant over. 
Oh, Microsoft ain't no stranger. 
I've only seen it in Modernizr's video and audio format support detection. So bascially, Modernizr detects first if the browser has support for MediaElement.canPlayType (detect if &lt;video&gt; and &lt;audio&gt; tags are supported at all), then constructs an Boolean object based on that result. To the constructed Boolean object, Modernizr adds more properties (boolean values) detecting if the browser supports specific video formats and codecs. Again, I agree with the other's in that one should not need the Boolean object explicitly.
[removed]
Thats why I was looking at early forks...those are repositories that aren't under Microsoft's control...unless you mean to imply that Microsoft was able to contact 60\+ random github members and convince them all to make shady changes to the git history? \&gt; And tbh it's not that difficult to convert js to ts. Its can be pretty difficult to convert to using inheritance hierarchies if the original code didn't plan for them. Even language aside, the code is very different.
I had written [a little something](https://medium.com/webmonkeys/properly-using-bind-in-react-2e5c7e62bdb8#c068) about this very topic. I hope it can help you even a little
gl hf
What the fuck does this have to do with GitHub?
Damn, and I was writting `const identity = x =&gt; x;` helper all this time‚Ä¶
Thanks for the great answer (and the really helpful analogy) &amp;mdash; could you just help me with a few things I need to wrap my head tighter around? &gt;You can simulate multiple inheritance by arranging multiple links of the prototype chain Ca you elaborate on this? Is this like Object.prototype.methodName.prototype = Function, OR like Object1 -&gt; Object2 -&gt; Object3, &amp;there4; Object3.prototype = Object2 &amp; Object2.prototype?= Object1? &gt; You can have objects without prototypes How? Also, example? &gt; You can change the prototype of an object i thought that was impossible? How do you that, is it like window.a = Object1.property1; Object2.a = window.a; delete window.a;//Now property1's prototype is Object2? Thanks!
nothing. just catch your attention 
The hackability of Atom is far superior to VSCode. VSCode is a lot more limited in what it offers in regards to the JS API as well as styling the entire editor itself :\(
Is it because 7 8 9?
Best way to learn a technology/framework/library is to start using it every day. "But how, since I'm lacking persistence?" \- you can ask. Well, persuade your CTO to embrace these into by your project. If that can't happen, find a job that would require you using these on a daily basis. That work, I'm telling you from my experience.
I'm not sure if you're doing this on mobile or not but just so you know, I tried something similar on mobile just over a year ago, intending to build a web application that would allow users to use GPS-like features through voice comms (as a proof of concept more than anything). What I discovered is that it's possible to hold open the mic for up to 10 seconds (using the build in voice recognition API's in Chrome) after which it will close, and you can reopen it again. However, this requires the app to be the foreground/active app and the UX is very tricky to get right. The upside is that it won't submit the speech to Google (and thus use resources) until it actually detects speech, but again, it's very difficult to get right. I'll take a look and see if I still have the code from that experiment when I'm home from work.
And is still buried deep into the OS, and will never be made available for Mac or Linux. 
Single Page Application; - Use node with express, or nginx to serve your files - Build your web interface/front end in react, angular, vue, or any other framework Chat platform; - Use node with socket.io, and optionally express or nginx to serve your files - Add a web interface/front end built in react, angular or vue API Platform; - Use node with express (or any HTTP server), with a DB such as MongoDB or MySQL to serve data from
It wasn't a good reason, it was the worst of reasons.
Yes
It wasn't their fault though. It was lazy web developers.
So... SPAM only?
Look at [https://github.com/graphql/express\-graphql](https://github.com/graphql/express-graphql) and the [https://graphql.github.io/swapi\-graphql/](https://graphql.github.io/swapi-graphql/) tool as well. I am sure I don't have to mention [Relay](https://facebook.github.io/relay/docs/en/introduction-to-relay.html) by Facebook, but all together it looks very good. I am thinking about making a one page Stripe store, for just a single category of products shown in pretty Bootstrap Cards. And I want it to have as little programming as possible. It looks like [express\-graphql](https://github.com/graphql/express-graphql) will take care of all my data needs. I hope this helps some of you with getting UI automatically tied to DB and other state needs.
&gt;&gt;The problem is that I can't find the button combination to follow tags, and it's important for navigating the help. The problem actually is that I can't find it on my keyboard. I've tried dozens of key combinations and they don't work, because it expects default key layout. Sure enough, if I changed my layout from Finnish to english, it probably would work, but that bug has been present for over 10 years and help without it is quite unusable. Point on the modes was that vi feels like it's built around it, instead of building it as a feature. emacs/vi comparisons were how frustrated I became when I try to have quick setup for my own, mostly due to historical fragmentation. It's been a while since I tried to set up vi/vim, but emacs had the: default js mode is appalling -&gt; try to find configs to make it suck less -&gt; find out there's better mode -&gt; need to install it with emacs' extension manager -&gt; emacs needs upgrading for extension manager to work -&gt; download newer emacs -&gt; get the new javascript mode -&gt; new js mode is better, but still isn't good. Vi feels like it really requires the legwork to figure out what settings are good and what are old, what additional code to use, needing to experience what doesn't work properly, researching it and fixing it. Maybe I have to look at some good examples on how people effectively use it. The few examples I've watched from the side were impressive and might've wooed me 3 years ago, but now I need to see something new. My workflow is far from perfect so I'll check the videos for new tricks.
I hate how right you are
Regarding APIs, Express is not the fastest. In Express's performance tier, I prefer Hapi. If speed is really you're only goal, Fastify and Polka claim higher performance.
&gt; You can simulate multiple inheritance by arranging multiple links of the prototype chain.. IIRC, (I don't usually like working with classes), something like: ES5 Style: function A() { /*... */ } function B() { /*... */ } function C() { /*... */ } A.prototype = { /* stuff */ }; B.prototype = Object.create(A.prototype, { /* B stuff */} ); B.prototype.constructor = B; C.prototype = Object.create(B.prototype, { /* C stuff */} ); C.prototype.constructor = C; ES6+ Style: class A { / *... */ } class B extends A { / *... */ } class C extends B { / *... */ } Basically, you can't (AFAIK) do class A { / *... */ } class B { / *... */ } class C extends B extends A{ / *... */ } //or class C extends(A, B) or other things like that. --- &gt; You can have objects without prototypes At this point it becomes simply a hashtable. You don't usually see this in the normal world. Most of the time in areas where you need to optimize, like games. const noProto = Object.create(null, {}); const anotherNoProto = Object.setPrototypeOf({}, null); // ES6+ only // or modifying an object const banana = {}; Object.setPrototypeOf(banana, null); --- &gt; You can change the prototype of an object Well, a caveat. in &lt;= ES5 you can't _really_ change the prototype in a universal manner. This will work, but not on IE IIRC; the __proto__ property isn't standard. ES5: const burrito = new Food(); const taco = new Food(); taco.__proto__ = burrito; ES6+: const burrito = new Food(); const taco = new Food(); Object.setPrototypeOf(taco, burrito); 
Testing is a very positive and necessary thing. I'm a tester myself. Making this lengthy for poster, not debating. In general, you and I would probably be much on the same page. The way he wrote his post though about bigger and bigger apps implied to me that he was already on a time crunch/getting overwhelmed and so needed to learn fast and get into tools techniques that could get that under control. He implied more of a need for a buildchain and things to help him wrangle his code. I feel he would be better served learning tests at a later stage. I remembered how difficult getting tests themselves right can be when learning (eliminating logic errors, +1 errors, false positives from a testing frameworks limitations, knowing when a unit test has bled over to an integration or e2e test, what's a good ratio of ut, int, and e2e, how best to keep the suite from growing out of control/scoping, mocks, etc.) all before the tests themselves have solid value for joe blow programmer. If he's just learning and has the time then testing may be ok, but I'd still say only if it doesn't decrease his love of learning it. That, to me, has always been most important in my progress. Love for it, curiosity, fun. Programming apps and programming a test suite appear to be two very different beasts to me now. I feel they should focus on getting the code under control and catching up to more learned peers, then do a deep dive into testing his own code. Unless these programs are being made prod ready/hardened, then he will have to anyway unless corp, then there will likely be a dedicated testing team that will come in. 
Then check out Apollo and Amazon appsync.
Holy shit, you learn something new everyday! I think I should look at Object properties and methods now... &amp;nbsp; Okay, last question, I swear: Can you create an infinite loop by setting A's prototype to B and B's to A? &amp;nbsp; Thanks!
I'm going to jump on this train to have a few examples :\) So let's say in plain old JS in 2008, we wanted to make a class \- here's how we did it: function MyClass\(\) { return this; } var instance = new MyClass\(\); Not too bad, right? Now, what if we wanted to add a function to this? Well, we could just make it hang off \`this\`: function MyClass\(\) { this.myFunction = function\(\) { console.log\('Hello, world!'\); } return this; } var instance = new MyClass\(\); instance.myFunction\(\); Seems like the right thing, but there's a problem. Every time you run \`new MyClass\(\)\`, it's creating brand new functions, and that eats up memory \- \_there must be a better way!\_ Prototypes are a way for javascript to re\-use functions and structure across multiple instances, and they let you do some neat things, too. So this is what the prototyped version looks like: function MyClass\(\) { return this; } MyClass.prototype.myFunction = function\(\) { console.log\('Hello, world!'\); } var instance = new MyClass\(\); instance.myFunction\(\); \`.prototype\` is a JS language feature, which means it's built in, and works everywhere. So what sort of neat things can you to with prototypes? \- Makes mocking some types easier for tests \- change a prototype function, and it changes for all instances of that type \- Less memory, functions only get created once. \- It's standard \- you're using JS in the way it was intended \(usually\)
Software, you mean.
No, developers. 
It‚Äôs confirmed now. https://tcrn.ch/2J9SSAD
Haven't heard of web developers making a check on Windows version starting by 9? I mean, it's not all different to user agent checks, but that's another thing.
Hi /u/Ho-Wan, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/kkokane, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/rukkro, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/ThePhamouzNobody, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/WishingPond123, For javascript help, please visit /r/LearnJavascript. Thank you!
Are you also a fan of PHP? I Strongly believe that presentation should be decoupled, minimal and dumb, not mixed with code.
most of the unicode space is garbage and rarely used characters that noone can type in, so if you want to generate them yourself perhaps stick to ascii or some range you know the user can type. I recommend using something like this: https://www.npmjs.com/package/bip39 Also for your code: do not use Math.random to generate passwords ever!! I hope you realize those will be insecure. 
Timely.
I don't think so. At best you could create a circular reference, but since you can't do multiple-things simultaneously, setting A's to B and B's to A would mean (ES6+): //given A and B const protoA = Object.getPrototypeOf(A); const protoB = Object.getPrototypeOf(B); Object.setPrototypeOf(A, B.prototype); // A's prototype is set to B's Object.setPrototypeOf(B, A.prototype); // B's prototype is set to A's, which is B's, so nothing changes. A.prototype === B.prototype; // true A.prototype === protoB; // true B.prototype === protoB; // true Now, you could swap them if you wanted to: //given A and B const protoA = Object.getPrototypeOf(A); const protoB = Object.getPrototypeOf(B); Object.setPrototypeOf(A, protoB); Object.setPrototypeOf(B, protoA); 
All software you run could run a cryptominer in the background. Easily detectable using something like wireshark though
Being a crybaby about some fake internet points is going to get you downvoted way faster than anything else
Glad you found it useful! Also added an ‚Äúexplainer‚Äù video for that type checking code, thanks to the feedback I got from two people, on /r/node Better type detection in JavaScript https://youtu.be/nL3iGyPiLHw /ht /u/MrStLouis &amp; /u/NuclearSpaceHeater 
Here's a sneak peek of /r/node using the [top posts](https://np.reddit.com/r/node/top/?sort=top&amp;t=year) of the year! \#1: [When you run out of disk space](https://i.redd.it/t5y8zb1kosm01.png) | [56 comments](https://np.reddit.com/r/node/comments/85nlo8/when_you_run_out_of_disk_space/) \#2: [Netflix migrating 1/2 of their api to node.js](https://youtu.be/QcNqfvMeWow?t=5m3s) | [76 comments](https://np.reddit.com/r/node/comments/8i8jzq/netflix_migrating_12_of_their_api_to_nodejs/) \#3: [Node.js Cheatsheet - Everything you should know in one single file](https://github.com/LeCoupa/awesome-cheatsheets/blob/master/backend/node.js) | [41 comments](https://np.reddit.com/r/node/comments/7v0rn7/nodejs_cheatsheet_everything_you_should_know_in/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [LeCoupa/awesome-cheatsheets/.../**node.js** (master ‚Üí 6dc05a7)](https://github.com/LeCoupa/awesome-cheatsheets/blob/6dc05a7733854a73cffd416e7c2ec921561ab06a/backend/node.js) ---- 
Probably by having to rewrite shit into the new UI and then first developing an MVP which does the job with the intention of some time upgrading back to the drag and drop. But then never getting priority on the drag and drop because "it works, right?".
Thankuh for the info.
&gt; Slow Right? We used the cloud offering for a while and for some reason they put our instance in singapore. Our company was based in the Netherlands... Just pinging the instance was about 300 to 500 ms. Then we had to deal woth the slow as fuck UI as well... We moved to self-hosted gitlab, couldn't be happier.
The only immediate benefit that I can see of doing this over templates or JSX is that it doesn't require a build step, since it's just JavaScript. Other than that, it seems \(at the least\) rather annoying to work with, by comparison. 
You run a completely open system, hardware and software? Get off your high horse
They also have no incentive to make every UI in all of their products complete shit, but they are. Microsoft is awful at UI/UX, possibly because they, as a company, do not prioritize it. They might not *intend* to ruin Github, but that doesn't mean it won't happen
So... you've used JS for 5 years and don't know about the prototype chain? I blame jQuery and Angular for this! /s
Creating a directive like `v-if` is mixing code with presentation. If you want presentation that depends on logic, you cannot get away from it. You can only dress up the logic as HTML and pretend it's not code. It's still code. And I'd rather read JS than a DSL someone invented and that competes with dozens of other DSLs for popularity. 
What would that look like compared to my examples above? It's not the JSX that I'm so in love with. Per my post, it's that JS is my templating language. If Vue supports JSX *and* supports using JS as the templating language, then it's super similar to React if you use it that way, isn't it?
yes absolutely.
webpack, electron, React, **node.js**, npm, yarn, VSCode, babel, rollup are all on Github. Which "big open source" projects are you referring to?
And now you've been upvoted quite into the positive. I wouldn't be paranoid about who it is. It's just normal Reddit. Trying to understand what gets upvotes and what gets downvotes will drive you made.
That creates a vector for infection. You don't just post links willy nilly.
Every little piece of code that Microsoft bought in the last years became a nightmare. Now Github is about to follow the same path.
I personally prefer it when casting for \_readability\_. Eg, \`hasTitle = !!user.title\` vs \`hasTitle = Boolean\(user.title\)\`
Jesus people love to bring this up, even though it's an old MS way of doing things. Edge is ripping out standards compliant features like it's their job and yet people STILL talking like this is all some elaborate plan.
Play Java on PC you peasant. 
Why don‚Äôt you guys just use a Jetbrains product. I know it‚Äôs a paid product but they make the best editors. I‚Äôve used Atom and VsCode and while I really like VSCode‚Äôs interface, nothing beats a full IDE like Webstorm. There are so many things that works out of the box with Webstorm not to mention features that WS offers that neither Atom nor VSCode offers. 
kenman I don't understand. What just happened here? Was my post moved to the /r/learnjavascript sub reddit?
Their new CEO really helped lift MS from the ashes that idiot Steve Balmer left when he burned MS to the ground 
Do you by any chance have a background in matrices
Fuck off
Promises are no longer new or novel. Please post tutorial-style topics to /r/LearnJavascript. Thank you.
Yeah.... I used JIRA at my last company and liked it. Now I use VersionOne and really, really, really prefer JIRA now.
Why from a textbook? I've found that something like https://www.freecodecamp.org/ where you immediately have to type in the code to solve a problem is a much faster way to commit this stuff to memory. Use something over and over and you're bound to learn it faster.
Not sure what your list of requirements to be a 'Full IDE' is, but Sublime Text is at the top of my list. I used it full time and had it customized into a pretty capable dev environment until switching to VS Code full time about 3 months ago. 
I think as a paid user you can use private packages. [https://docs.npmjs.com/private\-modules/intro](https://docs.npmjs.com/private-modules/intro)
Yes, using npm link to connect them locally. I‚Äòd also suggest to take a look at Lerna.
try gitlab
You might be interested in this [kill sticky headers bookmarklet](https://alisdair.mcdiarmid.org/kill-sticky-headers/). I have it on my phone too, and probably use it 15 times a day.
How about this? [https://stackoverflow.com/questions/17509669/how\-to\-install\-an\-npm\-package\-from\-github\-directly](https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly)
I keep saying this and people dont believe me. They did it with Java when they created C#. They markedly fucked the development speed of JS. They do good and bad in waves.
MS's internal culture would allow for that.
Because blockchain tech is already almost 30 years old. Someone took it, turned it into money, and now everyone and their mother is salivating over it. Blockchain isn't really tech, that's the problem. It's a blob, that when mathematically decoded, makes assertions about the signer, and in the case of bitcoin, about some of those blocks that came before. Seriously, this is basically PGP. The security of the Web (TLS) is basically the fundamental basis of "blockchain". Storj is a decent technology that uses "blockchain" to provide proof of work around storage. That's cool. Ethereum is the same, but around CPU work. Everyone else? Not so much "techology" but bandwagon riding to try and be the next Bitcoin. 
That's what Vuex is for
You are a very helpful bunch. Thanks.
No I didn't. Javascript's had a great run, sure. It's still a shitty language. 
This is a fantastic source to learn from but you will definitely need to do some research while doing these exercises. 
I‚Äôll use freecodecamp if i need targeted practice. It just didnt work for me as an entry learning resource. Maybe I am biased towards books, but id really love to know why there really arent any js textbooks with lots of practice problems like we have with Java and C. 
Be careful with your use of `Boolean` here. There are boolean primitives, and Boolean objects. You get objects using `new Boolean()` and primitives come from just about everything else (`true` and `false`, comparisons with `&gt;`, `&lt;`, etc.) as well as `Boolean` used as a conversion function which is what you're doing in your example. Boolean objects you generally want to avoid. Unlike their primitive counterparts, they do not equal each other in a comparison, just like with other objects. true == true //-&gt; true new Boolean(true) == new Boolean(true) //-&gt; false Objects can be compared with primitives correctly only if not using identity comparison. Identity (or strict) equality will call new Boolean(true) == true //-&gt; true new Boolean(true) === true //-&gt; false You'll also find differences in how you type check these values. Boolean objects can be checked using `instanceof` with the `Boolean` type while boolean primitives return 'boolean' from `typeof`. new Boolean(true) instanceof Boolean //-&gt; true typeof new Boolean(true) //-&gt; ''object' true instanceof Boolean //-&gt; false typeof true //-&gt; 'boolean' Because you're generally working with primitives, you'll want to try to stick to using primitives to prevent these differences from causing issues or complicating your code. If you have a truthy or falsy value you want to explicitly convert to a boolean value, you can use the conversion function which is `Boolean` without the `new`. This will return the primitive `true` or `false` representation of that value. Boolean(1) === true //-&gt; true Boolean('') === false //-&gt; true typeof Boolean(true) //-&gt; 'boolean' Boolean(true) instanceof Boolean //-&gt; false Some comparison operations don't require this conversion. In your example, you're comparing `x &gt; y` which will already result in a boolean primitive, so no conversion is necessary. But that might not always be the case, at which point you might want to use the conversion function. typeof (x &gt; y) //-&gt; 'boolean' typeof x //-&gt; 'number' typeof Boolean(x) //-&gt; 'boolean' Note that there's also an `Object` conversion function. If used on a boolean primitive, it will return a Boolean object. typeof Object(true) //-&gt; 'object' Object(true) instanceof Boolean //-&gt; true Often times, nowadays, you'll see double negation used in place of the Boolean conversion function. It can be a little more confusing (double negatives) but it is less verbose which can tighten up your code. const truthy = 'string' const falsy = '' !!truthy //-&gt; true !!falsy //-&gt; false
What? No In terms of total time spent coding JavaScript or *any* kind of webdev, I'd be about-a-few-months to really-less-than-a-year, at the maxMAX^(maxMAX). I was saying, "assume I have as much knowledge in JavaScript, as a five-year-old does in terraforming". Also, I neglected to learn jQuery for some reason (turned out to be a *good* thing, ha, take that, Lady Misfortune! &amp;mdash;&amp;mdash; wait, am I supposed to be thanking Lady Fortune here? Whatever) and I've resolved to *never* even *look* at Angular or Express *unless* I'm proficient in using vanilla Node.js, and it becomes repetition and not dryness that draws me towards frameworks of *any* kind.
I interviewed with Venmo a few years back which is now owned by Paypal. Not exactly what you're looking for but maybe it'll help. This was for a full stack position. One hour was spent on a pair programming code review. Just corrected some mistakes like "this" context, replacing failed callbacks with promises, etc. Then an hour of system design which consisted of designing how Venmo would store user data and transfer money securely. Then some process and behavioural questions (agile/scrum, teamwork, etc.). 
Get ready to pay extra for extra premium features once Microsoft gets hold of GitHub.
I do, but my friends can't afford PCs. :(
Or functional programming
This is only experimental so I don't actually care if the end user is able to type them afterwards. I want a full range of valid UNICODE characters \(special symbols, emojis, chinese characters, etc..\) and not only \&lt;33, 126\&gt; for valid ASCII characters. Why is Math.random bad for generating passwords?
This helped, thanks. That bit about binding functions using up memory? TIL. I didn't even *think* to think about it. So basically, prototype inheritance is looking up the prototype chain, and prototype is like the members of an object instance's "class" (by which I mean prototype). Thanks! 
Lerna + yarn workspaces is a great combination. Really helps to keep your packages to a more manageable size. 
What's the point of those, though? I played with some ways of creating circulars in my console, and not a *single* ***one*** of them crashed the engine. Why?!
Mojang really is working towards a "single platform" solution. But for all the silly comments here, Microsoft doesn't have much to do with it. Jeb was at Mojang before Microsoft, and he runs the creative side of Minecraft almost entirely. So it's not MS doing anything, it's still largely directed by Mojang employees.
No way. Please some confirm?
Right, clean explanation, thanks, I'm feeling very grateful!
Fair enough that you prefer textbooks. Sounds like a business opportunity if there really aren't any!
üòÇüòÇ
Reported for self promotion 
In the global context (outside of any function), `this` is the global object. In a browser, that would be `window`. Inside a function, the value of `this` depends on how the function was called. For simple calls like... function a() { console.log(this); } a(); // returns window ... it also depends on whether the code is in strict mode (in which case `this` will retain whatever value it had when the function was called) or not (in which case it will default to the global object). If the function is called as a method of an object, then `this` will be the object through which the function was called: function a() { return this; } let b = { myMethod: a }; // Note we're calling the same function twice, really, but // the value of this changes because of how the function // is called. a(); // returns window b.myMethod(); // returns b You may set the value of `this` explicitly by using `call` or `apply` (these are methods of the `Function` prototype): function a() { return this; } a.call("hello"); // returns "hello" And you may use `bind` to create a new function that calls another function always with a set value for `this`: function a() { return this; } let b = a.bind("hola"); a(); // returns window b(); // returns "hola" There are a few more subtleties (with arrow functions, for instance). See [`this` on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) for all the gory details.
Thanks, that helped. It was actually in the `npm install` docs. Easier than I thought. You can just point directly to any github repo that has a `package.json`.
NOTICE this. The majority of comments here are expressing dissatisfaction on this and almost all are down voted. That means people who did not comment are in majority to people who commented and have *different* opinion on subject. Microsoft dont do this, dont send your peeps here.
Everything. 
It‚Äôs confirmed now 
You can't do that. That would create a significant security problem. If the files are selected via file inputs, then you can read their contents via blob api. 
But it's open source, so Microsoft can't do that much harm.
This also helps. I didn't know you could do it with a local folder. I also just discovered you can use `npm install` with a folder name, as long as the folder contains a `package.json`. What's the use case for `npm link`? I couldn't understand when you would want to use it from reading the docs. Seems like you would use it mostly for getting a local folder into your globally installed node modules?
Ade you aware of Wunderlist? Microsoft acquired them now its a totally unusable product. 
With Vuex you still have to jump from template to js and back, with React you keep all that logic at the language level 
Who else did Microsoft acquire this year? 
JavaScript and JQuery: Interactive Front-End Web Development By Jon Duckett 
For a js job site it could use some UI fixes
Just being clear about what incentives do
They could relicense it or have github devs only contribute to a private fork for use with vscode and skype.
There is PMs
to be fair they got bought out and the new owners quickly got rid of that junk
RemotelyShit.
Check this one out. [https://eloquentjavascript.net/](https://eloquentjavascript.net/) It has different exercises at the end of every chapter as well as "Project" chapters. Really good if you not only want to learn stuff, but also practice it.
 lacks end of chapter problems.
&gt; https://eloquentjavascript.net/ Thanks. I wish it had more problems per chapter that span a wider difficulty range. I'll see if it helps me. 
AFAIK there's no contributor agreements for electron so they'd have to get every contributor to agree to a relicense or retlwrite a bunch of shit.
For challenges I suggest combining this \(or any other book\) with websites like [https://www.hackerrank.com/](https://www.hackerrank.com/) My opinion is that the challenges you want are for getting problem solving skills and most of these challenges are thought in the first programming language you learn \(usually in high schools/universities its either C or Java\). JavaScript is when you know how to solve problems and just need more tools to create products/projects.
That's not what extend means and it's not giving them control over anything outside of github's projects.
What did they do with Java when they created C#? 
They don't have much of an incentive to make their UI great in most circumstances because both in the corporate and consumer worlds they have such a lock-in on the OS and office product markets and neither grandma nor Bill from accounting disliking the UI is going to result in them moving to another OS our Office suite for a host of reasons. If it doesn't affect their bottom line, there's little incentive to improve. With GitHub, however, we're talking about a perform that is filled with technically savvy people, most of whom are perfectly happy to switch to another service if the the current one doesn't meet their needs. In addition, it only takes a few cli commands to move to a new service (for the vast majority of projects anyway). Between Gitlab and Bitbucket there are 2 viable exit for the majority of projects. Sure, they don't offer all the features or community scale that GitHub currently does, but a horrible GitHub experience will leave a void in the market the that can and will be quickly filled. I don't know that MS has ever had more incentive to make a product their users love. I'm not saying that they won't screw things up over time, causing a gradual decline, but so many people running around with their hair on fire like MS is going to burn it down tomorrow, and that's just not likely to happen. 
I created a 3D Game of Life (Cellular Automata) in javascript using three.js, it can be found here: http://www.howanto.com/comp/3dca.html Code can be found on my Github: https://github.com/Ho-Wan/howanto.com
Mostly doing local development of a dependency for a project, and testing your WIP-version if the dependency in that project. So if you are working on `foo` and want to test the new changes in `bar` you can use `npm link` to symlink them together correctly without changing the `package.json` in `bar` at all. 
Just wanted to drop the links for others reading your comment: Apollo [https://github.com/apollographql/apollo\-server](https://github.com/apollographql/apollo-server) Amazon appsync \(incl Apollo examples\) [https://github.com/serverless/serverless\-graphql](https://github.com/serverless/serverless-graphql), [AWS appsync pricing](https://aws.amazon.com/appsync/pricing/).
I also prefer textbooks with end-of-chapter exercises, but I'm not aware of any for JS. 
I'm not sure you're getting what you think you're getting. Are you trying to do a sort of pick? Because right now all you're doing is returning `this.otherService.otherForm.model` from `get model()`. Destructuring doesn't make an object; it puts variables in the current local scope from properties of an object. The result of the expression (if not destructuring in a declaration) is the object on the right hand side of the assignment. const orig = { firstName: 'joe' } orig === ({ firstName } = orig) //-&gt; true There really isn't any pick syntax in JavaScript (though some [proposals](https://github.com/rtm/js-pick-notation) exist). Generally people stick to something like [lodash](https://lodash.com/docs/4.17.10#pick) or the more verbose approach with object literals (which may include a step of destructuring)
And the fact that people like me will never go back is a lesson on poisoning a brand. 
Hey /r/javascript ‚Äì I've been working on a Bitcoin library written in TypeScript, and I just released the first production\-ready feature: a WebAssembly version of Secp256k1, the digital signature and verification system used by most cryptocurrencies. You can find more details and benchmarks at the link. If you're interested, please watch/star the [`bitcoin-ts` project on GitHub](https://github.com/bitjson/bitcoin-ts). I'm also happy to answer questions here. Thanks!
switch cases don't have their own scope, so you can't re-declare `para` in each case. You'd have to declare `let para` above the switch.
As a Windows 10 user, I have no fucking clue what you just meant.
I meant I prefered it purely due to personal preference, I wasnt try to say one was better than the other. I dont use githubs PR very often but I dont think I remember them being wildly different, in fact I believe github has more features on a PR so I dont know why the bitbucket one appeals to daily. Daily use I suppose? On mobile so youll have to google it for a screenshot I'm afraid.
Its definitely forked....
Just use if else if even if. You'll never know you need it from the start.
Right? Microsoft is for-profit corporation. They do not work for free, and they do not let others profit in ‚Äútheir‚Äù market. There couldn‚Äôt possibly be any strategy in their good-hearted business decisions.
https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish
Imagine you open a random webpage and your entire hard drive is read by some js and uploaded to shadyWebsite.com. Browsers don't let javascript do stuff like that. You can spin up a simple server with node and use it as a proxy to get whatever file you want.
So I guess it'll mess up if I run it in a loop. Since I need to create elements.. Hmm.. I guess i'll just use if. Thanks :\)
That doesn't answer my question...
Are you the author? Because there's an issue in the "this on methods" chapitre with the snippet below : const saying = hero.dialogue(); dialogue(); At this point on the walkthrough, no dialogue function has been defined outside of the hero object. 
‚ÄúThey have done a lot of good form the FOSS community in the last 3 to 5 years.‚Äù Perhaps this is because they wanted to change their image in the mind of their consumers. In the end, they don‚Äôt profit from being charitable, but they do profit from being perceived as charitable. Even if there has been some good to come out of that marketing decision, they determined that it would drive sales, increase their power, and maintain their dominance in the technology market. With dominance and power comes the ability to wield it without consequence at the expense of those dependent on their services, which they are keen to keep you locked into.
Thank you! I completly forgot it. I tried to pick some properties nicely. I know underscore/lodash's pick but I want to be protected from typos in property names. There are at least free solutions: const otherService = { otherForm: { model: { firstName: 'firstName', lastName: 'lastName', nestedFields: { butOnly: 'nestedFields.butOnly', second: 'nestedFields.second', threeOf: 'nestedFields.threeOf', fourth: 'nestedFields.fourth', five: 'nestedFields.five', }, oneMore: 'oneMore', } } }; 1. Destruct - Properties are duplicated - Hierarchy is clearly visible const getModelWithDestructing = () =&gt; { const { firstName, lastName, nestedFields: { butOnly, threeOf, five, }, } = otherService.otherForm.model; return { firstName, lastName, nestedFields: { butOnly, threeOf, five, }, }; }; 2. Verbose - Properties "not dupliacted" - You must check paths on the right side of ":" const getModelAllInOne = () =&gt; ({ firstName: otherService.otherForm.model.firstName, lastName: otherService.otherForm.model.lastName, nestedFields: { butOnly: otherService.otherForm.model.nestedFields.butOnly, threeOf: otherService.otherForm.model.nestedFields.threeOf, five: otherService.otherForm.model.nestedFields.five, }, }); 3. Pick - Simple - Not preventing typos - Could lead to hard-to-debug issues const getModelWithPick = () =&gt; pick(otherService.otherForm.model, [ "firstName", "lastName", "nestedFields.butOnly", "nestedFields.threeOf", "nestedFields.fiveWithTypo", "notExistingAnymore", ]); Personally I like getModelWithDestructing despite the fact that I have to double number of lines. What is your preference?
It's not a problem in a loop. You could do: while (n &gt;= 0) { let para; switch(...
Also, any tips on getting a job. I've been writing in Python/C# for almost 4 years now as an office worker in the field of inventory management. I've been using it to automate tasks and create simple applications for the inventory team. 
You can npm-install relative paths. Those turn up in package.json as `file:` URLs. Worked really well in a project of mine. https://medium.com/@alex_young/npm-5-and-file-urls-3c3631f7367c
Thanks to everyone for the help on this. I really appreciated the guidance. Once explained I was able to break the cookie down. Using an array, i was able to get the two strings, then convert the parts of them that I needed. I'm really happy about the little hands on project. 
Yeah. The spyware called "Windows 10" shows to some extent Microsoft is reliable!
Full disclosure: self-submission.
A circular reference _shouldn't_ crass the engine. Think of it this way (this is suuuuuper simplified and probably somewhat inaccurate; but it's useful as a mental model). You have a table of memory locations: | A | B | C ---|---|---|--- 1 | | | 2 | | | 3 | | | and I define a variable, `const x = {}`. The javascript engine will assign that to a place in memory: | A | B | C ---|---|---|--- 1 |x| | 2 | | | 3 | | | Now I assign a property to x: `x.taco = 'yummy'`. | A | B | C ---|---|---|--- 1 |x| | 2 | | 'yummy' | 3 | | | Whenever you reference x.taco, the JavaScript engine knows to lookup the value of x.taco in **B2**. Now say I create a circular self-referential property on x: `x.x = x`. | A | B | C ---|---|---|--- 1 |x| | 2 | | 'yummy' | 3 | | | All that's going to happen there is the JavaScript engine knows to look up x.x at **A1**. It's not going to copy a new version of into a new location in memory. Circular references might turn into messy-soup for us, but for the computer it's just saying "look here" or "look here". Incidentally, this is related to why `const x = 'banana'; x = 'fish'` throws an error, whereas `const y = {}; y.robot = 'kitty'` does not. Const essentially is like saying "you can't reassign this memory location". It doesn't have any opinions as to the properties of your value, only that your value itself does not change.
I bring it up because for some of us, trust is not easily regained after it has been violated. 
As to the point of circulars and self-referentials... ¬Ø\\_(„ÉÑ)_/¬Ø. You probably won't use them often in your day-to-day programming. But every once in a while they'll solve a problem for you. JavaScript is awesome/horrible in that there's literally like a billion ways to do anything. Sometimes you'll find the necessity for circulars out of closures or ease of access or any number of other reasons... other times these things are just byproducts of the language itself. It's like how "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo" is a [valid sentence in English.](https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo). Sometimes languages allow weird stuff to happen.
I have retrieved these for you _ _ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¬Ø\\\_(„ÉÑ)_/¬Ø`&amp;#32;or&amp;#32;`¬Ø\\\_(„ÉÑ)\_/¬Ø` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
To handle this, you would need to require the user to upload the file themselves. Use the File API \- [https://developer.mozilla.org/en\-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File)
I think the number one reason to be pissed about this is that even if Microsoft does a great job at everything and anything they lay their hands on, it‚Äôs always better to have diversity. Industries become brittle, corrupt, and stagnant when a few controls the many. With the purchase of GitHub, they now control the #1 place for open-source software and technology diversity. They now have the ability to implement a number of tactics that weren‚Äôt available to them without that control, all of which are aimed at increasing their share of the market. If they‚Äôre intelligent in implementing those tactics, it won‚Äôt be apparent. But it is illogical to believe that a for-profit corporation does not operate in its own best interest, but instead the interest of developers, consumers, or humanity in general. 
GraphQL is great. GitHub recently launched the newest version of their API in GraphQL instead of using REST.
Your gonna need to use a file input which will require the user to manually select the file. Web pages can‚Äôt go rooting around in file systems. You could do this in Node when reading your own files however.
I've always been partial to destructuring the desired properties out of an input object and returning a new object with only those properties. Yes, it adds a few lines and temporarily assigns a few more variables, but it affords a high readability and maintainability of the resulting function. 
I just remembered the (You Don't Know JS)[https://github.com/getify/You-Dont-Know-JS] book series. The questions at the end of each chapter are rather light, but the content itself is unbeatable. Kyle Simpson explains every feature of JavaScript in full depth. Every JS developer should read this series at least once, and you will keep going back to it for reference when you have doubts about exactly how JS works. Especially for the features that most devs continue to stumble over like prototypical inheritance, promises, how `this` works in JS, and closures.
Silicon Valley's incestual "sleepover"
That looks like a copy&amp;paste fail, he probably wanted to call `saying()`. But there are other errors in the examples as well: function Hero(heroName, realName) { this.realName = realName; this.heroName = heroName; } const superman= Hero("Superman", "Clark Kent"); console.log(superman); &gt; Note that this function is not written in strict mode. Running this code in node will not get us the value of ‚ÄúSuperman‚Äù and ‚ÄúClark Kent‚Äù as we expected, but it will instead just give us an undefined. No, this function would not log out "superman" or "clark kent" in any case. &gt; Lastly, writing the function‚Äôs name in uppercase means that we need to call it as a constructor using the new operator. This is a guideline at best, a capital letter does not mean you HAVE to call it with `new`. The best way I've found explaining how `this` is evaluated is: - is the function called via `call` or `apply`? Then you are expected to pass `this` on your own - is the function bound? then check where the binding happened - none of the above: is there a `.` before the function name? `this` is the thing before the dot; if there's no dot, `this` is the global object for given execution env or `undefined`
Is GraphQL essentially a new generation of sql query builder using a markup language rather than expressions? 
I think the Ideas behind GraphQL are awesome, but I absolutely can't stand the implementation. Typical Facebook behavior, put so much work into tech but disregard interface design entirely.
They bolted things onto the languages and ultimately just used it as a stepping stone to create a similar language and drive business.
Those are dependencies of your dependencies, ie they're necessary if you want anything to run! This much *should* be obvious.
Aside from the scoping issues that u/spacejack2114 mentioned, you have an awful lot of duplicated code that in those case blocks that can be factored out before and after the switch. Just as a first pass: let n = 10; while (n &gt;= 0) { let para = document.createElement('p'); switch (n) { case 10: para.textContent = 'Countdown 10'; break; case 0: para.textContent = 'Blast Off!'; break; default: para.textContent = n; break; } output.appendChild(para); n--; } That said, I concur with others who suggest using some other way to encode this behavior. Here is something I might use myself: function getCountdownLabel(countdownAt) { if (countdownAt == 10) return 'Countdown 10'; else if (countdownAt == 0) return 'Blast Off!'; else return "" + countdownAt; } let n = 10; while (n &gt;= 0) { let para = document.createElement('p'); para.textContent = getCountdownLabel(n); output.appendChild(para); n--; } This code is more concise, easier to understand, self\-documenting, and easier to change in the future should the need arise.
To add to the other comments, there \*might\* be away to do this if the webpage is hosted locally, i.e. "file:///path/to/your/file". The browser's local file security model is fundamentally different from the cross\-domain security model of hosted webpages. Alternatively, a browser plugin \(e.g. Chrome extension\) might let you do it. These could be possible if your application is, say, an internal corporate application.
Did not know this... For how long has this worked? Will try this out immediately! 
Creating C# is like the opposite of EEE...I'm not sure you understand how it works.
There‚Äôs a shitload of different ways to add an issue: most of them not obvious. What I can‚Äôt figure out how to do is get a complete list of what‚Äôs been assigned to me.
I still haven‚Äôt found a UI for diffs that I find acceptable: they‚Äôre all based on a 2 way diff when you really need one based on diff3.
I don‚Äôt know! I just recently discovered it. For me, it‚Äôs much better than `npm link`.
IIRC they just added a GraphQL api in addition to their existing rest API's. 
\(disclosure, I'm a yarn contributor\) Kudos for evaluation both solutions and choosing the one that best fits your use case. This is what I advise people to do as well. npm has come a long way in versions 5 and 6. Both npm and yarn continue to innovate in their own ways, and the teams actually talk about things more than you would think. \(npm folks have made yarn PRs and advised on certain issues\). There's really no clear "best" between the two and they both have their share of issues/bugs/quirks. I always tell people to try out both and go with whichever one works best for the needs of their specific project. For comparison sake, I still can't use npm on projects at my day\-job because they too have lockfile churn [https://github.com/npm/npm/issues/17722](https://github.com/npm/npm/issues/17722) and updating github dependencies was still broken last time I checked [https://github.com/npm/npm/issues/17028](https://github.com/npm/npm/issues/17028)
I think I might have done a poor job explaining myself. I‚Äôm not looking to access a file on the client‚Äôs end. I‚Äôm looking to access a file within the same server that the html page is located
That's awesome to hear they were implemented. It's great to hear a programmer describe how their "soft" skills were instrumental in improving a project. Kudos! The tech community needs more people like you.
This. Public's memory is so short lived. Did the people here forget Embrace, Extend, Extinguish?
It's a new version of the API, but they haven't deprecated the previous version yet.
Nitpicking: this is dynamic analysis. Static analysis would be if you analyze the code without executing it
javascript.info, which is online content, has a good amount of challenges. Not every section but enough to keep you busy. Solutions provided if needed, plus a comments section. 
Thanks
Because like there person before said, most of Unicode characters are not assigned to anything yet. You will need to lookup blocks that are assigned and pick those.
fun fun function \(\) { You might of know already, but here's a link [https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q)}
Yes, with all of the accompanying underlying schema chaos. It's great for certain implementations, but I fear it's going to be the next "write all your APIs this way" thing and unleash a hell upon us.
Oh, you've convinced me by refuting my statements of fact.
Most comprehensive - [You Don't Know JS: this &amp; Object Prototypes ](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md) [You Don't Know JS: this &amp; Object Prototypes - Class syntax](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/apA.md) But it's basically this - class a { constructor() { this.val = 'aaaa'; } } class b1 extends a { getVal() { return this.val } } class b2 { constructor() { this.val = 'bbbbbbbbb'; } getVal() { return this.val } } new b1().getVal() // b1 doesn't have a anything for *val* on *this* so it looks on the class it extends // returns *aaaa* new b2().getVal() // b2 has a *val* so it returns, it doesn't need to check the class it extends // returns *bbbbbbbbb*
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**apA.md** (master ‚Üí f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/this%20%26%20object%20prototypes/apA.md) * [getify/You-Dont-Know-JS/.../**ch5.md** (master ‚Üí f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/this%20%26%20object%20prototypes/ch5.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e03ypaz.)
&gt;they even dropped IE.... They didn't, though. They just rebranded it.
Dropped IE? I wish. IE 11 will be supported until 2025, which means I will be supporting it until 2025.
&gt;They could have doubled my $7/month fee \(or added another tier\). &gt; &gt;Instead, like most of the brands here, it‚Äôs money over values. This is an interesting contrast
I've been reading up on different topics in Javascript, and have found Eric Elliott's Javascript Scene articles were very helpful, specifically his articles about prototypal inheritance: [https://medium.com/javascript\-scene/search?q=javascript&amp;#37;20prototype](https://medium.com/javascript-scene/search?q=javascript%20prototype). I think prototypal inheritance is great, but you have to take some time to get used to it \-\- you do yourself a disservice if you try to think of it strictly in terms of OOP. I find a great way to learn it is to try using it. Elliott wrote a library that helped me work through this \-\- it's called stampit \([http://stampit.js.org/](http://stampit.js.org/)\) and it plays well with everything. 
Every good tool can be misused. 
All the answers are great sources. But while I was learning JavaScript, I found this particular video to be very enlightening. With nice illustrations, it is super easy to visualise prototypes and prototypal inheritance coming into play in JS. [https://www.youtube.com/watch?v=PMfcsYzj\-9M](https://www.youtube.com/watch?v=PMfcsYzj-9M) Highly recommended. And, very curious if this video will help you wrap your head around the concept. It certainly did for me.
That last paragraph is why I'm moving out as well. Its just.. Not how this shit was supposed to happen - and I'll do my part. ... Would you like to know more?
Try to put the ‚Äútarget=_blank‚Äù on the &lt;a&gt; tag instead of the &lt;div&gt;.
What fact... Being baffling is an emotional response...
Objects in JavaScript are dictionaries. They have a magic `__proto__` field that can point to any object which will be the prototype of the first one. When you look up a field on the object using either `obj.field` or `obj["field"]` syntax (they are different way of doing the same thing), and the field is not present in the object, the JS runtime looks for the same field on the prototype. If the field still can't be found, the property is looked up on the prototype of the prototype, etc... const a = { x: 5, }; console.log(a.x, a.y, a.z); // 5, undefined, undefined; there's no y here But if we add a prototype: a.__proto__ = { y: 6 }; console.log(a.x, a.y, a.z); // 5, 6, undefined a.__proto__.__proto__ = {z: 7} console.log(a.x, a.y, a.z); // 5, 6, 7 If you set `a.y` or `a.z` it will create those fields on `a` and will leave the prototypes alone: a.z = 8; console.log(a.z, a.__proto__.__proto__.z); // 8, 7 Constructors are a way to automate the initialization of the fields of an object, and assigning it's prototype. function B (y) { this.y = y; console.log(this.__proto__ === B.prototype); // true } B.prototype.z = 7; const b = new B(9); Here, calling `new B(9)` creates a new object under the scene, sets its __proto__ to `B.prototype`, and passes it to the `B` function as `this`. You can create further prototype chains: function A() { this.x = 5; console.log( this.__proto__ === A.prototype, this.__proto__.__proto__ === B.prototype ); } A.prototype = new B(6) const aa = new A() console.log(aa.x, aa.y, aa.z); // 5, 6, 7 Calling `new` also does some magic such that the `instanceof`operator also works. Note that the `this.__proto__ === ...` lines are true only when the functions are called with the `new` operator. If you call them normally, `this will point to the global object or be `null` depending on whether you've enabled strict mode or not (or to `foo` if you use `A.call(foo)` or `A.apply(foo)`).
Thanks. That's not exactly what I was looking for here, but that's a good option to know about.
Or bot. M$ bots.
Here is a working demo: [https://codepen.io/anon/pen/PaNPJz](https://codepen.io/anon/pen/PaNPJz)
Did you write that article? Why do you need to disclose what's under the post's title?
If I understand you correctly, you have this file hosted on a server where it's accessible through an HTTP request. In that case, you would want to use either fetch or XMLHttpRequest on the URL where you can find that "file". I recommend fetch if you're just playing around and your environment supports it. In production you might need to polyfill it though. Here is some documentation: [https://developers.google.com/web/updates/2015/03/introduction\-to\-fetch](https://developers.google.com/web/updates/2015/03/introduction-to-fetch)
My simple rule: THIS has **no meaning** in JavaScript. THIS is just a placeholder for the _*context*_ that called the function. That's it, knowing the use cases probably helps a lot. 
Look up the Node.js filesystem module docs. Something like, const fs = require(‚Äòfs‚Äô) const file = fs.readFile(‚Äòfilename.txt‚Äô) 
By default modern browsers will attempt to show the PDF in the window or a new tab. Different browsers behave differently. From my experience you need to set some headers on the server side to get it to download vs display in browser. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
Not really. GitHub charging me more doesn‚Äôt change their focus on open source. They‚Äôre just asking me to pay more for access to it. Taking $5b and handing the company off to what has traditionally been the antithesis of open-source software is totally different. 
Because Math.random is not truly random, it's pseudo random: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random Use a cryptographically secure library if you want to use something with passwords. Or better yet, do that on the server side.
Stylistically, don't use `__proto__` to access the internal `[[prototype]]` property. Use `Object.setPrototypeOf(...)`. ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf))
yup, this in browser is different from nodejs
Use readFileSync if you don't need asynchronous operations 
I don't follow. `this` scopes similarly in the browser and node.
But it does have meaning, isn't \&lt;\&lt; this \&gt;\&gt; just the bounded object? The global object contains all, so that's the default. And if you have a function defined as a property of an object then the function is bounded to that object. You can also change the bounded object via call/apply/bind. That's about it. The only "edge case"/gotcha is when you have ES5 functions in bounded functions because they don't attach to the bounding context, but that makes sense to me. Just like objects defined in bounded functions \(or otherwise\), they are independent of the lexical scope by default. ES6 functions try to "fix" this by bounding to the object in which they were defined. That's useful if you think that's the behaviour it should have, and it reduces a few boilerplate lines, but I think it actually complicated the subject and makes understanding the concept harder. I don't think it is necessary to treat \&lt;\&lt; this \&gt;\&gt; as a magical thing.
If you want to play with GraphQL and happen to have a Postgres database lying around, point https://github.com/graphile/postgraphile at it and see what happens. I found it provided me with a very low resistance way of visualising how I might access my data via a GraphQL API 
This is pretty useful. Thanks!
Beautiful architecture. Legitimately a window into the future of full\-stack architectures. 
Yeah your response here and the "continued decline of medium.com" mentioned in your post just sounds super jaded. Paywall tags seem like they'd do the trick just fine. It sounds like you just don't like medium.
You do realize VS Code is open\-source, right?
&gt; After learning that in JavaScript that 0.1 + 0.2 is NOT equal to 0.3, I feel I'm having an existential crisis here... That happens in **literally** every language that adheres to the floating point standard. Here a C++ example: #include &lt;iostream&gt; #include &lt;iomanip&gt; int main(){ float a = 0.1; float b = 0.2; float c = a + b; // prints 0.300000011920928955078125 std::cout &lt;&lt; std::setprecision(30) &lt;&lt; c &lt;&lt; std::endl; }
Well, `&lt;script&gt;` tags are executed on the client side, so and AJAX request is most feasible, unless you're willing to do a proper web-app through express or something.
Correct, I went for `__proto__` for conciseness in the sample. I could also have mendtioned that `__proto__` actually is a getter/setter pair for the private `[[prototype]]` field, defined on `Object.prorotype`, the default prototype of JS objects. I didn't want to introduce those concepts to a beginner that's struggling with other aspects of the language though. User-visible behavior would be identical in most cases if `__proto__` was a plain (non-enumerable) field. There's an exception if you cut `Object.prototype` from the prototype chain though: const a = Object.create(null); console.log(a.x); a.__proto__ = null; // __proto__ stops being magic and becomes a plain field. a.__proto__ = { x:5 }; console.log(a.x); // null; booo 
Hi /u/tmpphx, For javascript help, please visit /r/LearnJavascript. Thank you!
Save the chunks temporary,then create the blob. [like so](https://github.com/devongovett/blob-stream/blob/master/index.js)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [devongovett/blob-stream/.../**index.js** (master ‚Üí 5a7b179)](https://github.com/devongovett/blob-stream/blob/5a7b179cf29707e62552ef23d4d4ca996ea5da99/index.js) ---- 
I highly recommend the Udemy course JavaScript: understanding the weird parts by Tony alicea. A whole lot of stuff clicked for me after watching that. He's got the first few parts on YouTube for free.
&gt; *this* is whatever you make it to be - The Spirit of JavaChristmas 
Here is the same issue: 1) create array function BlobStream() this._chunks = []; 2) append chunks in .write this._chunks.push(chunk); 3) make a blob this._blob = new Blob(this._chunks, { type: type }); -&gt;&gt;&gt; here we've memory wasted, _chunks + _blob this._chunks = []; // free memory
43 years, dude. 
Wow I'm stupid. Sorry. Didn't read the entire post :/
Np at all, friend.
I would just like to second the suggestion for Hackerrank. I've spent many an afternoon frustrated at not being able to solve a problem there. Generally I try easier challenges in languages I'm not familiar with, a great way to learn!
Google 'YouDontKnowJS on github'
Came here to link this; @getify is really good at JavaScript
Nice, but remember: it's usually a better idea to flatten your store structure than to have nested data.
Not a textbook but, codeschool.com is amazing
So similarly, one might say they're the same. In fact, some would go so far as to say Node.JS has the same JS engine as Chrome. /s
I use [this cheatsheet](https://github.com/gordonmzhu/cheatsheet-js) by Gordon Zhu as a reference. Not sure how good/complete it is, since I'm a noob, but hope it helps.
Again: you do realize that VSCode is open\-source....... \^\^\^right?
Do you mean the docs or tools or? GraphQL itself is a spec not something with an interface.
AFAIK, it‚Äôs good etiquette to tell people if you are submitting something you have written yourself.
As an alternative for folks who use PostgreSQL, [apollo-client](https://github.com/apollographql/apollo-client) with [Postgraphile](https://www.graphile.org/postgraphile/) is great! AppSync doesn't natively support PostgreSQL yet üòï
Madness! Next you're going to say I should enable row level security and create a role for each of my application users!
Thanks for all the suggestions. 
*statistical* analysis, not static
Skip prototypal inheritance entirely. Class-based inheritance is far, far more common and will apply to more languages.
Except it doesn't exist in JS.
*class* and *extends* are [literally keywords in the language now](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends).
Why are you not credited on the blog post page?
Also pre\-ES6, and pre\-death\-of\-jQuery.
Nice nice. I'm going to try this.
I‚Äôm still using Yarn. npm 6 is indeed faster than it was, but it completely ignores packages sometimes when I npm install. Like, straight up doesn‚Äôt install something listed as a dependency in my package.json. And other times it just hangs and never finishes the install. Maybe I'm the only one in the world with these issues but npm has continuously proven itself to be incredibly unreliable compared to Yarn.
I've checked this out before and thought it was pretty cool. There is also a Graph ql frontend wrapper that is useful for external Apis that you may have no control over or in the case where your company may not find rewriting or modifying some internal Api useful. Instead of mapping your types to a database connection you would map them to an Api route. 
My company \(Clausehound\) recently moved the lion's share of our RESTful endpoints over to GraphQL. On the whole it's been a massive improvement: what triggered the change was doing an audit of page load times, and finding in many cases 16\+ independent \`fetch\`es coming client\-side on the first page\-load \(on different endpoints\), and then those data merged together client\-side. As a legal tech firm, the biggest advantage we've found is around security. Considering everything as a GraphQL object also gives us a reasonable place to define security roles. The tough part with REST is that we'd often end up with only a few routes per controller, and a lot of the access control would sit at \(or close to\) the route. So you could load 80&amp;#37; of a page's data, then simply fail on part of it, which was a very difficult state to manage client\-side. We'd need to figure out \(on the client\) what "mode" \(usually based on the user, e.g. "admin"\) we were loading the page in and adjust our requests accordingly. With GraphQL, both the load on the application, and cognitive load on the developers, has gone way down. You build your relationships to the objects you need, and then the client sends in its request along with the JWT payload. We send back the available data for the user's claims \(or a 403 if they don't have claims for it\), and that's it. The main thing I miss about REST is the ease of caching. While it's true that REST generally gives you back much more data than you need, that also implies that you can cache the same info and it's useful for more users. Our endpoints would cache and be served from a filesystem, which brings the CPU down to almost nothing and even lets us serve the rendered files from fast servers closer to the client requesting them. GraphQL takes quite a bit more work to divide our Objects up into cachable ones, and configuring AWS to serve certain GraphQL requests from a cache is far harder than simple GET to a URI.
Here‚Äôs a list of all their offerings. Count the number of open-source products and projects. https://support.microsoft.com/en-us/allproducts
Not sql, replaces REST api ‚Äòs, so no more routes. Hard to describe on mobile rn but definitely worth taking a look, it is a game changer.
The `class`, `extends` and `new` keywords are just "syntactic sugar" for Prototypal Inheritance. Classes definitely don't exist in JavaScript.
Those keywords are just sugar. Its prototype inheritance underneath. &gt; JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript's **existing prototype-based inheritance**. The class syntax does not introduce a new object-oriented inheritance model to JavaScript. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
Depends on the DB you're using. There are some databases that use it natively now. I've been using dgraph for some personal projects and it's query language is GraphQL+ which is GraphQL with some extensions for indexing, filtering, and such. The really nice thing is that it lets you easily specify queries that in SQL would involve lots of JOINs. If you're backing with a SQL database the translation layer will take care of the JOINs for you, and if you're working with a graph database then it's just a native edge traversal operation.
&gt; Its prototype inheritance underneath. Which doesn't matter for 99% of projects.
Hi /u/Dr00gy, For javascript help, please visit /r/LearnJavascript. Thank you!
Careful you don't automate yourself out of a job...
You're all a little right. What we JavaScripters understand prototypal inheritance to mean -- objects delegating to other objects -- has long since been used to implement classes and classical inheritance in other languages such as Python, Ruby, and Smalltalk, which is why classes in Python and classes in JavaScript [behave remarkable similar](https://i.imgur.com/p9Kw815.png). The distinction between prototypal inheritance and classical inheritance is fuzzier than we think. cc /u/Qwakeworld /u/ritajalilip /u/Lurk_Skylurker /u/misc_ent
Oh look, a medium article pimping someones book, vaguely disguised as a guide! I am SHOCKED. 
&gt; It adds an entry to the dependencies: &gt; &gt;"dependencies": { "helpers": "file:../helpers", ¬∑¬∑¬∑ } I feel like I wouldn't want npm to add this to my package.json when publishing the package. Am I missing something? Overall, I've found [Lerna](https://github.com/lerna/lerna) to be the most painless way to handle a monorepo with multiple individual npm packages. Interesting article, nonetheless.
I can't disagree with that!
We tried this at work a little while back and came across some problems. When using npm 5, there was a bug preventing us from installing local modules that had one or more dependencies that was also a local module. Everything worked fine when we downgraded to npm 4.6.1. Then we switched to yarn and that didn't seem to have any issues either Hopefully this has been fixed by now
bad bot
YOU WOULDN'T DOWNLOAD A JOB
I imagine something like this with plain JS: `document.querySelector('#wrapper').innerHTML += '&lt;div class="timer"&gt;&lt;/div&gt;';`
Only if you're comfortable using something without understanding how it works.
&gt; Skip prototypal inheritance entirely &gt; Which doesn't matter for 99% of projects. Bold statements based in ignorance. You mean it doesn't matter to you. This would raise huge red flags if someone said this on my team.
I love these guys who boast about how they programmed some software to do their job for them. Wow, congrats, now here is your pink slip since that automated software was made on company time and I no longer need you. Thanks to all the programmers speeding up AI development to replace humans... I guess?
Count the number of products/projects that are relevant to the discussion.
I don't know why you think that Skype and PowerPoint have more to do with GitHub than VSCode, but... you do you, I guess
This is where you don't say a word and just act busy while reading reddit.
Probably posted this exact comment like 5 times now, but still have yet to be fucked by yarn, so I just keep using it. 
Game changing, you say? How so?
Maybe it will prove to be helpful to you: https://wanago.io/2018/03/19/prototype-the-big-bro-behind-es6-class/ Cheers!
Codereddit.com
Codereddit.com
I was referencing the name `identity` for their function
Well that was terribly anticlimactic
The same way Safaru is buried deep into macOS and won't be available for Windows or Linux.
BitBucket gave my account to a hacker without telling me, and refused to give it back even when I proved that I still controlled the e\-mail I signed up with, as well as the private key associated with the account's public key. So yeah, personally, I'll never use it again.
Same here. Truth be told I still have a few projects which only use npm, but I like how yarn doesn't forget about files or make me delete the lockfile and run npm install again 
I'm an unemployed automation specialist myself \- I sure as hell would download a job if I could!
Can someone Eli15 me why I should change/learn graphql?
&gt; unemployed automation specialist I would've believed you, but your post doesn't have enough buzzwords per word count.
The George Costanza method. Walk around looking frazzled all the time and folks assume you are way busy.
Man after reading that article.... you created an insanely simple node script and then pushed your book...
Safari is guilty of the same sins as IE/Edge
Get truthy items from a list: items.map(Boolean)
Prisma is a great tool to look at in conjunction with GraphQL as well for the backend
The query language itself certainly counts as an interface does it not?
If "under the hood" classes weren't implemented using prototypes, and yet behaved the same as they do know, would that change how you used them?
Guilty as charged! I use things every day without understanding how they work under the hood. I'm ok with that.
Not just him...his co-workers too...this guy better look out...
I wouldn't call it a game changer, but it could be a great alternative compared to writing 3\-4 REST endpoints or dealing with query parameter hell to filter data from a standard JSON REST endpoint.
its been working like that pretty much since the beginning pretty neat
+ https://www.prisma.io/
They wouldn't behave the same way though if they didn't use prototype inheritance. If that were true there would be no difference between prototype and class based inheritance. The original statement still stands: javascript does not have class inheritance.
We have it where I work, we have probably 10 rest calls to get data from different places some cacheable some not, some needs info from one call some not, that where it shines the best, instead of do the orchestration on the front end you define a schema of what needs what and how to resolve the data via other downstream services (rest, graqphql or whatever), once you have the schema and resolvers you can add caching in any of the resolution edges of the graph then it‚Äôs matter of writing the query with and graphql will do the graph call in the correct order win the most parallelization possible all this on the backend while your front end app only makes a single call, it has made front end developers job much easier since you don‚Äôt have to know at that later how the services depend on each other and where are all the downstream services or their conventions, for us it was a game changer for sure. 
I'm going to shamelessly use this opportunity to ask about the one bug with Yarn that keeps bothering me, but I haven't filed an issue about :) I love the offline mirror feature, and it's the biggest selling point I use for Yarn over NPM. But, somewhat frequently, when I add a new dependency to my project, Yarn will skip adding some of the transitive package files to the mirror folder, and it's hard to find out until a CI build fails. The only solution after this happens is to clear my local Yarn cache, and remove and reinstall that package. Any idea on what's going on? Unfortunately, I haven't had time to try to create a meaningful repro of the issue. 
I actually did this a couple of years ago. A big part of my job was keeping a university's lab Macs updated. Over the course of 4 months, I automated 90% of the job using a combination of [Jenkins](https://jenkins.io/), [Autopkg](https://github.com/autopkg/autopkg), and [Munki](https://github.com/munki/munki). A couple of months after rolling out my solution, I was let go. In the end it worked out, though. I told my tale of woe to an interviewer and they hired me to write middleware. :)
You have a app that is hitting different services on different places with different contracts, then imagine that you need data from one service to make the next call to another service, some of these services depend on each other while others not, now you need to get info from all this services to render your app and you want to do it as quick as possible, without graphql you need to know what depends on what and what can be done in parallel and what can‚Äôt, then remember that the contracts are different downstream so all this logic has to be in your app layer. With qraphql you define a hierarchical schema and how to resolve each of the edges of the graph and using the provided query gql knows what needs to be resolved, how and if it can be done in parallel, then you can add caching on some edges or not and your app will only need to make one call to graphql server and get all the data it needs in the most efficient way. There is not really an advantage if you have two or three endpoints on the same server but when you have a graph call then it is definitely a great tool, the more complex the graph the more help you get from it. 
Wow that's weird. I have never had that happen to me and it doesn't sound familiar. Definitely open an issue on GitHub, especially if you can figure out a pattern to it.
Well, nothing in a conventional computer is truly random, it‚Äôs just that `Math.random()` was designed to be quick and output numbers in a small interval. You could say it‚Äôs not random enough compared to some other pseudorandom number generators. In his case, he‚Äôs generating passwords for users, not storing them using plaintext or anything. Given a decently long sequence of characters, I‚Äôd say his passwords might even be safer.
Thanks a lot! I get it now! &amp;nbsp; &amp;nbsp; Now.... How do I get from my level to yours?
always look forward to these posts
You have a div with an ID of a? By calling $('a') in jQuery you are calling &lt;a&gt; elements. You need to use $('#a') to call an ID or $('.a') to call a class. for updating it's text use: $('#a').text(newText);
This is useful. Thanks!
Its really bugged on my pixel 2 and I can barely scroll Up but it looks like a simple slider with snipping animation High to low speed to me on touch events. At least its how I would reproduce it on mobile.
No problem, glad to help! * [Read You Don't Know JavaScript](https://github.com/getify/You-Dont-Know-JS) * Don't worry about what framework or tooling or whatever to use. None of it matters. Javascript developers love to argue over pointless stuff. If something works, it works. Period. * Just write code. * No, seriously, write code a lot. Programming is literally learning an new language. _It definitely helps to immerse yourself_. * Come back to it 3 months later and laugh at how little you knew. Rewrite it. * Come back to it in 3 months and question what the hell you were thinking. * Move onto another project and write more code. * Learn to write tests. Test your code. * Begin writing code to make your life easier when it comes time to test it. * Begin writing code to make your life easier when you have to come back to it 3 months later. The best thing I ever done to aid development is to conscientiously write code that will be clear to me looking at it months down the line without any context. _Write code for future you, not now you._
You have to have some understanding of how a thing behaves, otherwise how can you use it with any confidence that it's going to work the way you expect? I obviously don't mean you have to understand it **100\%** down to the level of the microcode instructions being executed on the processor \- that would be overkill, and the whole point of higher level languages is abstraction \- but the distinction between class\-based and prototypical inheritance is itself a rather high\-level concept. If you *genuinely* don't understand the difference, it will eventually end up biting you and causing you grief. At the very least, you won't be nearly as effective a developer as someone who *does* understand this distinction. If you're okay with that, well, best of luck to you. =\)
Yea it seemed like a slider to me too. But delving into it it didnt translate an axis like a slider would just overlayed divs. I think I figured it out finding a vanilla js script to detect swipe direction. We will see. I am surprised there is no go to plugin for swipe detection seeing how big mobile is. 
jQuery is falling out of style??
At least a year. I did it to test a library without having to push to git with every iteration.
Its pretty easy to detect any touch movement on mobile, just dig up around google and you'll find it really easily :\) I'v used it in the past for multiple projects.
quickly
For those who have been using GraphQL for a while: how are you approaching error management? does it work easily (enough) with e.g. Sentry? if not, what is your approach?
and for a blog or something similar? 2-3 alternatives, lightweight.
I attribute a ton of that to the company i worked for they were very willing to listen to their employees concerns and needs. I just changed companies and my new position requires a lot more IT skill than web development but so far they are the same way, to me it's the most valuable thing a company can offer, filling the needs and listening to employees.
Thanks so much! You really have my gratitude! 
But IE11... I'd say probably never. Much as I'd like to say "pffft" to them IE11 use still sits at around 4% of our user base. Until that drops to somewhere less than 0.5% we can't push out Web Components. I doubt we are alone there...
Yea the answers on SO and such all pointed to hammer.js or another plugin but they all seemed to have been dropped support wise. Thanks for the help! Much appreciated!
`this` is the thing to the left of the dot. Any explanation of this should start with that sentence. It's usually true, and what `this` was designed for. Then you can go over the exceptions: - when there is nothing to the left of the dot (then it's the global context) - when it has been reassigned (such as with `new` and `bind`)
Don‚Äôt worry you don‚Äôt have to.
nice
 class BlobCollector { constructor (initialChunks = []) { this.chunks = initialChunks } push(chunks) { this.chunks.push(...chunks) } pull() { return new Blob(this.chunks.splice(0, this.chunks.length), { type: type }) } } Splice mutates the original array so at the end of `pull()`, `this.chunks` is an empty array. You could also do this without a class, this is one implementation.
&gt; www.tutorialrater.com what is the evaluation criteria?
Drop jQuery and read up on DOM 2 specs.
checkout postgraphile 
Checkostgraphile. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'checkout postgraphile'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
upcoming react app that streams your self hosted media https://github.com/ridhwaans/homehost. powered by tmdb and spotify APIs uses: react, redux, webpack, expressjs currently has movies and music todo: tv shows, podcasts, comics, books 
I been using Yarm since it was back at 0.24 and had zero issues upgrading or any of the other issues this article claims, working on Windows, mac and Linux. I guess nothing perfect, but that article does sound like it's more of an extreme case.
Think about this this way your objects don't really inherit anything they just point to whatever object you "inherited" from. So that means if you were to change a property that you inherited from, that change is reflected in the new class you created. In Java it's like a blue print so inheritance is just a whole new set of of methods and data created in memory that becomes independent once an instance(or object off that blue print) is created in memory. In JS it's just a reference to another object. I would suggest just not really using inheritance and just use closures to encapsulate data, it's a superior pattern IMO.
I updated my Chrome extension [Recent PDF](https://chrome.google.com/webstore/detail/recent-pdf/ihjgdammecebcjinfmllgniaeneabkdk). And I am very proud of how it turned out. Don't judge based on the webstore screenshots as I have not updated those yet.
If anyone wants to learn GraphQL with GitHub's API from the client-side perspective, before going on the server-side, checkout these tutorials: * [A complete React with GraphQL Tutorial](https://www.robinwieruch.de/react-with-graphql-tutorial/) * [A complete React with Apollo and GraphQL Tutorial](https://www.robinwieruch.de/react-graphql-apollo-tutorial/) 
react &lt;label className={`${this.state.inputData.length &gt; 0 ? 'has-data': ''}`}&gt; &lt;input type="text" value={this.state.inputData} onChange={this.updateInput} /&gt; &lt;/label&gt;
"GraphQL is great" "Look at all these neat queries" What almost no one mentions is the queries were always the easy part (REST has been using `expand` parameters for ages), it's the mutations that are a nightmare. There are no namespaces so every command collides at the top-level. The 'official' recommendation is to treat every mutation like an RPC call (sounds eerily like SOAP, no?) and to name them `createBlogEntry`. If you have less than a dozen mutations that might work but if you're any reasonably sized product you'll end up with dozens of calls that all start with `create` or `update`. If you want to find out everything you can do against a certain type of object your only hope is to grep the documentation or hope the developer had been kind enough to group them for you on their documentation. If you follow many of the tutorials out there for mutations you'll also end up with multiple endpoints to affect the same resource, such as `updateBlogEntrySubject` and `updateBlogEntryBody`. There are solutions to all of that but they won't be in any official tutorials or issue trackers. Most of the time those issues will be closed with a "Won't Implement", saying they want to keep it flexible, which has the expected result that everyone who implements GraphQL will do it differently or servers will be required to implement it the way the most popular client expects it (See: Relay Connection, Graphcool Query Filters). The one place they do make an official recommendation throws reusability out the window. Every top-level Query and Mutation result should be a unique type definition (`[Mutation]Payload`). It makes sense but the language could have made it easier to define a bunch of single use types for that purpose, never mind the documentation and tutorials not covering that while getting everyone hyped about the system. After doing tons of research and experimentation I ended up leaning back to the lessons learned from REST by making the mutations follow the same pattern: one mutation to create or update a resource and putting the subject first for dependent actions (`blogEntry(input: BlogEntryInput)`, `commentMarkSpam(filter: CommentFilter!)`). I also went one step further by making reusable Filter inputs for Queries or Mutations that avoid having twenty field inputs for each actual field in the object (eg Graphcool), and a single easily reusable top level Paging input that works across all queries. That was way more painful to figure out than it should have been.
Prisma is still a very young technology, its nice when it works, but there are a lot of things that just doesn't work and doesn't really indicate that or why it isn't working.
Just a small remark, I think you don't need the template literal
why did you bother putting it in the quotes like that? Wouldn't this have been enough: &lt;label className={this.state.inputData.length &gt; 0 ? 'has-data': ''}&gt; &lt;input type="text" value={this.state.inputData} onChange={this.updateInput} /&gt; &lt;/label&gt;
lockfile churn is precisely the reason we just went from npm \-\-\&gt; yarn at work. wtf is the point of lockfiles if they just adjust when you use carets in \`package.json\`?!
Depends on what he's analyzing exactly. If it's source code then static analysis is probably the correct term. Not every code analysis is statistical in nature. https://en.m.wikipedia.org/wiki/Static_program_analysis
GraphQL is awesome. It solves over- and underfetching compared to a REST API. In short - you just get the data you care about. I came in touch with it using the open source headless content management system https://getmesh.io You can try it with the demo app and see some examples here: https://getmesh.io/docs/beta/graphql.html
Maybe this is a silly question, but if my data is in a SQL database, how do I then query that DB to return what GraphQL needs to return data to the client?
MPJ is awesome and makes great videos. This really really is not a great comment here though. It doesn't answer the question, address any part of it, and is entirely lazy. We can be better.
\&gt; Other than that it defaults to the global context instead of undefined \(which is dumb\) And kind of deprecated ‚Äî it's `undefined` in strict mode and in modules. It's a thing, and a full explanation should mention it, but putting it first confuses more than it informs. 
Sorry, exaggeration. But still quite a few are on, or have moved to Gitlab, such as Gnome, Gimp, Inkscape, F\-droid, Gitter, for example. I wouldn't expect the Microsoft or Facebook apps to move, but Githubs terms of service have always been on the shitty side. We shall see over the next few weeks how many other projects see the risk of this move.
Can second this. It's honest and I mirror this sentiment. Permission implemention needs to be thought through and when I was implementing multiple column filtering + ordering pagination I was disappointed with the limitations of the schema and found myself writing a lot of boilerplate
This is a huge update for Meteor. I feel like it is finally shedding some of the fat its been carrying around to support legacy \(\&lt; 1.0 release\) codebases.
ah your post wasn't there when I wrote my comment. I also didn't know the name of what I was referring to \- thanks :\)
This is just upper object, class, function(es5).. no? 
Wouldn't really recommend it but Vanilla js isn't that bad if all you need to do is toggle a class. document.querySelector("#myinput").onkeyup = (e) =&gt; document.querySelector(`[htmlfor='${e.target.id}']`).classList[e.target.value !== '' ? 'add' : 'remove']('has-data') 
Nah, don't worry about it. Building *enterprise-size projects* with jQuery has fallen out of style in favor of newer frameworks (ie. React), mostly because they 1) offer nice modern features like building 'single page applications', and 2) they scale better when many devs are involved due to nice file and code structure. If you're just starting out, jQuery is perfect. Keep it simple - vanilla JS, jQuery, HTML, and CSS (jQuery is still a workhorse in many situations, and lots of libraries use it. You'll want to be able to understand jQuery code when you see it). Don't worry about integrating the 'hot' new library of the month unless the need in your application is very obvious, or you just want to for learning / fun. For your example, try this: $('#a').text("this should display instead of hello"); 1) The "#a" part is called a CSS selector. # is the symbol for "id". (Without it, as in your example, the selector matches all 'a' tags (link elements)). 2) jQuery runs the selector and gives you a 'jQueryObject' (like an array) that contains the matched elements. In this case, it will only contain the one div. 3) So then you just need to call a valid method on the jQueryObject. .update() isn't one, so .text() is what you're looking for. 4) Extra bit: To get the element contained in the jQueryObject, you can access it like an array: $('#a')[0]. That gives you the 'raw element', which you can read/set innerHTML on. (Using this method, your example would look like: $('#a')[0].innerHTML = "hooray!";)
Post code pls.
Edge is available for Android, which is very Linux-y. And Safari for Windows was discontinued around version 5 due to lack of interest.
To me, it makes sense in a single-repo setip. For instance, I have a game with server and client in one repo, along with shared files containing classes for compressing and decompressing data,schema for communication, etc. I can then just request the shared files while it having a package.json such
You also don't have to do a .length &gt; 0 as inputData.length being 0 would evaluate to false. So, inputData.length ? 'has-data': '' Even more, you could use short circuit syntax and have inputData.length &amp;&amp; 'has-data' There is also a really great package called 'classnames' build to make this exact case cleaner in your code when you have multiple cases. 
Vue, it's so elegant. &lt;label :class="{'has-data': inputData.length}"&gt; &lt;input v-model="inputData" type="text" /&gt; &lt;/label&gt;
I believe there are performance implications when dealing with many instances. 
this guy javascripts!
You must be doing something weird and wrong here. npm works fine. Yarn is dead! :D
For what it's worth, I've been programming in JS (front-end and node) for professionally for almost five years now and literally have never had to use inheritance once, so it's not worth losing sleep over :)
I doubt it ever will, they're really pushing DynamoDB. You can write a lambda function to talk to a SQL server instead. I'd almost say it's preferable because you don't have to learn how to format a database request using VTL (which you'll probably never use again in your life) but can instead just use the language of your choice in the lambda function.
I don‚Äôt think so, with a java class all of the methods and data is stored locally, where as with prototypes used by JS, Python and Ruby there is a lot more hopping needed to be done. But that being said I still think there is no need to ever use prototypical inheritance in JS. Just use closures and object literals. Your program will both run better and be easier to reason about. IMO using classes is just fine too, just don‚Äôt extend classes or inheritance it‚Äôs a pretty stupid pattern and only leads to headaches and mysterious behavior 
My advice it you're just learning JS is skip prototypes entriely for now. IMO the opportunity cost of learning prototyple inherritence vs learning other stuff just isn't worth it. It's become a low level understanding the language thing rather than something you need to know to write JS. JS is moving more towards a functional approach which doesn't use inherritence at all. Learning about higher order functions and function composition will more valuable. 
Time is finite but there's almost infinite things to learn. The opportunity cost of learning prototypes for someone starting to learn JS just isn't worth it in my opinion. If I saw someone in my team using inherritence, let alone prototype inherritence I would strongly suggest they might want to use composition instead. 
they had moved away from XML to javascript What does this mean? I think you meant something else, but I'm not sure what.
Yarn was justified for like 6 months while npm had some shortcomings that yarn fixed. Npm has nice caught up and filled those holes. I don't know why people care so much, and argue about it. But everything, open source especially, is easier if we all use one package manager. So please, by all means, abondon yarn.
angular solution:: &lt;label&gt; &lt;input type="text" ng-model="example" ng-class="{'has-data':example &gt; 0}"&gt; &lt;/label&gt;
Not using inheritance, sure. But using classes pre-es6, accessing the prototype was essential. 
fucking useless bot
It is, and it allows us to ask questions to you directly if we have some :\) \(just to add to your answer\)
AngularJS (1.x) ``` &lt;label ng-class="{ 'has-data': $ctrl.text.length &gt; 0 }"&gt; &lt;input type="text" ng-model="$ctrl.text" /&gt; &lt;/label&gt; ```
I hope your teacher is satisfied with this solution https://codesandbox.io/s/l2wll5l1nz
Angular does this automatically, but the class is titled ng-not-empty. Okay to be fair you would need some code elsewhere: &lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;label&gt; &lt;input type="text" ng-model="inputWithSomeNameForTheDataToBeStoredInHere"&gt; &lt;/label&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) {}); &lt;/script&gt; This is that done minimally in angular, but the script part and the container is both once per page.
Vanilla js is ‚Äúnot bad‚Äù in any task
https://www.reddit.com/r/javascript/comments/8of0nk/need_an_eli5_on_prototypes_the_prototype_chain/ JavaScript has objects. Objects can have properties, e.g. object.propertyName = 100; or object.methodName(). Every object (other than rare exceptions) have another thing called prototype. Prototype of an object is another object. When you access a property of the original object (e.g. when you get a property or call a method), in case that property doesn't exist, it'll look it up on a prototype object, and if that doesn't exist, it'll look it up on the prototype of the prototype and so on, i.e. it will do a look up on the whole prototype chain. Basically prototype works like a fallback: if something isn't found on an object, it will try to find it on the prototype. It could serve a similar purpose as "inheritance" in other OOP languages. [original](https://www.reddit.com/r/javascript/comments/8of0nk/need_an_eli5_on_prototypes_the_prototype_chain/e0327an/)
I started using Vue a little over a year and a half ago. Best decision ever
üôÑ nowhere are they claiming it's static analysis. It's a performance tool. With statistics.
Who are the target users for this? What applications is this useful for?
Ember.js \`\`\`javascript \&lt;label class="{{if inputData 'has\-class'}}"\&gt; \&lt;input type="text" value="{{inputData}}" oninput={{action 'handleInput' value="target.value"}}\&gt; \&lt;/label\&gt; \`\`\`
&gt;I don‚Äôt know anybody who isn‚Äôt confused at the state of JavaScript these days, whether you‚Äôre new to JavaScript, or you‚Äôve been coding with it for a while. OK, I've read enough.
rraz [https://en.wikipedia.org/wiki/List\_of\_mergers\_and\_acquisitions\_by\_Microsoft](https://en.wikipedia.org/wiki/List_of_mergers_and_acquisitions_by_Microsoft)
Dead as a doornail.
[removed]
[removed]
Yarn workspaces \+ interactive upgrades \&gt; Anything that NPM currently offers.
rofl good luck.
jQuery: $('input').keyup(function(e){ e.target.parent.class(e.target.val().length ? 'has-data' : ''); }); I'm writing this from memory, so please forgive me if I've skipped something vital! Will test and update when my laptop is finished with ruddy updates üôÉ
Well, I've just generated **B8.4.iSF\)tM\&gt;e5r&amp;\^KUKoQ1"F4.$\&gt;7Na** and when I test it's strength on [https://howsecureismypassword.net/](https://howsecureismypassword.net/) it says it'd take "2 quattuordecillion years" to crack it.. I don't think it's weak. Although there surely are ways of making it even better like randomly \(or with some kind of a seed\) repeating / not repeating characters there are already there. 
Cypress.io
I dont think typescript has anything to do with the "core" and also theres no good reason to recommend php or asp over nodejs when someones already learning js 
Basically anything you would build a single page app with will work for any front end, whether it's a blog or otherwise. There's plenty of alternatives, just google 'front-end frameworks' or 'node frameworks'.
This technology has been a magical experience compared to RSpec and Selenium.
it certainly feels that way when I check the forums and SO. especially when compared with a couple years ago if that's when you first came across it. however I haven't found anything else I would prefer to use and it's still activity updated.
How would you explain QT to the JS community?
I've got some lingering issues with Yarn, but as long as its workspaces are saving me from linking hell, I'm happy to stick with it.
 const input = document.querySelector('input'); const label = document.querySelector('label'); input.addEventListener('input', () =&gt; { label.classList.toggle('has-data', input.value != ''); });
Thank you. Guess I'll have to check it better.
There is a youtuber called **The Net Ninja** that just finished a video series on object oriented Javascript, where he talks about prototypes: https://www.youtube.com/channel/UCW5YeuERMmlnqo4oq8vwUpg/videos
This can be done using css in case you just need to update how input display. input:not([value]), input[value=""] { // style if no value }
Focus on speed of development and ease of shipping your applications to the users ?
From what I've read on HackerNews, the Qt community despises Electron and JS. Why would you want to build a cross-platform app with html/css/js when you could use C++ and python and have a UI that looks like it's a linux app from the 90's?
As others have pointed out, the browser can't read files without using the file API (i.e. a file picker dialog). On the other hand, a node.js application can use the `fs` functions to read a file on the local system (i.e. the server). However, a web browser can't read a file from the server unless the server has it exposed publicly. If the file is exposed publicly, then it'd be a simple case of loading it via a `&lt;script&gt;` tag (but then the server expects it to be javascript or something parseable), or using `XMLHttpRequest` if the file is a binary file or otherwise (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data).
Be careful, the \[second parameter of toggle doesn't work in IE.\]\([https://developer.microsoft.com/en\-us/microsoft\-edge/platform/issues/11865865/](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/)\)
&gt; Like, straight up doesn‚Äôt install something listed as a dependency in my package.json. Usually means you need to delete the lockfile. It's a pain.
We use it within our monorepo. Be aware though that once installed, any changes to the module will not be reflected. Even with a further install as the package Json version isn‚Äôt updated. So it‚Äôs not a total substitution for linking.
Thank you for your feedback ! I partially agree though, if you mean that entities should not be nested \(i.e.: not normalized\) than I totally agree. I don't see the problem in having a nested store state shape, I see nesting as namespaces to organize your data. Can you clarify further why you think that a flatten store structure is better ? I'm really curious, thank you !
Isn't it wrong to use npm install when you don't change your package.json? I thought you always should use npm ci for installations, except you want to add, change or remove packages in your project. npm ci never alters the package.lock file.
Go vanilla! Elem.parentNode lets you select label from the input, no need for a framework.
This is the best of all the answers
my question isn't what'll work and what not. it's "lightweight and fast frameworks or rather libraries". only for backend
Which as has been recommended, Express, or Hapi, or Fastify, or Polka.
nope, that's what i mean. we did the entire UI in XPT (XML Presentation Tier). They moved to jsp after that and then they moved to spa (javascript) which is when I interviewed there the 2nd time around.
For the love of god, if your use cases are that example don't burden the user with downloading a framework. Just use regular ol' JS. (Few examples already among the comments)
This is the correct answer. You don't need a framework or library of any kind. 
 tag`a` doesn't return a string, it returns an array. This is because the first parameter to a tag template literal is supposed to be an array, not a string. function tag(template, ...values) { return template[0]; } There, I fixed the function.
with a lambda function, it can.
This.
That.
Having used all three, I tend to find myself using Mocha by preference - I see more of it out there and it just 'makes more sense'. Not a very technical answer, sorry! 
Ummm not really. This works based on the `value` attribute, i.e. what's in the original markup, not the current value of the input. https://jsfiddle.net/1crf4gqj/1/
Thanks! I am, and have always leaned towards mocha. The ability extend your tests with other frameworks makes it a very interesting framework to look into. Is it mature enough, you think?
That's just a simple polyfill away, fortunately. DOMTokenList.prototype.toggle = function(token, force) { if (1 in arguments &amp;&amp; !this.contains( token ) === !force) { return force; } else { return original.call(this, token); } }; [Found here.](https://gist.github.com/matijs/d1e0bdce90b507b9dbe7e280a34f0e59)
Vanilla ES6 https://jsfiddle.net/1xyrcd8v/6/ const labelClassName = e =&gt; { e.target.parentNode.classList.toggle('has-data', !!e.target.value) } [...document.querySelectorAll('input')].forEach( input =&gt; input.addEventListener('input', labelClassName ));
I believe so, good support base and active community of users. Of course 'maturity' is the time in a systems life-cycle that falls between 'new and exciting (and broken)' and 'outdated'. In Javascript, this fleeting state is occupied for seconds only.
I really like **TestCafe** as it is the new kid on the block and is simply the best: \- It has framework specific extensions for React, Angular, Vue and Aurelia that let you use component names as selectors. \- Integrates seemlessly into my Continuous integration method \(I use CircleCi but I think it works well with other tools too\). \- I really liked the ES6 way of writing tests. My test files look way cleaner compared to Selenium for example. \- It works with every browser \(compared to Cypress that only supports Chrome / Firefox\) and it even has mobile support. \- Testcafe runs on node, so you can call your node server from here \(If you use one\) to clear fixtures, etc \- Testcafe\-live was released a while ago which enables you to see instant feedback when working on tests
If you want a framework, my advice would be Vue.js (somebody else already posted a nice snippet). If the only stuff you need is something like that, you could go vanilla: &lt;label&gt; &lt;input type="text" onkeyup="javascript:this.parentNode.className = this.value.length ? 'has-data' : '';"&gt; &lt;/label&gt; 
To make strong foundation you might start with this http://javascript.info/native-prototypes
Mocha has the widest 3rd party support for all kids of reporters, plugins, patterns etc, and it works well with Chai.js and it's various assertion extensions. qUnit and Jasmine ain't bad but a little more limited.
I‚Äôve been using it for the past two years in production and it‚Äôs been awesome (especially when combined with React). Meteor gets so much hate for absolutely no good reason. I‚Äôd recommend to anyone reading this that they give Meteor an honest try and go into it without any assumptions.
You're right but I like the fact that `.length &gt; 0` is more explicit, though. It shows that your intent is "something should be in the list".
Mature? All three you mention are from the node.js early days so as mature as JS libs can get.
Hi, I don't know that learning a framework is a good mindset to have. A framework is a tool, not a language, and I think that's an important distinction. I think it's more apt to say that you "understand" a tool, which comes after learning the language that it's built on. If I was voting for what I think you should learn, it'd be foundational concepts. I'd love for you not to make the same mistake as me. While I think Vue and React are fantastic, I really can't recommend starting out with them. you'll get sucked into some behaviors you don't understand and battle that for years. That's not to say you shouldn't learn them, either. you should learn all of them. each are valuable in different ways and excel at different things. Don't try convince yourself that one framework is better than another - Instead, spend that energy deciding which is good at what, and why. Hope your quest goes well. And I would like to vote for Cycle.js
I wouldn't call what I see here elegant by any stretch of imagination. Terse? Maybe. Elegant? Absolutely not.
In React I would probably make a stateless component for this, e.g. const LabelInput = ({ value, ...props }) =&gt; ( &lt;label className={ !!value ? 'has-value' : '' }&gt; &lt;input value={ value } {...props} /&gt; &lt;/label&gt;); and manage state up in the parent, but now it's out of scope of this question :)but something like this: class Form extends React.Component { constructor(props){ super(props); this.state={ inputValue : "" } } updateInput(e){ this.setState({ inputValue : e.target.value }) } render(){ &lt;LabelInput onInput={ this.updateInput } value={ this.state.inputValue }/&gt; } }
Or something like SvelteJS, which compiles down to frameworkless code.
You might be interested in this https://www.sweetjs.org
Thank you @name_was_taken
Great explanation!
As someone who did I'd recommend to not waste time on Meteor and use something more extensible and widely used.
Can someone explain this?
"Classes" aren't fixed after they are defined like they are in traditional OOP. You will be thinking something is immutable, when it's not and that is quite a cause for concern. Purely out of ignorance. Hey look, I can use a knife as a toothpick... everyone does it so it's fine... I'll keep teaching people it's a toothpick...
why do you say it's not extensible? you can use any npm package you like and you can make your own meteor packages if your prefer that...
Seems like a bit of an edge case but you could always write it like: Promise.all([ a.catch(() =&gt; null), b.catch(() =&gt; null), ... ) or Promise.all(args.map(x =&gt; x.catch(() =&gt; null)) 
There is a really good article on MDN about this topic. A lot of resources below already, but hope this one helps as well, as it really helped me to understand the concept when i first came across it. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain 
Which makes the lockfile useless.
&gt;So please, by all means, abondon yarn. LMAO why would I.
Smarter way to learn javascript. 
If you were working with a relational database, why didn't you use SQL queries with bound parameters?
You know, OSS is not (only) a marketing strategy for big companies. They do indeed profit from being charitable by making tools and software widely available (and improved upon by the community) yet profit from hosting/integrating these technologies on their proprietary platform. It totally makes sense to open source the runtime and user-space from a cloud providers point og view. What I‚Äôm trying to say is that Microsoft isn‚Äôt surviving despite the oss strategy, they survive because of it. And that fact isn‚Äôt lost on them.
Well, Qt Quick relies on JavaScript quite heavily, so they should already be familiar with the language.
You're all wrong.
After having tried Protractor (for Angular), Nightmare, WebDriverIO, DalekJS, and probably a few others, the one I had the most success with was NightwatchJS. With the others I spent sometimes days just getting them set up and with Nightwatch it only took me an hour or two. Runs on top of Selenium, supports multiple browsers, fast, etc.
Why jQuery? That‚Äôs barely less code than vanilla, but with vanilla you don‚Äôt have to load a 200kb library.
I don't think you're being fair here. Does [this](https://www.youtube.com/watch?v=f7en65HkjeQ) look "like it's a Linux app from the 90s"?
I committed to Vue for a major project without ever having used it. Worked perfectly. Either I am really good or Vue is really well done. Spoiler alert, I am not very good. Also used Vue and WS to build a SpaceTeam clone in just a few days.
Yea, my first thought was to use jQuery. This use case is too simple for something like React or Angular but if you go Vanilla you end up in "does this work on IE"-ville.
I think in general if you're someone who needs/wants to use an Secp256k1 library, you already know you want it. And if not, you probably aren't in the target group.
Teacher? 
Good question. I would load it because you're going to use jQuery lots beyond the immediate simplified example. No website is this simple, and for 200kb you remove about a gazillion cross-browser issues and make your life a lot less hassle. It's a fair chunk of code and my preference would be angular if I had lots of this kind of responsiveness in my page, but the question was about frameworks and I was providing the jQuery-ish way of getting it done. 
GraphQL is for querying your 'application', not an actual database. It's used by front end languages (website, mobile) and/or by third parties (other internal teams, external integrations). It's a replacement or aggregator for SOAP and REST, not SQL. I am also using SQL queries with bound parameters on the relational database.
That is exactly what a graphql sceptic said would end up happening when GraphQL showed up! He compared it to a "text box you put your SQL into and call it an API".
Multiple calls argument is moot with HTRP/2 and server push.
I didn‚Äôt recommend php or asp over nodejs. I said one of the three. Learning TypeScript before picking a framework seems like a great plan to me. We do full stack dev at my work and have completely transitioned to TypeScript. IMO, it is the second biggest advance in app development in the last decade with GIT source control being number one.
What's not elegant about it, care to elaborate?
You can write applications that don't look like that and also run on a fraction of the ram, why would I want something that takes 500mb of ram to render a simple UI?
you know it's coming, unity will probably be the leader here
Seconded. Also you can run them on BrowserStack and actually test your target browsers (oh, hello IE11) no matter what you develop on. 
What would you use instead?
Only negative remark I could think of is the pricing. I wouldn't use it for personal smaller projects
You could say the same of all of these. Why challenge **this** poster on literally answering the question?
Congrats on being kudos'd by Evan You himself: [https://twitter.com/youyuxi/status/1003366017840631809](https://twitter.com/youyuxi/status/1003366017840631809) üëç
NightmareJS with Cucumber (for BDD) works really well. You could replace Nightmare with Cypress.io or Google Puppeteer, but this worked nicely for me. I have blogged about this combination (and background with regards to E2E testing and setting it up in a CI tool) here: https://arothuis.nl/posts/behaviour-driven-e2e-testing/ 
&gt; IMO, it is the second biggest advance in app development in the last decade how so? It just adds type safety. You could just use .net xamarin if youre after that. IMO the real innovations are stuff like react native if you ask me. (Of course typescript is a lot funner to work with than xamarin but you get the point). 
Atom will be a good canary for what Microsoft wants to do with this purchase, if they start shutting it down and pointing everyone to VS Code then all the doom-sayers will have been right.
I stick unit testing + integration testing my react components using Jest and combined with actual manual testing by me, our qa department and the occasional volunteer. I have spent a lot of time working with Selenium solutions (own test lab and browserstack) but in the end there is no solution that provides you with the guarantee that everything works well and looks good. And the time spent using tools like selenium is a complete waste imho, as whatever you test on them should work perfectly using modern dev tools (babel). There are always variations in how html/css is rendered across browsers and the only way to actually catch those is having a human look at them.
Not out of style, it would be very borderline questionable to start a new project with it. In other words, you ware wasting your time with a library whose only real use case today is catering to aging legacy codebases. There's nothing you gain here and nothing you learn that will be valuable in the long term. If you just want to know how to mutate the dom, read up on the web api. If you want to write apps (and in that case you won't ever touch the dom), use a framework.
Super cool! :) Are the rules for a 3D GOL the same as the 2D? If not how do they differ? Regardless, cool little project+visualization! 
I've never seen anyone speak out against refactoring before.
I ask, because I see no point in using jQuery any more. The cross-browser issues are basically nonexistent now with ES6 and Babel.
Whatever you want it to be!
Because I don‚Äôt understand why people still use jQuery. With ES6 and Babel there‚Äôs really no point any more. Whereas frameworks add a lot more functionality that - while still available in ES6 - are packaged to make things easier and faster than writing it in vanilla. JQuery doesn‚Äôt do that any more.
I think it‚Äôs just a contrived example to see how different frameworks solve be same problem.
Funny how very very similar this is to the modern React answer, but with just a slight different syntax (I.e., `ng-class` vs `className`)
Meteor is truly awesome if you want to be productive fast.
Can you explain a big differentiating factor between the two? npm seems to have added some of the features that yarn added first, like lock files. For my uses they seem totally equivalent.
What's your complaint about the query language? It's my understanding that the query language was likely the driving force behind most of the tech.
Throw real exceptions (network failures, data constraint violations), use Sentry as normal on the server. Don't throw expected failures (invalid user input, failed field-level authentication, etc), but instead model the failure states into your schema.
When you need to support IE, jQuery can save your life.
I don't follow, HTTP/2 doesn't offer solution to the cost of multiple roundtrips beyond allowing you to pipeline them all through the same connection. The speed of light is still the speed of light. The whole point with GraphQL (and similar technologies) is that by composing everything into a single query, you can have the GraphQL server perform the roundtrips to the data source (round trips often measured in sub-millisecond times), rather than having the client doing it (round trips measured in tens or hundreds of milliseconds). I wrote a slightly more expanded Stack Overflow answer about this a while ago: https://stackoverflow.com/a/42486327/15687
In VueJS: &lt;div id="app"&gt; &lt;label :class="{ 'has-data': hasData }"&gt; &lt;input type="text" v-model="textInput" /&gt; &lt;/label&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: '#app', data: { textInput: '' }, computed: { hasData() { return textInput !== ''; } } }); &lt;/script&gt;
Cross-browser issues are a lot less prominent, except with IE. IE is still the devil. lol
Babel is the key point here. If you're not transpiling, then you can run into IE issues. IE is basically the only source of serious browser compatibility issues these days, so if you don't care about supporting it VanillaJS is absolutely fine.
Thumbs up for the manual after the focus on the other two for E2E. I think people try and automate it too right away, but really, well designed manual tests can be converted easily, you have to design anyway, and real interaction can find some areas to be sure to cover that aren't captured in requirements.
Thrilling, but the question wasn't "what do you think of these frameworks or libraries", it was just asking how to do it.
Where is the link? 
Yeah at no point on the first 5 pages of Google does CVS return 'Concurrent Version System' to me so???
There's already an Ember example, but I don't think it's a great one. I think the template engine is a nice and elegant one. &lt;label class={{if whatever 'has-class'}}&gt; {{input value=whatever}} &lt;/label&gt;
Switch to 4 spaces for indent? Just kidding. But not really. Personal choice! 
Fair enough. Still, "CVS programming" returns a ton of relevant results. No one is impressed by the fact that you've somehow managed to avoid learning this particular term, nor are they impressed by your failure to figure it out for yourself.
There is a non-trivial amount of code in there so I only briefly looked through it but at a glance nothing really sticks out to me as a major code smell. You‚Äôre using modern JS like async await, relatively short/small functions, etc. What I would start doing though is adding unit tests (maybe I missed these somewhere but I did not see any). This way as you make changes to your code you can be sure you didn‚Äôt break something else. They‚Äôre also a great way to refactor your code when you want to improve it. So when you feel like a particular piece or function is not as well written as it could be, or someone points out a spot for improvement, you can more quickly refactor it without worry. Sometimes you might even write a test and realize ‚Äúoh yeah, why did I write the function like this it could totally be written simpler than that‚Äù Do you have experience with unit testing? If you don‚Äôt or don‚Äôt know how to get started I can point you in the right direction.
&gt; but the last UI release to Bitbucket is an absolute nightmare Absolutely agree.
The real question is will there be a way to import Unity Store assets/models?
Because TypeScript let‚Äôs me have shared libraries and functions that can be refactored with ease. When we were doing JavaScript it was tough to make changes because something might break.
Are you aware of the code review stackexchange? You should post some code of your own which you think could make use of improvements and they will call out every little detail and give you some advice its pretty cool
Man! I wish I had found this back before I had to sort this out myself. I'm glad he really emphasized that prototypical inheritance is fundamentally how JS works on that front. These visualizations are excellent too. I wish more tutorials would do this style instead of just static code and voice. Great link. :) 
I have never heard of unit testing before, but I would love to learn more!
Why not just use npm modules? I get the refactoring part but with JSDocs alone you get amazing IDE support, IMO typescript isnt worth the time unless your team is of decent size.
Ooh, this looks exactly like what I was looking for. I will check this out later, thanks.
Sorry I was using a hyperlink/hidden link, here is the URL: https://github.com/Geekz45679/kBot I will have a read up on design patterns. Thanks.
I'm just being playful. But to honestly answer your question, I'd only choose to write something in Qt if it's an app where performance really matters. Not every electron app is a bloated, power hungry, slow mess like Atom. Look @ VSCode.
As long as you only need to target one version of one browser
 const format = ({ model, origin, angles: { x: ax, y: ay, z: az }, quantity, amount, direction }) =&gt; new Array(quantity).fill(null).map((_, index) =&gt; { const { x, y, z } = { ...origin, [direction]: origin[direction] + index * amount }; return `"model" "${model}" "origin" "${x} ${y} ${z}" "angles" "${ax} ${ay} ${az}"`; }); // returns: // [ // '"model" "abc" "origin" "0 0 0" "angles" "0 0 0"', // '"model" "abc" "origin" "10 0 0" "angles" "0 0 0"', // '"model" "abc" "origin" "20 0 0" "angles" "0 0 0"' // ] const formatted = format({ model: 'abc', origin: { x: 0, y: 0, z: 0 }, angles: { x: 0, y: 0, z: 0}, quantity: 3, amount: 10, direction: 'x' }); `format` returns an array of lines because I don't know how you want to print the output to the screen, just modify it the way you want. It's left to hook up `format` with actual user input. You should definitely sanitize your user input \(`direction` has to be either` 'x`',` 'y`' or` 'z`' for example\).` quantit`y`, amou`nt etc have to be numbers \(us`e parseI`nt\) and bo`th ori`gin `and an`gles have to be of t`ype { x: number, y: number, z: number `}. You get there by e.g: const orig = $origin.value.split(','); if (orig.length !== 3) /* ... */; const origin = { x: orig[0], y: orig[1], z: orig[2] }; A last note: Always handle error cases \(e.g. the value of `$origin` is` '$*foo//x`' but not e.g.` '34,24,23`'\).
I'm getting 4~8 fps for the demo.
Thanks! ‚ó°Ãà 
I feel as though you're upset at me for some reason? Technically, it was "How would you solve this simplest task with your favourite javascript framework?" It makes no mention of libraries. Normally I wouldn't be so pedantic, but you misquoted in order to prove a point. That being said, I understood the question. That doesn't mean I'm not allowed to also have a question, does it? The purpose of public forums such as reddit is to create a dialogue, is it not? I asked a question, and he answered. I made no judgments; I was simply curious, considering the current state of Javascript. That's it.
A structured JSON in a string literal
Vue and React are ‚Äúlibraries‚Äù, too. No one has called those out. 
React.
In that case, why not just use vanilla js? As someone that had to support IE, that worked just fine for me.
You don't have to remove .length. I'm just say you don't have to compare it to &gt; 0 since 0 evaluates to false. Read it as "does a length exist". The only time that's false is when length is 0. Therefore, you don't need to compare. Also, other types, than an array, have a .length method so this isn't only for them. Hope this helps! 
I just moved from a position where we supported IE, and I used vanilla just fine without transpiling. I don't consider myself a Javascript expert by any means, so I feel like it should be rather simple to do.
I am talking about JavaScript for the browser. I am currently doing full stack with ASP.Net but writing more TypeScript than C#. What do mean by worth the time? It isn‚Äôt slower to code than JavaScript? 
Why do you keep downvoting me? Simply because you don't agree? Do you not feel that's a bit childish? Vue considers itself a framework; React considers itself a library. And my issue was not with library vs framework; I was merely pointing out you misquoted.
The way I understand it the core is open source and there are tools that you pay for. However, you can get by without paying for the tools. The tooling just makes some stuff easier. I just use the free stuff myself. :-)
* npm added the `audit` command which yarn has not added yet. (yarn work in progress) * yarn has the concept of `workspaces` for supporting monorepos. just to name a couple different features.
Yeah man you can use private npm modules to share code between projects or components. And with webpack and babel etc. you can use npm modules in your browser as well. And YES using typescript is a lot slower than plain JS. But again, its all about what environment you are using it in. With a big team the refactoring capabilities of TS might actually save time in the end but for smaller teams using plain JS will get you where you want a lot quicker. (You still use typing via JSDocs and code formatting via linters) 
I started with webdriver.io - now I‚Äôm using testcafe. It supports many browsers and it is much cleaner than selenium based solutions.
Yeah, can someone explain to me why it was working in the first place? 
yeah... same as many Java IDEs are advertised as Java IDEs... maybe this email is fake... maybe the lawyers didnt understand what are they even fighting against.
Exactly. This is most likely to be used as a component in other projects, like cryptocurrency wallets or node software. It's also likely to be useful for people making very small cryptographic command\-line tools, and maybe simple public/private key systems on web apps. There's some more detail in the article \(and at the links in the article\).
That‚Äôs not accurate. TS is JavaScript, you can use the any type and do all the dynamic stuff you can do in vanilla JavaScript. There are only few devs on each project at my work. We have all transitioned to TypeScript and everyone loves it. I haven‚Äôt notice any slow down, not sure what you are referring to. Compiling adds like 0.1 second from the time you save until you can reload browser but it‚Äôs barely noticeable.
I downvoted the last comment because I thought it was ridiculous. I haven‚Äôt downvoted any others. 
There are no round trips, the server is pushing the data instead of the client pulling it.
Tabs 4 life!
For each answer you could have an object that describes it, so you could have a property "type" that would indicate whether the answer is Star Wars related or Star Trek related. const answers = [ {answer: 'Yoda', type: 'Star Wars'}, {answer: 'The Enterprise', type: 'Star Trek'}, {answer: 'Star Wars Star Destroyer', type: 'Star Wars'}, ]; const starWarsAnswers = answers.filter(answer =&gt; answer.type === 'Star Wars'); const starTrekAnswers = answers.filter(answer =&gt; answer.type === 'Star Trek'); console.log(`Your result: ${starWarsAnswers.length} Star Wars, ${starTrekAnswers.length} Star Trek`);
But how does the server know what data to push? If I want X and Y, and to know which Y to ask for, I need to get X first; how does this work with server push?
Well, I believe you all love it because you used C# before? In that case its absolutely not a slowdown. Only when you have used JS for a bit and then discover TypeScript. And yes you can use dynamic stuff in TS but why would you use TS then? If youre using plain JS at all then you should use JS in a proper way (proper documentation and common design patterns), then I dont see why you would need TS. IMO TypeScript is just mainly for huge teams and people who arent comfortable without having any types at all. I for instance was able to completely transition to plain JS and have never had any problems with refactoring or what not just by using proper documentation and following my own rules. 
I'm glad you like it :) The rules for 3D are similar to the 2D version, but the 3D one requires a very specific ruleset (5766) to work well. Using this ruleset, there is a 3d glider which is just like the 2D glider except it is two layers deep. Almost all the other 3D rulesets either die out or grow too quickly.
Some `let`s that should be `const`s, some over-usage of unnecessary `await` statements and an over abundance of try-catches - the only thing _really_ bothering me is the try-catch hell, [checkout this SO answer which does a better job at explaining the _why_ than I do](https://stackoverflow.com/a/12609630/587811)
TypeScript is not for only large teams. But you don‚Äôt have to use it, your loss.
Noob here. TL;DR, what does Meteor do?
I thought I was going to like Vue because it seemed like the simplest currently. I have experience with Knockout so coming from that was pretty easy. I then tried React a few weeks later and realized how much better it was. No more random strings in markup, the IDE could actually figure out what I was attempting to do. Implementing Typescript support was a non-issue since it's all just JS. Typescript support in Vue is a nightmare and I regret using them together in a project. Vue just reminds me of a bad combo of jQuery and Knockout now.
One thing to watch out for is that code within try-catch blocks aren‚Äôt optimized to the same extent as code not wrapped in try-catch when on v8 &lt; 6. 
[removed]
Usually, the data pushed in subsequent responses is expanding on the first response. So, if you have a list of things, you might get the list with URLs to each individual thing and then all the items being pushed individually.
There is no such thing as "traditional OOP". Classes in Python, Ruby, and Smalltalk, for example, are also [mutable](https://i.imgur.com/p9Kw815.png), just like JavaScript's classes are. Python has been around longer than Java, and Smalltalk has been around longer than C++.
Ok, and then I could count the number of answer.type for each essentially? Thank you so much. This was bugging the crap out of me that my limited knowledge couldn't figure it out. Thanks a ton!
Looks alright to me, Only thing I would say which is preference probably \- use camelCase for file names \`listsettings.js\` \&gt; \`listSettings.js\`. You do this in a few places so you're half way there. And all I'd say is just use a standard, like Airbnb or prettier
It seems you didn't understand the issue. The fact I've used a template with zero values is irrelevant. I could've written the following, and the result in Edge, Safari, NodeJS 6, 7, 8, and 9, would've been the same: **true** ``` function tag(template, ...values) { // by ES2015 specifications // the template is a frozen Array // unique per each unique static content // represented by any template literal return template; } tag`a${1}b` === tag`a${2}b`; ``` The whole issue is based on that feature detection which used to differentiate between badly transpiled TypeScript code or broken implementation in Firefox &lt; 54. If you keep reading the post you'll notice that now you need to compare per site, not per realm, so that now the check should be written as such: ``` const tag = t =&gt; t; // this is same site, same scope // instead of two distinct // t`a${v}b` === t`a${v}b` const site = v =&gt; t`a${v}b`; // so now to feature detect broken transpilation // of broken Firefox &lt; 54 site(1) === site(2); ``` Above check will return `true` in every JS engine, transpiled either via Babel 6, Babel 7, and/or TypeScript, and in every NodeJS including version 10. I hope it's clear now what changed. It was subtle, and because of that, it broke a lot. If you follow the TC39 discussion you realize they agreed they shouldn't have done shipped such change right away because it broke ES2015 specifications, as contract I've assumed to develop some software on top. Best Regards 
It doesn't use the Unity engine so I don't see why it'd be any easier than importing them into a Babylon or three.js game.
Don't [swallow exceptions](https://github.com/Geekz45679/kBot/blob/master/modules/functions.js#L87). Let them propagate.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Geekz45679/kBot/.../**functions.js#L87** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/modules/functions.js#L87) ---- 
The server you send the GraphQL requests to needs to implement "resolvers" for the queries and mutations defined in the schema. The resolvers are just functions that take input, and inside of them you query your database and return the data.
lol
No problem, if you have any questions you can PM me anytime.
I'm getting 60 fps. Mid 2014 Macbook Pro.
Ah okay I see what you mean, and I do not miss the old days of webdev... Some things are better off forgotten.
I took one glance at the bot.js file, and even though I didn't get chance to go through it, but it looks like I could quite easily jump in and work with the code if I needed to.
How does one go about learning WebGL2?
This is a good first start! Layout wise you're right on the money. Style wise, its a bit jarring. Here are some notes on things you could work on: - Try not to use busy images (such as a person's face) for backgrounds. It can be distracting to the user - Don't center align text large amounts of text. This is actually pretty difficult to read in long format. - Just like on reddit, no one likes a wall of text. Breaking out your writing into logical parts and separations makes more sense than all the info all at once. Other than those stylistic and UX issues, you seem to be on the right track!
It's AngularJS with nicer syntax.
And took us 1/2 day to migrate to our very large enterprise app away from those methods. That's hardly a reason to give up on React.
Any reason you didn't just do this? {{input value=inputData}}
I didn't talk about the values at all. The first parameter is an *array*, not a *string*. It is an array of strings. You are returning it directly, as an array. When you check 2 arrays against each other, they don't match. ['a'] != ['a'] As my updated function shows, you can return the first string from the array of strings that the function gets and get the expected output.
Send a HTTP GET request to the file location.
I like to split up my code into three parts, the executable code, state, and functions. Usually what will happen is that as I write my executable code, I'll start abstracting code bits into functions, and those functions most of the time will have shared state. Here is an example of what that looks like in javascript. function OperationsFactory() { //state declarations var a = 1; var b = 2; var c = 3; //functions return { sum: () =&gt; a + b + c, difference: () =&gt; a - b - c } } //executable code var operations = OperationsFactory(); var d = operations.sum() + operations.difference(); The same can be done with the class syntax, just placing your state declarations in the constructor (with class syntax you get the added benefit of being able to access the functions on `this` which allows me to run some of my executable code in the constructor if I feel it's necessary) 
Totally agree, can ascertain meaning in a glance this is way
what controls move?
~60fps chrome/mbp what browser/machine?
I see, my bad ;-) i misread the title, sorry
no, you need to revise the basic concepts here. yes http2 makes it much less expensive to do round trips, but it's still MUCH better to have a single trip with graphQL than multiple efficient trips with http2.
k 2 arrays against each other, they don't match. you keep not reading the specs or understanding the issue. The returned array is unique per template literal object, that has been the case since ES2015. Do you understand ??? You return the Array, not the string, not the join, the Array and its' the same object in NodeJS 6 to 9, Safari, Edge, and Chrome before 66. This changed and the change \*\*still\*\* return the same array if it's per site instead of realm.
Can they just make meteor\-client\-bundler an official feature already? I absolutely could not be less willing to use Meteor's outdated, awful client\-side compiler or serve capabilities. Angular, React, and Vue have had dynamic polyfill generation forever. This isn't remotely exciting, it's more sad than anything that they refuse to work towards integrating with first\-party tools at all.
45+ FPS on my ancient ThinkPad from 2012 (Intel HD 3000). Are you trying to run it on an IoT toaster?
That's because everything they're doing on the client side is an idiotic mess. You can't use actual framework tools without hacking the Meteor client out with a loosely maintained, 3rd party package. There is so much unique and awesome about Meteor and its DDP system and it's hidden under a swamp of "do it all mentality" and poor development focus. As they wax about how this minuscule size optimization is "one of the most powerful features added" I have to seriously wonder if they know that things like AOT and tree shaking exist.
Easy there Satan.
Most frontend frameworks actually are implemented on top of this technology!
All frontend frameworks are built on this ‚Äútechnology‚Äù...
I have this general impression that people who come to React from 'above' the stack (those accustomed to templating and plain CSS) or 'laterally' from long-established technologies (JQuery for example) tend to dislike it, and people who come to React from the stack below (Python in my case, PHP, general backend etc.) tend to fall in love with it immediately.
Does nobody Google their project name? https://www.luna-lang.org/
Meteor has had dead code elimination for a long time
I'm just playing, you made it sound like an assignment. if you look at the JavaScript file in that link you'll see how you can do it without rewriting the same code
Whoops, uses tabs not spaces, there goes half your audience... But seriously, there's nothing like glaringly wrong here?
Haha I spent like a week coming up with name ideas. The way I see it there are only so many names to go around. In fact on NPM there are around 700,000 packages and names there have to be unique so it basically rules out everything. I tried about 20 things before settling on Luna. I‚Äôm not trying to compete with Luna Lang but if you google Luna, even that project does not come up until page 3. My goal is to come up if you google ‚ÄúLuna JavaScript‚Äù
Thanks - so yeah that's the part that I'm always curious about. Are there any guides on how to implement such a resolver? It seems like part of the complexity is turning a set of " I want this data " into queries for every possible combination of data to fetch.
Google chrome, Arch Linux Nvidia 1050 ti. Will troubleshoot on my end.
So, in that example he should throw the error again? Or maybe the try/catch should be in the caller?
What If you want to change the value?
hence why the parenthesis ;)
Got it! üëåüèª
In this example, yes. also, "propagate" does not mean "rethrow" ('he should throw the error again?'). propagate just means "leave it alone"; (also, by "swallow" MoTts means he's returning the error to somewhere and since _it returned_ it won't be caught again by another handler. if you had one try-catch inside another, only the second one would catch that throw. (simple) example of non-swallow: function throwError = (s) =&gt; throw s; try { throwError('hello'); } catch (e) { console.log('got error and didn't swallow it', e) } (simple) example with re-throw: try { throwError('hello'); } catch (e) { throw e; }
Me too :). I'm not sure whether functional programming picked it up from the identity matrix, or if there's a common root.
Really can‚Äôt believe people actually promote to use Angular or React for this. For these tasks use NO framework. Just Javascript. This is basically: var label = document.querySelector('label'); var input = label.querySelector('input'); input.addEventListener('input', function () { if (input.value) { label.classList.add('has-data'); return; } label.classList.remove('has-data'); }); This is just one of the many simple ways you can do this without frameworks.
I think most of the GraphQL libraries make it easier than you're expecting. Adapting an example from https://www.howtographql.com, take this GraphQL query. ``` { allLinks { id url description } } ``` Your resolver could be like this (Node.js w/ knex query builder): ``` function allLinks() { return knex('links_table').select('*') } ``` The GraphQL library will take care of only returning the fields you asked for, even if that SQL query returned a bunch of other stuff. I'd recommend reading some tutorials on that link above. Not sure what backend language you prefer, but there are libraries for most of them which include guides for getting started.
Yeah that makes a lot of sense. I've been a C# dev for 6+ years now so the additional structure to JS via Typescript and to markup/components via React is a blessing. With it it really does all finally come together and make sense for the first time rather than a bunch of seemingly mashed together technologies to somehow output a UI.
thx
super cool, great way to learn.
My guess was that when the spec for tagged templates was finalized by Ecma TC39, tagged template literals were *supposed* to be *literally* **literals**. The thing about literals is that they are often not only unique, but two distinct references to the same value should be equal to one another, just like strings, just like numbers. The other advantage, here, is that the only way to implement tagged literals would be through the use of WeakMap. This means that there can only ever be *one* instance of a tagged literal. This should result in fewer memory usage.
*woosh*
I see. Seems like if they really intended that to be part of the spec (I'm not seeing that anywhere in the spec, but I've never been great at reading specs) they'd probably want to introduce a new type that, say, all tags had to return. I guess I do sympathize that changing the behavior silently can be disastrous, but I question the judgement of ever relying on this edge case.
it's both in the post and [also linked](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-gettemplateobject), read 'till the end on the notes of ES2015: &gt; Each TemplateLiteral in the program code of a realm is associated with a unique template object that is used in the evaluation of tagged Templates (12.2.9.5). The **template objects are frozen** and the **same template object is used each time a specific tagged Template is evaluated**. If that's not clear I don't know what would be.
"Wrong" may be too strong a word. Following are some suggestions which you (or others) may or may not like. Sometimes they are not an instantly apparent improvement, but looking at it with a longer time frame they do contribute to general improvement of the code. ^(Small note: There are also some other concerns, like extracting constants and other similar things "best practices" which I won't mention here. They _are_ interesting, but I'm going to concentrate on just one thing: Levels Of Detail) I'll look at https://github.com/Geekz45679/kBot/blob/master/events/message.js. I chose this at random. There's nothing _particularly_ "wrong" with it, but it also isn't particularly good in these aspects: - It's a single function on 50 (long) lines of code. - It is _very_ process oriented, very linear. - It doesn't introduce any semantic constructions that might help explain itself. - It does quite a lot of things. Or in other words, it gets some input, twiddles around with its parts, and finally executes an action (a command). `message.js` [seems to be an event handler for the _message event_](https://github.com/Geekz45679/kBot/blob/master/bot.js#L64-L74). Now, the first thing I would try to consider is this: This is doing a lot of different things. In general, I would like an event handler such as this one as being as close to this following pseudo-code as possible: function eventHandler(client, msg) { if (!relevantMessage(msg)) return; let action = process(msg); if (!valid(action)) { signalInvalidAction(); return; } let result = execute(action); processResult(result); } Note that in the empty lines we may _need_ some additional processing or whatever, but for now, this is enough. And also note that I don't mean "follow this general schema", but actually "stay at this specific **level of detail**". Let's look at one specific example: On [line 4](https://github.com/Geekz45679/kBot/blob/master/events/message.js#L4) you have this: if(msg.author.bot &amp;&amp; msg.content.startsWith('k!') &amp;&amp; msg.author !== client.user &amp;&amp; client.user.presence.status !== 'invisible') return msg.reply(':warning: Bots can\'t run commands!'); Now, this, as is, is at least one or two levels of detail _below_ what we want. Instead it would be better (for our current meaning of "better"), if we had something like this: if (isBotMessage(msg, client)) return msg.reply(BOTS_CANT_RUN); And, somewhere else, we had... const isBotMessage = (msg, client) =&gt; msg.author.bot &amp;&amp; msg.content.startsWith('k!') &amp;&amp; msg.author !== client.user &amp;&amp; client.user.presence.status !== 'invisible'; In fact, we could/should take it a bit further; just giving it more meaning. Like `msg.content.startsWith('k!')` might be better represented as `isCommand(msg.content)` (I'm guessing a bit, ok?), or `msg.author !== client.user` as `!ownMessage(msg)`. After a bit this could be written as something _like_: const isBotMessage = (msg, client) =&gt; isBot(msg) &amp;&amp; isCommand(msg.content) &amp;&amp; !isOwnMessage(msg, client) &amp;&amp; !invisible(client); ^(Again, I'm guessing a bit about the exact names and meanings of things so they may not fit exactly) We continue down on the message.js file/function and find a whole block which I couldn't immediately get all of it's intricacies: if(msg.guild) settings = msg.settings = await client.settings.get(msg.guild.id); if(!settings &amp;&amp; msg.guild) { try { await client.settings.set(msg.guild.id, client.config.defaultSettings); settings = await client.settings.get(msg.guild.id); client.logger.log(`Loaded settings for ${msg.guild.name}`, 'loaded'); } catch (e) { return client.logger.error(e.stack); }; } else { settings = { prefix: 'k!' }; } This whole things _seems_ like something that requires certain knowledge about Discord (guild?), but anyway... It seems like this whole thing tries to produce a `settings` object and that it depends on that `msg.guild` thing and on the `client`. So, we might extract it and substitute it for a line like... settings = await getSettings(msg.guild, client); I've opted to allow any exception there here to bubble up. You may or may not want that. If you don't, then do take care of processing it. If not, it will bubble up to wherever it is relevant to acknowledge it. Anyway, now that we have settings... if(msg.content.indexOf(settings.prefix) !== 0 &amp;&amp; msg.content.indexOf('k!') !== 0) return; Two things. One is the same as before: giving it semantic meaning, we could extract this to `if (!isBotCommand(msg.content, settings)) return;` or something similar that let's us express ourselves at such a level of detail. With all this about level of detail, what I'm trying to communicate is that you _want_ to write at different levels and you _don't want_ to mix the levels in the same function. You want the level of detail in a function to be as _meaningful_ as possible and as _uniform_ as possible. The second thing there is that `'k!'` constant there. It's the third time it has appeared. You should put that kind of thing in a constant somewhere and reference it. ^(Small note: I don't completely get why check against _both_ `settings.prefix` and `'k!'`. I hope it does make sense to you, but do ponder if it's really necessary.) [Lines 24 and 25](https://github.com/Geekz45679/kBot/blob/master/events/message.js#L24-L25) could be better expressed (more meaningfully) as something like: let { command, args } = process(msg, settings); Ok, I think it's enough, right? The other half of the code (and, of course, the rest of the files) could go through a similar process. In the end, the main handler function should probably end up being something like 10-15 lines and it should all read in a high level, uniformly expressive way. Note that I know all these things seem like small stuff, and that not everybody likes it. Your original code is _fairly linear_ which makes it _fairly readable_. But what does doing it this way contribute? What you get in return for the effort is this: We have separated our code in different levels of detail. This makes it easier to reason about or code in two main ways: - Having a more general level of detail means we can reason about the general process without affecting the details. Should we, idk, `[msg.flags = extractFlags(args)](https://github.com/Geekz45679/kBot/blob/master/events/message.js#L45-L48)` here or should we do it before? You're not thinking about what "extracting the flags" entails, just the action itself. That is, we have different concerns when we think about different levels of detail, so separating those, means that when we concentrate on one such level, we will only (hopefully) be modifying that piece of code, and we will be thinking at a more uniform level of detail, which helps for better reasoning. - Having separated those details in separate pieces, means that they don't interfere with each other. That is, if you separate correctly each operation, then you'll have better guarantee that they don't conflict with each other and that they work correctly on their own. This allows e.g. to introduce unit testing more easily, but not only that. Even if you didn't introduce testing, you would still benefit because changing one piece should not interfere with other parts, if you separated them correctly. ---- Note that all this is both: a. not the end in itself, but a path. It's an evolution in how you write code. It will help you think and write in both more expressive and better structured ways. It may, in time, lead to using approaches such as being more declarative or more functional (which again are not ends in themselves, but tools to have in your belt). b. not easy or immediate. This is something which you have to exercise. It doesn't come instantly in a natural way. A good exercise, is to follow what I've sketched above: go through code you have already written; try to cut it into meaningful chunks; extract pieces and define different levels of abstraction. Do this again. Even with new code. Reserve some time, after writing some code, to go over it _refactoring_, extracting and expressing meaning. (There are some additional techniques you might try to investigate. Search stuff on _refactoring_, on _unit testing_, on _TDD_ (even if you don't end up doing TDD), on _[wishful thinking design](http://wiki.c2.com/?WishfulThinking)_...)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Geekz45679/kBot/.../**bot.js#L64-L74** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/bot.js#L64-L74) * [Geekz45679/kBot/.../**message.js#L4** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/events/message.js#L4) * [Geekz45679/kBot/.../**message.js** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/events/message.js) * [Geekz45679/kBot/.../**message.js#L24-L25** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/events/message.js#L24-L25) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e05p57n.)
This convention is widely used in frontend development. React uses it for applying inline styles, jquery uses it alot, 1 example is when you pass an object to .attr to apply multiple attributes at once. 
hmm, on windows it creates the same thing as a symlink, that is a shortcut basically. That means it reflects the changes made, which i verified 5 minutes ago. Maybe it differs on system to system?
Possibly went offline? https://github.com/npm/registry/issues/349 I didn't have any issues an hour ago but it may have happened since then, or possibly an accidental wipe of stats for today.
I like the idea but i'm not sure how much time i could dedicate to a project like this. If you find other people and start something, i would definitely be interested in seeing it and maybe contributing every once in a while. Also, i think people would be interested in what kind of project this would be, a website, a game, a CLI tool? Or you don't know yet?
People who come from php tend to love React? The most popular php framework currently, laravel, ships with Vue by default. How many other backend frameworks do you know that ship with a default frontend framework? Clearly php as a community prefers Vue.
Next week on Medium: &gt; Micro-Frontends are sooooooooo last week. ***This*** is the one true solution of all solutions!
thanks, bruh
Okay, I guess I didn't and still don't really understand what a `TemplateLiteral` is, or what `GetTemplateObject` refers to. When I read really closely and try to understand it as well as I can within the context of this post, I believe what this is saying is that the first element of the tag function is not actually an array of strings (as the MDN documentation suggests) but rather this specific object called a `TemplateLiteral`? Or is it suggesting that the return value of the tag is somehow always frozen and memoized, and I guess side-effects would be ignored (this seems less likely, but the excerpt doesn't actually clarify)? In response to "If that's not clear I don't know what would be.", I'm actually pretty surprised you think that's the clearest possible way of describing it. I clearly don't know what "GetTemplateObject" is or what significance the specific term "TemplateLiteral" has. Neither of these topics is covered in the original post and they seem pretty abstractly covered in the spec itself: GetTemplateObject is described as being "is called" but it's never described when, why, or by what it's called. I'm sure if I dig deeper and figure out, for example, what "ArgumentListEvaluation" is, I could figure it out, but I really think there are clearer ways that the article and you could be describing it.
Use onInput and onChange handlers and it should work for all major browsers. IE10 had a similar design choice.
All frameworks are frameworkless code, even ones built from frameworks.
Most likely a web application. Right now we are brainstorming ideas, but someone suggested a Git\-based/ version control note taking app that uses Github/Gitlab or Bitbucket API's. We are open to discussing new ideas if anyone has a specific project they would like to work on.
That‚Äôs like saying that you prefer being hungover because you drank too much the night before. It‚Äôs just an icky side effect of opinionated software.
I see, so the gist is to use some ORM library. I've tried a few in the past but mostly just use the plain old node-mysql connector with queries. I'll have a look into some of those more, but I haven't yet been keen on abstracting some of the DB interaction to a ORM. Granted, my use case right now is rather simple and I could see the value in an ORM for other use cases.
yeah, but you can become a player if you get in on the ground floor of something new
great answer here folks 
No, its because react doesnt play well with server side rendered html. Since react cannot parse/compile html, React must start with an empty container (like a div) and then react can take over and render the html from there. This problem doesnt exist with Vue.
it's clear if you understand what is a template object. Quick recap here: * when you write `` `anything${'here'}!` `` you are writing a template literal. It starts and end with a back tick. It allows multiple lines and interpolations, which are not like `eval` or `Function`, are actually scoped JS like any other. * when you write `` fn`anything${'here'}!` `` you are implicitly invoking a function/method that is usually referenced as **tag**. Tagged template literals are all template literals that are implicitly passed along a function. * such function will be invoked with at least 1 argument, up to `1 + amount of interpolations + 1`, because interpolations always have surrounding _strings_. Please stay focused on the third point: ```js function tag( templateObject, // a frozen array // always unique // representing the static // parts of the template literal ...values. // zero, one, or more interpolations ) { console.log(templateObject.join('-')); console.log(values.join('-')); return 'whatever'; } ``` Now hopefully is clear what is a `templateObject` and here some revelation, you can test today in Safari, WebKit, or Edge. ```js tag`anything${'here'}!`; // it will log the templateObject // it has length of 2 so // its join will produce "anything-!" // there is only one interpolation // joined extra arguments will produce "here" // the returned value will be the string "whatever" ``` Now, for the last 3 years of specifications, including Babel transpiled code, writing the same template literal, passing through a function, in different places of your application, and even in different files, would've **always** provided to that tag function the same `templateObject` because its static representation is **always** the same. Who you think about it, it makes sense, same sense two strings are always identical even if defined in two different files. With bundlers and Babel preserving this behavior, this has always been the case until latest V8, and probably future Safari, will ship a different version of the template literals that will not provide exact same `templateObject` even if two template literals are identical. This means: * if you have a library like hyperHTML (or lit-html) that parses DOM stings once per `templateObject`, you might have cases where parsing is executed multiple times because the relation static-content =&gt; `templateObject` might be broken * if you support legacy browsers and you are relating via `WeakMap`, instead of a `Map` that has been sufficient for the last 3 years, being `WeakMap` impossible to polyfill on frozen objects your legacy targets will have memory leaks forever, while before this change, it was at least contained into the amount of template strings, but never more than that. I hope I have better explained what is the issue and why I wasted time to write a post informing developers about it: it's not by accident that I was using the frozen Array, it was the best / handy part of ES2015 template literals, even if not super memory friendly in the long term (but again, unless you were evaluating new templates each time with different content it wasn't too bad, now legacy browsers are broken instead). Best Regards 
React: updateState = ({ target }) =&gt; this.setState(() =&gt; ({ input: target.value})) render() { &lt;label className={state.input ? 'has-data' : ''}&gt; &lt;input value={state.input} onChange={updateState} /&gt; &lt;/label&gt; } Vanilla: const input = document.getElementById('#input') const label = document.getElementById('#label') input.addEventListener('change', e =&gt; { label.classList.toggle('has-data', input.value) })
&gt; This new modern/legacy bundling system is unique to Meteor, for now. No other framework (to my knowledge) has anything like this I know I'm just nitpicking, but Polymer has had this for a while now.
Of course, because free software is cheaper than paid software, and it encourages early adoption of new technologies. It‚Äôs essentially a freemium model where only 1% of their software is open source. They then benefit from the free labor of developers they didn‚Äôt need to hire to produce software that they then charge for. That‚Äôs fine and makes sense. Does that mean they should own the entire platform that supports the majority of OSS? No, but they did need to be perceived as being a part of the community so they could convince people to not jump ship when they planned this purchase. A 3-5 year strategy is very short-term. With that leverage, they can then control the community that has threatened their model for so long. Whether the purchase turns out to ‚Äúnot be so bad‚Äù as others have said, is actually impossible. Sure, GitHub may actually see an improvement in quality, but the data that Microsoft is able to collect through this platform is insane. It gives them a massively unfair advantage over other proprietary vendors. It isn‚Äôt simply about surviving because of OSS, it‚Äôs about abusing OSS because they own it.
Of course, because free software is cheaper than paid software, and it encourages early adoption of new technologies. It‚Äôs essentially a freemium model where only 1% of their software is open source. They then benefit from the free labor of developers they didn‚Äôt need to hire to produce software that they then charge for. That‚Äôs fine and makes sense. Does that mean they should own the entire platform that supports the majority of OSS? No, but they did need to be perceived as being a part of the community so they could convince people to not jump ship when they planned this purchase. A 3-5 year strategy is very short-term. With that leverage, they can then control the community that has threatened their model for so long. Whether the purchase turns out to ‚Äúnot be so bad‚Äù as others have said, is actually impossible. Sure, GitHub may actually see an improvement in quality, but the data that Microsoft is able to collect through this platform is insane. It gives them a massively unfair advantage over other proprietary vendors. It isn‚Äôt simply about surviving because of OSS, it‚Äôs about abusing OSS because they own it.
Thank you. I really appreciate your patience in explaining this to me, and I believe I understand much better now. I have one favor to ask, which is that you might re-format your code to fit Reddit's markdown standards which are much more annoying than most as they do not respect the \`\`\` code blocks, so I can't actually read your full code examples as they go off my screen. You need to prefix every line with four spaces. I do have one question which is somewhat unrelated. In the example of: function tag(templateObject) { return templateObject; } const one = tag`string`; const two = tag`string`; According to the original specification, would the uniqueness be preserved such that `one === two` because the static parts are the same, or are they different because they're called on different "instances" of the string? I know/believe in unoptimized C++, for example, this will result in two instantiations of C-strings in the text section with different pointers, so you'd have to do a deep comparison. However, it's not entirely clear to me how JS (with no text section) would be able to always tell that these two strings are the same without doing regular deep comparisons to see if the two strings are identical.
I'll join if you can get a couple people together for it or even us two if you want to get something down for the resume. Currently I am a Java developer. I've started doing JavaScript tutorials lately to learn the language &amp; related frameworks as that is where it looks like a good chunk of freelance development is heading. My weak points would be on JavaScript development so I'd be hoping to get feedback on the items I contribute. I do have experience with the team oriented items you listed though.
I don't personally use an ORM either. Knex is just a nice library for building dynamic SQL queries. Most of the tutorials for GraphQL use ORMs, but it's definitely not a requirement.
I'm not gonna tell you... ?
Hi /u/fk_the_system, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/evilsniperxv, For javascript help, please visit /r/LearnJavascript. Thank you!
It‚Äôs just so concise. The shorthand in the markup is also so nice. @handler=‚Äúhandler‚Äù :attribute=‚Äúvalue‚Äù So simple. And the docs? Unmatched. They are the best docs I‚Äôve ever used. Then, of course, making plug-ins and add-ons is super trivial. I made one that adds a uiState property to each VM which is either ‚Äúmobile‚Äù, ‚Äútablet‚Äù, or ‚Äúdesktop‚Äù in like an hour or so. It‚Äôs seriously an awesome framework.
This is a terrific idea! Work has me pretty bogged down this month, but in the future if things die down a bit I'd love to join in. I'm a full stack engineer, and would love to practice with some modern frameworks, so if that's something you'd like to explore as well let me know! :\-\) 
Testcafe is excellent and easy to reason with. 
I'm just learning Javascript after years in Java/Python and would love the experience of a project in JS before I start mine up at work. Keep me in touch.
I started a slack channel. PM me your email for an invite.
loadCommand shouldn't have a try/catch at all. If an exception is thrown, just let propagate. The [call site](https://github.com/Geekz45679/kBot/blob/master/bot.js#L54) should _maybe_ have a try/catch, but that depends on what the right thing to do is if loadCommand fails. Do you want to ignore the error and keep going? (Probably a bad idea.) Or do you want to skip just the one command file and continue iterating over the rest? (Catch the error, either log it or invoke an error handling callback, then `continue` to the next loop iteration.) Or should the init function itself indicate an error condition, that init couldn't do what it promised to do? (Then no try/catch even at the call site, just let the exception propagate.)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Geekz45679/kBot/.../**bot.js#L54** (master ‚Üí 4acc039)](https://github.com/Geekz45679/kBot/blob/4acc039acf4ec75820661bac2ef4c8df3b1abbab/bot.js#L54) ---- 
for the last 3\+ years, \`one === two\` would've always returned true, and this was per specification. Node 6 to 9 does that, and so does every browser beside Chrome 66\+ and recent Firefox. Before, the syntax parser would've collected on the go all template literals parts and associated them to the same \`templateObject\` no matter when, or where, these were encountered: this was per realm \(which is in few words the sharing of the same global scope\). Now it's done per site \(which is in few words sharing of the exact same position in code as in a function\). I am a developer that reads, and advocate, specifications, and when it comes to JS \(but also other languages\) I do \*\*never\*\* compare with other PL because they are all different, and I don't care about others behavior, I care about understanding the PL I am using at that moment. P.S. I see the post correctly so I am not sure what I should do to improve the code.
&gt; P.S. I see the post correctly so I am not sure what I should do to improve the code. Got it -- I was on the pre-redesign site. The redesign seems to include this markup enhancement.
&gt; (seemingly) I think it is just their reporting having problems. I see that NPM is having problems at the moment too, but for example the react-native-maps going from ~45000 one week to 0 the next isn't really possible. 
I like the idea as well. I could probably swing 10hrs a week... Message me?
&gt; I am a developer that reads, and advocate, specifications, and when it comes to JS (but also other languages) I do **never** compare with other PL because they are all different, and I don't care about others behavior, I care about understanding the PL I am using at that moment. Regarding this note in particular, I completely understand. The reason I bring up C-strings is essentially because I didn't know the words "per realm" and "per site". A design as I was suggesting in which you compare C-string pointers would essentially relate to "per site", which I believe is easier/more-efficient to implement from an engine (in JS) perspective as you don't have to have a global cache of strings to look up. However, I think the usecase you're referring to actually results in a greater need for this "optimization" at the engine level, for the reasons you're saying, and so the change does not seem to account for it.
unit testing is a must have in the professional world. any library of decent use will also have unit tests or functional tests. easiest way to see if your code works, or if you broke your code with a recent change. it will also more easily point out where in your code you did a shitty job, because that code will be a pain in the ass to test. could start to look into test driven development, or just unit testing with something like mocha/jest/chai/sinon (so many javascript testing frameworks to choose from).
Thanks for the detailed response. Always enjoy your posts.
You need to reverse the signs in lines 86 and 87. Also your ball speed just alternates to 1 and negative 1 each movement. Making ballspeedY be negative currently does nothing, but a hit is detected if you at least reverse the signs as mentioned
Im not sure if I missed it when I quickly glanced over the code, but I didnt see any collision dection.
What is the alternative to call backs and promised? This is a genuine question I want to learn.
if(ballY &gt; 790) { if(ballX &lt; paddle &amp;&amp; ballX &gt; paddle+paddleWidth){ ballSpeedY = -ballSpeedY; } else { ballReset(); } }
we should bake a bunch of rasberry pies
&gt; Note that the this.__proto__ === ... lines are true only when the functions are called with the new operator. Nitpick: this is not true. You can also use [Object.create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
I'm actually really interested in taking part in this in a project manager scope if that spot is still open, and enough people end up being interested that having a project manager would be useful. I have a little experience doing project management of design &amp; development projects in an agency context and would like another item to put on my resume :\) I can also do some light contribution\-\-I have high beginner knowledge of Javascript\-\-but I would prefer to help with the coordination aspect more than anything else.
Oh yes of course. Getting that deep into testing is way too far at that level. I could've clarified that I meant learning unit-testing and not much further. Haven't actually thought about doing a whole test-suite with int &amp; e2e - cause I had a tester doing that most of the time :P
I kinda like having strings in the markup. It lets you see behavior of the application without having to dig through mountains of JS
Correct!
Absolutely, the main goal I want out of this is for people to step out of their comfort zone and gain some experience and confidence in something new. The project itself will just be a tool we can use to do that, rather than an enterprise quality piece of software.
I‚Äôm not sure if you‚Äôre confused or meant to reply to someone else. I don‚Äôt care about your opinions on why one might be better than the other. Other frameworks don‚Äôt include one because, most of the time, it‚Äôs just unnecessary bloat and coupling.
Very cool!
Check chrome://gpu
42 fps on my phone.
.. which I very much appreciate as delegating past unit tests keeps me employed. lol ;D
No disrespect, but your first paragraph tells me that you don't have the faintest clue how OSS operates in enterprise / commercial market. It certainly is not a freemium model where only 1% is open source. I'm sure you know this but one of their largest investments in the developer community is, in it's entirety, available for everyone [no strings attached](https://github.com/dotnet/core/blob/master/LICENSE.TXT). That includes the [platform compiler](https://github.com/dotnet/roslyn). Secondly, it's asinine to suggest that MS is doing this with the intention of ripping off 3rd party developers. Yes, they benefit from the community working together solving a shared problem, but that's exactly the point. It's the same forces that drove node.js to become one of the most popular developer platforms, not because Joyent conveniently needed some free labor but because the community needed the software. Open Source Software is very rarely "software as a service" applications, but rather utilities, libraries, platforms, languages that does not solve a single purpose in a narrow domain. On the other hand I wholeheartedly agree that one should be weary of putting too much power in one basket. The potential data gold mine under the hood of GitHub is quite scary in ms hands. I'm aware of the possibility that this acquisition will fragment the overall community and many big players will migrate to other platforms. But we don't know yet how involved Microsoft will be in the day to day operation of Github, maybe it will be a great boost to a poorly performing business or it may culminate in a disaster. We don't know. But suggesting that Microsofts involvement in the OSS community is just a ploy to garner goodwill before striking the hammer on Github is just tinfoil level absurd.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dotnet/core/.../**LICENSE.TXT** (master ‚Üí 51c2ee1)](https://github.com/dotnet/core/blob/51c2ee17df1b9ed9e96aa8fc1ab81d6540c9bcca/LICENSE.TXT) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e060sg1.)
Micro servless front end cloud based apis are the future
Do you have examples of how to achieve this ???
Have noticed this too. Will add that I had several issues with installing modules a few days ago too. 
It's funny, because JavaScript is a bit like this. But actually micro frontends really are the future. They eliminate legacy. You can use React, Angular, Backbone, even jQuery. We have services written in plain old ES6. It all works together, and if something becomes legacy, that's fine, you just update that one part, or else leave it. If something works, why change it right? Disclaimer: I am the author of the article, and I led the migration to micro frontends at Beamery.
Let's hope not üòÅ
48 FPS on mobile. It looks static though.
I'm working on a follow up. Will post here when it's ready. We used single-spa by Canopy Tax. They are good guys and the code is solid. Here's the library. Lots of examples there. https://github.com/CanopyTax/single-spa
&lt;label class="${someValue !== ''? 'has-data' : ''}"&gt; &lt;input type="text" value.bind="someValue"&gt; &lt;/label&gt;
thanks
true, i'd prefer to have competition.
MK Ultra web app
Any concerns with long-term effects of fragmenting the company's skill requirements across a variety of different technologies and standards? I can see this being a problem for devs to context switch, or to be brought into teams where they now have to navigate codebases that don't use the same stack.
This seems to happen from time to time. At least 2-3 times recently. IIRC last time, back in... April? only affected @scoped/packages. They tend to recover after a while and then counts are more or less ok.
I like the motivation behind this article, but it's really not a novel concept. A well-architected system (frontend, backend, wherever..) will consist of small, independent pieces of functionality wired together. When one piece of your system is removed, the system as a whole should not fail, it should simply lose that bit of functionality. It might be easier said than done, but it is a good mentality to adapt, no matter what you are developing on or for. If you are looking for a practical application of this in JavaScript, I'd recommend checking out [cycle.js](cycle.js.org). The framework is constructed in a decentralized way, such that there is no inter-module dependency. every module can stand alone as its own application. This is really exciting, and while cycle certainly helps achieve this, you don't need any framework to achieve it - just disciplined adherence to a few functional principles.
1. "They'll be different this time." LinkedIn is a bad example, given the shady stuff they've done via a vie user privacy. 2. True for BB, but Gitlab can be self-hosted. Besides, Atlassian isn't Microsoft anyway. That's already throwing out the fairly specific distrust of Microsoft. And that's the whole article. Two points, one of which is just "you can trust MS now."
Thanks didnt know about that sub!
NPM went down for a WHILE the other day
I currently do.. my whole first few weeks is basically training. But I'm also entry level fresh out of undergrad .. they should give you time to learn their development stack . 
Super secret master piece, \`SELECT PROJECT FROM SIMPLE\_BEAUTIFUL WHERE SECRET \&gt; 1\` and freaking leak it, it ain't no thang baby. There is nothing impossible here. You are implying that secrecy is a law of physics, a law of a brick wall and thick head, a butter side down fallen piece of toast. I simply wrote a query, out of love for people with good taste in code, I asked them to share some good ideas. It is not tautologically impossible, we call it unterse. (I love you all (kind of), but please don't leak actual secrets people, I don't want to end up on some list of "very dangerous javascripters")
I just remembered another Simple &amp; Beautiful "secret", you might have heard of it: [http://microjs.com/](http://microjs.com/) and what I love about it is that it has the file size of each library in font as big as the title. And it also has GitHub stars as well, it is a brilliant piece of work. There is something truly magical about small libraries. Take a look at [https://github.com/paulca/whenever.js](https://github.com/paulca/whenever.js) which has a fluid non\-DSL\-DSL like so: whenever('Click Me!').is('clicked').then('Change the text to "Clicked!"') it makes one ask, OK, how does the program know how to handle all this? It is a two step process, first you write it out in English\-ish and then you have to write the functions for it. Sounds stupid right? No. That's how [GraphQL](https://graphql.org/) works, that's how [Cucumber](https://docs.cucumber.io/guides/10-minute-tutorial/) works. And the most beautiful thing here that we are all forgetting in our haste to finish out daily code; is that coming back to it in three years, undocumented, with messy comments, we can still understand what this does: whenever('Click Me!').is('clicked').then('Change the text to "Clicked!"') This library totally qualifies as a small and simple secret.
"basic understanding of JS and how the DOM works". Sure. However, if you want learn DOM and it's quirks better you should not use jQuery. 
Yeah the idea of intentionally allowing your codebase to fragment is a bit terrifying. If you are a big software company with lots of different applications, then of course there's going to be some variety in your stack. But in the same application? What happens when you get the feature request: "when the user adjusts setting X [on the settings page written in JQuery], we want to show them a banner on the homepage [written in Angular 5]." Now you either need to know both or bring in two devs for a super simple feature, and communicate across two disparate front-end architectures.
I know you are joking, and you didn't expect a reply, but people here: [https://wrapbootstrap.com/](https://wrapbootstrap.com/) are dying for CLASS. I am so sick and tired of looking at those pointless mixed up templates filled with vapid snippets that fail bootlint. What they all need is an idea. If you actually made a FUI with strange experimental lingo, it would be a joy to try to publish it and sell. Take a look at [https://www.reddit.com/r/FUI/](https://www.reddit.com/r/FUI/) there is a whole community of designers there. Do it, call it a Secret App Boilerplate; or just go all the way out and create: FUI User Interface, a recursive acronym for the app that made cheap Hollywood movies blink interesting crap in the background. Goodluck.
I meant freemium as in some software they produce is completely free, like VSCode, Rosalyn, etc. That software exists to get developers introduced to the Microsoft ecosystem, then draws them into their paid counterparts and fully integrated in the Microsoft stack, just like freemium models intend to convert customers into paid members. However, the disparity between what is actually open sourced vs what is proprietary is huge. That gap may diminish over time, but they will never give up their attempt to gain and maintain absolute dominance in the market regardless of how much they cooperate with others. They want to be the leader, and that means keeping their competitors at bay - many of which originate in the open source community. That goes for competitors with their open and closed source projects, since both ultimately drive their business forward. 
AngularJS `&lt;label ng-class="{'has-data': val}"&gt;` `&lt;input type="text" ng-model="val"` `&lt;/label&gt;`
We actually use front end micro services at scale in production. It's a bit unwieldly at first but a lifesaver how it ends up https://www.mosaic9.org https://zalando.de (Sorry, but trying to advertise zalando here, just want to offer a large scale example of a mosaic site)
&gt; ...and communicate across two disparate front-end architectures. I would just use `window.settingX`. Honestly, wouldn't be too hard at all, you can also use `customEvents`, or anything really. 
No screenshots or diagrams :-(
Use let if you need to reassign and const all other times. You should focus on immutability over variable reassignment, though. Also remember const objects can have properties reassigned even if the variable can't be.
Yes indeed. It's something we are aware of. We are no longer an Angular shop, or a React shop, but an everything shop. On the upside, it makes it much easier to recruit good developers. They know they will always be able to work with interesting tech and will never be siloed in legacy.
What‚Äôs wrong with using facade patterns again ? 
That's a great way to get spaghetti code. Maybe not with the first feature, but implement half a dozen in that manner and you'll find developers slowed down and features mysteriously failing.
in this context, it obscures what happens under the hood. there are plenty of legitimate uses for facade patterns, monads and all the other stuff jquery is made of.
Maybe I'm missing something. If you're using every framework in the book, won't your vendor bundles be gigantic? Lazy load or not you're still burning through my monthly data
We're using Cypress for an enterprise application with a react frontend. It's a charm!
I imagine so, although a lot of libraries if shared via a CDN could be cached. I guess that'll not work when bundling..
I actually see this as a positive - you are not betting all your eggs on one piece of tech and you're not forcing your devs to, either (in respect to their long term careers). Specialisation is ok but a lot of juniors are getting specialised now and I wonder the pains they will experience later on when their fundamentals are rooted in one, narrow slice.
so instead of rewriting your stack every 2-3 years you can do it every 2-3 months but still have to maintain many different spaghetti legacy stacks? , that sounds like a great idea, you solved the internet!
Dude I love this idea. And honestly this could be amazing for multiple people to connect. And create projects as a whole. More together makes you learn to work with multiple people. Sadly I'm too busy at the moment with work. But it's a great idea!
That's very good in theory, but in practice, most front-ends are monoliths. A project is started and a framework is chosen. Then the whole app is constructed using that framework. We can be careful to make it modular, using components or MVC, or any other type of organisational structure, but sooner or later, the framework itself will be obsolete. A that point, the only way to upgrade is to chuck the whole thing in the bin. I have seen this happen so many times. Cycle looks intersting, but I can't help thinking that in five years, it will be legacy, just like AngularJS, Backbone, jQuery. Angular 5 is becoming legacy. Even React will be legacy one day soon. The DOM on the other hand is probably not going anywhere fast.
It actually makes recruiting much easier. Devs know they will get to play with the cool stuff.
Maybe if there could exist a single fucking javascript framework that didn't become legacy after 3 months we wouldn't be here. 
If somebody else riddled themselves why would they want to highlight words to show progress, I've came up with an answer - you can build a karaoke machine with it. Hit me with your ideas. Seriously though, this seems to be a cool, little library, good job 
This is what the API is for. They visit the settings page and make the change. We send the data to the API. Then the user visits the home page and we pull the data we need. Ideally you don't need two devs, you just teach your devs both frameworks. With a larger app, the choice is between fragmentation or a monolith. Monoliths are hard to deal with.
We experimented with a global flux store, but in the end, we just used routing. That covered almost all the bases.
Agreed. Global events are not a good way to organise things. We experimented with a global flux store, but in the end we just used routing.
This is very interesting. We used single-spa. How did you find mosaic?
Ok let me clear this up because this is in this article and people need to understand and as an Angular Developer it gets me: Its called **Angular**. Not *Angular 2*, not *Angular 4*, not *Angular 5*, and not (as soon to be released) *Angular 6*. It's called **Angular** and it is CURRENTLY on version 5.2 *Angular 1.X* is called **AngularJS** and is being depreciated. Everything that is not *AngularJS* is simply **Angular**.
Sorry, it's a high level overview. I'm working on a follow up which descends into details.
Ain't no one impressed by your sassy sour puss neither, ole' chickenlips.
Summer is the slow season for programming.
You don't load everything on first load, you just load the code you need for the current route. Each micro-app can be compiled separately.
It doesn't make sense to pollute the API with a purely presentational feature (in the example, showing a notification of what's changed when a user returns to the homepage from the settings page). So devs need to know every framework which every dev has brought in over the past five years? Even if that was plausible, it's a huge time sink and the constant context switching would be a drag as well. This strategy is a 1 year strategy. Things will work for 1 year, maybe 3 years depending on how active dev is. But people come and go, the stacks people use change, and this whole thing will become unsustainable.
In the article it says 2 react and 1 legacy angular on one page. So I'm getting 2 vendor bundles. Surely it would just get worse over time
Well we don't write spaghetti. Greenfield features go together very quickly. Legacy code still works. It's insane to throw away a complete working app every 2-3 years. So instead we build small apps, then wire them together using a small central router. It doesn't sound like spaghetti to me.
Actual use case that triggered this - For a project, the site wants the user to read a specific text on the page while showing progress of a task (upload, etc)
[removed]
True, but if you google Angular, you still get a mixture of AngularJS, Angular 5, and everything in-between. Our legacy app was AngularJS.
Never gonna happen.
I just read that as "soiled in legacy". Both versions work!
Yes, that is true. We certainly could get the filesize down by removing all our AngularJS code. That's probably going to take a year though, because there really is a lot. At some point we'll need to do the same with our React code.
How do you deal with UX and UI fragmentation? Do you have some policy in place? Otherwise, how do end-users react to having to learn something new with each micro front-end?
They do :) I remember when I started out. Someone gave me some CSS to write, and from that moment on, I was the CSS guy. I never got to do anything else. I left soon after. I never want a junior to be trapped in a single tech stack.
We have a notifications API. It uses sockets. At some point, notifications will probably become their own app.
Cool idea, but the fact that it breaks the user selection is a big problem.
We have a small NPM module full of SASS variables. We also have a really great interaction designer, and some shared React components. The end user doesn't know that they are using more than one app. They see a small loading spinner sometimes as we lazy-load code, that is all.
It does not. It's laying an overlay on top - not actually changing the user selection. 
My bad. "Looks like it breaks the user selection" then :)
That's why I like running the show and picking the stacks :D
I think this is a cool concept, and I can see the benefits of being able to enhance or migrate simple, independent UI pieces, and avoid monolithic frontends. However, I think most companies would still want settle on a standard stack for those pieces. Think of how many great ideas in the last five years have ended up being not such great ideas. Migrating a bloated frontend from AngularJS to something else, for example, is a pain, but at least you know when you're done. With this, you'd be finding bits of AngularJS mixed into your codebase for years after you move away from it. New Devs will be excited at the freedom to try out their new ideas, but less so at having to wade into countless old technologies to do bug fixes and minor enhancements.
True. The text is actually selected underneath. By changing the highlight background color to have a transparency will do that.
I'm interested. I do full-stack JS. I also do Python and C#. I like game development
What Javascript frameworks are you using that are no longer supported after three months? If your framework is no longer supported in less than a couple years you're probably picking the wrong ones in the first place.
I would love to migrate the whole app from AngularJS to React. We estimated it would take around six months. That's six months with no new features, and little tangible benefit. That's a hard sell. I don't think I could get that past product, CT, or the investors. Then in three years we'll have to do it again, and for two of those three years we won't be able to recruit the best devs because our stack will be old. This way, everyone gets the best stuff all the time. Currently the team is enjoying styled components. It's a good solution, and it makes everyone happy, so why not let them have fun?
HTTPS
Also knowing that the 'this' keyword does not work for arrow functions
True, my CI server is on vacation 
How could I not laugh at being called ‚Äúchickenlips‚Äù üòÇ You win.
Sounds good. I'd like to join and hopefully make the time to build something together. 
I appreciate you speaking up about this. Feeling connected to developers can be difficult, especially when you're new. We face things such as "imposter syndrome" or may live somewhere the world that makes difficult to find people in our personal communities that we share this passion with. I personally speak best through my code, so I actually created [gitconnected](https://gitconnected.com) to help give back. These were things I felt as a beginning developer and wanted to give a way to support those who may be having the same experience.
I think we grossly exaggerate the "burden" of a JS framework. We know the [things that affect page performance](http://stevesouders.com/hpws/rules.php), and minifying, for example, is only the 10th most important. If we add 50K of extra page weight, the page performance goes down by maybe 25ms -- not even perceptible by a human. In contrast, if we take our mere 2 lines of vanilla and put it in an external script -- that is, make an extra HTTP request -- then the performance goes down by 100ms or so. Page weight is an easy scapegoat, but measurement shows it isn't nearly as much of a problem as we make it out to be.
This is such a good answer. I wish someone would have given me this advice when I was starting out. 
I think they should only count manually installations, not dependency installations. Or at least provide both metrics. 
I'm down depending on the stack and amount of time involved
I agree that it's not that big of a deal. My qualms lie mostly in the mindset that people need to use libraries for every little use cases. Kind of similarly to how when one browses Stackoverflow JS related questions from some years ago almost all the answers pointed to jQuery or jQuery plugins. JS and Dom manipulation both have gotten better since. I'm just a grouch tbh
Are you also the kind of guy who holds a grudge for 20 years because someone spilled tomato sauce on your expensive Persian rug, even though the dry cleaners got the stain out the very next day? Let it go already Dan, I paid for the cleaning and everything.
I totally understand your concern, but that's why I made a point that Cycle itself is not necessary. more than a framework, it is a set of guidelines, helpers, and restrictions, that encourage programmers to develop within a certain functional paradigm. This paradigm is not a new concept - it's been around for many decades - but it is not commonly used in JavaScript. The concept of sinks and sources is prevalent throughout low level architectures everywhere around us (video compositing, graphics drivers, processors, etc) So while you're right that Cycle as a framework probably won't be relevant in a few years, it's principles will never die as they are built on mathemetical proofs. My intention was not at all to compare it to something like React or Vue, because Cycle has no opinions about how you interact with the DOM. the DOM is simply another interface, just as any of your modules are interfaces that communicate with each other. The principles I'm speaking of are how these interfaces communicate. I'm talking about event-driven, reactive architecture - an idea which is agnostic to any framework. However, some frameworks do facilitate this better than others.
Cool concept but it doesn't look that good to me. Your bundle vendor file is going to be big. Even if you lazy load, your app will be slow (at some point you'll need to start your Angular), and it won't save you from a single route that contains components from multiple framework...I like it but I don't see how you can improve it What would be better is to do some kind of conversion....transform an Angular component into a React component, or something like that. But you'll probably need to pre compile it.
I'm going to guess from your post history you're the author. This is some good stuff, man. One of the best write ups on this topic that I've seen yet. I'll definitely be reading the rest of your posts. üëç
IIRC, the old behavior was copying, not symlinking, which would explain /u/cwright017‚Äôs experiences.
I'm in the same boat as you and I'd be interested in collaborating
How long is the lifespan of a particular web app these days anyway? 3 years? 5 years? If a framework can't get you thru that stretch of time, it's a bad framework, but I think even AngularJS, with Google's quick pivot, has been able to carry people at least 2 years. React or Vue apps scale properly if you structure your business logic accordingly. Hell I'm currently working on a SPA built in (of all things) FullpageJS, which I would now definitely consider a framework. I can absolutely see it running for a few years, likely until a new director takes over and decides they wanna completely redo the style of the department, and therefore their site. Except for monumental changes in platforms that happen only every 10-15 years, code only becomes "legacy" when you decide it's legacy.
You can definitely do that. I just like enclosing attributes with double quotes.
One reason I like mine is because it's one-way binding. Which is where we're headed in Ember.
Microsoft decided to buy GitHub instead of them.
They're just saying what they did, you don't have to downvote because you don't like it... Personally I think it's an interesting idea. Context switching and big vendor bundles are a disadvantage, but being able to shed legacy code as you go is a huge advantage when you're in "deep debt" territory. Business Reasons (tm) can make it nearly impossible to rebuild anew, so having a way to develop in smaller chunks is great.
At my job, we recently 'bolted' React on top of a months\-old Polymer 1.0 frontend after management pulled it out of the grave, because all 3 of us web devs have React experience, but little in Polymer. I myself have none. However, I've been assigned the work, after being given a very helpful proof of concept by the senior dev. It's been an interesting challenge \-\- both learning Polymer on the fly and negotiating with React. This article contextualizes that work for me as something that's a real issue in the industry. Hinging the whole thing on the address bar is a spark of genius though. I've been using window events to pretty good effect, but it all seems a bit janky. How do y'all handle application state, especially authentication state like authTokens for the api? 
AngularJS just got three years of long term support, it's certainly not being deprecated.
Nah; could care less about crap like that. I grew up reading works by Marcus Aurelius, Sun Tzu, Machiavelli, and other oddball books many don't bother educating themselves with. I also played chess since I was in elementary school, so their moves for positioning for control is pretty blatant to me. 
Long live IRC! lol :) Cool. 
Ever read Siddhartha by Hermann Hesse?
DOM 2?
DOM 2?
If-else statements have a condition, try does not. Exception handling should be used for *exceptional* cases. If else should be used for normal control.
Cool but quite broke on Android chrome
Yeah, but it's been since high school. I remember enjoying it though. It's probably set the seed for me to be more curious about eastern thought. I'm much more Taoist in my views of life nowadays, but a dear friend of mine is Buddhist and we've had some excellent evenings discussing the nature of reality and the human condition. I know I'm a total geek, but strategy and philosophy is one of my nuts. That and puzzles. 
[removed]
This is fire üî•
That's what I suspected, but figured npm would make a blog post explaining what went wrong. Maybe related to [this one](https://blog.npmjs.org/post/174411769410/how-npm-is-affected-by-the-recently-disclosed-git).
I'm not a particularly avid reader myself - I have a very hard time focusing on passive activities like reading - but I devoured that book in a single sitting. I don't know why I felt compelled to ask you about it though...
The level 2 spec, yes.ancient, I know. Just like jQuery.
There's a language keyword called "throw", which creates a language feature called an "exception", and usually an exception makes your code stop running, even when it's inside an "if" statement, but if you use "try" instead of "if" then it doesn't stop. (This is a simplified explanation.)
The hell
I could see that. Same here on the reading, but certain ones get under my skin. Really YouTube and audio books are spoiling me. Here's a link to Alan Watts. I feel I've found a kindred spirit listening to his stuff. https://youtu.be/Iv9zocKASsM I don't always agree with him, but then again I often don't agree with many but myself. lol ;) 
Worked for me. 
Im interested too! 
Thanks guys!
I‚Äôm interested! What are some of your project ideas?
Looks fine on my Android 
What does support have to do with depreciation? 
I would think op is exagerating. A couple years until depreciation is still tooooooooo fast. 
What? They totally should shut it down. Who in their right mind would support two competing products unless they had no other options? If anything they should try and migrate the features from both into one editor. 
This logic can be applied to any tech company. The only difference is that the newer ones were able to learn from Microsoft's past but very much operate on the same principals. 
I just want to add - you don't need to throw errors. lots of developers tend to abuse this as some sort of complex control flow mechanism. If for instance you had a function that handled a user password, you could certainly throw an exception "Invalid length", or check for improper characters and throw a different exception "Invalid characters" and then at the bottom you'd have a nice little garbage bin where you could collect the errors and report them back. while this might seem appealing, all it manages to do is obfuscate any *actual* error, something truly unexpected, and make it more difficult to trace. As a general rule, it doesn't make sense to throw errors for something if you can account for it - just return the error string, log it, and report to the user. Just wanted to clarify, because I always felt like there was some pressure to throw errors. in the vast majority of cases they overcomplicate things, and can be replaced with simple conditionals like you suggested.
React has been around for five years now.
hi there, i think i want to take part of your project. i'm sure this will be fun, i can code about 3\-4 hours in work day and 8\-10 hours in weekend. :D
Yep. I don‚Äôt like that Laravel includes Vue, and strip it out of any new project. I don‚Äôt think the backend should be dictating frontend setup, especially when it implicitly dictates a fairly poor setup. 
Pretty much where I'm at now. I noticed most of your listed positions are full\-time in London. Do you have any other remote opportunities outside the Node.js position? I have experience with Node, but I'm primarily a front\-end dev (React). This is a very subtle way to recruit, by the way. ;)
Hi /u/mamzelnyf, For javascript help, please visit /r/LearnJavascript. Thank you!
Vuesax Github: https://github.com/lusaxweb/vuesax
Hi! I'm a marine engineer but taken a sabbatical from my job and am teaching myself HTML/CSS/JavaScript since it's exciting, want to do this full time. Happy to join if I will be of any use!
Not only that, but you drastically reduce the available surface area for code reuse. Now, any time you implement a core piece of business functionality, each sub-project has to then wrap it in Vue, Angular, React flavored components. It seems extreme to go down this route of being entirely framework-agnostic. It makes perfect sense to split up your apps so that individual modules can undergo large refactor/version changes independently. But let's not pretend like there aren't advantages in having consistency across those projects.
In my company we have developed a really giant application with similar idea (app consists of hundreds of micro fe apps, which can be bundled and deployed separately on demand). On the top there is a shell application which goes thorough a gateway and finds where the requested app is deployed on cloud. And shell app can understand what common vendors micro apps need and serves it once as umd, so multiple sub apps can use them, only one request is enough for common umd libraries in this case. (On dev env apps bundle vendors but on prod build it takes the specified vendors out to use it from umd thanks to webpack) We do not have specific adapters atm (because most if our apps are react apps) but nothing seems to stops us from writing new adapters. By the way the legacy app was a giant monolithic java app which took so much time to develop, deploy. We are happy atm that how it all reshaped.
the fiddle wasn't working on my phone so I can't verify, but what stands out to me is the ev.target in the drop handler. target isn't usually what you expect, it's the element that triggered the event that eventually bubbled up to whatever element the handler (drop in this case) is tied to. So you'll probably need a direct reference to the container that you want to put the element into for the call to element.appendChild if I'm understanding you'll also probably want to run a query selector on the element that's already in there, and move it back to the container below
This is basically like saying, "use npm" or a package manager .. except for your whole site/app Like, the whole article basically describes component-based development .. but just calls it micro-frontends... :/ Just a another name for a common practice is it not?
REST isn't going anywhere imo, most of the web is connected with it... Just 2 cents
And as far as I'm away, try/catch is a lot less performant than if/else But don't quote me on it :)
Agree. Most people I met only online said, they really want to help me. After few questions they just didn't answer my question and ignored me. 
NO WAY DUDE HE SAID HE PERMANENTLY SOLVED THE PROBLEM. PERMANENTLY.
pronounced as "vue sucks"?
I guess it depends on your definition of "outdated". REST is the 800 lbs. gorilla, and because it's so established it's definitely not going anywhere soon. But at the same time, in my opinion GraphQL is the future. GraphQL is one of those technologies where (in my experience at least) once people adopt and embrace it they don't want to go back to their previous way of doing things. If it was me, I'd make GraphQL as the backend not because REST is dead or anything like that, but because GraphQL is a technology that a whole lot of people feel is an improvement over REST.
800.0 lbs = 362.87 kilograms ^(1 pound = 0.45kg) ^(I'm a bot. Downvote to 0 to delete this comment.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=stats&amp;message=Send%20this%20message%20to%20get%20some%20stats!) ^| ^[Remove_from_this_subreddit](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Blacklist%20this%20subreddit&amp;message=javascript) ^(^Beta) ^| ^[Support_me](https://www.reddit.com/user/Bot_Metric/comments/8lt9lf/donate/) ^| ^[v.4.2](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
Googlebot uses chrome 41... can render some JS but may take a little longer to index... will update chrome engine towards or just after end of the year... BUT... Here's a recent video from Google IO (may 2018) that addresses specifically this. [https://www.youtube.com/watch?v=PFwUbgvpdaQ](https://www.youtube.com/watch?v=PFwUbgvpdaQ&amp;t=359s) 
I highlight while reading articles so I don't lose my place. Could turn this in to a pretty nifty extension I'd bet...
GraphQL is easier for frontend, but harder for backend.
If it came to it the source code for Atom is open source and the project could be forked. I personally use VS Code but recognize that it would be a really dick move to take away Atom from those that like it.
Also interesting to know, do people who develop mobile apps also adopt GraphQL? For me it seems like it‚Äôs the hype technology for people who mostly create SPA, not sure that other consider it as the future 
I work with it in Zalando 
Well sort of, yes. We are treating apps as big components, wired together with a router. This means we can use a mixture of frameworks, and can build, test, and deploy apps independently, and display them on the page at the same time. So yes, it is a component oriented pattern, but with a super-light extra layer. 
It would be nice if you could specify not just progress % but specific character start/end offsets!
Really like the look of these components, seems a bit more modern than the usual component libs!
More like Vue Sex amirite :D
We use GQL in production at work. They each have pros and cons, so they will most likely live side by side for now. Two big reasons to still consider REST over GQL are: - Its language/framework agnostic, i.e you dont need anything but don't need anything but a http lib and youre ready to use the full range of REST, and while GQL technically are normal http reqests, you still need to figure out if the server accepts request in the body or as url parameters and handle multiline strings, which might not work well in all languages. - If you have a flat parallel model of your data, REST is much more expressive and predictive than GQL, since REST is a fairly simple to grasp the concept of, and doesn't rely on a naming scheme of whoever built the API made up. So don't choose GQL because its seems like its about to take over the industry, but consider using it if: - The API is client facing and is supported in the language its written in. - Your data structure needs to stay deep and relational all the way to the reciver. GQL might seem like heavy train right now, and all that's needed to derail it is a better client query protocol(only contender *was* netflixes falcor) or something completely new. If the project is purely for educational purporses then GQL is a very good thing to learn the concepts and design of though. 
It works of course, it's just lexically bound to its context.
Good idea. But it needs to be improved.
Interesting, specifically the example :) Since JS is prototypal is surely just an under the hood difference making JS OO too? Which I believe most people would disagree with would they not? By traditional I was meaning to say the majority market players i.e. Java / C based languages (C#, C, C++). I could be wrong, but I'm not aware the objects can deviate away from the classes they were derived from in such languages?
But react it's not a dependency 
Components built with React need the React library to run. Those built with Svelte do not - they are just simple constructible JS objects. They are therefore able to be dropped in to other apps built with other frameworks (or none).
Hi there, I think I am very interested in this. I am a Chinese graduate student just finished a 3-month internship. I am a front end developer in react&amp;redux. Maybe working with a Chinese boy would increase our collaboration skills!üòÉ BTW, how can I join you in this fantastic team?üòã
Thanks for the feedback Skilla123! Are you running it Headless? 
Oh Hi! Having a rocking tech stack does help with recruitment :) Sure, we have remote positions. About half the devs are in Europe, some in South America. One guy is in Wales. A couple up in Scotland. Half the sales team is in Austin. We are definitely looking for people who like JavaScript. Why don't you PM me your LinkedIn, Github or whatever you've got and I'll see the right people get to look at it :)
What an unfortunate name
Yes, all our new apps are in React. Our old apps are in AngularJS. Bringing in a new framework means porting the whole UIKit, which takes a sprint. That said, all the general styling is contained in a single repo full of SASS variables that can be easily reused wherever we want them. We call it Runic. It has colours, gaps, animations, breakpoints, and standard styling for things like buttons.
Hi, yes, I think we did. It's been a problem for my whole career. Now I think we finally have a good solution.
Looks decent, not a big fan of the type choice nor the weighting used in the modal header, though.
Yes. No-new-features for 6 months while you throw away all the working code and replace it with apparently identical code that is somehow "cooler" is a tough sell.
One bonus tip for ReactJS Development that everyone should aware is about "How to Add ReactJS to an Existing Application" [ReactJS Development Services](https://kunshtech.blogspot.com/2018/06/reactjs-development-how-to-add-react-to-an-existing-application.html) 
Their reddit user seems to be /u/substack.
This is why trademarks exist, and I'd bet he doesn't have one. Also, despite using browserify in the past, I had no idea who made it and have never heard the name before. Ethically, they could be in the same situation I am and have really done nothing wrong. At this point, they've put a lot of time and money into the name, too, and I don't think they are ethically required to change it. Sure, it's unfortunately for substack. But it's pretty easy to come up with that name on your own and he didn't trademark it.
I think they are nested functions that retain access to variables in the enclosing function. But being nested they also have access to a lower level of variables as well. Someone can correct me if this is inaccurate.
Legality is largely beside the point; naming the startup isn't the same as just using a library, you'd think they'd look the name up first. The importance of this is to at least remind others to take steps to protect their name. Asking an individual to register a trademark is extreme, though; just a .com domain would have apparently helped in this case and is easily accessible.
Absolutely beautiful components
So like https://micro-frontends.org? Why not just use Custom Elements to wrap it? 
When I'm writing the test I'm using the GUI to run the tests because of extremely helpful stuff like this: https://docs.cypress.io/guides/core-concepts/test-runner.html#Selector-Playground The automatic tests before deployment on the respective dev/test/production server are done headlessly. On the issue of async calls: Cypress always waits for all network requests that a test step triggers to be finished before executing the next tests step. Say for example you have a button on your page that fetches data from the server and then displays this data in a new div. If you simulate the button-click Cypress automatically waits for all the data to be fetched and then the next step (checking if the newly fetched data is displayed correctly) is executed. No, I don't work for Cypress haha, but give it a try, you're gonna love it.
Github link: https://github.com/Ho-Wan/howanto.com
[removed]
Shame it doesn't work with the standard vue\-cli, vue\-init webpack\-simple.
Like many folks in tech, you seem to believe that a domain registration in some way trumps or bests a trademark. It doesn't. No matter how "wrong" or "not ok" that feels, trademarks exist for a reason. They existed before domains were invented, and they are the mechanism the law has chosen to use to distinguish between who has a right to something and who hasn't. 
Very, very likely, [he doesn't need one](http://www.worldtrademarkreview.com/Magazine/Issue/54/Country-correspondents/Strong-rights-without-registration). But even if he had gone to the trouble of registering, there's no guarantee it would have protected him. The fact that one is a very prominent and well-known OSS contributor and the other is a newsletter startup doesn't mean that there is likely to be confusion in the marketplace, where trademark is intended to give protection.... Unless substack has an email library I'm not aware of (or newsletter, I suppose). And the fact that the audiences evidently collided on a HN AMA doesn't equal market confusion. If anything though, it makes me think that the startup just failed miserably at their due-diligence when selecting a name. How can you make that mistake when you've gone through Y Combinator, of all programs? 
I worked recently with a company that was still using Backbone. I was quite surprised how nicely it all still worked. I have old MVC JQuery code that is still live and doing nicely. Any decently architected framework will last for tens of years. The problem is with recruitment. The good devs tend to want to stay up-to-date because it means they can jump between startups and not stall their careers. The legacy support folks get more expensive as time goes by. This leaves you with the people who are not interested in updating their skillls, who slip into legacy because of lack of interest. Those are probably not the people you want working at your company. The other issue is NPM modules. If I want an off-the-shelf grid component for example, React gives me a ton of choices. I can tap into the collected wisdom of the community. If I'm using old code, I won't get the same options.
Sure it's possible, but you should really use json for that
Why not export the array and then edit it's contents elsewhere? Or export helper functions to do the same? Do you have some constraint? The actual editing of files programmatically is best left to tools like Babel and webpack. If they aren't designed to do what you are trying to do, then editing the files might not be the best way to solve your specific problem.
You're seeing native behaviour override your event listeners. It's unfortunate, but not unseen. [https://support.apple.com/en\-au/ht202769](https://support.apple.com/en-au/ht202769)
I've said or implied no such thing about domains trumping trademarks; the focus is on domain registration because it's more accessible for an individual, and because the company literally came out and said that their selection was based on the availability of the .com and even linked to Paul Graham's article advocating for using .com as the main criteria. I don't understand the rush to defend the rights of a venture-capital backed company over the interests of a person doing selfless and widely useful work.