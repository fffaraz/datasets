Bold claim it had about explaining "modern Javascript". Explained nothing but React and Redux, and only so much as to know when one should use them compared to pure JS, or React alone.
nah, also wasm was released so if you're really against JS like many old school folks (seen that so many times in 11 years of pro. development) you can just compile to wasm from your fav language
You probably COPIED something wrong
Well it's already my second internship of 6 weeks (unfortionatly the first I did was more in a Server/System-Admin environement). Here are no other devs at this company, but I have unlimited internet access so that should do. I already started using Git once at home (just to learn what git actually is...) and also had a quick look at Node, NPM on the other hand is unknown to me so might take a look at it. Thanks for the answer! 
Nice job! 
This is very happy news.
Thanks, but doesn't this just get me the input element being manipulated?
In addition to what others have said, if you see function parameters being destructured, you will know exactly what properties of passed-in objects the function will use without needing to review the function first. 
The plugin you linked is certainly a popular one. Hapi has a built-in concept of authentication `scopes`. You can assign your users to a scope on account creation &amp; login, and use those scopes in your route config to allow/deny access. Scope Docs (https://hapijs.com/api#route.options.auth.access.scope)
Actually scrolling. Or panning, rather. Mobile is weird.
Meltdown and Spectre can be activated from Javascript in the browser, apparently. There's no program language that would have prevented this, though, since it's a hardware design problem and not a browser or OS security problem that's being exploited.
Any time executable code is run, there are potentials for vulnerabilities. There is no language in which this is not the case. And don‚Äôt think you are safe if you disable JS. There are ways to perform malicious actions with the css, html, and/or networking systems of the browser alone.
And your point is?
There's 8.3M places where "import React from 'react'" exists
That is a restatement of the original title. What about conclusions? What is the significance of the statement? Is it a problem? Is it a statement of celebration? Is there something special about the number 8.3 million? What? I could put a 
&gt; Reason from Facebook and Elm. F#/Fable falls in to that same category, as well.
I found this very helpful, thanks! 
Yeah, I would appreciate looking at pages to get the better understanding of the problem
nope. 
Simulating modules is only one thing people use Webpack for so even if that aspect becomes obsolete the rest may not. However, HTTP/2 doesn‚Äôt mean that bundling is unnecessary. You still need to deal with network latency and one mitigation for that is to use gzip to reduce the amount of data crossing the wire. However, gzip performs better when it has a larger amount of data to work with. HTTP/2 gives us greater flexibility in how we bundle but physics still applies interesting constraints.
And another 4M for 'require("react")'
The text area stores its value as plain text and not html, so return lines would be "\n" not "&lt;br&gt;". Like ugwe43to874nf4 said, b.trim()=="" will work. 
Nah, the front-end roles will probably be split up into smaller more specific roles. The need for backend devs will decrease. Backend today is pretty much setting up a database, send some JSON with a framework and put the code on a pre-configured cloud setup. 
I wouldn't say "nobody", but with all the new frameworks and their ways to handle the same issues, jQuery certainly isn't as useful as it once was.
I've always used it just for browser compatibility. Until all browsers are universally compatible.. there will always be a need for something like jQuery. Also, with the web continuously getting faster and devices getting faster, is using jQuery that much of an actual problem? 
I think the JS community will need a new bundler (or perhaps Webpack will need to be majorly refactored) within the next few years. We need a bundler that takes the same input as Webpack currently does, but produces an output that is real ES modules but bundled like Webpack does, and then also output a push-manifest for the split bundles etc. so that a web server can read it and serve bundles accordingly.
I haven't used jQuery in any projects in a long time, why do you think we need it? With transpilers and polyfills like Babel, you can write "new" JS without worrying about backwards compatibility.
One idea would be to check whether on the affected computers/accounts the remote unit has indeed been mounted with all caps or not. If this is indeed the problem you could just modify the condition to `if(this.path.toUpperCase().indexOf(....` (that is, adding `.toUpperCase()`). If the problem is elsewhere I would suggest, that since this is a professional environment and there's a company behind, maybe they could hire someone knowledgeable to try to solve the problem or provide you, or your co-worker or both, some paid training.
Actually... The query does not mean exactly that; it includes a lot of other results. I mean, a match for "import React from 'react'" does not _exactly_ mean that the code found _is_ "import React from 'react'". So you cannot even draw that conclusion.
The query is fuzzy. Just browse some of the results found and you'll see.
aaaaaah
Just a guess, can it be due to things being stored on localStorage?
I appreciate your reply. Thank you. 
They use an Access database and click a hyperlink to access the PDF located on a remote file server. I have checked local access and adobe settings but see nothing affecting the issue. If JavaScript is disabled, any user can open the pdf without issue. 
Glad to help encourage. Good luck out there!
1) It seems that the author didn't even read the linked article through to the end, because it's made clear that the entire thing is speculative 2) The author uses a lot of snark to dodge the point that it is _ridiculously_ easy to sneak malicious code into even big packages, and it's a problem that while not entirely unique to JavaScript is extremely exacerbated by current JS' dependency hell (as the original post explains - few people if any can claim they personally go through the distributed files for the hundreds of packages the typical `npm install` on a decent-sized project pulls down). To illustrate - if you want to build Nginx (a fairly large, really popular C project) from source, you're going to need Nginx, PCRE, OpenSSL and ZLib (which comes with most OSes by default). That's it. On the other hand, installing the `serve` package from NPM (which only has a fraction of Nginx's functionality - just the static file serving) pulls down _156_ packages. 3) Beyond that, the original post was able to demonstrate that once he could get his code into your browser, a lot of the security measures we (fail to) employ are bypassable with a few simple tricks and a small dose of luck. None of the exploits he "used" are particularly _smart_ or complicated. NPM aside, it's definitely worrying how much we depend on the goodwill/common sense/competence of the people whose sites we visit.
Love the website design too, and very clear to read on mobile. ++
I agree 100%. All these comments by people who say they write vanilla JS for webpages are honestly just reckless IMO. The compatibility problem between browsers is still huge, and doing big things raw is just plain dumb. I love jquery with a passion, it's incredibly powerful, tremendously easily and opens so many doors.
[removed]
Netlify is easier
Thanks, but I don't think this is actually due to something bound to the element. It's an odd issue! It seems that the event is being dispatched. There is an app installed in this website which, for reasons I can't deduce, generates a hidden input element with a value, blurs it, then removes it from the page. No idea why they do that!
I thought it was a pretty solid example of how you'd take a component built with jQuery and convert that to React. Given how many developers have worked with jQuery for years and now making a switch to React/Angular/Vue... I think being able to illustrate to those developers how that transition might look is really a great tutorial. Would you NOT consider React/Redux modern JS? I mean, is he supposed to somehow create a single article that showcases all modern frameworks in depth? I don't think that's exactly realistic... and for the scope of this article, I thought it was well done.
const get = (...path) =&gt; value =&gt; whatevah will do, thanks. 
Agreed! The next generation bundler will need to model the same semantics/functionality as the browser does when importing (+ circular dependencies). It should be able to load `http:` (https and http2) and `file:` protocols seamlessly. I hope it will cache aggressively so that the only requests that ever need to get made are HEAD to check the `Last-Updated` header for changes. Ideally in the future all registries will be able to checksum individual files as well as the library/module as a whole. Any future build tools should be able to verify the module they are bundling is the module that was published by the author. Parcel gave JS parallel bundling, so any new bundler would need to use a similar mechanism to speed up large builds. Tree-shaking and scope merging (taking two ES module scopes and unifying into a singular global scope) need to be kicked up a notch and refined to avoid any kind of speculative bundling (webpack does this when it isn't 100% sure what you might require). I should be able to import JSON or JavaScript and only get exactly what is needed. Any leftover clutter is discarded. Scope merging should identify any top-level variables in a module and determine if a parent module already defined it and then map to the previously aliased value. I think getting these two concepts right in a bundler will make a huge difference in performance and bundle sizes. Keep in mind that Gulp isn't a build tool so much as it is a task runner. webpack would be an inappropriate replacement for task running, it isn't designed for much more than a single task that just so happens to occasionally have side effects (generating css files, images, etc). Task running is a bit outdated it seems, in favor of things like npm scripts, but I do agree that we'll need something super lightweight to coordinate, unless this new bundler is suitable for multiple derivative builds (that derive from the main configuration, but can be configured different based on something like NODE_ENV). I'm working on a new bundler for funsies, and these are the things I'm thinking about when I think of "next-gen" and ESM.
Perhaps in a couple of years, when IE11 is gone and the spec has grown, but i doubt the raw spec will ever be used as they've imagined. The bundler will most likely still be around, just without the "bundling": it would create tree-shaken, transpiled, HTTP2-friendly single-modules instead of a bigger bundle and smaller split-bundles. As a developer you wouldn't notice when webpack drops bundling once it's time. Standards overall are fine, but they have to have merit as well. Modules aren't such a pressing problem, it's currently being dealt with very efficiently by a bundler. Right now there would be so many cuts and regressions if you'd use native ESM: IE11 left out, **huge** payload, long loadingtime, being unable to handle non-js resources, what handles transpilation (babel, es-next, jsx, typescript, etc.), what about hot module reloading, etc. HTTP2 alone won't make the smallest dent against the benefits you get from tree shaking (!), shared chunks (!), hoisting and compression alone. I've seen tc39 committe members echo similar sentiments. The direction is good, but it's far, far from usable. 
I think you may be right that case sensitivity is the issue. File paths are using caps on some systems and not on others. I will reply back soon. Thank you. 
I think the relevancy of jQuery (or lack of, in modern dev) is a two-fold problem. 1. A lot of schools teach web development with jQuery, even though the practices may be completely deprecated in modern-ish browsers. 2. jQuery has been around a long time, and has many resources. To address point 1, web dev in schools will always lag behind, either from teacher/course laziness, or from unqualified teachers. Given enough time, point 2 will resolve itself, being that browsers will become more compliant to standards, and generally better over time. That said, there will be other libraries to deal with the eventual inconsistencies in newer technology. I've come across light-weight jQuery alternatives over the last few months, but it's my opinion that none of them will be successful because of the lack of tutorials and articles using these tools, especially in comparison to the amount available from the jQuery community. That's all to say, because of the familiarity to what I'd estimate be 99% of professional web developers, jQuery will always have a place for people who just want to get something done. Say what you want about jQuery, but it works, and you can hammer out working solutions fast.
Very helpful. I'm a React n00b and have been looking for a simple explanation of what Redux is and what problems its designed to solve. This sums it up very nicely.
I am in love with your website design. Your background color is fantastic, and I love the "torn" look when you display your code. Now... Back to reading the article. 
Great one! Cheers.
Any modern framework abstracts browser inconsistencies. You don't ever touch the dom in these any longer. They're mere fractions of the size jq would take, reach speads that wouldn't be possible either using plain js or jq, and they make handling state and views actually manageable and transparent as opposed to jq blowing state into dom nodes and class fields, which has caused some of the most [catastrophic view layer code](https://pbs.twimg.com/media/C7eEVWJVUAA8era.jpg:large) the world has ever known. Jquery will still be around in legacy software, but reasons to use it in a contemporary project are getting slim. Hence, the lib is in measurable decline and plagued by maintenance turmoil.
so is the dependency count what you have the issue with? 
nice way to answer my question with a rhetorical question. 
I mean, it does seem you only read like ten words of my comment that weren't even the (direct) point. To reiterate: While malicious packages affect every language, JS in particular typically has hundreds upon hundreds if not thousands of dependencies per project _that would be impractical for devs to constantly vet_, hence the comparison with a project from another language that has few enough dependencies to count on one hand. And besides that, the apparent weakness of browser security measures is reason enough for concern on its own.
Relevant? Yes! Remember all that legacy code? Should you use it for new projects? Don't think so. I think jQuery is outdated. We have Babel for browser inconsistencies and a shitload of npm packages for everything, like left-pad ...
right. I understand your point that due to the sheer number of packages, it makes it harder to audit the code your application is actually executing. The crux I'm trying to get at is that the number of modules doesn't really make that easier or harder, outside of some manual labor in finding the package (not hard). Other than that, it really comes down to line count and ease of reading code to properly audit it. Not the number of modules. Thats not really a good gauge of audit difficulty. 
I guess it's all about size. With something like 50 components, which might even be simple, you are not going to see much difference - probably even only immeasurable. You could try to scale up the number of elements (maybe even into the millions) as well as increasing their complexity and the complexity of the CSS (longer &amp; more selectors). If you do that, you should start seeing some differences when changing styles.
&gt; Am I missing something? Has anyone else done performance tests with the Shadow DOM? &gt; Maybe if I did 10,000 components I would notice a difference? Yes and yes. The virtualDOM/ShadowDOM is most useful when there are a ridiculous amount of elements that need to be updated. As you are probably aware the reason this is so is because of the way browsers handle it (i.e they do a diff of the DOM and only swap the changed elements out, rather then having to perform an uncached recursive lookup). I think the reason you're not seeing any performance benefit is because you're not leveraging compositing properly (because you're using font-size, etc in your animation), thus the workload is not being offloaded correctly to the GPU (it is being executed on the main thread) and layout thrashing is taking place. The following should be of use to you - [Paul Lewis: Google I/O 2014 - Mobile Web performance auditing](https://www.youtube.com/watch?v=WrA85a4ZIaM) - https://csstriggers.com/ - [David Valdman: Functional Layout - Updating the DOM at 60FPS | JSConf EU 2015](https://www.youtube.com/watch?v=biJXpv-6XVY) - [Denis Radin: Rendering HTML via WebGL | JSConf EU 2015](https://www.youtube.com/watch?v=9oGQucDOaoY) 
The thing is. I tried it with 'will-change'. And still nada. I'll try it with more components.
Thanks for the feedback u/przemo_li. You‚Äôre right, I could probably have done a better job of describing how React and Redux have influenced other libraries. I‚Äôll consider making an update or perhaps a follow-up post. Is there anything in particular you feel I should make sure to cover?
You're right. Is it possible for Webpack to emit ES modules though? i. e. leave both the static and dynamic import calls as they were, save for changing the paths according to the code-splitting that was done.
Well son of a nutcracker. BTW. Do you mind critiquing my code? https://github.com/roecrew/zam/blob/master/zam.js
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [roecrew/zam/.../**zam.js** (master ‚Üí 122548b)](https://github.com/roecrew/zam/blob/122548bd90929b9cf1d45b051f96ee0f49e79347/zam.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsdprnc.)
apologies, im gonna have to decline.
How big is the difference in your security handling, between having 10 dependencies with 10k LOC, and 10K dependencies with 10 LOC? You need to vet both. That's my whole point about security concern. Don't blindly install something from npm just as if you wouldn't blindly run an executable you download on the web.
No problem. Thank you for your responses with this topic!
As your links already say, shadow DOM is more for encapsulation than performance. Anything they say about perf are nitpicky technicalities grasping at straws. If anything, for purely static content, you're likely going to be taking a huge hit by rendering stuff via JS, instead of using the browser's HTML parser. Only if your HTML complexity justifies the encapsulation features of shadow DOM will you begin to be able to make a meaningful comparison to other encapsulation mechanisms (e.g. components -- not virtual dom -- in React). And at that point, you're comparing JS, which is orders of magnitude slower than CSS (in the context of perf). Btw, you're definitely not going to get any meaningful benchmark results from a sample size of 1-50, especially if what you're benching is repaints from CSS changes. It sounds like what you're trying to measure is the difference between constraining CSS changes to a shadow DOM vs a huge plain HTML tree. In my experience, perf hits from CSS changes are negligible in the vast majority of cases (with perhaps the exception of cases like full-screen parallax with translucent image layers in "experience"-style ipad apps). There are many many many other things that will screw up performance orders of magnitude more than any performance gains you would get from shadow DOM's CSS encapsulation. 
yes that's definitely along webpack's chords, doable in a loader right now, they will support it by default it when the time is right I think https://github.com/webpack/webpack/issues/4170
&gt;Anything they say about perf are nitpicky technicalities grasping at straws. lolz! thank you for your feedback! Out of curiosity. Can I get your LinkedIn and/or github? 
Thanks to Babel I've been using all of these without really realising that they were that far out in the spec. `Object.values` has been immensely useful
https://developer.wordpress.org/reference/functions/wp_enqueue_script/
I think you should tell us what feature you're talking about first.
The one from the link: https://github.com/tc39/proposal-decorators/issues/40
https://github.com/verdaccio/verdaccio
Next time just say "Decorators" instead of "This feature" in your headline.
The fundamental property of adblockers is that they block the connections to known ad networks. Even if a script tried to run and connect to ad networks, the adblocker would block it. So the problem is not specifically in the javascript, but the fact that your browser makes the connection to the ad network. This could be done without any javascript with an iframe that loads an ad in itself - such as a simple image link. You can still receive targeted ads too, since cookies can be set even with js turned off.
I don't want to be a party breaker, while UI looks very nice, background is making text hard to read on my screen :(
Your username is not funny
Thanks a lot, thats exactly the answer I was looking for. I just had to turn javascript back on to reply to this comment. Switching it off was an experiment after learning about the Meltdown and Spectre issues.
Depends specifically how the ads are being handled. If the ads are implemented by default (CSS) on pageload, then disabling JS won't do anything except make you unable to close the ad.
First, if you're going to post a bunch of code format the entire thing into code blocks so it's readable. Second, this is too much code to simply paste into a forum and get good answers. You should make a codepen or plunker of this so you can link to an example of what you have so far.
`String.prototype.padStart` Is this here because of the npm leftpad fiasco... or was it there the whole time and now the leftpad episode is even more stupid?
gah, I hate trailing commas. The rest is nice.
Since this is a list of features coming in ES7/ES8 and don't exist yet, the former.
I hope that the standard will include the pipe operator soon. https://github.com/miraks/babel-plugin-pipe-operator
People use actual frameworks which sort that out entirely. jQuery is a thing of the past, even if it is still present in legacy code.
Why do you hate trailing commas? 
Neither, it was added to the proposal in 2015, and the leftpad fiasco happened in March of 2016. However, String.prototype.padStart / padEnd entered stage 3 just 6 days after the leftpad incident. So even though the feature was proposed before it ever happened, the incident may have accelerated the process. https://github.com/tc39/proposal-string-pad-start-end
Maybe they like git conflicts?
Maybe within the next year. It is currently in stage-1: https://github.com/tc39/proposal-pipeline-operator
I hate trailing commas because of it increasing the size of an array, and when doing certain functions on them, I get an error for data being undefined. Plus, it just bugs me seeing it there. Why have a comma, if there‚Äôs nothing there?
Greetings @khull123. I'm one of the maintainers of brain.js. Image recognition: http://linux.ria.ua/mnist_brain/nnTest.html doing math: https://github.com/BrainJS/brain.js/blob/master/test/recurrent/lstm.js#L7 Playing chess and searching online will require a bit more tooling, but are not as complex as you'd imagine.
It's someone elses code that puts a Korean timestamp onto the sheet, I was wanting to change it so that it puts a Melbourne timestamp. Thanks for the link but a lot of that is well above me. I can live with the Korean timestamp as Melbourne is just 2 hours forward it's just a little thing that was annoying me because I'm a bit of a perfectionist.
It doesn't do that. I believe you are mistaken. It's useful for clean commit histories and also it's just nice to have and annoying to not have if you use an editor where it's very easy to delete entire lines (and use that feature), so you can take out the last element without needing to make multiple editor commands.
I started writing a comment that was going to disagree with you, but re-reading your original post I think I just wanted to make what you're saying more explicit. Chrome (for example) uses 'will-change: transform' and 'will-change: opacity' as a hint to the layer system that elements should be pre-layered rather than waiting until your transform animation starts. You can validate this yourself using the Layers tab in DevTools. If that layer/element fails candidacy for some reason, then yes it won't have any appreciable effect. Animating font-size within your layer will cause re-renders rather than just composition. Explicitly - 'will-change' is only going to have an effect on how quickly your animation will start and can save you jank at the beginning of the animation as layer creation is a (relatively) expensive operation. TL;DR Verify using DevTools that you are getting a layer created properly if you expect to see perf benefits from animating CSS properties. Layering aside (AFAIK layering is independent of any perf improvements from the Shadow DOM), you may be interested in the following [CSS Containment](https://developers.google.com/web/updates/2016/06/css-containment) and [Boundarizr by Paul Lewis](https://github.com/paullewis/Boundarizr/) which was likely the pre-cursor to containment property. IMO I would expect that any noticable perf gains that you expect to get using Shadow DOM would instead be reflected by using containment and layering.
Yes! That and pattern matching and the optional chaining operator. There's some good stuff in early stages that I hope make it.
Oh okay so it's a religious war you want. ;) 
That's such a ridiculous statement. You're clearly not a professional developer, so i'd avoid giving out advice, especially when it's blatantly false.
I love how the leftpad debacle seems to have resulted in the feature being added natively.
It does do that, but with leading commas: ``` [ , 'foo', 'bar'].length // --&gt; 3 ```
It's not completely wrong, there is some truth to it. Static default props type checking does not function in TypeScript as it does in Flow. If you have *strictNullChecks* enabled you will get an error. There is a workaround, however. MyComponentClass&lt;MyProps&gt; { static defaultProps: Partial&lt;MyProps&gt; } The workaround is still not quite as functional in that you won't get an error if you specify the wrong type for your default props object, you have to specify the type for there to be any type checking, and you can't specify static defaultProps outside of the class.
I remember there being a transpiler or something that produced this issue. 
Yes, there is a way to handle stdin. Good to see that someone thought about that right from the start.
You have a little problem here: ['a', 'b', 'c'].includes('a') // true, not 0 like indexOf would give ['a', 'b', 'c'].includes('d') // false 
Small complaint: the monospace chalk font you use for code has a nearly invisible capital K. Or at least it does on iOS, I don't have another machine to test it on right now. You can see it in the first object of the Redux section.
So, what's the difference between this and dot? Seems to work the same
Honestly? CMV, but decorators and list comprehentions both seem like hollow syntax sugar to me so far. Neither seem to bring anything new to the table, so I'd rather see them left out. We have the tools to achieve these effects expressively, efficiently, and concisely without bloating the already complex miracle of engineering that is a JS interpreter/JIT/runtime. The more overlapping syntaxes and features we add to JS, the more it becomes a giant cluster like C# or c++. I've grown quite fond of our lean, mean, scripting machine- can we preserve that minimalism?
https://javascript.info/
Anyone know why my workplace has blocked that ( zamjs.com ) website? I thought it was benign... now I am waiting for that slap on the wrist from network ops. :O 
Don‚Äôt forget, privacy violations and cross-site scripting attacks are not limited to JS.
Bootstrap and DataTables still have it as a dependencies. I use jQuery for all my AJAX requests (along with other stuff) since I usually use one of these two frameworks.
I've gotten a library for loading configuration files (in a similar vein to Cosmiconfig) written in either TypeScript or JavaScript and using either ECMAScript modules or CommonJS to a basic state that I am pleased with. It still has polish and planning left, but it *should* be mostly usable at this point. If anyone wants to have a look (or maybe even give me a code review) you can find it [here](https://github.com/severen/disposition).
The course is still great. The fundamentals of how javascript and its engine hasn't changed. There's even mentions of ES6. If you do this course and check out a couple videos elsewhere on ES6 you'll be set.
The latter most definitely returns false. I'd think whatever browser/environment you're using is missing `.includes`, but the first example should give the same error if that were the case. ü§î
Ah, I see. Should have been clearer, then :P
Just to add on to your (excellent) reply: the example in the article looks misleading because there are `map` and `filter` methods defined on arrays in Javascript. But, if you look at the `import` at the beginning of the snippet, you'll see that `map` and `filter` are functions imported from the `lodash` library. So, we're not calling methods on the array, but as you mentioned, we're calling functions with the array as the argument.
I used to hate trailing commas, but then I tried enabling them with prettier and it's honestly just more pleasant to work with. If you need to add another item to a multi line list, you don't need to jump to the end of the line to add a comma, prettier already did that for you because you enabled trailing commas.
&gt; Since this is a list of features coming in ES7/ES8 and don't exist yet, ES8 has been the current version of ES since June 2017, this is not a list of things to come - this is a list of things that are already supported and considered standard.
The example on that page is just terrible. Notice they're using the lodash `map` and `filter` instead of the es6 functions. So their example is equivalent to import { map, filter } from 'lodash'; const array = [1, 2, 3, 4, 5]; filter(map(array, n =&gt; n * 2), n =&gt; n % 3 == 0);
Made a codepen :)
cool, its a small useful trick, hope I dont forget about it when the time comes :)
I didn't know this lib. Could you please explain me why using pipe operator is better than chaining. I looked at the example I don't instinctively grasp the advantages. 
I'm completely irrational when it comes to trailing commas. Objectively they're convenient for reordering, and they work better with vcs. On the other hand I think they're ugly ¬Ø\\\_(„ÉÑ)_/¬Ø
Maybe I don't understand something, but you don't need lodash to use map and filter with dot, it works fine in es6
&gt; To illustrate - if you want to build Nginx (a fairly large, really popular C project) from source, you're going to need Nginx, PCRE, OpenSSL and ZLib (which comes with most OSes by default). That's it. On the other hand, installing the serve package from NPM (which only has a fraction of Nginx's functionality - just the static file serving) pulls down 156 packages. I agree with the overall point of your comment, but is this really fair? Each of PCRE, OpenSSL and ZLib have their own dependencies; `make` of course, plus languages (C, Python, and Perl at a minimum) and their compilers/interpreters, and those are just the ones that are shared since they each have their own dependency graph. It may not sum to be &gt;156, but it's a more than the handful you initially named. Again, I agree that npm is a bit of a house of cards, but I believe the argument to be made is that packages nginx depends on are more-or-less well-established, ergo there's a level of trust that has been earned. There's also the fact that those projects move much slower and deliberately, further reducing the chance of bad actors, and that the ecosystems for them are typically much more rigid.
Am I the only one who thinks these boilerplates are boring and not noteworthy? I mean, it's good to have them there when I Google "redux react observables typescript" or whatever stack I'm feeling that day, but ultimately I think most of them are just a waste of the creators time :/
For testing React I would go with Enzyme and Jest. Check out Cypress for UI testing as well
Do you have the back end package.json configured so that if you enter "npm test" or whatever in the command line, it automatically runs the front end tests?
&gt; I agree with the overall point of your comment, but is this really fair? Each of PCRE, OpenSSL and ZLib have their own dependencies; make of course, plus languages (C, Python, and Perl at a minimum) and their compilers/interpreters That's ridiculously disingenuous - should I start counting npm/yarn, Node itself, JavaScript, the V8 engine, ic4uc, libuv, C, C++, make, etc among the dependencies for serve as well? I know this might be shocking to someone who mostly writes JavaScript, but yes, Nginx itself, PCRE, OpenSSL and ZLib are the only packages required to build Nginx. PCRE, OpenSSL and ZLib have no other (non-optional) package dependencies.
Uniformity is great, but something about there not actually being another item after the comma feels jarring to me. Like I said, totally irrational.
Thank you for your input, but I'm sorry to have to tell you that I could not care less, random Internet guy.
You're not wrong, Walter, you're just an asshole.
Using parenthesized arrow functions is pretty ugly. If we add that syntax, why not also add a way to do partial application? a |&gt; b //b(a) a |&gt; b() //b(a) a |&gt; b(1, .) //b(1, a) a |&gt; (b()) //b()(a) The last one is the rarest, so it should get the most awkward syntax
If you're that fussy, you shouldn't be programming in Javascript as the whole concept of web browsers, Javascript, HTML, etc is like a huge fat bloated warty version of a trailing comma.
yeah, that would be an OCaml, F#, ... thing
I think you're right regarding the official tc39 proposal. The babel one is just inserting the expression on the right hand side as the first argument for the function on the left hand side. So my example should really be const n = 2 |&gt; (_ =&gt; multiply(_, 3)) |&gt; (_ =&gt; add(_, 4)); or (with [papp](https://github.com/tc39/proposal-pipeline-operator#usage-with-functionprototypepapp)) const n = 2 |&gt; multiply.papp(3) |&gt; add.papp(4);
It's something we should bear in mind: all those frameworks and libraries that lighten _our_ load as developers pass the buck to users instead (cost of downloading, parsing and compiling JS).
I think it did in IE something. 
&gt; reach speads that wouldn't be possible either using plain js or jq Every benchmark I've seen has plain JS as the fastest when it comes to DOM manipulation (for obvious reasons).
That are baseline benchmarks, testing the overhead of a managed append/delete/etc. in the real world a framework organizes read/writes in order to not thrash layout, renders only the parts that have actually changed, and the one with the biggest impact is just waking up: async scheduling. You would not reach that in a plain ja app, it actually Quere obvious, too. 
Are you new jere? We reinvent the same shit every week! My drunken weekend brainfart is now a lightweight framework! Anyway, it is probably because most are not formally educated or exposed to existing technology. It is easier to throw together something yourself then to invest in figuring out other solutions.
Obviously past a certain scale of application things like the use of a virtual DOM and so on have clear performance benefits, but to claim that on the whole a framework is faster than plain JS is just nonsense (especially since the framework itself is written in plain JS, not magic). In fact, on a small application it would actually be faster to use tailored implementations of batched updating and reactive rendering than the general case a framework solves for. It's just too much cognitive load for most devs. Beyond rendering there is also things like registering/handling events and so on.
It is not a claim, vdom was invented in the first place to solve the performance problem in an application that scales. It is also logical that it is faster, no matter if small or large, unless you mean a very simple page without state changes that you can just output. In that case vdom would perhaps be one millesecond slower, but it would at least still make the application smaller, more readable and accessable to a large eco system of parts. In a bigger app that difference turns into something that isn't negligible. &gt; Beyond rendering there is also things like registering/handling events and so on. Exactly, a framework uses *a single document event source* and re-pools events to save you from gc hits and other perf pitfalls. Overall there are so many technologies deployed, you would essentially rewrite the framework to reach its speed. 
Yes, this is exactly what I wanted to know. Thanks. The first option sounds easier for me to get started with haha. Is one of the two options considered better or more professional?
Make your own class that extends Array instead of adding things to the array prototype
I'd say that's fake but since this Tencent's Xuanwu Lab has asian letters on their site you may say it's more likely to be real :)
https://github.com/rbuckton/proposal-partial-application
i tried wiht my google chrome, updated firefox and old firefox 9 portable. all of them not vulnerable and safe :|
Trailing commas feel wrong to me, so if you are irrational on the matter so am I. It doesn't feel unambiguous: is that a nothing or a something with a nothing value, perhaps terminating the list with a NULL value. Than again for multi-line declarations and lists I like leading commas, which I think puts me in a minority so what do I know?! I use them for similar reasons all the time in both JS and SQL: let a1, a2 , b , c1, c2, c3 ; and SELECT a1, a2 , b , c1, c2, c3 FROM someTable I also like grouping related items wit short names on a line, as above, which is something that divides opinion too. Many prefer *all* items in a multi-line list to have their one line for consistency.
Do you believe that can make sense to create a scaffolding cli using this skeleton? Would you use it? Thanks for any feedback!
For those who missed it, this is a Redux tutorial I wrote recently. Enjoy!
I don't know how this checker works, but for my version of Chrome it showed that I'm not vulnerable. Then I checked and I don't have SharedArrayBuffer and Atomics globals anymore so apparently my browser has been updated according to what Google Stated here (https://sites.google.com/a/chromium.org/dev/Home/chromium-security/ssca). 
Slow down, 2018 didn't even start properly in programming world.
the article linked wasn't about npm specifically imho, it was just an example. it was about how trustworthy *any* dependencies are. and this IS a serious matter. the author of this article doesn't seem to get that and gets hung up on npm.
You can adjust Prettier so it does that. 
Yes!! That‚Äôs what it was! Thank you! 
Hahaha I would never!
Tried Firefox on browserling site, not vulnerable. Reddit's page viewer also not vulnerable. I also checked the code and it contains lines like: const sharedBuffer = new SharedArrayBuffer(...); So if the browser already disabled those objects the test will show that you're not vulnerable.
Cool project, and I wish you the best with it. As far as the AI part goes, I would say you are barking up the wrong tree. An AI that plays by rules you design is going to hit an upper limit really fast. (This was sort of the dead end of AI for several decades) Since you already have a game engine, I would strongly suggest something in Machine learning style of things. I think that this would be a pretty good pick for "Reinforcement Learning" specifically. (For running the "learning" part of RL, you would probably want to use node, since its going to be a memory hog, and need to run fast and for a while... but when your done you will probably have a set of weights that play quite well) Awesome project! 
ah yes you are right man. i'm enabling shared array buffer in chrome and the script is working. https://i.imgur.com/UTVYQ1h.png this checker is actually really working. Thanks man
I wonder how they plan to sue people that use it..
What would: `['a', 'b', 'c'].includes('a')['a', 'b', 'c']` even do?
Seriously, how is that a condescending comment? Browsers are a poor man's container, they are a cheap VM. These things should not exist, they don't do anything that gopher didn't already do. By having this half arsed "document as application" bullshit, we don't have instant start VMs that would have native performance.
Just guessing here, but array lookup `'c'` in `true`? 
Thanks for the feedback! AI and Machine learning are completely new areas to me, ao I feel a bit lost :) Do you know any good resources for where to to start learning about Machine learning, specifically for AI? Many thanks! 
I have to read this article when I come home from work so I put an comment here to remember. I loved to play RISK back in the days so i created a clone myself but for online multiplayer instead of AI. It's actually a clone from the game General that existed on blip.se years ago, I notice the .se in you domain maybe you played that game long time ago?.
that is good stuff, thanks OP
[removed]
Not specifically aimed at OP, but two things that really bug me about most redux tutorials are the insistence that Redux completely replaces local component state when that isn't necessarily true, you can easily end up over-complicating your redux store that way. The other is that redux + react = functional react which again isn't necessarily true, certainly makes it easier but one does not necessarily equal the other. The main benefit of Redux, where it is appropriate, is sanity.
what do you mean by "functional react?"
That code does not give a Korean timestamp. `0` is falsy in Javascript, so saying `if(0)` is equivalent to saying `if(false)`. Meaning the following code will never run: if (0) { // Korean format var month = date.getUTCMonth() +1; var day = date.getUTCDate(); var hours = date.getHours(); var minutes = "0" + date.getMinutes(); var seconds = "0" + date.getSeconds(); var formattedTime = month + "Ïõî " + day + "Ïùº" + " " + hours + ':' + minutes.substr(-2) + ':' + seconds.substr(-2); return formattedTime; } So the function is equivalent to function getDateTimeString(timestamp) { var date = new Date(); return String(date); } Which should give you a date in your timezone.
[**Lisk Github**](https://github.com/LiskHQ/lisk) Invitation: Lisk, the decentralized blockchain application platform, would like to cordially invite you to the Lisk Relaunch Event on 20 February 2018. The Lisk network democratizes blockchain technology by enabling users to build their own decentralized apps using the mainstream language of JavaScript. LSK, the token underpinning the Lisk platform, is one the top-performing cryptocurrencies globally, with a market capitalization of over $3 billion USD. The Relaunch Event is a major milestone in Lisk's development roadmap, including the rollout of new front-end design, dashboard and wallet, among other announcements. It also comes ahead of the release of the alpha-version of the Lisk SDK for blockchain applications. We would love for you to be part of this pivotal event. The details are as follows: Date: Wednesday, 20 February 2018 Time: 7:30 PM-12:00 AM Location: Westhafen Event &amp; Convention Center, Westhafenstra√üe 1, Berlin If you are not located or able to make it to Berlin for this event we will be hosting a Livestream of this event which will be made live on our [**Lisk Youtube**](https://www.youtube.com/liskhq)
Looks Interesting :)
Thanks
There is no such thing. It was a reference to maximising the use of stateless functional components and the fact that every article about react or redux seems to have a section on 'how to learn more about functional programming'. This very article switched from using class based components to stateless function components for no real reason. Would you use a stateless functional component in this instance? Sure, but it certainly doesn't aid the understanding of using React and Redux together, I'd argue its a different topic entirely with its own set of advantages and disadvantages. Definitely outside of the scope of a Redux tutorial. Not that I am against these things, I use a functional approach wherever possible as I feel it results in clearer code but there is a certain implication when it is added to articles such as these that React/redux and functional programming go hand in hand just becase they sometimes use a functional approach.
Glad you find it helpful! Thanks for reading.
Please use more meaningful headlines. 
You could hear cycles/patterns. This could maybe help visually impaired glean more light into sort behavior. Cool experiment. 
I just saw somewehre in /r/programmer a article about meltown in webkit from the webkit blog Maybe only webkit is vunerable?
Does this library do "deep" patches / does the patch via spread operator support "deep" patches?
Can't wait to develop on this platform 
This would be better placed in r/LearnJavascript In any case... This is the "original code": function Vector(x, y) { this.x = x; this.y = y; } Vector.prototype.plus = function(other) { return new Vector(this.x + other.x, this.y + other.y); }; With the proposed module structure it simply becomes: (function(exports) { /* A */ function Vector(x, y) { this.x = x; this.y = y; } Vector.prototype.plus = function(other) { return new Vector(this.x + other.x, this.y + other.y); }; /* B */ exports.Vector = Vector; })(this.map = {}); Inside the module, that is, between points marked `A` and `B` you forget about `exports` and whatnot. You refer to `Vector` as `Vector` and build that module as you would. Usage outside of the module, would just be... var v1 = new map.Vector(3,2); var v2 = new map.Vector(6,1); ...and... v1.plus(v2);
Those things are indeed not very easy to setup. Here is an article that might help a little: http://dev.topheman.com/package-a-module-for-npm-in-commonjs-es2015-umd-with-babel-and-rollup/ (the first half or so is only relatively basic stuff, you have to scroll down to the build steps)
Looks like yes from glancing at source / no
Not to mention the fact that under the hood, react turns your stateless pure functions into classes!
take a look at fbjest or ava. For end-to-end testing take a look at Cypress.io
Thanks a lot! Will definitely read this.
I think Redux store should be treated a little like shared state database that could be serialized to JSON at any time. Keep it relational and as flat as possible and it'll stay clean. Anything you consider to be application state, like selected product id, should probably live there along the list of products, normalized into id-indexed collection for fast selections. Putting current status of every input field there would be silly, because changes in them are probably only relevant to their specific components. Component's state is implementation detail the application as a whole isn't concerned with, there could be 20 pieces of state that are irrelevant until some criteria is met and only then the state becomes relevant to the rest of the application, so an action should be dispatched.
Don't listen to that wanker, guy is a nutter. Your project is great
Rxjs is not state management. Rxjs is asynchronous pipeline processing. It can almost be thought of as really fancy promises. You can build a state management system with rxjs, ie ngrx, but by itself it is not a state management library. I still don't understand why the state of js survey listed it as such. I can only assume the survey creators have never used rxjs.
I agree with both of you! Take a look at https://www.valentinog.com/blog/react-redux-tutorial-beginners/#React_Redux_tutorial_Form_component_and_Redux_actions Even when using Redux it is fine to have stateful components. Not every piece of the application‚Äôs state should go inside Redux.
Ahhh, thanks for that clarification
I have about 5 years of professional experience as a js guy and I still find some of the easier challenges on Codewars to be pretty tricky. I think it‚Äôs probably less about mastery and more about getting really comfortable learning and teaching yourself new things 
Can somebody please ELI5 why use redux when there‚Äôs mobx? I‚Äôm new to react-native and found mobx a lot easier to understand and implement. 
I used `mocha` with `chai` for years and loved it. In the past year or two, made the switch to `jest` and have not looked back. `jest` just feels like an out-of-the-box solution for 90% of what I want to do in my tests. `mocha` worked but only with `chai`. `chai` worked but only with `sinon`. `sinon` worked but.... `jest` is basically just `yarn add -D jest` and go. 
It sure was a nice reading, hope I will find some time to check out your code som day :)
It is funny that all those tutorials always require react, where I would like to see pure redux tutorial, for how to approach data structure problems - agnostic in relation to the frontend framework.
Easier is relative. Mobx has many benefits and i'm sure it makes sense in a lot of situations, but it's still a complex system with a full api surface, edge cases and documents to study. In comparison redux is a *tiny* javascript-centric pattern with two or three apis. The main reasons i prefer redux: - i regard it as a clean solution, there is no magic, no hacks or circumventions - it is a simple but explicit convention that helps establishing a clean architecture. That isn't mobxes primary concern as it continues to let you mutate and destroy clarity at will. You *can* behave, use a central store and actions, but that's up to you. Overall i'd prefer immutability over mutation always when given the choice. - works with plain javascript objects, everything can become reactive: for instance loading a json, then getting patches from the server through json-patch - it just doesn't dictate how data must be shaped - doesn't wrap or mutate objects into pseudo-proxies - has bindings for everything, the logic container is framework and platform independent If you want to go in deeper i suggest watching this video: https://www.youtube.com/watch?v=76FRrbY18Bs
Try adding `location=yes` to the feature-string: https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features **EDIT:** I just tested it in Chrome and saw no change; both times, I saw an address bar that could not be interacted with.
Thank you :)
Jest is great, is generally close to mocha (for those already familiar with it), and has great tooling features. Otherwise cypress.io is the way to go, especially for audit trails.
trailing commas are ugly to look at, but are a godsend for refactoring.
&gt; with eight amount of effort and perseverance. Arg, I only have 2 amount.
looks awesome, will try it out
Thanks!
Thanks so much for the detailed answer. I'll have a play around with it and hopefully I can get it sorted.
If you need anyone to help vet your coursework let me know. I've been using and contributing to it for 4 years or so ;)
hope you like it :)
At start I built T(a)rdis to be used along the spread operator, but as the spread operator do not support nested, the diff function do not handle deep patch creation by default, but it provide a deep option you can set to true. https://github.com/Swizz/trdis#function-diff-from-object--array-to-object--array-deep-boolean--patch The patch function allow the exaclty same parameter to do the reverse job.
Too many low-ballers in the online freelancer market, and a lot of time and effort to get into the upper niche level. You're probably better off devoting your time and energy to wrapping your head around one of the app frameworks and getting something into the App store and / or the Play Store.
Make money with an web app on play store sounds good, what kind of app could worth to spend time on building? I thought people would pay just for games in Playstore/app store
this is work when you enable shared array buffer. take a look https://www.reddit.com/r/javascript/comments/7p5r3j/found_this_spectre_and_meltdown_checker_online/dsevlzx/
The article is also supposed to be about "the React ecosystem", and Rx is not part of that either. :/
&gt;"functional react" you mean Elm?
What does your directory structure look like?
I‚Äôm sorry. I‚Äôm pretty new to coding. I‚Äôm not sure what you mean
"How can I change div content pure javascript". I wanted to let users change whether blog posts appear as a list or cards and store that choice with absolutely jack experience. After figuring I'd never learn the language (no programming experience didn't help) I gave up entirely on learning. Years later, I'm now comfortable enough with the language to do relatively large solo projects. &amp;nbsp; Moral: Walk before you run (start with small projects, don't be me)
Look at Dan's tutorial on egghead. He's the creator. Also Mark Erikson has a lot of good info in the redux docs about structuring reducers. 
In any computer source code, there's only two types of valid quote characters: `"` or `'`
I think the main thing to keep in mind is templated strings are actually functions. Usually that doesn't matter and they are just cleaner and nicer to use. But every once in a while it could potentially create an issue so it's good to be aware of even if you never run across it. Other than that I don't know any reason to not prefer templated strings.
I know. I just typed this on my phone. I used proper quotes in my file :) 
Where are your files? Does the JS file exist in the same folder as your HTML file? You need to write the src as a path. So something like ‚Äú./scripts.js‚Äù Also in type put ‚Äútext/javascript‚Äù. It‚Äôs not needed in HTML5, but if you don‚Äôt know what you‚Äôre using then just use it to be safe :)
Yes hey are both in the same place. And in my type i have my file name. Even when I put all of it into jsfiddle it doesn‚Äôt link. I don‚Äôt understand 
So basically fallthrough as I understand it is what happens when you don't include breaks in your switch statements. A switch statement can and will match every condition possible if a break is not included. That is why you can do what you did in that gist and have multiple conditions execute the same block.
Type is the type of file. So it should look something like this all together (on a phone so I‚Äôll do my best about catching typos): &lt;script type=‚Äútext/javascript‚Äù src=‚Äú./scripts.js‚Äù&gt;&lt;/script&gt; (Replace my quotes with proper ones as the other user mentioned in the comments)
I actually followed redux docs chapter "Normalizing State Shape" and common patterns. This was valuable advice(I don't use react at all), so it would be nice to see more redux tutorials agnostic to view solution.
Here is a useful forum with information for you: [stackoverflow answer](https://stackoverflow.com/questions/13739568/how-do-i-link-a-javascript-file-to-a-html-file) 
Okay but don‚Äôt I link the file name like hangman.js in the part where it says text/JavaScript? When the file is on my computer saved
Oh okay. Thanks I‚Äôll try that :) 
Yes absolutely.
You‚Äôre welcome! DM me with more questions and I‚Äôll reply later today. Phone is dying
Still doesn‚Äôt work though. Nothing changed
I don't know who would support such a ridiculous way to write a switch statement. That flies in the face of the very basic principle of writing readable code. Furthermore you should be asking yourself what is the alternative to using a switch statement. They tend to lead to some really gnarly code. Is it really a 2 case switch? Why not if/else or early return. Or if it's bigger than 2 consider refactoring out the switch entirely.
Template strings are expressions that can evaluate with replacements, but they aren't functions. That seems a bit misleading.
Really just seems like a personal preference things. Unless you're using interpolation or tags, there should essentially be zero performance difference between the template literals and single/double-quote strings.
Technically it's still a fallthrough, but a case with an empty body is the only way to emulate a non-fallthrough (aka "structured") switch in JS. A structured switch will (usually) only execute one case block, but usually you can provide multiple cases with a single `case` statement. That would look something like: switch (expr) { case A, B: doSomething(); case C: doSomethingElse(); } Which would execute `doSomething()` for `A` or `B`, and `doSomethingElse()` for `C`. A `break` isn't necessary with this style of switch. Some languages (like JS) will start execution at the first matching case, then "fall through" other case statements until they reach something that interrupts execution (usually `break`). That's what your coworker is doing: switch (expr) { case A: case B: doSomething(); break; case C: doSomethingElse(); break; } On `A` we fall through the `case B:` statement, and execute `doSomething()`. `B` accomplishes the same thing by simply starting execution at its case statement, and `C` executes `doSomethingElse()`. [Wikipedia](https://en.wikipedia.org/wiki/Switch_statement#Semantics) has a decent writeup, and gives examples of how different languages handle switches.
Tagged template literals are function *calls*, though.
Making money from side-gigs as a developer can be extremely lucrative but will take a huge amount of time and dedication to get to that point. Seriously, if you're not willing to work and extra 20+ hours a week at home you might not want to even bother trying. Throwing your information onto freelancing websites isn't going to do any good. I'm going to talk about some of the ways you can develop extra income. **Freelancing / Consulting / Writing.** Freelancing, consulting, and tech writing are all very different but share one very important common element. Your personal brand. Your personal brand is what sets you apart from every other random developer, without one you will fail. How do you build a personal brand? 1. Find a niche. Maybe its doing wordpress development, native app development, the react ecosystem, whatever. Pick something and become an expert at it. 2. Build a portfolio. How do you do that? You're going to have to spend months developing for mock companies, family and friends, small local business, contributing to open-source projects. All without making a dime. If you go the route of wordpress development this means asking family and friends if they need anything done, researching local business, coming up with new designs, physically going to the business to meet with the owner and pitching them the idea. If you want to get into consulting you're going to have to spend time answers peoples questions online, participating in events to teach people, anything that gives you a track record of being able to help people solve problems. Going the route of writing and public speaking is going to take months if not years of practicing teaching new things to groups of coworkers, speaking to young students about tech, applying for calls for speakers through services like [Lanyrd](http://lanyrd.com/calls/). Whatever your niche is, you need to build up a track record of domain expertise. 3. Treat it like a business. It is. Register as an LLC. Get organized. Be professional. At some point you're no longer going to have to hunt down clients, they'll be coming to you from word of mouth recommendations. You're not going to be able to accept all jobs that come your way. When this happens tell them your backed up and that you can't get to them until X weeks/months but offer to recommend or introduce them to other freelancers/consultants whos produce quality work. This will help you build a network of people, and leave people with a good feeling about you. Freelancing is the most obvious of the way to make money which also makes it probably the most competitive. Most of the freelancing gigs are going to be wordpress jobs and there are so many people and agencies that do this now. As a solo freelancer you're going to be competeing with agencies who have very diverse teams: designers, developers, marketing people, SEO experts, PR writers, etc. They put out top notch stuff but at a higher price. In order to compete with agencies you need a rock-solid portfolio and competitive pricing. Consulting, speaking at tech conferences, and writing blogs are all very interconnected. It can be very lucrative but requires a very strong personal brand, a long history of experience, and an incredible amount of marketing, communication, and sales. Talking to people, going to conferences (and speaking at them), getting involved in the local dev community are crucial. Many speakers and blog writers use that as way to generate leads for their consulting or their company. **App development/publication.** The days of making millions off a weekend project app are over. You think you have an idea for a great app or game? Spend months researching before you ever write a line of code. * Look for similar apps * What problem does your app solve? * What differentiates you from the competition? Is that differentiation easily copied? How big is you competition? What does your competition's customers think about their product (what to they love/hate) * If there truly is no competitiors then you need to analyze the market. Are you solving a problem? How valuable is your solution? * What is your revenue model? Think of your app as a startup (because it is). Make a [pitch deck](https://fi.co/insight/creating-a-startup-pitch-deck-start-with-this-easy-to-use-template). Go to local pitch competitions. Look for target customers and assess their needs and wants. Once you have an idea of the problem you're solving, the market oppotunity, and who your customers are, then you can start building it. Still, it might fail. If it does identify why you failed. Did you not validate the business model well enough? Could you not execute the tech well enough? Whatever that reason, work on that and try again. Maybe with a completely new project. My most downloaded app (100K+ downloads) made me exaclty $0. My most profitable app had a fraction of the users but solved a much bigger problem. **Bug bounties.** There is a mertic fuckton of money to be made in bug bounties. I'm talking upwards of $10,000 USD per bug. I'm not going to expand on this much because I don't have much 1st hand experience (I've submitted 2 relatively small bug, one of which they didn't think was big enough to pay me, and the other I got a whopping $100 for) but you need to be an expert in securty, lucky enough to find bugs that others haven't found yet, and patient when someone else beat you to it. 
I'm afraid this package takes double the time of `npm i` when tested via `time ni`. Furthermore, it uses font glyphs that aren't universally available, particularly on my own terminal where only the checkmark displayed. This seems to be mostly a cosmetic wrapper around npm rather than something new like `yarn`. 
Did the survey, there are a lot of spelling error and grammatical errors FYI
You've come to the wrong place. 80% of the people here are kids under 20 who have never worked in the business. I would have thought your school would have taught you better ways to obtain this information.
This isn‚Äôt a tutorial, but it‚Äôs a good high level read to get you started: https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44
Yeah, the way he wrote that was really weird. I tried to pinpoint that as well but he said he structured it that way because he's separating the "initialization" from the "execution" of the code. But like I said, he's really persistent. Even told him that it's breaking the principles of DRY code. But he won't really back down and I'm kinda losing my patience as well. So I just passed it off to the other guys.
Exactly! And the reason he doesn't want to combine the 2 switch statements is because, for him, fallthrough does more good than harm... 
Don't be a piece of shit. Be a man instead.
Are there any webdev/javascript meetups in your area? Might be a good place to network.
I agree... What we argue about is the fact why he's ok with this kind of style: switch (expr) { case A: var1 = 123; } switch (expr) { case A: case B: doSeomthing(); } But is so against what i suggested of doing: switch (expr) { case A: var1 = 123; case B: doeSomething(); }
Why would you do this? This has been done a thousand times before. Why this?? For bonus-why: are you using Redux, too?
They are (and always will be) strictly better in the sense that they can do everything normal strings can do, and more. The only reason why we don't use them for everything (as far as I can tell) is probably because backticks are kind of ugly compared to quotes. But maybe someday that'll change, and template strings everywhere will become the standard. I could see that happening. People would just need to get used to the idea, just like with JSX and static types.
In my opinion, the easiest framework to get into is hyperapp. It's extremely tiny and therefore has about as small of a learning curve as a framework can have. Vue is another popular choice for beginners to frameworks. It's bigger but more feature rich. React is arguably the most popular but has a bit of a learning curve. Angular is the most feature rich but has by far the steepest learning curve.
In general I agree with you that having two switches with the same conditions, one right after another is pretty pointless and annoying (and I typically wouldn't even use a switch unless I had a bunch of very simple conditions). It really depends on how the rest of the codebase is written though, since it's usually more important to just be consistent.
Source please
Ha this is funny , I know grown men that have been on Reddit since it startedbut still use irc to chat and I ask these newbs at work( the 20's group) if they saw front page today and they give me blank snapchat/IG faces.
Sorry but what's your point and how is it related to what I posted? I'm drunk btw don't kill the messenger
Any ideas for use cases?
[removed]
Medium articles on micro services?
[removed]
According to the spec, a template literal with no substitutions winds up being exactly the same as a string literal. It's a bit convoluted, but the important bit is &gt; *TemplateLiteral* : *NoSubstitutionTemplate* &gt;1. Return the String value whose code units are the elements of the [Template Value] of NoSubstitutionTemplate as defined in 11.8.6. &gt;([Source](http://www.ecma-international.org/ecma-262/6.0/#sec-template-literals-runtime-semantics-evaluation)) Template literals with substitutions are basically just syntactic sugar for `String.prototype.concat` (which is what the rest of 12.2.9.5 describes). I didn't dig into tagged template literals, but it should be obvious that those involve a separate function call.
It's basically all because of the filesystem calls. The meltdown patch makes syscalls slower than they already are, so that's where the speed hits are coming from. It's a sad day for speed demons for sure, but there really isn't anything webpack or anyone can do about it, they need access to the files, which has to call into the kernel. There really isn't a way around it. But awesome job on the benchmarks! Out of curiousity, how many files get touched from `node_modules` during your webpack build (the stats.json should be able to tell you)?
Because the problem lies in the number of system calls, it's possible to work around this by, say, storing data in a single file and reading it. That is magnitudes fewer system calls than reading many files. It's not totally helpless.
m8, own up.
Lol pray you're not using npm on windows. It was EONS slower before the patch even hit.
a PR adding this syntax to the README was actually just merged into the master branch https://github.com/tc39/proposal-pipeline-operator/pull/79
Hipster cred?
Yes. Assuming that the JavaScript is enabled.
If you're referring to a client-side MVC framework like AngularJS, then I would go with Express so you can make very simple API calls. If not, Sails will probably get you going fairly quick.
wow, thanks a lot for taking the time to do this. the first two functions make much more sense now. I do need to spend more time understanding the third you included as its a bit tricky for me. thanks again for helping me. 
Did you read the article linked in the OP? Your questions are exactly what it's about. The tl;dr is basically &gt;Using backticks is better because you rarely need to escape backticks `` ` `` or `\${`, you get multiline support, and you get variable interpolation. and since there are no downsides compared to normal string literals (because they basically *are* string literals), they are "strictly better".
Define "extra". If you spend less you have extra to save. If you put max amount into 401k you get taxed less and have extra take home pay. If you're one of the best at what you do, you might get extra % raise, or an extra bonus. Here's a tip: change jobs every 2 years, to maximize pay increases and ensure you're getting top dollar. Shop for a new job after you just receive your 2 year pay raise: a new employer will typically pay you 10% more and you effectively get double raises every 2 years. Extra tip: you can do this and still have a life outside of work.
i wanted to cheat on a clicking game :D I think it's important to learn the DOM, everything else you basically earned in CS 101: intro to programing. 
I'm strict that if there's no interpolation, I use normal single quote.
But you're justifying not having locks on your house?
&gt; React is arguably the most popular but has a bit of a learning curve. What makes you think that? The cognitive overhead is minimal. React is a tiny javascript-centric view-layer pattern, the whole API fits written on your thumb. You can [learn it fully under an hour](https://egghead.io/courses/start-learning-react), in your list the only alternative that would fit that description is hyperapp, which is a React clone.
How is that justifying not having locks in your house? Do you understand how Spectre and Meltdown work?
Wow you're so smart for reducing it to a door lock analogy Please make a car analogy so we can understand the performance impact
Through a design flaw that has been known about for years but only made public via google? I'm not sure what you're getting at here. They sold a product that was not secure, and then they made it "secure", which dropped performance by 40% in some cases. They could have just sold us a secure piece of hardware marketed with actual speeds. 
...pay a little more attention, I'm not the one who used the analogy Also &gt; Do you understand how Spectre and Meltdown work?
Nice looking tool, well-made ‚Äî very elegant usage
You use workers for everything you don't want to do on the main thread. We use something similar (worker-loader) to process and unpack compressed meshes we get from the server. To do it on the main thread would lock the application. It processes several meshes on multiple cores. When the result is ready we take the data and display. I really like the api of this one, gets rid of the postmessage stuff. I think i'll try replacing worker-loader.
Do you actually have anything to say besides snark?
They still throw syntax errors on older android browsers or things like phantomjs.
But it is affected by Spectre, which preys on the same (base) vulnerability. Your point?
How is it different from Number.toLocaleString? number.toLocaleString('de-DE', { style: 'currency', currency: 'EUR' }) works for me.
Erm no. You sold me the product with the assumption it was secure. And now you're saying it was never secure and to make it secure impedes it's performance. And you knew about the fault at the point of sale? I think that's a pretty strong case for product recall.
You had some errors in your code. "&lt;/h1&gt;&lt;img scr="+ response.items[i].media.img.url +"/&gt;" was throwing an error, cause there is no media attribute on response's items. Also it's src and not scr. https://codepen.io/anon/pen/VyXezW?editors=1010#0
can you tell me how to do this with a post loop like i create
Well good luck returning all computing devices that use processor architecture that's less than like two decades old
Return it? They can come collect it when they've got my replacement ready thanks.
Soooo...business as usual?
Replace forEach call with your for loop. It's simple and you should be able to figure it out on your own. Resource: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
You basically said that the optimization (design flaw) that dropped performance by 40% is "not even Intel specific". Nodedotsj said &gt;Through a design flaw ... which dropped performance by 40% in some cases and your reply &gt;It's not a design flaw lmao. The optimization works exactly as intended ... it's not even Intel specific. At best you could blame all processor manufacturers 
And you can develop a chrome extension, install it locally, modify your page as you want. Why an extension ? Imagine your dad refresh the page.... just imagine his reaction x) About your university ? You are safe. Client side, is the client world. You can do whatever you want. But don't expect its working everywhere. Just on your computer. If he consults the site on another computer, you are f*cked. We are growing in a f*ckin world where everybody lies... As a daddy, dont do that. This is very, very, very disappointing and sorrowful for a dad that his son lies to him.
Instead of XMLHttpRequest, use `fetch` and `Promise.all`.
Transform yourself into a human-local-webagency. Pick tiny client that just want a single page. Billing them as lower as you can. You can expect some 300$ to 1000$ for the work. Every shops/person/freelancer wants a dedicated web page, but still thinking that is not affordable. 
...I'm not even sure why I expect better. &gt; a failure to design faster chips Do you know how processor architecture/manufacturing works?
...at this point I have to ask if you understand how Meltdown and Spectre work, because both you and Nodedotsj are mixing up so many things I might be better served just linking you to a primer on processor architecture
&gt; ..I'm not even sure why I expect better. Oh the chore you must go through having to correct people on the internet. I really feel for you.
I don't know, I just expected people on a programming sub to be a bit better educated on how computers work than the average person on the street
Hi i would really glad to chat with u, which of messangers fit u?
Let's use Reddit chat. 
Spectre patches _do_ impact performance. [Here's Microsoft warning of just that](https://www.theverge.com/2018/1/9/16868290/microsoft-meltdown-spectre-firmware-updates-pc-slowdown). Meltdown specifically targets kernel memory, which is why flushing the cache can protect against it, and this affects programs that make a lot of requests to the kernel (e.g. for reading from/writing to disks). 'Fixing' Spectre on the other hand is not really possible IMO, because it's an inherent flaw of out-of-order processing. That's going to need a new line of chips.
Hi, author here, I'm curious to see if others find this utility useful. Every since I started using async/await and the `until` utility testing UIs become significantly easier.
Proper LPT Right here.
Intel, as a chip manufacturer, is failing to design faster chips, irrespective of the cause of that failure. What, I should have used the word "manufacture" instead of "design"? You make one flippant comment on reddit and immediately have to defined yourself against pedantic pricks looking for an opportunity to show off their superior knowledge. Fuck off.
How is Intel failing to design faster chips?
They've hit their manufacturing limit.
...no? Do you know what _diminishing returns_ means? Actually do you even have a point at all?
Intel are failing to produce faster chips. (It has something to do with how small circuitry can get on silicon). So in order to create demand for new chips they come up with this brilliant marketing scheme to say all the old chips have a fatal flaw, producing a reason for everyone to have to buy new chips. I present this idea as a tongue in cheek reddit comment. I am immediately forced to defined my understanding of the chip manufacturing process. So my point is, you're a pendantic prick. Or what reason are you continuing this conversation? In the hope you can find something you definitively know more than me about?
Yes, and AMD, ARM and dozens of other chip manufacturers up and collaborated with them on it. The concepts of OOOE and speculative execution, and the published PoCs that demonstrate the vulnerability also retroactively came into existence just to justify Intel's huge fraud. Also lizard people are real and live under the flat earth and Jews did 9/11.
Yeah, sure. Let's just condemn a successful open source project based on personal preference. 
I didn't know that the performance drops were that big for specter. I guess [google](https://security.googleblog.com/2018/01/more-details-about-mitigations-for-cpu_4.html) classifies 5-10% performance drops as 'negligible'.
As someone who has never tried node.js, this article is ridiculously harsh. People are getting things done with node.js. The article gives me no reason to believe node.js should "die in a fire." If every open source project that had a more performant solution disappeared tomorrow, the world would not be a better place. Also, the benchmarks here don't have any details about what the servers are serving, so they have little value, but that's besides the point.
If what do you want is to practice english you're going to have more luck in these other subreddits: https://www.reddit.com/r/language_exchange/ https://www.reddit.com/r/ExchangingLanguages/ https://www.reddit.com/r/LanguageBuds/ They're specifically made for that purpose.
The thing is for most applications, we're talking about some operations that took microseconds taking a few more microseconds. The impact on _perceived_ performance is negligible - as you can see in the OP with the end to end tests. The apps that take the biggest hits are the ones that rely on tasks only the kernel can perform (like the build which does a lot of reading and writing of files, probably stdout/stderr as well, etc) because those micro and milliseconds add up.
You could also take a look at [Strapi](http://strapi.io)
As someone who's written code in Pascal, C, Java, PHP, JavaScript and a few other languages since the late 1990's and who currently makes his living as a frontend R&amp;D software engineer, I never understood the hype around Node.js beyond "let's try to do everything in JavaScript". It seems to me the popularity of Node.js is based mostly on hype by questionable management types and lazy programmers who can't be bothered to learn a language other than HTML/CSS/JavaScript. Anyway, there's a reason people still prefer LAMP stacks to Node based environments for hosting their websites 8 years since Node.js was first released. And the reason is that Node.js's single threaded environment is simply ill-suited for reliably hosting websites. Also, the Node.js core API is much too limited to compete with even a poorly designed language like PHP. No amount of marketing BS seems to be able to overcome this. Today, January 2018, everyone seems to be using Node.js, but as thr backbone of their build chain rather than a web server. And while this may be an improvement from relying on a mixture of shell scripts and Ruby scripts only one programmer in your company really understands (who may or may not have already left the company), Node.js is incredibly overused in this context, turning the typical build chain into a virtual equivalent of Rube Goldberg machines. This is why, even though most code I write is JavaScript code, I totally relate with that article and the frustration with hype-driven development that fueled it.
Npm v3.10.0 more or less resolved this, no? https://github.com/npm/npm/issues/11283
Neat exercise in the form of a life hack! Nice job on the site overall! Just my two cents: 1. The objective could outline the features of your gumroad lifehack instead of having the reader go to the site and figure out what's going on. It's a friction for beginners. 2. The checkboxes (beside the bullet points) at the bottom of the requirements look clickable! :). Is this intentional?
In JavaScript, objects are passed by reference and primitives are passed by value. [From MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions): &gt;Primitive parameters (such as a number) are passed to functions **by value**; the value is passed to the function, but if the function changes the value of the parameter, **this change is does not reflected globally or in the calling function**. &gt;If you pass an object (i.e. a non-primitive value, such as `Array` or a user-defined object) as a parameter and the function changes the object's properties, that change is visible outside the function, as shown in the following example: function myFunc(theObject) { theObject.make = 'Toyota'; } var mycar = {make: 'Honda', model: 'Accord', year: 1998}; var x, y; x = mycar.make; // x gets the value "Honda" myFunc(mycar); y = mycar.make; // y gets the value "Toyota" // (the make property was changed by the function)
Just avoid mutation and use shallow copies: let a1 = arr1.map(a =&gt; ({ ...a, test: 'updated' })) let a2 = arr2.map(a =&gt; 'NOT updated')
What do you mean?
&gt; Anyway, there's a reason pretty much everyone still prefers oldschool LAMP stacks to Node based environments for hosting their websites 8 years since Node.js was first released I'm not sure that assessment is [accurate](https://i.imgur.com/ruIQUcG.png). Node.js is *very* popular.
Oh, right üòÑ
&gt; webpack-dev-server has entered a maintenance-only mode. We won't be accepting any new features or major modifications. We'll still welcome pull requests for fixes however, and will continue to address any bugs that arise. Announcement with specifics pending.
So the code I posted works with Korean formatted timestamps that look like `1Ïõî 10Ïùº 09:20:46`. But since the if statement that returns the korean timestamp never runs, it looks like you are just getting the Date object as a string in the Korean timezone. This actually makes it an easier problem since you can create a new Date object from just that string, e.g. `var korean_timestamp = new Date("Wed Jan 10 2018 08:00:43 GMT+0900")`. And to get it in the current timezone of the computer your using, all you have to do is make it a string again, e.g. `var melbourne_timestamp = String(korean_timestamp)`.
I am certain there are many class actions in the works - though as the consumer I would not expect much if any compensation. 
Right. It's not a whole another package manager like yarn. I made it as a third party of `npm install`. and I'm pretty sure It wouldn't take double time of `npm i` because it actually executes the same command `npm i` and If there's no packages added without `--save` option, It wouldn't waste no time.
I'd recommend learning Laravel. It's opinionated but it has everything you could ever ask for and great learning resources (laracasts.com)
Well FWIW, I haven't seen any significant decrease in performance on my desktop, but I didn't grab any "before" numbers (just general feeling), and I'm using a... *unique*... setup. (i7-4960X, 12GB ramdisk) Also the main project i'm basing this on is a bit larger (`find . -type f | wc -l` returns `159214`, it's a monorepo for a few different front-end projects). Also, it looks like the general consensus is that older CPUs are getting hit with bigger performance impacts, so it seems like your results line up with that. file caching programs that exist separately from the runtime tools (AKA always running in the background) will be able to help for "second run+" in this case, but I honestly think the impact won't be as doom-and-gloom in the near future. File caching like that adds quite a lot of overhead in terms of memory usage, and often CPU usage in some cases, and while it could save the problem, it's a lot of complexity for an area that I don't think deserves it. Webpack (and friends) already have "hot reload" and "livereload" style features where you run it once, then it just file-watches and keeps everything in memory for when something changes, and those "refresh" cycles shouldn't really be impacted by the meltdown patches all that much. Yeah it gets worse, and module bundling is probably one of the areas that will be impacted most by this fix, but syscalls were already slow as molasses, and any easy gains to not use them have most likely already been done. Either way kudos for doing the work here! I sure as hell appreciate the numbers!
Awesome!
As author of the "Structuring Reducers" docs section (which includes the "Normalizing State shape" page), that makes me _very_ happy! :)
It‚Äôs really super dumb. This author is totally out of touch and has poor reasoning skills. Dudes talking about freaking lamp like it‚Äôs 2001 while people are out here deploying static react sites to github pages or s3 with one command builds and deploying bundled serverless functions to node environments on google cloud functions and AWS lambda all using node for the build and deployment process. 
You can use promises with XHRs.
Great thanks for the response - I'll take a loook. 
Does Jest allow tests to run in the browser as mocha does, or is it only for command line testing with node? We also want the ability to run our unit tests from different browsers using browserstack.
Yes, this is what we also feel with mocha, but once its setup it does seem to tick all of our boxes. 
I‚Äôll bite https://github.com/mcshiz/migraine
Why do you not use arrow functions or let/const?
....
I didn't know typing `new Promise(function(resolve, reject) { })` was harder than learning a whole new API
How is typing that line more complicated than fetch? OP already has their finished, working XHR - why must they rewrite it using fetch instead of just wrapping it in one line of code?
Why insist on using an outdated API? It's not like it's a lot of code that has to change. You are making a waaaaay bigger deal out of this than it really is.
Hello, I did a crosspost at /r/webdev and someone over there presented a workaround that worked perfectly for what I needed (https://www.reddit.com/r/webdev/comments/7p6wy5/animate_script_xaxis_scrolling_help/). I really appreciate you reaching out!
Here's a sneak peek of /r/webdev using the [top posts](https://np.reddit.com/r/webdev/top/?sort=top&amp;t=year) of the year! \#1: [Have you ever felt this??](https://i.redd.it/apcs1kvrpy4z.jpg) | [283 comments](https://np.reddit.com/r/webdev/comments/6iklbl/have_you_ever_felt_this/) \#2: [The FCC is killing Net Neutrality - Help spread the word in your own websites](https://np.reddit.com/r/webdev/comments/7emfo5/the_fcc_is_killing_net_neutrality_help_spread_the/) \#3: [An animated loading icon I made for my side project mydevportfol.io. Supposed to convey that the app is coding the user a website. Happy with how it turned out, feedback appreciated though.](https://i.redd.it/qftx8zcngnjz.gif) | [200 comments](https://np.reddit.com/r/webdev/comments/6xsl3l/an_animated_loading_icon_i_made_for_my_side/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Do we know why? Is there a replacement at present?
Maybe webpack is going to release a cli feature to serve based on your config?
They block ads. If you host your javascript and css on a server that usually only serves ads, sure, they'll get blocked. If you names them "advertisement.js" or something, yeah, it'll probably get blocked. But otherwise, no. They don't break the functionality of the site. They just hide ads.
&gt; Please note that webpack-dev-server is presently in a maintenance-only mode and will not be accepting any additional features in the near term. Most new feature requests can be accomplished with Express middleware; please look into using the before and after hooks in the documentation. Basically there isn't much reason to maintain the core application. It's mature and likely only to bloat at this point. If additional features are needed, they should be added as plugins to existing hooks.
Because fetch still needs a polyfill for IE and edge &lt; 14. You're giving an API that won't work on all browsers to someone who doesn't know what promises are. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
Honestly, Madge is probably going to be your best bet, so you should buckle down and figure out the layouts (or hack the project to meet your needs). Otherwise, `npm ls` might provide a barebones view that requires zero installation or setup, though it only operates on NPM modules. https://docs.npmjs.com/cli/ls
Im not entirely sure about this but I think ads are blocked based on where the ads are being pulled from. Kind of like blacklisting certain domains/urls. I don't foresee any problems with your plan tbh 
Nice looking page for your project! As a potential user, I really like to see screenshots, and couldn't find any -- am I missing them?
Search "site:edu learn JavaScript" best result will appear in front of you. Here more google search operator that will help you to search your course online: https://www.universalmanual.com/2018/01/google-search-operators.html
You also need a Promise polyfill for IE. So what? Doesn't mean there's a reason to recommend an outdated API, especially when the documentation clearly states lack of support.
Yeah, only nobodies like Netflix use Node for their production systems.
Ad blockers don‚Äôt disable GUI elements they block requests to known ad servers
Ad blockers don‚Äôt disable GUI elements they block requests to known ad servers
Your second `XHR` has a dependency on the data from the first `XHR`. Nest the second one inside the `onload` of the first one: let mapsRequest = new XMLHttpRequest(); mapsRequest.open('GET', gmapsURL+"&amp;latlng="+lat+","+lon); mapsRequest.send(); mapsRequest.responseType = 'json'; mapsRequest.onload = function(){ locResp = mapsRequest.response; //Weather Request let weatherRequest = new XMLHttpRequest(); weatherRequest.open('GET', weatherURL+"&amp;"+"lat="+lat+"&amp;lon="+lon); weatherRequest.send(); weatherRequest.responseType = 'json'; weatherRequest.onload = function(){ tempResp = weatherRequest.response; } } As the nesting get's deeper, it is commonly referred to as "callback hell". I would read up on Promises because they are an accepted solution to the problem of callback hell.
These are two I highly recommend. Brad Traversy does an amazing job of teaching without all the fluff. : https://www.udemy.com/modern-javascript-from-the-beginning/learn/v4/overview https://www.udemy.com/understand-javascript/learn/v4/overview
Yeah, and no one never heard of Linkedin. Those nobodies also use Node on their production system.
[Advanced Javascript](https://onlinecoursesstore.tumblr.com/post/166985752057/advanced-javascript) is a must course for front end developers and any web developer ... giving me lots of closures regarding coding issues.
Last time I checked, their backend was still Java + Python.
As a web server? For their website? Sources please!
 Make a function of your Ajax. Give it an argument onresponse, which is a function which will be a callback. function Ajax(onresponse) { onload = function () { onresponse.call(null,this.response); }; // Your code // Look into the order setting information see https://developer.mozilla.org/nl/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest } Ajax(function(value) { // Do something with value }); 
This has nothing to do with `.forEach()`, and there is nothing inconsistent about the language's behavior. The reason your two samples work differently is that _you wrote different code_ in the two. To illustrate, let's write the same code without a `.forEach()` call, by directly accessing the first element of each array: let arr1 = [{test: 'one'},{test: 'two'}]; let a = arr1[0]; // a is now a reference to the {test:'one'} object a.test = 'updated!'; let arr2 = ['a', 'b', 'c', 'd']; let a = arr2[0]; // a is now a reference to the string 'a' a = 'NOT updated!'; Does that make the difference between your two versions of the code more clear? In the first one, `a` is a reference to the first element of `arr1`, and you are setting `a.test` to a new value. Because `a` is a reference to the same array element as `arr1[0]`, this is the same as if you'd done: arr1[0].test = 'updated!'; In the second example, `a` starts out as a reference to the first element of `arr2`, but we then _discard_ that reference completely by setting `a` itself (not `a.test`) to a new value. `a` is no longer connected to the original `arr2[0]` in any fashion. What would happen if we wrote the first example more like the second one? let arr1 = [{test: 'one'},{test: 'two'}]; let a = arr1[0]; // a is now a reference to the {test:'one'} object a = 'NOT updated!'; // instead of: a.test = 'updated!'; Now this would work the same as the second example: it would not update the existing data in the array, because again by setting `a = something` (and _not_ `a.test = something`) we have discarded the reference that `a` originally contained and given `a` a brand new reference to the `'NOT updated!'` string. Or going the other direction, what if we wrote the second example more like the first one? let arr2 = ['a', 'b', 'c', 'd']; let a = arr2[0]; // a is now a reference to the string 'a' a.test = 'updated!'; // we can only wish... Now we have a problem. After the second statement, the variable `a` is a reference to the string `'a'`. But a JavaScript string is _immutable_. It has no properties that we can change. So when we attempt to set `a.test` to a new value, we are performing an illegal operation. In strict mode, this will throw an exception: Uncaught TypeError: Cannot create property 'test' on string 'a' In non-strict mode, it will simply fail silently. Either way, attempting to set `a.test` when `a` is a reference to a string will fail to set that property.
Awesome, I would love to see more this I think is actually bread and butter of redux :)
https://www.quora.com/What-companies-are-using-Node-js-in-production-in-Texas/answer/Matt-Warcholinski
From my understanding, `jest` does not run in browser, only in Node. You'd have to pair it up with something else ( `nightmare`? `cypress`? It's been too long since I've done acceptance testing on UI side ). As for unit testing in browsers, why is that a concern? Do your units use things outside of themselves that change during the browser testing?
hehe - really glad you got your problem solved, feel free to ask anything which bothers you about js/webdev! cheers
Yes. The only thing a `const` restricts you from doing is using `=` again directly with the variable declared with the `const`. You can use anything you want when initially defining it. You can even change the properties of the value if it is defined as an object. But you aren't allowed to give the variable a completely new value. const a = "one" + 2 + Math.random() // ok const b = { one: 2 } // ok b.one = 1 // ok b = { two: 2 } // error - can change properties of b, but not b itself edit: typo
Brad Traversy's Udemy course Modern Javascript from the beginning is the best course I've found for beginning Javascript and I've tried almost everything that will get mentioned here, I'm pretty sure it's the only course that starts out with es6 instead of shoehorning it in as an addendum .
[removed]
Jest is for unit testing. If you want to to do integration/end-to-end testing use something like Cypress that's designed for it. Also don't do unit tests in a browser. The suite needs to be fast. When they run in a browser everything gets an order of magnitude slower and you'll be running the tests constantly, so a lot of time is wasted.
&gt; As far as I can tell I wouldn't benefit from using SailsJS and would be better off just sticking to ExpressJS? Yes.
[removed]
Been ages since I last looked at it but I enjoyed [NodeSchool](https://nodeschool.io/) 
I also like Brad's [Modern JavaScript From The Beginning](https://onlinecoursesstore.tumblr.com/post/169368619297/modern-javascript-from-the-beginning) course. It covers mostly everything JavaScript, with projects. And Brad is great instructor. I have all he's courses.
&gt; In my personal experience, the personal experience of other - and especially more senior - developers is far more valuable than any amount of marketing BS. Alright, sure, and most of the developers at my company have been working for more than 10 years, some for decades, and we're all happily using Node for production apps and services. Maybe you just need to get outside your bubble? You shouldn't hate on things you don't understand, you just look foolish. If you think all there is to Node is "marketing BS" you're the one who's been mislead.
What do you mean ?
Request blocking is the main thing, but uBlock (for example) can also automatically remove page elements.
even the recycled and outdated Eduonix courses !? Now that's dedication ! Ribbing aside Brad is a great instructor, he was voted the best web dev programming channel on YouTube by a pretty wide margin (and rightfully so) .
True, uBlock is a bit of an outlier compared to Adblocker and Stands though because its a wide spectrum blocker
Thanks! I just signed up and watched the first few lessons. Seems very good.
A 9kb drop in replacement would be awesome! We've used preact-compat in the past but it looks like it could take a while until they reach api compatibility with react16. Is this a full Fiber implementation? Do you account for async rendering as well?
The first step will be linking your CSS &amp; JS files to your HTML file(s), did you figure out how to do that yet? Once that's done experiment a little with modifying DOM elements and browser events like 'onclick' or 'onhover', etc. After you're comfortable: there's going to be some functions/math involved to randomize (if it's continually scrolling output downwards say within a div) the boundaries as well as whatever things like trees or whatever you want to pop up as scenery. Maybe you want to keep track of score using variables, maybe after they hit the boundary you might want a popup Alert window to tell the user it's game over.
oh modals are a good one, thank you!
everyone does that somewhere during their life eheh
that's pretty common. what was the most difficult part? ajax cal, errors, etc... 
They clearly did some serious homework with this library: https://github.com/NervJS/nerv/blob/master/packages/nerv/src/vdom/patch.ts#L177. It even uses the LIS algorithm: https://github.com/NervJS/nerv/blob/master/packages/nerv/src/vdom/patch.ts#L385
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [NervJS/nerv/.../**patch.ts#L385** (master ‚Üí 51970fe)](https://github.com/NervJS/nerv/blob/51970fe8c2391ffcfd6ce976e9c78614abf186a8/packages/nerv/src/vdom/patch.ts#L385) * [NervJS/nerv/.../**patch.ts#L177** (master ‚Üí 51970fe)](https://github.com/NervJS/nerv/blob/51970fe8c2391ffcfd6ce976e9c78614abf186a8/packages/nerv/src/vdom/patch.ts#L177) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dshdtso.)
I'm in here playing tag come at me
Any time you wanted to use workers but couldn‚Äôt get it working because the API is frustrating.
Also even local things like if you name your javascript file `adverts.js` or something
https://imgur.com/g9vFPvL I made this to further clarify things, just in case
Okay so the optimization was actually a security flaw that they had known about for many years yet kept a secret while they kept pushing out vulnerable processors. How deep on the corporate cock are you? 
Why are people downvoting these??
This is the correct answer 
I have 15 yo experience as a developer and work for a leading firm in the space.
/r/lolangular
Once something works, maybe you should stop fixing it.
Do we need a replacement? Maintenance means they're going to fix bugs, so it'll keep working.
I read this the other day. Probably a repost
It doesn't work with webpack 4 sadly and the `@next` branch has been made obsolete recently out of the blue. If anyone knows what's going on, that would be extremely helpful. We've always been test-driving webpack alphas/betas to mitigate the impact of config mutations. It's a first that both projects don't work together any longer.
I submitted an issue for our marketing site for you https://gitlab.com/burke-software/passit-marketing/issues/10 Yes there is a lot to do! We also really need to get the sign up process as smooth as possible and make the links to web extensions more apparent. Thank you for your feedback. Free free to submit or upvote any of the existing issues on the project.
Wow, CanJS are still trying, bless
A library is made with ‚Äòvanilla js‚Äô, smarter algorithms utilising caching and optimised change-detection and whatnot can give an edge. 
What‚Äôs the catch?
Worst advice so far. Did you even google that? Also, universities will be essentially guaranteed to teach very out of date, whack.js. Do not use the resources you find this way if you want to learn relevant Javascript.
Are you interested in contributing your nerve version to the official js-framework-benchmark repository? I‚Äôll happily accept that PR.
I closed the tab immediately when I saw Pepe the motherfucking frog.
Both free and paid courses are very good. I started with freecodecamp and was struggling a lot, felt like too much info was thrown at me too quickly and I probably don‚Äôt have the discipline required. I can recommend the paid course as well because for the quality of the teaching it‚Äôs not that much money, but just enough that you **will** keep going. For people like me who tend to procrastinate and take things slowly because of 100 reasons, this is actually pretty important.
My advice would be to add an ID to the script tag, so you can easily find it within the script.
I only have experience with angular 2+, and I am biased. But, angular is more robust out of the box. It's a full framework, whereas react is just a view. Angular also has multiple ways of handling data (two way data binding, services), whereas you need to bring in software to handle that in react (ie, nuclear, redux, flux). Also, angular does templating, and let's you split up JS and HTML. I just like that because I can scroll less. Also, typescript out of the box. Also, observables are great to work with.
NodeSchool is good
You don't have to be on the "corporate cock" to consider a situation rationally instead of acting like an entitled child Spectre and Meltdown have been known about for _months_, not years, and they weren't "kept secret". Did you not pause to wonder how OS vendors were able to roll out patches so fast or why older processors/OS versions are worse affected? 
I was poorly trying to get at how well supported it is in serverless functions since it's a supported environment on all the providers. Also people deploy node web apps behind web server proxies and use process clusters and stuff and it can be pretty dang good. I mean no one is saying GO isn't a great web service language, just that node is quite useful in the space for a bunch of reasons ranging from being able to server side render js, to having nice api for streams, non-blocking calls, and other common webby patterns.
It fully mimics react api. Once api changes it has to change. I doubt it can always stay performant in such conditions.
WSL is going to be hit even harder isn't it? :(
For universal apps there's stuff like [Razzle](https://github.com/jaredpalmer/razzle) and [Backpack](https://github.com/jaredpalmer/backpack) which extends webpack but handles SSR and without any initial configuration needed.
There also [DIO(a 7kb alternative)](https://dio.js.org/) which has API compatibility with React 16, Fragments, Portals etc.
Although I haven't seen any evidence of this, could the Dev server not be being merged into webpack core soon?
Thanks again for the help. I'm just a little unsure where I need to put the new codes you've given me. Since this sheet will never have anything to do with Korean time should I just delete everything relating to it? (I'm not sure which parts I'd have to delete and which to keep).
MDN has this wrong, just like nearly everyone who has written on the topic. The idea that JavaScript uses two different calling conventions for objects and primitive values is nothing more than a myth. Let's write some code to test the first paragraph you quoted from MDN: function foo( arg ) { arg = 24; } var num = 42; foo( num ); console.log( num ); // still 42 So far this works as MDN describes. Changing the value of `arg` inside the function did _not_ change the value of `num` outside the function. Let's try it with an object instead: var obj = { value: 42 }; foo( obj ); console.log( JSON.stringify(obj) ); // Still { "value":42 } Just as with the primitive value 42, passing an object into the function and then reassigning the argument inside the function has no effect on the outside world. "But Mike," you may object, "of course reassigning the parameter inside the function doesn't change anything outside the function. The parameter name is really just a local variable! You wouldn't write the code that way for an object argument. You'd modify a property of the object instead." You mean something like this? function foo2( arg ) { arg.prop = 24; } var obj = { value: 42 }; foo2( obj ); console.log( JSON.stringify(obj) ); // { "value":42, "prop":24 } Ah, but we _didn't write the same code_ inside the two functions. These two lines of code are not the same thing at all: // In foo arg = 24; // In foo2 arg.prop = 24; And this is the source of that persistent myth. The two functions behave differently not because JavaScript used a different calling convention for the primitive vs. object, but because the two functions _do not have the same code._ You may note that this is the exact same issue that started this thread: OP's code for the two different `.forEach()` loops behaves differently because the code _is_ different. So back to MDN. Are they really _wrong_ to say there are two different calling conventions for objects and primitives? After all, their statement describes the observable behavior just as well as my statement that there is only a single calling convention. And that's the point. Thinking there are two different calling conventions for primitives and objects is a completely unnecessary distinction. It complicates one's mental model and makes it harder to understand how JavaScript code really works. There are enough complicated things and special cases in JavaScript as it is. Inventing one out of whole cloth as MDN has done is not helpful to anyone.
That was a very long-winded way of saying not a lot. Saying "Objects are passed by reference" is not incorrect but I can see why it might be useful to think of an _object reference_ as being passed by value. You are able to use an object reference value and update members from it, but assigning to the reference obviously won't have any impact in the parent scope.
javascript is dead. millennials ruin everything they touch.
the ecosystem around React is pretty solid now, especially for the core concerns of your app - react + redux + side effect layer of choice (redux-observable, redux-saga, whatever) + react-router. Most Angular apps I see end up using redux anyways - either with angular-redux or NgRx - so it still follows the same reducers / dispatchers / etc pattern. Even if you don't go that route, you should still put some thought into how you want to manage your state (and most people I see doing that, end up with a roll your own flux-like implementation, or, no concept of management state at all and it's ... eep). I've mostly used Angular (early adopter of both 1, and 2+) - done a bit of react, and dabbled in Vue - I really wanted to like Angular 2, and I'm highly productive in it now just because I've used it so much - but still find at times it feels like I'm fighting the framework, and/or there are so many ways of doing things that trying to keep the number of concepts / APIs / etc in my head or at least at a level that I feel comfortable with feels like a challenge. That said, the full buy-in on TypeScript is nice - and the tooling / etc around TypeScript has improved greatly over the last year or two (it used to be a thorn in my side, but now a fan of it), and once you get your head around a few of the more commonly used RxJs operators - and since they are so integral to how Angular works, some async stuff does get rather nice to work with. I just have a hard time getting excited about Angular recently, it's a tool that gets the job done - but I still have my gripes with it.
By "The Future of JavaScript ES8" they mean _features proposed for ES beyond ES8_.
I personally avoid `switch` statements because of code bloat but I think it is totally okay to use fallthroughs as long as you annotate it in a comment: switch (expr) { case A: var1 = 123; // fallthrough case B: doSomething(); }
Colt Steele's course on Udemy is what got me into programming. https://www.udemy.com/the-web-developer-bootcamp/
Seems foolish to use this over React. 
&gt; A minor release that is a drop-in replacement containing many bugfixes Note to Google: in the JavaScript world, we call that a **patch release**.
Good talk! Some cool stuff I'd heard about, but did not know about [Temporal](https://github.com/tc39/proposal-temporal), wow. 
What sort of benefits does the pages/index.ts or shared module.ts provide? Are you able to use them to prevent redundant imports? 
After thinking about this for a while, what I think it ultimately comes down to is: how do *you*, as a developer, feel about JavaScript? If you: - Think JavaScript is a beast that needs to be tamed - Find configuration to be confusing - Genuinely enjoy Java programming - Think that object-oriented design patterns are the litmus test for enterprise-grade applications - Think software engineering is copy-pasting code from StackOverflow into Eclipse and hacking until the compiler ~~kills itself~~ stops complaining - Need to be told what to do in order to make code more reusable Then use Angular. If you: - Think JavaScript is a legitimate language with a future worth investing in - Think functional programming is *as relevant* to JS as object-oriented programming is - Are comfortable writing your own reusable code and writing helpers that are relevant to your own application (as opposed to just inlining lodash and/or using whatever helpers come with React and Redux) - Think Karen needs to stop trying to make `RxJS` happen - Are open-minded to new solutions to old problems (JSX, CSS-in-JS) and are able to understand the benefits Then use React. 
I finished the Udacity Front-end Developer Nanodegree and am currently in the midst of the React Nanodegree. I've liked both and recommend them. 
[@github's latest tweet](https://i.imgur.com/nZ9zYRo.jpg) [@github on Twitter](https://twitter.com/github) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
IE8 .. seriously? I thought this shit was dead long ago.
IMO, at this point I just have to laugh at nearly anything that's taunting performance as a feature. Except for some very particular cases (like long, scrolling lists) you're more likely to be killing yourself on an errant api call or business logic function than the actual performance of the JS library. Unless you're running at mega scale or have engineers to throw at crazy problems, performance is probably far outweighed by more important issues like being able to deliver features quickly.
I find that React gives more control as it's only a view. In contrast, Angular is a MVC framework and I find it's less in control. I started liking vue.js more now-a-days as it's very simpler than react and easy to get started with.
&gt; long, scrolling lists i dont know if there is any solution for some of these issues
This is a horrible hack, but if you add a random param to the `query` variable then it will make it uncacheable. const query = "posts?filter[orderby]=rand&amp;filter[posts_per_page]=1&amp;cachebuster=" + Math.random(); The proper fix is to inspect the HTTP headers, and change the server so that it tells browsers not to cache. In Nginx the config would look something like, expires -1; add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, private, max-age=0" always; if_modified_since off; etag off;
I am guessing the Webpack 4 announcement will cover the future of this particular module.
Is that possible when it's not my server? This is a public API.
No, you can't control a remote server / public API. If you were to proxy their server you could modify the headers, but that's probably a lot of hassle so the `&amp;cachebuster=" + Math.random()` is probably good enough.
Thanks a ton! I'll look into this! :D
I've read some blogs on Typescript. I need to start playing with it.
If you want to learn pure JavaScript then I‚Äôd skip this as it covers a ton of stuff including HTML and CSS. However, if you‚Äôre looking for a general full stack course then I‚Äôd highly recommend this. It‚Äôs insanely long, but Colt is a brilliant teacher and I‚Äôm sure you‚Äôll come away knowing a bunch more than you started with!
can anyone recommend clips for object oriented javascript. Was taking a course and I learned the basic concepts, but when it came time to apply it I was so confused. Had to make a music playlist and I was so lost. Any advice where I can look for better explainations on this for beginners?
I like how 'Nerv!' can be interpreted as a German exclamation of annoyance. A fitting name for yet another Framework.
virtual DOM + server-side pagination + faked scrollbar + lazy loaded/unloaded rows as scrollbar moves. Been there :(
Thats what in working with and its still slow with tables with a lot of columns, and inserting/deleting rows, inline forms, etc. oh and infinite scrolling not paging...
It needs to die, but that doesn't mean it's not in use in places that need to be supported. Large administrative organizations often are locked to an OS and browser for security reasons, and usually that means Windows. Government, schools, and hospitals are all examples. If you have to support it, it's nice to have tools that are compatible.
I WARNED YOU 
The status quo is strong with this one. I find it interesting that people are dismissive of performance, especially given that this lib literally claims API parity w/ React 16 without a compat layer (unlike preact and inferno, which are nerv's most direct competitors). There's definitely a market for these drop-in replacements; heck, my company (Uber) uses Preact on its mobile web app precisely for perf reasons.
I know hating on angular is popular but come on. Literally the first bullet after "what's new" says "We‚Äôve **added** fullTemplateTypeCheck ...". That qualifies it as a minor release.
This looks really nice. I will try this!
I liked EloquentJavascript: http://eloquentjavascript.net/. It's not really a course, but it's a useful resource for a beginner developer. 
Seeing what you typed, I am feeling the need to inform you before you get too much confused: ‚Ä¢ Java and Java*script* are different languages and should not be confused with each other. ‚Ä¢ Also, you might want to make sure you actually reply to the person's message as they might not be notified otherwise.
Most welcome konan792885! Thanks for your kind words :)
Thanks lonniebiz! Your most welcome, if you have any changes please let me know :)
I've created a minimalistic 9 line jQuery plugin for popups. Check it out here. http://bangtech.net/project-57 Please do note that the website's in Danish, just use Google Translate to show the text in english.
React-virtualized totally solved this for us !
&gt; Announcement with specifics pending.
This makes me so happy
'pages/index.ts' makes me reduce the lines of code needed to import all the pages in the app.module, it just makes code cleaner. Shared module is there because organizing things in modules is a good practice, and yes also to prevent redundant imports. 
I took his course to it very good then 2nd one he did is good but missing some parts for react he said hes going to add a third one to sort this out. But His 1st course is a good Start.
I would also Check out his Youtube Channel. 
r/webdev r/web_design r/frontend
Watch Javascript: the Weird Parts. Read You don't know JS
I am not dismissive of performance. Working in the gaming industry, performance is one of the most important aspects of what we do. However, if it ain't broke, don't fix it. Our biggest gripe when we started using React to render in-game UI was that the WebView introduced way too much overhead in terms of high input latency and memory consumption, and we never got it to perform well enough on consoles. So, we decided to tear that out and replace it with a custom renderer that renders our React components directly in the game engine instead. It's bascially the same concept as react-native. Get rid of the slow parts (WebView+DOM) and replace with a custom renderer. The actual real-life performance of React has never been a major issue for us, even though we use a really old JVM that lack JIT. This is why I'm questioning the need and necessity of libraries that outperform React.
With react fiber you can use intersection observers. It performs really well! Check this project out for some ideas: https://github.com/researchgate/react-intersection-list
I asked @shellscape on Twitter, this is what i got: &gt; yeah, hopefully someone steps up to maintain wds further and gets that merged soon. &gt; webpack@4 introduced a lot of sweeping changes, so there were bound to be growing pains. I will mention that the ideas behind wds@next have found a new home, which supports webpack@4 and http2 out of the box, and I'll have more info on that in the coming weeks. &gt; I was the main dev on the `next` branch and I've chosen to step away from the project. that's not to say someone won't step up. but `next` was predicated on abandoning old browsers support - something the team decided they didn't want to do for wds at present.
Wow, i've heard of Dio before, never suspected it was api compatible. Though can it be aliased? I'm not looking for a React replacement, but rather something that i could alias in production to decrease the payload.
Do we know which version of node this won‚Äôt be experimental anymore? 10?
&gt;tabs instead of spaces literally unreadable 
He swung from one extreme to the other. The reality, as usual, is more grey-area. Developers *do* want feedback. They *do* want suggestions. They won't always act on them, but they often do enjoy receiving them and sometimes implement them. Going from "here's my idea, do it now!" to "I won't post an idea if I won't do it myself" is far too black &amp; white. The middle road, "here's an idea I'd like to see" is much nicer to both parties. I'm not saying not to code it yourself if you want. But don't refrain from posting the idea just because you aren't willing to code it.
This
&gt;Please keep in mind that my code is not anywhere being perfect, but I guarantee it to you that I‚Äôm working and studying hard to get as better as I can, so if you see something you‚Äôd do differently, don‚Äôt hesitate to comment. Not the most reassuring thing to read at the start of a tutorial...
I just tried that URL from your code and Chrome is *not* cacheing it for me when I reload the page. I tried a modified version of your code in the Chrome console and was told that the site isn't sending a CORS header, so it wouldn't let me fetch it at all. Perhaps you've got something else going on?
Hopefully. But there's still a lot of discussion around this, as there are lots of problems with the current specification (which I'll discuss in the next blog post). I'm guessing 11-12. 
You could create a Pong game. It's not too involved although creating an opponent that has increasing reaction/speed could take a bit.
Hey, I just saw this. I totally agree - if you use bitmap comparison tools, like webdrivercss and others do, then the false positives are many. But if you use an industrial-grade comparison tool, then the results are totally different. These tools use sophisticated computer vision techniques to minimize the problems, and lots of companies today use them to test the look of their applications. 
Thanks for the response. Yes the code interacts with the DOM and creates new elements, which is created differently by each browser. This is why we wanted to test the code using unit tests for each browser. This appears as though we are testing browser specific implementations of these functions, however to us the end product must function the same in all the browsers we support. Any thoughts or suggestions are welcome!
Exactly. Demanding you only submit an issue if you intend to try to fix it yourself is as deadly an attitude for a project as the attitude which expects someone else to fix all your bugs and requests for you. 
Interesting. Did you have disable cache on in your DevTools (in the Network tab)?
Looks sweet! Can it open an external file/module, like [Worker.IO](https://github.com/janmisek/workerio)? Any other differences compared to that project that you know of?
&gt; Not the most reassuring thing to read at the start of a tutorial Reassuringly honest and humble. Too many articles give (intentionally or otherwise) the impression that "X is one one and only correct way" where most of the are the same as this: a log of what one person, who isn't massively experienced, found to work well. Definitely better for beginners who happen upon the article: they may still find it very useful but know to think about looking for alternative methods too.
I checked that, and it was off. I also tried it with the devtools closed with the same results.
Interesting I‚Äôll investigate some more. 
If importing ES modules is async, does that mean that the import statement acts like an await would? And the import function is an actual async function itself?
I have yet to discover a project where I would pick Redux over MobX. I just find MobX more readable. I've even used it with TypeScript for full type coverage and found it a blessing. 
Possibly relevant that I'm using this within a create-react-app setup. But that doesn't explain why this is only happening for me in Chrome 
Something I see many people seriously misunderstand about open source software is that you are generally paying nothing and using it at will. This means you are entitled to nothing and the software can cease to exist at any moment. Bitching and crying about that isn't a resolution. If the software does go away nobody owes you anything. Something I see less often is some amount of entitlement towards support. When you pay for a software license you generally get dedicated support. When you use open source software you generally pay for nothing and support is available as a feature of community support. The misunderstanding is that nobody owes you dedicated support. If there is an incompatibility or missing necessary feature you should fill it yourself and submit a pull request back to the original project, but that original project isn't there to support you.
What are custom elements?
So its literally just npm install with different terminal output? I guess thats cool
https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements
Check out /r/dailyprogrammer/ If you're learning a new language the challenges can be a good way to dive in.
I was making the request to **https**://quotesondesign.com/ instead of **http**://quotesondesign.com/. Chrome is only caching when it is https, can you confirm? 
Kyle Simpson from YDKJS has some great videos on frontendmasters
So.. does this mean we should be moving to modules now? 
No. I mean you can try it out, but it's likely a lot of people will just continue to use CommonJS. IMO
That's not working for me. I tried the code in the op again in Chrome Canary and it doesn't cache. Weird. 
Site seems broken to me. I don't see any content. 
Hey, awesome idea! Let's get in touch over email: marcin@reactnative.education Cheers, Marcin
hi. is it? which browser are you using to surf the site? It would be helpful for me to solve the issue. Thank you for the comment.
He isn't doubting his own skills.. He's simply stating that his code isn't perfect.. If you think you think that all the code you write is perfect you're probably wrong.
In the meantime people can use esm, I‚Äôve found it to be pretty great https://github.com/standard-things/esm
I mean, my primary project is something that I've really concentrated on keeping up with the latest and greatest, even if it uses switches to run. I actually depend on a ES Module in one part of it, so.. I'm curious.. for the future.. is this THE WAY ? or does it really not matter, as long as you're not writing code that needs to be browser compliant as well? 
No, please don't. Not yet. This is still experimental, and may change in the future. As I will discuss in the next blog post, it is actually pretty probable that things *will* change. But start thinking about it. I'm guessing that the transition will *start* in a year.
CSS has media queries for print. As far as making text from a table responsive, you might want to consider using CSS display: table, and then for print changing it to something else so you can rearrange the content to be more consumable.
Hurray!
Thank you! For some reason I could not come up with the proper way to spell that word for the past 2 weeks. 
Thank you
Hi, I'm sorry you feel that way, if you do have a few minutes to spare please give it a try! Thank you for the feedback.
This small tutorial and a college level course are not even close to being comparable. Saying your not perfect does equate to being faulty. 
Because someone recently wrote an ebay API in Javascript that actually works, and it's a ES Module. :-) 
Excellent, so you got exactly what you want? You were given the information you needed to decide whether or not to proceed instead of spending time that you would later consider wasted. Or would you have rather read the page in blissful ignorance that it might not meet your exacting standards?
Not very surprising that a better framework becomes dominant five years later when it is built upon lessons learned from the older ones. Also not surprising that technologies like jQuery are on the decline after the inconsistencies and missing features it brought have been solved by browser vendors. Finally, in comparison with other languages and environments, javascript and web oriented technologies are much closer to the extrovert and innovative designer mindset than the tried and true engineering one. Not that there is anything wrong with either. But it is way easier to patch a broken web service anywhere than, say, an embedded industrial control box and nobody sane would prioritize a fresh user interface to a stable one for the same one. 
&gt; and ask for my money back. Give me your paypal details and I'll refund you the $0.00 you spent on the artical out of my own pocket.
eh, im using vue
thats a virtual scroll right?
Yes it it :-)
I rolled my own in vue, and it works, but still not perfect...it's really only noticable when there are rows with forms/buttons and rows without and you scroll, you can see the flicker
Thanks. Yeah I'm still learning and had done an Angular 5 MEAN auth boilerplate myself. It's a little sloppy and redundant so I could learn a lot 
React virtualized + nice placeholders, it was easy to setup and it just feels so fast
Nope.
Hi /u/zekerpik, For javascript help, please visit /r/LearnJavascript. Thank you!
you're welcome :)
Hi /u/fagnerbrack, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Wat
You can‚Äôt use them as arguments for dynamic import / require either
Out of curiosity, why do you think Angular treats JS as 'beast that needs to be tamed' and React doesn't? Both of those tools are best used with a transpiler.
Came to say this
Haha, okey. Then there's https://github.com/heavyy/vue-intersect if you haven't found it already.
This answer is wrong, as here i indicates value, not the index.
I partially disagree with that graph that shows popularity based upon questions asked. It seems natural to me that a brand new framework will have much more questions on StackOverFlow lately since the older frameworks have plenty of them already answered, so the number of its new questions will drop proportionally over time, regardless its usage drops at the same rate or not. The understanding of that graph is a little bit misleading.
I have no clue about processor architecture, this is a javascript subreddit. We high level boi. All I'm saying is that anyone who bought a processor within the last year deserves a full refund because it was known about yet continued to ship with flaws intact.
I'd probably just rip out the react stuff in the end and append an optional section on front end frameworks. Overall a solid learning path, I may use this to check my basics. Thanks for sharing.
Ooo, neat! I'd love to see a writeup of how you did that custom renderer.
 window.onerror = function (errorMsg, url, lineNumber) { // do something with the error. }
Probably not going to happen. It's proprietary software :'(
So... in short you wrote a react native competitor. That's pretty much the same thing this is: a reimplementation of the rendering system that maintains API compat with React. The only difference is that native mobile offers different opportunities to tackle perf than a pure web target. "If it ain't broken" is not the best way to think about perf. Perf is a feature: at scale, faster app === more money. JD (the company where they claim nerv is used) is basically the Amazon of China. They probably know a thing or two about the impact of perf at scale, and the impact on bottom line for supporting IE8 (which still holds a significant share of the browser market there).
Agree. After some time all the questions have been asked, this doesn't mean that the framework is less popular it just means that people are googling
&gt; It was built on the fancy new Observers, how's that for dandy? What are you referring to? I saw no reason to check out Vue because its main selling point seemed to be to transfer the Angular 1 templating mindset to virtual DOM (which has its use cases, but is not for me), but I hadn't heard of "fancy new Observers" or them being related to Vue?
I personally enjoyed Stephen Grider's courses with React Native + Redux on Udemy. I was able to skip through it already having a knowledge of React and Redux beforehand, but he paces it quite well for a beginner IMO.
I wrote a sprite batching library for 2D WebGL games... thoughts? [Link](https://github.com/snordgren/spritebatch.js)
100%. I've looked up so many jQuery and angular questions over the years. Don't think I've ever had to ask one... Everything's already out there.
Can you elaborate?
And to carry over my followup from /r/sharepoint: I've almost got this. Using the pattern I mentioned in the OP, I used `$.when()` to batch up my requests: function doEverything() { var selects = 'Title,ProductNotes,PrimaryContact/Name,AltContact/Name,OtherContacts/Name', options={ list:'Supported Products', params:{ select:selects, expand:'PrimaryContact,AltContact,OtherContacts' } }; getProductList(options).then(function(d){ var promises = d.map(function(o){ return $.when( getTeamMemberDetails(o.PrimaryContact.Name), getTeamMemberDetails(o.AltContact.Name), (o.OtherContacts.results || []).map(function(user){ return getTeamMemberDetails(user.Name); }) ).done(function(){ return arguments; }); }); $.when.apply($,promises).then(function(){ //Not quite there. console.log(arguments); }); }); } function getProductList(o){ return api.getListData(o); } function getTeamMemberDetails(user){ return api.getUserProperties(user) }
I totally agree with this. I used his courses and also Cory House's on Pluralsight to get me jump started on React. Both guys are great and highly recommended.
If you can't guarantee this site will always exist for all time, no matter what, then this site is pointless. Even then, to comply with many licenses, you have to include the license, not a link to it. So it doesn't work for any of those. And for offline distribution? Nope, doesn't work there, either. It's nice to have a site that has the licenses available to read through, but it's not a replacement for the existing methods of showing licensing information.
For dual mode packages, why can't you rewrite as ESM, and then just wrap the ESM and re-export as a CJS module? Then you can use `"main": "entry"` in package.json, and `entry.js` will look like this: async () =&gt; { module.exports = await import("./entry"); } This way would not require any transpiling.
The guy probably confused getters and setters with observers, which Vue uses to "observe" changes in the tree (but only shallowly).
&gt; jQuery was still incredibly revolutionary, Prototype was incredibly revolutionary. jQuery just improved on it. 
You can use them just fine with `require('...')` and `import('...')` expressions, just not `import '...'` statements. I'm assuming that's what you meant?
Unlike more traditional developers, I agree with your decision to ditch semi colons and use tabs. I refactored your library to reduce excess code, swapped out some conditional branching with switches, and moved everything over to streams. I think you might be interested in the Xspf stream and how it generates XML wrappers using the _flush method. It's a nifty trick. I need to get back to work but would be happy to comment later on anything you're curious about. https://github.com/THEtheChad/xspf-playlist/blob/master/index.js Cheers!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [THEtheChad/xspf-playlist/.../**index.js** (master ‚Üí 93750c6)](https://github.com/THEtheChad/xspf-playlist/blob/93750c6496d463485f6c10ef08c4e8e2766fa2ec/index.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsj6qci.)
He didn‚Äôt say it wasn‚Äôt. He said it solved a lot of problems that have since been solved by the vendors themselves. 
I was referring to a memory leak issue when using template literally inside of dynamic import statements with webpack, IIRC
Ah, well that's webpack's problem, not that of template strings. Probably a temporary issue anyway, and it doesn't apply if you're using the features natively.
Yep, exactly this. 
I still find jquery utilities incredible useful 
Oh I agree that it's reliable workaround, but I'd call it a hack because adding intentionally unsupported params to the bypass cache is a workaround
I didn't suggest that he said it wasn't. I was just adding onto the conversation.
Solved, as indicated in my edited /r/sharepoint post. It's ugly and probably not the "right" way to do it, but it works. If any of you geniuses have some insight on a smarter/more elegant way to do what I'm trying to do, I would be eternally grateful.
Yes, [The Complete React Native and Redux Course](https://onlinecoursesstore.tumblr.com/post/169588490092/the-complete-react-native-and-redux-course) is an excellent course! Stephen has the ability to make things look amazingly simple. I already started to build my own React-Native app!
Yeah maybe coupling was the wrong word. It just feels a little like it defeats the purpose of UI components, and turns things into more of a templating language rather than a UI framework. But I guess figuring out where that top level is will be what makes it useful.
I was expecting to see some output, instead of the code. :/
Generally that time was extremely valuable for the "web as platform"
bot.on('message') , function (message) =&gt; {
tried that get this erry now Syntaxerror unexpected token =&gt; 
 Right, missed that. bot.on('message') , function (message) {
Yeah I've heard that story before, but I'm not really looking for an Angular 1 alternative. I was just curious about the Observers thingy. (Also because I'm relatively happy about Observables, which might be what they meant but then I'm still not sure what Vue's got to do with it?)
Ah right, shame - that's more of an implementation detail that would not factor in me deciding what to use.
ok thanks again it says unexpected token )
&gt; And your SCSS can remain as such without bizarre JS patterns. You can do SCSS in react too, just saying
So then perhaps my changes weren't needed after all. I don't see anything else that might cause that. 
There's not even a == in your code, so the problem lies outside this snippet.
thats all there is and i put the ==&gt; { 
As a newbie web-dev student, i struggle to understand the deal with React. What's so great about it? Or is it just popular because of Facebook?
now it says unexpected token =&gt;
sorry i met =&gt;
That sounds like an acceptance test or an end-to-end test. You are not testing that your code does what its supposed to do, you are testing that the side-effect of your code is correct. From my understanding, unit testing is "Given x, I get in return y" or "Given x, it calls y and z with A". You do not care *what* those things do, just that they get done.
i added some things to the code look up at the top 
It makes it easy to deal with state and for passing stuff between parent and child components. It also is fairly fast and easy to understand with a big ecosystem. My favourite part is probably the ecosystem actually. Lots of answers to common questions on stackoverflow and a lot of libraries that extend the base React experience.
 const discord = require('discord.js'); var bot = new discord.Client(); bot.on('message', function (message) { if(message.content = 'ping') // message.reply('pong) message.channel.sendmessage('pong'); }); bot.on("ready", function () { console.log('ready') bot.user.setGame('Helping the world') }); bot.login('NDAwODM5MTE3OTkyMDk5ODcw.DThguA.uIMwTalipTA3ua3CAYcwy4IceLo');
Things have really settled down in the past couple years with most new work settling on React, and to a lesser extent, Vue. Of course all the others dropped off at the same time. A lot of the new new tech is stuff that builds on react, like redux or redux-saga. I don't see React being supplanted by a newer framework simply because it's legitimately good and scales well (with redux, etc). The other frameworks were discarded because they had too many pain points. Good riddance.
awesome that worked if it doesn't take too much explaining what did you do?
This seems to be the crucial detail: &gt; As new syntactic features are added to ECMAScript, additional cases requiring explicit semicolons emerge over time. In other words, even if you're aware of the *current* cases where semi-colons are required, you can't be aware of the *future* cases where a semi-colon will be required. The safest way to future-proof code against future ASI hazards is to use semi-colons.
yeah, there's a reason for that. The one I rolled basically uses a computed property called "visibleItems" that uses the scroll position times the item height to determine the first item which should be visible. without knowing the item height I'm not sure how else you would do it. The rest of the solution uses spacers above and below the visible items, all calculated in real time. 
Also number of questions does necessarily correlate directly to popularity. Like angular will have load more questions than react because it has a much bigger api (which isn't intuitive, and requires massive documentation) vs react which is comparatively straight forward.
That's correct. We're not going to remove ASI support, or break compatibility with the existing code, but as the language progresses, relying on ASI or especially enforcing ASI style will likely become inconsistent and risky.
I thought because /r/javascript is the most used language on Github this would be interesting to the community. Also, the author is the direct maintainer of Javascript projects. He's definitely ranting about Javascript. Look at the comments, there was acceptance.
I love `@std/esm` and it lets me use `import` when I want to. But is `import` really that much better than `require`, given the current Node.js ecosystem? What are we gaining?
It's incredibly simple, focused, and powerful.
Great post. I was hesitant to open it because I thought it was gonna be a gnarley web pack discussion. I should have known better with Tyler as the author. Definitely worth the few minutes to read!
to me.. so many languages use semi-colons... not using them creates a bad habit that can carry over
All of the other replies, and also the fact that it's very easy to adopt incrementally, e.g. on existing server-rendered pages for example. Just point it at a &lt;div&gt; and tell it to update that one part of the page. And from there on you can convert as much of your existing site as you want to it.
It is unfortunate, but ES5 had the opportunity to permanently cement this issue. The `"use strict";` pragma could have required the use of semicolons.
Redux is independent of React, maybe you meant react-redux?
On an Android mobile device. I think the native Reddit app opens the default browser 
You also get a smaller community, less active dev team, fewer modules and less job prospects.
We need more moves from the TC39 and stop this "everything goes" attitude in the JS world. I've been using Go lately and it's just awesome that all code bases are written in the same way.
Right, so unlike await it won't completely stop, because it will load other modules at the same time, it just won't continue with any non-import statements until they all have finished.
Tagged template literals. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
You had an extra ')' that ends the argument list for the function making the callback definition invalid.
Interestingly, the creator of JavaScript [seems opposed](https://twitter.com/BrendanEich/status/951554266535141377).
you could do ``` async function foobar() { const [a, b] = await Promise.all([ foo(), bar(), ]); return baz(a, b); } ``` await is just some sugar of async. the way i think of it is anytime you want to use `then`, use await instead.
You could always spread over an array with `Promise.all`. async function foobar() { const [a, b] = await Promise.all([foo(), bar()]); return baz(a, b); }
Yuck.
Stackexchange rules of no duplicates affects this wildly too. When the framework has had a long enough life, the most relevant questions have already been asked. Users simply don't have to ask anymore.
Fair
Yes, let‚Äôs not start or try anything new. Let‚Äôs stay the same so we can maintain our incredible job prospects. Why are we even using React? Let‚Äôs just get back to es3 vanilla. 
&gt;anything new Vue is not "new" -- it's a reactive component-based front-end view library. It fulfills the same niche as React without innovating anything.
https://github.com/ondreian/ebay-promised i guess actually looking at it, it's transpiled to CJS, but at the time I first started messing with it, i couldn't get it to load via require, so i made a mjs to use it 
And now I feel kinda (very) stupid for not thinking about this. Thank you, I think you just converted me. Firefox console says it works, haven't read the spec yet but I assume it should be the same everywhere.
Plenty of languages (most?) don't use semi-colons or don't use them in C-like fashion. 
Why is this even a debate? It‚Äôs not like I spend a ton of time typing semicolons, so why spend any time arguing or thinking about it? Do people just need to hold a strong opinion about things to feel smart?
I based the code on my [own code here](https://ericoporto.github.io/ktg/) , except I needed to remove touch support and make it ES6 class like and I need to learn how to pack this for npm once it's working . Any help would be cool.
I'm considering becoming a Python developer; at least they're not discussing semi-colons and spaces vs. tabs. It may be just me, but I find the JS community really childish.
I stopped reading at "I wouldn't really consider Eich as an expert/authority when it comes to JS," 
Bye
&gt; Do people just need to hold a strong opinion about things to feel smart? [Wadler's Law](https://wiki.haskell.org/Wadler's_Law): &gt; In any language design, the total time spent discussing a feature in this list is proportional to two raised to the power of its position. 0. Semantics 1. Syntax 2. Lexical syntax 3. Lexical syntax of comments *edit: made it more specific*
Then I‚Äôd be spending like months of semicolon timing time thinking about it.
Good thing we already have semi colon rule in our eslint 
The problem is that Go's ASI is designed for semicolon-free writing styles, while JavaScript's ASI is designed for typos in regular having-semicolon writing styles. JavaScript was also written in like a week so the ASI has a lot of flaws in both directions, and backwards compatibility prevents any of those flaws from being fixed. The most famous flaw in the other direction is: return true; Which returns `undefined` instead of `true` because ASI turns it into return; true; 
https://twitter.com/BrendanEich/status/951576865667338241 Note: Brendan Eich is opposed because he thinks semicolons should be required.
Thank you elaborating on my last point. 
I believe this was at least partly prompted by not being able to satisfactorily resolve some parts of the class fields proposal syntax in relation to ASI.
There is no case for which saying ‚ÄúI stopped reading at [the beginning]‚Äù ever helps your argument.
Wait, so this is dynamically loading on the client side. How does that work with a bundled SPA? Is it just really high level sugar on an async call back to the route that served the file initially? How does it compare to just relegating content to be served incrementally using async calls of your own (through websocket or ajax) while still serving the full bundle without necessarily loading static content? I'm gonna sleep on this and see if it makes more sense. o_O :P
It's not really related to being lazy. It's purely a style choice. I don't think ASI is necessarily good, but having a transpile step allows you to omit them safely without using ASI. Similar to how groovy doesn't require them, but Java does.
I stopped reading at "First of all, I'm an ephebophile, not a pedophile..."
I stand corrected.
&gt; it, feels, well, a little hurtful HAHAHAHHAHAHAHHAA what the hell did I just read? Since when does a parser care about your feelings? We write so robots can move bits around, and robots don't care about your feelings.
That's a bit of an oversimplification ‚Äì he thinks they should be required for that specific proposal, but he seems to be a [fan of standard/semicolon-free style](https://twitter.com/BrendanEich/status/951558694570901504).
What is a realistic timeframe to master this kind of depth of knowledge and skill?
One has to ask if questions are a good sign or not? Does it indicate popularity or confusion with the language/API? Yers ago I want led to track this and luckily StackExchange makes the data queryable. Feel free to use this query I built or tweak for your own needs. ;-) http://data.stackexchange.com/stackoverflow/query/359494/js-library-analysis-over-date-range The date range is so you can do things like... 2 years ago (730 days ago)... for a given 30 day period how many questions were tagged with JS framework X?
Wow
Maybe I'm misreading but can't you replace that with transformFoo(foo()) if transformFoo is also asynchronous to remove the '.then'?
you can absolutely get rid of that `then`! async function foobar () { const [a, b] = await Promise.all([ transformFoo(await foo()), bar(), ]); return baz(a, b); }
The syntax is built by humans to be read by humans. There's a split in dialects, where some people like extraneous punctuation;;; and other people don't. Now the high mucky mucks in charge of the syntax have decided to come down on the side of Group A. It's not bewildering that Group B might be a little put out.
I read that. I didn't know whether to laugh hysterically or be deeply saddened.
They're just noise to me. I like my code to be code and less punctuation, personally. It feels cleaner and simpler that way to me.
It should take about six months.
I do not think it needs to be React. 
"Functional" "Stateful" :thinking:
I don't know why you're being downvotes, that's a fair viewpoint
That's still fixable by introducing an other directive. I propose `"use really strict";`.
Code is more often read than written, JavaScript without semicolons is a lot easier on the eye.
RIP edgy JS ninjas
Found a really good explanation on the reasoning, drawbacks, and situations on where to use Nerv. https://github.com/NervJS/nerv/issues/10#issuecomment-356913486
This is the canary of the Tabs VS Spaces War. Buckle up. 
&gt;a lot
Code is more often read than written JavaScript without semicolons is a lot easier on the eye
Because it is not noise. It makes the code so much more readable. With semicolons I know instantly what is happening. Without it I must mentally start parsing the next line to know what the fuck the current line is doing. Code is read way more often than it is written, so why would you optimize for typing speed instead of reading speed. Makes no sense to me.
I see the exact opposite. Does that make you right and me wrong? Just different ways we view code. Tbh my main problem with semicolons is the inconsistently, I see so many long objects or anonymous functions regularly missing them. It should be 0% or 100% imo
Lifecycle? I thought people just created things to abandon them once created.
That you can call await on promise when it is needed isn't always mentioned like in [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await). Combined with Promise.all you can for example trigger multiple fetch() in parallell. Promise.all( items.map( async () =&gt; {item} =&gt; { try { const data1 = fetchData(item.url1) const data2 = fetchData(item.url2) const data3 = fetchData(item.url3) processData(await data1) // some additional processing processData(await data2) // some additional processing processData(await data3) } catch (error) { } } ) ) 
StandardJS which is default enforced by ESlint enforces low-semicolon JS. Huge swaths of developers are actually running ESlint on autopilot and many webpack starter kits even have builds setup to break on ESlint nags. Not to mention that majority of text-editors that lint JavaScript real-time do so using ESlint set to defaults. I'm with Brendan Eich on this.. this is going to cause much more grief than simply being careful with introduction of ASI-breaking changes in the language.
Backwards compatibility is over rated. Break some stuff and make the language better overall 
It's because they consistently have poor taste in technology.
That's like your opinion man
Haha, I'm not sure I agree with you. 10 years in and I'm still not close.
I tend to use semicolons, because I don't like whitespace/newline relevancy in my languages and it feels like interpunction to me. This is probably engrained in me by other languages (including natural written language), so take it with a grain of salt. That being said, recommendations are not laws. This is an acknowledgement that designing a complex language without interpunction characters is difficult.
Can I ask you what do you mean is inconsistent when using semicolons. Do you have any examples? When you say you see it opposite, are you saying you don't have to start mentally parsing the next line to know what is happening?
Hey! Do you work at Box? Have you guys tried out Happypack and the hard-source plugin?
[Web development before React was tough](https://twitter.com/AdamRackis/status/844289020372901888). You either had jquery, which single handedly has led to the most catastrophic code salad known to humankind, or complex templating frameworks that were inventing new html extensions and js-like parsers with a ton of rules to learn, rules that would change drastically from version to version, too. React came along and suddenly you could do in an hour of learning what took months before. The library is so simple that you are merely looking at a few examples, you don't study docs and api references. React solved longstanding issues that still plague other frameworks today. The most curious thing about React is, it left the browser. People figured that Reacts approach isn't just better for the web, it's better than what we're used to on native platforms, too. If you know React, you can target any platform you want: web, macos, linux, windows, android, ios, vr, ar, tv's, watches, shells, etc. The crazy thing is that the eco system still works. Imagine being able to use the same knowledge you have to make a [complex console application](https://github.com/Yomguithereal/react-blessed) but now you can use regular eco system packages, like react-motion, to [move things around](https://github.com/gaearon/react-blessed-hot-motion). 
Every single instance where omitting a semicolon can be hurtful is a terrible code anyway. That, or outdated stuff with a bunch of IIFEs that nobody writes that way anymore.
If you have that much trouble mentally parsing JS lines then you're looking at badly written code. Python has no semicolons yet is considered one of the easiest language to read/parse. Identation should be used for visually grouping pieces of code in a different scope or control structure. That's programming style 101. If you look at two lines of code, both starting on the same coloumn you should be able to grasp that those are procedurally executed.
Hello, yes we've only tried Happypack briefly to make babel-loader run in parallel. However it didn't help much. As for hard-source-webpack-plugin we're unsure about the reliability since it's pretty aggressive caching, need a closer look at the source code. Since we're now building in parallel, we've disabled all caching to avoid race conditions which means we probably won't use it to build prod bundles. We're still evaluating the plugin for development environment though.
&gt; Angular is a MVC framework It's actually a CBA, or component bases architecture. Perhaps you're thinking of AngularJS (aka Angular 1)?
(in classes)
&gt; Does that make you right and me wrong? Yes. The parser is the ultimate judge. Without semicolons it makes guesses which means it won't be always working as intended. With semicolons it will be always working as intended.
Have you heard about js comma operator? It goes like this arr.map(item =&gt; item.x) arr.map(item =&gt; (console.log(item), item.x)) Also, this pattern is useful for me too .map(item =&gt; ({ xxx: console.log(item), name: item.name, }))
Yes!
They'll fix it soon enough.
&gt; StandardJS which is default enforced by ESlint enforces low-semicolon JS. `semi` isn't even in eslint:recommended ruleset. Eslint doesn't force semicolons in any way.
if you read this line if (expression) return 5 Then you can't know what it does without looking at the next line. That's what I mean with mental parsing. It is not hard to do, but why should you need to do it for almost every line of your code base? Or how about this code someFunction() [4, 5].filter(x =&gt; x === 4) What is the result of .filter()? someFunction(); [4, 5].filter(x =&gt; x === 4); Now, what is result of filter? In the first example I have to look at the second line to determine what is happening in the first line. Also the code doesn't do what I intended.
 const [a, b] = await Promise.all([foo(), bar()]) const [c, d] = await Promise.all([foo1(), bar1()]) // &lt;- this does not depend on a and b, but awaits them anyway so just do this instead? const [a, b, c, d] = await Promise.all([foo(), bar(), foo1(), bar1()]) 
`"use stricter";`
What coding guideline allows you to write if statements like that? Most styleguides say you should use brackets for if statements. Besides if you see that, you know exactly what it does, it returns and resumes control to the less indented block of code. I don't see the difference in your second example. Both are on the same identation level, so when looking at [4,5].filter() I don't need context, I know that it is a filter function on an array of 2 elements. Besides not being useful at all (since you don't assign the filtered output) there is nothing wrong or different in those two examples.
&gt; How does that work with a bundled SPA? Webpack will automatically split code into a separate bundle if you do `import(...)`. Your main bundle will not contain it, and you can either load it on demand, or even cue the browser to pre-fetch it once it has completed critical tasks.
You're right, however a large number of these Webpack starters have `"extends": "standard"` so I assumed that's how eslint comes by default. I don't really have a horse in this fight, even tho I am somewhat of a Pythonist so semicolons aren't really my thing, but they irritate me much less than `camelCase` (which does reduce readability) and I've learned to live with that one being common in JS. I still think it would be nice if the TC people came up with this idea (or even a hard rule) years ago, before so many codebases became low-semicolon and when much more people were coming in from Java/PHP where semicolons are mandatory.
Never understood that exemple as having semicolon or not does not change anything. However, that code needs explicit semicolon (and the error thrown is not really user friendly...) : ```[1, 2].find(n =&gt; n === 2) [1, 3].find(n =&gt; n === 2)```
&gt; Besides not being useful at all (since you don't assign the filtered output) there is nothing wrong or different in those two examples. The first example is actually not an array. It tries to access index [4, 5] in an array returned by someFunction(). So that kind of proves my point. Not adding the semicolon changes the code and makes it harder to reason ab out.
Since `"use strong";` was finally never used...
They're not hip. 
`"use force"`
I'm. Not a fan of Eslint 
&gt; I just don't see why you would not want semicolons. Because ASI is there regardless and you need to be aware of it, you might as well take advantage of it. function carShouldBrake (data) { ... return someoneOnTheWay(data) || redLight(data) || goingOffTheRoad(data) || cliffAhead(data); } if (carShouldBrake(data)) { brake(); } else { accelerate(); }
&gt; I still think it would be nice if the TC people came up with this idea (or even a hard rule) years ago, It doesn't matter as JS libs and starters pop up every 5 minutes. The change will blend in smoothly. &gt; Doing it now and this way it kinda looks like finding ammo for a knee-jerk aesthetic reaction on StandardJS rising in popularity. That's not true either. http://www.npmtrends.com/standard-vs-eslint-config-airbnb-vs-eslint-config-airbnb-base-vs-eslint-config-standard
"use strict_new_newer_last"
As a counter-example, Python uses almost no punctuation at all, not even for a lot of the boolean logic operations, and is considered one of the most immediately readable languages out there - "executable pseudocode" as some would describe it. There's a difference between using punctuation to add legibility, and adding punctuation unnecessarily. After all, many languages, like Erlang or Prolog, have different punctuation for statements that terminate a block, vs statements that simply continue a block. That's probably a bit excessive, right? Personally, I use semicolons, but it's not like having a version of JS with no semicolons would immediately become entirely illegible.
Well, looking at the [diff](https://github.com/tc39/ecma262/pull/1062/files#diff-3540caefa502006d8a33cb1385720803R11068), the proposed change seems to indeed add a comment (first change proposed in the diff) that ends in: &gt; As such, consistently explicit semicolon use is recommended. So, you are right that the PR is a more general warning about possible future problems with ASI. But then again, the change _does_ include a recommendation to use semi-colons. To be fair, it is _still being discussed_ and there are other related changes being considered to, so you're right that the TC39 does not _yet_ recommend one way or another. But if the change is accepted with the current spirit, it looks fairly probable that it will include some general recommendation to use semi-colons. All in all, a headline "TC39 **considering** officially recommending..." seems like a pretty correct description of the situation. They _are_ considering it. It is under discussion at this precise moment.
I love ASI. It cuts down the tedium of unnecessary semicolons. Semicolons do nothing for readability for me. It's unfortunate that an easy language to use like Javascript is turning into a very difficult language to get along with. Maybe next they'll add significant whitespace so we can complete the descent into pedantry.
&gt; Without semicolons it makes guesses which means it won't be always working as intended. This only happens if you really have no idea what you're doing. Javascript without semicolons isn't difficult at all.
To be absolutely pedsntic, there is one, very rare case where that sentence would be justifiable ‚Äî if the person saying it is themselves between 14 and 18 years old (because then it just means they're into people of their own age). But that's not how that sentence ever is used IRL.
Python has "punctuation", see colons for new blocks. In most cases a new line is the end of the statement, if it's not, then you have to have some way of determining where it ends, sometimes by wrapping in parenthesis. It does impose limitations though, one of which is that lambdas have to be a single line.
what about "hoisting" in JavaScript. when compiled the variable is brought to the top. so even if I was set to 10 within the for loop it would be 0 
But so does JS, even without the semicolons. We're not talking about removing literally all punctuation, we're talking about removing some of the punctuation be omitted grammatically. So the comment that JS without semicolons is liketalkinglikethis is what I was specifically trying to get at.
Maybe this is just unfortunate phrasing on your part but c'mon, semicolons don't turn javascript into " a very difficult language to get along with"
I kinda hate that the arguments are a,b,c in this debounce function and the format of it. It feels like you expect us to just copy that and never think about it. It would be better to have it be clean and let us know what's happening in this "performant" debounce. 
```function debounce(a,b,c){var d,e;return function(){function h(){d=null,c||(e=a.apply(f,g))}var f=this,g=arguments;return clearTimeout(d),d=setTimeout(h,b),c&amp;&amp;!d&amp;&amp;(e=a.apply(f,g)),e}}``` Have you taken this function from a minified source?
Whilst we're at it, could we bad trailing commas? I've just inherited a codebase with `method(calls,that,look,like,this,)`
the transpiled version should work in any reasonably recent Firefox, the last example should work starting from 57, and the first few won't work because Firefox doesn't have ponter events, I didn't include the simulator for them in starting examples to make them shorter
Agreed. I just tried from Firefox 57 and the divs don't move when dragged. Would you consider fixing the examples?
I minified it. I'll put up the unminified version too.
These are the most popular examples of how lack of semicolons can bite you, but on the other hand both of these examples have more legible analogs that don‚Äôt cause any problems. I would request a refactor for either of these examples if I were reviewing the code. I think the other example I saw up above in another comment was a ‚Äúreturn‚Äù on one line and ‚Äútrue‚Äù on the next line, with the author lamenting that ASI would add a semicolon after ‚Äúreturn‚Äù, causing the parser to interpret the first line as ‚Äúreturn undefined‚Äù. But again, that example begs the question: why would you write a 2-line ‚Äúreturn true‚Äù? I have not yet seen an example of code-breaking non-semicolon JS syntax that doesn‚Äôt make me ask ‚Äúwhy would you write it that way anyways?‚Äù
I prefer my code to have no characters at all. 
oki, fixed, I added a polyfill in the first examples, all should work now in Firefox 57
My point is not that the lack of semicolons leads to lots of problems, it doesn't, just that it requires more mental work to understand the code. Even if the extra overhead is just 1%, why would you want it? ASI is the compiler trying to guess what you meant. Why not just tell the compiler what you meant?
For you and me, there's Python.
Or "get over it and use a semi colon hipster"
Nope, JS is going in a different direction, even adding support for trailing commas - i.e. in Objects. And they do make sense, even though I agree they're kinda ugly..
Thanks
Just like PHP a few years back: [mysql_escape_string](http://php.net/manual/en/function.mysql-escape-string.php) vs [mysql_real_escape_string](http://php.net/manual/en/function.mysql-real-escape-string.php)
Hard times for Standard style to come
How does it verify the correct signer? I don't believe NPM supports keys for a repository. Couldn't an evil person just sign their bad package the same way?
Is there even a war for that? Does anyone see a single advantage in using tabs?
What kind of animal uses tabs :-P
"use strict_new_newer_last_FINAL"
Be careful, you're kicking a thriving, angry nest.
They're nice when the list is separated onto multiple lines, but I don't really see the benefit when everything's on one line like that.
I like this one.
I kind of thought that semicolons were always recommended...
I disagree that it requires more mental work to understand. The combination of proper, predictable indentation and sensible, readable line breaks makes the addition of semicolons redundant, imo. And by adhering to those principles, I never have problems with the compiler not knowing what I mean, either.
Your can remove your .idea with this solution. https://stackoverflow.com/questions/1274057/how-to-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-gitignore
I'm so angry right now, I'll sneak in some tabs in space based open source projects to cool off.
i hate you
In comparison, how many companies follow Airbnb style guide , which enforce semi ? What I don't like with StandardJs is that it is not a standard as it's name pretends but Feross opinionated style, being right or not. Npm not using namespace by default , it's even worse.
The problem is real, but your answer is called "defensive copying" and has its own set of problems. I'm not saying you shouldn't use it (in some cases, it is actually the only option), but performing a deep merge every time you take an argument from an outside function doesn't play well with performance. Also, it could touch underscored (private) properties, which leads to undefined behavior. To combat mutation, I would categorize it as two cases: when you receive mutable objects, and when you send them. ## Receiving mutable objects At receiving, primarily as function arguments, you have an advantage in JavaScript, the event loop design guarantees that synchronous functions don't get interrupted. Therefore, if you receive a mutable parameter, you can be sure that nothing outside your function will mutate it until your `return` statement. However, callbacks, promise handlers, and asynchronous functions can be affected by mutation. For example: Callbacks: function foobar (foo) { console.log(foo.bar) // this is safe setTimeout(() =&gt; { console.log(foo.bar) // this is not safe }, 1000) } Promises: function foobar (foo) { console.log(foo.bar) // this is safe baz().then(() =&gt; { console.log(foo.bar) // this is not safe }) } Async functions are just syntactic sugar for a `then` chain, meaning you are safe until the first `await`: async function foobar (foo) { console.log(foo.bar) // this is safe await baz() console.log(foo.bar) // this is not safe } In all of these cases, you have a "safe zone" in your function. Use that safe zone to save everything you would later need into a variable. For example: async function foobar (foo) { const bar = foo.bar // assuming foo.bar is an immutable primitive console.log(bar) // this is safe await baz() console.log(bar) // still safe, because the changes in foo don't affect the function variable bar } If you require more than just primitives, you can still use the deep merge technique, but at least you are not merging the entire object, which means it's less likely to run into undefined behavior. ## Sending mutable objects Of course, you aren't just consuming mutables, you are going to use them too. Let's take this example: async function foobar () { const foo = { bar: 'example string' } console.log(foo.bar) // safe await baz(foo) // foo, a mutable object, is passed to an outside function console.log(foo.bar) // not safe, baz() could have mutated foo } By letting go of `foo`, you let go of control over it, and `baz()` could have code that tries to mutate it. (It actually happens a lot when inexperienced people handle default values.) However, you don't have to resort to defensive copying since ES6 and its proxies. My usual method here is to create a "shield" proxy, which lets you access data the same way, but blocks all mutations. This way, you can safely pass any object to any function and be confident it's not going to change it. It works like this: const foo = {bar: 'example string'} const shieldedFoo = shield(foo) // creates a read-only reference to foo console.log(foo.bar) // 'example string' console.log(shieldedFoo.bar) // 'example string', shield is transparent to all read operations shieldedFoo.bar = 'mistake' console.log(shieldedFoo.bar) // 'example string', shieldedFoo is read-only foo.bar = 'intended mutation' console.log(shieldedFoo.bar) // 'intended mutation', you can still change the object through a read-write reference This way, you can easily solve the problem in the above function: async function foobar () { const foo = { bar: 'example string' } console.log(foo.bar) // safe await baz(shield(foo)) // only a read-only reference to foo is passed console.log(foo.bar) // therefore, this is still safe, foo is guaranteed to be untouched } Write operations fail silently, like in other immutable JS objects (there are a few actually). However, this can cause some trouble with badly written libraries that don't expect immutable parameters. Therefore, a patch to shield that throws an error on write attempts might be helpful. --- ## Appendix: full code of the `shield()` function: // returns a proxy that blocks all attempts to mutate the target object const nope = () =&gt; false const unset = {} // how to use reference-based equality for authentication 101 const shieldedObjects = new WeakMap() function shield (bearer) { if (!(bearer instanceof Object)) return bearer if (shieldedObjects.has(bearer)) return shieldedObjects.get(bearer) const cache = {} const descriptors = {} let proto = unset function mask (property) { return (typeof property === 'symbol') ? property : `prop-${property}` // for tricky names like 'constructor' } function getProperty (target, property) { // nice try const masked = mask(property) const value = target[property] if (typeof value !== 'object') return value if (!(masked in cache)) cache[masked] = shield(value) return cache[masked] } const shielded = new Proxy(bearer, { set: nope, deleteProperty: nope, setPrototypeOf: nope, preventExtensions: nope, get: getProperty, getPrototypeOf: function (target) { if (proto === unset) { const prototype = Object.getPrototypeOf(target) proto = (typeof prototype !== 'object') ? prototype : shield(prototype) } return proto }, getOwnPropertyDescriptor: function (target, property) { const masked = mask(property) if (masked in descriptors) return descriptors[masked] if (!(property in target)) return undefined const descriptor = Object.getOwnPropertyDescriptor(target, property) if (descriptor === undefined) return undefined // for some reason some properties get here if ('set' in descriptor) delete descriptor.set if ('value' in descriptor) descriptor.value = getProperty(target, property) if ('writable' in descriptor) descriptor.writable = false return descriptor } }) shieldedObjects.set(bearer, shielded) return shielded } module.exports = shield To apply the error on write patch, change the `nope()` function into something like this: const nope = () =&gt; { throw new TypeError('Attempting to mutate immutable object') }
Or if new syntax is added to the language in the future, which is the motivation for having the TC recommend semicolons.
Whitespace and punctuation are different in the way the human brain perceives them - you know this, of course. Code and English are also completely different. With formal logic, which is more like code, standard English is eschewed as well. All that to say, this isn't an apt comparison, as I'm sure you're well aware. It boils down to personal preference, semicolons.
The new syntax is almost certainly optional to use, and likely just syntactic sugar which may or may not really be that useful. 
&gt; Does anyone see a single advantage in using tabs? Yes. Clicking on the whitespace and having it aligned to the indentation levels.
I just noticed this: &gt; Hey, so - this makes me a little sad. JS is the only language I write, and I don't use semicolons. I know it's just a warning clause, but it sounds like the TC39 is saying we're bad for using the language in a particular way. And it, feels, well, a little hurtful. Feelings are hard to describe, but yeah - it's not a great feeling. WTF. Is this a millennial thing? That is an absurd level of emotional sensitivity. How do people like this hold a job? Do they cry into a pillow anytime somebody has a differing opinion?
You're right! I wasn't fully awake yet.
No. I can still place the cursor between levels. It's really annoying.
That's one of my least favorite things about Rust. 
For others reading this, you should be aware of Object.freeze to prevent mutation of object properties: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
There's a nice one in Matlab. `close` closes the current figure. `close all` closes all figures. And `close all force` closes all figures, including some extra special ones not included in "all figures" for the purposes of `close all`.
My recommendation is: `"security";`. Nobody wants to say it but the semicolon holy war is a security conversation. Either you are risk intolerant, for whatever reason, or you are risk averse, for whatever reason. Your motivation for using (or not using) semicolons could be the single most important qualifier in the universe, but it is still about deferring or accepting a certain amount of risk. I say this as a CISSP. Security is **only** about two things: * Assessing confidentiality, integrity, and availability * Performing adequate risk analysis I am not favoring any opinion on the semicolon holy war. Aside from eliminating ASI under a more strict and entirely optional pragma I would also throw a couple more things in there, like type recasting.
And how would using semicolons help that one? It's actually deceptive, making the illusion that it's `return true;`, not `return; true;` like it becomes after ASI. If you don't use semicolons, you don't get weird ideas about this one. We need `"use no asi";`
This still `await`s twice, once for each argument here. 
This still awaits twice I think.
Only one problem, it's shallow, and deep freezing an object has the same performance impact and same possible errors as deep copying it. Actually, it's even worse if it contains anything from the outside, because you mutate it that way. The reason I like proxies so much is that they can be deep without having to go through everything. `shield()` is deep and lazy, it only processes a property when you access it, to the extent you access it. Moreover, even when it does decrease performance, it smooths it out instead of having one big spike at the beginning.
The problem is not how many times you await, but what's after it. When you do this: async function foobar () { const a = await foo() const b = await bar() return baz(a, b) } it doesn't start `bar()` until `foo()` is completed. However, the code in the example starts both in parallel, then when both are finished, continues with the return. It's quite easy to see that this: -- foo ---&gt; | -- baz --&gt; - bar -&gt; | is faster than this: -- foo ---&gt; | - bar -&gt; | -- baz --&gt; even though both await twice (denoted by `|`).
It's like doing foo().then(bar()).then(...) instead of foo().then(bar).then(...) You're still wasting a tick. `Promise.all` is the best option
THOSE EVIL SEMICOLONS THE CODE IS NO LONGER WORKABLE FOR ME
I use tabs mapped to spaces and this also bothers me, but I feel like it should be addressed by a setting on the editor I use and not by formatting baked into the plaintext file I've opened.
That's awesome, thank you! I knew I shouldn't be hard coding strings, I just didn't have any reason not to. Walking into work, I'll dig deeper. 
Careful that‚Äôs how you write java code !
Because computer languages need to be precise, and you actually do need to type them in order to enforce the preciseness and avoid ambiguity and bugs.
I only put semicolons in my javascript when node or when react build process yells at me. This happens when for example you start a line with a square bracket or parenthesis. Is it possible to introduce a bug by not putting semicolons without rising an exception at build time ?
Isn't this a little like if oracle said something along the lines of: &gt; I know you all use garbage collection, but we may add Java features that break it, so don't use this feature of the language anymore. Kind of seems like ASI compliance needs to be a requirement of new functionality, not a 'nice to have' Edit: A word
This is perfectly fine, until you realize that languages should not only be expressive but also designed in such a way that non-experienced developers will be encouraged to avoid these situations. It is insane how many people with just enough knowledge to write code will be able to write the most obscure code. It is rarely pretty. Some like to avoid writing brackets. It is perfectly reasonable to do this, but readability in general will decrease if you make it a habit. It is better to include redundant prevention syntax with little overhead to ensure all code in general become more readable. As such, I am definitely in favor of adding semicolons. 
Wow, this is great, thank you! I knew there were lots of optimizations to make, I love how you refactored the types and things. I'm at work, I want to sit down and grok all of the changes, but could you explain these lines? I've not used reduce() much. ``` const allowed = Object.keys(types) .reduce((allowed, key) =&gt; allowed.concat(types[key]), []) ```
Try rollup, I found it to be easier to make projects npm ready than webpack
It needs to wait for all the data to be available before it continues. The complaint wasn't that "await" was used twice, but that the first await waits for the data before the second one starts, killing the benefit of being asynchronous. 
It's not a standard at all. It's just, rather obnoxiously, named "standard js" by it's developer. It's just one style of many, with a idiotic name.
I agree, but semicolons are the least of your readability problems with JS. If you really want to enforce readability in JS today, you must lint, and if you do lint with some sensible rules, semicolons lose their usefulness immediately. At least in my experience.
This actually scares me.
To each his own. I feel languages without semicolons enforce good coding habits by forcing "one statement per line" and prevent at the parser level that some monkeys are doing something like this: hey(); look(); how(); cool() i(); am(); i(); put(); everything(); on(); one(); line();
JSlint insists on the trailing comma for objects. In my opinion it's the dumbest standard I've ever seen. I mean, you have to type a comma either way...
Thnks for the response. They know I am in a bootcamp and don't mind the lack of experience. Any advice for a newcomer?
Yeah, I never said that. I actually add semicolons because of people like you who just can't read code without them. Semicolons are your crutch.
 An example from 2017: https://stackoverflow.com/questions/86105/how-can-i-suppress-the-browsers-authentication-dialog
That's awesome! Very cool work.
I don't know who you're arguing with, you're preaching to the choir but the point remains that many places still use IE8 claiming the locked-down administrative security as the reason, and I still have to support these clients.
Ha I was reluctant to drop semi-colons but I'm loving the semi-free life!
&gt; is proportional to two raised to &gt; the power of its position This is such a programmer phrase lol
This is great! I just spent half an hour learning streams and can't believe I didn't know about them. I have a question, do the streams flow through item-by-item in order? Are race conditions possible in which one chunk may return before another? I ask because in the case of albums, I want to maintain the order of the files as they were read from directories. Another small change is that jsmediatags should be run when id3 is true (jsmediatags IS my ID3 reader), the other function using paths is for when id3 === false. Thanks so much, this is exactly why I posted the code, I love seeing better ways of doing things. Would you like to PR your code?
My thinking has changed on trailing commas more so because of diffs in source control not so much because of a language feature. const foo = { bar: "hello", baz: "world" }; If I add a third member, `zzz : "something"` to the end of the above object, I alter two lines. If I have the trailing comma, I'm only adding one line. It makes the diffs much cleaner. &gt; `methodCalls(looking,like,this,)` Fuck that noise tho.
Guys, just wanted to let you know what the new version v1.1.0 is out with lots of bug fixes and new features! [Check out this release](https://github.com/hql287/Manta/releases/tag/v1.1.0 ) My apologies for the delay, but from now on, there will be a minor release every week. üòÉ Enjoy!
Some of those comments.... Someone links to: https://feross.org/never-use-semicolons/ Jesus christ. The author has a fundamental problem understanding language design. 
Oh, I see, an event queue tick. How much does it affect performance? In most use cases of JS, the ease of development outweighs microoptimalizations like that, as long as it's still "micro". --- By the way, no, non-functions passed to `then()` don't go through `Promise.resolve()`. [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then): &gt; If one or both arguments are omitted, or are provided non-functions, then `then` will be missing the handler(s), but will not generate any errors. If the `Promise` that `then` is called on adopts a state (`fulfillment` or `rejection`) for which `then` has no handler, a new `Promise` is created with no additional handlers, simply adopting the final state of the original `Promise` on which `then` was called. Basically, the previous value passes through. It would be error-prone anyway, if `bar()` returned a function, it would be executed, not passed.
I get your point. In my case that would be caught by a linter or other static analysis tool.
It probably doesn't impact performance much, I was just making the case that `Promise.all` is preferable. Misconception about then has been corrected.
This. Trailing commas look ugly but are quite practical.
That example isn't to point out the dangers of relying on ASI, but to point out that having ASI comes at a cost, even if you never rely on it.
That's what they were saying; a lot of the discussion around ASI is how, because ASI is imperfect, writing code without semicolons can be dangerous. Their example was to show that ASI also causes issues in the "other direction", where code which has semicolons in all the correct places can also be broken by an over-eager ASI.
Javascript is 100% backwards compatible, right? Maybe I'm wrong
If you don't know the answer of a question, try to explain what and why do you think could be the answer. Try to show them how do you think. Or how you can research the solution. 
I wish SQL had a few features to make editing easier. Trailing commas would be nice, but if we could use "WHERE" as a synonym for "AND", it would make query generation 100x less of a pain in the ass.
No problem. Think of the array methods like this: - forEach: touch every element, don't return anything - map: touch every element, return the same number of elements (but modified) - filter: compare every element, return a subset of the elements - reduce: touch every element but return something completely different The thing to realize is that reduce can literally return anything you want. It could return the same array, it could return an object, it could return a function. The signature looks a bit like this (in psuedo code): target.reduce( function(thing_from_last_iteration_OR_starting_thing, element){ return thing_for_next_iteration }, starting_thing ) So in my example: const allowed = Object.keys(types) .reduce((allowed, key) =&gt; allowed.concat(types[key]), []) On the first iteration, reduce looks like this: ( [], 'image' ) =&gt; [].concat( types['image'] ) Second iteration: ( ['.jpg', '.jpeg', '.gif', '.png', '.tiff'], 'audio' ) =&gt; ['.jpg', '.jpeg', '.gif', '.png', '.tiff'].concat( types['audio'] ) So on and so forth. The last iteration returns all of the arrays concatenated together. The last iteration determines what ultimately gets returned by the reduce method. If I wanted, I could return something completely different on the last iteration, and that's what would be assigned to the variable `allowed`. 
You think it's untidy because why? It's ugly? It makes your code look bad? Do you really sit there and think, "Wow, this is just a wonderful line of code. Edgar Allen Poe would love the name of this method. Sucks that I'll have to add a semi-colon to the end of it and ruin it all. I mean just look at that kerning and the subtle curve of the R!" I use semi-colons in JavaScript because their intent in usage is clear to anyone who has ever coded a C-style language. Python, Kotlin and Scala are just fine without semi-colons. They are designed with that in mind. JS could have been just fine without semi-colons had it just made that decision. Instead JS trolls us with this gray area containing both possibilities and we're arguing this 20+ years after the language was designed. If you're using Python, Kotlin, Scala as your back-end language, you're probably not going to use semi-colons on the front end. If you're using Java, PHP, Perl, etc. you're probably going to use semi-colons. 
I didn't say it's difficult. I've said that you choose between the parser knowing for sure what you wrote and guessing what you wrote. It's safer to use semis because you don't know what guesses the parser will make in the future (hence the change).
Yeah, that authentication dialog pops up because the server is returning a "WWW-Authenticate" header back to the client, not because it's returning a 401. 
I never implied that it was a standard. 
&gt; because I DO KNOW what the fuck I'm doing with javascript. Which may stop being truth overnight unless you're a clairvoyant. :) &gt; You, on the other hand seem to be a superstitious coder that probably doesn't know what's going on most of the time. Perhaps I don't need to and I prefer focusing on what really matters? :)
Www.codewars.com, or simply make index.html and write some scripts for practice and total better understanding 
Proxies aren't without their limitations though. Maps will break shield, for example m = new Map([['x', 1]]) m.get('x') //-&gt; 1 shield(m).get('x') // error And this problem will only get worse when privates are added to classes which would also break in proxies.
Some things I look for in a frontend interview. Don't try to pretend or guess what you don't know. "I don't know but I am willing to learn and I am a fast learner" are the magic words. Since you only have the weekend, there's not a whole lot you can cover but I would check out some of the things that are very particular to JavaScript and try to understand them a little better. The [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) books by Kyle Simpson are excellent for that. I would focus on the book about "Scope &amp; Closures", and the one about "this &amp; Object Prototypes". If you can get through those and memorize the key points, you are way ahead of most people. If you still have time after that, brush up on HTML5, CSS3, and jquery.
&gt; try to explain what and why do you think could be the answer As someone who has interviewed a lot of programmers, this is risky and can feel awkward. Nothing is worse than someone desperate to have an answer and trying to pull stuff out of thin air. You have to make it super clear first that you do not know the answer. Make sure the interviewer is open to the idea of you guessing or showing how you would research the answer. Sometimes "I don't know" is perfectly ok and they would rather just move on to the next topic.
Super clear explanation, cheers!
It sounded like you where saying that semicolons was making the language difficult, but I wasn't entirely sure if that's what you mean, which is why I had the part about unfortunate phrasing in my comment. Thank you for clarifying though
How come?
It is nice to see the other side of the table. :) Usually this works for me. The interviewer shows me a piece of code and ask me to tell what the code do. "I don't know but I think that lines 3 and 4 will do XXX because of YYY." I think this is better than just say that you don't know. But it's just an idea. :)
You can take a look at this questions. But don't worry a lot about this. https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/README.md
Here's the author's answer to that legitimate question : https://www.reddit.com/r/node/comments/7pri0s/pkgsign_package_signing_and_verification_for_npm/dsk6aao/ Basically, the article doesn't explain it, but it seems that the previous identity used to sign the package is stored if trusted, and if it changes, the package cannot be verified.
You're right, shield doesn't handle `this` very well. I don't see any other way right now than binding the property if it's a function, but that could still affect behavior in other cases.
Frankly, I used to prefer tabs, but I've been working so long in spaced codebases, that I have defaulted to spaces for all my work now. :-S There's no disadvantage in tabs, and I'm not sure why so many people have settled on spaces. Especially since I prefer 4-unit spacing, and the rest of the world seems to prefer 2-unit spacing, which just isn't enough spacing, for me. So I should prefer tabs heavily. But I just don't care, so long as I can write code that is 4-unit spaced. 
Probably has nothing to do with EsLint, I think we just use some outdated Hipster linter on codeclimate that makes terrible suggestions. 
I have some colleagues that used that example for the opposite argument... That's why I never understood that example :)
... which reminds me, we don't support method(x,,,y,) do we? i haven't tried it in years. (that would call method with x, undefined, undefined, undefined, y, undefined) 
Now you can check checklists off your checklist 
You CAN manually clean up objects in Java. No one does because gc makes it unnecessary. The same comparison can be made to the -&gt; operator in C++. Technically it's just syntactic sugar, but how many applications would compile if it was removed? Removing ASI is a breaking change for, possibly, millions of web applications. tc39 allowing new features that are incompatible with ASI is irresponsible. If a new feature is incompatible with a language construct, the feature needs to be reworked so that it's compatible. You can't just tell people "Oh, that functionality that has been reliable for the past two decades? We're going to start introducing changes that break it, because maintaining compatibility is, like, hard and stuff."
I don't lol. You're obnoxious. Wasn't nice talking to you.
&gt; `//! js 2.0.0` A shebang in a Python or bash script is designed to be read by the shell, but ignored by the Python or bash interpreter. There is no shell in JavaScript. Also comments are deleted in minified code, so this is a non-starter. &gt; `"use js 2.0.0";` I can't think of a good reason for this not to work with the next generation of browsers. But what happens to the generation after that? If My version of Chrome is looking out for `"use js 2.0"` and I visit your site which runs a script that starts with `"use js 3.0"` how does my browser react? Do I just not get any JavaScript? 
In the real world it hurt me once using an IIFE. I see expressions as entities that have to be unambiguously terminated and always end with a semicolon;
That's why it's `//!`, not `#!`, but I get your point. Also, it's not necessarily python, `#!/usr/bin/node` also works. As for your example, old browsers have trouble with new features anyway, but how about this? // js 1 code function handleOldBrowser () { alert('download a better browser, dammit') // bad way of handling the issue, but it's an example anyway } "use js 3.0.0 or handleOldBrowser"; // js 3 code
Since reddit goofed, this was intended for you: https://www.reddit.com/r/javascript/comments/7pr0e2/tc39_considering_officially_recommending_using/dsl4e99/
I am embarrassed, this was intended as a response to below. I'm not sure what reddit is doing lately this happened three times to me over last few days. https://www.reddit.com/r/javascript/comments/7pr0e2/tc39_considering_officially_recommending_using/dskptyn/
For that kind of thing, I do it the way god intended: With a shell script (which can run/be in any language) and a cron job.
I don't have a great answer for this, but a decent guess. JS in browsers is really well optimized. Like.. REALLY well. ASM is a good example of this. So if your goal is to write in a higher level language then you can skip JS altogether and use something like Reason or Clojurescript. There isn't really a need to upgrade the JS runtime just for JS specific upgrades.
It's not about leaving JS, if I wanted to, I'd write it for wasm and hook it up with a JS library. But JS itself could use some backwards-incompatible changes sometimes, and bumping a major version number could be a great way to do it.
What's obnoxious is getting downvoted for liking and using ASI. People are way too uptight about semicolons, and they always have been. 
any concrete examples on what should be removed?
See, the point is that the first example is buggy, and you didn't notice.
generally, yes. but other languages that i've used allow you to skip a parameter by just leaving it out, and i don't think js does that even now that we have default parameters. :-S 
I dunno where you work but at least in the US, as long as you don‚Äôt let it affect your full time job, don‚Äôt use company resources, and don‚Äôt work for competitors, you‚Äôre usually okay. A buddy of mine has a contract that says his employer owns all of his intellectual property, even if created at home, but those terms generally don‚Äôt hold up.
Make a separate script (e.g. tasks/do-the-thing.js) Then set up a cron job that executes that script. (node /path/to/app/tasks/do-the-thing.js) You just need to make sure whatever user cron is running as has access to node.
I actually had to do this recently, and naturally you'd look into standard shell cron jobs But **holy shit** I ran into so many issues trying to get it to recognize node, environmental variables, and issues with npm and using babel-node, and after multiple hours, multiple attempts, and multiple google threads I just gave up Instead, i ended up using [node-cron](https://www.npmjs.com/package/node-cron) which is basically like a cron-job, but done in a node application, and got it running in &lt;5 minutes What you would do is in your project have a separate js file who's sole job is to run the job, and just do a import cron from 'node-cron' import Thing from 'src/utils/Thing' cron.schedule('35 */6 * * *', function(){ Thing.doThing(); }); and then `forever start ./cron-update`, or add it to your package.json "scripts": { ..., "cron": "babel-node cron-job.js --presets es2015,stage-2" }, and do `npm run cron` So much easier, especially if you're a node developer not completely familiar with bash/cron stuff
I'd love to give my opinion on that, but all it shows is a background picture.
yo dawg?
With tabs you can be 100% sure that your code sits on an even spacing, none of that inbetween shit. With spaces, if you press backspace accidentally one too many times while refactoring you can end up having code on 4, 7, 8, 10, 12 and my OCD goes off the charts I don't think I've ever copied code that uses spaces and *not* ran into formatting hell
Yikes. I scanned both my personal site and it appears Github Pages and Netlify both get 0/100 scores.
That's why I asked if it's stupid or not. Apparently, it is stupid, at least in the form I asked. The main point here is breaking changes, if we follow semver, minor or patch versions don't really matter. It could simply be "use js 2"; and it would be a regression in features at first, not a guarantee for matching a spec. Let's say JS 2 doesn't have to support ASI anymore. That breaks compatibility with any code that depends on it the slightest, but also makes room for features or corrections of behavior. I don't think version jumps would be common, but every once in a while it may be worth it to clean up some legacy stuff without breaking existing code.
setInterval
To encompass your functionality in an all-Node system, use a task scheduling system like node-resque, which is built into platforms like ActionHero. Using cron is fine, except when you have long-lived resources that your entire application may need (configs, database handles, http clients, etc). Then separating functionality becomes cumbersome. And despite what white-bearded mythological figures intended you to do with cron, the universe demands that you evolve. üòâ
Wrote this kind of quickly so I'm sure there are some test cases where this wouldn't pass, and the resulting validation error messages aren't great, but I would probably do something like this: function schema(model) { const validate = (model, value) =&gt; Object .entries(model) .reduce((result, [ key, type ]) =&gt; { const val = value[key]; let required, error; if (type.type) { required = type.required; type = type.type; } if (val) { if (typeof type === 'object') { if (typeof val !== 'object') { error = 'result does not match schema'; } else { const validation = validate(type, val); if (Object.keys(validation).length) error = validation; } } else if (!(val instanceof type) &amp;&amp; typeof val !== type.name.toLowerCase()) { error = `should be a ${type.name}`; } } else if (required) { error = 'is required'; } return error ? { ...result, [key]: error } : result; }, {}); return value =&gt; { const validity = validate(model, value); if (Object.keys(validity).length) return validity; else return true; }; } Uses recursion and some hacky type checking.
 Object .entries(model) .reduce((result, [ key, type ]) =&gt; { Dude that is so smooth, I had no idea about Object.entries -- and destructuring like that in reduce is great
This function has a caveat that you cannot use the property "type" in any nested objects.
Maybe I'm not understanding what you mean, but every modern editor can easily convert pressing the tab key to N spaces. You don't have to press the space bar N times ... So it's exactly like a tabulation, only better.
Main bottleneck here is the network. Whether the web application initialization time is short or long, it'd depend on the size and complexity of the application. For network optimization... Merge all resources of the same type (i.e. script, CSS) into one file, to minimize the number of network requests. And use URL variable (e.g. `file.ext?t=123456789`) only when they are newer version (set it from the HTML). i.e. don't make the clients to always retrieve the resource from the server. Use the file modification time sent through HTTP resonse header. Also consider using the Application Cache feature.
Choose which element you want to put the image element into - as a container. Use one of these element retrieval methods: https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector Then to put the image into the container element, use one of these: https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore &gt; I want to put it into a simple HTML page so that if firstimage.jpg doesn't load in time it will load newimage.jpg instead. That code should work as expected except below line. image.src = "firstimage.jpg" + encodeURI( document.cookie ); It should be: image.src = "firstimage.jpg?cookie=" + encodeURI( document.cookie ); Although you should check the HTTP request header from the server-side script if you want to read user cookie from the server.
I kinda took some of your approach and did it in a functional way function Schema(schema) { const keys = _schema.parse(schema); return json =&gt; Model(json, keys); } function Model(json, schema) { const errors = _schema.validate(schema, json); return { valid: Object.keys(errors).length === 0, errors, json }; }; const _schema = { parse (schema) { return Object.entries(schema) .reduce((obj, [key, definition]) =&gt; { obj[key] = _schema.parse_model(definition); return obj; }, {}); }, parse_model(model) { model = (!model.type) ? { type: model } : model; model.type = typeof model.type(); return model; }, validate(keys, json) { let _validators = Object.values(_schema.validators); return Object.entries(keys) .reduce( (result, [key, model]) =&gt; { let error; _validators.forEach( test =&gt; { let result = test(model, json[key]); error = result || error; }); return error ? { ...result, [key]: error } : result; }, []); }, // Tests that are run on each value validators: { validateType(model, value) { if (!value) return null; const type = typeof value; return (type !== model.type) ? `expected '${model.type}' but got '${type}' instead (${value})` : null; }, validateRequired(model, value) { return (model.required &amp;&amp; !value) ? `required key is null or undefined` : null; } } }; Validators are easy to expand now just by defining more functions on the object. Also, I got rid of the getter and calculated it at runtime, I dunno why I originally did that
I don't see a problem with you trying to make a very quick guess to show your reasoning skills. Some people really go on for a long time spouting nonsense as if they can trick me... I mean I wouldn't be asking questions that I'm not already really knowledgeable about. I think some candidates must think I'm asking them to teach me and they can just invent shit.
Thanks! I think I fixed all the bugs, made a tiny yet useful [readme](https://github.com/ericoporto/kejo) and made a [demonstration webpage](https://ericoporto.github.io/kejo/). Now trying to understand how to do the packing!
https://stephengrider.github.io/JSPlaygrounds/
This is my solution: nothing crazy at all. Includes test cases: 'use strict' // C style assert: logs a stack trace if given a function that returns false, // otherwise disspaears during dead code elimination in closure compiler. /** @const */ var DEBUG = true; // set to false if you want the asserts to dissapear var assert = (() =&gt; !DEBUG ? () =&gt; {}: (test) =&gt; console.assert(test(), test.toString()))(); var warn = (() =&gt; !DEBUG ? () =&gt; {}: (msg) =&gt; console.warn(msg()))(); // or write this an an es6 class, personal preference var Schema = function (schema, required) { assert (() =&gt; typeof schema === "object" || typeof schema === "string"); this.required = (required === true); // coerce to boolean from undefined this.schema = schema; this.numRequired = 0; if (typeof schema === "string") { this.isPrimitive = true; } else { this.isPrimitive = false; for (var key in schema) { assert (() =&gt; schema[key] instanceof Schema); if (schema[key].required === true) { this.numRequired ++; } } } }; Schema.prototype.validate = function (objToTest) { var hasRequired = 0; if (this.isPrimitive) { // primitive types return typeof objToTest === this.schema; } for (var key in objToTest) { var schemaValue = this.schema[key]; var objValue = objToTest[key]; if (!schemaValue) { // key present in object not present in schema return false; // or throw depending on use case } if (!schemaValue.validate (objValue)) { return false; // nested object incorrect type } if (schemaValue.required) { hasRequired ++; } } // if hasRequired !== this.required, then we do not have all of the // required elements in our check object. return (hasRequired === this.numRequired); }; // each object entry MUST be a new Schema, otherwise, nested types will break. // you can nest your schemas however deep you want. var subscriptionModel = new Schema ({ id: new Schema ("number"), email: new Schema ("string", true), name: new Schema ({ firstName: new Schema ("string", true), lastName: new Schema ("string") }, true) }); // passes: all fields assert (() =&gt; subscriptionModel.validate({ name: {firstName: "john", lastName: "Smith"}, id: 1234, email: "foo@bar.com" })); // passes: lastName not required assert (() =&gt; subscriptionModel.validate({ name: {firstName: "john"}, id: 1234, email: "foo@bar.com" })); // breaks: bad types assert (() =&gt; !subscriptionModel.validate({ name: {firstName: "john"}, id: "hello", email: "foo@bar.com" })); // breaks: no email assert (() =&gt; !subscriptionModel.validate({ name: {firstName: "john"}, id: "hello", })); 
Absolutely one of my favorite techniques - combining entries and reduce opens up so many doors and gets rid of empty initialization. 
https://github.com/agenda/agenda is good for this. I'm biased in that I wrote the UI Agendash for this project. We have a Slack channel and some great contributors.
Asynchronously, satan
I was just giving a poke at this, and I'm noticing that import.meta isn't currently supported in 9.4.0. (SyntaxError: Unexpected token import at ModuleRequest.js:33) .. probably worthy of mentioning if this is implemented somewhere already or not, it doesn't seem to be. 
You need to reference the jQuery library.
Lol no, they are fundamentally different languages with very different syntaxes, APIs, and features. What are you trying to accomplish?
I told my team today that I didn't want them to give me bug reports because it sounds like they're saying I'm bad for writing the program in a flawed way and it feels a little hurtful. They just laughed and flipped me another ticket.
One solution is dont store the external data in your database at all. Hit the external api for every request but put the api behind a cache like varnish with 24 hour expiration. Now you dont need a scheduler.
[Like Brython](https://brython.info)?
You probably would have had an easier time exposing a url and hitting it with curl on the cron timer.
Very nice article. Angular 2 ftw tho. I'm a corporate tool I guess.
I'm glad vue is getting the traction is deserves. It's a dream to work with. 
U nees to make automaically number above 20.. I test on my phone
I don't think so. The language never need them and doesn't need them unless you try to use the new syntax they are adding, which I probably won't, so *my* javascript won't need them.
I'm going to give it a shot on a small project I have assigned. Any good intro videos for someone coming from Angular?
The more you zoom in, the slower you zoom. I think it's better to use exponential zoom. Also, when you add a lot of functions the program freezes.
I hope that API is part of a standard, and not a chrome specific extention (IE style)
[removed]
Another vote against this "recommendation" (which will eventually become a requirement as these things do). My code looks cleaner without semicolons and I can more quickly parse code in general without them.
&gt;inconsistencies when using semicolons Are semicolons needed for any of the following? * Function declarations * Function expressions * Block statements (if/for/switch/etc) * Class methods/bodies * Module exports Remembering the rules for when they're unnecessary is (currently) just as confusing as when they are necessary. The argument against semicolons is basically that if you make sure you declare things (like arrays and functions to be used in IIFEs) before using them you can effectively stop worrying about semicolons entirely, and let the compiler worry about them instead.
make numerous of javascript pojects with no help like form-validator,word count,progress bar. for output learn all things like mouseevents,clickevents,changeevents,loading events. the more you complete javascript projects,the more you clear about all output events 
We use agenda and it‚Äôs been nothing but awesome. 
yeah but then you have a public URL that does something that probably isn't supposed to be very "public" node-cron does the job just fine
Looks like [the spec](http://wicg.github.io/aom/) has authors from Google, Apple, and Mozilla.
Bigger the project the crazier it gets. Managing huge project without a framework would be a nightmare. Our angular app has over 2700 different parts I cannot even imagine not using one. For smaller personal projects I find jquery still great.
Pretty sweet! (Just a shame that the title is so clickbaity - it doesn't even say anything about the why...)
Exactly. _Once._ It happened to me twice in total, and both times it was during some "prototype" test code that I quickly wanted to check out. Yes, you're confused for 10 seconds but then you go like "Ooooh it's one of _those_ times". I don't care much about using or not using them, but for me: not using semis == trailing comma Why? Because of diffs. I use trailing comma because reordering is easier and makes a cleaner diff. The same is true for not using semis when you have longer chains. Since I use FP style a lot, I tend to have these: _(array) .map(() =&gt; {}) .filter(() =&gt; {}) .map(() =&gt; {}) .reduce(() =&gt; {}); Having the semi at the end makes it equally "difficult" to reorder as well as: [ map, filter, map, reduce ] Both of these share common "drawback": last line is different. It's even more obvious that these two cases are very similar when you look at differences between RxJS 5 and 5.5 where we have "lettable operators". They allow us to change this... obs$ .map(() =&gt; {}) .map(() =&gt; {}) .filter(() =&gt; {}); to this. obs$.pipe( map(() =&gt; {}), map(() =&gt; {}), filter(() =&gt; {}) ) I'm not saying it's a huge deal. But I surely more often add another function at the end of the chain or reorder the chain than having an IIFE or starting the code with a weird character.
No problem. Took me over ten attempts to post my reply too, it was all 500 errors. Maybe reddit has a stray semi on their backend?
Oh good, it's _this_ thread again... Write vanilla if you want, [plenty of developers do it](https://stateofjs.com/2017/front-end/other/) but you'll just be solving problems that have already been solved, and just tying yourself in knots because there's no obvious way to organise your code. While you're at it, delete [Chrome](https://chromium.googlesource.com/) and [Firefox](https://dxr.mozilla.org/mozilla-central/source/), because they also contain a lot of other people's code. If you don't want to piggy-back on open source code then you're going to be writing bash scripts all your life. Wait hang on, you didn't write bash, did you...? React is so powerful _because_ of all the work that has gone into it, not in spite of it. And now that previous work manifests as a huge node_modules folder. And when you are ready to build a finished React project, it compiles all that work into a &lt;1MB file. The size of the development stack is a total non-issue. Once you get done with the intro tutorials that explain what goes into a starter React project, you'll graduate to using [Create React App](https://github.com/facebookincubator/create-react-app), which installs your dev environment (webpack, babel...) in a single command. I just tried a fresh install and the dir is 195MB before I've written a single line of code. I run `npm run build` on the demo app and it outputs a 35.65KB .js file and a 299B .css file (both gzipped), which is all my users will see. None of this is unique to React, every mature framework will give you some kind of final build/optimisation process before deploying your app. But every mature framework will install a sizeable dev environment. None of this is unique to JavaScript, either. Try installing Android Studio or Xcode or Unity. Those IDEs run into gigabytes, and the actual text editor is only a tiny, tiny part of that. The rest is libraries full of tested and optimised code that make up a mature dev environment. But _no one_ sits down to write a mobile app, 3D game or desktop app in Notepad with no environment or pre-existing libraries. So why should we do that for web apps?
It would decrease the time spent on waiting for load of separate resources, TTFR etc. And would increase page load time, so whether it's a gain or not friends on how much extra you load, and how fast the page loads compared to the CDN. CDNs add some time for network negotiation, so if you were loading a file that was quite small, it might be faster in the original source code, bit I think generally, not so much.
We are full Scala shop and even we don't use Scala.js. Granted I haven't fully been updated on it, but I can't justify using it especially of UI Devs have to learn Scala just for this.
No, you don't. But then again, it would be a nightmare to drive the dom without. But i doubt that's going to be your problem from here on. You should read up on node in general because there seem to be some misconceptions. Node is a portable environment. You don't upload node to the server. Node contains dev dependencies, build tools, examples, tests, readme's, several distributions for esm, es6, es5, commonjs, etc. The size of it doesn't matter. You need build tools in order to save you lots of manual labour. But if you're scared of that right now, all frameworks can still be driven by script taps, including react: https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html
I'm building application in the same way (Scala and Scala.js and nothing else), and it is on the production ~1year. Everything is fine until now from scalajs perspective (any problems I had was deriviations from upickle library). My stack is: - upickle (circe is recommended now) - scalatags - quicklens I recommend from the beginning, take the time to choose a good RX library. Some UI libraries has its own solutions (scalatags hasn't). There is also nice framework http://udash.io/. It seams to be pretty stable right now. You can check https://github.com/japgolly/scalajs-react also. It needs extra time to lern (especialy if you don't know react yet) but also works.
You're right. I totally forgot to mention that import.meta.url (and await import) are in the pipeline, but not there yet. Updating post... (Thanks!)
It‚Äôs seems every shop has that *one* dude that is too proud to use open source code. They insist on writing everything from scratch. Everyone else‚Äôs code is automatically garbage. 
I've definitely looked for some Vue + typescript examples, i've found Vue surprisingly pleasant to work with(coming from React/React-Native), just needed to add typescript on top :)= 
I heavily use Scala.js in production, shared my experience at Riga Dev Days 2017: https://youtu.be/FJr-fxlpUC8
human short sightedness &amp; arrogance is fascinating
Sometimes.
You can look at my other repo [Moving Mate](https://github.com/victorgarciaesgi/Moving-Mate) for real world application with JWT auth! We just started to make the app so it's juste the header/log in/sign in and it's Symfony in the back-end!
Why I am being downvoted?
You don‚Äôt *have* to. You choose to. And thus you are part of the problem. If everyone refused to support IE8, people would be forced to upgrade.
net ninja has a good vue series on youtube
It is buggy according to the intended behavior, not according to the spec. Some people...
Problem is that its proclaims to be solution for backend developers, but if you don't have any efficient frontend expirience - you won't be able to use it due to a lack of community/documentation. Though if you're proficient with simple ReactJS - it could be a good solution for small projects to keep everything in one place.
I'm not sure I understand the black magic sentiment. They're all their own versions of js. But jumping right in to react might be a bit difficult. Personally I'd suggest trying to do it in js/jQuery to get familiar with basic js first. To learn the problems that frameworks try and solve 
I would start with JS first, then learn why jQuery takes some pain off of vanilla JS, and how it's good or bad in some cases, THEN React. Diving headfirst into React was what I tried to do and it was a big deterrent for me because I didn't understand anything and especially not webpack at the time.
This one was excellent: https://egghead.io/courses/react-fundamentals React is a small pattern around regular javascript, if you know the language there's not much to learn, otherwise your efforts will also make you better at javascript, so go for it. Jquery is on its way down, still heavily used for legacy software but it would be odd starting a new project with it. The frameworks that aren't functional ship their own emulators and syntax extensions, you're leaning their special blend of javascript/html, that knowledge is only applicable to the framework itself and will outdate over time.
There is no right answer for every case. VanillaJS and JQuery are a good combination for starting out and creating basic interactive webpages. As complexity increases however, you may wish to use a framework to simplify the way you reason about your application. Consider if the framework is right for you an a case by case basis. If you find yourself in a situation where you are having to constantly work around the framework, then perhaps that is not the best solution for your app. React and Angular are both popular frameworks which you could benefit from being familiar with.
You're not... Except for this comment. 
The parser doesn't guess. It follows precise rules, which it follows perfectly, every time. 
[removed]
"You were redirected to this page due to an error. Sorry for the Inconvenience." Could be better.
I know this. It's been called that for a few years. I'm not unfamiliar with Scala or the library. I stand by my original statement.
How about: ``` import bulb, { Signal } from 'bulb'; ```
You could substitute Scala for any language and your non-argument would be equally baseless.
This doesn't work, because what you're doing here is importing default export, which is not defined at all in case of `bulb`. If it were possible to do `import * as bulb, { Signal } from 'bulb';` it would work, but it's a syntax error.
Which is weird, because I never actually presented an argument.
Shout out to my favorite front-end framework that could: mithril.js. Looks like they only added about 1.5k stars in 2017. What‚Äôs wrong with you people? Go use it!
Good refresher.
Hmm yeah I guess, or "there's no standardised way to find out what the browser understood of your a11y markup", so I guess it does say it. Still, the point of the article is to highlight the fact that an accessibility object model is coming and explain what it is, so I'd still consider it clickbait (i.e. annoying because it doesn't give you an idea of what the article is about).
They forgot about -0 being falsy
I'm not adept in JS yet but from what I see at the moment the promise structure is a must-know.
Does that fall under design patterns? I think I might as well get it over with. The course keeps bringing angular and nodejs in between while I don't even know what they are or their syntax(angular's syntax looked weird, weirder than javascript's assignment of a function to a variable).
I _think_ it falls under design patterns for JS. I'm only just starting to formalise my JS learning now :p From what I've seen of NodeJS so far it's pretty much JS with a few bells and whistles lopped on (like library management for your project). Others, please correct me if any of the above is incorrect. I'm not yet that strong in JS and I'm always happy to learn :)
So javascript's design patterns are different from the generic design patterns that we learn in other compiled languages?
form validation done
ZZZZzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
"Transpiling is a specific term for taking source code written in one language and transforming into another language that has a similar level of abstraction"
Most design patterns are language agnostic and knowing them makes you a good programmer regardless of the language you're using. So they're definitely worth learning. For Javascript, I'd say that understanding of closures and scope is one of the most important things you can learn. It's what allows you to use the Module Pattern (probably the most profilic Javascript pattern) effectively and knowing how it works will save you from a lot of headaches down the road. 
Learn pure js, then you can pick up polymer,svelte or skatejs - one of web component based solutions if you want to work with DOM model.
This has a few patterns https://addyosmani.com/resources/essentialjsdesignpatterns/book/ This doesn't cover closures or fp though.
A new JS library was produced every 30 minutes in 2017. I wonder what 2018 will give us.
Personally I don't feel that there's a lot to "learn" with Bootstrap. It's an awesome time saving CSS framework but it's pretty much plug and play. You might be interested in learning SCSS. It's basically CSS with a lot of extra functionality, like variables, mixing, and nesting. As far as JS frameworks go, I don't think you can go wrong learning any of the popular ones. There's not really an objective way of telling you which to learn next. I like Angular but I've also used Vue and React and think they're great as well. Maybe you could do some of the beginner tutorials for each one and see if one "calls out" to you.
Definitely, especially with ES6 becoming more and more common. There's still going to be a lot of legacy code out there though, so it's nice to know. 
Interesting example! I never thought about the diff/merge aspect of the semicolon vs no-semicolon debate. Do you think, from your experience, that there are less merge conflicts with your team when using the no-semicolon style? If so, I think this would be a huge point against using semicolons, since it actually has a value (better productivity).
Assuming you mean their mouse, you can set a timer to record x,y coordinates and the change from last tick. But i think you‚Äôll have issues with the mouse leaving the browser window causing the whole thing to stop recording. 
I think that learning a modern framework will be more useful in the long run. You should know how to find and manipulate dom elements, but that shouldn't be too much a hurdle. I believe the way future is more and more treating the browser as a compilation target instead of being married to the specific implementation details of the browsers. A modern workflow can already abstract the javascript being written for development from the one being run in the browser, and there is SASS which can handle many of the vendor prefixes for CSS, and now we have gatsby for react, which handles many of the performance optimization for initial render and lazy loading assets. So that makes js, css, and html all now compilation target assets. It now possible to get a very performant website without ever thinking much about the browser. React is fairly simple, and there isn't very much to learn for the basics. The great thing about it is that is just javascript, and not too much magic that you need to worry about. I think the days of manually manipulating the dom and hand writing the assets actually running in peoples browser are numbered for all but the most simple applications.
Given how 0 === -0 is true, does it matter?
jQuery was created when the DOM API didn't have much flexibility. That's changed and 90% of what you'd use jQuery for can now be done with vanilla JS just as easily. The one place that using jQuery can make your life easier is with making HTTP requests, but now JS has `fetch`. My suggestion? Implement things in vanilla JS first. Then move onto React. Skip jQuery, but do look at implementations of it from applications from a few years ago.
You don't have to make it public. It's pretty easy to check the client address in express (or whatever) and ensure it's private. 
&gt; an infinite loop with a 24-hour sleep at the end The whole "an infinite loop with a 24-hour sleep at the end" really set me cringing.
I think it has some which work well with the passing of functions as parameters in to another function , such as the promise pattern. I'm not the best person to answer this though, I think you're best off studying up.
Don't pre-occupy yourself with the idea of "black magic" too much. When you build your own house? Are you going to also try to make the bricks, glasses, drywall, wiring, and porcelain? Sure, you can smelt ores and make your own copper wires, but the quality of your copper wires are going to be terrible. 
r/LearnJavascript r/LearnProgramming
You'll find [this site](http://youmightnotneedjquery.com/) really useful for translating between how to do a particular task in vanilla JS vs jQuery (in either direction).
I actually meant waving a smartphone around.
To understand how libraries like jQuery, Angular, and React fit in the spectrum of DOM manipulation, I'd definitely learn the basic DOM APIs on their own first. Most APIs are pretty simple. The DOM is a tree of components, and you can create new nodes, add and remove them from the tree, set attributes, query the tree, etc. jQuery was popular for filling in gaps and covering over browsers differences in the DOM APIs, but the DOM is pretty consistent across browsers these days, which to me eliminates the need for jQuery altogether. Pretty soon after you learn how to create some DOM, you'll want to group some operations together into a reusable component, like a menu, search box, navigation drawer, etc. That's where the frameworks come in - they define a component model so that you can write them. Like jQuery, frameworks are popular because of a gap in the DOM - a lack of a user-extensible component model - but that gap is gone now. The web has native components called... Web Components. Personally, rather than learn a proprietary and temporarily popular framework (all frameworks go out of fashion eventually), I'd just learn to write Custom Elements. They're pretty simple: class MyElement extends HTMLElement { constructor() { super(); this.attachShadow({mode: open}).innerHTML = ` &lt;style&gt;:host { color: red }&lt;/style&gt; &lt;h1&gt;Look Ma, no framework!/h1&gt;`; } } It's just vanilla JS, and you don't need a compiler like with React and Angular. You can play with this right in devtools. Web Components are supported in Chrome, Safari and Opera, and Firefox is implementing now (Custom Elements are in Firefox nightly - they're rewriting the whole Firefox UI in Web Components). Other browsers are supported through polyfills. DOM management within a component is still manual though. It's not necessarily that bad, but it can be cumbersome for complex components. Frameworks usually give you some kind of templating system like Angular templates or JSX. Instead of a framework, you can use a library that only solves just the DOM creation and updating part. *Warning, a little self-promotion below:* I made one of these libraries myself called lit-html, which just lets you write HTML templates as JS strings: import {html, render} from 'lit-html'; // This is a lit-html template let sayHello = (name) =&gt; html`&lt;span&gt;Hello ${name}&lt;/span&gt;`; // This renders &lt;span&gt;Hello Angular&lt;/span&gt; to the document render(sayHello('Angular'), document.body); // This efficiently updates the document to &lt;span&gt;Hello React&lt;/span&gt; render(sayHello('React'), document.body); There are other libraries that just tackle the DOM management part too. There is usually a little bit of magic in these libraries in order to get updates to be fast, but one like lit-html are very small and very readable if you wish. (Check lit out here if you want: https://www.npmjs.com/package/lit-html) 
Yes. I need frameworks for my work.
This would be hard to debug blind, also doesn't make a lot of sense because window is global and shouldn't need to be passed in. Try making a code snipper where you boil it down to the exact problem, just a react component shim rendering a div or something which includes knockout/jQuery. You might identify the problem when narrowing the case or at least make it easier for others to help you debug.
I don't blame anyone. I'm not sure where they learn this, maybe from teachers who they never question. I also do coding in languages that require semicolons like C, but if I forget to add a semicolon - the compiler goes derp and wastes some more of my time. I'm really happy that javascript has ASI so I can focus on the logic and not worry about tediously adding a semicolon to every damned thing. If I'm writing JS code in a team, I have to add semicolons because many on the team just can't understand code without semicolons, and the linter enforces it anyway. FML. 
Here's my guess: First, require() assumes that any script you load is a CommonJS module. It looks like knockout-jqueryui.js is not CommonJS or UMD. I think if you had a UMD build, you wouldn't have this problem. Next, since require() doesn't work on the web, you must be using a bundler, and the bundler is going to try to preserve CommonJS behavior. It may be rewriting the reference to window. I'd check the bundler output to see if it's changing `window` to undefined, and if there's a setting to preserve certain globals. You could also look for a UMD build or knockout-jqueryui.js.
Losing
Second this. I would absolutely start with Vanilla. Once you get down the concepts of DOM manipulation, it‚Äôll be easier to understand exactly what React is doing. Especially before jumping into JSX. 
I also support this method. Learning vanilla will help you understand the benefits and pitfalls of jQuery, and both work pretty closely with the DOM, which can then help with learning React. They build nicely on one another.
Another thing that confused the heck out of me when it first happened to me: `typeof {} === 'object '` and `typeof undefined === 'undefined'` but `typeof null === 'object'` which means `if (typeof foo === 'object' &amp;&amp; foo.bar === 'baz')` will throw a TypeError if foo === null.
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout here it says that grid+flexbox go together :D guess I just need to learn Grid from responsiveness part (I think)
Hey /r/JavaScript! I‚Äôm a (newish) developer who loves tinkering. I‚Äôve been diving more into experimenting with how I can create JS applications to create solutions to personal challenges. I‚Äôve been using a RPi 3 primarily as a kodi/retro box but figured I could probably create an environment for testing projects - maybe even my own server so that I may create API routes to access data (for free!). Nonetheless I found some fantastic tutorials (its much easier than I expected) and achieved my goal! Thought you might enjoy this write up I did along the way. 
I try to think of it simply as: undefined means exactly that, we have not bothered to set a value for this thing. null means we explicitly set a value and wanted it to be anomalous. null shows intentionality you cannot infer from undefined. 
I have been working on my compiler for a JavaScript-like syntax for WebAssembly. It's coming along nicely, it's now possible to use it within Webpack/JavaScript via a simple loader. Probably the easiest way to experiment with WebAssembly today! I'm always looking for OSS contributors. If you're at all interested, don't hesitate and reach out. Link https://github.com/ballercat/walt
But do I do DOM manipulation with JS or jQuery then?
More superb and useful IS libraries?
Kinda both! :) jQuery is just a library on-top of JS. In the end, jQuery is doing DOM manipulation through vanilla JS, it‚Äôs just an abstraction through methods. If it was me relearning with what I know now, I would look into how JS can create and manipulate elements within the DOM. Then you learn jQuery which makes it much quicker and leaner (much less typing!) to do those manipulations. I think it‚Äôs important to understand what‚Äôs happening under the hood. If you have any questions I‚Äôm absolutely available to help! 
Agreed. It‚Äôs like learning to build a pc by putting parts together vs what each of the parts do, and why they intersect
It took me the longest time to figure out what the hell that was a picture of 
I didn‚Äôt know that undefined caused the method to take the default params. Neat!
I don't think there's anything necessarily wrong with Scala.js itself I'd _definitely_ be worried that someone is going off to do work on their own for longer than a month without review (even if they are senior). I'd also be worried that they are building an application without a framework. Scala.js isn't a framework, and when you don't use a framework, you end up writing your own (unwittingly).
Yeah, i'm part of the problem for accepting a job at a biotech who has clients that use IE8.... /s It's my job so... I _do_ have to if I intend to keep it. It's childishly naive to think large corporations are going to ditch large swaths of clients in the name of "best practices"
Is it a hobby project or is this at work?
Just to clarify, you do use scala.js in production at work? My company has had the same 1-2 devs do everything in the last 15 years. The dev working on the prototype just learned Scala for this project because we need Apache spark. I'm not sure what led him to scala.js. noone else knows Scala. I have very little say in direction, Im not sure they even know what front end frameworks are. I havem met the dev but I think he's pretty old fashioned and has exclusively worked with c# net. I have no idea how to respectfully approach this 
&gt; Yeah, i'm part of the problem for accepting a job at a biotech who has clients that use IE8.... /s You sure ain‚Äôt part of the solution. &gt; It's my job so... I do have to if I intend to keep it. Right. So don‚Äôt pretend you don‚Äôt have a choice. If you choose to do unethical work, that‚Äôs on you. &gt; It's childishly naive to think large corporations are going to ditch large swaths of clients in the name of "best practices" You seem to have an awful case of black/white thinking here. No one says they had to drop the client, they could just propose a different delivery method if the client isn‚Äôt willing to use a modern browser. And not using IE8 isn‚Äôt just ‚Äúbest practice‚Äù. Anyone who is still using IE8 on the internet is grossly negligent, since they‚Äôre exposing their business to vulnerabilities that have been fixed in supported browsers.
But `(1 / 0) !== (1 / -0)`
So you think its practical/safe to go with just scala.js and no framework? To clarify, our product is going to have lots of UI(visualizations, controls, etc...) , it is something analysts would be using
Vue is fully ES5 compatible and can be delivered via CDN. It gives you an almost Angular-like data binding component syntax, and feels like an evolution of jQuery into something more, I dunno, React-y. I'm not a Vue evangelist, I've barely used it. But it sounds like a really good fit for this situation.
So here's the cookie crumbles, as I mentioned above, a lot of times when I was googling things like "add &lt;li&gt; element to page with js" or whatever, most solutions were just straight up jQuery - it kinda blurs the line for me where jQuery kicks in and what is just regular JS
&gt; we'd be better off to abolish null from usage and use only undefined. Then how could I indicate that I set a value to be a non-value? If I have an algorithm that checks a value, if it is `undefined`, how can I tell if there was a mistake somewhere setting values or if I meant to set `x` to be `undefined` as part of my check?
Oh man the null thing I didn't know about. Which has led to me go read this whole SO question: https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript My eyes are bleeding looking at the diversity and lack of consensus on the basic problem of "is this an object" testing.
You can't declare an Array with fixed length in javascript. But 2d array can be declared as ``` var matrix = [[0, 1], [2, 3]]; ``` BTW, usually it's a bad thing to use the explicit constructors (such as `new Array()` or `new Object`, etc), unless you're specifically know you're need exactly this thing.
Yes I meant 2d array. It‚Äôs just task I need to finish, so the second answer should be correct?
So, I tend to initialize variables to `null` if I know they might get defined in the future but I don't know when.
Thanks for your answer! That is somewhat comforting. Mind if I ask some follow up questions? - Do you think it's still practical to use scala.js if you're not pairing it with any compatible framework? To add some detail, our product will have a pretty complex UI. It's a BI tool. I can't imagine how messy the code would be without a framework. - If you think we absolutely need a framework, could you give me some advice on how to talk to my boss about this? What are some talking points? The lead dev is maybe 50 and has only ever used .net . I don't think they even know what modern frameworks are - How long do you think it would take to be proficient in it? Myself and maybe one other dev are likely going to join the senior dev who built the prototype. Neither of us two know any Scala. But I know js very well. How steep is the learning curve? The lead dev doesn't even work in the office and communication is very slow. - How well does it work with 3rd party dependencies. Say I miraculously convinced them to use scala.js-react, can i still use my beloved npm/yarn packages? Does webpack still work? 
Thanks I'll check this out! Do you use it with any framework?
Yeah it was a required file for vue to work with typescript. Also the npm package "vuelidate" don't have its types one npm!
Hm, you don't need that bind in Vue. Couldn't that also be changed in React itself?
[try this ](https://stackoverflow.com/questions/4378435/how-to-access-accelerometer-gyroscope-data-from-javascript) 
 In both my current and previous job I've been using Scala, but frontend was JavaScript (or typescript). It's probably a fine choice, but most projects will have frontend developers who will prefer a "native" js solution (typescript is almost native js because it's a superset)
Don't forget when a key is undefined vs when a key has a value of undefined.
Thanks for taking a look. Those functions are all available as methods on the `Signal` class. Check out the API docs. The Bulb API additionally provides all combinators as curried functions, purely as a convenience. This allows you write your code in a more functional style, with partial application etc. But you don't have to use them. Your above example could be: ``` import {Signal} from 'bulb'; const a = Signal.periodic(1000).always(true); const b = b.delay(100).always(false); a.merge(b).subscribe(s =&gt; { document.getElementById('results').textContent += s.toString(); }); ```
I've been working on a flow-diagram project for the in React. Currently it's for desktop only as the controls are with mouse and keyboard. Demo: [https://rmfisher.github.io/react-flow-diagrams/](https://rmfisher.github.io/react-flow-diagrams/) List of Keyboard Shortcuts: [https://github.com/rmfisher/react-flow-diagrams/blob/master/README.md#instructions](https://github.com/rmfisher/react-flow-diagrams/blob/master/README.md#instructions) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rmfisher/react-flow-diagrams/.../**README.md#instructions** (master ‚Üí 5ec54d7)](https://github.com/rmfisher/react-flow-diagrams/blob/5ec54d7572ead9390ea9aff64625291a3d163637/README.md#instructions) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsmrljq.)
Would you rather the JS community stagnates?
&gt; typeof null === 'object' That issue was caught early on, but, if I remember correctly, Microsoft insisted on keeping it this way since changing it would break some websites. (Like, 3 or 4, probably.) Here is how that bug happened in the first place: http://2ality.com/2013/10/typeof-null.html
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AVSystem/scala-commons/.../**GenCodec.md** (master ‚Üí b9853b8)](https://github.com/AVSystem/scala-commons/blob/b9853b8b7e72d0a22481d23ce3b5feb58a46f1ff/docs/GenCodec.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsmsd46.)
Once upon I did. Almost a decade ago, and several years before Simpson even coined the term, I wrote [code like this](https://pastebin.com/cVXRDn0j). I liked the simplicity of it. I liked that the only difference between a derived type and an instance was whether you invoked "init" on it. I liked that there was no distinction between instance vs static methods. And I liked the syntax better than the pseudo-classical we had at the time. Though, for performance reasons, I ended up having to switch back to the pseudo-classical style. Browsers were just better optimized for that. Fast forward to today, and the syntax preference isn't a compelling argument anymore either, since ES6 classes provide a much nicer syntax that the pseudo-classical. And finally, over time I eventually recognized that the class/pseudo-class object structure is actually [exactly the same](https://www.reddit.com/r/javascript/comments/65pf19/whats_the_purpose_of_the_constructor_property_in/dgc53ng/) as the OLOO structure, and the only actual difference is which piece of that structure -- which entry point -- we assign to a variable.
Thanks for your answer. Yes, I saw they are available as methods. This is not really that important, but still I prefer the API design of `xstreams`, `bacon`, `most` and others little bit more, because they all hold similar functions (like `Signal.periodic` and `bulb.merge`) in the same single namespace (`xs.periodic` &amp; `xs.merge`, `Bacon.repeatedly` &amp; `Bacon.mergeAll`, `most.periodic` &amp; `most.merge`). Well, there are already a lot of APIs like this so maybe there is actually much more point to make it different like you did - just for the sake of diversity.
work.
Because that's part of the [HTML spec](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#the-htmlallcollection-interface), not JavaScript. It's also both non-standard, and deprecated.
Imports don't allow any destructuring tricks except of just plain names, so this one is syntax error.
Awesome. I‚Äôll check it out!
#/usr/bin/env python #coding=utf8 import httplib import md5 import urllib import random appid = '20151113000005349' secretKey = 'osubCEzlGjzvw8qdQc41' httpClient = None myurl = '/api/trans/vip/translate' q = 'apple' fromLang = 'en' toLang = 'zh' salt = random.randint(32768, 65536) sign = appid+q+str(salt)+secretKey m1 = md5.new() m1.update(sign) sign = m1.hexdigest() myurl = myurl+'?appid='+appid+'&amp;q='+urllib.quote(q)+'&amp;from='+fromLang+'&amp;to='+toLang+'&amp;salt='+str(salt)+'&amp;sign='+sign try: httpClient = httplib.HTTPConnection('api.fanyi.baidu.com') httpClient.request('GET', myurl) #responseÊòØHTTPResponseÂØπË±° response = httpClient.getresponse() print response.read() except Exception, e: print e finally: if httpClient: httpClient.close() 
http://appcdn.fanyi.baidu.com/api/demo/python.zip
Adds a "#" to ''?
Oh shit i get it, every iteration it adds a hashtag to the variable
tada. :D
 function httpRequest(url, callback){ var xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) callback(xmlHttp.responseText); } xmlHttp.open("GET", url, true); // true for asynchronous xmlHttp.send(null); } httpRequest('api.fanyi.baidu.com', function (response) { console.log(response) });
Well there's also the very explicit `Object.is(0, -0) === false`
Thanks for this - for new projects this looks great, but a bit tough to integrate into existing projects. Will keep this in mind for the future.