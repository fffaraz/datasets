Resolving 23345/45020 packages
I don't think you know what empathy really is.
&gt; Don't call things 'user' but call it objUser or strUser or userID or whatever it actually is. I should NOT need intellisense in my IDE to figure out what's going on. This one is a good trick. Thanks for posting :)
Using recursion when you can use a loop is a bad practice.
It's fine :)
I think he wasn't allowed to use .toString(2) specifically as it converts a number to its binary format for you.
Practical Javascript on https://watchandcode.com https://www.theodinproject.com/courses https://www.freecodecamp.org/ https://github.com/P1xt/p1xt-guides/blob/master/job-ready-javascript-edition-2.0.md https://github.com/P1xt/p1xt-guides/blob/master/wd-cs.md https://github.com/getify/You-Dont-Know-JS https://eloquentjavascript.net/Eloquent_JavaScript.pdf https://developer.mozilla.org/en-US/docs/Web/JavaScript https://addyosmani.com/resources/essentialjsdesignpatterns/book/ 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [P1xt/p1xt-guides/.../**wd-cs.md** (master → 94502c3)](https://github.com/P1xt/p1xt-guides/blob/94502c325de7d0c628402dd90a6d327768face5b/wd-cs.md) * [P1xt/p1xt-guides/.../**job-ready-javascript-edition-2.0.md** (master → 94502c3)](https://github.com/P1xt/p1xt-guides/blob/94502c325de7d0c628402dd90a6d327768face5b/job-ready-javascript-edition-2.0.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0pvbfb.)
I spent many years writing AS2 &amp; AS3 and the types always felt like a hacky addition there, too. Also, they used that syntax b/c declaring type was optional. There was a performance gain for using “strict mode” meaning you had to declare type, but if you were ok with a slightly slower app, the language handled dynamic typing just fine. AFAICT, the only reason someone would want to use typescript instead of es2015 is static typing. Why allow dynamic type at all? Inferred type is fine, but it’s still static type at compile time. 
I know recursion is not always the good solution and that's why I gave 2 examples. Personally, I prefer to do it with the while, even if the recursion seems simpler.
&gt;You always, ALWAYS have to know what is the type of a variable that you're using, even in a weakly typed system. The ONLY "benefit" of a weakly typed system in this regard is that you can perform runtime type checks and branch your logic accordingly. &gt; &gt;But if what you truly WANT is to have the same variable contain values of different types at different times, you are asking for trouble and for other people reading your code to be thoroughly confused fairly often. That's a great way to increase WTFs/s. Weakly-typed systems are a non-issue. Your point of always having types in your head is irrelevant since that's just a way of organizing things in your head, not your code. We're talking about whether there's benefit to explicitly mention the structure of these data structures, not that we're organizing our thoughts around them. As for primitive types, which I thought is what you were alluding to in the previous thread, the compiler/interpreter solves it for you. &gt;It's type-safe, self-documenting, AND happens to be a better representation of what is actually happening. That's a pretty small example you have there. I think you'll agree everything looks like a good idea in the small. It's frustrating that when we are talking so abstractly and as such it is harder to come up with examples that showcase exactly what we mean, but we're just gonna have to trust each other that we aren't talking out of our asses. But to actually respond to your example, I think the types are unnecessary. The names of your variables seem to do just fine at documenting everything I need to know. &gt;I know what you mean by this. I'll assume you meant you don't know what I mean by this. I meant that the beautiful people that implement these languages have the choice of using stronger type systems inside the compiler while making the language itself usable at weakly-type level. As long as it is not exposed to the user (aka the developer that uses the language), it's inconsequential. &gt;Again, this is the wrong way to think about it. Don't "try to convince the type checker". It's not a nanny. It's a tool. USE it to your advantage to prevent yourself and your team from making a whole host of non-runtime mistakes, and to express meaning to the rest of your team, which, by the way, includes future you. Haskell users tend to compare the type check akin to a friendly rival that they propose types to and that it fights back until they found a good type representation. They often have to come back in code and "adjust" types so that their programs will work. The drawbacks are accepted since they offer them a lot of safety and benefits. &gt;I would argue that types are slowing you down because you are thinking about them all wrong and need more practice expressing what you want in them. &gt; &gt; &gt; &gt;Your wording here is slightly strange. I never say "experience with type systems" is a "pro of using them". I said if you don't have experience with them, you won't know how to use them correctly. Yeah, bad phrasing on my part. I meant that you mention types are good but people don't see that because they are inexperienced. First of all, that's an assumption you shouldn't make about someone. Second of all, experience with anything will make that thing easier to use. How is that going to convince anyone said thing isn't actually slowing you down? I could make the opposite argument and say you don't have enough experience working with weakly-typed languages. Also, please don't take my comments as being ill-intended. It's just my perspective on things, and there is no reason to heat these arguments up, since neither of us win anything material out of this.
This is so true. My boss pushed me towards TypeScript for my project at work, and for a few months it just sat in the background occasionally getting on my nerves. Then I went on holiday and learned some Rust. By the time I got back I saw it all differently, and as I've utilised TypeScript more I've begun to really understand JavaScript's (fucking weird) type system as well. I refuse to work on a non-typed project now. Strict TypeScript is just so so so nice.
But this would be terrible when it comes to the bundle size delivered to the client 
TypeScript is getting better all the time, so perhaps this used to be an issue, but it doesn't appear to be anymore: http://www.typescriptlang.org/play/#src=class%20Test%20%7B%0A%20%20%20%20myProperty%3A%20string%3B%0A%0A%20%20%20%20constructor()%20%7B%0A%20%20%20%20%20%20%20%20this.myProperty%20%3D%201%3B%0A%20%20%20%20%7D%0A%7D
It was quite popular when React was first launched. Never tried it and haven't heard of it in while so maybe it's not a thing anymore :)
https://github.com/Microsoft/TypeScript/pull/23696 Currently when you have a function with generics, either you let the compiler infer all of the generic types, either you supply them all. (Flow has the * syntax for this) const fn = &lt;A, B&gt;(a: A, b: B) =&gt; something //you either write fn(1,2) //or fn&lt;A = number&gt;(1, 2) Sometimes you actually need to hint the compiler on some of the generic types a function has to receive. If you let him infer all, it may work, but may be a bit... say, fragile -- because he is working with extra assumptions. I had run this sort of issue with react-redux and recompose (mostly HOCs) That pull request may greatly simplify a couple of react typings.
&gt; I don’t have to worry about crap code because I write jsdocs on each function that explicitly state that input should only be a string or a certain object and output is going to return a promise that resolves a number. What if those comments were actually enforceable?
This is probably because you need to inform TypeScript of your environment in `tsconfig.json`. Although, having said that, if you're using TypeScript why are you using CJS and not ES imports?
I could imagine it being the case. The development of state management solutions revolutionized the way we do fontend and made react a valid choice on its own 
Yeah the creation of a true React ecosystem which can provide complex projects on it's own probably killed most usage of this technique.
Does my small TS React project here look familiar? https://github.com/SamHH/bukubrow/tree/master/webextension/src This is similar to the code I write in larger projects at work and it's a hell of a lot cleaner than plain JS, or PropTypes.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [SamHH/bukubrow/.../**src** (master → 1920fdd)](https://github.com/SamHH/bukubrow/tree/1920fdd1aa7eec1e438cd4ea538ecc7da8f69e28/webextension/src) ---- 
If you're resorting to caricaturing those with whom you disagree then you should probably reassess the validity of your argument. I started out on PHP, then moved over to JS with Babel. I've since fallen in love with TypeScript with the help of learning the strongly typed Rust on the side as a hobby. For me, it is _significantly_ more complex to enter a JS codebase with type information because you can't trust any of the code, and nor can you refactor with any real level of confidence that it won't break something else. I get the Microsoft thing. I also feel uncomfortable using React which is developed by Facebook. But the fact of the matter is that these technologies are fantastic, and should an issue ever arise they're open source with an enormous community of enthusiasts behind them. So I'm not really worried about that. If you have any questions specific to TypeScript then please do feel free to ask.
If that enforcement requires deviating from standard syntax, lacks support from third-party libraries, adds a build process that may not be necessary (in my case: nodejs doesn't require babel), and occasionally needs you to spend an hour googling for some weird edge case tooling configuration issues - is it really worth it?
But the 3rd party libs you use may have. For example, the 2nd parameter of mapDispatchToProps receives a Dispatch&lt;any&gt;
I think we're starting to understand each other a bit more. I have to run but I'll type up a response a bit later. Have a nice day.
Ah, that makes more sense! I would've interpreted it more literally, or less literally? Either way, probably incorrectly.
Thanks for the example about learning Rust, which improved your understanding of types in general. That's what I was trying to get at.
&gt;If in any callback you're writing you specify a string that doesn't exist as a field name on the table typescript will red underline the string. that's pretty impressive
Try writing a `postinstall` script in `package.json` and do all the manual work in there.
Eloquent JavaScript is a free textbook with really good exercises. If you are brand new to coding, it will take several times read-through. It is pretty dense and not the most beginner friendly (although it was designed for beginners) But i learned a lot of great stuff there. Also the site javascriptissexy.org explains the tough subjects well. Once you get a foundation, you should also do a toy problem/algorithms site like coding wars, hacker rank, leetcode, codingame 
Strong/weak typing: Whether variables and values can be interpreted as having different types in different contexts: const n = 1; const x = 2 + n; // n is a number const y = "hi" + n; // n is a string Static/dynamic typing: Whether types are set in stone at compile time or can change at run time. let x = "hi"; x = 1; // Static typing prevents this because x is a string // (with or without annotation) Explicit/inferred type: Whether the programmer must annotate the type or the compiler can figure it out from context. const y = 1; // y is inferred to be a number const x: string = 2; // Error: x is explicitly a string 
Hi /u/helpmeJavascript, For javascript help, please visit /r/LearnJavascript. Thank you!
&gt; Seriously? Yes. Dynamic typing is outright better imo. Even if you are firmly planted in the cult of type, which seem to be the majority here, please consider it is possible that some of us disagree. https://vimeo.com/74354480
Hi /u/Solnick911, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/thilehoffer, please refrain from personal attacks. Thanks.
&gt; If you think you have no bugs that could easily be avoided with typescript, you are delusional. I absolutely do, because I have strong unit test coverage which finds all those same problems and more, without the overhead of adding types. I feel like types are a mental crutch that people use to excuse a lack of good unit testing. They end up still having bugs, so it really has no value to go typifying code, ime. 
This is how we end up reinventing the wheel in Javascript every the years. 
React, redux and typescript. Redux dev tools are enabled in the production release The sources dev tools show some .tsx sourcemaps (empty, tough)
That guy just said my codebase was likely a pile of shit with no information about our projects. Normally, I am very nice and helpful on programming subReddits. I don’t know what the deal is but r/JavaScript is much more toxic than r/dotnet. 
The creator of lodash works on the Chakra team, which is surprisingly actually faster than V8. He is obsessed with speed and performance. I can't answer the question directly, but I just wanted to throw that out there. Everything in lodash is built for speed (depending on what it's used for).
If you can write untyped code without falling prey to the classes of errors usually avoided by using types, then you should publish a book because people would pay good money to be able to do that as consistently as a compiler could without the overhead, both cognitive and build-time.
If you don't write type parameters in code then you'll need to do it in comments for your own and for your coworkers sanity. But there's no guarantee those comments will be kept up to date with your code. Types solve both problems at once with less work. Typescript deals with union types and flow-based analysis quite well actually. I wish Typescript or Javascript had a library like Newtonsoft's JSON parser for C# which guarantees that the JSON is of the format I expect: var user = JSONConvert.DeserializeObject&lt;User&gt;(json); In fact I do use a typescript library called io-ts which does something similar but requires some additional boilerplate to get those run-time type checks.
In my experience, entirely.
Yeah, but it's just some random internet person throwing shade at your project -- not you specifically. It wasn't the nicest thing to say, and they could have worded it better, but you need to be able to keep your cool and not stoop to their level (or lower, as you did). &gt; I don’t know what the deal is but r/JavaScript is much more toxic than r/dotnet. Us being 10x's bigger is likely a large part of that.
I think you've missed the point of what he said about devs who "cheat" typing. We see this throughout development. Force developers to write unit tests and you see a bunch of expect(true).toEqual(true). Force them to use linting and you find a bunch of /* eslint-disable */ in your files. You see it on PropTypes in react where people just put .any on everything. That kind of mentality is all over the place, especially in large development shops with lots of contractors and tight deadlines. I'm not saying don't use the tools, but be aware that they're not a panacea. Dogma isn't helpful. All these tools become less valuable when you don't have a culture that promotes them in the right way. You also have to identify where the boundaries are and which boundaries might be softer than others. 
&gt; That being said it is definitely a tradeoff, probably not worth it for the majority of projects. I agree. IME the cost of typing never pays for itself. The biggest loss in in the much more concrete and less general code produced, which is less reusable and requires more effort to apply. The gain is always lost in the noise, since everything that can be caught by typing is either caught by linting or unit tests anyway. The only real gain I see for typing is some auto-completion help in IDE's... 
Amazing literally the first video i clicked on is the solution to this exact task! https://uw.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=e5777098-9253-40bc-b8ad-a8ae0146e564
maybe not
Great article. I've read about online caching before but it didnt totally click. This article made it very understandable. 
Seemed like a valid post to me. Rappid is indeed a paid product, but the link was more about the article itself. Cheers :)
You are right. I overreacted. Sorry.
&gt; something wrong with the practices of this developer I would guess that it was not a single person that decided this was a good idea, but rather a collection of different people or teams trying to design solutions to problems within the constraints they were working with at the time over the course of the life of that body of software. By attributing the blame to a single, imaginary bad developer we lose sight of the idea that the systems we work on are large and span multiple process boundaries (data in js in memory -&gt; serialized to a format for the network -&gt; serialized to disk in a database -&gt; read from another system on another computer, etc). Of course everyone wants their code to be clean, to have single well scoped behaviors like a function that always accepts or returns data of one type, but we sometimes have to come up with solutions that more closely model the reality of the problem we're dealing with than the problem we want to solve. If we blame the person that committed the code, we'll never be able to untangle the tech debt that's already bogging down a system. Sometimes I was the bad developer that wrote the bug (actually, I always am). But I'm also the developer who finds the bug later. If you fire me for writing bugs, your software will always be broken.
I've read the guidlines, and do not understand the reason. :/
A lot of people see unit tests as a crutch for not having static typing. The most common argument against TDD seems to be that it makes code hard to redesign. So if you have enough tests to catch *every bug* as you claim, the code must be super rigid? 
There is no workaround but you will learn to cope with it. 
Types used sparingly are good. I actually like TypeScript quite a bit since as I already mentioned, it does not force you to use types when you don't want to. So it's a sort of gradual typing, which to me is the best of both worlds. But when you have to cram everything into the type system, you can hit trouble.
Thank you... similar posts in the thread getting buried under unthinking hate here. Its fine if you like static types people, but there are no shortages of languages for it. There are very few good dynamic languages and javascript is at the top of the heap. As someone who has come from a static type background and changed over to dynamic types I find: Upsides of dynamic types: * I almost never have to "refactor" anymore. Without depending on the types, multiplicities, and guts of other code, each module is independent and can be replaced as a whole if needed * Increased modularity makes writing units tests easier and faster * Easier to reuse code since everything tends to be a generic * Fewer lines and bytes needed to express logic, faster development cycles * between linting and unit test coverage, I dont miss any bugs that type analysis would catch Downsides of dynamic types: * IDE not as good at auto-completion. 
One criticism my coworker has of Reason is that it doesn't have async/await yet (well it kinda can, but [you need to jump through some hoops](https://jaredforsyth.com/posts/building-async-await-in-reason/))
Hey, I'm starting to write this tutorials, let me know what you think. Is it easy to follow? Is it too verbose? Does it need better explanations? etc. Thanks!
Can't we just let some things be magic!?!!?* *Actually this looks kinda neat.
It gets even more comical in the Java world: Typescript (typed) -&gt; Javascript (Nashorn, untyped) -&gt; JVM bytecode (typed) -&gt; ASM (untyped) 
\&gt; You still can't provide good arguments to support your claim It's not "a claim" it's conventional wisdom within the programming domain. If you want to claim that conventional wisdom is wrong then go ahead and make your case, but stop pestering this dude and acting like he said something no one's ever said before.
I wrote an article about it: [https://medium.com/@CalinLeafshade/why-i-chose-react-over-vue-3dd9a230b507](https://medium.com/@CalinLeafshade/why-i-chose-react-over-vue-3dd9a230b507) But fundamentally it's about the relationship to javascript. Vue takes a more tailored approach by providing a templating system with a load of directives. This can look neater and has some advantages but React chooses to leverage the tools already present in javascript. React also favours immutability whereas Vue favours reactive mutable components.
Well yea. But thought its worth digging into the source of the library that you are using. Not only for understanding the *magic*, but to learn the magic as well :)
&gt; So if you have enough tests to catch every bug as you claim, the code must be super rigid? Yes, but the inter-dependencies are typically limited to one module, so changing one module is usually little more than rewriting it and its tests. You dont need a compiler playing hide and seek across a whole codebase. &gt; The most common argument against TDD seems to be that it makes code hard to redesign I like to rapid prototype first to save time. I can go over an iteration or two without wasting any effort on validation tests. ? Once Ive settle on a reasonable implementation, at that point i add the tests. Pure TDD is wasteful i feel because you are trying to over specify before you fully understand a problem. 
I do a fair amount of Java and Typescript and I must say, if you are constantly using explicit casting, my instinct is that you are doing something wrong. I honestly can't remember the last time i had to do that.
I can't say I share that experience. I usually find a good solution to anything *somewhere*. And in my case it was something I'd expect to be a common problem (my particular case involved importing classes)
Also, a lot of people developing complex javascript apps are using those build tools already. There's not much overhead to switch from a Babel loader to a TS loader?
Yes, but a "binary number" is different from "string of decimal digits, each encoded in binary".
&gt; I would guess that it was not a single person that decided this was a good idea, but rather a collection of different people or teams trying to design solutions to problems within the constraints they were working with at the time over the course of the life of that body of software. I haven't read much further because as you said: you guess.
I'm not really debating that. I think it's more a cultural issue, identifying the pain-points of a tool, and promoting best practices than it is specifically a tooling problem inherently. For example - I know of a shop that is fixated on tooling. They're constantly looking at what better tools are out there. However, no matter what tools they provide their developers they are still producing sub-standard code. They fail to see that the tooling is not the challenge, the level of developer they are hiring and the culture of "get it done now" versus "get it done right" is killing them. 
I loved his Node course. If this is as good, it's a steal for $10.
I would argue that the reason React took off was because it was made by Facebook and promoted heavily in SF Bay area conferences/meetups, not because of technical merits. One problem that React beginners often run into is that they get confused with JSX/ES6 syntax. Mithril, for example, is even more JS centric (it's idiomatic to *not* use JSX and it's not opinionated at all about even ES6), but it's nowhere near as popular. WRT templating vs JSX, when you say "overhead and complexity", you're really just using overloaded terms to describe abstractions. The reason Vue and Meteor could completely rewrite their rendering engine algorithms with minimal user space breakage was precisely thanks to being designed using the template abstraction. More recently, Svelte and Angular Ivy are taking advantage of that same form of abstraction to produce extremely optimized bundles, which I don't foresee happening in React (maybe ever) due to the sheer complexity of the JS spec that permeates a render method. Also, one can argue that because of the choice of using templates, Vue has some very powerful facilities that React simply doesn't (e.g. `v-on:click.capture`) Another thing: React API surface is not small at all. Synthetic events is part of the surface area, and so is every HTML/SVG property under the sun, on a case-by-case basis. This is in contrast to most other systems that have pass-through semantics for HTML attributes (and the reason why a few weeks ago the Svelte author was taking a jab at React touting "pointer event support", when the fact that it wasn't supported at all before was an artificial by-design limitation not shared by competing frameworks).
The server is off-site and I'm able to connect using the MongoDB Compass UI application. My main goal is to alter some server data using JavaScript. I'm following the instructions to initiate a connection [here](http://mongodb.github.io/node-mongodb-native/2.2/tutorials/connect/) and installation under Quick Start [here](https://www.npmjs.com/package/mongodb). I can't seem to connect
I misread this as in scratch. I would have been even more impressed
We are probably using it differently :) I can do everything on VSC that I did on WS
It's a commercial product.
Nice, any chance you can do one for Koa?
You are reviving an ancient and unresolvable debate about untitled vs. typed languages. Might I suggest you take on something more doable, like trying to bring peace to the Middle East?
Jup you're missing where a random dev knows what sort of variable it is and which properties it has without digging through all your code and remembering it perfectly.
Or even when you yourself visit that project 6 months later
&gt; poor communication This is the general issue, but this is the reality. Your manager comes to you and says: "There is a project that was started last year by a developer that is no longer with us. There were higher priority issues back then so he had to stop working on it. I have no idea how far along it is, but it IS a priority now, and we need to know if it can be done in 3 weeks."
It depends on what kind of front-end role you are aiming for. If you want to do design integrations, I doubt you will ever need to understand RxJS. Although, if you want to be a front-end dev on a large-scale project that handles a lot of logic client-side then it might be good for you to know these patterns. Now, to me, RxJS is something you should consider learning only if your basic web dev skills are on point, it's quite advanced stuff. I would start by focusing on HTML, basic CSS, and a lot of JS at first; the ecosystem changes fast, and these building blocks are the only constant. Here's a neat article that reflects my thoughts well: https://snipcart.com/blog/learn-vanilla-javascript-before-using-js-frameworks I hope it helps. :) 
The Bjarne Stroustrup quote comes to mind: &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses You aren't going to find any clear, readable, simple, maintainable, "perfect" codebases out there, because they don't exist beyond small toy examples. Instead I'd spend your time just looking for codebases that are *similar* to yours. If you are making a massive app, maybe look at VSCodes's codebase and see how they do things. Look for github repos written in typescript with a shitload of stars. Compare how a massive codebase looks/acts vs a smaller single-purpose codebase. Programming is all about managing complexity. In order to see what is working and what isn't, you need to look at where it breaks down. A "perfect" example will tell you what to do, but a messy, ugly, hard to understand, difficult to change old codebase will tell you a thousand things that you shouldn't do, while also showing tradeoffs that had to be made. At the end of the day, the product is going to come first. You can write the most elegant, readable, well commented code out there, but then the second a client or your boss changes the scope or requirements, you end up having to work with what you have. Big older codebases will show you how they made those tradeoffs, and you can decide for yourself if their architecture or documentation or anything else contributed to it or not.
exactly. superior master framework.
No?
You should really have a look at using npm, it will make distributing your project much easier. Have a look at this tutorial... https://css-tricks.com/gulp-for-beginners/#article-header-id-3 To avoid committing your node modules to git, you'll need a .gitignore file
It definitely does, thanks :)
Great stuff. 
Just want to note here that you can produce a apps using Rollup. It’s use case is not only libraries and categorizing it as such pushes into a box it doesn’t belong in. Rollup.js a very powerful tool and while Webpack reins supreme due to the masses and sheep, the Rollup community has produced a number of very useful plugins that enable developers to produce apps just as sufficiently as they do with Webpack. Point is, you categorize Rollup.js as being for only libraries and you couldn’t be more wrong. 
This is a cool idea!
I'm going into front-end with the intent of becoming a full-stack node (and maybe Go) dev. I don't plan on focusing on design, though I do want to create PWA apps for non-profits at no cost. So design might play a role in my future.
This started off as a project for my data visualization class, but it turned out really cool so I want to share it with everybody. This is an interactive visualization of over 26,000 English dreams, collected by the psychology department of UC Santa Cruz. The original data can be found [here](http://www.dreambank.net) - note that DreamBank is a completed project and they do not take in any more dream series. The visualization is made with d3.js, the necessary data transformations are done in python, using some modern machine learning techniques - most notably sentence vectors, T-SNE, Autoencoders, and sentiment analysis. A full write-up of the techniques used can be found [here](http://josauder.github.io/dreambank_visualized/dreambank_visualized_technical_report.pdf), and the code (which is very messy, please don't judge me) can be found [here](http://github.com/josauder/dreambank_visualized). I hope you like it! Feel free to follow me on [Twitter](http://twitter.com/josauder), I am rather new but there is more content to come!
Hey, thanks for the comment! I actually say something like that in there, quoting my quote (LOL): &gt;Some time ago the idea used to be [this one](https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c): &gt; &gt;**Use Webpack for apps, and Rollup for libraries** &gt; &gt;But time has passed since then and Rollup has gotten a lot of plugins and improvements. **You can use it NOW for JavaScript libraries and also for most applications that could use a bundler.** Maybe that just confuses people? I want to help remove that idea from the masses, that Rollup is just for Libraries, main articles found when you Google it show that opinion.
Let's not and say we did?
Interesting. I'd like to get into writing tests extensively. So far I'm only using them in a couple of libraries that are used by all the products at my company.
Sorry I don't get that. 
&gt; I mean how hard it is to plan ahead the specification of what your variables should be even if you have a large team Just try it and you'll quickly realize it's not as easy as you think to get to 100% type coverage. It's hard enough that just about every major piece of software that you've ever heard of has either moved away from dynamic languages to static ones or stayed on static languages from the beginning. In my company (uber), it was from Python to Java/Go. In my brother's (duolingo) it was from Python to Scala, in Facebook, it was from PHP to Hack, Google just used Java from the beginning. Typescript, Flow, Elm, Reason koolaids. I could go on. If you don't see the point of types, you probably just haven't gotten to the point of complexity where you don't understand the entirety of the codebase (which is generally the default mode of operation for a sufficiently large codebase)
Ah! Apologies for this. I just re-read it and it was well composed and written on a second glance. I skimmed across your article initially and read the bold text “Use Webpack for apps, and Rollup for Libraries” and this deterred me immediately, so much so that I stopped reading and made my above comment. Maybe try rework that element or drop the bold text. 
Will do! thanks for the input, very useful :) Funny how I wanted one thing and resulted in the other lol
This was way more on me my bro. I didn’t read it properly. Really nice read second time around though. :)
Not intuitive to get started, but pretty cool.
Do you really need a book? TDD and a functional approach will cover your ass really well.
Ha. I remember a conversation I had with a teacher after having used Express for a few projects. Something like: Me: I don't get what this IS. Like, I get how to use it and how it simplifies stuff, but I have no idea what it's doing or why it's doing it. What's the magic I'm not getting? Him: Yeah, I mean, that's basically it.
So I tend to agree with you. I've used Flow and TS before and found that it doesn't catch that much for my needs. That said, I think the vast majority of programmers for the vast majority of applications do run into these problems, and there's a certain risk vs. reward here. That is to say, while using TDD and a functional approach works in almost all cases for me, the risk that it may one day fail catastrophically in production might make using types the entire time worth it. Plus, there are just a lot of programmers who either don't understand or don't care to understand either of those concepts and want the language to hold their hand, and I think that's valid. It's a little bit like saying "No one needs Rust because RAII in C++ will eliminate almost every kind of memory issue", but there are other benefits and it's not always possible or practical to use RAII 100% of the time.
Well thanks :) 
I used to dislike this as well, but I've come to like it. Reasons: 1.) Functional languages generally use this syntax - it reads like a typed lambda statement. f -&gt; (x:type, y:type2) : type3 2.) Removing the types to have an untyped function is a lot easier. f -&gt; (x, y) 3.) Variable declarations can be typed or untyped without changing the syntax or introducing a specific keyword ("var", or "dynamic", or "auto", etc). I started out a long time ago with C++ and I currently work with Javascript, Typescript, and C#. I'm used to the C-style syntax and I do like it, but the functional lambda-style syntax has grown on me quite a bit. I think I've come to like that the type definition is divorced from the declaration statement.
I think would be much better to use modern es. Not everything but maybe var app = exports = module.exports = {}; it's not the best especially for educational purposes.
Yeah, its a good point. Will make those changes.
Don't use socket.io for authentication. Use another endpoint, send the JWT to the front end, and redirect to the part of the front end that uses the sockets.
It's more that Typescript thinks it's smarter than me. This happens for a lot of things. For instance, let's say you have this: &lt;canvas id="mycanvas"&gt;&lt;/canvas&gt; I can do `document.querySelector('canvas').getContext('2d')` with no problem. But `document.querySelector('#mycanvas').getContext('2d')` throws an error, stating getContext is not a valid property. And I'm not using CJS; I'm using Electron. I'm pulling in my app via a modal, so the window itself has require, because it's through Electron. It allows me to pull in Electron's features into my web app.
&gt; ...because number bases/systems aren't a CS concept but a part of basic to intermediate arithmetic? I've asked two other non-CS students whether they learned base conversion. Their answer was no, they're from a different state than me (WA). &gt; Like I've said elsewhere, it's pretty much counting. We aren't disagreeing on that. We're disagreeing on whether your everyday person actually 1) learns base conversion in school 2) should learn base conversion in school. Anyway, this is a pointless argument - you keep arguing tangents which, while true, aren't relevant to the discussion. You apparently really really want to assume people learned base conversion in school and that would be prioritized over math that's actually useful to 99.9% of students outside of CS toy problems. If you really want to argue, go argue with Common Core: http://www.corestandards.org/Math/Content/NBT/ because that's the minimum standard for education in the US - and there's nothing about ensuring students can do math in base-3 because that's a useless skill for 99.99% of the population.
The reason for this, as I understand it, is that TypeScript can't know for sure what element will be returned when you query the DOM for a class or ID, whereas of course if you query directly for an element type as well then it can be confident in its type safety. Your options are either to type-guard it or to assert the type. Or, and I haven't tried this before, just change the query to `canvas#mycanvas`.
1. Make a register endpoint that doesn't require auth. 2. Make a login endpoint that takes credentials and returns a JWT in response body. 3. For other endpoints, check JWT in auth middleware.
&gt;Your point of always having types in your head is irrelevant since that's just a way of organizing things in your head What I mean is, any time you access a variable you do have to know the type of that variable to know how you can use it. &gt;We're talking about whether there's benefit to explicitly mention the structure of these data structures, not that we're organizing our thoughts around them. Every data structure is explicit. They all have a structure in memory that was explicitly defined in your code, whether you declared a type or simply constructed it out of random objects and arrays. Declaring types makes it trivial for anyone reading that code to know exactly what every variable contains *at a glance*, something that cannot be said for languages like JavaScript. &gt;That's a pretty small example you have there. I think you'll agree everything looks like a good idea in the small. Absolutely. It's not a representative example of everything. But I don't agree that "everything looks like a good idea in the small". &gt;It's frustrating that we are talking so abstractly and as such it is harder to come up with examples that showcase exactly what we mean, but we're just gonna have to trust each other that we aren't talking out of our asses. Indeed. &gt;But to actually respond to your example, I think the types are unnecessary. The names of your variables seem to do just fine at documenting everything I need to know. In a small function, I would say it's not as important to be explicit about your types. But in library or framework-level code, I think it is. &gt;I'll assume you meant you don't know what I mean by this. You assume correctly. &gt;Haskell users tend to compare the type check akin to a friendly rival that they propose types to and that it fights back until they found a good type representation. They often have to come back in code and "adjust" types so that their programs will work. The drawbacks are accepted since they offer them a lot of safety and benefits. I can't really speak about Haskell because I don't know it. I'll just qualify all of my points by saying they are within the context of widely-adopted OOP languages like Java, C++ and JavaScript. &gt;Yeah, bad phrasing on my part. I meant that you mention types are good but people don't see that because they are inexperienced. First of all, that's an assumption you shouldn't make about someone. Second of all, experience with anything will make that thing easier to use. How is that going to convince anyone said thing isn't actually slowing you down? I could make the opposite argument and say you don't have enough experience working with weakly-typed languages. Point taken. Appealing to authority is a bad argument and I usually know better. &gt;EDIT: Just saw the OOP thing I didn't answer to. My point was people got enamoured with the corporate-version of OOP (not the Alan Kay's original proposition) and then realised the types they conjured up are not so true to life. I see.
S/he is saying they would rather not build express from scratch and just pretend like they did. It’s a bad joke. 
 v = v.replace(/(?:poop)/g, "poopity scoop"); v = v.replace(/(?:scoop)/g, "scoopity poop"); v = v.replace(/(?:oop)/g, "oopity poop");
https://github.com/jfromaniello/passport.socketio
Yes, I'm aware of why it happens and how to get around it, but like I said, it should not be a full-on compiler error. It should be a warning only. The fact that Typescript assumes it's smarter than me is annoying. Again, I like Typescript, but this one thing just really pisses me off. I know what I'm doing, Typescript. I appreciate your help. What I don't appreciate is you stopping me from doing my job for literally no reason.
It's incredibly common, though, and often less a result of "this was intentional" and more "this made sense at the time". Code debt is a real thing for any real project with changing requirements and many developers.
The compiler isn't sentient, it has to either be always safe or never safe. It chooses the former and enforces that you actively inform it of when you know better; this is why type assertion exists, and it's not something you need to utilise all that much in my experience. The alternative as I said would effectively be no guaranteed type safety. That would be much worse to me as a developer, personally.
I just read your message, I already got my package.json set up so I'm glad you reaffirmed I was on the right track. The tricky part is working with the submodule. 
Plenty of mocking frameworks with TS support. I thoroughly enjoyed using TestDouble two years ago, not sure where landscape is now.
Why not both!?
In my last JS company we had the policy of annotating return type anyway. We had a fairly legacy codebase where tiny changes could unintelligibly propagate type changes across the codebase.
Having had my fair share with strange TypeScript errors over the years I came to the realization that when TypeScript speaks, you listen. Even if I'm immediately inclined to say no way, there must be something wrong with TypeScript, I give it the benefit of the doubt as it always turned out that TypeScript was actually right.
For newbies in js do you mind explaining what is express? other than a library...
&gt;fairly new to java I assume you mean Javascript (very different languages) since you're building a Chrome Extension. \--- Based on the code in your comment, you're doing the same thing 3 times! Imagine the text on the page was "tie a loop." The first line wouldn't do anything, and neither would the second, but the third would transform it into "tie a loopity poop." This is good. But what if your string contains "poop" already? 1. original: "take a poop" 2. after line 1: "take a poopity scoop" 3. after line 2: "take a poopity scoopity poop" 4. after line 3: "take a poopity poopity scoopity poopity poopity poop" What this tells us is that lines 1 and 2 are unnecessary - line 3 alone would produce the desired output.
Interesting. I’m coming the other direction. Started with Actionscript (which used the same style as ts) then vanilla js for a long time, and now more C# and Java. Maybe it’s a case of liking what you’re using, but the languages feel so similar in other ways that it feels like a miss to me. When I use lambdas the return type is pretty much always inferred. 
Yeah, so it turns out the optimisation is a minor one that occurs with global variables but it means V8 can give it a once over, see a non-object primitive `const` and leaves itself a note that it can skip over that on the next pass since it cannot change. It's getting close to the realm of micro-optimisations, but you weren't wrong.
What you posted works fine for me. Your real error must be elsewhere.
No sufficiently complex codebase fits the latter criteria. Hello world will, though. Perhaps do quick 1h dives into a few open source projects to get a sense of taste. But you'll find nothing solving a sufficiently complex problem is, well, simple, especially if optimizing around conflicting criteria like performance.
Well put. I came to JavaScript because I wanted to do away with the static typing of C#. It was a lot extra ceremony that I didn't need. I think it's wrong to add an extension for static typing on top of JavaScript just for the sake of tooling (because last time I checked TypeScript doesn't enforce types at run-time). If one is looking to TypeScript for the sake of creating sound and reasonable code then I believe they would be better served by a language like Elm, PureScript, or ReasonML.
React and Redux are often considered two of the most readable popular codebases. jQuery historically has been considered a well-written library, though the style and feature-set is probably pretty outdated. lodash is a nice spiritual successor in this regard, but I think it's kind of hard to get into because a lot of its source is heavily reliant on common utilities which are quite abstract. I rather like the source code of [Objection](https://github.com/Vincit/objection.js). Any popular boilerplate is going to use mostly best practices and will show you how to structure end applications (websites and such) without being too opinionated. But all of this is largely subjective, so YMMV.
I think you instantiated the class and invoking the static method. like new FBConfigsListener().getInstance(). That throws error. You have to invoke as: FBConfigsListener.getInstance(). Hope that helps.
Came up with a method eschewing even modulus. It's wordy and long, but it gets the job done. `function DecimalToBinary(num) {` `var binArray = [];` `var FinalBin = "";` `var compBit = 1;` `while (compBit &lt;= num) {` `binArray.push(compBit);` `compBit *= 2;` `}` `compBit = 0;` `while (binArray.length &gt; 0) {` `var bit = binArray.pop();` `if (bit &lt;= num) {` `num -= bit;` `FinalBin += "1";` `} else {` `FinalBin += "0";` `}` `}` `return FinalBin;` `}`
You can get a job using React.
What are you looking for is called [nominal types](https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html), e.g.: type RecordID = string &amp; { _recordIDBrand: never }; toShardRecordID("foo"); // error toShardRecordID("foo" as RecordID); // OK 
[https://github.com/despo/gorillas/blob/master/docs/gorillas.bas](https://github.com/despo/gorillas/blob/master/docs/gorillas.bas)
Was the number larger than 32 bits? If so, that might be the case. Even the built in .toString(2) can only be precise up to 32 bit.
Oh that feels kinda dirty but I see whats going on. the _recordIDBrand: never - is just thrown out, it's not referenced anywhere else.. correct? In your opinion, Is it overly pedantic to declare these? It's just extremely formal to me, and makes a lot of sense to do so. In some fairly particular use cases. In this case I would have been justified - What I was doing was refactoring some API code to handle technical debt, so I was using a big hammer - enforcing types - and noticed some variable reuse of the string id due to naming, so I wanted to wipe the slate of the variable reuse issues. (No bugs related to it, but ... ffs WHY!) 
Larger than 16. Not sure what went wrong 
your call method has side effects, even after you tried to remove its side effects. Adding a key to an object is a side effect, if for example the called function iterates over the keys of 'this' it would get a different result with your implementation than the native implementation.
From your link: const createFoo = (value: string): FooId =&gt; ({ type: 'foo', value }); This reminds me of a thing I did back in the PHP days, trying to enforce parsed type safety on a small team of juniors. I'd created a few functions to do safe parsing of a value from the post/get that returned something like this. array( parsed =&gt; 'pass', value =&gt; parsed ); The service layer I was responsible for would reject if any value passed to it was not safe. It was annoying to work with at times, but so were the bug reports from security validations. :/
It's almost as if I've mentioned twice now in this thread that I'm *not from the US* and where I'm from number bases (including conversion) are part of the high school curriculum, but noticing that would require you to have that vaunted reading comprehension now wouldn't it? Also lmao at thinking the Common Core is some sort of gold standard for global pre-tertiary education
&gt; function decToBin(input) { let binStr = ""; while(input &gt; 2) { binStr = (input % 2 ?"1":"0") + binStr; input = Math.floor(input / 2); } return (input % 2 ?"1":"0") + binStr; } Seems to work for me for any number. Negatives, now, might be a problem. For all of the solutions here, actually.Not sure what went wrong, but I don't think it's your code. Testing it against the system .toString method comes up with the same results.
Straw-man
Where's the strawman or did your reading comprehension not point out to you that I had been talking about _my_ experience in school all this while?
What about the first paragraph do you disagree with? 
I was thinking on this topic and it occurred to me... are there things you're unable to do in TS due to the need for types? An example that came to mind was variadic functions with parameters of multiple types, but further reading indicates that one's not impossible to achieve. I guess my question is... are you ever writing TS and think to yourself "man... this would be so easy in JS" - does it ever cause a road block you wouldn't otherwise experience if you were dealing with JS? Sorry to be so inquisitive - I'm heavily considering moving over.
You should try using a jsconfig with vscode. ITV uses vanilla js only, but runs it though typescript your checker to find the most obvious mistakes. That's the lowest common denominator and no friction. 
Found it. It's only triggered if you have a number ending in an even number. Otherwise it works fine. I suspect it's the input/2 with the floor function doing it.
&gt;What I mean is, any time you access a variable you do have to know the type of that variable to know how you can use it. &gt; &gt;Every data structure is explicit. They all have a structure in memory that was explicitly defined in your code, whether you declared a type or simply constructed it out of random objects and arrays. Declaring types makes it trivial for anyone reading that code to know exactly what every variable contains *at a glance*, something that cannot be said for languages like JavaScript. You don't have to know the whole type of your parameters in weakly-typed languages. You just need to establish an interface. If I'm adding 2 variables in my function, I don't care if they are of a certain type or not, just that they can add. Nothing more. And so, I verify just for that. It's as if I'm defining interfaces for each parameter of the function, but *implicitly* and with *arbitrary precision* (for example, I can specify arbitrary conditions on nested properties of the said parameter; imagine translating that in a type system while still trying to keep the type as generic as possible). Now you could argue that these weak-types are still types, and well, they are. But they are far removed from what most would call a type system, especially when compared to the languages you just listed. That's why I avoid saying the word "type" and just say "data structures", since the type checking is done by the programmer and only if he wants it. &gt;In a small function, I would say it's not as important to be explicit about your types. But in library or framework-level code, I think it is. True, types become some sort of guards / tests that the user of the library can be sure are passed. But this does mean that the API of the library is limited to the expression power of the language (which is what I meant by types making code "brittle"). This is why many libraries tend to break the type system via metaprogramming when trying to get more non-standard APIs. Now, to explain my position a bit better: Type systems were created as restrictions on the language. The goal is to avoid invalid programs by making them not compile. Those invalid programs include the programs we would consider to have bugs (wherein lies the safety granted by the type system). But the expressiveness of type systems is limited, and you have to conform to the rules in order to gain the benefits. It's just inherently slower, by definition, to code up. You annotate variables, you define entire type hierarchies and only after, you gain the benefits of having done that. And if by lack of luck you end at the expressiveness frontier of the type system you use, you just can't code your design, so you'll have to change it. The languages you listed are really just System F-sub lambda calculi, which is, for most things, enough. But imagine you didn't have generics, stuff like map/filter/reduce can't be coded without breaking the type system in that case. In JS, which is essentially an untyped lambda calculus, you can code anything you want (and probably in fewer lines of code). Type systems are useful and can prove black magic-worth properties of your programs. But it rubs me the wrong way to see them put on a pedestal with no mention of drawbacks. They are not as much of a hassle thanks mostly to IDEs and type inference but they aren't untouchable either.
Holy shit guy, where you received your education is irrelevant to whether the average individual on Earth in the Solar System of the Milky Way learns (or should learn) base conversion at a pre-university level. If your education wasted student time teaching base-3 then good for you. Congrats that you know bin/oct/hex are used in the real world. You're a genius.
I believe, from memory, that this makes type inference easier. I can't remember the details though! I think there was a discussion about it in the last year or so. Perhaps it just makes parsing easier. Can't quite remember. I do remember there being a good reason though that a lot of languages do it this way.
So you're React is the new PHP?
Good bot!
Thank you for finding this reference!
Nope. The stuff I work on day to day is not meant to be open sourced. Even if it could be, much of it is not general enough to be of use to another project.
More than likely: speed. The native implementations handle tons of special cases that loads doesn’t.
No problem! I read your comment and got a brain/memory itch, had to scratch it! 
The quote is confusing, once more than 1 person contributes to an unlicensed project it suddenly becomes frozen with nobody able to do anything?
It's hilarious how you accused me of making a strawman argument while saying things like "If your education wasted student time teaching base-3", or how apparently my school experience doesn't count but yours is clearly the go-to reference for if the average individual should learn how number bases work. Maybe you should stop projecting so much? My education taught binary and decimal arithmetic, discussed duodecimal and sexagesimal (you know, the bases of time arithmetic), and covered the general relationship between other bases and decimal. But according to you one needs a university-level education to understand such complex arithmetic concepts as "integer division" and "counting".
VS Code uses the Typescript language server which is more advanced than what the JetBrains products currently offer with their own implementation (as far as I understand from reading issues on their tracker). There's an issue on the Webstorm YouTrack to integrate the Typescript language server though, so soon (I hope!) Webstorm and related products like PyCharm will have the same level of editor integration with Typescript as VS Code enjoys.
OP asked if anyone moves their sharable code into separate packages, and you responded with "I don't write sharable code"
Greetings, i'm new to ***programming*** started learning **html** to **css** and now **javascript**. i have realised little or no experience, i wish to take part in activities that can help me get my hands on the plough. Am presently **studying Javascript** and i hope to learn alot in this community . Any advice or support will be greatly appreciated.
It’s just that without a license the permission for someone to use the code in their own project is ambiguous. You wouldn’t want to sell your own fork of the software and later find that it has a GPL license or something even more restrictive. You could be in breach of the agreed terms of use which can have consequences.
When you resize browser window (I'm in Firefox), it throws off the mouse location
Can you give more info on how your project is set up? It's difficult to understand where your actual issue is. It sounds like your problems can be solved very easily with git and a package.json
Just check out what Typescript IDE can do. I always use TS in small solo projects. Really frees your head and helps to design and move forward.
I also like to write native js methods for fun. The other day, I randomly wrote out Array `map`, `filter`, `sort`, and `reduce` for fun. It's interesting to go through the exercise of figuring out how you'd write them, and since you need to look up the full spec, you usually end up learning something about them
Actually that looks really clean, I like it :)
Read through it, but the explanations seem wrong to me. I still can't see how `let i : int = 0;` would be easier for either the IDE or compiler to parse than `int i = 0;`. The main argument seems to be that the type identifier, because it's optional should come after the declaration, and it's easier to strip optional arguments that come after. I can grok that. The problem with that argument is that there's an assumption that all variables need to be declared using `var` or `let` or whatever before the type declaration. In C# you use the typical `Type name` style declarations, but if you want to infer type you just declare as `var name`. This seems even easier for the compiler to parse b/c it doesn't have to look for optionals. The declaration is either explicitly typed or inferred, and that info is in the same spot every time, at the beginning of the declaration. If the a language were to drop the requirement for `let` and instead prefer `name : int = 0;` I could see that being a valid argument. TS, though requires `let` or `var` or `const` just like es2015. Did I just uncover the real reason TS prefers this format? Is it b/c of the block scoping difference between `let` and `var`? If so, that's an easy fix: kill `var` like all js best practices recommend doing anyway, and just assume a declaration wants to compile to `let`. Maybe that decision was made b/c when ES2015 hadn't been finalized, they wanted TS to be "just javascript" and the TS transpiler just looked for `:`s and stripped the next word. Today the TS class structure is pretty different than that as TS class structure is not the same as ES2015 classes so they need to do some extra transpiling there anyway...
Private package managers are a thing if you need to keep stuff on-site and/or closed source. I'd check out [Verdaccio](https://github.com/verdaccio/verdaccio) if you're interested.
Nope, OP asked if anyone moves *project's* shareable code into separate packages. He writes shareable code within a project, and understands that he doesn't need the extra overhead of requirements outside of what his project needs.
Good bot
Hehe, yeah I happened to go down the coffee route as well, never again 😅🙈
Everything is magic, just depends on how much ;)
This is not only about extra requirements. The most important point what I see on this approach is integration solution, versioning and maintenance.
In TypeScript (and JavaScript) the `let` isn’t superfluous though. It tells that the variable should be mutable and have block scope semantics (as opposed to `const` or `var`). Even so, I don’t see what you want to type when declaring a variable with type inference, just the name? count = 0 Then you’ll get into the same problem that Python has were you never know if you are declaring a variable, or assuming a value to an existing variable. I personally find that very annoying. Anyhow it’s all just a matter of preference, wether you write `number count` or `count: number`, and everyone is free to prefer whatever they want...
Yeah, I usually do it as well, unless the function is really really short. Definitely not a bad thing to enforce 👍
Again, it can still warn. I don’t know why it has to not compile at all. It used to be that it allowed plain JS, but then it just kind of decided not to in some cases. Also, did you really think I believed Typescript to be sentient?
Is it free?)
Yea, I learned an important lesson about weighing community support more heavily, especially when it comes to foundational things (for instance, as a small example, *the language your entire fucking codebase is written in*)
Or what happened a lot on my last project... random Dev sneaking a new property on an object that has nothing to do with that object just so it ends up in the scope of a function he wants to modify but doesn’t want refactor.
We have private repositories. However, again, most of it is business logic heavy.
Hmmm, must have missed that word. My bad.
Yeah, installation instructions in the README. Even has a [Docker image](https://www.verdaccio.org/docs/en/docker.html) now.
Ha, not at all, just getting across that the language has to pick its priorities. You can configure to some extent the level of safeness in tsconfig, though. But at the end of the day the language is useless by default if by default it allows you to forgo its primary feature, its type safety. P.S. Not me who downvoted you, ignore that person.
Thanks! :-) Do let me know if there's anything you'd like to know about TS, I've come to really love it (as someone who hated the idea of it at first, no less).
K
well first of all, your event listener: response.on('data', function(body) { let obj = JSON.parse(body); //Just a function that does stuff with this data setQ(obj.results); }); assumes that `body` is the complete JSON object; which is not guaranteed. the `data` event sends a CHUNK of the data, which may or may not be the entire message. Instead, you need to do something like this: var body = ""; response.on('data', function(chunk) { //Just a function that does stuff with this data Page += chunk; }); //'end' event signifies the message is done response.on('end', function() { let obj = JSON.parse(body); //Just a function that does stuff with this data setQ(obj.results); });
Express is a Javascript framework which is used to build Web Applications. With Express, you can build a server side application that handles HTTP requests. You can read more about Express here: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction
I guess I am not at that level yet. I am sure all those people preferring typescript has a valid reason. I just didn’t know if it was just the type safety thanks 
Yes you are. Everyone writes bugs in every programming language and no amount of planning will prevent that. Typescript is a tool to reduce bug surface area. It's not just there to be a handhold for junior developers who don't know what methods exist on an HTMLDivElement, it's to protect senior developers from themselves and each other over the months and years after development of a feature that implements a complicated interface ended. In a language where anything goes typescript keeps you in check.
I totally agree I just finished that course. This is the course that finally made JavaScript click for me. I highly recommend it.
&gt; I've made a node.js app that is only launched through the command prompt. My clients don't like this Then typing "myprogram.exe" at the command prompt isn't going to change things, is it?
I see what you're saying, but can't .exe be run just from clicking it? 
Sounds like you just need a bat file.
Good bot
Now I'm a bit worried.. when you say they don't have a background in programming or computers, you implied that you *do* but... you have never heard of a shortcut? Or batch file? Or a shortcut to a batch file?
that sounds great, thanks for the help! 
Hi /u/gfrobenius, this post was removed. I'm going to write an extended message here as I can feel your frustration. The post was removed because it's just complaining about SO, and complaints really aren't the point of this sub. But, I know why it might've been downvoted: It's a 3rd party library, and you don't provide a working reproduction. It's _much_ easier to help someone when they give you a jsfiddle, codepen, or at least a fully self-contained example. It's about like calling a mechanic on the phone and saying, "Hey my car is making a funny noise, here's a picture of it, what could it be?" versus taking the car into the shop and letting him inspect it in person. The `call()` and `apply()` methods don't have anything to do with inheritance; they are just different ways of calling functions which allow you to change the `this` inside of the function. https://codepen.io/anon/pen/WyZgdg?editors=0010 With that said, they _can_ be used to call a method from another object -- that object could be a parent method, or it might be a method from a completely different object. As for your code, it looks correct -- I'm not sure why it wouldn't be working for you. But again, I can't say for sure because I don't have any code to debug.
I think you should take a look to the new features that EcmaScript has, You can have OO with EcmaScript 6 and also rely on Prototypes, which are an important part for JS environment. If you already has the idea o have worked with JS, Should be easy for you to handle it. I'd like to emphazie that you might need to change your mindset to an async way of thinking. 
lmao so instead of just listing of these possible solutions in your first comment, you just find ways to insult me? I wonder what made you so bitter about someone just asking a question 
I'm not bitter. Since you decided to backhandedly insult your client, I felt you deserved a similar insult.
https://i.imgur.com/oyRHZN4.png
Thanks man. Yeah I know better. Was on a long coding bender as was frustrated. I knew DHTMLX was rarely discussed on SO also. Ended up posting my own answer. And I realized when this post was blocked that I picked the wrong sub. My bad. Thanks for the reply and the info.
Heh ok, I'll spell it out for you.. &gt; they do not have a large background in programming or computers in general. Neither do you. Obviously. So why mention it?
ITT: No one answer's OP's question
&gt;&gt;all I did was say that your viewpoint doesn't reflect my own False, You suggested I was making a character judgement. When I was only describing the nature of the question.
I suspect the projects where you see no benefit are small and types not contain large/important interfaces. I have a small project that doesn't benefit much from TypeScript. I also work in a very large project where it is clearly invaluable. eg a response from the server containing a large/nested domain model object that is typed automatically by a tool that converts C# classes/interfaces to TypeScript. For this project the main benefit I see is the use of interfaces - making the code much clearer (what method is receiving what, and what it's returning), as well as getting safe refactoring benefits from the compiler. I have fixed countless bugs just by converting to types, suddenly realizing that the method that returns an important "Schedule" object, can also (accidentally) return an object that doesn't contain all the required members
JavaScript is fine for OO programming, regardless if frontend or server-side The JS community doesn't debate OO vs procedural (as sometimes happens in the PHP community) but instead debates OO vs functional. JS classes don't have private fields, but then neither do Python classes (-ish; Python has name mangling). JS doesn't have interfaces (-ish; they are in superset languages such as TypeScript) but then neither does Python. JS makes it easier to use ordinary functions, unlike PHP where, due to autoloading mechanisms, you end up putting everything in a class. JS has only single inheritance, unlike Python's multiple inheritance or PHP's traits. Though, JS classes are mutable like Python's, so you can manually copy properties to achieve the same effect.
Yes, IVSCode is directly and deliberately paired with TypeScript. As soon as changes are made to the editing service, VSCode incorporates them in the next release within weeks.
Interesting misunderstanding. Please note, I was responding to someone - not OP. I was supposedly empathising with that person. I know exactly what it means. You need to read more carefully.
Try against [an http source](http://authtest.midnightfreddie.com/public/stuff.json). It's been a bit since I did this in Node, but I think you need to provide the approved root CA list (the right way) or bypass certificate validation (what most people in a hurry do, you insecure bastards). Ok, after a quick Google and a visit to the site you reference, there is a hard-coded root CA list in NodeJS according to the first site I clicked. And the site you're using uses LetsEncrypt, and I vaguely recall having to add their root CA to something in the past because it's relatively new. So your problem *might* be that you need to explicitly add the LetsEncrypt root CA as trusted.
I completely see your point and I've been thinking about this for a while. I was so happy to see this thread, yet so disappointed for these responses above. 
Yep it is a good point that when moving code into another npm package that the solution is more complicated, versioning is more complicated, and maintenance is increased.
I want to do away with ´let´. Best practices for js recommend developers should never use ´var´ as it is. Once ´var´ is gone, we can assume ´let´ is the default, it is no longer needed. There can still be a modifier for ´const´ to denote the few constants in an app. In JS you might write: let a = 0; let b = “one”; const c = 2; let d; // uninitialized unknown type, legal In TS this looks like: let a : number = 0; let b : string = “one”; const c : number = 2; let d = 3; // type inferred let e = “four”; // type inferred let f : number; // uninitialized known type let g; // uninitialized unknown type, illegal In my preferred world it looks like C# &amp; Swift, ´let´ block scope is assumed: number a = 0; string b = “one”; const number c = 2; var d = 3; // type inferred var e = “four”; // type inferred number f; // uninitialized known type var g; // uninitialized unknown type, illegal This style creates static typing like TS, but is much more concise, doesn’t need ´let´ and doesn’t lose anything but the JS ´var´ keyword which we shouldn’t use anyway. 
Works. Minor fix (Page -&gt; body), and stubbed in `noQ` and `setQ()`: const https = require('https'); const noQ = '10'; gameURL = "https://opentdb.com/api.php?amount=10" + noQ // noQ is a variable passed into this method from elsewhere and it is a string such as "10". https.get(gameURL, function(response) { let body = ""; response.on('data', function(chunk) { //add whatever chunk of data you just got to the previous chunks body += chunk; }); //'end' event signifies the message is done response.on('end', function() { let obj = JSON.parse(body); //Just a function that does stuff with this data setQ(obj.results); }); }); // stubbed-in setQ function setQ(results){ results.forEach(e =&gt; { console.log(`Category: ${e.category}\n${e.question}\n`); }); }
Chrome too. Cool project though!
Yeah, this community has a lot of people who really want to prove they're smart over the most mundane of things. Best to ignore it. Shortcuts are a good route. Batch files too. You can essentially write a script that contains your node command and have them use that instead. My only worry is that they then get confused about how to use that. Perhaps they'd prefer you built a simple gui for them instead? 
That's an excellent README!
Yeah, I feel like this is a common theme across a lot of tech-related subs. I was able to write a three lined batch script that did everything I needed. Also, the app already has a gui, the only thing they needed to use the command prompt for is to launch the app. I see the reason behind your concern tho :) 
Originally I would like to have some features of Optional &amp; Rx-like &amp; PubSub functions; however somehow that's too heavy if including them at the same time. Thus the implementation just includes the core functions, and more clear to use.
If I understand this code correctly, `cards` is an array that you want to loop through, right? I don't see why you need to loop through with both a `for` loop *and* a `.forEach()` loop. (Besides, looping through an empty array with `[].foreach` wouldn't do anything, would it?)
use this :) https://github.com/zeit/pkg
I've been inspired by [typeorm](https://github.com/typeorm/typeorm). If you use TypeScript as your daily language, you might find some fun stuff in there!
Yeah, that was one of the first things I tried. However, the package doesn’t play well with google sheets api which is critical for the project I’m working on. 
I have no idea. It's not my code. The function startGame is supposed to run when the body of the document is loaded, and that's represented like this: &gt; document.body.onload = startGame(); The goal is to have the show, open, match, and disabled classes removed. I can't even read the conditional. I have no idea what the i is even supposed to represent ¯\_(ツ)_/¯
``` Monad.just(1).is present(); ``` I'm confused, is your "`Monad`" just an option type?
That error usually means you have an extra semi-colon or something at runtime that isn't understood. Debug in your browser Dev tools to get the line. 
I name things sensibly: Name is obviously a string Count is obviously a number Id might be either but is typically determined by your backend and not manipulated by you so its type doesn’t matter. Besides undefined, I rarely make type errors. I use React prototypes and a good set of tests.
I am. I'm receiving two error messages in the console. The first one specifically references line 65, which contains this code: \[\].forEach.call(cards, function(item) { I'm not using semicolons at all, although the tutorial does - they aren't required anymore. 
Try another browser? Welcome to development. 
Weird Parts is great!
Add a semicolon at the end of: deck.innerHTML = ""
This perspective is positively influencing my perception on the issue, so thanks for your input. I see that this type of exercise does prove that you can do the fundamental task of coding, so in this regard, it's a good screen. I think I'm taking that skill for granted (which I shouldn't, since not every dev applicant can actually do it) and looking instead at all the ways a concrete, 45min coding challenge has so little to do with actual responsibilities expected of a developer on a real application. In particular, much of the skill in real world development comes from the ability to actually self-acquire the requirements effectively. As a developer you are typically given higher level requirements, along with a large complex existing codebase to implement them against. A product manager or designer can't understand every flow and edge case the feature/task/ux will run into - they give a handful of use cases and expect you to interpolate a design that integrates with the technical reality on all fronts, meeting all the core use cases plus the ones the PM didn't even think of. Plus also accomplishing the task of keeping solid, maintainable, performant, readable code architecture, making good decisions about libraries to use, it goes on and on and on. So while I acknowledge that the interview question is useful, I think it's useful to the extent that it's useful to know your candidate can crawl before you see if they can run. I suppose I resent being asked to prove I can crawl, but, that's just my ego I think, and I see the value in checking that at the door during an interview. So, yeah. Well said, thanks again for your take.
Ok
TypeScirpt's name says it all - types. If you aren't using them diligently, why are you even using it? What's the reason of using TypeScript when every type is :any ?
the claim was "it's wrong on so many levels" and never even provided a single argument why it is wrong. on conventional wisdom, there was a time conventional wisdom said "earth is flat" all I asked the dude was to be a bit more rational, if he just presented his arguments, I'd have present counter arguments.
In retrospect, very bad.. also, forgot to add that it was a great read and will need to read through a few times. I too had trouble understanding the pieces mentioned and its helping me understand express better than before.. trump the lazy joke up to my frustrations with my brain.. 
Not so. They weren't created in a vacuum. I have written an example (was for another comment): - Design pattern: Iterator, introduced for C++ as one of the Gang of Four design patterns for common workarounds for things the language couldn't provide out of hand. - Foreach: language feature added to languages so that people wouldn't have to bother writing it over and over. You might say it is a language agnostic now, considering many languages stemmed from C/C++, but there wasn't any need for Iterator pattern in languages like Lisp, or R, Haskell or any other where already there was an idiomatic way of achieving it. So I still stand on "design pattern is a common workaround for specific language/framework deficiency"
Let's not start on the beliefs, already there are people with beliefs that downvote all I write because they feel hurt by different view. One cannot love an experience of something and believe against it. You either do the first, or the second.
which is why it was in general, not *you*, but *any*
developers? grown children is what I usually reply when some one asks me what they are :)
Imagine normal legacy typescript project. It's not the language, it's the legacy that makes it messy. Typescript just adds one more layer of mess over javascript being now you'll also have to deal with type juggling
&gt; Oh well. Guess I'm done here. You've mistyped #1: you're still "feeling something isn't correct" so you still have no rational arguments, meaning "you don't really understand patterns."
&gt; (as opposed to const or var). You're wrong. `let` is exactly like `const` with the difference you can't re-assign `const`. So do your self a favor and (almost) never use `let` but only `const`. You can even do `for (const item of items)` and be sure that `const` doesn't get re-assigned inside the `for` block
&gt; (as opposed to const or var). You're wrong. `let` is exactly like `const` with the difference you can't re-assign `const` variable. So do your self a favor and (almost) never use `let` but only `const`. You can even do `for (const item of items)` and be sure that `const` doesn't get re-assigned inside the `for` block
&gt; ´const´ DOESN'T CREATE CONSTANTS. It just creates constant binding between the variable name and the object it references. Rule of thumb: `const a` is the same as `let a` when you don't re-assign the `a` variable to another object (the object isn't constant, you can still change it)
WebAssembly could possibly make TypeScript obsolete for web development. But I would still use TypeScript for any Node.js development.
Do you have any knowledge of how parsing and compiling work? Let me assume you don't (even if you do), so I can present an over-simplification. The SO answer said "reduced ambiguity". What does that mean? Well, first when parsing a line of code, it gets split up into tokens, and then those tokens need to be arranged into an AST (abstract syntax tree). This tree would have something like `a + b`, parsed as + being the parent, a to be the left-side child, and b being the right-side child. With `let i: int = 0` would still be the case. It will still need to be somehow transformed into a part of that tree. And there are rules of how, which part goes to the top, with child goes first, second, etc. So "reducec ambiguity" means the rules of how that tree gets produced are smaller in number, thus not many that are too similar that can produce "unexpected" results. Hope that helps.
First I thought I will do for koa, but later thought to go with express. Explaining koa is easy as the LOC is very less. Its on my task list!
Thanks for your comments. May be if you feel any part of the content is tough to read or can be improved, please feel free to raise a PR.
I didn't say I never declare types (that's basically impossible in java btw), I just said I never do any casting.
Oh, I had misread your comment! My bad!
In fact it has `flatMap()` [https://github.com/TeaEntityLab/fpEs/blob/master/monad.js](https://github.com/TeaEntityLab/fpEs/blob/master/monad.js) As I programmed some sync or async cases... finally I separated async to the other module named `MonadIO` (Just as Haskell one :P) https://github.com/TeaEntityLab/fpEs/blob/master/monadio.js 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [TeaEntityLab/fpEs/.../**monad.js** (master → 02c03b6)](https://github.com/TeaEntityLab/fpEs/blob/02c03b67f53f9f28d7482dab7d992400c3a367bf/monad.js) * [TeaEntityLab/fpEs/.../**monadio.js** (master → 02c03b6)](https://github.com/TeaEntityLab/fpEs/blob/02c03b67f53f9f28d7482dab7d992400c3a367bf/monadio.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0rbzgd.)
well Java has its own set of problems. stopped using it for the favor of JS because of the all so many incantations one had to write to satisfy the compiler, the actual code that did have the business logic amounted to 15%-35% per method. in that reguard, I had to train myself to ignore large chunks of the codebase (and ignoring code makes you ignore bugs as well) so I can see what's going on. arguably, similar situation (like JS/TS) exists with C++ over C. C++ has overly complex type system (templates anyone?) when you can just use C to do the same.
He doesn’t say how it reduces ambiguity, unless he means that the presence of a ‘let’ keyword (regardless of the rest of the pattern) is easier to parse because it is the singular declaration command. Given the requirement of that singular command to “reduce ambiguity”, the rest of the SO answer makes perfect sense. If that’s the case, I am disappointed in the tradeoff of a decrease in parser complexity (which I as a user should never have to alter) for verbose code. That’s compiler centered design, not user centered design :(
my bad, it's reducing ambiguity to the compiler, not the person writing the code :) in the compiler it is not as singular as you might think. there are many rules of how to recognize what the code is meant to do. think of the C++ example: `int a = 0` the compiler will have a rule that says: "if line starts with `int`, it is a declaration and the variable type is int" like, the type is there from the get-go, you can't alter it. so they had to add another rule that said "if it starts with `auto` expect the variable type later on" and because there are competing rules as to `int* a, b`, you migiht think it will declare two pointers `a` and `b`, but in fact it declares one pointer `a` and one integer `b`... so, many competing rules in the compiler makes you get unexpected results. user centered design is to not shove types in the programmers' faces like C++ i.e. let the compiler infer the type, you as a programmer shouldn't specify it is a string type since you already give it a value of `'some string'`. so, in user centric design, the type declaration isn't the most importaint thing, not to you, it's what you do with the value. that's why, types come at the end, so you can omit them when compiler does the proper inference for you. hope that helps
I would if I were able to figure out the proper compilation steps to compile ES6 to something both node and webpack can understand.
We don't take kindly to inheritance 'round here 
In my experience, not at all.
Mostly, I agree with you, but the misconceptions in the writing... They don't "cheat" typing, just the static type checks. ES it self has types, remember? Array is a type, for example, and you can't cheat it to behave like a string (no, this is not a challenge for someone to re-implement a string through array :) What they do "cheat" is the purpose of the tool. If you use TypeScript, do strict types (I don't like them, I wouldn't use TS), but if you just slap :any to every like, how about you just spare you the trouble of dealing with TS at all? Arguably, TypeScript is for type checks, so either you use it fully, or not at all. Half-assed usage just gives you the pain of supporting yet another language and tooling with none of the (not worth the cost, according to me) benefits of static type checks.
I'm trying to follow along with the tutorial, but there's a lot of problems with it that I don't think would be very useful. Let's take this first example. `exports = module.exports = createApplication;` `function createApplication() {` `var app = function(req,res,next) {` `};` `return app;` `}` Now, other people have wrote that this is using ES5 syntax when we probably should be using ES6. That's kind of the low hanging fruit. But the way the tutorial is written, it's really hard to figure out what this is supposed to do, why we need it, etc. It's also not clear why we're creating a variable called "app" when we can just return that directly. We don't know what req, res, and next do, nor do we have any idea of the types of res, req, and next. Which is relatively forgivable. But then we switch to application.js and we get this: methods.forEach(function (method) { app[method] = function(path) { this.lazyrouter() var route = this._router.route(path); route[method].apply(route, slice.call(arguments, 1)); return this; } }); So, this is where it starts to get hairy. What exactly is in this 'methods' library? Is it just an array of strings? If it is, then surely it would be more useful to write them out, if not, then why is it being used as a key on the app object? Additionally, "path" is a protected keyword in Javascript and should not be used as a variable, this.lazyrouter() doesn't exist yet, nor does this.\_router. I'm 99&amp;#37; sure that [slice](https://slice.call) is undefined, and that even if it was, call is used indirectly, as "arguments" would take the place of "this" in whatever slice is, with 1 passed in as the first parameter. I think you meant "[Array.prototype.slice.call](https://Array.prototype.slice.call)(arguments, 1)". At any rate, this also can be greatly simplified by going to ES6 and using the spread operator. So, then we define app.lazyrouter where we call an instance of a Router class we haven't yet written... It just seems very backwards. We can't really use anything we've written until it's all complete, and that's just monolithic, interdependent software development - i.e., it's not the type of stuff we want to encourage in the real world. It's more important to build stuff up from atomic pieces. 
Hey author here. Yeah I guess you have some very valid points. The reason I have sticked to use ES5 is that I thought making the same code snippets as in express library will help the readers go and actually read the original source itself. That said, yes certain things like `Router` class etc are used in the code, before even its created. May be I need to re-order the way the tutorial is written. Will take care of this. Good points. 
I don't think this is the problem - semicolons are automatically inserted ([http://www.bradoncode.com/blog/2015/08/26/javascript-semi-colon-insertion/](http://www.bradoncode.com/blog/2015/08/26/javascript-semi-colon-insertion/)).
[This isn't exactly what you ask for but you might find it useful. It describes how to structure application to make it clean and maintainable ](https://youtu.be/mBxpOvlbAow?t=1)
I miss read this as "scratch". (Checked if the post didn't mean "scratch". It took me 3 irritations to realise.)
I just left a project that was doing this (separating components into private repos)... and it was an unnecessary overcomplication that slowed development, and deployment of working builds. Whenever new requirements came through that effected the shareable components, we had to make fixes to both the shareable and the external dependent applications... which was a nightmare when you're waiting on one build to be reviewed, and passing in order to begin development on another. I learned that this moving shareables outside a project is a very delicate architecture, that will easily effect process, and boilerplating.
IF already contemplated, and is one of the next components thank you very much for using Vuesax
There's an issue with that bit of code; `document.body.onload = startGame();` will execute the `startGame` function and return its output (or `null`), and set the `onload` event equal to *that*, which might cause some problems. Instead, it should be `document.body.onload = startGame;`. The `i` stands for index (although the variable can have any name - this is just a common convention). It means that you're looping through an array of items, and at each iteration of that loop, the index increases so that you're accessing a different element from that array. \--- I've never seen the construction `[].forEach.call(cards, function(item) {` before, but I found this [Stack Overflow thread](https://stackoverflow.com/questions/16053357/what-does-foreach-call-do-in-javascript) from a few years ago that explains it.
I've updated the README.md the following is a `flatMap()` example: ```javascript // flatMap (sync) m = Monad.just(1).flatMap((x)=&gt;x+2).flatMap((x)=&gt;x+3); console.log(m.unwrap()); // 6 ``` Thanks for reply :D
&gt; enabled implementation is straight forward, so skipping the implementation details here. I would be cautious about statements like this, as well. If it really is straight forward, it should be easy to include a quick definition. If it's not, well... Besides, it's a function called `enabled` called from a `this` reference which is (presumably) intended to be pointing to `app`, but then utilized inside of a lazy loaded private `_router` property by creating a new instance of a separate `Router` and using `this.enabled()` to provide (again, presumably) a set of options _to_ that new `Router` instance, and I have no idea what `enabled()` even returns. Booleans, I suppose? Or maybe getter functions with references to the original `this` context? I suppose it doesn't really matter in this specific case, since I can just assume that it boils down to some sort of option that's either enabled or disabled. But in my experience, I have to be very careful about assuming what things may or may not be straight forward to the reader, or I've found I'll lose people on accident.
Hey yes, exactly, those are not actually required (at this stage), planning to remove those texts in my next push (also the code).. I'm working on it. Thanks for your feedback. 
Of course. Thanks for sharing! "Build X from scratch" are often my favorite kinds of tutorials. 
Dumbest shit I’ve seen on reddit, quite frankly 
This is pretty cool - very useful for trivial changes. Definitely makes it easy for changes like documentation, formatting, string typos, etc.
I’m moving. 
Meh. Ok. Underwhelmed but in a way that I think GitLab does so much right and is more innovative than GitHub, or Atlassian, and this falls a little flat with a vim and cli guy. I realize for the vast majority of people, especially beginners this makes the product more accessible. Tl;Dr I set the bar high with gitlab, this is underwhelming.
I have addressed few of your comments like `slice` etc..
Thanks. Removed the unwanted codes.. Now it should look much cleaner. 
So I guess you'd prefer the legacy code base then? 
I prefer github since it's open and free, I want to be able to share my code and collaborate with other developers. 
What do you mean with async way of thinking? I never programmed "async" yet, but i would like to know how.
Gitlab is more open - you can even read their source code. And gitlab has public repositories as well.
Just think of all the learning opportunities that a legacy code base provides ...
what's problem? 
There are a couple ways to solve your syntax error, but overall I don't think your function is going to do what you intend. Let's look at the syntax error first: adding a semicolon after `deck.innerHTML = ""` would work, or wrapping your empty array in parenthesis would also work: `([]).forEach.call` However, you could also rework your script to be a bit simpler and easier to understand, and I think this script might be closer to what you're trying to accomplish: ```javascript deck.innerHTML = "" cards.forEach(function(card) { card.classList.remove("show", "open", "match", "disabled") deck.appendChild(card) }) ``` 
But you read that this is a first implementation and they are still working on it?
its really simple; as others have said, it can be done using batch files. here's an example 1. Create a text file, rename it to something like start***.bat*** 2. Edit the batch file (right click -&gt; edit) 3. Enter `cmd node app.js`, this will start your node. 4. Alternatively, if you want the window to be kept open after your node exits (e.g. through an error) either place `PAUSE` in the next line of your batch file or make use of `cmd /k app.js` (both of these will keep the command line open after exiting the app, however with `PAUSE` the command line will be closed after an additional keystroke - try to experiment a bit with these)
&gt;Novel If you isolate your typescript code properly, you can start small and then spread your type-bootstrapping progressively either by converting existing js code to ts and add only the necessary type annotations slowly or with latest typescript you can import types into js (I don't remember the syntax but you write it as a comment) and then use the imported interfaces in jsdoc. If it's a brand-new project and coexisting with js is a requirement, you should write the infrastructure code (domain interfaces, domain specific utilities, common services) with typescript and then you can leave the consumer code in javascript
Not to mention free CI machines with the best API I've worked with
Slightly offtopic: [holy shit, their cookie usage notifier is magnificient.](https://i.imgur.com/fd1xtW0.png)
You'll probably enjoy callbags: https://github.com/callbag/callbag And to answer your P.S. + Yes, you can probably swap out gulp for webpack, but it will depend on some specifics + Jest is now my go-to for unit testing (Jasmine + more)
Are u taking about public rep. or private rep.?
That’s a good clarification, thanks!
My company is in the process of switching over to GitLab and I have to say I've been pretty impressed with everything I've seen so far. I actually can't wait to start using it!
You can always not use it if you dislike it...
Does it have *dark theme*
&gt; is exactly like [...] with the difference Then they are not exactly like then. They are different, as I said. Should probably not have used the word mutable since I was talking about a mutable binding and not mutable data. I do almost always use `const`, and I think that that should be the preferred style. Unfortunately it doesn’t look great, that ship has of course already sailed but I would have loved if we could have `let` as `const` works now, and `var` for how `let` works. That’s how it is in Swift, which I think is a beautiful language. Of course we don’t need anything to replace `var` since that behavior is not needed at all. Anyhow, I agree that we should use `const` in the majority of cases in TypeScript/JavaScript, that’s what I’m using at least...
Well, technically you can always use `any` to allow you to ignore types, but I don’t think that’s what you mean. There almost certainly probably are instances like you suggest but that’s more likely if you’re writing some kind of functional utility library or something. There definitely are times where it would be “easier” to not bother with types, but that doesn’t necessarily make it a problem with TypeScript. It’s usually a gap in my knowledge which I then look (usually to the guy who sits to my left at work!) to fill. If you’re thinking about switching, I would say just do it. It makes you think much more about what you’re actually doing when you construct a program, to the extent that I now visualise programs in my head slightly differently. There are plenty of other excellent benefits too, such as “squiggly line driven refactoring”, Type First Development, etc. Having written JS for 6 years and TypeScript for 1, there is no way I would start another project (that wasn’t just a quick node script for automating something, perhaps) without TypeScript. And it gets better every release. (I don’t work for MS, I just really like TypeScript)
Presentation, video: https://youtu.be/5nmpokoRaZI
Get in the game dude, gitlab has all that and more...
Yes, absolutely. Everyone has copyright over their own work by default. A contributor to an unlicensed project would retain copyright over their contribution. Without a license agreement, the copyright holder is likely to prevail in a lawsuit against anyone who uses, copies, distributes, or modifies their original work. I am not a lawyer, and intellectual property law is complex. The best solution is to choose an established open source license, one which has surely been vetted by actual intellectual property lawyers. Here's why it's a concern. OP published some "open source" code. Let's say you're a popular JavaScript blogger. You think this code is pretty cool. So you do a multi-week blog series using it. OP says "hey, wait a minute. I made this for ordinary people to learn from, not professional bloggers to profit off of! I'm calling my lawyer!" Their lawyer talks to your lawyer, your lawyer talks to to you, and you're advised that you should settle for whatever reasonable dollar amount OP asks for, because you clearly used OP's work without permission, and OP will win a lawsuit. This sort of thing is why you *always* need a license agreement when accepting open source contributions. And you *always* need a contract when doing collaborative work with others, if money is going to be involved. Even if the others are your bestest friends in the whole wide world - sure, you have nothing but love and respect for each other now, but what happens if you toss $100,000 into the mix? How about $1,000,000? 
If you CTRL+SHIFT+I, you can see that is in fact, using VSCode's editor.
Shouldn't be too hard to implement, since it uses a lot of code from VSCode.
Gitlab has both (just like github), and most of Gitlab's source is open as well, apart for some enterprise features. Github is completely closed source.
To display it on a web page you need to write to the response object. Use `res.write` for this, before your `res.end` For the `on('data', ... ` event to be triggered you actually need to be sending something to the server. You can navigate to the webpage `127.0.0.1:3000` and start sending your server payloads by opening the console on your browser and using `fetch` kinda like this: `fetch('/', {method: 'POST', body: 'from the client!'})` I can't see what your `processPayload` function is defined there. So disclaimer if there's an issue with that it could affect things.
&gt;React is a much better experience. My comment was in response to this statement being a subjective conclusion. If you're lucky enough to be in the position of picking a framework for a project that will be maintained for a very long time, company structure can be something important to consider. You may find yourself choosing a framework that other teams will work on once you finish the MVP for one example; those teams may have a different preference to yourself, they may find Angular a more enjoyable experience due to familiarity with it's architecture and dependency injection, perhaps more-so than React or something else. Dogmatic advice (X is shit because I hate it myself, don't use it) on choosing anything in tech is bad advice, avoid it.
&gt; Unfortunately it doesn’t look great but it DOES look great, what are you talking about? there is no need of thinking `var` or `let` look better, especially if you go for more functional style of programming where almost all you declare as variables are names to arrow functions. I've even moved to a style of the following, in order to make it all look clearly distinguished: ``` const f = ( (a, b) =&gt; a + b ); ```
oh, and to make your compiler happy: &gt; is exactly like ( ... with the difference of ... ) :D
True and I won't for a lot of reasons. I think a browser IDE is not necessary but I can see the utility. I'd honestly rather see their development time go in other directions.
Switching due to MS purchase of GitHub or some other reason?
Thanks for your comment, missed it completely, my fault will update the article with the same. 
GutLab is the new hotness because of irrational MS hate/ fear
`flatMap` is just the functor map `(a -&gt; b) -&gt; f a -&gt; f b` right? Would you want to demonstrate `then` instead for a monad, since that seems to be the monadic map `(a -&gt; f b) -&gt; f a -&gt; f b`?
GitLab has been the new hotness since GitHub started charging for private repos.
https://www.cookiebot.com/
That's Cookiebot
No, not really. They have been charging for a long time and their volumes were minuscule before the GitHub purchase. Now, they are just tiny.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
I'm seeing a lot of good things with GitLab, thinking of switching over for personal use.
Fun thing, the back button my mouse functions as a left click... maybe this is a WebGL thing? 
Yeah, I think op has conflated flatMap with map and monad with option
Did you read that article? Even a little bit?
What's confusing I think is that your Monad reference is only an option. While the Option type is a monad, there are many other types of monads (like promises, lists, IO, etc.). Unless I'm missing something about how your library works? Also, for flatMap to be implemented correctly, you'd need the anonymous function to return an option, not just another value. Your flatMap method is coming referred to as map in the fp world: I'd expect something like: ``` const result = Option.just(5) .flatMap(x =&gt; Option.just(4 + x) .flatMap(y =&gt; Option.empty()) result // is empty ``` and: ``` const result = Option.just(5) .map(x =&gt; 4 + x) .map(y =&gt; 2 + y) result.unwrap // is 11 ```
Finally a web IDE that uses Monaco. And also multifile.
&gt; Do you know a way that I can apply a different angle of showing the letters There are many ways, you'll have to read up. For example: \&gt; SVG way: [https://css-tricks.com/snippets/svg/curved-text-along-path/](https://css-tricks.com/snippets/svg/curved-text-along-path/) \&gt; Canvas way [https://konvajs.github.io/docs/shapes/TextPath.html](https://konvajs.github.io/docs/shapes/TextPath.html)
Where the semicolon is inserted follows specific rules. 'The only way the avoid this feature is to ensure that semicolons are always inserted in the correct place' - from your link. If use jslint/hint.
Released the first version of a very trivial [jsx handler](https://www.npmjs.com/package/ujsx) and finally made typings work as intended in [this little turd](https://www.npmjs.com/package/dtk).
These are known as singletons. Static classes would only have static methods and not be instantiated (think JavaScript's Math). Because there are only ever one instance of a singleton, that singleton is usually defined in a static variable, or in your case a module variable which is also fine. It would not be an instance member (`this.instance` seen in the constructor) because they are created for every instance and would need an instance to first exist before you could refer to it. In other words, you can drop the `this.instance` in the constructor since it's not doing anything. Otherwise, that part looks good. Given your error, it's possible there's a problem in how your `FBConfigsListener` is being imported, or maybe a typo in `getInstance` somewhere? It might help to log the value of `FBConfigsListener` to see what it is. https://codesandbox.io/s/0q0pl7n9yv
I checked the spelling by copy and pasting it. I also output FBConfigsListener from that file and its undefined. Since i had one file using it just fine i used that import statement so theres no typo there.
I'm just not sure what the world needs is another IDE.
It's not that irrational. MS has a past history of trying to force developers and users to use their products in order to be productive. .NET eventually failed because you had to pay to run a copy of windows server in order to run an asp based site. Just because they are making progress with open source lately with things like typescript and vscode doesn't mean people should forget this and protect their assets. I personally am sticking with github for now but I am also keeping my eye on gitlab to see if they step up to the challenge and offer something better.
&gt; I'd rather small reasonable easily tested functions You still should document the types of parameters and return values, though. Type annotations are the tersest way to do that. If you also want to ensure that the right types of arguments are passed, you have to write more code. &gt; over tooling [...] That's a false dichotomy. These two things aren't mutually exclusive. &gt; allows for me to more easily create [...] errors. What?
Thank you, I got the problems... I'll fix them as soon as possible :D BTW, except AsyncMonadIO, is it ok to use Maybe as Option name? I saw some implementations of Maybe in Javascript using this name and the behaviors are near fpEs implementation Anyways, thank you guys!! :D
http://bowlerclem.t3marketing.net/ used vimeo api to pause videos on overlay click, google maps api to change location on hover, custom "summary" accordion. Not something of big significance but I'm proud of it.
Thanks for your comment :D I'll correct the naming problems. Thank you :D
I wish the world agreed .NET was dead. It's still alive and kicking my friend
They said it couldn’t be done, but your fingers must be little Michelangelo’s to hack away such a masterpiece. God himself couldn’t make this better.
https://github.com/jterrace/js.js/
https://www.npmjs.com/package/native-js
You probably want typescript if you’re going to go OO. Vanilla JavaScript can do OO, but why punish yourself when typescript does it quite well.
Thanks for your correcting...I've learned a lot.&lt;(\_ \_)&gt; I've changed the wrong naming of \`flatMap\` &lt;-&gt; \`Map\`, thanks :D About the Optional, I found some posts like this: [https://curiosity-driven.org/monads-in-javascript](https://curiosity-driven.org/monads-in-javascript) and this one: [https://en.wikipedia.org/wiki/Monad\_(functional\_programming)](https://en.wikipedia.org/wiki/Monad_(functional_programming)) I found the definition of Maybe would be one kind of Monad, and it's an option type It seems ok to use Maybe as the name of Option class? I need some suggestions about the naming :P Anyway, thank you again :D
&gt; .NET eventually failed Holy shit, are you from the future? Because .NET is pretty successful nowadays.
It’s absolutely fantastic. We’ve never gone back. Self-hosted for life. 
&gt; That's a false dichotomy. It was a tongue in cheek decision to counter a false dichotomy with one of my own. &gt; What? Often I see the comfort of typing, or the tooling that comes with it, allow people to make nonsensical design decisions under the CYA guise of "the ide makes it easy to navigate the noise". This is the sort of thing that can lead to more bugs (through added complexity) and as many in here have mentioned it also leads to more time spent wrestling errors.
Hi /u/AutomationLabo1, this post has been removed. If you wish to post a link, please use the "Submit a new link" option. Thank you.
Hi /u/filous_cz, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/UrTwiN, For javascript help, please visit /r/LearnJavascript. Thank you!
Got my [app, SigParser,](https://www.integromat.com/en/integrations/sigparser) listed officially on the Integromat site. Here is a video for how to use it. [YouTube Capture email signatures to Google Sheets](https://m.youtube.com/watch?v=f7XHMoGWHDQ&amp;t=11s) 
Hi /u/FriedChicken24, For javascript help, please visit /r/LearnJavascript. Thank you!
Bitbucket is another great alternative with free private repos. Been using it for years.
Finally I've already done for this: using \`Maybe\` as its name :D It seems works, and also I re-implement correct version of \`flatMap()\`, and move old one to \`map()\`. I've correct these problems. Thank you very much :D
Yeah, Maybe with Just/Nothing is one naming scheme I've seen (I forget what language). Option with Some/None is just what I've used with scala before. Both naming schemes work :)
Thanks for your suggestions :D Thank you :D
A funny read - people will say anything to avoid admitting js is a good language. I get that a lot of people dislike it for various reasons. But being liked and doing its job well do not have to be the same thing. I personally think the things that js makes difficult or impossible, are things average programmers should avoid in nearly all cases, so the obstacle turns into a help rather than a hindrance. Not being able to easily writing blocking procedures is one such example. Not being easily able to use threads is another. Not allowing the typical OOP patterns to work is another. Forcing people to use and understand closures/callbacks in another. Having to write unit tests to get a basic sense of whether code is working or not (due to the lack of type information) is another. For many people who dont particularly want to use JS but are forced to by the web platform, and came from a java background, I can see how these hindrances generate a lot of dislike. And despite them all, they can still easily create working code, because these limitations tend to guide programmers into a style of development which is productive and effective. From my observation, the best part of JS is what it does not let you do. 
Agreed. Poor choice of words. It definitely isn't as dominant as it used to be in the web world. Many companies have moved tolonix and Java based solutions or AWS. With MS owning GitHub we could see a push for assure and .net again.
I completly new to programming, But why are you using a API for it? Can’t you just use timestamp for that?
I currently use Visual Studio Code for my IDE pertaining to web development. Can someone tell me the pros/cons of GitLab over VSC?
Just finished plugin for rollup which shows errors as system notifications [https://www.npmjs.com/package/rollup-plugin-notify](https://www.npmjs.com/package/rollup-plugin-notify)
Look into moment.js + [https://momentjs.com/timezone/](https://momentjs.com/timezone/) Good APIs should return date/time either in UTC or with a timezone: e.g. 2018-06-16T01:02:03+00:00 and moment is really good at parsing these and then allowing you to render them in whatever timezone you feel is best. If you don't know the timezone the API is using, either ask support or do some experiments -- e.g. if you determine that the dates are 2 hours ahead, then you should be able to guess at the timezone.
Do not try to convert timezones for a remote user. TZ is such a fantastically complicated problem. It is just edge-case after edge-case after edge-case. Leave it to the user's own system to handle localization. Send a UTC timestamp that is common to all users and make sure that is correct; then convert it to a date object in the browser and format it as you want. Use a library like [momentjs](https://momentjs.com/) to do any fancy formatting. If you absolutely, positively have to convert across timezones, use something like [moment timezone](https://momentjs.com/timezone/), but do not attempt to do this yourself. It is a slow, winding road to the [gates of hell](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time). And [read this](https://zachholman.com/talk/utc-is-enough-for-everyone-right) if you want to lose ALL hope.
Nope. We have never used GitHub. We used BitBucket and have other VCS In place. I think it's probably just the preference of someone who has more say than I do deciding for the whole business.
Adding a bit of curry to this. https://medium.com/@TheBilTheory/currying-with-the-shot-bo%C3%AF-ce4384974521?source=linkShare-97c351926e02-1529163106
Nothing against MS, but I liked that GitHub was independent of any one of the big players. MS won't kill GitHub but they spent all that money for a reason: to drive devs to Azure.
Or, they decided owning gitHub was cheaper for them than continuing to pay for the huge corporate account they had.
I have actually tried selfhosting it multiple times, but failed each time. I haven't found a way for it to simply run at a specific port, without using a bundled NGINX. The reason i'd want this is because i have multiple applications running on the same machine, most using reverse proxy on NGINX. If anyone knows anything about it, I'd be very grateful for some articles or guides which explain it.
They are not going use GutHub to push their tech. Azure is hugely successful and supports any technology you are interested in using. .net is .net.....not SU how owning GutHub could possibly help them expand the use.
You'll have to find out the timezone of the API first. If your timezone is `GMT-4`, and you already know that the API time is 2 hours ahead of your timezone, then that mean the timezone of the API is `GMT-2`. In your code, store the API time like below. var apiTime = "2017-01-13 11:56:01"; //just an example var time = new Date(apiTime + " GMT-0200"); 
You are both from the future and the past at the same time....As others have said, .net is in no way a failure. And no one cares about what they used to do. MS under Nadela is about access to any technology that developers want to use.
It's not a full editor. No plugins
Gitlab, itself, is open source...
I highly doubt that, but funny none the less. 
Makes chained function calls easier to read, at the expense of adding lots of small harder to read functions. Arguably making the whole thing harder to understand. Interesting, but I’m not sure the downside is worth it in real world situations.
A colleague and I had a similar conversation recently, the idea of currying is good but I’m unsure if the cost of harder to understand code from a beginners perspective is worth it.
&gt;And no one cares about what they used to do Well clearly they do if they are leaving github and checking out gitlab. 
Don't like reading? Watch [this video](https://youtu.be/-5wpm-gesOY). TL;DR: Don't try to do something by yourself that involves time and date.
Look I didn't come here to argue with a fanboy. I'm just saying that I don't feel their fear is unfounded. Use whatever tech you want. Run naked through the MS fields for all I care. I just am not going to blame people who chose to seek out different avenues.
As much as I hate to be picky but dark features are a easy selling point for me.
This is how you do it, folks.
[jsfeatures.in](https://jsfeatures.in) redid an old PWA with a friend.
Thanks for the information. Looking for Jest resources and all I can find is React related stuff :-/
https://cydia.reoo.me A better looking (imo) wrapper for an API u/s0n1c wrote.
I dont get peoples newfound love of gitlab. They pay their engineers like crap.
I'm just barely getting started, but I'm working on an SPA game for traceurs (people who do parkour) at pkroulette.app - there's nothing to show off online yet, except that's it's all es6 with zero build. I've got JS using imports without webpack or parcel as I just learned it was possible, and I'm really excited about it
Currying is the backbone of functional programming and is a very powerful concept &amp; tool. &amp;nbsp; &gt; lots of small harder to read functions &amp;nbsp; I personally don't find smaller functions harder to read since the mental overhead is also smaller. &amp;nbsp; &gt; I’m not sure the downside is worth it in real world situations. &amp;nbsp; Currying allows us to write small, composable and pure functions, which trio provide _tremendous_ benefits to real-world programming.
JS has already won.
Humanist: Spec and parser for mobile-keyboard friendly "command line options" grammar. https://github.com/jeswin/humanist
It's funny, because they likely started working on this before the GitHub/Microsoft deal, and they were using Monaco, a MS project. There is no escape!
I guess they can move along? 
sure but idk something strikes me wrong about the company. I welcome competition, but they seem sleezy. Trumpeting up a narrative of github being owned by big corporation (as if they wouldnt die for this exit plan)
It's named after [Haskell Curry](https://en.wikipedia.org/wiki/Haskell_Curry), since "Haskell" was already used by the language that bears his name. It's not named after the spice.
It's also a really terrible example as the original set of chained functions is incredibly easy to read anyway. If that was the most complex thing I had to read in a codebase I would be a very happy bunny. I hate contrived examples.
To everyone who is saying it's a stupid question, I think you are forgetting what our job is. We write functions to solve problems. The question is about assessing your ability to solve a problem. I've asked people questions like this, and I'll give them a clear goal, but sometimes you get people who try to hack a solution, rather than use reason to find one. The hacked solution will often only come close to solving the problem, and if you ask them how it works they'll have no idea. I don't want someone on my team who builds shit they don't understand.
Why don't you use Docker?
I have tried it, didn't have much knowledge about docker back then, though. I might try it again whenever i get a chance.
&gt; con·trived &gt; kənˈtrīvd &gt; adjective &gt; deliberately created rather than arising naturally or spontaneously. Good examples in articles are almost always contrived, because they basically have to be. If the example comes from real code, it's going to include a bunch of noise that's not useful for your understanding of the author's point.
Funny that some people are hating on Microsoft and wanna move to Gitlab because of an IDE that uses a lot of code from the VS Code project,which is open sourced by Microsoft. 
&gt; created or arranged in a way that seems artificial and unrealistic You missed a bit. But perhaps I should have said "I hate examples that are *too* contrived" I don't mind stripping out noise but when the presented example doesn't suffer any of the problems a solution attempts to solve, what exactly is it demonstrating?
https://javascript.info/async-await Really good stuff. You'll also want to look into how Promises work; they're at the bottom of the async-await construct.
I dont think anyone is arguing against the practice of currying here, just the syntax. This is a comparison of : set.filter(lessThanOrEqualto(N)) vs set.filter(i =&gt; i &lt;= N) you get all the same benefits, just a slightly different syntax. I dont see a major different between them honestly. 
One curry you can make, that's not as immediately obvious as callback for an `Array#map`, is for [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates). By building a new function from your function, you can apply rules that let you process string templates in different ways. e.g. I could apply my i18n translations, which will translate to some system-configured language like so: const translatedToSystemLanguage = t`Hello, ${world}!`; But, say I wanted to run it where I manually specif a language? I can make a function that builds another function that's set to a specific language const inFrench = tl('fr')`Hello, ${world}!`; const inSpanish = tl('es')`Hello, ${world}!`;
I prefer the terseness of using the function first class myself.
It is brilliant so far! I hope when it is done it can be linked from the main Rollup site, a tutorial like this is needed badly! Not sure about having to press a 'next' button to get to the next page, reminds me too much of sites that abuse that for advertising (not that you do!) A few things I would like to see added: - Mention that you can make the bundle an es6 module with 'es' (or maybe 'esm' now https://github.com/rollup/rollup/issues/1917) . Promote a future that is pure ESM! :) I know that Rollup plugins are probably out of scope for your tutorial, but having your CSS being processed by Rollup means you can have the watch functionality work for your CSS and have it processed on the way with SASS/Minify etc...: https://github.com/egoist/rollup-plugin-postcss "devDependencies": { "autoprefixer": "^8.2.0", "rollup": "^0.57.1", "rollup-plugin-postcss": "^1.5.1" }
You've gone from being b aggressive to getting angry to now just being a complete troll. It is not at all an insult to point out that clients - who have hired a person to do a tech related job - are themselves not capable of handling that job. That's a reasonable assessment of them. I don't expect my clients to know how to use my website, they expect my website to be user friendly. For a reason. They are users. Not developers. You're speaking from the position of "every office job is in the tech industry" because that's every office job you've had. Your clients must love you /s
&gt; Currying is the backbone of functional programming I think that's exaggerating a bit. Currying is a tool that just makes some concepts more manageable, that's all. To be precise, it reduces the complexity of general composition to a more restricted form so that the model of reasoning is simpler. It is, of course, an important tool for FP. But it is, mostly, a _practical_ tool. As such, it seems hard to call it "the backbone of FP". If one was to make a claim as to what "the backbone of FP" is, then clearly _composition_ itself seems like a much likelier candidate.
Use ECHO and tell the user what just happened too, followed by "press any key to exit", then PAUSE. It's nerve racking to execute a bat file and have no idea what it just did. 
The title is a bit confusing... what if Javascript wins what exactly? Social success and merit are far too subjective to be a useful measure for any large group of people. Everyone will have a different definition. We can agree on technical merit a lot more objectively. How compact is the code, how easy to read, how fast, how few dependencies, how many people use it, how many bugs reported...
&gt;The following two are equivalent \[…\].map(x =&gt; fnc(x)), \[…\].map(fnc) This is *not* true and can bite you in a surprising way. These are actually equivalent: [...].map(fnc) [...].map((x, i, a) =&gt; fnc(x, i, a)) `map`'s callback takes three arguments
 Well, I'll throw my own answer into the ring. I'll second the recommendation to read the React and Redux codebases, and I'll add Ramda to the mix. Although it's ES5, it holds up well. * JS: Ramda https://github.com/ramda/ramda * JS: Redux https://github.com/reduxjs/redux * JS: React https://github.com/facebook/react/tree/master/packages/react/src I'll also suggest a few repos that are written in other languages. I've found that these are generally quite readable and reflect clear thinking: * Clojure: Ring https://github.com/ring-clojure/ring/tree/master/ring-core/src/ring * C: SQLite https://www.sqlite.org/src/dir?ci=tip * C: Redis https://github.com/antirez/redis * Haskell: Yesod https://github.com/yesodweb/yesod * Go: Go https://github.com/golang/go/tree/master/src I'm going to spend a few hours a week on these, and see if I can come up with some reasonable generalizations on *why* these are good codebases. What do they have in common? etc. Should be a rewarding exercise. But I'm also very interested in reading the thoughts / blogs / comments of anyone who has already done a similar exercise themselves. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [golang/go/.../**src** (master → b459e00)](https://github.com/golang/go/tree/b459e0045404d30dc14ea82d3b735f12b43df7d4/src) * [facebook/react/.../**src** (master → ae14317)](https://github.com/facebook/react/tree/ae14317d6810d5b07d01308a2116a707e5e09983/packages/react/src) * [ring-clojure/ring/.../**ring** (master → 95e4ca2)](https://github.com/ring-clojure/ring/tree/95e4ca25d5b98c45f927b32b5c3c85c21c999d96/ring-core/src/ring) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0s5ijp.)
I will! I’ll start playing with it this week.
We don't need currying as we can always specialize a function in a much more flexible (and readable) way through a lambda, i.e. sum5andX = x =&gt; sum(5, x);
It's really easy, they even have a nice wiki page about it: https://docs.gitlab.com/omnibus/docker/ :)
My primary weapon of choice is Vue.js. I have had a brief rendezvous with Angular (and I found this framework to be too much like Ember.js - too many things out of the box that I don't need), then with React (and I fell in love with frontend development again after 10+ years of pure Java/Groovy backend) and then I found that little open source library called Vue.js... I find that no other framework has been so complete and so trimmed down at the same time as Vue.js is. It is exactly everything that I need and exactly nothing that I have no use for. I personally find the need to incorporate complex design patterns the exact opposite of the clean code that I try to write. I'm of the opinion that the code you don't have to write (for one reason or another) is the best code out there. So if I have to emulate the &lt;slot&gt; API in React that means for me there's some kind of functionality gap that shall be filled. The best analogy I can find (if one is coming from the Java background) is to look at the two like Java vs Groovy. Java is great but it has been lacking and still lacks some of the most essential features other programming languages have provided for ages (take properties for one). Groovy is basically all the things that made Java cool plus all the things that were missing due to historical reasons - with a cherry on the top in the form that it is a dynamic language. I do this comparison because React is thought of in a similar fashion: the least set of features that could probably work compared to Vue which is all the goodies from React plus things that you would have to do to do anyways in React (Hello world-style apps excluded).
Can I get an invite to the slack channel?
But composition _relies_ on functions that take a single argument. And currying is what creates those. 
I wouldn't feel bad about it not being clear, that code looks genuinely terrible. First step is open the page where it's actually invoked and watch it run. Second step is throw a `debugger;` statement into countkeys and somewhere around the strHtml garbage. This will cause chrome to pause execution of the script whenever a debugger line is reached and open up the debugger. From there you can hover the mouse over any value you want and get the value displayed to you. Pressing f10 will move to the next line, f11 will step into any functions on the current line. Third step is to slowly undermine the developer who wrote that, do not take any advice from them even if he/she is outranks you. General things that may not be obvious to someone new to js: anything that looks `/like this/gi` is a regular expression (googleable). document.getElementById is used to fish html elements off the page by their id= attribute. Setting innerHTML will replace that element's existing content with whatever you set it to. Good luck and godspeed.
 &gt;stopped using it for the favor of JS because of the all so many incantations one had to write to satisfy the compiler, This is not a problem with strict typing. This is just java being extremely verbose, it requires a lot of "boilerplate". This was always a problem with Java, though you pretty much can get rid of it by using frameworks like Spring Boot or Grails. 
Jest is my go-to
And thats great, because you can use either easily. For non variadic interfaces you can also easily wrap them in an autocurry - although that can be confusing when you mix styles or use 3rd party code.
Yep, that's why people using FP seriously prefer libraries like [Ramda](https://ramdajs.com/docs/#map), because JS has several similar surprises.
Dogmatic advice, as you put it, generally comes from a standpoint of experience. So while when you put it as “it’s crap” is brash, there’s generally a reason behind it being crap and that should be talked through. If you’re writing something that other teams rely on, why would you tie yourself to a particular framework or view technology? If you’re creating common components for back office applications, you should provide them in a variety of technologies so the people using them have the freedom to use the technology that makes sense for them. You keep coming back to dependency injection, and Angular’s architecture. Most of the time it feels more of a hinderance than help. It bleeds it’s design choices into nearly every facet of your application. I feel like if you go the Angular route, that’s it, you have made the decision and you’re sticking to it because refactoring the app into a different tech stack just wouldn’t be worth it. While React isn’t a full framework, refactoring the glue behind the components, or the view layer itself should be easily done since you’re just pushing data down into components, and the API driven by React is thin enough that refactoring the components is easy enough.
Major point of currying is that you can easily compose/pipe functions (e.g. `flow` from lodash or `compose` from Ramda) without actually defining anything new. When you have properly named functions, I don't find currying unreadable.
Thanks a lot for the nice comments! I do plan to add CSS, writting your own plugin, etc. I will add more on ESM, thanks for the pointer! Was feeling that this would get lost in a black hole, it is nice to know it is actually useful :)
I dont know google sheets but I do know VBA really well. The gist of what it does is: 1. Select sheet 1 2. Select range E4:E10 (whixh is on the active sheet which is sheet 1) 3. Copy the selected range 4. Select range G6:H12 5. Paste it
- You can't easily compose/pipe functions because the argument you want to set is not always first in place, which is a requirement in currying. - Defining lambdas is not hard. It's literally a one-liner expression that is almost as compact as currying.
I suggest you read this: https://en.m.wikipedia.org/wiki/Pun
I get you on readability ( although it's a bit subjective :) ) but that's flexible way of achieving the same partial application. Decent real life example: I have a form checking library that I wrote using partial application in the API. Basically, you have a map of field names paired with arrays of rulesets. { "name" : [isRequired] ,pass : [minLengthOf(8), isRequired] } Then in the view, you have your forms, and in the onchange method, you pass in check('name') Etc, which looks up the name in the map and essentially runs through all of the rules as a decoration on top of whatever else you want to do. It's nice, it's performant, and it's all based on currying and partial application under the hood. Would be much more verbose to specify functions for each field rather than have a generic checkField method that takes in the name and returns the proper handler for you. That idea stands with the rules too, minLengthOf(8) doesn't have to be specified as (x) =&gt; minLengthOf(8,x) in the ruleset.
Currying has made me a better JS programmer. Once you get familiar with it, it becomes a *very* low-cost way to refactor and reuse code, since you're basically creating (to put it in an OO way) "function factories" that store state without the ceremony of instantiating full-on classes. 
Their website has a lot of documentation: https://facebook.github.io/jest/ If you want an example that doesn't use React, here's one of my libraries that is using it: https://github.com/jakehamilton/leverage
Well done, was looking for something like that!
In guessing you can specify the port in the config file and then use you existing reverse proxy and just point to that. 
OK, now let's address the first point. What happens if you need to curry this way: (x) =&gt; minLengthOf(x, 8)
First-class functions are the backbone and currying is the brain ;P. 
[Made a clock that ticks down to the end of global oil supplies one evening](chriswoollon.co.uk/oil-countdown/)
Jesus you're still litigating. Next time why dont you try having a normal conversation.
I think they actually said that 
Sorry, no one with actual maturity 
I’m not a fan not, I’m rational. The position you are verbalizing is closer akin to fanboyism in that it’s an uncritical view of the commonly heals opinion of anti-ms people. Thy act like it’s the balmer/gates era still
Well, if you intend to use currying, you have to have proper argument order (3rd party APIs are rarely functional anyway, FP is IMO mostly used in business logic, data conversions and so on). It should be very rare to actually have to spell out whole lambda. Mentioned Ramda or FP version of Lodash do this (I mean the smart argument order). For changing order of arguments are usually prepared conversion functions (e.g. in Haskell it's `flip`). I am not saying it's *hard*, just that I like more currying, because I find it more reusable, testable and most of the time even more readable than having lamdas everywhere and repeating myself over and over. I guess it might be an acquired taste. When I was using Scala, I really loved the magical `_`, which handles just the case you are talking about (it has its limits, but in many cases it can be used): def f(a: Int, b: Int) = (a + 1) * b; val res = (1 to 50).filter(_ &lt; 11).map(2 * _).map(f(_, 2)).map(f(1, _)); 
Rollup will help you with that.
Doing that wouldn't really make sense in this context since the second argument is the field value, but I get what you're saying. You could also shorten the second one by saying minLengthOf(modify(8)) Where modify would change the number based on whatever criteria you want to add. I disagree on currying being useless. It's a simple way to introduce dependency injection without needing to pump things through a class or dive into the details of what you're trying for. There are a lot of APIs that benefit from that. Express has a lot of middlewares that do the same thing, where the first argument is a configuration for the middleware. Like saying app.use(bodyParser(config)) you pass in that configuration, and then you get back a function that is your middleware. How it works or the order of other arguments isn't something you have to worry about after you pass in the first. Essentially, that's what the form library is using as well, but in the case of checkField the config is just a string. There are few languages with native support for currying. It doesn't mean that it isn't useful in the others. I don't use it all the time, but there are definitely valid use cases, and they're more than just syntactic sugar ( which is in itself worth striving for if you're designing a public API to be easy to use ). You could also argue that any language that has decorators does actually have built in support for currying, since that's how they work under the hood in JS and python. And while JS's standard library doesn't curry by default, fat arrows make it very simple to do in your own. withConfig =&gt; modify =&gt; y =&gt; modify(withConfig, y)
Thanks for the feedback. Good point :)
Your example of "very simple" solution is slower and more complicated than just using a lambda, hence my point.
**[Raj+React RealWorld](https://github.com/andrejewski/raj-react-realworld)** For a couple weeks I have been chipping at a RealWorld project written using the [Raj framework](https://jew.ski/raj/). I think it is in a good state and meets all the feature requirements. I hope this is will encourage more people to try Raj out in their own apps seeing it put to use in a medium sized app.
I respectfully disagree. I am not saying jump ship. I'm saying keep your options open.
Just to get a bit more pedantic, JS's crazy scope means that neither of those solutions are actually equivalent. [...].map(fnc) [...].map(function(x, index, array) { return fnc(x, index, array)}) Are technically equivalents in all ways. [...].map(fnc.bind(this)) [...].map((x, index, array) =&gt; fnc(x, index, array)) Equivalent too, but require the first function to be bound.
Could I theme it to talk to Clippy instead?
"Plus, there are just a lot of programmers who either don't understand or don't care to understand either of those concepts and want the language to hold their hand, and I think that's valid." I could be wrong, but I think that's why I was down-voted to oblivion. People want to encourage a breadth of knowledge. Or they're greedy and these people want to work with juniors that read these things and want to program in the safest way possible, so they can do the seniors can do their job faster without fixing as many errors with juniors. It's risk v reward. I understand the concern of "fail catastrophically" and if I were making a product that MUST NOT EVER FAIL, I wouldn't use JS, I would use C++ or one of it's fancy new similar languages [ie. Rust]. For web development and even data processing, a failure usually means having to re-run code. Maybe you'll lose a day of processing time. meanwhile how much development time did you save building in babel-preset-env. I'm willing to bet the cost savings would be much better for the preset-env team.
/r/whoosh
I completely agree. By showing the arguments, you expose A LOT more knowledge of how all that code behaves.
I disagree that your version is more readable than the curried one: const sumXandY = x =&gt; y =&gt; x + y const sum5AndX = sum(5)
FYI: The project is dead so I can share.
Yeah and this is just awesome isn't it: sum(4)(5) So readable...
Cute, but the whole reason people use TS, is because it gives more errors than JS... I think you mean undefined behaviour and honestly, that would be a good book and would include things like mutability, normalization, defensive programming, etc. FYI, I believe I could build a system significantly faster in ES7, than C++, and I know both extremely well. Give me a team of developers, even as junior as you want, and I know I could get their confidence and therefor speed and capability to a productive level faster in ES7, than C++. People shouldn't underestimate the importance of confidence in juniors and the easier the language, the faster you can build confidence. (ofcourse there should be minimal magic in the 'language'... I don't want to encourage garbage like Angular 1)
Put the middleware between lines 9 and 10?
Where does it say that they are using code from VSCode?
Hi coderitual! I don’t really understand exactly what it is. Is this like an online desktop? It looks very responsive. What technologies did you use to build it and why did you build it? Was it a personal project? I would like to build a web app like this. 
Yeah this exact problem has been such a hinderance to my productivity. I don’t know how people can get anything done in this language. 
7.5B for avoiding say maybe a million dollars every year? Good deal.
The only word incorrect here is 'irrational'. There is a good amount of history available for people to base their hate/fear on. Ofcourse, you might not share that history, so might not share the hate/fear. Does not make the hate/fear of others irrational. 
 Hi rashad_sasaki! Yes, this is like online desktop. It's just library written in js + svg. The website was a "professional social service" (yea I know ;)) addressed mainly to programmers. It's like let's say behance + linkedin but for non graphicans. The main idea was something like this: *Show me your desktop and I will tell you who you are*. The purpose was also to encourage people to show not finished work. It was relatively easy to make your portfolio / home page there. Nice wallpaper, nice icons and arrangement of panels and voila. A bit like these wallpapers with powdered Linux desktops. 
They’re using the Monaco editor which is the backbone of vscode 
Thank you. TIL.
depends on the arity of `fnc` actually. they are functionally equivalent if `fnc` is unary.
Agreed wholeheartedly. When I go to use a third party library, I don’t need my IDE to tell me what to expect from a function call as soon as I type it out. I just spin up a test page and make some test function calls (with all the argument combinations I can come up with), and inspect the object with console.log. Either that or I can spend an hour reading the always up to date and precise documentation, and if that fails, spend a couple hours reading the library’s source code, learning the code flow and patterns and figuring out the output on my own. It’s so much easier!
Yeah, typescript hasn’t accommodated both of these features for literally months now!
&gt; If you’re like me, seeing a traditional for-loop in JavaScript makes you slightly uncomfortable. I'm all for using higher order functions but seriously, how can you be not comfortable with writing a for loop?
Hi! I wrote HTTP for Angular. If you have trouble getting the typings to work for you or have any other questions about it, feel free to ask :)
We’ll need a jsbin.
I disagree with the opinion that compiler errors are a huge deterrent for new devs. It's just a generalisation.
It just feels weird at this point is all. It's perfectly fine, it's just weird to see one in the wild. I like the declarative approach because there are fewer places for bugs to hide.
Yeah, if only typescript had a way to emit compiles js even if there’s an error. Like that’ll ever happen!
It just feels weird at this point is all. It's perfectly fine, it's just weird to see one in the wild. I like the declarative approach because there are fewer places for bugs to hide.
I guess it's because it leads you down what I've been saying to our novice developers as a path of the 'old ways' of doing things. The author explains there's nothing technically wrong with writing a for loop and of course there isn't. It's perfectly valid and acceptable procedural programming. There in lies the issue though. It is procedural. If you really want to get into building a functional codebase and getting all the benefits that brings then everyone should be onboard with writing functional code wherever possible ... And it pretty much is always possible.
Wow that’s cool! Thanks for sharing.
I read this as meaning uncomfortable when you see a for loop because there is probably a better functional solution, just like the one in this article. 
I've always used `Array(100).fill()`, which I think is more readable than the spreaded version (but I do like that too).
Yep, not considering this kind of thing leads to this classic line of code: ['10', '10', '10'].map(parseInt) // gives [10, NaN, 2] Because `parseInt` has signature `parseInt(input, base)` to which `map` is passing the element and the index.
I really don't think it's a better solution. From the article: const arr = [...Array(100)].map((_, i) =&gt; i); First, you create *three* arrays here: a constructed array, spread into another array, and then mapped to a third. Second, if someone new looks at this code, it isn't clear to them WHY the spread operator is used here, because the fact that a) constructed arrays don't have index keys and that b) using the spread operator here gives index keys with values of undefined is *obscure* knowledge. Sure, you or I know, but would the junior dev on my team or someone looking through my open source code know? Likely not. Here's a better solution: const arr = []; for (let i = 0; i &lt; 100; i++) arr[i] = i; *Anyone* can understand that code and they don't need to know the ins and outs of JS array to do so. Moreover, it's simply more efficient (you're only constructing and iterating through one array). Fewer lines of code != better code.
Ruby developers come to mind. Which is why I'm against teaching it as a first language.
`const arr = Array(100).fill();` `const arr = Array.from({length: 100})` + bonus normal js version: `[...(function*() { let i = 0; while(i &lt; 100) yield i++})()];`
Just do: Array.from({ length: 3 }).map((_, i) =&gt; i)
well, first answer: just about anything is _possible_ second answer: depends on what you want exactly, you could certainly script up the searching parts but then you might have to do some nasty filtering and scraping depending on the sites you are encountering. not to mention the task of ensuring that the search results are returning the people you are looking for to begin with. another issue would be the "public events" in question, is this an open-ended query or will there be a set of events you are searching. these details will add to the complexity of the problem you are solving with software. good luck!
Also: K.I.S.S. Fully agree with you
When simply summing two numbers of course you aren't going to be using a curried function, since you can simply use `+`. &amp;nbsp; However curried functions, including this `sum` one become very valuable to make tiny, modular pure functions that can be used to create more complex functions that are very clear and readable: &amp;nbsp; const sum = x =&gt; y =&gt; x + y const mul = x =&gt; y =&gt; x * y const add5 = sum(5) const triple = mul(3) &amp;nbsp; Now we can do _very_ readable things using our curried functions and partially applied functions: &amp;nbsp; const arr = [1,2,3,4,5] arr.map(add5) // [6,7,8,9,10] arr.map(triple) // [3,6,9,12,15] arr.map(add5) .map(triple) // [18,21,24,27,30] 
If you want to do it in one line use: const arr = Array.from({length:10}, (_, i) =&gt; i);
Why, apart from being pedantic, do you consider this an issue? The function passed to map() can simply ignore the second and third arguments. Am I missing something? 
I wanna search for artists at conventions so it could be searching for an artists name and if their name is mentioned in relation to my list of conventions. Is there a good place where I could learn about all of this in one spot? Or a term I can search to learn how to do it? 
This is really just being pedantic though? I don't understand how proving odd edge cases is arguing against the spirit of the article?
We have a node backend and a react frontend, both in TypeScript, and Jest works perfectly for us. To get the equivalent testing setup with mocha, you will also need karma (test runner), sinon (for mocks), chai (for assertions) and istanbul (for code coverage). You will also need to get them all setup and playing nicely together, which while not tremendously difficult, is time and effort that is not needed.
I forgot. `const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];`
Who writes this garbage..? Is this a serious article?
That's a bit of a non-argument though: anything remotely abstract can seem daunting and hard to understand for a beginner. that's kind of the point of being a beginner :P 
Didn't they transition to using websockets? 
Heh.. no. Wrong on all counts. &gt; It is not at all an insult to point out that clients - who have hired a person to do a tech related job - are themselves not capable of handling that job. It is when you're demonstrating an equal level of incompetence. I can just imagine how great a node application written by someone who has no idea what a shortcut or batch file is asks "but can't .exe be run just by clicking it?" must be. &gt; Your clients must love you They do! I don't expect them to be able to handle the tech things they hire me to do, and I don't misrepresent my own level of skill to them.
well, i think there might 2 things you want to research: web search APIs (eg duckduckgo, google, bing, etc), and web scraping libraries. after that you will want to create some sort of persistent application to run this search on a regular basis. that would require some sort of server depending on how you will deploy this. i mean, you could even run this on your home machine (again, depending on frequently you want it to run and if it needs to be always running). as you can see, there are loads of details here =)
Clean as hell! Everybody understands this code and it's even a oneliner!
Me. It's serious. Sounds like it just wasn't for you.
I understand 'map' at least is slower at looping than the equivalent 'for' loop. It's probably not significant in most cases but if squeezing the best performance out of your code is a concern you might want to stick with the old imperative way of doing things
Awesome! Thank you so much for the help. I'm gonna start looking all that up after work tonight. This is a much better start than I could have achieved alone! 
Look at the comment above yours, some built in or API functions might take arguments that you don't know about, leading to unexpected results.
mildly unrelated, but did anyone else get confused thinking he was using lodash in the map function? I know it's just a throwaway variable, but it's kinda like creating a function called `$()` that isn't jQuery.
Alternatively, let the transpiler handle optimization. If you're writing an app that needs the utmost performance, you're already using one.
I agree but it still becomes a weigh up between redundancy and understanding in reference to developers new to currying 
Thanks for censoring "h*ck" but making me say it in my head, you monster.
This is an excellent example -- one of those cases where JS's flexibility combined with dev ignorance leads to weird unintended consequences. I've been getting into Golang lately, and while I still love JS, there are a lot of perks to static typing.
Next up: How millennials are killing GitHub!
I believe this is actually your solution is most performant way of achieving this. The author's solution works but creates three arrays. `Array(100)` returns the first array. `[...Array(100)]` is spreading that first array into a new second one. And `.map()` returns a new, third array.
&gt; [...(function*() { let i = 0; while(i &lt; 100) yield i++})()]; You're a monster!
Can you put arbitrary JavaScript in a Google Sheet?
Yeah. 1: I learned a very simplified version of java, but not the real thing. 2: I got rid of the first two lines and it still happens
Meh, I'm not personally a fan of Indian food. 
And if you are a real senior. `const arr = [...[...[...[...[...[Array.from([new Array(100)])]]]]]]`
Someone here gave the canonical example of parseInt. But basically in the `map(fnc)` version fnc won’t ignore extra arguments if it takes any.
Honestly I consider it good to be pedantic when it comes to programming. Those obscure edge cases come up more often than one would think. 
Yes that was it, except it needed ‘score+=1
Yep
Didn't I see somewhere that \`.forEach\` vs \`for\` loop was actually slower? I don't normally remember that stuff as I don't usually that level of concern for performance, but it seems to ring a bell. 
I agree. I consider Clojure to be a functional programming language, and most Clojure code I've seen is not heavily curried. It *does* often do partial application using the threading macros, which is kind of similar, but if you grant that Clojure is functional, it's definitely not true that currying is the backbone of functional programming.
Usually there's a logical order to function arguments. This was kind of an eye opener when I started learning FP, because you're not used to thinking about it. Like with `map`, which is in non-functional languages is often written `map(value, fn)` but should logically be the other way around. Since `map(fn)` makes sense as a function on its own, but `map(value)` is rarely a useful abstraction. That's not to say you never need to apply a curried function in a different order, but when you do so you're often explicitly creating a new abstraction rather than just composing naturally. So in those cases it makes sense that you're creating a new function.
The trick is keeping functional code functional, and procedural code procedural. For the sake of doing what you posted, I’d vastly prefer: const arr = range(0, 100); Where the `range` function is more-or-less what you posted. Admittedly, this is more ideal in languages like Ruby where ranges are built-in, but still. The way I look at it is: business logic should be expressed procedurally, and “data” or internal logic should be expressed functionally (or declaratively, via structuring/destructuring).
Functionally equivalent, but OP said he was using some wack variant of JS so I dumbed it down a bit.
Ported [primitive.lol](https://primitive.lol) to javascript. I’m not the first, but I wanted more shapes and wanted it to work in 100% js, without native dependencies. https://github.com/ismay/cutout and the cli version: https://github.com/ismay/cutout-cli
Or reference existing implementations and inspect living objects with chrome dev tools. Turns out there is autocomplete on real objects. Whoda thunk. And spinning up a test page and working with real living code doesn’t sound like a negative to me. You’re acting a bit disengenuous to support your workflow. The best flow is the one that gets you personally generating quality code. I don’t struggle with my flow the way you outline. Just like it sounds like you don’t struggle with types like I do. 
Its a security restriction. I'm not sure why, but if your client is hitting a remote backend api you need to whitelist the client domain on the backend in order for requests to succeed.
That’s okay, no one does.
Agreed... they will break even in a few thousand years.
&gt;but the whole reason people use TS, is because it gives more errors than JS. When I say "falling prey to the classes of errors avoided by using types" I mean that since you are informed of certain kinds of errors at compile time you cannot encounter them at runtime i.e. fall prey to those errors. I basically agree with everything you've said.
Languages like Scala give you much better syntax for it
I updated a little project I use for quickly making html/css. It uses Gridzilla, livereload and does some basic minification and image compression. Also good boilerplate for starting your own gulpfile :) [https://github.com/laurenclark/gulp-workflow](https://github.com/laurenclark/gulp-workflow)
I don’t understand why people have the need for using these instead of create-react-app. 
It's supposed to protect APIs from getting hammered by rando websites. It's unclear to me how important this actually is, but it is enforced by the browser and I don't believe there is any way to turn it off. There are a few ways to get around it: 1. Whitelist the domain of your web app from the API 2. Disable CORS protections entirely from the API 3. If you have no control over the API, you will have to get clever. One thing you can do is proxy the API using Docker/Apache. Serve the client from Apache, and proxy in `/yandex` route that redirects to yandex.ru. I have posted instructions for how to do this on StackOverflow when someone else was having a similar issue: https://stackoverflow.com/a/49303336/4284401
Thanks. After spending almost 4 hours on trying to set it up, i think it's time to give up. Sometimes it says it's running, but refuses to connect, or it just doesn't run, without any error logs. I don't get why the installation process has to be such a pain in the ass.
Here is a one array solution: `Array.from({ length: 100 }, (_, i) =&gt; i)`
&gt;Fewer lines of code != better code. speaking of, there's 0 reason not to put curly braces around single line `if` and `for` statements. const arr = []; for (let i = 0; i &lt; 100; i++) { arr[i] = i; }
Your function should be a one liner of return val === faveNum. No need for the variable. 
if you wrote an article that said that, you couldn't spend 5 paragraphs pontificating about functional programming though.
I agree with everything you said here, except types vs. tests. Have you ever programmed in a language that had sum types and let you pattern match on them? Way better than 99% of unit tests imo.
Fetch has a mode of “cors” set that and see if it works. 
Thanks for replying! I tried shortening the function to this " var trueFaveNum = faveNum; function numberTest(val){ return val === faveNum; } numberTest(trueFaveNum); " no such luck. Any other ideas? 
What the actual fuck are you talking about
&gt; Array.from({ length: 100 }, (_, i) =&gt; i) `Array.from({ length: 100 }, (_, i) =&gt; i)` same array :) yay callbacks!
Do you have a faveNum function? It should be: var faveNum = 23; var trueFaveNum = faveNum(); Function faveNum() { return faveNum; }
 &gt; Array.from({length: 5}, (_, i) =&gt; 2 ** i) [1, 2, 4, 8, 16]
The API server controls it, not the front end.
There is no “logical order”, just common on order and uncommon orders. The idea that you will only ever need the common way is laughable.
Yes. But if the requested client does not set the cors mode it will not send the “options” call to see if cors is even possible on the returned header. 
Yeah CodeHs sucks
One of the reasons I really love TypeScript. Static typing combined with JavaScript's flexibility.
No, you can't do it if you have no control over the front end. How do you get around it? Create a VPS, make your own API, and set up a route to hit the site. No: fetch('someone/elses/website').then(res =&gt; res.json()); Yes: // vps app.get('/someone-elses-website', (req, res) =&gt; { axios.get('someone/elses/website').then(data =&gt; res.json({ success: true, data })); }); // client fetch('/my-vps/someone-elses-website').then(res =&gt; res.json());
`Request.mode` defaults to `cors`, though.
It (can) protect/s your valuable or mission critical business back end from being compromised by nefarious elements whom happen to brute force an API key or credentials. I'm currently neck deep in SharePoint/O365 front end work; disabling CORS, in a very simplified SharePoint contextual nutshell, protects resources between tenants so that, even if you're authenticated to O365 and have admin permissions on two tenants, you cannot share one business's resources with another. The reason this is important is that the two tenants in the example share the exact same API, and the same user account has admin access to both, meaning that if you allow CORS you can easily access the other tenants data. That, in my mind at least, epitomises what CORS is used for. I might be rambling, sorry not sorry if that's the case, hung over. Have you worked on back end systems in your career yet? Things become a lot clearer once you do.
What OS is this?
In my experience, taking a more declarative approach results is fewer bugs. A for loop is just fine too!
You're clobbering your variable. Look: var faveNum = 23; &lt;---- faveNum is a number. function faveNum() { &lt;--- You're redefining faveNum, now it's a function. return faveNum; &lt;--- This is returning the function. } Rename `faveNum()` to `getFaveNum()`. Try not to reuse variable names in the same file.
&gt; why can i fetch normally on the back-end or even with the curl command but not in the browser? Because the browser will pass along every yandex.ru cookies in the request, your proxy will not. You probably don't want foobar.com to able to get all your private facebook messages.
That works too! I actually like this approach more than the map spread.
Look at that last line. `faveNum` is being redefined to a function. This is why `const` is superior to `var` -- you wouldn't even be able to make this mistake.
I did my best.
Didn't know about the fill function before I wrote this post - benefits of putting content out there! :)
A few things wrong with this -- Passing anything to `next` invokes the error handler. Seems you have the error handler with `user` as first parameter -- so while this "works" it probably isn't what you want. Assuming the following middleware -- const middleware = (req, res, next) =&gt; { if (user) { console.log('we have a user!') else { console.log('no user here') next() } There's a few ways to attach middleware -- // global, applied to all routes app.use(middleware) // or via a router const router = new Router() // can be applied globally to the router. note that you must attach the router to app or another router via a prefix, or it'll be applied to all routes at that path level router.use(middleware) // for a specified route router.get('/path', middleware, (req, res, next) =&gt; {}) // you can also do above on the app level app.get('/other-path', middleware, (req, res, next) =&gt; {}) // (always make sure you attach router with a prefix) app.use('/prefix', router) Take a look at the docs http://expressjs.com/en/guide/using-middleware.html
And more efficient too!
Yeah I know what you mean but isn‘t the one special thing about it a „online“ IDE? ;)
Ahh. That was not my intention. I saw he was the one redefining the variable to the function with the =. I am typing this from my phone...
I *am* a huge fan of functional programming, and it's clear from the post. That being said, I think you missed the point if you think the point was to pontificate about functional programming.
And often, you only need to whitelist OPTIONS methods 
\&gt;.ts **( ͡° ͜ʖ ͡°)** But in all seriousness just using types in typescript on functions like you would with jsdoc is so much less of a pain IMO
My karma can't continue this argument lol
Wow. That was really helpful. Let me mull over that and see if it resolves the issue. Thanks for explaining all of that. 
The fill function is great, just learned about it. I agree that it's more readable.
You're looking at it from the perspective of functions that are already composed (i.e. how most imperative languages have worked traditionally). When you compose a function from multiple single-argument functions, then you lose certain information. After you've "uncurried" it to a function that takes a tuple of arguments, order indeed doesn't matter anymore. Try looking at it from the other perspective: if you *had* to compose a function like `map` from more primitive functions, which composition would make more sense? There are two possible compositions, but one is far more logical than the other. I don't want to sound like the typical Haskell circle jerker, but I will say this: if you've spent some time in a language where currying is the default, then the idea that the order in which arguments are applied is arbitrary becomes "laughable". If you were to start mixing the order of arguments around the language would become very awkward to work with.
I don't think you're using declarative correctly. Declarative means you are doing something in the code that you don't need to be explicit about. But your examples in the article are explicitly doing it, it's just doing it through a bunch of abstractions whereas a plain for loop is doing the same thing but with _less_ abstractions. Your suggestion in the article is memory inefficient, cpu inefficient and unreadable to those not as familiar with JavaScript. It combined multiple abstractions together to do something procedural and simple. Take the simple route 👍
I completely understand what he's talking about. He's not saying for loops are difficult to understand, it's just that there is almost always a cleaner way to solve your problem in JavaScript using map, reduce, filter, etc than using a for loop. The uncomfortability they are referring to is similar to the uncomfortability one often feels when they see code they feel is messy and needs refactoring. 
I've worked with functional languages. I'm just telling you that after 20 years of API design, I've come to understand I want to be *less* dependent on argument order, not *more* dependent on it. Significant argument order impedes API evolution, API flexibility in design and in use, causes confusion and the only "win" is that you type a few less characters *in some cases*. Significant argument order is the most pervasive and unnecessary case of premature optimization still plaguing computer languages today. If you want to have a truly balanced perspective on the benefits of both approaches, then if you have experience in functional languages, try using something like Swift for a few projects and see where your conclusion leads you to.
I disagree that using a for loop is always perceived as simpler (and without profiling I'm also uncertain if it's faster in JavaScipt either). While older programmers might be more comfortable with the loop abstraction (and it is an abstraction), younger programmers are becoming more comfortable with functional programming - of which functions like map and reduce are the bread and butter. I personally much prefer seeing a map function than a for loop doing the exact same thing, as it tells me exactly what the programmer is trying to do - map through an array and transform each of the elements. Same with reduce and filter.
&gt; I disagree that using a for loop is always perceived as simpler I never said this. In fact, all I said was OP used multiple abstractions to _do something simple and procedural_. I never said to always do this. The solution in the OP's article is bad but there are other, good reasons to use map.
Here's the secret - it's actually not a real restriction, just a convention enforced by the browser to protect users from [Cross Site Request Forgery](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF\)). So your request will usually have a 'Origin' header, which a server may/may not give a shit about. The response may/may not have an 'Access-Control-Allow-Origin' header, which a client may/may not give a shit about. All major browsers do indeed give a shit about this. `curl` does not. If you want to directly fetch from a domain that doesn't have your domain or '*' in the access control header, you're shit outta luck. You can't even change the 'Origin' header without the browser freaking out. You'll need to write a proxy. You should read through these links: * [CORS wiki page](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) * [CORS OWASP page](https://www.owasp.org/index.php/CORS_OriginHeaderScrutiny) 
Sure! Fork the repo and go right ahead! :) You'll just have to change the picture and replace all instances of "ducky.png" with "clippy.png". Have fun!
What is frustrating with all the blog spam is how contrived and few real world examples there are. So many make me ask "butwhy.jpg".
&gt; it's just that there is almost always a cleaner way to solve your problem in JavaScript using map, reduce, filter, etc than using a for loop. Be very careful with this. These functions all have their uses but you don't want to over use them, especially when it's not necessary. They all have memory allocation and cpu overhead; if you're on a machine with limited resources or are doing these types of actions inside of a requestAnimationFrame() you are going to have a bad time. I work on an embedded product that uses webkit for some applications and while it's great to be "functional" when you can you still need to be careful and reserved. Don't apply it to everything, especially when it's simple.
Not a single one of those enforce types at runtime. All of those, like TypeScript, are statically validated at compile time. The compiler ultimately emits functionally equivalent JavaScript which contains none of that type information. Despite being a polyglot, I can respect that others aren’t (or aren’t yet) so asking them to learn a dramatically different language and toolchain may be asking a lot. That’s _part_ of the value proposition of TypeScript: write the JavaScript you know with a simple syntax for annotating it with types.
Just test your url against [https://www.test-cors.org/](https://www.test-cors.org/). You must get a **200OK**. If not, you can roll your own *proxy* server to retrieve the content, and serve it with an **Access-Control-Allow-Origin:\*** header. Example with php, the first line should be: `header("Access-Control-Allow-Origin: *");`
That's js lib and normal website mimic something looking like desktop from os.
It’s not really a hack at all. By design, TypeScript needs to know about the execution environment you are targeting, since the execution environments can vary. For example, browsers have the global `window` but Node.js doesn’t. If you rely on `window` then you tell the compiler by configuring it to use lib `dom` in `tsconfig.json`. The TypeScript compiler has a lot of different options but most projects will set the same few common ones only.
I actually like the `for` loop a lot more when you're using all the `Array.prototype` methods, because properly applied its semantics are far more clear. Since we have `Array#map`, you don't ever say `const foo = []; for (let i = 0; i &lt; arr.length; i++) { foo.push(arr[i].trim()); }`. Because we have `Array#find`, you don't ever say `for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === someCondition) return arr[i]; }`. Purely by process of elimination, when you see a for-loop (or even an `Array#forEach`), you're really saying "this loop has side-effects". If I'm reading someone else's code, and I see an `Array#map`, I naturally assume it has no side-effects, so I only need to track what it's assigned to in its expression. If there were side-effects, that's an error and something I always flag in code-review. Now if I see `for`, I read through to make sure anything that's simply mapping/filtering/reducing/etc. happens outside it.
I'm curious, why `{length: 5}` and not `Array(5)`? 
I believe you have to listen for the 'touchend' event
That's what Google App Scripts is for. 
I agree with your sentiment, but since we're discussing language I feel compelled to get pedantic about one thing. FP is actually a subset of declarative programming, which could be lazily summarised as "declarative programming using functions". e.g. building a DOM using the fully-declarative language HTML like `&lt;p class="hello"&gt;Hi World!&lt;/p&gt;` could be easily implemented in just as "declarative" an approach using hyperscript functions as `h('p', { class: 'hello' }, 'Hi World!')`. If both are building a DOM they're really equivalent. I've always found the best way to think of the right approach is that imperative programming (of which procedural is a subset, lazily summarised as "imperative with functions") really means "how" to do something. Declarative programming is "what" something is. You can look at a recipe as a real-world example: one that says "smoothie: 1 cup milk, 1 frozen banana, 2 tsp vanilla, 6 frozen strawberries" would be a good declarative recipe, if you assume I know enough to figure out how to blend those things. One that says "pre-heat oven to 350F. Grease baking sheets. Roll batter into 1" balls., etc." is imperative.
 &lt;reeeeeeeeeeee /&gt; ---^ 
That's why I created this minimal :)
Not anymore. Jordan Harband references the perf [here, in this very long issue thread](https://github.com/airbnb/javascript/issues/1271#issuecomment-375810185). Apparently it used to be slower (overhead of the function call, etc.), but now the engine optimizes it out.
??
Yes and the performance difference can be quite large if your loop runs a couple of million iterations. It practically doesn’t matter though for many use cases, but if for example you’re developing on the front end and dealing with 3D animations and physics engines, using FP is pretty wasteful given the tight performance envelope. 
I was just having a conversation with a co-worker on this the other day. I mentioned how the for loop was dead and that if I were to find one I would have a distrust of whatever hack needed to be done that couldn't be done in a foreach. He got defensive about it so I had him check the project he's been working on for the past 6 months. Not a single for loop. He agreed after that. 
Pfft, amateur stuff! A true JS master wouldn't stoop to some flashy generator to make an iterator! [...{ [Symbol.iterator]: () =&gt; { let i = 0; return { next: () =&gt; ({ value: i++, done: i &gt; 100 }) }; } }]; Ahh... perfection..
Came here to say this. Although I've only ever had to use it once, I already knew t hat map() on it wouldn't work, because an Array created from the constructor is truly empty. So, Array(x).fill is the standard way to go. I think I might like inu-no-policemen's idea, though, I wasn't aware that Array.from had a map function for it. Not sure if it would also create the temporary arrays. 
Challenge for you based on a real world problem a coworker had on Friday: you have an array of arrays of varying length, where each is an array of ints, output one array where each index corresponds to the sum of all numbers at that index in each array (if applicable). E.g. [[1, 2, 3], [1, 2], [1, 2, 3, 4]] -&gt; [3, 6, 6, 4]. And yes this is an actual problem we were solving for a client... I told my coworker to use a for loop but I'm curious if there's a better solution ;-)
It's also pretty memory wasteful. 
I think he means imperative.
This is not about securing your backend. You can still hit the API and CORS is going to do jack shit as far as the backend goes. This is about the browser and offering some level of isolation in the context of the browser. Assume you have an API that you’re hitting on the backend from some js code in page on a domain you allow via CORS. The browser sees and understands this and allows the calls. Now assume, Joe random sees the code and tries to get the code and incorporate it in a malicious manner on his own website. Again, the browser will see that the requests are cross origin and will not allow it. Google “same origin policy”. CORS is a way around this, but it’s explicit (the api needs to support it) and you actually need to enable it. https://en.wikipedia.org/wiki/Same-origin_policy https://en.wikipedia.org/wiki/Cross-origin_resource_sharing
im 90% sure that this works on iOS $(document).ready(function(){ $(".yourElement").click(function(){ //do something }); });
You could map over the outer array and run a reduce on each inner array element to calculate the sums. 
On the topic of function currying, I made a convenient helper package recently. [https://github.com/g-harel/slurry](https://github.com/g-harel/slurry)
&gt; You keep coming back to dependency injection, and Angular’s architecture. I literally used DI as an example, one time. I'm not about making this an Angular vs React debate, both have their place and I've seen both amazing and terrible things built with both. I generally find that dogmatic options when it comes to frameworks and tech comes from developers who either barely scratch the surface of the thing they're dismissing because they don't like it or don't understand it, or developers who have been unlucky and spent too many hours frustrated with a legacy stack that has been implemented poorly. Most developers seem to go an arc of being opinionated about tech choices; Juniors know very little, so hold few opinions about tech and they are pretty flexible to try different things. They might inherit a viewpoint from a mentor and that will stick with them, it might cause them to dismiss technologies entirely based on one person's advice. Mid-weight devs who've had a few years experience tend to be the most opinionated and dogmatic in my experience (I was too), because they know quite a lot and they may have a few projects under their belt where they've been burned by poor decisions made by other developers. But they rarely have the experience with stacks outside their primary learning path and can sometimes take the viewpoint that "if it's not how I was taught, it's terrible, why doesn't it do the thing 'properly' like the way I've always known?". Seniors can sometimes retain that dismissive attitude for the rest of their careers, in my opinion these are the worst devs you can have on your team, they often think of themselves as superstars who do things the right way, the only right way is their way - I've met a few of these at various companies and they tend to drive away the really talented team members due to their toxicity. Fortunately most of the senior devs I have worked with tend to avoid locking in a opinion until they've experienced a framework or a tech stack for themselves and done more homework. I put more stock in a good team these days and worry less about the technical choices because I know a good team can make almost anything work well and be an enjoyable project to work on.
Aaah, there are so many wrong answers here. CORS exists to protect against REAL attacks based on browsers automatically attaching cookies that match the request origin/url. Here’s a simple example: We are a Bank API, and have disabled CORS. We also used cookies for authentication and session management. This is great, because we send a cookie, the browser automatically attaches it to each request to our API. Even if they close the browser, their session is valid until a time we chose. However, an evil website figures this out. What happens next: A user (Bob) logs into our site and checks his balance. Bob then navigates to the evil website. The evil website also includes a request to our API that transfers funds from Bob’s bank account to an evil one. The browser automatically attaches all cookies for our origin (url), including his auth tokens. We disabled CORS, so our API treats this request like Bob made it himself. We and Bob are screwed. If CORS were enabled, the browser would check with our API first to ask if this kind of behavior was expected, and we would tell them it’s not—do not send the request. 
Best one of the bunch. To the top wi' ye!
I agree. I was mostly referring to the fact that the author wasn't saying he was uncomfortable *writing* a for loop. I accidentally added the value judgement "better" having not actually considered the solution too closely.
.click is shorthand for .on Use .on(“click touch”, function(event) { ...
jsonp instead of json
Try them both in your console -- what do you see? Array.from({length: 5}) &gt; [undefined, undefined, undefined, undefined, undefined] Ok. Array(5) &gt; [empty x 5] Strange, huh? * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array &gt; Note: this implies an array of arrayLength empty slots, not slots with actual undefined values This is the important bit, because empty slots are not included in any of the `Array` instance methods, like `forEach()`, etc. The empty elements are often referred to as being _elided_. Basically, `Array(5)` does this: a = [] a.length = 5 Which also produces `[empty x 5]`.
Ah, not quite what I was asking. I meant, why wouldn't you do it like &gt; Array.from(Array(5), (_, i) =&gt; 2 ** i) [1, 2, 4, 8, 16] 
That's definitely not true. I work on a project right now that deals with pretty substantial amounts of data, and for that reason I wrote up and ran a bunch of different benchmarks for a bunch of different ways to do various iterative tasks looking for the best performing option. A simple for loop is still significantly faster than than the built in array methods (usually in the 5-10x difference range, depending on the function) unless something happened in the past month or so. 
In my opinion, for(let fruit of fruits){ } is far more concise and readable than fruits.forEach( fruit =&gt; { }); Using map is nice for one liners and cases where where better performance through mutable access isn't necessary, though.
I hate this. Just spell it out, use a sub, or just don't use it. OP, that wasn't a compliment.
`Array.from({ length: 100 }, (_, i) =&gt; i)` is more idiomatic, though I would just use a range function from lodash or whatever cause someone’s already got it in the project already
The web ide at the moment is just the core part of VScode in the browser. 
Because some people like to understand what is going on behind the scene. Some people like to have a better control about the tooling and used components / libs. 
Long sentances with a lot of commas are difficult to read as it becomes some sort of dialog, I’m in there too and get a lot of shit from my girlfriend because of it, stay strong brother you’re not alone, (fishbump)
In a press release or publication for a new version of a tool or product, explain what it does in one sentence. Don't make me click or Google.
That's the benefit of the good old for loop. You remember one thing, and you're good to go. 
&gt; Second, if someone new looks at this code, it isn't clear to them WHY the spread operator is used here, because the . . . OK, just stop. The “don’t do JavaScript because the people who don’t know JavaScript get confused and scared” bit is super old. You could apply this same logic to _literally_ anything anyone might not know.
fishbump? Patrick? 
I agree 100%. Would you dissuade people from writing code in the style depicted in the article because of said edge cases though?
I use currying on the occasion that I have several functions that have a very similar execution with slight variations. Recently, I made a script that returns random data for unit tests to use. I could have exported all of the arrays of possible values and called getRandomValue with the array as the param, but that seemed kind of convoluted when I really just wanted getRandomName and getRandomBusiness. This was particular to this case because there were getRandomSomethings that were more involved. So the APIs were inconsistent. So I curried getRandomElement and passed the arrays to it and exported the product. Very elegant solution and it kept my API consistent. I can post examples tomorrow since coding on mobile is not great. 
You could just write a wrapper: convertToInt = str =&gt; parseInt(str)
Um, yeah. `Array(n).fill(0).map()`.
I don't mind people being pedantic, but you're wrong about the second one. ``` [...].map((x, index, array) =&gt; fnc(x, index, array)) ``` doesn't bind `this` in `fnc`, it binds `this` in the callback. The callback doesn't use `this` at all, so it's equivalent to `[...].map(fnc)`. You can verify this by testing in a REPL: ``` &gt; function fnc() { 'use strict'; console.log(!!this); } undefined &gt; [1].map(fnc) false [ undefined ] &gt; [1].map(fnc.bind(this)) true [ undefined ] &gt; [1].map((x, index, array) =&gt; fnc(x, index, array)) false [ undefined ] ```
I would think the author's point is that indeed, if there are side effects, you'd usually use `forEach`.
I think the odds are very low that there's even one person reading this comment for whom this is a relevant performance concern at some point in their life, though.
What text editor is that? Or id it just plain design? And What color theme?
Thanks... What about if my timezone is GMT+1 it means that the API time is GMT+3
What???
For loops are way faster, since there is no callback to be called every time.
Why would those odds be low? For-loops are faster, some people (or to be more precise: some projects/approaches) care about that.
What about performance reasons?
so why not just use .d.ts then? instead of `jsdoc` write typings and use proper ES, it's a win-win, no?
i *AM* having a normal conversation. Normal for the person who had no arguments, normal for what you're doing. If you see other replies I did, I'm having normal as well, for what those people set up as a norm. e.g. https://www.reddit.com/r/javascript/comments/8r6p4y/i_feel_like_typescript_is_hindering_me_more_than/e0rcf3a/?context=1 When people make reasonable conversations, they get reasonable responses. That is all. 
How is `for` better than `forEach` in this sense?
&gt; This is just java being extremely verbose Many things come in to play to make it verbose, and of course a part of it is it's way of using types. I mean, a catched exception was a part of the method type as well... generics anyone? In a way, many things Java made at the beginning as improvement over C++ turned up to be a step back, not forward, and now there are: guard methods as a way of multiple inheritance, method handles as a way of function pointers, RuntimeException as a workaround to the catched exceptions... All these just added to the "boilerplate". I got rid of it by switching to JS. Oh, and Groovy/Grails was a big help in opening the more functional, more closure minded development. The only problem I see is people indoctrinated into "classical" development now trying to do the same to the JS ecosystem by moving what they felt comfortable with, not what is reasonable to have: TypeScript, classes in JS, now even this.#private properties to JS classes...
The spread does not create an array; it created an iterator.
can you even only do that? say I have some crazy Enterprise function `queryDatabase(xhr: jqueryXHR, args, cache = false)` how can I give the xhr its type without either jsdoc or typescript? as in make a type for each function? then I have to write two whole files I might as well be writing C header files...
&gt; First, you create &gt; three &gt; arrays here: a constructed array, spread into another array, and then mapped to a third. The spread does not create an array; it creates an iterator.
I'm saying that the [ ] around the spread is the new array and the spread iterates over that.
!?
Yes, iOS needs elements to be "clickable" in order to register click events. This means `cursor: pointer` or `tabindex="0"` etc. The easiest fix is to add `cursor: pointer` to the body if iOS.
Yes. That makes it two arrays, not three. Sorry if my nitpicking was coldly delivered; my intent was to help.
Because only very few projects should care about being that much (i.e. very, very little) faster, or are hitting the same loops so often that the speed differences actually sum up to a significant difference.
let's me try be clear on some things: 1. I'm using _WebStorm_ for development, and years before doing TS that IDE did pull typings and used them to do type checks while development. 2. So one way is to use an IDE that can do that, and another is to maybe setup the tooling to do the checks as per .d.ts on the .js files. I haven't needed this one, so haven't done it yet. 3. JSDoc is basically a declarative language you write side by side (in front of functions) JS code 4. Typings is basically a declarative language you write side by side (companion file) to JS code 5. JSDoc and Typings are both fulfilling the declarative goal header files did. 6. Although I'm not fan of all new things planned for ES.Next, one of those is @Annotations so that's the same declarative approach, with the placement of it in front of the ES function etc. Now, I don't say it's pretty, easy, or even a must, it's just a way one might go using ES without putting entire transpilation step in the development process.
If the issue is due to clickability, then wouldn't using a clickable element work as well as being more semantic? So a `&lt;button&gt;` or `&lt;a&gt;` tag?
There's no reason to put them on, it adds visual clutter. The indentation already shows the nested blocks clearly and cleanly.
Thanks for replying. Any links?
Yeah that's usually the solution. Generally, if it doesn't work on iOS then you have an accessibility problem anyway.
https://caniuse.com/#search=Accelerometer Doesn't seem to supported. However, here is nice article to look into - https://developers.google.com/web/updates/2017/09/sensors-for-the-web
or you remember a few things and suddenly your team can actually read your code.
No, you're good. However, I'm pretty sure the article's suggestion creates 3 arrays. `const arr = [...Array(100)].map((_, i) =&gt; i);` [`.map()` returns a new array.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
If your team can't read a for loop forcing everything into as few lines as possible and calling it declarative won't help you.
Sigh, okay. There’s a difference between forcing code into a few lines and not being overly verbose/horizontal. But if you’re going to just strawman the discussion into saying I try to code golf real world development because I think higher order functions are more readable than nested for loops then I have no response. To each their own, if your team likes the loops then you do you.
Not the person you're responding to but I do `{length: 5}` as well. It's just a micro-optimization in my head vs running the Array constructor code and returning `{length: 5, __proto__: Array.prototype}`
This is implementation specific today. Babel creates a new array
I did not say either of these things, try again. What I was saying is that the example in OPs post is overcomplicating the code by using higher order functions. The functions aren't the problem. Using them at every chance you get, is. Same goes for the spread operator.
Cool, that makes sense. At first I was thinking there might be a danger in _not_ using an Array instance for that argument but reading up on it more, it doesn't look like it.
```js arrays.reduce( (counts, arr) =&gt; arr.forEach( (num, idx) =&gt; (counts[idx] &amp;&amp; counts[idx] += num) || num), []) ```
https://carbon.now.sh
I don’t know how you jumped from ‘using higher order functions to solve this specific, simple ES potentially unexpected behavior that OP is describing’ to ‘using higher order functions every chance you get’. Are you projecting some frustration with style trends? 😂 OP’s code is very readable, if you can’t read it, I’m sorry to hear that, but it is objectively not ‘overcomplicated’ just because it uses a language feature that is not as ubiquitous as a for loop. I’m sure you will just tell me I’m wrong again though, so this seems pointless. Have a nice day.
ah yes, a fucking generator function, if we go retаrd, better go full retаrd
I only need an object with a "length" property. I don't really need a sparse array just for that. I also don't call constructors without `new`. You can't do that with classes and some of the built-ins behave differently if you do that. "new Array(5)" is one char longer than "{length: 5}". Anyhow, things would be much better with a "generate" method: Array.generate(5, i =&gt; 2 ** i)
&gt; console.log(arr[0] === undefined); // true WTF. What's wrong with just console.log(arr[0]); ? Why the use of an unexpected expected result? BTW His test there's something special about the array index 0. There isn't, it's the same for all other array indexes. 
It's not, and they both do a fine job conveying that you're looping for the side effects. forEach used to be a lot cleaner, since you didn't have to declare an index and reference it in the loop, and it scoped everything to the function, but that's no longer the case with `for .. of` and `let` &amp; `const`. Eg `for (var i = 0; i &lt; arr.length; i++) { var foo = arr[i]` hoists foo and i declarations to the top of the function. `for (const foo of arr)` scopes foo to the block. Some people still avoid the for .. of due to concerns that `Symbol.iterator` doesn't behave 100% exactly the same in IE due to how Symbols are shimmed (shammed) there, though I've yet to encounter any real world project where that makes any difference. for could be nicer if you don't want to have to convert to an array or use a big ugly `Array.prototype.forEach.call` on your iterable (eg on a `document.querySelectorAll`). forEach could be nicer if you already have a function you can pass in without wrapping it in another function (eg `files.forEach(saveToSftp)`. Both are fine and neither is better in an absolute sense. 
&gt; You could apply this same logic to literally anything anyone might not know. Yup. Welcome to leading a tech team. If you were just doing this on your own then hell, you can do brainfuck compiled to webassembly for all I care. If you're on a dev team responsible to a client then suddenly all that matters. As a senior dev, I have more important things to do than explain arbitrary js concepts to others because I chose to implement a bit of code in a convulated way. Here's another way to slice it: if the functional way is both more complex and less technically optimal, why would I ever chose it? To save two lines in my source?
Thanks. Here it is - https://join.slack.com/t/letterpad/shared_invite/enQtMzgxNjk5OTI2NTgwLWRlNjE4ZDEzMzE2ZmQzOWFjYTk0ZTA3ZDdjN2Q5ZTg5ZmNlZDM1MTQ0YzE4MzhkMDNiN2FjNzczZjk0MjZiNTU
It's not "clearer”. You can drop a value or replace it with another value, and most people would never notice.
I hate having these conversations cause it always seems like im calling someone wrong :'( 1. vscode figures out most of it for me let string = ''; and so on. I dont think I need an IDE especially one I'll have to get licensing for(?) 2. setting up tooling to do checks per typing per file?? you are literally writing typescript and then an implementation file? 3. yep but its wholly detached from the code so going `/**` `* @param {jqueryXHR} xhr` `*/` `queryDatabase(xhr, args, cache = false)` Seems pretty dumb when we already know its a param, we already know its name all we want is a type 4. I don't want to write a declarative file I want to have one file cause this is javascript and I rarely need to write multiple implementations and if I am I'm going insane and so will the person who has to maintain my code. 5. @Annotations are not declarations of types, though they can be used to sort of declare the intent by the nature of decent naming conventions. They are just functions AFAIK. So if you had `@logged` `queryDatabase(xhr, args, cache = false)` it would apply he 'meta'function called logged which would, say, write out something to a logger. Angular relies on it heavily to turn an ES class into a component or a service by attaching metadata and transforming everything. If you don't hate yourself and just use typescript as JS with types you're golden in my eyes. Finally I really do need the transpile process cause IE is still a thing in the enterprise world. In fact the only thing I dislike about typescript is it moves too damn fast with monthly releases, but then so does everything in the web world.
As someone else already stated, OP's "solution" is the most inefficient approach to the problem out of the options he got. Why would you go for that if there's a well established - at least - equally readable option that does not come with overhead? Because you use the wrong tools to solve a problem. Hence "using higher order functions every chance you get". Whatever, agree to disagree and all that.
Yeah... I came here to know what this is, see a image of a car and when I'm on desktop, ok, I'll do a quick search..on mobile I just read the comments and go away.
Contrary opinion here, but the average JS programmer doesn't understand currying. You should always be writing the simplest code possible, so whoever is maintaining your code understands exactly what's going on. The last thing you want to be doing is writing code which other people don't fully understand. This is how spaghetti is born.
Why wouldn't you want it in the uses local time?
[Seems like it](https://i.gyazo.com/a931a596ee5043f8d59046b30fcf8685.png). Got roughly the same results each time.
You can also break out of for loop which is very important sometimes 
Do yourself a favour and read this: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS Excellent resource on this. 
Wow, thanks! Do you know the color scheme? Really wonder why nobody has made a simple text editor like it
That's what I'm using, only is: $(document).ready(function(){ $(document).on('click', '#element', function(){ //do something }); }); Because the elements are generated dynamically after log in.
You are a fan-BOY. It sounds unreasonable and waaaayyy too emotionally involved.
CORS is not supposed to protect APIs, it protects normal web pages from cross domain attacks. APIs should not use cookies, so they should be immune to these attacks by default.
I belive OP is just having a laugh, mate.
I always did `Array.apply(null, { length: n })` to solve this issue. 
Domain does no matter, content is.
That would be summing up each array, not summing up each index across arrays. 
Ruby was an amazing first language to learn (though I didn't have a teacher, per se). Javascript with its world has done far more to ruin for-loops for me. 
I didn't have a teacher per se, but Ruby was an amazing first language to learn. Javascript, with its quirks, has done far more to ruin for-loops for me. 
Oh JavaScript 
One thing to note is that I don't think Array.fill works in any version of IE (only Edge) while Array.map works all the way back to IE 9 (without the arrow function in this example, obviously). Unfortunately, supporting IE11 is still a "thing", as it can easily be 10% of a site's web traffic.
np, it's open source now
You can easily write one yourself. While it would be nice to have it (e. g. as Array.create), it really isn't necessary.
can you try adding: return Promise.resolve(singleData); in the save callback? Right after the line: console.log("Item added: " + singleData); 
Or anyone not wanting their browser to take a gig of memory.
Monokai!
Meanprogrammer.com oviously.
Typescript won't help with that particular example, because it matches `parseInt`'s signature. 
Still I would not trust a single one of these “starters” for a real production app. If you need more control, create-react-app -&gt; eject (or use Next or Gatsby).
&gt; return Promise.resolve(singleData); Nope, still wont work... It's strange, the let newTodo = Todo(req.body).save() Returns an [object Promise], but the let newTodo = Todo(req.body).save(function(err,data){}) Returns an unidentified I dont know why the second one wouldnt be the same?
Why not `let newTodo = Todo(req.body).save().then(data =&gt; ...).then(() =&gt; ...)`
This seems to work and sorry for my ignorance but I would like to go with: 1. save data and listen for errors 2. Then go a fetch the updated version of data and not: 1. save data, then go and fetch the updated version of data and then listen for errors...
I think this is the reason: https://github.com/Automattic/mongoose/blob/master/lib/model.js#L362 https://github.com/Automattic/mongoose/blob/master/lib/utils.js#L219 if you pass a callback function to save(), save() just invokes the callback without chaining it. If you call save() without a callback function, it returns a Promise. https://github.com/Automattic/mongoose/blob/master/lib/utils.js#L232 I don't know why API behaves differently on remove(). Maybe open a PR/Issue on their github repo.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Automattic/mongoose/.../**model.js#L362** (master → 3fed6f0)](https://github.com/Automattic/mongoose/blob/3fed6f08116f8e9cfb038b7d8b04ee5e6d8fdcf7/lib/model.js#L362) * [Automattic/mongoose/.../**utils.js#L219** (master → 3fed6f0)](https://github.com/Automattic/mongoose/blob/3fed6f08116f8e9cfb038b7d8b04ee5e6d8fdcf7/lib/utils.js#L219) * [Automattic/mongoose/.../**utils.js#L232** (master → 3fed6f0)](https://github.com/Automattic/mongoose/blob/3fed6f08116f8e9cfb038b7d8b04ee5e6d8fdcf7/lib/utils.js#L232) ---- 
You can also "break" higher order function. Instead of `forEach` you can use `some` or `every`. Map by definition maps all values so is not interchangeable with for loop (`forEach` is).
So you mean i can select any domain and it won't limit my scope in future and i just focus on content is it?
Throw a `.catch(err =&gt; { throw err })` in the end of the promise chain.
You are a fan-BOY. It sounds unreasonable and waaaayyy too emotionally involved (at the expense of reason). ALL code you write is executed on the same kind of machine, using the exact same kind of architecture, and now people get as emotional over nuances as middle ages Christians about tiny differences in interpretation (there were thousands more groups than just the two now major ones). Take a step back (better a thousand steps) and become less deeply emotionally involved. If you need a pointer to some *truly* different kind of computation, take biology and biochemistry courses (excellent ones are free on edX, for example). Compared to the difference between how that system works and any(!) form of human-made programming the difference between various types of the latter are next to non-existent. Especially since it all runs on the same machine (CPU).
Oh, I know, I was just using the mention of static typing as an opportunity to mention TypeScript. It won't fix that particular issue because of the way `parseInt` works, and static typing won't fix that, but it will give you a lot of protection from other issues.
Even a .catch() wont solve it becaus the newTodo is still undefined.
so cors its something on the wb or the page that requests it
then just wrap the save functionality in a Promise, something like: const p = new Promise((res, rej) =&gt; { Todo(req.body).save(function(err,singleData){ if(err) { rej(err); return; } console.log("Item added: " + singleData); res(singleData); }) }).then(data1 =&gt; function(data1){ Todo.find({}, function(err, data){ if(err) throw err; res.json(data); }) });
Thats really strange... Thanks! Just opened an Issue: https://github.com/Automattic/mongoose/issues/6603
Then do this: app.post("/api", bodyParser.json(), async (req, res, next) =&gt; { try { const singleData = await Todo.create(req.body) console.log("Item added: " + singleData) const todos = await Todo.find({}) return res.json({ todos }) } catch (err) { return next(err) } })
I didn't really read more after the section about null. It just seemed so silly to me. Like this &gt; Default arguments treat Null as valid, i.e. pass Null into `someFunc(someParam = 'default value')` and `someParam` will be Null. Like what is this supposed to show? If you passed 1 as a parameter then `someParam` would be null. And then this &gt; For instance say you wanted to store if a person has hayfever, how would you store it on initialisation? Which doesn't really seem like a good example since by the sound of it you would need a bool, and in the "Hence why so many languages (C/C++ and Java included) use it [null]" list you list languages which doesn't have implicit types, and for a bool the default value would be `false` rather than null in those languages.
&gt; You can easily write one yourself. I won't modify objects I don't own. &gt; e. g. as Array.create I'd use "generate". It's the best fit. It's also what Dart uses (List.generate). &gt; it really isn't necessary Same goes for map, filter, reduce, etc. None of that is necessary. Absolutely necessary is very little.
Thanks. You're right. Not sure what I was thinking on that one.
The OP himself is complaining about Typescript compile errors.
you are right. it is not the right sub.
CORS is enabled/disabled on the server where the request is addressed - so in /u/IamfromSpace's example it would be the Bank API.
Well it looks like medium from outside but from inside it is different.
The spread operator also doesn't work in IE11, so both solutions will have to be polyfilled.
Unit tests can find logical errors - of which type errors are less than ~5%. Typechecking alone leaves you exposed to most bugs. This is an obvious consequence of the halting problem. &gt; Have you ever programmed in a language that had sum types and let you pattern match on them? Sure.. but that has no bearing testing that your algorithms solve a given problem or not. I'm not sure what causes you to equate those. Type correctness is a very very small part of algorithm design...One I've become convinced by experience is not worth the human overhead. 
Hm. Does it read as an emotional article? Didn't mean for it to, but I'm pretty new to writing so maybe it was read by some people as trying to be persuasive. Just to clear the air, my goal was to teach my readers why you can't map over a constructed array as you might expect, and definitely not to convince you that this approach is better than any other approach.
This problem is getting to the hacky portion but because it it still simple it's okay. I would probably use one of derailed's solutions but here is a solution that doesn't use any sort of indexing. It also shows just how much packing of information you can do with arrays, which is a good thing and a bad thing. function padArrayWithDefault(arr, n) { while(arr.length &lt; n) { arr.push(0); } return arr; } var arrayOfArrays = [[1, 2, 3], [1, 2], [1, 2, 3, 4]]; var longestArrayLength = _.max(arrayOfArrays, function(i){ return i.length; }).length; var keys = ["a","b","c", "d"]; // Dynamically somehow var structured = arrayOfArrays.map(array =&gt; { var commonLengthArrayBecauseZipHasLimitations = padArrayWithDefault(array, longestArrayLength); var kvp = _.zip(keys, commonLengthArrayBecauseZipHasLimitations); // [a, 1], [b,2], [c,4]] var objects = _.object(kvp); // {a:1, b:2,c:4} return objects; }); var result = _.keys(_.first(structured)).map(key =&gt; { //SelectMany(x =&gt; x.Value).Sum() var pluck = _.pluck(structured, key); return pluck.reduce((s, f) =&gt; { return f + s; }, 0); }); console.log(result); // Array(4) [ 3, 6, 6, 4 ]
The example code (see the edit code button on top left) is a tiny self-hosted js compiler. At the very end you can see that the compiler compiles 10 lines of code. The internals of compiling these 10 lines get then visualized.
Make the request to reddit API from your own web server, then return it back to the client side.
I have no experience with Mongoose, but doesn't this do what you need? app.post("/api" , bodyParser.json() , function(req,res){ Todo(req.body).save() .then(newTodo =&gt; Todo.find({}).exec()) .then(data =&gt; res.json(data)) .catch(err =&gt; { /* Error handling here */ }) })
Why do people just hate at every OO part of JS? * `null` \- How would someone represent emptiness * `typeof` \- Yes, there are some standard issues * ASI - Semicolons should've been mandatory from the beginning * Floating point integers - What other standard would you choose, considering JS is loosely typed? * ES6 class binding - Its just one thing to remember in event based architecture (mostly backwards compat) * Pass-by-ref and Immutability - Your users memory is limited (they don't have infinite amount of RAM)
It’s done only by a browser. Anything that makes web requests that you _explicitly request_ don’t bother with CORS (curl, postman, your URL bar, etc). However, your browsers loads scripts that make requests on your behalf. The browser can’t be sure that one website isn’t trying to hijack the credentials of another, so it enforces CORS.
The second one works because it is calling `Query.prototype.remove`. No part of the code has a handle on a Model. But yeah the first case is definitely a documentation issue since the intent is clear from the code.
[CORS for Developers](https://w3c.github.io/webappsec-cors-for-developers/)
Exactly, my other comment talks about enforcement, and you’re correct that it is enabled or disabled at the server. So browser == enforcement and server == enablement.
I can recommend learning by doing. Start by hacking together a static playground website, practicing the native API and then slowly turn it into a silly hobby project. That way I found it much easier to grok the more complex concepts like Javascript's object context (the curious case of '*this*'), promises, iterators, functional programming techniques etc. It's more accessible with a real application not just imaginary examples. By the way if you're interested in functional programming there's [a YouTube channel called funfunfunction](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q) done by an awesome Swedish developer. Instructive as well as entertaining.
someFunc(1) will pass 1. someFunc(false) will pass false. someFunc(null) will pass null. someFunc() will pass undefined. If you treat "null" as undefined, you're going to have a bad time. As for true/false/null, the other languages you listed all have "boxed" booleans which allow you to set vales for true, false, and "not known yet". In javascript, null means "not known yet".
Check out Aframe, it has what you’re looking for
&gt;null - How would someone represent emptiness Maybe monad? &gt;Floating point integers - What other standard would you choose, considering JS is loosely typed? Big integer? &gt;Pass-by-ref and Immutability - Your users memory is limited (they don't have infinite amount of RAM) Still would be nice to have them by default instead of the other way. Something like Scala's val and var would've been really cool. But, yeah, I agree that there are no good reasons to hate on OOP. But I guess going full FP makes you seem edgy but still mainstream.
I don't understand his problem with `null`, though I could understand people confusing `null` and `undefined`, which is also a valid value. The only real `typeof` quirk is `typeof null`. All the others make a lot of sense. A data, an array, a regex, ... they're all objects. The `pass-by-ref` thing is interesting, because JS actually DOES NOT pass anything by reference, or at least not the way other languages do it. In other languages: when an argument is passed by reference, the caller and callee use the same variable for the argument. If the callee changes the argument (by assigning a different value to it, for example), the same will happen to the variable in the caller. So in that sense, JS passes by value, the values are mostly mutable objects though. Maybe the confusion comes from the way PHP does this? By default it also passes values by value, but it always passes objects in a copy-on-write way.
&gt; I scroll up and down multiple times the extra text will move up or down seemingly randomly. The text disappears after a couple seconds. It could be that there's a CSS animation rule applied to the element. Otherwise, it looks like a browser rendering bug to me. Because the result is inconsistent.
There may be a (hacky) solution, but it depends on the code - which is unfortunately, not provided.
1. vscode is not up to pair to webstorm, and it *is* an IDE (with all those plugins). I just don't mind getting a licens for something that I consider an essencial work tool (one that allows me to be more productive i.e. get better salary) - so, IDE/Editor, whatever, that's what you need static type checks by 2. you're also setting up tooling for TypeScript/Flow/whatever that isn't the standardized supported ES, so no argument there 3. JSDoc *is* code, albeit not idiomatic to ES, and especially latter years there's no development there, still, I put it there as a reference 4. when you're writing TS you're writing a declarative file, one that gets transpiled to JS, so yeah, TS is not JS (the tooling argument), and the people who will need to maintain your code more or less will go insane whatever the code does, it's legacy, foreign to them 5. @Annotations (named decorators in the ES lingo) are everythiing you want them to be, considering there are @NotNull annotations in Java, you can also imagine a decorator of the kind `@types('Xhr','string[]','boolean')` like you noted in number 3. That decorator will be - part of the idiomatic language - declaring just the types (no unnecessary repetion) - no need of another language bolted on top of ES Time will tell. On few tangents (just to provide context of my different view on things): - Please don't mind how awkward Angular is, it's just how Google/Python/Java institutionalized people understand the world, thus make TS/JS code that looks like it. - I can say I don't want to use TS just because of the transpilation step, but that's just part of the problem. The other one I have is with the way big companies push for type systems to be(have). - I mean, if you look at SOLID, the I there stands for many specific interfaces, usually a bundle of a method or two... well, another way of looking at it is duck typing with an interface keyword :) - Big companies that support the platforms/ecosystems don't need artists in the programming art, they need biological parts in the code generators (I wrote in some other commend about this), so the mantra, nay, the dogma is "we can't reason, we need static type checks, then we can feel safe". It's just not for me. 
Interesting take. I’d say most seniors are that way because they can tell the team is heading towards a cliff and trying desperately to avoid them driving off it. Seniors also need to learn the new frameworks so when they’re code reviewing they at least know what to look out for when it comes to possible problems. The onus is on them for releases to go smoothly with as few problems as possible. I feel like most of your statements can be boiled down to communication problems, and not taking things personally. Are there better ways of communicating that something “is terrible”? Of course, does it come from a place of experience, probably. Do you know they are in fact wrong? Possibly, try sitting down with them and explaining the situation.
[removed]
Hi /u/Irocidar, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'.
Hi /u/matthiasberlin, For javascript help, please visit /r/LearnJavascript. Thank you!
Apparently krpano has a [Gyro2 plugin](https://krpano.com/plugins/gyro2/). To be honest, while I've used krpano a number of times, I can't really say anything about the plugin. It's based on the `devicemotion` [event](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent). On the other hand, as has already been mentioned, browser support for all this is very experimental so...
The issue arise when adding lines that should be scoped into the If statement.
&gt; is it actually possible, using the client side only, to fetch resources from a different domain? yes, **if the domain allows it.** The server has to explicitly allow it though. If you have access to the server, you can change it to allow this to happen. If you don't have access to the server, you need to use a proxy. &gt;it won't work, but what is the easiest way to make it work without a proxy it won't work without a proxy. &gt;i don't even understand why it has to be that hard, why can i fetch normally on the back-end or even with the curl command but not in the browser? [this answer](https://www.reddit.com/r/javascript/comments/8rn8ja/i_dont_understand_how_cors_works/e0t0brz/) explains it
is there a way to check which websites allow such behaviour and which don't? i eventually gave up and started using express.js, but i've never been able to fetch using the client side only - steam, yandex, flightrader24 - none of these seemed to work for me.
Before trying to understand CORS, let's break down something called the "Same-Origin Policy." This is a web security mechanism enforced by browsers that prevent websites from accessing resources on other websites of a different "origin." An origin is just the combination of protocol + domain + port. In other words, the Same-Origin Policy disallows the following scenarios: 1. https://example.com makes a request to http://example.com/api/cats (the protocol is different, https vs http) 2. https://example.com makes a request to https://mysite.com (the domain is different) 3). https://example.com makes a request to https://example.com:8000/api/cats (the port is different) As I mentioned, it's a security measure. The classic attack scenario is the following: I visit my bank's website (www.mybank.com), login, check my account, etc. During this process, a session cookie is saved in my browser. Next, I browse reddit and click on some random link (www.evilsite.com). Unknown to me, this is actually a malicious site that makes a request to my bank's API using the same session cookie stored on my browser! However, because the domain is different, the Same-Origin Policy saves me and my browser blocks this request. Ok, now onto CORS. CORS (Cross-Origin Resource Sharing) is a way to *relax* or *circumvent* the Same-Origin policy. In some scenarios, you want to make requests to a different origin because it's trusted. Example scenario: you host your static resources using a CDN service which has a different domain; you want to make requests to this CDN to grab your assets, but the browser keeps blocking you due to Same-Origin Policy. You can use CORS to make this happen. Here's a simplified version of how it works: 1. Your website (https://www.example.com) makes a request to a CDN to grab static assets (https://www.cdn.com). Note that it's a different domain, so this violates the Same-Origin Policy. 2. When the request is received by the CDN, it checks the Origin header and attempts to validate it. You've configured the CORS settings in the CDN to allow https://example.com. It sees this and then attaches an "Access-Control-Allow-Origin" header in the response. 3. The browser sees the Access-Control-Allow-Origin header in the response, sees that it's a validated origin, and allows the request to go through. 
I don't know of a way without making a request to the resource and seeing if the `access-control-allow-origin` response header is set to allow you to request it.
I used it for production and whenever i see anything needs to enhance or refactor I'm doing it immediately, I need to take control over everything is going on behind the scenes! 
Hi, Sucrase author here! (Just noticed this thread.) A few thoughts: * The intended use case, for now, is development builds. Most of the time, unit tests and dev testing happen in a modern browser or modern node, so if compile times are painful, you might be able to drop in Sucrase and make local development more pleasant. You can still use Babel for production builds and when running unit tests in CI, since they generally don't need to be fast. This also means you don't need to trust some guy's side project when shipping code to real users. The downside, of course, is that the code running in development and production is different, so you might occasionally see bugs in one but not the other. It's a tradeoff that I'll let others decide. * A longer-term thought is that IE usage is getting lower and lower each year, and eventually it will be acceptable to drop ES5 support. Hopefully Sucrase be there for when that happens.
`null` is the big one that bothers me ... Given other languages with actual optional types it feels so clunky. But you really need to structural the whole language and standardlib around optionals for it to make any kind of reasonable sense.
You're right. I misread the first post, sorry.
While /u/IamfromSpace is totally on it, it's important to stress that CORS is ONLY a web-browser restriction. Your browser is not letting you make requests from one domain (A) to another domain (B). There is an interface for a server to tell the browser that it would like to disable the security restriction for certain requests, but most web server frameworks do not disable this restriction by default.
Yes.
eh. If you have the memory, use it, otherwise it's wasted. Embedded devices, which I spent the last 6 years building web apps for, tend to not have very high powered CPU or much RAM, but modern JS toolings don't care the slightest bit about that. :-) 
Bingo, exactly.
No worries, dude!
The outer function is only called once, so `x` set to 0 once, now you get a function back from the outer function that contains `x` in it's closure scope. The reason `x` is not being reset is because when you call `result()`, only the inner function is executed, not the outer one. The value of `x` is retained in memory as long as a reference exists to it. The anonymous function has reference to `x`, and you have a reference to this function, so you indirectly have access to `x`, that prevents it from being garbage collected. And finally each time you call `func()`, you get a different function in return. So calling `func()()` repeatedly won't give you the same result as calling `result()` repeatedly. In the previous case you get a new function ever time, each with it's own internal `x`, but in the latter case you are calling the same function repeatedly that performs on the same internal `x`.
&gt; Does it read as an emotional article? I replied to a comment of yours.
I didn't have a teacher per se, but having a fixed thumb was an amazing thing to have. An opposable thumb, with its quirks, have done far more to ruin [complex tool making] for me.
`null` is not something new, it has been around for ages (from the origins of C). `undefined` is actually the extra thing in JS, which again is pretty much self explanatory. People think that they have a problem with something, where they actually don't.
I read most of it and I still don’t know 
"How to use a hammer as a toothbrush" - Craig Taub
Maybe you just havent done the kind of development where you would appreciate static typing. If you'd ever done for instance, Domain Driven Design with a very complex set of objects as the evolving domain layer, you might appreciate types, classes, access modifiers and whatnot a little more. Im working on a project like that right now with Java backend and Angular frontend and honestly I'd hate to do this with say pure JS.
JavaScript. Not java 
Not dumb questions at all. The other reply gave a vey good answer, so I won’t repeat it here. It might help you if you realize that functions in js are not just some lines of code you can execute, but an object like any other. With closures, they can have an internal state, like you discovered. Even in languages without objects, you can use closures as a poor man replacement. And in languages without closures, you can use objects as a poor mans replacement. In essence, they are equivalent. 
Use your console! var buttonend = '" class="button-style-css button-style-css-large button-style-css-green"&gt;&lt;span&gt;Commencez votre magasin gratuit aujourd'hui&lt;/span&gt;&lt;/a&gt;'; there's an unescaped ' in this code, swap it to \'
Not dumb questions at all. The other reply gave a vey good answer, so I won’t repeat it here. It might help you if you realize that functions in js are not just some lines of code you can execute, but an object like any other. With closures, they can have an internal state, like you discovered. Even in languages without objects, you can use closures as a poor man replacement. And in languages without closures, you can use objects as a poor mans replacement. In essence, they are equivalent. 
Sure, I'm not disputing any of that. However, just because something's been around forever doesn't mean there aren't better alternatives.
Primitives to build simple, flexible, WAI-ARIA compliant React autocomplete/dropdown/select/combobox components 
Rock on! You'll of course want to do the usual: go through online courses, attend local javascript meetups, and build actual projects for yourself, for friends, or for any small clients you can find. As for here at /r/javascript, read articles that get shared, participate in discussions, and read the description before you post so it's relevant to the topic at hand (in this case, the topic is "Post a link to a GitHub repo that you would like to have reviewed").
&gt; \' Sorry, what exactly would I be swapping to /'
I have done a lot of different dev, languages, frameworks, and can never appreciate the little gain vs the big pain of static typing
Not saying you were wrong, but I just wanted to mention that if you were using relatively simple microbenchmarks on fake data sets, they can be very misleading because the engines are typically smarter than most simple benchmarks.
the string needs ti be in quotes, this code is in single quotes and &gt;" aujourd'hui " is ending the quote early, so it tries to parse it - so make it &gt;aujourd\'hui
Well ok you must be right everyone else must be wrong
They both look the exact same to me? What am I missing here?
’ vs '. Curly quotes vs dumb quotes.
i assume you're on mobile and it's being parsed weirdly, there should be a backslash before the singlequote before &gt;aujourd'hui after &gt;aujourd\\'hui did that make it render
I disagree about how useful types can be. Both for proving correctness and making it easier to understand what a program is doing. On top of that, types are much less of a maintenance burden than unit tests. In some cases they actually make it EASIER (sometimes by a lot) to refactor your program. I would agree with you if we were talking about maybe java or c's type system though, instead of all possible type systems.
&gt;’ vs '. Curly quotes vs dumb quotes. You should always use curly quotes for typography, btw. Hmm, I tried using the curly quotes and I still could not get it to work. Then I removed the aujourd'hui word altogether and it still doesn't work.
Now the console says: Uncaught TypeError: Cannot set property 'innerHTML' of null Btw, thanks for telling me about this, I had not idea console existed.
Call by value is not correct either. The term is [call by sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing).
Ruby has one idiomatic (non-function) way to loop over a range of numbers, the elements of an array, etc. (in this case the numbers 0 to 5, inclusive): for i in 0..5 puts "i is #{i}" end Meanwhile, JavaScript has `for` for numbers, `for in` for objects, and `for of` for arrays. I know which one I prefer. There is no reason a beginner should be doing anything particularly complex, with or without Ruby. There is also no reason to consider JavaScript particularly well suited for complex tasks. Your analogy with fixed and opposable thumbs hits so far off the mark that it's not even insulting.
I'm skeptical of the performance concern here. Yes, in theory it is less efficient to do it the functional way. But have you benchmarked the difference? What environment are you in? How often is this function called? I think you'll find that in practical applications, the difference in performance is irrelevant. In the browser especially, DOM operations are usually so slow that the time spent executing JavaScript code is a tiny percentage of a typical function call. So great, you got your JavaScript execution time from 20ms to 18ms. Now wait for the browser to spend 250ms performing the operations your JavaScript requested. I also don't love the argument about making it easier to read for junior devs. Junior devs should, and often do, know about basic language features like the spread operator. It's silly to account for their possible ignorance here, not only are you handicapping everyone but it's really quite patronizing to juniors.
Well, if everyone says earth is flat, does that make it right? O.o Jokes aside, it's hard to see it can be different if you've been in a bubble. Luckily, I've done a lot of different dev, not just C family languages, so...
Dude fuck off
The OP is just one developer, not all "new devs".
Types are somewhat less effort than writing unit test - which makes sense because they do not do nearly as much validation. Since unit tests also catch everything that types do, it feels like pure waste - and thats only counting the initial implementation time, not even counting the inevitable refactors that types introduce. And types do make it easier to refactor, but not using types makes it less likely to ever need to refactor at all, because everything can be modular and self contained. I feel that proponents of typing often sacrifice code isolation and modularity, because they have to import other types from other codebases. Its very hard to both have types a not have spaghetti. I had a haskell team working under once- I only allowed it because they were so passionate about their tools. In the end, it seems like the spent most of their time fighting their tools and very little time actually solving business problems. Its one of the experiences that led to my current opinion. 
Most cities will have monthly meet ups. It’s a great place to meet other developers and learn a lot of cool new things. I believe there is a website that has a bunch but a simple google search should point you in the right direction 
Maybe. I would like to see the code base where performance is that imperative that porcedural code is refer to functional because it's come down to that and there's no other options. Swapping these functions out is never going to be the lowest hanging fruit.
The french page uses button2 as it's id but both your other pages use button1, might be because the js stops getting evaluated if it finds that there isnt a button1 that exists on the french page? The other pages get that same innerHTML error but it's a line later. 
If login happens after the document is ready then `#element` may not exist when you're trying to attach the click handler. If you weren't using jQuery you'd probably see an error in your console but jQuery just ignores the problem if it finds no elements.
Damn that beard
Getting "application error" when I go on the website. Will try later because that sounds amazing. What a great idea! I was looking into doing something similar and display it on a screen with my raspberry pi.
Thanks, that was very helpful. 
Thank you!! It looks like switching that over fixed the problem I was having! I'm pretty sure that I had changed it to button2 because button1 was not working either the first time around (the pages were all copied from the original). So I had done some tinkering with the code trying to fix it. Now that I've switched it back, it does seem to work, but I am also not using "aujourd'hi" in the button text anymore so maybe it was a combo of the two things. Either way. FIXED! Wasted way too much time on this. Thanks Reddit!
Its okay now. Maybe temp hiccups from heroku
How would it be smarter for the engine to make itself appear slower than it actually is? If that were the case, I would expect optimizations in the forEach to shine even better, not fall to pieces. But no, I benchmarked both the individual tasks and the overall job of processing a single whole dataset in a number of ways. 
Can we stop calling everything "hackable"? It's not hacking if the piece of software intentionally provided the means of customization
Yea he’s probably an outlier, good point.
Didn't even need to look at the url to know this post was on Medium
no problem, glad it worked!
Thanks a lot man! I got it to work by using aujourd&amp;#39;hui Works like a charm now! Cheers
I'm not going to even pretend to understand all of this, but my takeaway from this walk was that it is difficult to test performance of microbenchmarks. https://www.youtube.com/watch?v=65-RbBwZQdU
try this? const onerr = err =&gt; {throw err}; const reply = res =&gt; data =&gt; res.json(data); const validate = (err, data) =&gt; err ? err : data; const find = data1 =&gt; todo.find({}, validate); const api_post = (req, res) =&gt; Todo(req.body) .save() .then(find) .then(reply) .then(validate) .then(reply) .catch(onerr); 
Getting Application Error after refreshing from an AuthError that redirected me to #error=state\_mismatch
Yes, I'm aware of the complexities of benchmarking, which is why you back up you results by actually profiling the live code afterwards. 
Sounds like you got it covered then since you are using live code and real data then. :)
meetup.com. Sign up, pick your city, and you can scroll through existing meet ups, or try to start your own. I’ve been to a few in the Boston area I found through there
He's Mormon, stay away from library
Thanks for replying :) I completed the project this morning and didn't bump into any more issue regarding that module.
why so salty?
&gt;null &gt; &gt; \- How would someone represent emptiness Can't speak for the article, but JavaScript has TWO null types for some godforsaken reason. Obviously I understand the difference, but it makes for very poor developer ergonomics.
Definitely aframe. Don't use krpano
I settled on `[...Array(3).keys()]` which seems idiomatic JS to me and I also find more readable than the alternatives.
I read the entire article, but I found myself shrugging with almost every point. The only one I empathized with is the numbers.
If you learned JavaScript in the last year, you should have learned spread operators. If you learned JavaScript more than a year ago, you've had at least that whole year to learn spread operators. If you have junior developers who don't know JavaScript, the blame is on you or whoever hired them. If you think `Array(100).fill()` is equally readable or better than `[...Array(100)]` and it's as performant or better, there's no reason not to use it. But if your reasoning is "dummies who should not have been hired in the first place can't read it," that's bullshit. My issue is with your bullshit, not with the your preference.
I'd recommend taking advantage of the object-oriented capabilities of JavaScript and most programming languages - namely [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes). That way there is a standard set of properties to be expected (stuff like defBase and blockChance), and you can just make your individual items from that class.
WTF does that have to do with anything?
I'm not sure what you're getting at. I think you may be overthinking this.
I've just read Kyle Simpsons new book "functional light js" highly recommended for those interested in doing FP in JavaScript. 
when you want to learn and better yourself.
So fucking annoying right?
Use classes, I am using classes for characters(all things that can move, kind of like unreal engine pawns) and another for weapons, i even have a weapon applied in the character class that allows me to just feed the weapon object into it
Whenever. If there's a framework that has the tools to help you build faster try it out. Just pick a framework and learn it well. I chose Vue.js, it's all about preference.
Typically if a framework has a large list of features that you would use, then it could speed up development. Or you can start off with a framework that may have a ton of features, but you are only going to use 3 or 4 of them, you could replace that functionality with vanilla js later on and reduce the baggage of a full framework.
it's the worst
When you understand what it is doing for you and when it is the wrong fit
For a quick and dirty project, I would make a json database (object) of weapons, another of shields, another of any types of equipment. Then, I'd make a character class that has hp, mp, and whatever else you want to spec them with. It would also hold a weapon, armor, etc, each of those is a class itself with and their instance specs populated from the json database. There are other ways to do this, but this approach, in my opinion, would give you a good mix of flexibility, speed, and expandibility. 
The naive answer would be "always" but unfortunately that tends to backfire mid-to-long term. There are two main problems when you depend on a framework. The first is that frameworks always are trying to be "full stack" these days. They feel it's a badge of honor to offer a solution that does absolutely everything from configuration and injection, through services, persistance, validation, and user interface. While it's a badge of honor for the framework author, it's mostly a trap for the framework user. A "full-stack" framework prevents modularity and typically encourages a flat "spaghetti" type of application where code is at best categorized by horizontal type (controllers, views, models, helpers, services, templates...) instead of by structure of small, encapsulated independent modules that are built for reuse and flexibility. You can avoid the trap of the "full-stack framework" by interfacing with its features selectively and defensively through adapters, rather than embedding your business logic and core functionality into framework artifacts. But the temptation will always be to give up and follow the help manual that factors everything as flat framework artifacts. The second problem is that your app is *your specific* app, with *your specific problems and goals*, while frameworks are built for some "generic app" that exists basically only in the mind of the framework author (and is polished and refined through imperfect feedback by the users). When you use a framework you're locked to the way the framework author thought, the problems he stumbled upon and the way he decided to solve them and understand them. Unfortunately for you this means your client may ask for something that's quite basic in a custom app, but in your framework it'd either create a mess, or is outright impossible (without forking the framework). So to not fall into the trap of that second problem, you must understand the app you'll be developing very well, to make sure "its shape" matches the "shape of the framework" you'll use. Otherwise there will be a bad impedance mismatch between you app and your framework, and you'll have to tell your client "sorry the framework can't do that" a lot.
Eh, Oracle is dying. They are hemorrhaging money trying to build up their "cloud" products that no one has ever heard of. Sure they made a lot of money, but they can't continue on like this much longer.
Isn't that why everyone calls it golang?
I second this! Still working through it but he's just a damn good tech writer. 
Is what the framework offers something you'd rather write and maintain on your own? If not use a framework
If you could post an example of a timestamp you're getting from the API, that would help us to give you more specific advice. Is it a datetime string in some format like "2018-06-18T15:30+03:00" or maybe "18 Jun 2018 15:30 GMT+03:00" (or even without the explicit timezone), or is it a given as a number of seconds or milliseconds?
I found this vidoe to provide a good visual of a closure along with some other topics. https://www.youtube.com/watch?v=QyUFheng6J0&amp;t=2s 
Go with Python as first language 
Probably not. You will learn lots of terrible habits no matter what language you start with. Better to get learning the bad stuff out of the way early, so good on you for prepping. Nothing like experience.
Learning JavaScript badly will. It is the difference between an engineer and a developer. The trick is to learn the fundamentals of programming. Then you can apply those patterns everywhere. Hint: Learn TypeScript if you want something closer to other languages (java, c#)
JavaScript is an incredibly useful and flexible language, and learning JS first won't prevent you from learning other languages in the future. There are definitely some advantages to learning some other languages as well, maybe a statically typed compiled language, or a more purely functional language. Learning more languages will expose you to more ideas and patterns, which will help you in all of your languages. 
How do you use Go with Python? 😁
I'm Gopher 😂😂
I wouldn't waste your time with him. He is a fanboy of nitpicking. ;-)
A quick web search should reveal the primary language that your CS degree will focus on, it would probably be best to focus on learning that language. If in doubt you should focus on https://www.edx.org/course/cs50s-introduction-computer-science-harvardx-cs50x (don't pay for the certificate) it will teach you a little about C, Python AND Javascript (as well as SQL) and you can find out for yourself which language you're most comfortable with. A good CS curriculum should leave you with the ability to adapt to any language, so it's probably best to start with a language whose learning resources tend to teach programming fundamentals and not just syntax the way that the great majority of Javascript learning resources tend to do. 
Run a function that sets a value in memory when cb is clicked. Then interrogate that object in memory, much faster than looping thru the dom 
I dont remeber the correct 'on' method, may onchange() 
Use classes and factories 
Definitely not. I learned JavaScript first and it was all I used for many years. Since then I've learned Java, C, etc. and I've noticed no downsides. Every language has it's quirks that you have to get used to that might take a second to remember/forget when switching between languages.
JS is definitely weird and inconsistent on some fronts, and it's definitely possible to pick up bad habits from JS. That said, I think the effect is over-stated, for the most part. To learn programming effectively is more about how to think about and break down problems than any specific technology. In that regard, JS is no better and no worse than most anything else.
This is what I did. It can be a rough path, but for me it was the right path. I'm a UI/UX designer so naturally JavaScript spoke to me first. I couldn't really make sense of things in the beginning, but once I dove into React and Angular - I started to learn the high level patterns and techniques that carry over from language to language. This stuff allowed me to dive into .NET and PHP projects within my department without a whole lot of struggle. Like mentioned by dwighthouse, there is nothing like experience. So the more comfortable you are looking at the code the easier it becomes to work with. 
Just use: document.querySelector('.YourListSelector input[type="checkbox"]').addEventListener(function(e){var el = e.target;}); e.target is the element clicked
 function onCheck (checkbox) { const { checked } = checkbox; const { name } = checkbox.dataset; console.log(name, checked); } &lt;input type="checkbox" onChange="onCheck(this)" data-name="something" /&gt;
&gt;It is the difference between an engineer and a developer. What separates the programmers, coders, and hackers from the engineers and developers?
No? The only way it will mess you up is that you will develop a disdain for heavier weight programming languages (Java), and you will be consistently be disappointed by other language's package ecosystems and open source communities since you will be spoiled to the core by npm and package.json.
This doesnt work as im not putting the input fields in with HTML im building them using DOM for multiple reasons. Code looks like this: function loadUploads(){ fetch("restservices/algemeen/uploads") .then(response =&gt; response.json()) .then(function (myJson) { for (const uploads of myJson){ var row = document.createElement("tr"); row.setAttribute("class", "hover"); var uploadsInhoud = document.createElement("td"); var checkbox = document.createElement('input'); checkbox.type = "checkbox"; checkbox.value = uploads.inhoud; checkbox.onChange = "onCheck(this)"; checkbox.id = uploads.inhoud; uploadsInhoud.appendChild(document.createTextNode(uploads.inhoud, checkbox)); row.appendChild(uploadsInhoud); row.appendChild(checkbox); document.querySelector("#uploadsLijst").appendChild(row); } }) }
&gt; checkbox.onChange = "onCheck(this)"; Change this to `checkbox.onChange = onCheck.bind(null, checkbox);`. You could also have `= onCheck` and change the parameter of onCheck to the event, and access the checkbox via `e.target`.
The engineer is like an architect who knows how to put together a building. The programmer is the skilled carpenter who can build it. A coder is a guy who only works on his own house. 
This worked man, thank you!
The most significant risk you face with JavaScript as a first language is that you end up, learning about / frustrated by, bugs in the language design, rather than the core problem of structuring your problems and ideas into algorithms and ultimately solutions. As long as you have adequate support to resolve the issues that arise and the patience and dedication to learn and work through these issues you will be fine. On the other hand if you pick a better language you may learn more about how to organize your ideas and create algorithms. On the plus side there are fantastic JavaScript implementations on both the server and client side many significant platforms.
Great software developers create a solutions that is clear, simple, easy to understand, and malleable to change. This does not strongly depend on the use of specific tools like TypeScript / JavaScript. On the other hand prejudice about specific tools and techniques is common among software developers because the path to great solutions is not well understood.
Instead of binding event listeners to each checkbox individually, bind an event listener _once_ to a common ancestor of all your checkboxes. Events will bubble up from your checkboxes and be captured. Here's a demo: https://jsfiddle.net/alexb/bk7x9scg/ This way you can avoid having to keep track of elements as you add/remove them. The common ancestor could be your table element, or even the entire document itself.
Hi /u/ilikeminion, For javascript help, please visit /r/LearnJavascript. Thank you!
Nice!
Hi /u/twattty, there's no need for that.
First, I take no issue with the spread operator. We use it regularly and every dev on my team knows what it is and how it works. My concern is that the *reason* that it is being used here is obscure (that is the entire topic of the article). I could explain it in a comment in the code, but then why not just write more literate code in the first place? Second, we hire people for their technical ability as well as their analytical skills, communication etc - we are a mid-sized tech consulting firm. For me, not knowing the spread operator is not in and of itself a reason not to hire someone. It takes about five minutes to learn and understand so the fact that someone knows it tells me nothing of their technical ability. Hell, I only started using it a year ago when I started my current position because we weren't transpiling at my last company.
Geocoder is the Maps search tool: ``` this.geocoder = new google.maps.Geocoder(); this.geocoder.geocode({ 'address': &lt;your string here&gt; }, (results, status) =&gt; { if (status == google.maps.GeocoderStatus.OK) { let loc = results[0].geometry.location; this.map.panTo(loc) return loc; } else { return null; }); } ```
Honestly when is something like React not a good fit? Anything that's more than a bare bones website could benefit from a framework like react?
I had to replace the `\"` by `\\"` and `"` by `\"` in the script and passed that to `eval`, now I can get the latest result in the operations stack from `eval`. The reason I din't post the script is that it's not known beforehand either.
Maybe use classes, interfaces and some inheritance to get rid of all the repeated switch statements? Polymorphism is a good thing.
Look into the "entity component system" architecture. Here's one library that demonstrates it: https://github.com/adngdb/entity-system-js
The stuff in the readme about async/await not being flexible enough for this sort of thing is an issue I've run into personally. Nice to see there's a library to make those kind of situations easier.
What API call are you making? And what are you doing with the data once you receive it? Gotta give us a little more to work with to help ya out
That’s true, sorry about that. It’s a react app that will, in short, allow you to save queue points on YouTube videos. I’m requesting the snippet and then using the ID within the iframe api. Most of the time everything works fine however within the snippet response I can access the thumbnail and all the meta of a video but when using the ID within the iframe I get the ‘user has blocked video from being played away from YouTube’ error (not fact wording)
Thanks for the suggestion! I definitely need to clean up my code, I don't like the switch statements everywhere either haha. Also unit tests are on my to-do list. I can't get by just manually testing anymore!
I always wait too long to start adding tests and regret it; it's a hard discipline to adhere to. I guess that's why in true TDD you're supposed to write the test before you write the code :)
No, god, why, no don't do this.
As a general rule, the less code you end up repeating, the better. In this case you don't want to duplicate all of your item stats in several places. Let's first build a master loot table (a list of all the items in the game), for this example it will contain only 3 items: First some housekeeping though. Let's declare a few variables so we can use numbers instead of typing stuff out each time. const itemType = { 0: 'armor', 1: 'weapon', 2: 'consumable', }; const stats = { 0: 'health', 1: 'mana', }; Ok, these are short and easy to follow, so let's get back to our item list. const masterLootTable = [ { name: 'Dagger', type: 1, damage: 1, speed: 0.5 }, { name: 'Leather Vest', type: 0, armor: 2 }, { name: 'Health Potion', type: 2, stat: 0, effect: 10 }, ]; Now, let's say your character is wearing a west and had a dagger. You could then do something like this: const equipped = [0, 1]; What this does is allow you to look up your items from where they are stored (once and forever) instead of creating copies. Let's say you need to calculate the total amount of armor the character currently has. You can iterate through all the items in ```equipped```, hit up the ```masterLootTable``` based on the indexes you have, and if a given item happens to have a ```type``` that corresponds to armor, you just tally up it's ```armor``` value. Why did we go through all this trouble? So that you never have to worry about the data stored in these item objects. You'll never need to re-enter it anywhere, and so you won't mess it up or have too many bugs, because all the item lists in the game (equipment, inventory, chest treasures, monster loot, etc.) can now simply refer to your master list. Let's say your character killed a cobold who dropped a health potion. This cobold's own loot table (regardless of whether it's custom made or generated) has to have a list of just some value pairs. genericCoboldLootTable = [ {2, 75} ]; This means it will drop a health potion (because it has an index of 2 in the ```masterLootTable```) and the odds of dropping it are 75%.
I'll bite - why not?
You know.. from my experience.. you learn one you can learn them all. All programming languages are basically the same. Focus on one understand it completely then you can program in what ever language you need to... 
they're annoying af
If you don't want to limit a scope just pick a domain with your nickname or real name.
Don't be the guy who uses polymorphism in everything just because he learned about it from a book yesterday.
Cool, I'm definitely going to check out your code. I have something kinda similar that I have been using as an exploratory project for a bunch of different libraries/frameworks (Elm, Phoenix, Node, React, etc) if you want to check it out! https://github.com/rawhat/playlistr Hopefully we can learn some stuff from each other :)
How about as a very simple means to remove all that duplicated code? Have a player 'class' and extend it for each instance (youtube, vimeo, etc.) Now you don't need switch statements everywhere. Since when is reading a book or using a concept a bad thing?
Turn your foreach implementation into a function, if you are worried about code reuse. Otherwise I don't think there is a function for what your want.
Not really worried about code reuse. Just worried about the readability factor of these lengthy looping syntax. Sad reacts onli
I'm sure there is a label so you can either use to hide or do something.
This: for(let i = 0; i &lt; fruits.length; i++){ if(fruits[i] == "apple") { //do something } } can be expressed as a filter and forEach: fruits.filter((f) =&gt; f == "apple").forEach(...); provided the original "do something does not include a break statement". For the second example, you can use some: const fruits = [{name: "apple", price: 420}, {name: "banana", price: 96}]; if (fruits.some((f) =&gt; f.name == "apple")) { } 
`forEach` *is* the correct method, if you want to "do something" inside while you check. The other methods are appropriate fits for declarative programming, which is a way of writing code to say "this thing looks like this" and not going into detail on how to do it. Declarative programming (implemented via the subparadigm Functional Programming, or FP) is built heavily around *expressions*, which say what you assign the data to. Compare to imperative programming, implemented via the subparadigm Procedural Programming), is built heavily around *statements*, which basically mean "do something". `forEach` isn't for the newbies while pro-users use `Array#map` and others, because it's just plain better. They're different things fit for different paradigms, which may or may not be an appropriate approach depending on what you're doing. If you want your "do something" to be based on some check returned from the array, that's an expression-approach. Your main complaint about the `find` was that it was too-long. The increase in FP practices in ecma are why we have arrow functions and destructuring now, which cleans yours up quite a bit: if (fruits.find(({ name }) =&gt; name === 'apple')) { It's plenty readable and pretty short.
I am at an early stage in developing, so I don't know anything but Good Luck
I recommend his books to everyone. 
Work requires us to avoid ES6 (for now) so I am quite inexperienced in destructuring or arrow functions but &gt; ({ name }) Is this what you call destructuring? So basically you are immediately going deep inside the array by searching for every object.name during the .find() operation? Neato. Thanks for the elaborate response 
This is nice. I think some and filter is interchangeable depending on how you want to `do something`. `.some()` only returns a boolean value checking whether or not the criteria is met, while `.filter()` returns every item in the array. I think `.some()` is the best in this scenario, without reiterating over the results. Should be translated to const fruits = ["apple", "mango", "banana"]; for(let i = 0; i &lt; fruits.length; i++){ if(fruits[i] == "apple") { //do something return; } }
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Using web tech for game interfaces is not uncommon; guild wars 2 does this for parts of their interface as well. Trying to wrangle lower-level code to make GUIs for games is painful most of the time.
This is what they said about jquery
Great article. Unfortunately this is quite common problem to async await. Personaly I am using more naive aproach called cancel token: https://github.com/coderitual/react-ui-patterns/blob/master/cancel-async/README.MD There is an ongoing proposal about making thich mechanism as a part of language (you don't need to call throwIfRequired after each await). Stage 0 of proposal (it wasn't "accepted" in that form): https://github.com/tc39/proposal-cancellation/blob/master/stage0/README.md Stage 1 of proposal (started from scratch again): https://github.com/tc39/proposal-cancellation
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tc39/proposal-cancellation/.../**README.md** (master → f353839)](https://github.com/tc39/proposal-cancellation/blob/f35383948a18d75a1c52ed0c595a70fcef6f941d/stage0/README.md) * [coderitual/react-ui-patterns/.../**README.MD** (master → 57c8709)](https://github.com/coderitual/react-ui-patterns/blob/57c8709e61691d6ba0581a729ede73af2e76dca7/cancel-async/README.MD) ---- 
Didn't early UE3 games use flash for the main menus as well?
IIRC Battlefield 1 is made with react as well
Scaleform probably
Sounds easy enough to do with either a filter and then a foreach or a filter and then length check (aka some) 
I interviewed for this job back in the day (about 4-5 years ago), to work on the UI and would have been possibly leading it. I think the only reason it fell through, iirc, was that I didn't hear back from them for a month or more. They claimed their wires got crossed somewhere and they never got back to me to let me know they were still interested and wanted to move ahead with the final parts of the interview. I think between that and the ultra low pay, which would have been something like a 15k-20k pay cut, which doesn't account for the cost of living increase from their location.
I concur, I really like Jest - just switched. I can't seem to get it to ignore tests that haven't changed though. Otherwise it works great.
*Tons* of games [used Flash for their entire UI](https://en.wikipedia.org/wiki/List_of_games_using_Scaleform) - that list isn't even complete. All of EA's sports games starting around 2006 used Scaleform, for example. It's a natural thing to do - it's nice to be able to hire designers who are already familiar with your UI tools. 
Cool, but lots of uses of explicit anys. You're really losing the power of TypeScript when you do that.
Yup. Dota2 already does it. It's in the works for cs go. Their implementation is a bit different but very similar to html/CSS/JavaScript. They use a custom XML format instead of html iirc
I get that a lot of effort went into this, but shopping carts are probably *the* worst thing (apart from authentication) that could be implemented client side (only). When I'm shopping online, I expect to be able to add items from Chrome on my phone to Firefox on my laptop to a vendor-specific app on my second phone. When I checkout, I expect my cart to be emptied on *everywhere* I'm logged in. That's the normal UX for a shopping cart, and anyone who messes with that is going to lose a lot of business (especially since they're not Amazon). There's a reason people use those pesky databases and server-side solutions to manage shopping carts. This seems like a not very well thought-out solution looking for a problem. 
&gt; If you have the memory, use it, otherwise it's wasted Can people stop repeating this nonsense? There's no modern OS that "wastes" RAM. 
The second rows will only remain equivalent as long as the api won't change. However, these two will always be equivalent: ``` whatever.map(fnc) whatever.map((...args) =&gt; fnc(...args)) ```
Hey, this article helped me a lot: https://frontendian.co/cors
how the fuck they could make game from react?
You can try Advanced JavaScript on coursegalaxy and courses on fronendmasters.
Or equivalently the same result without any tagged templates: const translatedToSystemLanguage = ([str1, str2], world) =&gt; str1 + world + str2 const inFrench = tl('fr')([`Hello, `, `!`], world) 
yup, react is really good for building itnerfacfes
see also the text summary of their design doc on [ui modding](http://camelotunchained.com/v3/bsc-design-docs/ui-modding/) along with the "modsquad" of community members [e.g.](http://camelotunchained.com/v3/evening-update-thursday-august-6th-2015/) &gt;The Mod Squad, or TMS for short, is a joint developer and Backer effort, led by our lead spaceship engineer (he loves that title) JB to take modding to greater levels of awesome. While JB will be holding a live streaming session this weekend, the key things that our Backers need to know are: &gt;That we remain committed to making our UI/mod system the best in the industry. Now, we know we are too small of a team to do that totally on our own, but with some, ah, additional help, we think we can get there. As our Backers know, we have been using GitHub as our UI code repository for quite a while, so TMS is a natural evolution from that path. &gt;That we are looking for Backers who want to get involved in the modding initiative, whether by contributing code or ideas to the project. &gt;That the Backers who contribute will be rewarded with everything from game credits to in-game rewards, upgraded tiers, swag, and cash. &gt;So, if you are a Backer of Camelot Unchained who wants to be involved in this effort, please head over to our Forums to join the team as it forms. This isn’t quite an “Avengers Assemble” moment, but we think it could be very cool for those who participate, and also improve the game both in the short and long term for our players.
What is the advantage vs `ramda`s curry?
Both named and ordered args are useful. Naming is often hard and subject to name clash. Also you can achieve named args by passing objects and destructuring inside the function.
True question : Some of you still start new projects with CoffeeScript ?
This order is specific to the `map` function, as part of the functor interface. This is commonly used as method functor.map(fn) of in the point-free style map(fn, functor) where the functor arg comes last, to facilitate the curried version map(fn)(functor) newFunctor = pipe( map(fn1), map(fn2), ... )(oldFunctor) 
&gt;Cool, but lots of uses of explicit anys. You're really losing the power of TypeScript when you do that. Actually code in general doesn't look very good, I have seen some other mistakes too. Anyway it's an interesting example to read.
&gt;t.org logos are almost same 
user _interface_
I thought UE4 used Javascript as well?
I never said you have to like TypeScript, but saying types gives no benefit, no bug reductions and "less" useful code is simply wrong. I'm not going to watch your 1 hour video, if you have an argument, just say it. For an experienced TS-user, it goes faster using typings, there's less time wasted going through files finding out what an object contained. You don't have to go through the mind killing experience of transpiling a project, going to a route and making some changes in your app, only to find out you wrote "data.ndoe" instead of "data.node", TS instantly notifies you of this. I think you should try out TS more before saying it's completely useless ...
When would you not want to use a framework, and why? Would you not want to use components, 3rd-party controls and generally be able to re-use code and scale from the get go? JS &amp; naked dom don't re-use views as there are no components, you are shut off from the eco systems, handling state is mess, crawling through dom nodes to inform views of updates is an even bigger mess. Perhaps if you're dealing with a plain html layout without interaction, but even then, if it gets bigger you probably would prefer an organized structure with re-usable components. Frameworks today are small, mean little to no boilerplate and introduce sanity. Saving the 4-30kb you'd otherwise save isn't worth going back into the dark-ages. Similar to how babel-polyfill on top of your project allows you to use modern javascript.
I always like to say "making it work is step 1". Sure you can clean it up but many times when I have issues with something I put code in different files or different orders and then it becomes a bit of a mess that requires cleaning. Something I do after it eventually works. And for some things there are no typed files available and making them yourself will take quite some time. If you are trying to see if library X does Y, you can go with `: any` and get it to work first.
Interesting. Something I've been looking into for a while now as game design has been an interesting topic. Just doesn't have a lot of jobs in my area. So is the UI they (or others) make only the menu's, the buttons and texts and whatnot or are some items (like markers or player icons) done in the engine and not UI? Because some games like to mix it up. In any case, interesting to see it work an probably not easy to do with all the effects and whatnot. Performance will also be very important too.
Of course you can build an app without TS, you can also build it in jQuery, doesn't mean it's a good thing. Once you got started with a TS app, it's not really much maintaining, I mean if something doesn't blend with TS, it's just to force it to the "any" type and it's going to resemble JavaScript. All the times you misspelled a simple object node, having to transpile the entire project, go to the route to find that out, instead of the compiler warning you instantly. If you have a complex data tree, you can just type hint the entire structure just writing "o" "n" "a" with dots between to precisely locate "object.node.anotherNode". These things TS brings is a bless to work with. You don't have to do as many automatic tests, such as bindings between prop mapping and components, and for instance when you're instansiating a new component, you can simply write "&lt;Com" and TypeScript will automatically import the &lt;Component /&gt; and render the name, it will help you identify what props are needed and in which type, you can do everything from a single file. I think if you tried it out, you'd realize how much time you save, and how much you get for free.
Wouldn't making more use of functions make it way more readable?
This! Definitely look at using ES6 or Typescript. A good pattern to use in a game like this is the [ECS] (https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system) pattern.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system) - Previous text "ECS" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
The UI for PUBG is also in React, at least the main menus are
I don't know UE4, but JavaScript and ActionScript (the language Flash applications are written in) are cousins, both extending EcmaScript.
I can't predict the future of course but from what you're saying, I'd go typescript. (This is subjective obviously) It's much more safer (due to tooling around it) to work with than pure JavaScript, you can use it for both front end and backend (node) and the popularity of node and ts friendly UI frameworks is skyrocketing. + one more thing, no matter what you choose, learning to program in any language will make you a better programmer. When you're better in programming, learning new languages becomes easier. Good luck !
This. Use a database of JSON resources. 
I love Sarah. She’s a genius. 
(Just like Battlefield 1)
This is a good practice to get into even if you don’t plan to add or remove elements programmatically. Anytime you find yourself using multiple event listeners that all do essentially the same thing, you should consider looking up the DOM tree and attaching a single event listener there instead of per element. It’s easier to reason about event handling this way, and it’s much more performant.
He’s the author of the You Don’t Know JS series, no?
Lol why?
PUBG's lobby UI is web based too. 
IMO, it's better advice to start with pure Javascript. There are many more tutorials and it's easier to get help with it. Once they've got that down, moving to Typescript can only improve their situation, and it's not like it's *that* different. But trying to apply Javascript advice to Typescript could be confusing for a novice.
You can get it to work by providing an executable path to Chrome(application path in Mac &amp; simply google-chrome-unstable on ubuntu), Chromium doesn't support most audio/video codecs OOTB.
Does this mean you'll finally support Linux?
Best guess: It's just as much work to roll your own support for HTML/CSS/JS as it is to write a new system using a custom XML format. Windows does this in WPF with XAML, as does Android (and maybe iOS as well?) for their respective UI's.
Where is the ospec approach problematic when using linked packages?
If you still like CoffeeScript you might as well go all the way and instead use Python compiled with TransCrypt.
Holy shit this is the next version of Dark Age of Camelot?! I used to play that game so much back in the last decade! That's amazing!
There are no burgeoning frameworks that I am aware of, though I hope that changes.
Shouldn't these be explained in a low level language? And then explain how they work in a high level language?
Not a regular TS dev, but I would probably just make a type alias that's descriptive (`type LibraryXYType = any`) so it gets a description and can be replaced easily later.
&gt; saying types gives no benefit, no bug reductions and "less" useful code is simply wrong. I have over 30 years of programming experience, and Ive tried every language under the sun. Ive implemented compilers and done every type and level of software work. Please dont just assume my opinion is invalid because you disagree. IMO: types are useless for programming (with the exception of hardware types used in C/C++/ASM) &gt; I think you should try out TS more before saying it's completely useless ... Dont worry about that, ive used oodles of TS - im quite experienced with it. The best part about typescript is turning all of its types off by making everything an ":any". Thats typescripts main advantage over other typed languages: you can disable the types, which makes it suck less. Still not as nice as plain vanilla JS. 
Thanks for your feedback. This wasn’t meant to replace robust shopping cart software. Just a quick way to add shopping functionality without diving into all the weeds - albeit at the expense of no cross platform persistence and limited features. 
No, it can be added with plugins such as [UnrealJS](https://github.com/ncsoft/Unreal.js/blob/master/README.md) but out-of-the-box UE4 only uses it's own [UMG](https://docs.unrealengine.com/en-us/Engine/UMG/UserGuide) and [Slate](https://docs.unrealengine.com/en-us/Programming/Slate) for UI and [Blueprint](https://docs.unrealengine.com/en-us/Engine/Blueprints) and C++ for programming.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://docs.unrealengine.com/en-us/Engine/UMG/UserGuide) - Previous text "UMG" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ncsoft/Unreal.js/.../**README.md** (master → 69bae55)](https://github.com/ncsoft/Unreal.js/blob/69bae55cf239565938ea2080e544a9be5dfb72d2/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0vea4y.)
When framework provides solution to your problem and flexible &amp; extensible for your future requirement.
The article isn't bad advice, but it is very beginner / 101 material.
Wow, great source, thanks for sharing! 
First, this is not typically what is meant when someone says “microservice”. A microservice is most often a small service running on the server. What you’re building is a form of dynamic code loading and so you might find more resources if you look at it from that view. It also makes it clear how to handle your third point. Your frontend just needs to load React before loading any of your dynamic code. This can be as simple as using the `script` tag.
It’s a spin-off since mythic owns the rights to the name DAOC, but it’s still made my the same person. I’m super excited for the release! 
Grunt? CoffeeScript? It's like 2013 all over again!
Hard to argue with Free.
Link bait 
I second this!
Many or most of the programming languages are designed in a sync way, one instruction after other, in JS, with the async way of thinking, you should consider the promises or callbacks. It's just to know when to use each paradigm 
https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a
https://www.reddit.com/r/javascript/comments/8rlget/heres_why_calling_map_on_a_constructed_array/
🌚🌹🌹🌚🌚🌚🌚 🌚🌹🌹🌚🌹🌹🌹 🌚🌹🌹🌚🌹🌹🌹 🌚🌚🌚🌚🌚🌚🌚 🌹🌹🌹🌚🌹🌹🌚 🌹🌹🌹🌚🌹🌹🌚 🌚🌚🌚🌚🌹🌹🌚
I would also bet that optimization is easier if you only have to support a limited set of XML object rather than optimizing a whole html/css/js engine.
It won't hurt you a bit! You may develop some specific blind spots: * Type systems. After learning JavaScript, statically typed languages will feel foreign for a while. * Concurrency and parallelism. JavaScript has pretty decent features (Promises, async, and await) for writing concurrent code, and you'll run across them early on. However, [for historical reasons](https://github.com/promises-aplus/promises-spec/issues/94), JavaScript's Promises are subtly different from other languages' async features. Promises will teach you a pattern that works in other languages, but it isn't the most elegant thing around. You probably won't read much about parallelism at all, unless you dive into Web Workers right away. * Security. I know a scary number of JavaScript developers who simply don't care about securing their applications. That said, NPM is getting better at raising awareness about security since they introduced npm audit. Your computer science classes will cover all that junk for sure. Arriving with a working knowledge of JavaScript will only help you, as far as I know.
You'll have to search all of the script code. Search for all assignments to e.g. `$1`, put a breakpoint on all of the found lines, then reload the page.
Thanks.
Basically the issue was that when using relative imports I get locked into whatever is in the filesystem (meaning that if the library is in a broken state, I can't test it because well the thing is broken). If I use non-relative imports, then I basically have to import an older version from npm, but then I can't consume a new feature at all. In a sense that's no different than using a different test runner altogether, and not really testing itself (in my opinion). Besides, if I somehow publish a broken state, I still have the chicken and egg problem, except with NPM now tangled in the mix. I could instead link to the bleeding edge in disk, but then I get back to the same chicken and egg problem from the beginning (in addition to having ad-hoc non-reproducible local state due to the package linking) and other fun stuff because NPM. 
Thank you for showing me the ecs pattern. I've noticed this pattern in unreal engine so I'm glad to know it has an official name!
The big appeal for RN over Cordova is that it uses Native Components so that (in theory) it will have better performance than Cordova's "WebView". That being said, in my experience so far... I've found React Native to suffer a lot of performance problems on Android. For example, in my "learn the framework" app I've been building, I get a solid 60FPS on an old Ipad AIR, but on a new Galaxy S8 I get 4fps. I know a lot of it may be with how I am coding the app, but I must admit I was very shocking to see this problem manifest, seeing as the whole reason for me trying RN was for performance benefits. If at the end of the day I have to do a lot of optimizations to make it run well for Android. I may as well do the same opitizations in Cordova's WebView. This thread maybe more insight: [https://www.reddit.com/r/reactnative/comments/8lm5wx/android\_bugs/](https://www.reddit.com/r/reactnative/comments/8lm5wx/android_bugs/) 
Semi-off topic, is it possible to pin a topic to this community. This is a pretty recurring question of "if I learn javascript, will it result in X" where X is ranging from "me becoming a bad developer" to "will it transfer to some other language." I don't think there is any problem with this post in particular, but maybe having a more central thread could help people decide if they want to learn JS.
A lot of people recommend jest as the _it just works, no config_ test framework, but that's never been my experience. I use it in work projects, and always end up writing config for it. I think a lot of people have good experiences with it, though, and since it's currently popular, there will be a lot of help/support. Jasmine is pretty similar to jest - I think jest either backs onto jasmine, or at least has some integrations tied in. I find it to be a little slow, but it also has a lot bundled in. I use mocha a lot, since it's pretty trimmed down, but you have to be comfortable plugging different pieces into it, since it's pretty bare bones. Mocha was my go to for a long time. Most recently, I've really been taken by ava. It's even more trimmed won than mocha, so much that there are no typical spec-style functions (ie describe/context/it), just before*/after* and test. What I like is it doesn't pollute global state, and forces test isolation. Each file runs in it's own process, which can be pretty fast. I treat files like describe blocks (so my files look like `&lt;file I'm testing&gt;_&lt;testing scope&gt;.test.js`), which isn't too bad. In spite of my heavy enjoyment of ava, I'd probably recommend sticking to something like Jest - a lot more people are going to be able to help if you get stuck, and there's a money and companies behind the project.
I'll jump on this too, just to say that you might get some benefit from working with people online, but you'll get a lot more benefit working in person.
Any sources on this? I'd love to read more about it, especially CS:GO.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Immediately, my intuition tells me \`Todo(req.body).save(function(err,singleData) { ... })\` is not a promise. Typically a promise would look more like: `Todo(req.body).save().then(function (singleData) {}).catch(function (err) {})` With that in mind, there is no reason to think that `.save` is doing anything with promises. We can fix that, though, by building our own promise around save! const savePromise = new Promise(function (resolve, reject) { Todo(req.body).save(function (err, singleData) { if (err) return reject(err); return resolve(singleData); }); }); Now you could do something like: savePromise .then(function (singleData) { Todo.find({}, function(err, data){ // I'm guessing this should be finding against singleData.&lt;something&gt;? if(err) throw err; res.json(data); }) }) What do you think about that?
If you've got the money build a native app. If not than one of the other will have to suffice but they are not nearly as good.
https://www.reddit.com/r/csgo/comments/8qncfl/counterstrike_global_offensive_update_for_61218/ ctrl +f "panorama" I think on the dota2 custom game wiki has a bunch more info on how it works. I probably found a link for that in the cs go post.
I believe that is there for browser compatibility issues
That is a million :)
the first part resets the value of the onload function to an empty function so if/when run again, nothing would happen. The second part calls handleClientLoad(). By reseting onload, handleClientLoad only runs once.