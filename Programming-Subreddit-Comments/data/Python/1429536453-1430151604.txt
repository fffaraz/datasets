Unless I misunderstood your example for that class, `Monty`'s immediate super (in the MRO) is `Spam`, not `Alot` (it goes left to right). You can see this with a simple test: &gt;&gt;&gt; class Spam(object): pass &gt;&gt;&gt; class Alot(object): pass &gt;&gt;&gt; class Monty(Spam, Alot): pass &gt;&gt;&gt; Monty.mro() [__main__.Monty, __main__.Spam, __main__.Alot, object] Similarly, `Alot`'s super checks will go in order listed (left to right, not right to left) (This is mentioned in the talk: https://www.youtube.com/watch?v=EiOglTERPEo#t=30m48s ) For /u/stillalone this talk originated from a blog post Raymond did, which gives an example of the adapter class: https://rhettinger.wordpress.com/2011/05/26/super-considered-super/
There are two articles here about using python with PDF: to manipulate the PDF and to test the PDF: http://reachtim.com/archives.html 
I seem to have dropped my....oh, there it is! /s
Wait? You are complaining about this? THIS IS BRILLIANT. I can't imagine why you would not want to have this? You have an error, what are you wanting to do? PASS on the error handling. You literally just typed out what you wanted to do. Anyone in the fucking world can figure out that you just passed on that error. Like holy fuck, that was simple, easy, and it looks fucking great and is fucking readable. I can't imagine that you could complain about this... and because you are complaining about it, I can't imagine how hard to read your code must be.
All good editors have a reindent code block function. For example, in sublime, CTRL + [ and CTRL + ] will indent in either direction for you, which makes correcting indents trivial. One of the biggest screw ups from auto indent, is that it catches one line (Your first line), but doesn't catch the rest because they are already indented out a certain amount.
That was 3.2
I think you've misunderstood. The Cartesian product of [1, 2, 3] and [4, 5] is [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]. It is really useful, so much so that it's implemented in itertools.
It isn't a fork of anything, just under 150 lines of code I wrote yesterday. You can see it just generates the argparse interface from the class and methods marked by the decorators. https://github.com/F483/apigen/blob/master/apigen/apigen.py
Agree, I have a very particular style of coding, but it helps me out spacing thing both with whitespaces and returns (LOTs of them). Most people find this style "disgusting" (literal words from my coworker) but I'm used to it and can navigate through my code pretty easily. Sadly I can't do that in Python. 
Well, technically "type hints" is just a standardized way to use "function annotations" if I understand correctly, and they've been in since 3.2 I think. And "type hints" don't actually give any real functionality so there isn't really anything more to implement.
This is /u/aspyct's point, it's not semantically empty.
Yeah, I use python 3 most of the time as well
Not even remotely comparable.
I'm a bad person. Here's something from a recent side project: def queryize_string(s): return re.sub(r'[ _\.,\-\(\)\[\]]+', ' ', s).strip() ... ... try: show_name_query = queryize_string(show_name) resp = requests.get(IMDB_SEARCH_URL.format(show_name = show_name_query), timeout=settings.IMDB_TIMEOUT_SECONDS) except requests.RequestException as e: logger.error(e) make_not_found() return None else: # load the html page into a jquery-like python module d = pq(str(resp.content)) found_shows = d(IMDB_CSS['search_results']) if found_shows: most_likely = pq(found_shows[0]) href = most_likely.attr.href imdb_title = most_likely.text() imdb_id = re.findall(r'[a-zA-Z]+\d+', href, re.I) if imdb_id and imdb_title: x = imdb_id[0] return x if verify_name(show_name, imdb_title) else None So...this little snippet is using `requests.get` to load a url on IMDB and putting a url-valid show name into their querystring. If the `requests` library throws an error, they all inherit from `requests.RequestException` -- so it's kinda like a catch-all that you can look at the "why" later. The next part is using a python library called [`pyquery`](https://pythonhosted.org/pyquery/index.html), it takes the requests.get response's HTML and throws it into a parser that works like jQuery. `d = pq(str(resp.content))` : puts the HTML into the jquery like thing. `found_shows = d(IMDB_CSS['search_results'])` : is using a selector, `td.result_text &gt; a` to grab all the hyper links in the results table. It's not glamorous, but it gets the data and it's pretty easy to understand. If you wanted to use Selenium or Ghost.py they have their own "selector syntax" which queries the virtual DOM, but as far as a GET with raw HTML this usually works just fine.
Well, that's silly, but I guess it's easy enough to make a nano wrapper that uses 'file' to identify source code type and pass appropriate commandline args.
question, I see a lot of experienced programmers laud vim and emacs. My brief experience with them made me feel *regressive*. What is the benefit I'm missing? Hotkeys? I'm fairly new to CS in general. :)
This person's got it. Reportlab to generate the overlay, PyPDF2 to merge it on top of the original. That's the simplest strategy. If you actually want to edit the PDF, there might be something free out there (I haven't found it yet), but Reportlab has a commercial version that'll fit your needs.
Exactly.
I've had a pretty good experience with wxPython, pretty straight forward and well documented with lots of googleable examples 
Use HTML5 ;-) You take bottlepy, and you code a server which expose HTML5 pages and restful services. (with angularjs, it's a better combo too)
Excellent tutorial. Thanks! As an aside: as someone new to Python, I appreciate the source code walkthrough. The best way to learn a new programming language, I've found after learning three others, is to actually do a project in it. With code samples and tutorials like yours, my little n00b projects are actually kinda fun. So, thanks again!
No, I can understand it. I used to complain about `(void)` prototypes in C, too. It's an aesthetic thing.
People like emacs because you can really easily write "plugins" for it. It's basically a lisp interpreter. VI/Vim actually has less functionality out of the box that notepad++, but the shortcuts for editing text are delightful Edit: I use vim all the time. In my opinion vim has less out of the box because a lot of the things you take for granted need to be configured. Syntax highlighting, search, sensible tabs and line endings, mouse support, file search, etc.
So you love Python and then recommend Clojure… funny you don't talk about Hy. It's a dialect of Lisp that translates to the Python AST and allows two-sides interop. Sounds promising no ? :) http://docs.hylang.org/en/latest/ 
Jupyter/IPython has some GUI capabilities.
This isn't easy. I had to do this add my first Python work. :(
What would it do on normal lists? Just like `Ellipsis`/`...`, it was introduced for library use
What are these words?
They added the `Ellipsis` (i.e. `...`) just for numpy
They are both very powerful editors with a large learning curve. Depending on how comfortable you are with your current editor, it could take a while to get as productive in emacs or vim as you are now. The difference, however, is that you can always keep learning.
Hi, I'm the author of a few Python books, and the latest will be out in a week and available for free under a Creative Commons license: http://automatetheboringstuff.com Chapter 13 focuses on using Python to parse and modify PDFs. The bad news is: the situation is pretty grim. The best Python module I found in my research for this chapter was PyPDF2. Even then, you are very limited to what you can do. You're limited to working on the page level. Individual paragraphs and text can't be manipulated. The Python PDF modules are more read-only. So, basically, no, there's no way to underscore the NE in the PDF copy. You could, however, use GUI automation modules to simulate keyboard/mouse clicks to open the PDF in Acrobat, find the text, underline it, and then select save from the menu. That'd be a hack (and dominate your keyboard/mouse for a bit), but it would get the job done.
As a non computer scientist I have to wonder what one would need beyond vim?
Sorry. My point is: Nested blocks of indentation are only possible in a ‘linear’ way. There is no sane way (that I know of) to express, e.g. supplying a block of code as a function argument, when all you have is indentation. The non-existent multi-statement lambda was kind of my proof for that. With curly brackets as delimiters, it is easy, as in the following Scala example (written in a more verbose style than needed): List(1,2,3,4,5).map(x =&gt; { print(x); x * x }) This does not translate well to indentation (it does translate to built-in `for ... in` syntax, though – but of course only in a limited number of cases).
Contours represent the "outlines" of an object in an image. In this particular example, we are sorting the outlines of Lego blocks -- contours facilitate this process. Given a list of outlines of the Lego blocks, we first sort them by their size (i.e. how "big" they are) followed by their location in the image (i.e. left-to-right, top-to-bottom, etc.) It's common to first sort contours by their size to focus on only the largest objects in an image. But then we may need to resort them according to the location of where they appear in an image. And that's exactly what this article covers.
A `typing` module implementation is part of the PEP proposal. https://www.python.org/dev/peps/pep-0484/#the-typing-module
+4 if on a new line after `bar` (Enter, Ctrl+V), +0 if on a new line before `baz` (Enter, Up, Ctrl+V). You have a cursor, you can see the level of indentation that will be used.
Ah I understand now. It hadn't occurred to me remote coding would be a frequent thing and best done on those editors.
Not last I checked. @ is really for the math libraries; none of the built-in types or classes support it.
It was time to migrate to Python 3 years ago!
Indeed. I originally went to another talk about security. The guy mustered all the charisma he had to tell us to go see the Disney talk because it was better. So I did.
At PyDataParis a couple of weeks back I spoke on "Cleaning Confused Collections of Characters" and I spent a few slides looking at extracting text and tables from PDFs (but not reassembling them). Some of the linked tools might be useful? http://ianozsvald.com/2015/04/03/pydataparis-2015-and-cleaning-confused-collections-of-characters/
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
You don't test in production? HEY LOOK EVERYONE, THIS GUY PUTS BUGS IN HIS CODE THAT NEED TO BE TESTED FOR! Must be a lousy programmer. /s
That's not really it though. C doesn't need an `elif`/`elsif`/`elseif` because it has compound statements instead of blocks. In C, an if-statement is `if (EXP) S else S`, _not_ `if (EXP) { S* } else { S* }`. Languages that use keywords instead of braces tend to have the same need for an `elif` as Python, because they use blocks, because that lets them get away with not having a `begin` token.
Editing text in vim is a different paradigm. Opening vim for the first time is a bit like trying out a purely functional programming language when all you've ever done is programming in Java or C++: "You can't have a sequence of statements? How can you even do anything besides factorial and fibonacci in this useless language!?" You have to be willing to ignore the urge to do things according to the paradigm you know in order to learn the advantages of the new paradigm, and it will take time until you are productive.
The problem that pycharm apparently solves is copying a block of text that starts at a certain indentation level and *never goes below it* (may go forward though), and pasting it in a given indentation level. That's all you can expect from an IDE to do, that's what Eclipse does for Java (try pasting code that contains more } than { and see how well that goes...), and it's definitely possible in Python.
You don't have to use `pass`. You could put any literal in there and it'd serve the same purpose. Try it with `None`, `True`, `1`. Basically, the syntax is looking for an indented line, so there has to be something on it. `pass` functions really well by producing human readable, explicit code, which I'd argue is an advantage and consistent with python's design philosophy.
As he explained it, he addes an if (..) { at 0 indentation level (left of the screen), and another with } at 0 indentation level. Python [screws with his workflow](http://m.xkcd.com/1172/). I don't condone his opinion, of course...
Dumb question: I just saw that issue #21560 was fixed in 3.4.4 but not in this 3.5.0 release. Do some fixes pass "silently" to the next version or someone missed this one?
Further, if c is EOF then the correct thing for the generator to do would be to raise a StopIteration exception.
Hi guys, Thanks for the podcast prayer! I have a bunch of guests lined up and a host of episodes either recorded or scheduled. You can bet we'll make it to 7 or 8 just on what I have already lined up. But I am working hard to get some sponsorship to keep things alive for the long run. Wish me luck. The next two episodes are excellent (Enterprise Python at PayPal and SQLAlchemy with Mike Bayer).
I was just translating the specific syntactic construct, not the idiom. But yeah, you wouldn't do it like that in Real World Python™
Not a dumb question. The answer is, yeah, it usually will pass "silently". You can see "Roundup Robot" posted the checkins? That's because it saw "#21560" in the description of the checkin. When it gets merged forward to 3.5 the description is generally just "Merge" or "Null merge" or something. And, indeed, the fixes in #21560 were merged into trunk (aka 3.5 right now) in the very next revision: https://hg.python.org/cpython/rev/7e179ee91af0/
Today I learned! Thank you!
You should be able to work through a book based on 1.7 whilst using a Django 1.8 install. The biggest change in recent Django versions, certainly for a beginner's perspective, will be the introduction of built in migrations in 1.7. The changes between 1.7 and 1.8 can be found [here](https://docs.djangoproject.com/en/1.8/releases/1.8/). Nothing quite as major, but two notable differences are support for third party template engines, and additional PostrgeSQL specific functionality. If you are just starting off, you probably want to stick to sqlite and the default template engine anyway. Edit: As /u/stormandsong points out there is the changes to the meta API as well. Fortunately the changes are [well documented](https://docs.djangoproject.com/en/1.8/ref/models/meta/#migrating-from-the-old-api). To answer the question about books: [Test-Driven Development with Python](http://chimera.labs.oreilly.com/books/1234000000754) is a good book that covers Django 1.7. I've done a quick search and it doesn't seem to be any use of the meta API which would be affected by the backwards compatibility breaking changes in 1.8 so I would recommend this book. You can read it online for free via that link. 
Haha, I never thought of using it for that! I kinda like it ^^
I actually thought about that. Only issue is that the marketing team have sent me on the template presentation in the way they want it (powerpoint, laid out in a certain way and open to being altered slightly). So I had written in placeholder names into their template which simply get overwritten and formatted correctly by the script. Unfortunately I don't think that I could get them to move to html because they would lose their creative control then...
I have been using virtualenv for awhile now after having to use so many weird dependencies but just ran into a problem where I could not get a cron job to run correctly in a virtualenv. I tried all my google - foo and nothing worked so with much frustration I finally gave up and installed everything system wide and is working perfectly. I wish I could figure out how to fix the problem in the recommended virtualenv way but sometimes that takes too much time and energy. EDIT: fixed bad typing
&gt;Additionally it's the only reasonable meaning of a product of two lists Not entirely. There's also the possibility of elementwise multiplication. Ie, [x*y for (x,y) in zip(list1,list2)], and this is complicated by the fact that this is what numpy arrays do by default. A cartesian product might make sense more generally (as lists can often contain things that can't be multiplied), but it's not entirely intuitive that this is what it would do. In the meantime, there are ways of doing a cartesian product. Eg. `[(x,y) for x in list1 for y in list2]`, or via `itertools.product`. This is a bit longer than just `list1 * list2`, but it's not *that* common a requirement, so a bit of verbosity isn't that big a deal.
I really enjoyed this tutorial. I've been working on getting up to speed on some docker implementations and this has probably been one of the better big picture tutorials from making an entire webapp from a dockerfile to using docker-machine and then deploying as well. Very helpful! 
Check out [Flask](http://flask.pocoo.org/) (and visit /r/flask), it's a dead-simple web framework. Great community, and lots of quality plugins/extensions. I'd say it's a good candidate for exactly what you're describing.
Get a slightly better text editor.
Finding a specific example (Which, of course works to your advantage) is no way to answer a question about "most of these things". So, you didn't actually answer the statement, AND you showed how you have a limited grasp of malicart's statement.
Just wait until you try to block and copy some code into your code. While braces/brackets would work just fine, whitespace usually doesn't. 
The first time I used Python was in 2011 when I was maintaining a sloppy, copy-pasted Python script to do a bit of ETL. Not all of the spacing was consistent, and it was a massive pain for me at the time to figure out what went where. Now that I've gained a bit more programming maturity and both write &amp; maintain much saner code, the lack of brackets is no longer an issue to me.
That depends entirely on what you're doing.
It's better, yes, but it falls just short of being math, and math IMO is what we all really (if unknowingly) want. This is one reason (of many) that it's good to learn more than one language. Haskell, for example, doesn't allow `if` without `else`, because Haskell doesn't allow statements. Everything is an expression, and all expressions have a value. Thus, you can't have if only, because in the false case, there would be no value. You can branch, but both sides of the branch must have a value. In fact, the values on each side of the branch must agree in type, because the entire if/else expression has a type, and anything depending on that expression is - as are all things - depending on a result with a given type. I think many of these phrases and best-practices we make up - like "explicit is better than implicit" - are ways of trying to get us back to math, in a subconscious, self-unaware sort of way. We know certain things work, and certain things *seem* better than others, but most of us don't know why. I think what we're all really doing is finding math, sometimes, and gaining a kind of appreciation for certain structures, which happen to be more like math. Because we don't know that they're math, we come up with natural-language ways of trying to define the patterns we see in them. I can't prove that yet. It's just a feeling. Oh, and Haskell doesn't have a null/nil type, and such a thing is considered [a bad idea](http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions) anyway.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 2. [**Apologies and retractions**](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions) of article [**Tony Hoare**](https://en.wikipedia.org/wiki/Tony%20Hoare): [](#sfw) --- &gt; &gt;Hoare has always been willing to accept that he has made mistakes. Speaking at a conference in 2009, he apologised for inventing the [null reference](https://en.wikipedia.org/wiki/Null_pointer): &gt;I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language ([ALGOL W](https://en.wikipedia.org/wiki/ALGOL_W)). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. &gt;For many years under his leadership his Oxford department worked on formal specification languages such as CSP and [Z](https://en.wikipedia.org/wiki/Z_notation). These did not achieve the expected take-up by industry, and in 1995 Hoare was led to reflect upon the original assumptions: &gt; --- ^Interesting: [^List ^of ^London's ^Burning ^episodes ^\(series ^6)](https://en.wikipedia.org/wiki/List_of_London%27s_Burning_episodes_\(series_6\)) ^| [^He ^Jifeng](https://en.wikipedia.org/wiki/He_Jifeng) ^| [^List ^of ^London's ^Burning ^episodes ^\(series ^1)](https://en.wikipedia.org/wiki/List_of_London%27s_Burning_episodes_\(series_1\)) ^| [^Eric ^Hehner](https://en.wikipedia.org/wiki/Eric_Hehner) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqiqmui) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqiqmui)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Sure, it just looked odd to go half the way but then stop.
What's implicit in that rule is the addendum "all else being equal."
Hence why I prefaced my post with &gt; If your object are simple enough
&gt;However, never say you can't do x with python, there is always a way to do what you want to do. That's not even kind of true.
Never saw that movie, didja? It's a shame, it was the best of the original Star Trek franchise.
Like 99% of programming languages, python is Turing complete. So, unless you specify syntax limits (e.g., must use anonymous function), it is 100% true. There are good reasons to design programming languages to limit features (e.g., python's decision for anonymous functions to be limited to one statement). Otherwise you end up with a mess like C++ or perl where there are tons of ways to do everything and its much more difficult to read and understand anyone's code. If your function needs to be multistatement, define it non-anonymously.
&gt; because nobody wants to actually do else ifs the second way. It's done that way in Pascal/Delphi. :-) If x = 7 Then y := 2 Else If x = 8 Then y := 3 Else If x = 9 Then y := 10 Else y := 0; Although you'd normally use a CASE statement for something like this in Pascal.
Guido gave [a talk about this](http://pyvideo.org/video/3389/guido-van-rossum) during pycon2015. From what I gather, there are lots of workarounds and ways to cater to your specific dev environment.
I wish there was just one amazing UI toolkit instead of 20 different decent ones. If there was ever anything like JavaFX for Python, that would be awesome. 
Check out the sniffing part http://www.secdev.org/projects/scapy/doc/usage.html def functionname(): # do things with each packet # sniff interface and pass each packet to function sniff(iface="eth0", prn=functionname) 
I've played around with VIM (and Emacs), but I've found that I'm much faster just using ctrl, shift, home/end and the arrow keys to move around quickly. $ is a pain to type compared to pressing end, and I'm much more comfortable using backspace/ctrl+backspace to for example delete a character/word (delete/ctrl+delete to delete a character/word forward). Killing the rest of a line is a bit harder with home+end, backspace though. I do have an autohotkey (windows-specific program that enables you to create your own hotkeys, including chorded hotkeys: there is no linux equivalent. Don't believe me? Prove it!) script which makes these things easier though (caps+a/s/d/f is bound to home/end/backspace/enter for example, caps+j/k to ctrl+left/right and caps+zcqe to up/down/left/right among others).
For those of us working with scientific data this is huge. My code can sometimes be unreadable from all the calls to some function while the equation itself is perfectly readable. I've already see people abusing it in other places, expect to see a lot of libraries using it for completely different purposes such as building email addresses, URLs, and more. I think it's a good thing, personally. 
And, for those of us on Python3 (which you should be, too). pyvenv - added to standard distribution in v3.3
Yeah, it's a nice gimmicky introduction, but I definitely wouldn't shelve out $25 for it. I think most installations of `vim` also come with a `vimtutor` command that gives very thorough explanations, tutorials and examples. :) 
GTK maybe, if you don't need to run on OS X (little bit painful to get working). I have some examples with PyGtk 2 and 3 [here](https://github.com/alexandrevicenzi/GladeBuilder). GTK looks good on Linux (native), and a little bit XP-like on Windows.
Semantics has to do with the meaning of things, syntax has to do with their form. The phrase "'syntactically meaninful' is more than a little bit confusing".
&gt; This, in a way, restricts the use of functional idioms in Python and forces code to be written more linear, more in a procedural style. This is by design. Mastery of programming is not reached by creating dense, functional code. It is found by writing universally expressive code that gets the same stuff done. Python guides you towards the latter. Guido knows what he's doing.
Other scripts that I use, but are worked on by labmates, also live on the remove server. Though I could always pull them down into my machine. Part of the reason is that I work on Windows and the remote server is Unix. Not all our scripts and tools would work on Windows. I should just dual boot Linux...but I haven't gotten around to it yet. Bigger reason, though, is that a lot of the files we work with are gigantic. Our cluster has lots of cores and we can parallelize different analyses to make things fast! Storing and downloading those files would be a pain over wifi, but the cluster has a superfast connection.
It's difficult in some points. You only can get a data source if there's an end point for that. e.g: an API. If the page is rendered at server you can't do such thing. May you could use some crawler in this case.
 &gt;&gt;&gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!
Cool trick: Read a book about the next big JavaScript framework. By the time you finish it, they will have already created a new and better one!
Thanks. That's what I was thinking, too -- that it was fairly complete in terms of language features. But with @ being added, and talk of `async` and `await` keywords (see [here](https://mail.python.org/pipermail/python-ideas/2015-April/033050.html)), it does seem things are moving faster -- Guido indicates that [here](https://mail.python.org/pipermail/python-ideas/2015-April/033050.html).
Vim is built around a language of key presses. Because it's a language, it builds on itself. People who don't know what they're talking about think it's a bazillion hotkeys. It's not. It's a bunch of verbs, nouns, adjectives, direct objects, etc., each expressible as typically one or two keys. Motions are Vim's grammatical direct objects. There are tons of them. A few, for example, include: hjkl Vim's cursor keys - left, up, down, right, one line/character 0 1st column on current line ^ 1st non-whitespace character on current line $ last column on current line b previous beginning of word before cursor w next beginning of word after cursor e next end of word after cursor fx forward onto next occurrence of x on current line Fx backward onto previous occurrence of x on current line tx to just before next occurrence of x on current line Tx to just after previous occurrence of x on current line } to next empty line { to previous empty line gg first line of buffer (and first non-whitespace character, if any) G last line of buffer (and first non-whitespace character, if any) There are dozens more, and you can define your own. There are plugins that define many more. Motions are a way of instantly jumping to where you want to jump, and when you get used to them, you don't even think about them. They become muscle-memory, and you can get blazingly fast with them. Watching anyone else use a regular editor after even just learning this first level is painful. They seem achingly slow. Most of these motions take a count - a count adjective, to be precise - so you can, e.g. `3w` to jump to the 3rd beginning of a word after the cursor, or `4t(` to jump to one character before the 4th open-paren after the cursor, or `3gg` to jump to the 3rd line from the top of the entire buffer, respectively. It's amazing when you start being able to feel how many 'f's there are after your cursor, and you just subconsciously hit `4f`, land exactly on the character you want to, and keep going without pause. There are also text objects, which are like motions in both directions. They let you talk about logical regions *surrounding* your cursor. These all start with either `i` (for inner) or `a` (for around). The difference is that `a` includes the thing surrounding what you're talking about (or whitespace), and `i` doesn't. For example (and there are not only many more, but you can define more, and one plugin actually defines more than 400 more!): iw in word ip in paragraph ap around paragraph i" in double quotes a' around single quotes i) in parens ib in parens ("brackets") a] around square brackets i} in curly brackets These don't make sense on their own, but consider hitting `v`, which puts you in visual select mode. From this mode you can type one of these text objects, and it will swell the selection in both directions to select all of it. For example, `vip` will select the paragraph you're in ("visual in paragrah"). `vap` does the same, plus surrounding whitespace. `va"` will grab everything in the double quotes you're cursor is in, as well as the quotes ("visual around double quotes"). `vi"` grabs just what's in the quotes ("visual in double quotes"). These *also* take a count, so if you do `v2a}`, you'll visually select everything around you out to two curly-brace levels, including the braces. All of this gets much cooler when you add in the verbs. Some of these include: c change d delete y yank (copy) gU "go upper" (uppercase) Change is like delete, except it leaves you in insert mode, so you can immediately start typing a new thing. It also remembers the whole thing as an action, so I can, e.g. do `c2iw` to change the word I'm in (wherever I am in it), along with the following word to some new thing. When I'm done typing the new thing - which can be any length - I hit escape to get back to normal mode, and then I can go to another word and hit `.` (dot is redo) to change *that* word, *and* the word following it to the same thing. This gets handy. If I want to comment out a few lines, I might hit `I#` to insert at the beginning of the line a #, then escape out, and visit other lines, hitting . to do the same to each in turn. Regardless of where I am on each line, . inserts a # at the beginning, because that's what `I` does (enters insert mode at the start of the line), and the previous action was `I#` - the 'insert at the beginning of the line' is baked into the redo. This comes in handy in all manner of places. `ci)new thing&lt;Esc&gt;` changes everything in the parentheses I'm in to "new thing", and then . in any other pair of parentheses does the same. So, if I want to delete the paragraph I'm in, I don't reach for the mouse. I never reach for the mouse. It's a huge slow-down. Gary Bernhardt also hates the mouse, and has a good quote on that: "I like the cadence of always typing." Me too. I type `dip`, and the paragraph is gone. `d2ip` would kill 2 paragraphs. This is almost instantaneous. I don't really type `dip` in sequence, though. It's not so deliberate. I kind of form my fingers in the right heights *as* they all fall simultaneously, striking in a kind of fraction-of-a-second arpeggio that sounds like a single key press. It's total muscle memory. It's just an action in my brain now that happens without thought. I also don't think so much in terms of discrete actions like `dip` anymore. I think in streams of small bursts of them. The muscle memory composes into new things. I know I want to move a block 2 down from where it is, but I don't start performing the actions of that. I do dap2}p, and it's done in about 0.5 seconds. I didn't think at all. Almost every change I ever make takes a fraction of a second. It *really* changes how you think after awhile, and absolutely changes how you work. I'm an order of magnitude faster than I was in my favorite GUI editor, sometimes 2 orders. I'm quite convinced that heavy Vim use changes your brain to hold information better as well. I'm in my late 30s, and my memory has gone through the roof exactly as my abilities in Vim (and a few other things) have increased. I don't even have to practice new keys and usage anymore. I just absorb things now. I hardly even write things down these days, because I just remember tons more than I used to. You can get a sense of how Vim allows for rapid action with [this screencast](http://blog.extracheese.org/2010/11/screencast-custom-vim-refactorings.html), though note that Gary makes a lot of typos as he works, and he rarely uses the best Vim combos. I'm a bit slower than him in raw typing speed, but make almost no typos as I work, and almost always use the best available combo. It's a very clean, efficient, deliberate way of working, and it gets completely out of my way in the way that working with a mouse in a regular editor can't even dream of doing, and never did for the 20 years I programmed without Vim. It's very important to note before I end this that `cip` doesn't exist. It's a sentence. I'm sticking the action `c` with the text object `ip`, to create the idea of changing the entire paragraph I'm in. This is why Vim *isn't* thousands of hotkeys. It's thousands of possible phrases, but it's made of only dozens of pieces of a few kinds of parts of speech, and you can absolutely develop a natural-language-like flow with them. Early on you might thing of the pieces as discrete things, but eventually you think in terms of entire thoughts, and it's just like learning a language and becoming fluent in it, where you can express new things all the time, naturally. The difference is that it's really just a dialect of English - great if you already know English! If I tell you my friend's name is "Fooblop," even if you've never heard that name before, you don't have to learn or relearn any English to use the name. You can immediately fold it into your entire knowledge of English to say all manner of interesting things, like "Fooblop is an interesting name," or "For how long are you in town, Fooblop?" or "I think Fooblop should meet my other friend, Bill." This is the magic of Vim's model. Once you're comfy with the basics, I can teach you another motion - most are fairly obvious/mnemonic in nature - and suddenly you can say 8 new things without any more effort. I teach you a new verb, and you can say dozens, maybe hundreds of new things by mixing it with motions, text objects, and adding in counts where needed. I'll also add that Vim feels to me like rock climbing (which I've never done, so I could be wrong :). It's all about quickly finding good handholds. If I want to indent the paragraph I'm in, that's an obvious thing to reach for - `&gt;ip`, i.e. "indent in paragraph." If I want to indent just this line, I use the doubling shorthand (most commands can be doubled to mean "do this... here", e.g. `cc` changes the line you're on, `dd` changes the line you're one, `gUgU` uppercases the line you're on (doubled-doublings usually have a shorthand version (because Vim/efficiency), so `gUgU` can also be stated as `gUU`), so I'd do `&gt;&gt;`. If I wanted to indent the current line and the 3 below it, I'd do `&gt;3j`, i.e. "indent from here to down 3 lines." If I wanted to indent from the current line to the next blank line (e.g. to the end of the current block), I'd do `&gt;}`. I use `{` and `}` to jump around to blank lines often. I use `&gt;` to indent often. When I want to combine those, it's obvious and easy to do. While there are other nice things, this is the core power of Vim. Your keyboard becomes an interpreter of your thoughts, allowing you to speak commands as sentences at your text editor at remarkable speed. You don't think about WASD when you play a game. I don't think about anything when I edit text, except what I want it to say, and my fingers automatically do the rest now.
Now if only there was a way to have all this in a Sublime Text 3 or Notepad++ setup. 
I think three more have been announced in the time it took me to read this comment!
Vim has changed everything about how I work, and all for the better. It's magical and incredible. I can't even use other editors now, because they're so horrible by comparison. Vim is on my short list of must-learns. Other things include git (beautiful) and haskell (unbelievable, game-changing).
I think there are no multiline lambdas in Python, because it's the one place where Python is about expressions, and not statements. Lambdas have a value, which is why you don't need return. Statement blocks don't, which is why functions need a return to have a value. There are no multiline anythings in Haskell, either, because it's all expressions. There are some bits of language syntax that give you the feeling of multiple lines, like where-clauses, and do notation, but they're syntactic sugar that expands back out to singular expressions.
The only time this has been a problem for me is in Python code pasted and sent to me through Outlook, which seems to strip indentation, just for fun. Reindenting pages of Python code requires figuring out what every line of the code does. I suppose there's some utility in that, but also omg.
for what it's worth, coding stuff in PyQt always feels satisfying and correct, even with all crufty verbosity inherited from C++. I'm always impressed by how awesome that framework feels. VTK is up there, too. 
Say you're in charge of hiring me. What do want to see from me to prove that? Github? Show up with a thumb drive of different projects?
How do I do function application through pattern matching in Python? How do I get rid of the parens and colons? How do I get where-clauses? What do I do for algebraic data types, and pattern matching on them? How can I disallow nil values? What about structural sharing? Can I do Lisp-like macros? Can I use any unicode characters for identifiers? Can I make laziness the default? Much of this is syntactic, but much of it isn't. Yes, you can do anything in any Turing complete language, but for many things, this involves writing another language in your language (with its own grammar, compiler, etc), which isn't really Python anymore. I'm just taking umbrage with the idea that you can do anything at all in *any* language, let alone Python. It's a bit disingenuous, and a bit misleading for newbies. There's nothing wrong with being honest and saying that ADTs aren't really available in Python, just as multiline functions/statements aren't really available in Haskell.
Pillow *is* PIL.
&gt; $ is a pain to type compared to pressing end, and I'm much more comfortable using backspace/ctrl+backspace to for example delete a character/word (delete/ctrl+delete to delete a character/word forward). Killing the rest of a line is a bit harder with home+end, backspace though. And it's not just that! Can you easily delete, say, three words? What about from the cursor to the next comma, paren, or other arbitrary selection? And then you add vim's ability to re-perform the previous action with `.`, and things get really great.
Having had to work on a significant Haskell project in the past, I can say that I will always prefer to work in Python for anything large or complicated. Maybe Haskell is more pure or whatever, but I think it is a horrible experience.
Procedural vs. functional has absolutely nothing to do with it. `lambda` could easily take a block, but then it wouldn't be a lambda expression in the strict sense (but then, whether being puristic about FP concepts in a language as thoroughly imperative as Python makes any sense at all stands to reason). Either way, anonymous functions take blocks in other languages similar to Python - Ruby, JavaScript, PHP, even most Lisps, they all allow anonymous functions to contain the same things as named functions. Python, however, tries to be a pure functional language in this regard (but, as the keen reader may observe, fails, because while the body of a lambda has to be an expression, not a statement, it can still have as many side effects as you want: `lambda x: print(x)` is completely valid). Haskell, by the way, has less of a problem with this because whitespace is only relevant within certain contexts, and even those can be avoided if you want to be extremist about it. Besides, it is rare to see Haskell functions longer than a dozen lines or so, except when you are dealing with some eDSL or data description minilanguage where long functions are more natural. And, as a closing note, nothing in Haskell demands or even just suggests "mixed-length indentations" - some people like to align things based on the keyword that introduces layout, but others (including myself) stick with fixed 2-space or 4-space indents, and the resulting code looks much like Python in this regard. For some reason, though, "leading comma" style works better than it does in Python: data Foo = Foobar { foobarName :: String , foobarSize :: Double }
&gt; Mastery of programming is not reached by creating dense, functional code. As a general statement: true. Of course. &gt; Guido knows what he's doing. That may as well be true. But then again, decisions like structure by indentation and a general procedural programming model were made deep in the 1990s. And now the language has to deal with those decisions some 20 years later. Not saying these were bad decisions or that we cannot deal with them. And it is not something which could be changed in any way. But those decisions most certainly were not made in knowing that they’d still be used today. That is not to say that the very same Python could not be conceived today. But the syntactical pros and cons would be different than 20 years earlier.
One more very major feature that breaks backward compatibility is the model meta API. This should definitely be called out in any discussions re: what's new in 1.8, since it does break backward compatibility.
&gt; `lambda` could easily take a block Hmm, how would the syntax look like then? I am genuinely interested. Not arguing with anything of the rest. I think we mainly differ in how we define style guides.
`{}` is more like the `:` in Python…
Does Kivy do this? 
In C: 10 statements → 10 + 2 tokens. 5 statements → 5 + 2 tokens. 1 statement → 1 + 2 tokens. 0 statements → 0 + 2 tokens. In Python: 10 statements → 10 tokens. 5 statements → 5 tokens. 1 statement → 1 token. **0 statements → 1 token**. That last one is where stuff breaks. Deleting a line is isomorphic with deleting a statement; **except** when that line was the last one in the block, in which case we need to use `pass` instead of deleting. Not isomorphic.
Paraphrasing my example from elsewhere: if foo: bar baz Now I want to paste something (doesn't even matter what, really) between `bar` and `baz` - how to indent? You can't tell for sure, either choice is going to be wrong in about 50% of all cases.
You're totally right, I should have mentioned this. 
I think you missed the **unless you specify syntax limits**, because you just listed a bunch of syntactical limits you'd like. Python doesn't have pattern matching or lisp style macros, just as haskell doesn't have non-recursive for loops or natural eager evaluation and C doesn't have indentation-defined macros. Granted you can usually express the same thing in a more cumbersome logic. E.g., you could take a common pattern matching example from haskell: mySum [] = 0 mySum (x:xs) = x + mySum xs and do it in python: def my_sum(ys): if ys == []: return 0 x, xs = y[0], ys[1:] return x + my_sum(xs) Sure, this is going to be inefficient python as python does recursion quite poorly, but it expresses the same logic.
Hotkeys are indeed the benefit. Working in a terminal means losing a ton of fancy GUI/mouse usability niceties. You can regain some of the functionality through advanced hotkeys and plugins. It is a very steep learning cliff though (once you get past the basics) and a lot comes down to configuration and personal preferences. 
pyGal does seem to be a bit laggy in use. I've also noticed it doesn't update correctly in Firefox. Sometimes the mouse-over effects work and sometimes they don't. They do work fine in Chrome. I'll probably try out Bokeh in a future article and see if performance is better or if I just like its graphs better.
We don't need it. def y(x): print(x) return x * x map(y, range(5)) 
Look at Delphi: http://www.deltics.co.nz/blog/posts/2223 Here you have users saying they need a "no-op" statement to make code clearer. In fact, there's a whole Stack Overflow question asking users what they use instead: http://stackoverflow.com/q/7536493/267938 ...and you find some users using comments to fill the space e.g. // Do Nothing or //No-Op Python, as usual, is right on the money here and shows how beautifully designed it is - IMHO because the people who develop it have other jobs using it all day so they know what they want/need and what won't work. 
A situation where two people both want to expand a definition / stub into code at the same time? Something has already gone wrong then. This is not a case you can be using to try to argue its uglyness. The changes might *look* nicer syntactically when viewing a merge diff, but this is purely superficial. They will both be the exact same difficulty semantically trying to figure out the order or conflict of code. And in your first case, even pragmatically I find `pass` easier: in 90% of editors, just double click on it and start typing out code instead. Practically the simplest possible workflow, no enters or caret movement required.
But... duplicity already does that. [Duplicity](http://duplicity.nongnu.org/).
Did you have much functional programming experience at the time? What were the worst parts about it (syntax? advanced things, like monads?)?
This question would be better suited for /r/learnpython or /r/maya. I suggest you take a look at the official pymel documentation at: http://download.autodesk.com/us/maya/2011help/pymel/generated/functions/pymel.core.windows/pymel.core.windows.image.html#pymel.core.windows.image Here you can read up on the image method and make sure to take a look at the code example at the bottom of the page.
/u/aspyct (and possibly you) are confusing "semantics" as it's commonly used with "[semantics](http://en.wikipedia.org/wiki/Semantics_%28computer_science%29)" as it applies to programming languages. "pass" does not perform any kind of state change, it does not correspond to any action taken by the interpreter. It may mean something to the person reading it, as would a comment, but from this point of view, neither of these things have semantic meaning in the sense of formalization of programming languages. Put another way, neither would have a "non-empty" representation in a proof system which correctly models the python language. edit: disambiguation of OP
this is a fair point. In hindsight I wish I would have said "syntactically required"
Well, but you can't have a block with no statements in it. Why not? There is no *semantic* reason for it, the only reason is syntax.
Unequivocally? Wow. I'm rarely so convinced of myself anymore. &gt;Computers, despite the name, have always been task executors rather than math calculators. Really? All of the early machines I've researched have only done mathematical calculations. You entered a number, through switches, punch cards, etc., and they output other numbers. We do things now on computers that seem like they're not math, but under the hood it's still all numbers. &gt;but that side effect is what makes computers so damn useful to our everyday lives Are you using the term "side effect" [as I know it](http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29)? I'm not particularly excited about such things, and I'm glad we're using math to find ways - e.g. monads - to reason about and deal with the huge problems they create for us. &gt;the ability to do more than just math. I don't think computers *can* do more than just math. We can layer abstractions atop the math, but it's all still just math. &gt;So, yes, when we are doing actual number crunching we want "math", There's quite a lot of math that doesn't involve numbers. "True &amp;&amp; False" is math. It's boolean algebra. `map toUpper "foo"` is math. "foo" is a list of characters, which is a functor, which is an element of category theory, i.e. math. The `map` function is actually functor mapping, which in this case takes characters from the domain of all characters to the codomain of all characters not including lowercase characters. When I say I want math, I don't mean numbers. I mean I want pure functions, i.e. proper, mathematical functions, with referential transparency. When I call the same function later with the same inputs, I want to be guaranteed that I'll receive the same output. I think we all want that almost all of the time. I don't want to have no idea that your function is calling out to the web, or to the disk, or to the user for input, or to a random number generator. If you must do that, fine, but I want it to be super obvious, and to occupy as small a footprint as possible. I want structures, like monoids, and applicatives, that come from math, and thus come with known properties and strong guarantees about what exactly can happen if I use them. I want the composability that such structures allow. I think most of us would like such things. They're really nice. I want type guarantees. I don't like that `5 + (4 if x else "foo")` works in Python when x is truthy, but fails with a type error when x is falsy. I didn't really think about such things until I learned Haskell, where everything is an expression, and has a type, so `if` must come with `else`, and the results down either branch must match in type (because the whole if/else expression has a single type), so I can always do `5 + (if z then x else y)`, because x and y have to be numbers (and z has to be a boolean), or the program won't even compile. That's a weird bug I'll never be able to write (nor will my coworkers), let alone have crash the program a month from now. Functional reactive programming seems to hold a lot of promise for dealing with constant inputs and outputs (side effects) in purely functional (i.e. much more mathematical) ways than the callback hell that's plagued us for awhile now. I think we *do* want math most of the time. &gt;those languages will never be able to fulfill all programming needs. I remain unconvinced.
I know I'm the minority here .. but I REALLY miss the braces. I HATE the forced whitespace because when I switch editors it sometimes gets mucked up between tabs and spaces. 
http://wbond.net/sublime_packages/sftp It works by putting a config file into a folder on your computer and maps that folder to a folder on a remote server with a specified path you put in the file. Enjoy! Occasionally it can be annoying if I don't have internet/the remote server is down. When that happens I comment out the sftp-config.json file til I have internet again. 
&gt;&gt;I think you missed the unless you specify syntax limits Nope: &gt;Much of this is syntactic, but much of it isn't. Also: &gt;&gt; Python doesn't have pattern matching or lisp style macros, just as haskell doesn't have non-recursive for loops or natural eager evaluation and C doesn't have indentation-defined macros. Yep: &gt;There's nothing wrong with being honest and saying that ADTs aren't really available in Python, just as multiline functions/statements aren't really available in Haskell. My point was that it felt disingenuous to imply that anything in the world you could ever want to do could be done in Python, because it implies further that there's no need to ever learn another language, when the truth is that there's a tremendous amount more to learn out there, and learning other languages - especially ones in other paradigms - is hugely valuable. I've become much better at Python by learning Lisp, Haskell, a little bit of Forth and Prolog, and a few other languages. I've actually *lost* a lot of interest in Python (previously my main/most beloved language) because of Haskell, and find myself dropping into Haskell to solve something, then going back to Python to write some Pythonic implementation, which I never like as much. I've come to regard dissenting voices in these programming forums as being some of the most valuable things I've encountered. They've shaken me up, rid me of belief systems, informed me of things I didn't know, and furthered my knowledge and abilities more than most things, so I like to potentially be that for others now, when I have a moment.
Also a mediocre programmer. I love Python because of the simplicity. I was learning Ruby when I discovered Python, and it just clicked with me. These type hints are just going to bog me down. I like the idea of a separate file (or perhaps a separate section) of stubs if that would improve execution speed (why else are we doing this?) where it's needed. The downside, of course, is having to manage two separate descriptions of a function. This is already required in c-like languages, so I imagine tools could help. 
Like it too. Python code is more 'readable' in my opinion then any other code. From day 1, anyone who has ever programmed before know what the statement is doing, while if there was nothing there you'd have to know the meaning of nothing being there, if that makes any sense. Though copying is an annoying issue, as one line always seems to manage to be indented differently then where I copied it from. 
For anyone who came here thinking the question is not about editing but about creating PDFs: The best way I found to create PDFs in any programming language is to use LaTeX. Use a template engine like Jinja2 and render the templates into .tex files. Then call pdflatex or your own choice of compiler. EDIT: Oh and when you do it in a web application escape your data or you'll get a LaTeX injection attack vector.
The Python-only web offerings continue. First [nagare](http://naga.re) then [Reahl](http://reahl.org) and now Flexx. 
Good point. I forgot about that definition of semantics, though it makes perfect sense in retrospect. In that case, though, there are *tons* of things that are syntactically "meaningful" but semantically empty, so the argument of /u/tdammers falls a little flat. There is no isomorphism between syntax and semantics. Any given semantic has many syntactic structures that could have created it. The relationship between syntax and semantics is many-to-one, not one-to-one.
Afaik, there are no plans for cpython to use type hints to improve performance. It's just a documentation thing (and for improving IDEs and the like). I'd be much more in favor of optional static typing that improved performance (like cython) being built in than hints.
This was a fantastic read. You've persuaded me and I can't help but think this gem of a comment deserves more exposure. Do you mind if I submit it? Or better yet if you have a blog. In the past I did make an effort to use VIM but of course didn't know anything of what you explained and didn't understand the fuss. This was profoundly enlightening. I read your other post mentioning Haskell, which has piqued my interest. With all your technical savvy may I ask what line of development you are in? I've been programming for a year. I have so many things on my list, including wonderful algorithm books, higher mathematics, SQL, Github and Haskell. May I ask where you would prioritize VIM on that adumbration? 
Your two "opposed" documentation examples are pretty similar. You describe the type of the argument in each. If type hinting solves having to otherwise document the types of argument, you should be able to dispose of describing the type in the docstring, yet it would be much less readable as we intuitively expect type information in the description of the argument anyway. Also, if you were using type hints in your understanding of code, you'd presumably have a plugin for your IDE (or vim or emacs) that does this anyway. I believe IDE improvement is a big motivator for type hints. Inline or stub file, it makes no difference to the majority of use cases.
And op says this is exactly the problem.
Now I'm looking up Nano...
Probably there are a lot of tools that do the same thing. In my case, I was trying to understand a little bit of boto lib. :)
But manipulating matplotlib artist objects seems very pythonic. Matplotlib's object oriented side makes it capable of anything. If you want your stuff to look like ggplot, just make an appropriate matplotlibrc file.
What about changing your code base to use pillow? Should be an almost trivial change, no? And it's a good change for keeping your code base more future compatible.
Oh and PyJS (which seems to have merged with Pyjamas) ... but this compiles Python to javascript, so you need to hook it up to pure Python via a networking mechanism.
What are you pasting in? Also in that situation, as you would have to add a newline to accept the new code it would be under the if branch if you were already indented, and if not then it should be outside the if branch
Have you looked at Plone? https://plone.org/
When I posted that, there was no actual link to the rc2 download. It probably appeared a little later.
The problem is that a dynamic html page needs Javascript, so then you're using two languages.
Thanks for the reply so just to clarify my program needs to be able to handle multiple inputs that while do different things. Basically the program will always display text that it gets from the Arduino that says voltage and current, but while it displays this text I need to be able to input things like r to reset the program or s to stop it. S will the signal module be able to do that? 
I've done most of my work using PyQt.
Wagtail is great! Highly recommended. 
You've jumped through pages of hoops to tell him what he already knows. Even the most trivial task involves shitloads of math, because it's essential to do the thing. And yes, of course, the means and end can be described mathematically, because of course they can. But that does not make the essential and abstracted *means* == the desired end. Not if we're being intellectually honest. 
Each `count()` call spawns a separate generator, so yes. But I'd really think there'd be a more attractive alternative to nesting infinite loops. Generally you use a `while True:` in python in order to emulate a `do-while`-type loop, or maybe in some cases where the stopping condition is very complicated. It's just hard for me to imagine a situation where nesting them couldn't be replaced by using a simpler structure somehow.
No, op said the problem is python-pptx ``install_requires`` Pillow and op's project ``install_requires`` PIL. Since op's project will likely not notice the difference between Pillow and PIL (by design, because Pillow *is* PIL), op should consider ``s/PIL/Pillow/``. Sorry, I should have explained this in more detail. Also there are at least 4 different attempts to address this situation in some way or another on PyPI, maybe one will help (in the case where op's project cannot switch to Pillow): - pillowfight - pil-or-pillow - Pillow-PIL - pillowcase 
Maybe it would be best to try this out on a night with a SF Python User Group meetup. If you want more 1 on 1 chat time check out the project nights. 
Important is the line just after that one in the Zen: &gt;Although practicality beats purity. This cuts both ways: in the writing of what compliant python *is* and what good python code is. Meaning that here, it is (and sometimes should be) possible to break some of the hard-fast rules of the syntax because it is more practical that way. A good example is that the pep8 rule on line length that was talked about recently, should probably read more along "$char_nums_per_line ... ish" (eg, "80-ish length"), because sometimes it is just more practical to have the line go to 82. IMO though if people want to break/change the syntax of python we have the whole AST module that can allow that. For example, XML-ast python is a nice one to use for computer generated code.
Yea I find that if cron jobs are giving me trouble I have them call a simple wrapping .sh script that captured my environment variables *then* running the program I needed.
FWIW, [Substance D](http://substanced.net) is a more modernized web application server that steals a lot of concepts from Zope and Plone. It's built on Pyramid using ZODB. 
Came here to say this. +1 for this great tool. 
An example?
Submit away. I don't have a blog, though I've considered it. I'm in games, but kind of a weirdo. I've been called an academic, and realized it fits. I'm not a great academic - I went to art school, did *okay* - but any free time I have I'm reading up on Haskell, or trying an /r/dailyprogrammer challenge, or fighting to grok monads, and I've always been like that. It sounds like you may be as well (*sees "adumbration" in comment, decides you're definitely like that*). The real shocker for me has been [only recently] realizing that most people *aren't* like that, even in the world of programming. I've had the hardest time getting even devs interested in any of this. I thought it was just me, but my Haskell meetup group friends say the same thing: "I can't find anyone who cares about x," where x is FP, Vim, emacs, git, monads, Haskell, etc. I used to think people *would* really like these things, if only y, where y is "they could see what I'm seeing," or "they could see how this solves their struggle(s)," or "they weren't afraid of z" where z is time investment, failure, looking like a nerd, me (I'm kind of big and beardy), or whatever. Now I think most people aren't academics, and don't just get pleasure out of learning a bunch of new things, and it's kind of a hassle to them. To that end, I've been trying to learn more Haskell and OpenGL *through* Haskell, so I can make some game-like things to show coworkers to get them interested in Haskell. Then I found out that Haskell library monster Edward Kmett is [doing the same thing](https://www.youtube.com/watch?v=yFXzuCFeRGM&amp;feature=youtu.be&amp;t=1h41m35s). I was linked to that by a games dev in Japan who is making demos to try to convince his game industry peers that Haskell is cool. No one he works with in games so far is interested. I learned about Haskell from an old coworker (in games, now at another games company) who has been trying to get his coworkers interested in Haskell, even porting some ideas to C++ and giving talks about the benefits. He's having a hard time getting anyone into it. We're a small, scattered task force. Please join us :) &gt;I have so many things on my list That's only going to get worse :) My list is huge, and always grows. It includes other lists, like Ollie Charles [papers](https://github.com/ocharles/papers) repo, and [this more-specific-to-Haskell list](http://www.reddit.com/r/haskell/comments/2blsqa/papers_every_haskeller_should_read/). That's far from a full list, and that's just papers. I have lots of long comments, big websites, whole books, and areas of mathematics to get through. It's daunting, and I've heard the same lament from many in the Haskell community, which is full of academics. As a group we're quite info-addicted, even if - perhaps especially when - it's painfully complex. &gt;May I ask where you would prioritize VIM For me, it's ASAP/ongoing. I use it with everything I do. It forms a kind of base for all my other efforts. I can say that once committed to it, it took me only a few days to be useful, and a few weeks to be very comfy with the basics, as there are maybe a couple dozen. The only other person I've managed to get to use Vim was a coworker who saw me do so many things so quickly that he wanted in. He told me after 2 weeks of use that he was already ruined for any other editor, and felt he was faster than he'd ever been in Notepad++. YMMV. Think of how long it takes to learn a few new game mechanics with a weird controller - not that long if you're interested. You can be using hjkl to move around by lines and characters in seconds to minutes, and wWbBeE to be jumping around by words not long after that, i and a to insert and append (enter insert mode before and after the cursor) quickly, escaping back out to normal mode right after that, then using 0^$ to jump to line edges, and I and A to do so along with entering insert mode (escape to get out) all in the first day. Each new thing is no big deal. E.g. hit o to 'open' (create/enter insert mode) a line after the one you're on (escape to get back to normal mode). Hit O to do the same thing, but above the line you're on. Try it with a count (e.g. `10oawesome&lt;Esc&gt;`). There are a few things that come back around often in Vim. For example, often the shifted version of a key reverses the direction. We just saw that `o` opens below, and `O` opens above. Likewise, `/` puts you in the search prompt - type something and hit enter to start searching forward - while `?` (shift-/ on most US keyboards) does the same, searching in reverse. Once you're searching, `n` will jump to the next match, and `N` will jump to the previous. If you started with a `?` search, `n` finds the previous, and `N` finds the next. `gg` jumps to the first line of the file, and `G` jumps to the last. `g` is a prefix for a ton of commands - it's Vim's junk drawer - so that's why `g` is doubled. E.g. `gU` is "go upper" which is an upper-casing command, while lower-case is the lower-case version - `gu`. I think of the above as "shifted" versions of keys, whereas for others I think of them as capitals, and these are like superlative versions of commands. E.g. `d` is delete, which takes a motion, but `D` deletes to the end of the line, and thus needs no motion. The same thing happens with `C`. Oddly, this is not how `Y` works (it copies the line, like `yy`), but many - including me - fix that in our vimrc files with `nnoremap Y y$`, which remaps (in normal mode) the pressing of `Y` to actually be the pressing of `y$`, which is the sentence "yank to the end of the current line" (you may recognize that verb and motion from the original post). Most of us consider how `Y` is implemented to be an error, or oversight. Doubling is also super common for verbs, as I mentioned in the earlier post. All commands want a target - either a motion or text object - on which to operate, but many let you repeat them to mean "where I am," and that usually means the current line, because Vim started out as QED (late 60s!), which became ed, then ex, all of which were [line editors](http://en.wikipedia.org/wiki/Line_editor) (Vim is a [screen editor](http://en.wikipedia.org/wiki/Visual_editor)), so a lot of its powers are line-oriented. So, I can give you a fish (the above), or I can teach you to fish (what comes next): 1. Vim's helps rock - read 'em. 1. Get input. IMO, I wasted 15 years wanting to solve every problem myself, and never see how anyone else did things, or read anyone else's code, or talk to anyone about their ideas. This held me back tremendously. I've had 10 minute talks in #haskell that have cleared up something I've been trying to understand for 2 weeks. I've learned faster this past year than I ever have, because I'm in meetup groups, on freenode, in reddit programming rooms, etc. 1. Read other people's code, especially if it solves cool problems, and looks clean and clear. This might be someone who knows some things, and you want to know them, too. I'm guilty of not doing this nearly enough, and I think this is common. Peter Seibel, Lisp guru, and author of the fantastic "Practical Lisp" (the most starkly beautiful [online tech book](http://www.gigamonkeys.com/book/) I've read, up there with [Pro Git](http://git-scm.com/book/en/v2)) has [a Google talk](https://www.youtube.com/watch?v=pQy22qPH7i4) on one of his other books, "Coders at Work," wherein he interviewed 15 famous coders to see what makes them tick, and he found that everyone thought reading other people's code was paramount, but very few actually did it. 1. Read books on coding. I think an important one for new programmers, which is still great for old pros is "Clean Code," by Robert C. Martin. I want to throw that thing at half of the programmers I've ever worked with. It's just all good advice on writing code that's easy to change, which is the thing that code hates being, and one of the biggest problems for devs. 1. Speaking of, Clojure creator Rich Hickey has a great line in [this talk](https://www.youtube.com/watch?v=rI8tNMsozo0): "There's a new participant in our standup. It's growing in the corner of the room. It's this elephant. It's called 'the software we've already written.'" Martin's book is full of ways of dealing with that very real, very constant presence. I've been on games canceled because dev slowed to a messy crawl. I've seen a never ending stream of ideas shot down, because it would be too hard now to get them in, with how complicated everything is. I've seen this go by unnoticed even more times. Estimates are longer than they would be, because things are crazy. It's usually there when someone says "That would take like, 1 to 2 weeks, at least." It's rarely a hard problem - but the mess makes it hard. Most of my ideas are made a lot more complicated by other things - outside forces, like the messiness of coupling with something else, or the environment that's a mess, and doesn't allow for my ideas in an elegant way. 1. Learn a few languages, but make them count. Don't learn just learn Python, Ruby, Javascript, and 3 other languages roughly like them. Learn languages that will change how you think entirely. Learn a stack-based language, like Forth. Learn a Lisp (Common Lisp or Clojure, e.g.) for its amazing macros (nothing like macros in other languages) and the 'everything is a list' and 'code is data' ideas. Learn Prolog or miniKanren, or Clojure's core.logic for logic programming (Aja Hammerly has [a great talk](https://www.youtube.com/watch?v=hEOVcLAPRG8) on this). Learn C to get close to the metal and experience history (the language is tiny and simple - doing big things with it is hard). Learn an Assembly to get even closer to the metal and experience ancient history, if you care to, but don't stay there too long :) Learn Haskell to learn functional programming, mathematical concepts, and to experience [purity](http://en.wikipedia.org/wiki/Pure_function) in Hard Mode, no warps. 1. Find the best; learn from them.
All of your examples were syntactic. (1) Pattern matching can make elegant code and you can go that route in python with if clauses checking types of arguments. (2) Where clauses are simply syntactic sugar. E.g., instead of writing quicksort with pattern matching and where clause like: quicksort [] = [] quicksort (x:xs) = (quicksort less) ++ [x] ++ (quicksort more) where less = filter (&lt; x) xs more = filter (&gt;= x) xs You would write def quicksort(ys): if ys == []: return [] x, xs = ys[0], ys[e1:] less = filter(lambda y: y &lt; x, xs) more = filter(lambda y: y &gt;= x, xs) return quicksort(less) + [x] + quicksort(more) Getting rid of parens and colons are just syntax. You really want algebraic data types/lazy evaluation/macros etc in python? Try imports like [MacroPy](https://github.com/lihaoyi/macropy). Second, never claimed there's no reason to not learn other languages. There are plenty; languages can be better (either cleanness of code, or getting efficient fast code to execute) at solving particular tasks. Pure functional languages like haskell are great for mathematical based problems. Prolog is wonderful for solving problems where you have a ton of facts and just want to plug in facts and have it's built in backtracking search output valid solutions for you. Javascript is necessary for client-side web stuff (and useful for async server side webstuff with node). SQL is necessary for working with DBs (yes ORMs exist, but its helpful to understand SQL; at the very least for adding proper indexes and optimizing queries). R is great for statistical analysis of data. Matlab/octave is good at dealing for tasks well-modeled with linear algebra with numerical data. Mathematica (and to lesser extent sage) is great at doing things with symbolic math. C is necessary if you need lower level stuff like writing a device driver or embedding something on a simple controller. C++ / D / Rust (maybe soon?) if you want fast implementation with modern language features. Ruby on Rails was the beautiful web framework of choice a few years back and ruby is still a nice scripting language. Java/C# have their places as something more accessible (better libraries, more crossplatform) than C++, but close to C++ in speed. etc.
this is right
Ultimately, I got what I want. I just wanted to make sure new programmers reading this thread wouldn't see "You can do anything you'd ever want to do in Python" and think "Cool, I'm done," and skip out on learning anything else for many years. You not only agree, you clearly know a bunch of other languages, which would imply on its own that you value learning more than just one language.
Separate type and/or separate section nails it Haskell has this great type syntax already. I don't get why we can't get the purely-visual version of that.
ah, I see. He needs pptx in his current project that already uses PIL. I though he was asking how to install pptx without messing with his base install.
I've yet to jump on the virtual environment bandwagon... I've been gradually adding best practices over time as my time allows (Python replacing some MATLAB, using version control, using distributed version control, writing tests, ...). Being on Python 3.4 on windows using Anaconda, I'd love to hear folks opinions on venv vs. conda environments. I've yet to have the classic dependency clash that warrants virtual environments. I do have Python 2.7 installed, but anaconda makes it straightforward to manage that, so I don't feel I need "environments" for Python 2 vs Python 3. I only have Python 2 around for things like mercurial bindings, not for my actual coding. All my stuff shares the same up to date scientific Python stack... Any recommendations?
Check out [Jekyll](http://jekyllrb.com/).
you need to ditch the plot method and reuse the axes object http://stackoverflow.com/questions/8955869/why-is-plotting-with-matplotlib-so-slow Fast matplotlib gets way more complicated, but it's doable. I've gotten a factor of 100x faster even with changing labels, but without readjusting everything
Thank goodness. From reading some of those emails, I was starting to think I was the only weirdo who has to read the source code of libraries. Seems convoluted to me to suggest that library users will rarely have to deal with the source of the libraries. Though I suppose it's a valid enough point that a majority of libraries will be supporting python 2 for a long while yet, and I am getting the impression that this inline type hinting won't be viable for python 2 code at all? So it would throw errors in 2, or am I misinterpreting that part?
But they have one related upside as well: I (someone who doesn't care about them) don't have to look at them at all. Sure, if you actually care, it forces you to go look at a seperate file. But for me, if you've jammed this type noise in the file, I've got no recourse but to mentally filter them out of the code. 
In my own personal experience, type bugs are not something I run into very often. And when I do run into them, they're very easy to track down and fix. Maybe it's escaped my notice, but can someone point me to a real rationale for them? All I have at the moment is "we have annotations, so we should formalize them". Is there any real data towards how much time developers are spending on type bugs? Maybe there should be some profiling before we invest so much in premature optimization.
But you already look at docstrings for documentation (I assume). To be honest, I find makeSubtrees(remainingAttributes: List[str], examples: List[Dict[str, str]], attrValues: Dict[str, List[str]], className: str, defaultLabel: str, setScoreFunc: Callable, gainFunc: Callable ) -&gt; TreeNode or LeafNode: easier to read than like, sphinx-style docstrings, and it often conveys just as much information.
How about no? Complain about the syntax? Fine, propose a better one. Complain about the concept? Go away.
*"[there are 4 similarly named multi-level dictionaries that] map strings to strings with an int "* I found your real problem. : )
Oh yeah, I didn't write the api, although I can't blame them too much, three of the four were *very similar* in what they were, so having similar names isn't surprising.
Then fine, but I don't think it is and since Guido doesn't think it is either, you need to convince people with decent argument and not just because you don't want to. So make the argument...what is the problem with type hinting? This isn't about playing devil's advocate. Type hinting is a very good idea.
Ok, I'll propose a better syntax. I don't like the cognitive load these inline annotations introduce. Instead of def makeSubtrees(remainingAttributes: List[str], examples: List[Dict[str, str]], className: str, setScoreFunc: Callable) -&gt; Dict : why not use a decorator that I can gloss over if I don't care to read it? @type(List[str], List[Dict[str, str]], ], str, Callable) -&gt; Dict def makeSubtrees(remainingAttributes , examples, className, setScoreFunc) : Keep it DRY by making the types positional, don't require the argument names to be typed again. Use _ as "don't care", if you only want to add type to some of the positions. *edit spelling, linebreak.
Decorators can be used to make what was complicated *much* more simple. Take [functools.lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache) for example. It turns this: _foobar_cache = OrderedDict() _MAX_FOOBAR_CACHE_SIZE = 128 def foobar(x): global _foobar_cache, _MAX_FOOBAR_CACHE_SIZE try: return_value = _foobar_cache.pop(x) except KeyError: return_value = x*x _foobar_cache[x] = return_value if len(_foobar_cache) &gt; _MAX_FOOBAR_CACHE_SIZE: _foobar_cache.popitem() return return_value Into this: @functools.lru_cache(maxsize=128) def foobar(x): return x*x Which is pretty cool in my book.
Well, the same function in Haskell would look like this: zipmap :: (int -&gt; int -&gt; int) -&gt; [int] -&gt; [int] -&gt; [(int, int, int)] zipmap f xx yy = {- definition goes here -} but admittedly it's also cheating because Haskell has syntactic sugar for tuples and lists.
If my understanding is correct, specifying types can allow for dramatically improved performance.
The problem I see with that (and you can disagree) is now you don't have types next to arguments. My complaint about the syntax...why not use: def makeSubtrees(remainingAttributes: list[str], examples: list[dict[str, str]], className: str, setScoreFunc: callable) -&gt; dict :
Explain to me how this isn't ugly?
We should look at Erlang's `-type` `-spec` directives. Rather than inline the type spec in the function declaration, Erlang allows us to specify the interface along side the function but usually on the top. -type point() :: {X::int(), Y::int()} -spec getX(point()) -&gt; int() getX({X, _}) -&gt; X. In Python that may look like # type: Point = Tuple[int, int] # type: get_x(point: Point) -&gt; int def get_x(point): point[0] If we take this approach, we can put the type hints in the module that uses them without requiring a separate interface spec file. 
If you would like to write only python code, avoiding html, javascript, css... you can try this https://github.com/dddomodossola/gui. 
What's better? I at least proposed an option. I'll live with whatever is chosen, but I think it makes sense to use the same names as the builtins for list and dict since they're already used for str, int, and float. If you don't want types at all, give a reason. If you do, but you don't like the way it's being implemented, propose an alternative. How about explaining why what I proposed is ugly? Often when people point things not everyone thinks is obvious, what has been seen cannot be unseen. 
So... Cobol?
I'm also a mediocre developer but I think you can do some pretty cool tricks when you have type hints. For example: You can create an [Inversion of Control Container](http://martinfowler.com/articles/injection.html) and have dependency injection along with automatic recursive dependency resolution which can help to achieve decoupling and better testability. But then again I'm pretty new to Python and don't know if there is a better way to achieve the same thing built into the language already. I agree with the post/email? those features are very useful in a large scale web application but other than that maybe is over kill for your everyday middle of the road applications.
Nope. Closer to theoretical chemistry / quantum information: http://stephanhoyer.com/physics/
that's not duplication! that's syntax. also the problem you've mentioned can happen with indentation too. The difference is the simpleness text editors can match brackets, but I haven't seen any indentation matching (?) in any IDE.
You signal your intent that a statement is in a block by indenting it. You signal your intent that a statement is in a block by including it in the same braces. That's two signals. Only only one matters to the computer. And the other one is what humans see. It's dead easy to change one and neglect the other. If you're very very lucky, divergent intent signals will be invalid syntax and won't compile. That in the minority of times though.
Sauce for Real Python. Thanks in advance! 
[https://realpython.com/] (https://realpython.com/) 
And IMO it should be cython / C / most languages style syntax: int some_int = 5 Instead of the typescript / currently suggested / ugly (IMO) syntax: some_int: int = 5 Not that it makes THAT big of a difference. But I really do prefer the former.
Current status Flexx is still very much a work in progress. Please don't go use it just yet. The ui part is not even working yet. The exception might be the webruntime and pyscript modules, although their API's may still change as well.
I believe a single line of python in a whole post doesn't make this a python related. Aka wrong subreddit.
Just for completeness: [Kivy](http://kivy.org/#home) is a python gui framework that allows deployment to windows, linux, OS X, android and iOS. Thus it "feels" relatively "mobile-y", e.g. native touch and multitouch support. The look is distinct and not native to the platform (without styling), so it will probably not fit your problem. 
http://kotti.pylonsproject.org/ small simple 
Then I suggest you start studying your course materials and writing the solutions.
Same situation here! I've also found Chris's blog useful (especially to reassure myself that I'm not nuts for thinking python/pandas is an appropriate tool for these things). I've accumulated lots of "practical business" extensions to pandas. Simple things like `pd.read_excel_sheets` to get a `dict` of `{worksheet_name: dataframe,}` pairs for each sheet in a workbook (has turned up lots of hidden sheets). But also helpers for column renaming (because `rename_axis` and `reindex` are clumsy), adding columns based on an existing column or columns, splitting dataframes into a list of dataframes based on some condition, folding up rows with an `aggfunc` which does what you'd do with `pivot_table` but lighter faster, etc. Almost ready to share but most of the code right now is written in rapid-development functional style which makes it cryptic with heavy dependency on a totally untested library. Here's the `pd.read_excel_sheets` part: import zipfile, lxml, re def find_sheet_names(filename): def xlsx_read(filename): return zipfile.ZipFile(filename, 'r') def xlsx_parse(zf, path): return lxml.etree.fromstring(zf.read(path)) def get_xmlns(root): return re.compile(r'^({.*})').match(root.tag).group(0) def get_sheet_names(root, xmlns): return map(lambda sheet: sheet.attrib['name'], root.find('.//'+xmlns+'sheets').getchildren()) try: zf = zipfile.ZipFile(filename, 'r') except: return [], filename root = xlsx_parse(zf, 'xl/workbook.xml') xmlns = get_xmlns(root) sheet_names = get_sheet_names(root, xmlns) zf.close() return sheet_names def read_excel_sheets(filename, sheetnames=[], exclude=[], **kwargs): if not sheetnames: names = filter(lambda x: x not in exclude, find_sheet_names(filename)) else: names = sheetnames return filter(lambda x: not isinstance(x, list), map(lambda name: catch(lambda: pd.read_excel(filename, sheetname=name), []), names)) pd.read_excel_sheets = read_excel_sheets PS if you work with LOTS of excel files (like handling many directories of hundreds of excel files), using `zipfile` and `lxml` will be much faster for the simple tasks like finding which files contain pivot tables, etc. Just open them and parse the XML. The data in pivot tables is held in two XML files `pivotCache` and `pivotCacheDefinition` and can be extracted (to DataFrame) *reliably* and way faster than with any of the excel readers like openpyxl etc.
Another vote for Mezzanine. Code quality and internal consistency find exceptional in comparison to all other Python/Django based frameworks I've been tangled with so far.
What can I say? I've found it easy to use, powerful, and it has extras like localization utilities. But of course there is a learning curve.
it makes no sense however 1 &lt;= 2 / float &lt;= 0.87 and so the best optimization is the following: False
PPS a (poorly written) pivot table extractor: import StringIO import time, re, lxml, zipfile from itertools import ifilter, chain, imap, count from itertools import islice as take import pandas as pd def catch(success, failure, *exceptions): try: return success() except exceptions or Exception as e: return failure(success, e) if callable(failure) else failure def xlsx_namelist(filename): return sorted(zipfile.ZipFile(filename,'r').namelist()) def xlsx_read(filename): return zipfile.ZipFile(filename, 'r') def xlsx_parse(zf, path): return lxml.etree.fromstring(zf.read(path)) def get_xmlns(root): return re.compile(r'^({.*})').match(root.tag).group(0) def etree_to_dict(root): ns = '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}' return {root.tag.replace(ns,''): dict(root.attrib, **{'C': map(etree_to_dict, root)})} def nparray_from_xml_dict(d): return np.array(map(lambda x: map(lambda y: y[y.keys()[0]]['v'], x['r']['C']), d['pivotCacheRecords']['C'])) def pivot_header(d): return map(lambda x: x['cacheField']['name'], d['pivotCacheDefinition']['C'][1]['cacheFields']['C']) def pivot_fields(d): return map(lambda x: filter(I, map(lambda y: catch(lambda: y[y.keys()[0]]['v'], ''), x['cacheField']['C'][0]['sharedItems']['C'])), d['pivotCacheDefinition']['C'][1]['cacheFields']['C']) def pivot_description(d): return dict(zip(pivot_header(d), map(lambda x: dict(enumerate(x)), pivot_fields(d)))) def convert_excel_date(x): regex = re.compile(r'^[1-2][0-1|9]\d{2}-[0-1][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9]') try: datetime.strptime(regex.match(x).string ,'%Y-%m-%dT%H:%M:%S') except: return x def convert_excel_null(x): return np.nan if isinstance(x, (str, unicode)) and x in ('.','X','-',' - ',' ','N/A','na') else x def extract_pivot_table(filename): f = xlsx_read(filename) definition, records = map(lambda xmlf: etree_to_dict(xlsx_parse(f, xmlf)), ('xl/pivotCache/pivotCacheDefinition1.xml', 'xl/pivotCache/pivotCacheRecords1.xml')) f.close() df = (pd.DataFrame(nparray_from_xml_dict(records), columns=pivot_header(definition)) .cast(floatable, np.float64) .repair_header()) desc_dict = pivot_description(definition) for x in df.columns: try: df[x] = df[x].map(lambda y: desc_dict[x][int(y)]) except: pass return df Recently I got the idea to make this into a Postgres FDW with `multicorn`... shouldn't be tough at all!
Are you sure this is doing what you expect? If we make the substitution `x = 1/float + 1/float` then your line is equivalent to 1 &lt;= x and x &lt;= 0.87 So if `x &lt;= 0.87` is `True` then `1 &lt;= x` *must* be `False` and the whole thing must be `False`. If `x &lt;= 0.87` is `False` then the whole thing will be `False` regardless of whether `1 &lt;= x` is `True` because that's how the `and` operator works. So your line is actually entirely equivalent to False If that is what you mean, then to answer your question: Yes, if you instead use False you will get fairly significant speed up ;) But I don't think that is what you mean is it? Edit: Completely screwed the analysis originally, 'tis all better now.
You are worried about the situation where someone writes a function with type hints that are too narrow or specific. But the current situation is where users of that function just have to take a wild guess as to what is acceptable, that situation is ok? 
So what type of bugs do you run into? Because except for stuff like arithmetical errors, a lot of bugs are exactly the thing that a strong type system stops right in its tracks.
That's not the current situation, though. These things are currently described in documentation, which you need anyway to know when to use what (even, say, Haskell, can't do without that). The only difference type hinting will make is for tools that can automate part of the programming process.
Thank you. Type hints are *documentation*. But unlike docstrings, type hints are machine readable too and can bring a whole bunch of other benefits related to tooling. With that in mind, I don't understand the resistance some people have to type hints. We all agree that docstrings and documentation in code is useful and valuable, but why wouldn't we want to make better use of our doc writing efforts by using machine readable documentation? 
I don't see why dividing two integers should return a float, if I wanted a division to return a float that I would cast one, or probably both, of my integers to a float. Why make it more complicated to use python for people with programming experience to cater for new programmers which then will learn something that is unorthodox and not supported by the majority of languages? It doesn't make sense to me. I mean, what would you expect this to return, if you didn't know the language used: (int)a / (int)b I would expect it returns an integer, not a float. Now consider this: a // b I wouldn't know what it would return, it could be a boolean for all I know.
So how do I say "Accept anything that has a values attribute"? (Now, how do I say "Accept anything that has a values attribute which is a calllable"?) How do I say "Accept any iterable" or "Accept any sequence"? Could you please provide an example of how these things are done? (Also including the other scenarios I mentioned, if possible) I just checked the mypy docs any see nothing like this. Now, even if typing.py supports these things, how often do you think the proper level of generality will be used? For me, it's telling that I've yet to see anyone not use the builtin concrete types in any examples yet. (And I'm suscribed to python-dev, so I've been reading the discussion about this PEP) This is not simply a technical issue. You have to also consider how it's going to actually be used. 
Not true. It could allow for faster warmup of a jit like pypy. Though in places where I was providing type hints I imagine I wouldn't mind raising an exception
I'm familiar with TypeScript. It is structural typing and you can easily define your own interfaces or say inline that parameter x should be an object with the one or two methods on it that your function actually uses. It would be a pity if Python's type hinting couldn't easily express these things. 
Awesome, glad to hear you enjoy them! 
Using it, works like a charm
Coming from C++, I find the absolute lack of type safety hard to adjust to. When I write code I know certain things (e.g. this variable has these methods, will never be altered inside this function), but when I come back to modify it later I may forget the assumptions I made. So having type hints must be a step towards more reliable code. OTOH python is fairly quick to get stuff going, in part because you don't think about types as much...
My concern about type hinting is that they go against the spirit of duck typing. Suddenly, types have become synonymous with classes rather the required protocol to be consumed by the function.
Docstrings are separate from the source, and easy to skip over when all I'm interested in is the function signature. In my editor they are folded away, by default. I think knowing the expected types can be very useful. However, I think many of the proposals for just how to provide them can too easily cause more harm than good in most cases.
Of course there would be lots of things it wouldn't work on, just like multiplication doesn't work on two strings. But this operator is being introduced in order to do matrix multiplication, so it should work on any nested index-accessible sequence of numbers which are of the right lengths to allow matrix multiplication.
I can't help but think that all of these graphs should be showing absolute numbers, not relative ones.
&gt; But it's just that little bit uglier, just that little extra mental effort, just that little extra barrier that is going to mean some people, at the margin, just give up on learning programming, or switch to *javascript* javascript!!!
Woa woa woa I'll admit I don't love type hinting but decorators are *easily* one of my favorite features in the language. They've completely changed how I write and modularize code.
Well, yes, but specifically that *decorators* are a fantastic application of reusable components.
you can check [freezer](https://github.com/stackforge/freezer/)... but I think only works with openstack backends 
Oh hell yes! That's the main reason I am excited for type hints. It is my hope that it will lead to Pyalyzer, the Dialyzer clone for Python ;) 
This will be less of an issue once we get a static type analyzer like [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) or [Flow](http://flowtype.org/). It'll complain whenever they're out of sync. This is going to help a lot when it comes to documenting interfaces and detecting breaking API changes. I can't wait for our type inferred future!
I guess, since they are machine-readable and you are a programmer then you could write a tool to filter them out automatically. See, the promise of better tooling is already paying off.
It's *better* but the ubiquity of `get_` and `set_` methods is still very unpythonic. As a slight aside, are there any good tutorials for using Matplotlib's artist objects or is it all just a case of figuring it out from the docs?
Sure, and understanding how they work (nested function defs and closures and stuff) can be pretty weird for a new programmer. However, explaining *what* they do (in my experience) is usually very very easy. They alter a function somehow- make it cache results, make it print after running, etc. Much like iterators in for loops, how they work can be easily deferred. 
pretty much, yes.
This is the right way to approach it with matplotlib. OP: In what way is the file constantly changing? Does the number of points change, or just the y-values? Is it big enough that "readlines" is a non-insignificant step?
Couldn't agree more... For the plots I often generate, I rarely use the Seaborn plot types, but I almost always use their colormaps with combination of matplotlib styles.
I'm formatting the HTML version of the Creative Commons release right now. It should be ready Wednesday or Thursday. I'll be posting chapters as they are done.
Meant to reply to you sooner, but work got a bit crazy Friday. The two pieces are drastically different although there is some fuzzy gray area for sure (at least in SQLAlchemy). The TL;DR version is the toolkit lets you run SQL queries using Python. You don't have to worry about the SQL commands directly nor about DB-specific details. Just raw Python. The ORM takes it a step farther and you just worry about your objects. Any creation, modification, and deletion of objects is translated directly back your DB. You do things -&gt; they happen. No need to add in the extra logic of what needs updated, when, where and how. It just goes on behind the scenes. No manual intervention or maintenance required on your part. It gets fuzzy because the ORM is essentially bolted on top of the toolkit. They also share the same feel when querying and have some overlap in that arena. The first few paragraphs [of this portion of SQLAlchemy's tutorials](http://docs.sqlalchemy.org/en/latest/core/tutorial.html) do a pretty good job of explaining it. Says basically the same thing I did above, just worded slightly better. 
So use a stub file. It's a choice and that's a good thing.
Thank you for all your hard work!
Give [vex](https://pypi.python.org/pypi/vex) a shot - YMMV It essentially creates a sub-shell and launches your module/app inside of the sub-shell
does systemd or upstart automatically restart crashed processes? Does systemd or upstart allow non-admin users to run and manage processes? Does systemd or upstart manage log file size and rolling them over? Can you configure systemd or upstart with a simple ini file? Does systemd or upstart give you a handy web client and cmd line client for start/stop/restarting configured processes and viewing/tailing logs? If yes to all of the above. Then yes, I would agree with you that it is redundant. 
Have a look at [vex](https://pypi.python.org/pypi/vex) if you haven't already. It builds on virtualenv and is neat-o (check the examples to see what I mean).
The tokens become relevant when the isomorphism between syntax and semantics breaks. Many tools, including source control, are built on the assumption that this isomorphism exists and usually holds true; when it doesn't, this introduces a new potential source of errors. I agree that a "this block intentionally left blank" symbol is beneficial to the "read" use case, but I disagree on the idea that "read" is the most important use case, at least for production code. The most important use case for production code is "modify", and `pass` can be devastating for that, because now our "line of code" is no longer a syntactic entity; its meaning and its position in the source tree now depend on context, and this in turn means that when you change code, you have more things to worry about than the code you're changing and the stuff that depends on it anyway for other reasons. If Python were still the educative language it was originally designed to be, then "optimize for reading" would be the way to go, but for real-world production systems, I prefer "optimize for modification".
&gt;All of your examples were syntactic. Just for the record, disallowing nil values, structural sharing, Lisp-like macros, and laziness as a default are *not* syntactic constructs. Some benefit from a bit of syntactic support, but none require it. I said "Much of this is syntactic, but much of it isn't." I stand by that.
Oh man. THANKS! I was going to purchase this book. I'll still buy a print copy (cause i'm old school like that).
*"...but now we have to trust them to write proper documentation.'* Yes. I am assuming that the programmer is able to write sentences. If he can't do that, all is still not lost, assuming we have access to the code. A programmer has always had to be able to write documentation and he always will have to to properly understand the intent of arbitrary code (even code wee have access to!). That was true before and will be true after this PEP. The difference is that if he writes bad documentation (assuming I can guess the intent (which I can't in general)) I can simply ignore it. If he writes bad type hints, he's added noise to the signature (making it more difficult to read), he's missignalled the functions requirements, and will make perfectly good code throw errors when validated with a type checker. *"Are you familiar with the idea of the interface (or signature) to some code being conceptually separate from its implementation? Because you've been advocating coding to implementations, which is generally considered a bad idea in most of the industry."* No I haven't. Please clarify. 
Awesome, thanks. :)
Would if I could. It's a large amount of tedious formatting that relies on tiny human decision making. :P
Thanks!
It's 500-1000 new unrelated values so simple rolling isn't a viable option. Recreating the whole plot is excessive but it must be all new data each time.
Hm... many Design Pattern are not really relevant for Python as the language itsself solves some problems at language level. Others appear in a quite different shape... so imho Python is not really a good choice to teach Design Pattern if you don't take care! If you simply write Java code within Python syntax there's more harm than use 😉 Of course it depends on taste - but the GoF book is definitly **not** written with beauty didactic in mind, but with scientific style and and as a complete exposition. Thta makes the book of course not bad at all - but imho difficult to really gain an understanding why to use pattern and the underpinning OOP principles like SOLID and related ones. The HF book instead tries only to present the more basic and more often used pattern with strong didactic aspects. Of course there is much repitition - but they want to teach, and repitition is therefor needed. The authors also put weight and emphazise on the building blocks and low level OOP principles, which fit nice together and make the reader open his mind towards the usage, hierarchy and fitting of all those components.
For similar reasons to how I prefer using namedtuples over multiple return values, I really like this idea.
I'm not talking about the group as a whole; I'm talking about the statements inside the block (and frankly, whether `{}` can be considered one statement in C is kind of debatable, but I digress). In C, going from 2 statements to 1 to 0 looks like this: { foo; bar; } { foo; } { } In Python, it looks like this: foo bar foo pass If you feed the last two to something like `diff`, you'll get this for C: - foo; And for Python, you get: - foo + pass In other words, the diff for C tells the truth ("something has been removed"), while the diff for Python doesn't ("something has been changed"). 
I think Harry's points are correct, though I'm not ready to commit to his proposal. Most people that use python voluntarily cite its expressiveness and simplicity. Python scripts can be read aloud like prose. This was not an accident, python was designed this way. Type hints are at odds with this design goal. They deliver consistency at the expense of python's aesthetic. IMHO there are plenty of languages that have formal type systems. If a programmer needs these guarantees then they should use a compiled languages that affords them. Introducing this feature into python undermines one of the languages core design goals to introduce a solution that is really only "half-baked". This is because python is interpreted and will never have a formal/unavoidable compilation step where all the type checking is done. Even the PEP describes it a "powerful linter". I think that is key if you want a linter go write a linter I don't see why I have to be beholden to it. In summary not a fan.
I've been working with Python for maybe 10 years now, and "math" is something I rarely use. *Logic*, sure. But not math. Everything I do is text-based. Type annotations will be next to useless to me, and will simply bloat the clean, simple code I work with if it becomes a Best Practice. I'm absolutely loving the idea of a separate hint file. If it doesn't happen, I fear my career in Python may come to an end through sheer annoyance.
You're using Python 3? This might be the first real endorsement of v3 that I've ever seen. Why do you think people are so resistant to it?
type hints rock the world in bigger projects. They document the code, they prevent bugs, they help with IDEs.
Heh, I had to write it myself for the book. I saw several other modules that did similar things but they weren't 1) cross-platform, 2) for Python 3 and 3) had dead simple APIs. Also, I used PyAutoGUI to create a bot that plays the flash game Sushi Go Round: https://www.youtube.com/watch?v=lfk_T6VKhTE
Welcome back! :)
I don't have a strong opinion either way on this but as far as aesthetics go, I wouldn't be too bothered if Harry's example was written like: def zipmap( f: Callable[[int, int], int], xx: List[int], yy: List[int] ) -&gt; List[Tuple[int, int, int]]: """ zipmap's docstring """ print("This looks better") Then, like you say, use type aliasing to keep it DRY if there is repetition or to hide ugly nested types. For people totally not interested in the type hints, perhaps some tools for editors/IDEs could allow you to toggle their visibility? Or at least you could use syntax highlighting to make them less visible. However, I repeat, I don't have a strong opinion on this one way or the other, I'm just thinking out loud here. 
Oh damn, didn't notice! Browsing through the examples, they are basically self-documenting. Great work and good luck with your book!
 self.Execute(cmd, timeout = self.timeout if timeout is None else timeout) I had no idea you could do that directly. Just tested it out, and it does work, but I'm not so sure how I feel about that yet :P in any case, this one example is rather contrived, but this is a pattern I've noticed myself running into a lot so I figured it's probably worth it to find a better way. Definitely appreciate the feedback, thanks! And yeah, using a dict feels safer/saner, for sure.
Because when you google stuff the vast majority of stuff you find is code in python 2. Then you get used to it - then you find python 3 and you're like "No."
[No, but people do that.](https://andreacensi.github.io/contracts/)
The 3rd party modules argument is still relevant in the spatial sciences and oceanographic fields but yeah i understand that is a relatively small subset of users.
A lot of my coding is pretty defensive, so I tend to check inputs and sometimes outputs. Maybe a little like primitive contracts. Personally, I'd love it if we had a special version of assert for this purpose - that could then get sucked into the docstring.
Interesting discussion on [Hacker News](https://news.ycombinator.com/item?id=9415793).
You don't seem to have read the OP. If I can choose to use stub files or not, then other code that I'm interested in may have made the different choice to use in-line type annotations. When that happens, I no longer have an option or a choice.
Hey! You're the guy that initially got me into programming! Thanks a lot man, you were a massive help when I started python!
What about just putting the instance default timeout in the function as a default parameter? class MySubClass(MyClass): def __init__(self, timeout=None, *args, **kwargs): self.timeout = timeout def pexecute(self, cmd, timeout=self.timeout): 'execute cmd and dump output to interpreter, specify timeout or not' if timeout: print self.Execute(cmd, timeout) else: print self.Execute(cmd)
I had no problem with it until I was trying to manipulate bytes for a cipher. Python 3 decided every byte was multi-byte unicode and fought valiantly against everything I tried to do to convince it otherwise, eventually vanquishing me and returning me to 2.7
I do. I just *also* want to be able to set it per method-call, as appropriate. (say, 1.5s timeout is fine for 90% of what you do with X device, but certain commands take a long time to return anything at all, so you give THEM a longer timeout, etc...) edit: to clarify, there isn't really much of a sentinel value you can use. As data comes back, it's almost all multi-line, so I can't stop receiving on newline, etc... there *IS* a prompt, but it's a single character and I can't guarantee that character won't occur in any other valid output. So every singe call takes `t + timeout` seconds, so keeping it lean-ish is a good thing. Until it's not, and I need to give it more :P EDIT^2: obviously as soon as I typed that I thought of a good way to optimize it, but I still want this flexibility none-the-less. (for future reference: '#' is not a good sentinel value, but '\n#' is a lot better, and `if str[-2] == '\n#': timeout = timeout*.25` seems like a good way to go...)
Nevermind, you cannot use 'self' in a default parameter of a class function definition. Learn something new every day. It appears the standard way to handle is like your 3rd suggestion above (http://stackoverflow.com/questions/7371244/using-self-as-default-value-for-a-method)
I love your cryptography book!! Thanks for your contribution to the Python community. 
did you try spf13 vim configuration? http://vim.spf13.com/ https://github.com/spf13/spf13-vim
&gt; but for some reason the other libraries just won't work. Do you have any log you could share? Since you're almost there, with all the dependencies ready, it shouldn't be much harder.
He's adding a recent commit that fixes a memory leak. Pillow has official binary wheels on Pypi, but I couldn't find any nightly builds.
I need a commit to be included, to fix a memory leak. This commit has been only recently posted.
There's no log unfortunately, it just refuses to pick up all the other libraries. I'll try getting more information tomorrow about it.
What type of things can you automate/do you discuss automating? Just wondering if this book is for me.
Well, what you don't like about your example? Looks legit to me... except, that I seldom need to do something like this. What are you trying to do? 
I have not, no, but this looks interesting. Any links that describe how to migrate successfully from "vanilla" vim to SPF13? (and in the event that I want to revert back). Also, a cursory search yielded problems of spf13 and python, do you know if this has been resolved?
I take it back! Thanks for the link!
It looks like there are chapters on filling out web forms and filling out forms in apps, just from a comment OP posted.
&gt; posting chapters as they are d RemindMe! 3 DAYS "Python book from an awesome guy"
What if IDEs just put in an option to hide the type hints? I'm imagining a keyboard shortcut to toggle them, or just hovering over a method to see the full, hinted version. 
Messaging you on [**2015-04-25 22:56:00 UTC**](http://www.wolframalpha.com/input/?i=2015-04-25 22:56:00 UTC To Local Time) to remind you of [**this comment.**](http://www.reddit.com/r/Python/comments/33cy0q/my_latest_book_for_total_beginners_automate_the/cqk6fcs) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[http://www.reddit.com/r/Python/comments/33cy0q/my_latest_book_for_total_beginners_automate_the/cqk6fcs]%0A%0ARemindMe! 4 DAYS ) to send a PM to also be reminded and to reduce spam. _____ [^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/) ^| [^([Custom Reminder])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!) ^| [^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback) ^| [^([Code])](https://github.com/SIlver--/remindmebot-reddit)
Thanks! :)
Try the new binaries at http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow, which include the fix.
But having it in the same file is a huge advantage for maintainability. (And I would put it directly above the function, not at the top of the file.)
Those "good reviews" looks like gaming ratings to me. Three of them didn't buy the book they supposedly reviewed (and two of those accounts have only one review). Out of the two remaining reviewers who are verified buyers, one didn't read the book and the other has only one review. Use "Look inside" option. There are two chapters available as a preview. Check them out and see if you enjoy the style and the content so far. There's also a table of contents available ([PDF](http://cdn.oreillystatic.com/oreilly/booksamplers/9781491945285_sampler.pdf)). Parts I and II are your standard introduction of Python and its modules/libraries (pandas, numpy, I/O, statistics, excel integration, GUI, etc.) - these can be looked up elsewhere. The only interesting part is the third one, but you can find similar information for free in a [PyCon talk](https://www.youtube.com/watch?v=c4WltP4-Xlk) and [a webcast](https://www.youtube.com/watch?v=Cc0HlKKCSHU), both by the book's author. Also, it looks like this book depends heavily on a paid, third-party platform.
If it works for you then don't change.
If we are talking about assets like images, etc. as opposed to Python scripts, import os, and get the root directory of your game - this is assuming that you will be launching the game from the top-level folder of your project: import os root_dir = os.path.dirname(__file__) And you can then get your assets easily: image_dir = root_dir + "images// home_screen_bg = image_dir + "main_bg.jpg" If you want to store Python scripts in sub-folders, you must include a file in each sub-directory named __init__.py (I'm a reddit formatting n00b - the init file has two underscores on either side of 'init') - it can be blank. This will allow you to import scripts. For example, if you have a settings folder with a config.py script containing different settings, you would do the following from the main file: import settings.config
I agree. This is probably the only style that works when the types are this complex. 
RemindMe! 4 DAYS "Check out Automate Boring Stuff with Python"
The corresponding Pillow issue, for reference: https://github.com/python-pillow/Pillow/issues/1200. 
Hi gohlke: when you say "include the fix" do you mean https://github.com/python-pillow/Pillow/pull/1196/commits ?
What are the correct paths in this case? If it's helpful, we can include them in setup.py.
And we in turn (Pillow Fighters) upload those packages to PyPI for added convenience :-) Hat tip: gohlke.
same, fucking esri...
Huh, thanks for clearing that up. Would an error be thrown then if an argument of the wrong type gets passed in? Or by assertions do you mean from more of a readability / static analysis perspective?
Ooh, typealias. I like that part of swift and would welcome an emphasis on aspect-like oriented typing
I would love to see this setup too.
True, and then you won't need to jump around to look up the types.
Because my company uses CentOS on their Unix machines, which ships with 2.6.6 (to this day, iirc). When I learned Python, I didn't know there were different versions, and if codeacademy mentioned it, I forgot about it. It became apparent that there are multiple versions of the language about 2-3 months in, and by then I had already written a lot of code, but I wasn't advanced enough to appreciate the changes that 3.X brings. By now, I have both versions installed, but I ususally still use 2.X, mainly out of habit.
You got me with the title alone. EDIT: I've pretty much made a career of automating the boring stuff with Python. And Ruby.
This is definitely something that I think will be helpful to me. I ordered it from Amazon.
This is now my default response for all future encounters with the non-technical technicians.
I would suggest not calling the function until you validate the input. Separate those concerns.
Nothing special, really. I try to install all libraries in a common root, maintaining `lib`, `bin`, `doc`, `include` subdirectories in this root. So I just pointed them all there, with the exception of `libtiff` that I had to add `/libtiff` to the include path. EDIT: might as well post the lines to make it clear: JPEG_ROOT = ('C:/msvc_libs/lib', 'C:/msvc_libs/include') ZLIB_ROOT = ('C:/msvc_libs/lib', 'C:/msvc_libs/include') TIFF_ROOT = ('C:/msvc_libs/lib', 'C:/msvc_libs/include/libtiff') FREETYPE_ROOT = ('C:/msvc_libs/lib', 'C:/msvc_libs/include') 
I agree about the analogy being adjusted (consciously or not) to lead to the desired conclusion (that Python 3 is not worth it). I'm also quite surprised at people complaining about the backward incompatible changes in Py3. I know that it may seem a bit weird in our age of Chrome v41 and Firefox v37, but the whole point of the major version number bump is to [signify incompatible changes in the API](http://semver.org/). If there were no backward incompatible changes, it would be Python 2.8, not 3.0.
It's hard to say without knowing exactly what you mean by "open" - it would depend on what module or function you are opening it with, but that is what I do with all my assets - set a variable containing the full path to the asset. I'm fairly new to Python and programming in general, but it seems to me that this is the "safest" way to point to assets, and will ensure it's compatible across the different operating systems. I would recommend you work your way through the tutorials on the following site to get a firm grasp on how to program games in Python. The tutorials are in full on the website, but also available in print - they helped me in a big, big way: http://programarcadegames.com/
I am VERY green when it comes to Python. My hesitance into embracing it as my new language of choice is because of the seemingly undecided community base on what should be the standard. Why embrace something that's old and obsolete? How can a user base of seemingly intelligent people think that is a good idea? Or is it the normal lazy old school dev attitude you encounter where even though it will fail eventually, if it ain't broke don't fix it? Can't wait to check out the book :)
is this a real thing?
You rock! I have been waiting for this book to come out for since back in January, and to hear now its going to be Free under the Creative Commons license is awesome for a broke college student like me. I will be sure to pick up a copy or two when I get the money. Thanks and keep on writing. 
You could flatten both dictionaries and compare the sorted pairs: def flatten(dic): """Flatten a dictionary, separating keys by dots. &gt;&gt;&gt;&gt; dic = {'a': 1, 'c': {'a': 2, 'b': {'x': 5, 'y': 10}}, 'd': [1, 2, 3]} &gt;&gt;&gt;&gt; flatten(dic) {'a': 1, 'c.a': 2, 'c.b.x': 5, 'c.b.y': 10, 'd': [1, 2, 3]} """ def items(): for key, value in dic.items(): if isinstance(value, dict): for subkey, subvalue in flatten(value).items(): yield str(key) + '.' + str(subkey), subvalue else: yield key, value return dict(items()) result = sorted(flatten(complex_dict2).items()) expected = sorted(flatten(complex_dict3).items()) assert result == expected 
I don't get it. What's the advantage of this program in comparison with using python -i -c &lt;something&gt; ? olp "sum(range(10))" &gt;&gt;&gt; 45 vs python -i -c "x = sum(range(10))" &gt;&gt;&gt; x 45 (The next example has raises NameError: name 's' is not defined, fixed in my version) olp -d "get_bin = lambda c: str(bin(ord(s)))[2:]" olp "get_bin('a')" &gt;&gt;&gt; 1100001 vs python -i -c "get_bin = lambda c: str(bin(ord(c)))[2:]" &gt;&gt;&gt; get_bin('a') '1100001' I don't want to show how to rewrite other examples, but it is pretty easy (the only exception is pipes example, although I'd argue that somebody will ever use such "feature").
In my opinion (and let me start by saying "Python 3 woo!") I think Python 2's for people who began with it is that the cliche 'old habits die hard' and the differences are enough that it's almost like learning a second language, in the programming language sense and in the linguistic sense of "Oops, that's the wrong grammatical syntax, people are looking at me funny, dang it I'm going back to Python 2, it's nicer." Or something like that
Ok I see. I'll apply it to my expertise. It's basically the equivalent of a random dev who used to code in php4x picking it up now, right?
Very cool. Saving for later
I don't think there would be any value in validating them either since if they are invalid names you couldn't refer to them in the function anyway because the syntax to do so would be invalid. (On a side note, True &amp; False actually are re-bindable in python 2.x) &gt;&gt;&gt; def f(False=1): ... print False ... &gt;&gt;&gt; f(False=2) 2 
Hey i attempted to improve/clean it up but then i got distracted at work so i lost track of where i was. I think you will get the idea of it when you read it. I tried to put re-use of code into your script and make it a bit more dynamic and easier to re-use [Pastbin dump of code](http://pastebin.com/a9e2GjNy) *There is an error in the pastebin on the multiple_replace, should have a trailing ")"*
Sure, if that analogy works. I'm not really familiar with other languages, though, as I'm green to everything except Python 3 (though I am picking up Ruby. Love the inject and map commands) If someone who works with Python 2 could support my hypothesis, that would be better.
read the `os.path` [docs](https://docs.python.org/2/library/os.path.html), they're great for manipulating directories in a platform independent way.
To simply answer the question in the title, I think it's in part because "[explicit is better than implicit](https://www.python.org/dev/peps/pep-0020/)". See also [what the BDFL had to say](http://neopythonic.blogspot.dk/2008/10/why-explicit-self-has-to-stay.html) way back in 2008.
I've been looking for ways to integrate asyncio and/or threading with tkinter. This will certanly help. Edit: typo+wording.
You need more tiny humans, then. 
It's an apples and oranges comparison. In C++ the members of a class have to be declared beforehand, and are forever fixed. In Python, attributes are fluid and dynamic. They can be added and removed at will at any time; there is no fixed layout. Under your scheme, if I write `foo = 42` inside a method, is that assigning to a local variable named `foo` or is that assigning to a new instance attribute? Or a new class attribute? There would be no way to know, as there's no class definition that the interpreter could look at to figure out which names are attributes and which aren't. There needs to be disambiguation; you must assign to `self.foo` if you want an instance attribute, `cls.foo` if you want a class attribute, and `foo` if you want a local variable. Passing `self` as an explicit parameter simplifies everything, as it means that methods are ordinary functions that happened to be defined in the body of a class block. The language doesn't have to invent any new syntax or semantics for methods. They behave exactly as regular functions, with all that entails. Consider this example: class Foo: def __init__(self, val): self.val = val inst = Foo(42) def foo(self): print('val =', self.val) Foo.foo = foo inst.foo() # =&gt; "val = 42" The `Foo` class gained a method simply by assigning a regular function to an attribute of the class. I think that's pretty amazing. Regarding the notion of private things, you have to discard that entire idea when dealing with dynamic languages like Python. Python allows anything and everything to be introspected at runtime, in opposition to C++ which has no such ability. That means that privacy does not exist here. If a client wants to open up the guts of a class and poke at its insides, they have full access to do so and there is no way to stop them. That's part of what makes the language so powerful and flexible. But it means that it's also pointless to try to enact barriers. Don't access undocumented variables, or variables with names that begin with `_`. Or maybe do access them, if you really have a compelling need. Maybe you want to open up the guts of something and add logging around a particular method for debugging purposes. Maybe you want to replace a method with a mock for unit testing. Maybe you're a mad genius and you want to monkey-patch things all over the place and create some scary contraption that might actually work (e.g. gevent.) Again, the ability to do these things is exactly what sets dynamic languages apart from others. Private does not exist here. Stop trying to write Java in Python. 
&gt; Is that a bad use of my time? I think so. There are a lot of super complicated things that you can get into (e.g. PyPy, the GIL) if just go to youtube and watch David Beazley videos (he's a Python "rockstar" and is actually kinda funny, but how useful are his talks?). There's a lot of things you can do with Python, that you should do because nobody will be able to understand it and it's a hack upon a hack upon a hack. Still, it's nice that you can do it because sometimes you need to. Get the basics down first. Learn the standard library. Learn a few useful third party packages. You'll dig into the code at some point, see a bunch crazy syntax, learn what that means, and get better at Python. &gt; This is not hollywood. The C++ way provides real security Security from what? Python is very popular language for the web. Google is huge user of Python. So is Dropbox. At least with Python, you don't need to worry about overflow errors or checking to see if a file really opened or pointers or mishandling of unicode or if the string buffer was overrun, which are huge sources of security problems. Also, why do you want to learn a language you don't think is secure? An unsecure language is a toy. It's really not that bad...
A great suggestion!
To call a function, you need brackets: so for example if len(string) == 3: func1() You place any arguments you want to pass to a function between the brackets. This is very, very basic stuff, however. You're probably better off looking for a tutorial as this kind of things are taught in any decent tutorial. 
Len returns the number of characters, not words, so you'll need to split the string and count the items in the list that returns ie. string = "this is a string" words = string.split() if len(words) == 3: func1() elif len(words) ==4: func2() And so on. :-) 
/r/learnpython
Thanks for this answer. You've given me much to think about. One question. In your last line, should it be inst.x() or is x() not actually a method but some special thing? 
/r/learnpython
The idea is that the details of the implementation of software components (i.e. classes, functions, methods) should not exposed to users to the component. Instead components should expose an interface which describes what it does and how it should be used. In Python terms that is the function signature and docstring and possibly type hints. If someone has to ignore the documentation and type hints and consult the code directly, then something has gone terribly terribly wrong. Related wikipedia topics are: https://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29 https://en.wikipedia.org/wiki/Information_hiding
Yes, that seems much better. Would you still have to pass it as a parameter in class definition though?
Really cool and inspiring. Thanks for sharing !
This thread has been linked to from another place on reddit. - [/r/programming] [/u/gfixler explains why you should learn VIM](//np.reddit.com/r/programming/comments/33mibi/ugfixler_explains_why_you_should_learn_vim/) - [/r/vim] [/u/gfixler on Vim. (xpost from /r/Python)](//np.reddit.com/r/vim/comments/33gdpf/ugfixler_on_vim_xpost_from_rpython/) [](#footer)*^(If you follow any of the above links, respect the rules of reddit and don't vote. ) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Really? I've never observed that. Certainly, it's easier to write bugs in Java than it is in Python, because Python is easier to test.
&gt; I find the absolute lack of type safety hard to adjust to There is no lack of type safety. In fact, Python is strongly typed, unlike C++ which allows unsafe casts. &gt; but when I come back to modify it later I may forget the assumptions I made. So having type hints must be a step towards more reliable code. You don't use comments in C++? Were they phased out in a recent standard?
But you have it backwards, type systems stop bugs before tests even have a chance to catch them, right? Java wasn't what I had in mind for a language with a strong type system, though. And why should Python be easier to test? Genuinely curious, I've never heard that before.
&gt; type systems stop bugs before tests even have a chance to catch them, right I have never seen any evidence of this. Rather I would suggest that statically typed variables prevent trivial errors only, and imposes such an overhead on the programmer that tests frequently don't get written. &gt; And why should Python be easier to test? Genuinely curious, I've never heard that before. 1. You can do it interactively 2. There's less overhead to writing python code in general, so adding tests is easier. 3. Python's dynamic nature makes it easy to stub and mock, with and without libraries. Relatedly, duck typing makes it easy to write the right test for a piece of code, and build up tests iteratively. 
RemindMe! 4 DAYS "Check out Automate Boring Stuff with Python"
Reading the whole thread, it's clear to me that python 3 is primarily for language implementers to enjoy implementing a language. They say they care about adoption, but they clearly don't care for the opinions of people who use python to get things done.
Perhaps I meant type checking. The point is that in python there is no limit on the types accepted by a function, nor is there a limit on the type of object returned by a function. Whereas in C++ I am able to depend on being able to handle the response from a function. &gt; You don't use comments in C++? Were they phased out in a recent standard? If your comment is in good faith then you perhaps don't realise how useful it is that in C++ you can have the compiler verify that the return value of a function that you are treating as a particular type actually is a particular type. In python you only find out that it wasn't a dict like you thought it was when you exercise that piece of code. I personally like to encode as much of my knowledge of the intended behaviour into code as possible. The more constraints I can describe, the quicker I can eliminate certain classes of bug.
I guess so.
There a several reasons why you would want to use this feature: * Methods with a lot of arguments (like your example) implement this feature in order to avoid accidentally calling the method with the arguments in the wrong order. * When creating a module/library that will be used by other developers you can use this feature to make your library more user friendly by improving readability. Very basic example: [here](https://gist.github.com/vlad-dragos/6ddbf0938af7f321585e#file-gistfile1-py) If you're lokking for the oficial reason why this feature was implemented you can read the PEP proposal [here](https://www.python.org/dev/peps/pep-3102/). 
Heh, shame, I was looking forward to trying it. Well - back to trying if I can use Rapydscript ;)
&gt; The point is that in python there is no limit on the types accepted by a function, nor is there a limit on the type of object returned by a function That's not actually true. The types accepted by the function are the types which conform to the function's required protocol for inputs of that type. You will get an exception if an operation is missing. &gt; Whereas in C++ I am able to depend on being able to handle the response from a function. What kind of hell code have you been working with? It's extremely uncommon in python to return types which do not conform to a documented interface, with the exception of None being an alternative in many cases. &gt; you perhaps don't realise how useful it is that in C++ you can have the compiler verify that the return value of a function that you are treating as a particular type actually is a particular type No, I don't realise it, because that's not what happens. Type checking the return type of a function isn't that useful because hell code which needs that checking can easily be caught with code review. The errors that kind of practice causes should be trivially caught with unit testing. &gt; In python you only find out that it wasn't a dict like you thought it was when you exercise that piece of code. Again, I don't know what you're doing, but either you or the code you're working with is doing things very wrongly. &gt; The more constraints I can describe, the quicker I can eliminate certain classes of bug. A great place to do that is in unit tests. There, you have the power of a turing complete language to perform whatever checks you want. Based on what you've said, I bet you don't use templates very much in your C++. Try working with templates for a bit, and you'll see the advantages of duck typing.
I don't understand this idea that statically typed variables are overhead, or that duck typing is less overhead. Static typing: I declare my variables (perhaps giving an explicit type) and assume throughout my program that it has a certain type. The compiler tells me when I violate this assumption, which might lead to a bug even a million tests won't catch. Duck typing: I declare my variable and assume throughout my program that it has a certain type. Of course, if I violate this assumption I have to wait until my program is already running to figure that out and then figure out why it went so wrong. While programming, I also have to keep in my head exactly what types a function takes as input, what order they are in, etc. anyway. And if I forget? How do I check this? Comments? Tests? How is that better than one line telling me what types it takes? send :: Request -&gt; [URL] -&gt; [Response] That tells me a whole lot of information, where's the overhead? I'm not sure how you program but I have a clear picture in my mind always of what types a function receives as input and which it gives as output. This clear picture obviously includes what those values are and thus what *type* of value they are. Why not codify this and allow the compiler to ensure I'm following my own rules. How is it a good thing to be able to accidentally break assumptions? By the way, in languages like Haskell and even more so OCaml which have powerful, static types, you don't need to write function signatures or give variables types if you don't want to. Everything can be inferred and you can very often write a program completely void of types. I grant you your first 2 points in comparison to Java, but those are issue of compiled vs. interpreted languages and have nothing to do with typing. Java is not all static types have to offer and for "pro-typers", it's a great example of a language that forgot to actually take all the good things static typing brings to the table. I might be a dullard but I honestly don't understand what you mean when you say duck typing makes it easy to write the right test.
http://xonsh.org/?
No use of the with-statement for files and sockets? 
I do not think languages should have a universal standard. Different languages are supposed to be used in different circumstances and by different people. Also, because the majority of languages do it one way, it does not mean it is better. Mathematically 1/2=0.5 makes more sense then 1/2=0. If you ask a mathematician who cannot program whether a integer divided by an integer gives an integer as result, what do you think he would answer? And I think python breaks with the majority of languages in a lot of ways. If every programming language did exactly the same if given the same syntax, whats the point of having multiple programming languages?
&gt; I don't understand this idea that statically typed variables are overhead, or that duck typing is less overhead. The overhead is that the types in your program must conform to the notions of your compiler's type checker; accordingly, to be able to execute any of your code, it has to pass type checking in compilation. The benefit is that if you manage to use that type system to perfectly represent the types in your program, in theory at least, certain classes of error become impossible. &gt; if I violate this assumption I have to wait until my program is already running to figure that out and then figure out why it went so wrong. Do you write unit tests? If so, you're executing your program and figuring this out. How frequently do you find that you spend a significant of your time figuring out that you have a type error? &gt; How do I check this? Comments? Tests? How is that better than one line telling me what types it takes? Comments can and should carry more information. &gt; Everything can be inferred and you can very often write a program completely void of types. Yes. That's not the type system we're being offered in Python, though, so it's completely irrelevant to this discussion.
&gt; Mathematically 1/2=0.5 makes more sense then 1/2=0. If you ask a mathematician who cannot program whether a integer divided by an integer gives an integer as result, what do you think he would answer? Well, python is a programming language so you have to look at it from a programmers point of view, not a mathematicians. For a programmer it makes sense that division with two integers returns an integer, returning a float is inconsistent and unorthodox.
&gt; Why do you think people are so resistant to it? I don't know if a lot of people are resistant to it or the migration path is just harder for large projects. Where I work, we have a django app that is still on Django 1.4. It was a long term release and we are currently in the process of upgrading it. It is a **large** django app so obviously this takes some time that has to be devoted to it that can't be devoted to fixing bug and/or adding features. Django only added initial python 3 support in 1.5. I would love to migrate over to python 3 but that obviously will take some time and a lot of testing. I think within the next 5 years, you will see more and more of an adoption of python 3.
The reason this won't work is that function arguments are evaluated at function *definition* time, rather than when they're being called. At that point, there's obviously no instance for "self" to be attached to (indeed, it hasn't even finished defining the *class*, never mind creating an instance). It'll fail because it can't find any variable called "self" (unless someone has defined a `self` global, in which case it'll run, but will do the wrong thing) The fact that args are evaluated at definition time also leads another common gotcha when you assign a mutable object as the default . Eg: def add_to_list(x, l=[]): l.append(x) return l If you call this without passing the `l` argument, this won't create an empty list every time, but rather reuse the same list it created once when the function was defined. ie: &gt;&gt;&gt; add_to_list(1) # Returns [1] &gt;&gt;&gt; add_to_list(2) # Returns [1, 2], rather than [2]
Just a stupid question but isn't there a LaTeX to HTML converter? Or the book isn't written in LaTeX? BTW seeing the table of content I'll give it a try, I always been not attracted to python, not because it is not powerful, but space blocks drives me nuts and are much harder to read for me. Any advice on that?
&gt; If your program fails the type check, it most likely will fail upon execution, at least some of time. That's the case with any language I've come into contact with. So, you're referring to a language which (a) has a static type checking system; and (b) allows you to compile and execute notwithstanding detected failures. I'm not familiar with such a language. I'd love to know what it is. As to the point I'm making, one reason python code is usually shorter and more readable than e.g. Java code is because you don't have to prove to the compiler that your use of types is correct. &gt; Unit tests and comments are neat if you're the only one working on your program and it's not too large. Types are comments that don't go out of date, and tests that don't go unmaintained. Are you joking? Either you're trolling, or you've never worked on non-throwaway software. Whichever it is, we're done here. &gt; why shouldn't we offload some of the work to the compiler if we can and save headache now and down the road? That's all I'm saying. Because you're not doing that. You're using a less powerful system which allows you to pretend that you have information and testing which is as good as the real thing. You can always use a half-assed tool to do a half-assed job. The reason you shouldn't is because it's half-assed.
Maybe I am biased on this (I am a physicist) , but isn't programming a mathematical tool to describe and execute mathematical algorithms. The integer/integer = integer division is consistent because most programming languages do it. I a am against doing it because every one else is doing it. The only thing I can see is that it is unnecessary unpractical and confusing when switching between languages, on which I can agree. 
RemindMe! 2 DAYS "Get free python automation book."
&gt; Who's the troll here? What I meant was that it would fail if executed without type checking. Way to dodge the issue, think hard about why you wrote that paragraph. I wrote that paragraph to interrogate whether or not you were telling the truth about having used such a language. It turns out you're not.
&gt; but isn't programming a mathematical tool to describe and execute mathematical algorithms. No, it is actually quite far from that since the programs we write has to run on real hardware and the hardware doesn't work like mathematics do(well in a sense they do but since you cannot, yet?, create hardware that simulates mathematics perfectly you are working in a very constrained environment). When writing programs you constantly have to distance yourself from the perfect theoretical model in order to create a program that actually works. Sure there are a lot of mathematics involved in the theoretical part of programming but once you have to implement that you will have to replace those perfect ideas with something that will actually run on hardware. Basically, the integer/integer division makes sense because that is how the hardware works and therefore there is a long tradition of having int/int return integers. As a side-note the floats in programming doesn't work like decimal numbers in mathematics, so if you expect floatA/floatB to return the same result as it would in mathematics you are in for an unpleasant surprise. When working on real-world projects you are even further away from algorithms. There you spend most time, like 99%, on stuff like project-management, API-design, optimisations for hardware/software, code-conventions, deployments, testing, developing-standards etc then algorithms. For example, it can be more important how you name your functions than that the functions themselves perform well or even are correct.
&gt; Indent your code blocks with 4 spaces. When did this change? Google used to use 2 spaces.
I'm glad in any case, 2-space is impossible to read
That's pretty damn cool. Is the code hosted anywhere?
I think I did it wrong, but yeah... Gotta figure out how to use this bot.
Working at CERN, that doesn't surprise me in the slightest.
Sometimes you need to pass keyword arguments that are reserved python keywords: &gt;&gt;&gt; make_xml("node", **{"if": "foo"}) "&lt;node if='foo'&gt;&lt;/node&gt;"
What's so bad about `result = [(x, y) for x in range(10) for y in range(5) if x * y &gt; 10]`? Yeah, some comprehensions can be hard to read when they contain multiple loops but that one is pretty simple. Also, why not just link PEP-8 and then add any specific changes?
Sometimes, but not in this case. C++ is one of the hardest languages to write secure code with, particularly for the naive. http://phoxis.org/2012/01/25/accessing-private-data-members-directly-outside-from-its-class-in-c/
Awesome practical ML project. Any info on the SVM software used?
Its only missing one section - DONT SUDO PIP INSTALL
Great point! The book is completely open-source actually, so if you feel that something is missing feel free to add it, contributions are highly welcome :) Here's the Github page: https://github.com/quantifiedcode/python-anti-patterns
Part of the problem is that the basic goal sets for science and software are nearly orthogonal. In science (mathematics/humanities/etc) the goal is to do "a hard thing once". If an experiment takes multiple Nobel laureates and overeducated assistants months to operate that's ok if the result is good enough. The important thing is the finished result, the tools are only needed once, and don't need to be durable, reliable, or easy to use (though of course it's better if they are); peak performance is far more important. In software development, the main goal is "never be wrong or late". Most software does fairly simple things, only more quickly and reliably than a human can. Process is much more important, because the goal is to make tools that rarely fail and are easy to fix and maintain when they do. Tools also have to fit together reliably with other people's tools without nursing by a human. So for example, Latex is a very ugly system from a programmer's viewpoint. It has almost no safety features, allows absurd abuses of semantics, and the meaning of expressions can rarely be parsed by computer. It is oriented towards output formats like dvi/ps/pdf that resist automatic processing beyond graphical manipulations. The people writing Latex contribute to the problem, not bothering to use what tools are there for making better source documents. Of course, this is ok. The end product is supposed to be a piece of electronic paper, and the end result will be manually verified by several people proofreading it. "Maintaining" a paper is a silly idea: you publish corrections, you don't edit the source of the original. Anyway, many things that programmers take for granted (type safety, encapsulation, source control, IDEs, debuggers, quality tools, build systems) are foreign ideas in math and science departments. Edit: I'm very frustrated lately with math typesetting. Your choices are basically unstructured semantic - free Latex, structured but semantic-less and insanely verbose presentation MathML, or semantic content MathML, which is utterly insanely verbose, documented-only-by-standard and essentially unimplemented except by prototype XSLT stylesheets from the working group that translate it to presentation MathML.
So it won't work for away games since there's usually not an accompanying goal horn? Could you maybe use some scraping or an api to tell you if it's a home or away game and then use two different learning algorithms? Also, do you have issues with false positives at the end of periods? 
Yeah, I'm not sure if I like their solution to it. Hmm, maybe a some middle ground: result = [] for x in range(10): result.extend((x,y) for y in range(5) if x * y &gt; 10) still kind of looks like shit. For this specific example you could use itertools.product but I still think just supporting multiple for loops would be better.
Much longer but immediately clear. result = [] for x in range(10): for y in range(5): if x * y &gt; 10 result.append(x,y) 
RemindMe! 2 DAYS "Get free python automation book."
It shouldn't matter what version ships with your OS, because you shouldn't be using the OS python anyway. You should be using alt-installs and virtual envs, or something like Docker. 
Where do you work? Almost all of Python uses spaces. Tabs aren't fully portable.
Awesome! Thanks. I can hardly believe it's finally out myself. It's happening!!! :D
Thanks!
/r/learnpython FTFY
List comprehensions can also use multi-line format: result = [(x, y) for x in range(10) for y in range(5) if x * y &gt; 10] P.S. Just checked the guide, and the above code is in the section titled "NO". I still think the code is easy to read and will use it: It's as clear as the for loop version, without redundancies like the initialization of [], calls to append, and some colons. If anyone can see any major disadvantages compared to the implicit loop version, I'd like to hear it, thank you. P.P.S. A sample code from the NO section, which I think it's more clear than its for loop version: ((x, y, z) for x in xrange(5) for y in xrange(5) if x != y for z in xrange(5) if y != z) I read it like this: collect all combinations of (x, y, z), where x, y, z are from [0..4], x != y and y != z. It's declarative and is as clear as a mathematical formula: {(x, y, x) | 0&lt;=x, y, z &lt;=4, x != y, y !=z}
Awesome! I haven't gotten around to exploring regex, but this looks a lot cleaner, thanks for the improvements! 
Sounds like a good plan, will definitely check that out, thanks! 
Feel free to say so as often as you like. :)
Are there any tools which specifically parse this function docstring style: def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): """Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. I like the way this looks and use a very similar style to document my functions when they have arguments, but do any tools like sphinx actually do anything with it?
Pretty much what I do as well.
Thank you for your hard work and make it free. Good guy.
Good, because I've found one major error already: http://docs.quantifiedcode.com/python-anti-patterns/readability/not_using_unpacking_for_updating_multiple_values_at_once.html
Not return at all is the same as returning None. I would recommend no return statement, otherwise you might confuse people. They might think there is an error status they need to take into account.
Spaces are also handled consistently. Spaces AND tabs won't be
&gt; Use imports for packages and modules only. As opposed to what? 
Look up napoleon. It parses google style docstrings. I personally prefer numpydoc though. I use everything else from the google style guide.
Google it?
&gt;Can you easily delete, say, three words? What about from the cursor to the next comma, paren, or other arbitrary selection? I don't do those things nearly as much as I want to go to the end of the line. I do understand why it would be great to have such things available. I'd probably try to use vim if the most basic commands weren't such a chore. It boggles my mind that a super common operation such as going to the end of a line requires a command that's so hard to do. Is there any good alternative keybindings that fix these obvious shortcomings?
&gt;List comprehensions can also use multi-line format: This doesn't address all of your points, but I literally just hit Save on a response to that style here: http://www.reddit.com/r/Python/comments/33gg02/google_python_style_guide/cql1snu?context=3
Whoa, funny running into you here! You're the odra who made the tennis-y game for the Ludum Dare before this last one, right? That was fun! 
Flask is the best to learn good practices and new patterns, take a look at app factory, Blueprints and the whole Flask ecosystem.
If that's the case, that means use... import package.module as mymod mymod.function(...) You can argue that that's less explicit both ways (e.g. all imported functions are defined at the top vs. what module did something come from in the guts of the code). Still if 80 characters is a hard cap and you're using classes, those extra 6 characters matter and you've just wasted 14.
 from class import function I'd think...
Procedures(*) should have no explicit return, and if you want to return early (after a pre-condition check or something), then use just "return" without any value. (*) Yes, functions with side-effects and no return value have a name, dear GenX people. :D
You should qualify those rules more (at least in the body of each rule). E.g. "Returning more than one variable type from function call" should be "Using special return types instead exceptions to indicate errors" or something similar. The rule has some merit even with that broad scope, but it's perfectly OK to return None when the other option is always an object (i.e. something usually 'true'). Yes, you can raise a LookupError, but that can be awkward. See "re.match" for example. Sometimes sentinel objects can be the better choice, but those are more needed in statically typed languages, Python *can* live without them. As a side note for the mentioned rule, your exception example's body is too long, and should put the 2nd line into an else clause. That's the "keep your try body as short as possible" rule you might be missing. Also, "raise ValueError('Wrong password')", which also makes the assumption you have there about catching the *right* ValueError less dominant. ;)
There is a Doxygen filter for Python called [doxypypy](https://github.com/Feneric/doxypypy).
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Regarding `namedtuple`: while I agree with the pattern, there's also this pattern for extracting tuple elements from a function return value: first, middle, last = get_name() print(first, middle, last)
Function style for funsies: result = filter(lambda (x, y): x * y &gt; 10, zip(range(10), cycle(range(5))))
We use this style at work and have tools that auto format the code on commit. Google's `yapf` tool forces [vertical alignment](https://github.com/google/yapf) instead.
Does this do something that shelve doesn't do?
svm in scikit-learn
Anti-pattern: Putting each anti-pattern on a separate webpage.
This is actually quite simple: $ conda install mysql-python
I've extended the above article here: http://skybert.net/emacs/programming-python-in-emacs/ it also includes looking up documentation, show usage of symbol at point and the embedded python shell. re elpy: sure it's great, I've just come to like anaconda so much I'll stick with it. re flycheck: haven't used it will have a look
I would prefer this style. A few extra lines aren't bad to make the code more clear
Alan Kay, the inventor of smalltalk and OO is supposed to have said *"I invented the term object-oriented, and I can tell you that C++ wasn't what I had in mind"*. Python prefers the explicit over implicit in this case and exposes self. I guess you are trapped half-way between knowing C++ and learning Python which requires you to either hold two ideas of OO in mind or embrace the Pythonic way.
Python isn't for one liners and there are far better existing languages and utilities in Unix that fill the one-liner slot better than this. Just learn sed/awk/grep/find/perl -p -i -e/less/...
I can confirm the latest Sphinx does work with this style, and that is what I am using. It may take a little tweaking to get everything to line up right. http://sphinx-doc.org/latest/ext/example_google.html
God damn it! Spoilers, I didn't see that coming.
&gt; So how do you align code? With spaces. &gt; Where do you break a long line and how do you align it? Break it wherever you like. Align it with spaces. &gt; You can't mix tabs with spaces. Python 3 will throw an error You can't mix tabs with spaces *for indentation*. You can use tabs for indentation and spaces for alignment just fine. &gt; your editor will still randomly align it based on the size of your editor's tab. Editors don't do anything randomly, and once again, you should use *spaces* to align. If your alignment screws up based on your tab width, then you are using tabs to align. Don't do that. Use tabs to indent, don't use them to align. 
butler? https://michaelallen.io/introducing-butler/
I never have either, and to me tabs definitely make more sense since they can be configured to display as x spaces, therefore rendering the whole concept of using a fixed amount of spaces quite moot. Alas, I use spaces myself, because conventions etc. That said, I would like to know about this havoc you mentioned. Would you mind giving a brief summary, or some relevant links? :)
Where's the anti-pattern for shadowing builtins? :) def append(number, list = None): # the keyword None is the sentinel value representing empty list if list is None list = [] list.append(number) #... 
Is there a reason that EAFP is preferred by the Python community?
Chaining methods make beautiful fluent apis. When you got something with a state such as a DB connection, it makes sense to return the current state to keep working with it. 
Can't see how it would be particularly difficult, but that's neither here nor there. I'm glad you aren't the dick you portrayed yourself as. :P
I'm not sure of the exact angle, but I assume doing it this way has advantages when the main goal of this site seems to be advertising your automated code review service.
&gt;If they write it in some ways, it can break on my system and then I can't read it. I don't think it would actually break - I think you just wouldn't LIKE reading it. &gt;If they didn't use tabs, the problem would go away. But if YOU used tabs, the problem would also go away! You don't like the tab width varying with the editor but maybe that's exactly why they like tabs! Look, I prefer/use spaces myself but, as in any religious debate, the arguments make sense on BOTH sides just depending on your perspective and priorities. The whole point of my suggestion is to introduce a measure of objectivity into this debate. There is no agreement on what people LIKE but there is an objective way to evaluate a style choice based on how much ripple effect any given change causes. That's an important aspect of a style that is often overlooked, IMO.
Thanks, I'll check it out.
It's one less blocking dependency for legacy projects :).
I like it. The only thing I don't like is that it automagically outputs base64. It should either be base64-in, base64-out, or bytes-in, bytes-out. For most of my use cases in this, I'll be having to add the step of processing the base64 into bytes again. Blah.
The globals example is terrible, because WIDTH and HEIGHT aren't actually needed anywhere in the code. The better example would be something that actually requires keeping state between function calls, perhaps *solving it with a state object passed in or declared within a closure (or an object default value, though I consider that one pretty hacky). * edit for clarity
&gt; I can't control how other people setup their editors and that it makes the editor settings effectively random when I use someone else's code. That makes no sense. Using other people's code doesn't make your editor settings "random". What does that even mean? &gt; You can't use tabs if you want consistency. What *kind* of consistency? If your projects use spaces to indent, then the consistency you get is that the code looks the same to you and to other developers working on the project. If your projects use tabs to indent, then your code always looks how you prefer regardless of how other people working on your projects like to see their code. They are both consistent, but in different ways. I don't see any value in forcing other developers to see the code how I like it. I don't care what they see. I *do* care that all the developers get what they want. Tabs are the only way of achieving that. &gt; However, the reason I didn't know is that I'm not going to mix tabs with spaces anytime soon, because it will break. Am I missing something? You just said that it will break, I pointed out that it wouldn't, you admitted that it wouldn't, then immediately said it would break again? We've literally just had this discussion. It doesn't break. 
A disk based hash dict is really useful. Be interesting to compare this implementation to redis-collections which uses redis for hash operations.
Also, who are all these crazy people who use exec to do the following? &gt; s = "print \"Hello, World!\"" &gt; exec s
&gt; as in any religious debate, the arguments make sense on BOTH sides ... The whole point of my suggestion is to introduce a measure of objectivity into this debate Objectively spaces are more consistent across multiple systems. I doubt there's a single programmers editor that can screw up 4 leading spaces hardcoded into the line, and many that can interpret a tab differently depending on how they are set. &gt;&gt; If they write it in some ways, it can break on my system and then I can't read it. &gt; I don't think it would actually break - I think you just wouldn't LIKE reading it. If reading it slows you down, it's "broken". Your source code is part of your product and a product that's harder for its maintainers to modify is a worse product. It's not just that I don't like reading it, the alignment carries additional meta information about the code.
I... I am, actually. \*ohmigods someone remembers\*
Is it that big a problem where people should use spaces instead of tabs? 
I think the max 80 character line length in this and PEP-8 is silly. Who has that little horizontal space when editing or reading code? I find it very easy to write (and read) code longer than that, especially when dealing with strings and sting formatting. Take this example: descriptive_variable_name = 'Attribute 1: {0}, attribute 2: {1}, attribute 3: {2}'.format(var_one, var_two, var_three) Even before the .format it's over 80 characters long, so where do you put a line break? And this is before any indentation. I also believe that [tabs for indentation, spaces for alignment](http://blog.codinghorror.com/death-to-the-space-infidels/) ([like so](http://blog.codinghorror.com/content/images/uploads/2009/04/6a0120a85dcdae970b012877709a74970c-pi.png)) is the natural order of things, but when writing Python I have adapted and use spaces for indentation, even though we have a character whose sole purpose is to advance the cursor to the next level, or tab stop.
Some tips are great, but others come off as pure PEP8 zealotry. There is no justification on why tabs/mixed tabs and space is supposedly worse than spaces other than "spaces is the standard for the CPython project!". I'd rather have clearly defined indentation levels (visible whitespace) I can adjust to whatever screen I'm using and use spaces for alignment.
Exceptions are the basis for handling errors in Python, the language is designed around that, not return values.
https://www.reddit.com/r/Python/comments/33gg02/google_python_style_guide/cqld9fg
(Probably the comment was supposed to say that it has to iterate through three elements of the list.) They should have done list(range(10000)) vs. set(range(10000))) and then queried for an element not in the list. Also that particular anti-pattern has nothing to do with python; you can use the wrong data structure in any language.
1. What if someone else decides to use tabs instead of spaces? 2. Four spaces might be four spaces but what are four spaces? If you use spaces for both indentation and alignment, at some point four spaces stop being an indentation level and start being a line padding, and that point is unclear. 3 What if you used 4 spaces, but I prefer 2 spaces for indentation, or vice-versa? 4 A tab is an indentation level. Always. So what if it shows different in another text editor? Semantically, it's still an indentation level. If the user of the text editor wants their indentation level to measure 8 spaces, then let it be so. 5 You align things with spaces. Tabs are only for indentation.
Apparently, them. 
&gt;Use imports for packages and modules only. I'm assuming from module.thing import * is still ok, since you're only importing the entire contents of the module to the local namespace. ^^^Not ^^^really.
In a case like this, absolutely.
See, this is where you just have to be a big boy or girl and do what feels right, I think that format is quite readable, style guide be damned.
Comparing tabs vs spaces to a debate over "destroying the Earth" is just... intellectually dishonest. I did not say *every* statement is a subjective one and it's disingenuous to represent me like that. Especially because the *very first thing* I did in my last post was acknowledge this objective statement: &gt;&gt;Objectively spaces are more consistent across multiple systems. &gt;Yep... This is an objective statement, yes. But then you're implying "more consistent across multiple systems" is better and *that's* where you get subjective. "More consistent" isn't a goal for everybody - for many, that customizability (i.e. inconsistency) is *why* they like tabs. The very thing you hate is the thing they love, so you can't convince them by telling them your way will eliminate what they love. These are reasonable people who have these preferences and goals - not crazies who want to "destroy the Earth".
First off, thanks for the kind words. I really do appreciate it. Second, you asked what my general problem I'm trying to solve is. Here are my key problems related to my world: * Big IS seems to focus on building "Enterprisey " systems that work well for some of the complex big problems. In other words, running SAP is that right thing for a big public company and IS makes sure it is up and running all the time and gives us the correct results. * When it comes to asking for any kind of solution to my problems, I always get a "show me the ROI" or "show me why you can't use our existing system/report to do what you need?" * I get frustrated because I know the problem space well enough and the technology well enough to know that this is a few hours worth of work to implement properly but IS just does not seem to want to do that. * The result is that well-meaning people take the problem into their own hands and build horribly complex Excel/Access solutions that really are not maintainable or scalable in any way. * As a long time python user, I shudder at how many smart people don't realize that there are alternatives to doing all this manual work. * I recently started using pandas and realized it is so helpful for this class of problems. * Pandas allows me to do very powerful data manipulation in simple python code vs. obfuscated VBA or purely manual processes documented step by step in Word. * In my ideal world, a smart analyst would be able to use python+pandas+whatever else is available to them to automate away all those repetitive processes they do today. * My most common use case is: pull a bunch of data out of a couple of systems, join it together, filter it, do some clean-ups then generate a report. Given all of this, I feel a little bit like a poser because I am not an expert on all of this. If you asked me to write a complex SQL query, I'd struggle. However, I think python is powerful and simple enough that I can filter data in pandas, combine with a couple of other tools and generate a passable Excel/HTML/Text output with the results. Yes, python could email it out too. Another way to put it is that I am trying to reach people that don't have the time to learn SQL+powershel+pandas+ruby+javascript+vba+HTML in order to build the best system. I am just trying to tell people that learning python is going to give you a tool set that will do the vast majority of what you need. Focus on building that python skill and I think you can do just about anything you could possibly want. I agree that there should be some simpler system to do this. But I have not seen it. I can't promise that python+pandas is the best but I can sure as heck say it is not the worst :) I don't know if I'm helping but with what you're telling me python+pandas seems like a reasonable solution for your needs. Is it the best? I can't guarantee it but I don't think you're missing something nor are your crazy. 
It still is. 
It's not OK internally. This undermines the purpose of the rule, which is to keep the global namespace as clean and explicit as possible.
The [Test for object identity should be is not](http://docs.quantifiedcode.com/python-anti-patterns/readability/test_for_object_identity_should_be_is_not.html) page seems somewhat confusing. It says things like: &gt;&gt;to check the identity of an object is `OBJECT is not CLASS` why is CLASS used as a placeholder there, rather than something like OBJECT2? Classes aren't the only (or even most likely) thing you'd be using `is` on. That choice of name seems more appropriate for something like isinstance - it's almost suggesting `is` is doing a type check (ie OBJECT is an instance of CLASS), rather than an identity check (some languages (eg c#) do use "is" to mean this, but python isn't one of them). The example given is similarly misleading: if rectangle is not Circle Ie. a lowercase variable, `rectangle` (suggesting some object instance) being compared with the capitalised `Circle` (suggesting a class name). This seems an odd usage. More realistically, you'd be comparing with something like `None`, or maybe some special sentinel object. I'm not sure why you'd ever be checking that an object bound to a variable named `rectangle` is, in fact, a class named `Circle`, unless you're really bad at naming things.
with commas representing tabs, tabstop every 4: def a(x=3, y=4, flag=None): ,,,,some_code ,,,,some_more code ,,,,for code in codes: ,,,,,,,,print(a, ,,,,,,,, b, ,,,,,,,, c) tabstop every 8: def a(x=3, y=4, flag=None): ,,,,,,,,some_code ,,,,,,,,some_more code ,,,,,,,,for code in codes: ,,,,,,,,,,,,,,,,print(a, ,,,,,,,,,,,,,,,, b, ,,,,,,,,,,,,,,,, c)
https://github.com/d0ugal/clip.py ?
I also hate the 80 character line limit nonsense. But also, this is the internal style guide at Google, not something that Google is saying all python projects should follow. 
Probably cause they have more experience than you?
&gt; Comparing tabs vs spaces to a debate over "destroying the Earth" is just... intellectually dishonest I take it therefore that you can't logically disambiguate the two cases? :-) We choose criteria to measure, we choose how to measure them, and then we decide based on subjective ranking system which is better. If you're going to resort to "this is madness!" then I'd like you to define madness without invoking a subjective majority consensus (X is mad if some fraction of people say it is so), or divine will, both of which are "religion". Incidentally I never said my argument was *not* religious in nature. [In this post](http://www.reddit.com/r/Python/comments/33gg02/google_python_style_guide/cqlbl2g) however, you seemed to want to tell me I was, and I actually agree with you. Spaces are the path of least resistance for me (more consistency, less broken code, more existing code) so I wish to spread the Religion of Using Spaces.
I've been using Python longer than Google has existed and feel that the official style guides are adequate. No need to re-invent the wheel and create confusion about which style should be used by doing so. 
 def list_of_lists(list): return [[x] for x in list]
&gt; That makes no sense. Using other people's code doesn't make your editor settings "random". What does that even mean? It means I may have to reconfigure my editor in a way that I cannot predetermine until I see their code. If I know the format of their code in advance, and it matches my format, I don't need to take any action. &gt;&gt; You can't use tabs if you want consistency. &gt; What kind of consistency? Compatbilty with the Python ecosystem in general. Sure, if you are working on a specific project, you should match the project's settings. &gt; Am I missing something? You just said that it will break, I pointed out that it wouldn't, you admitted that it wouldn't, then immediately said it would break again? We've literally just had this discussion. It doesn't break. Syntactically it will be fine (as you correctly point out) but there's the still problems with it changing line lengths and where you would naturally break a long line. Plus, there is a higher chance of a misconfigured editor messing something up since so many people have theirs set to replace tabs with spaces.
&gt; The "good" example is more concise, but it's less readable **and has different behavior**: (Emphasis mine) This is the real reason we actually use unpacking for updating multiple values *when it's logical*.
Of course, a time and a place. Maybe you want to update all at once based on the old values, and sometimes based on the mutated values. I just wish this was explained clearer in the page instead of saying "it's the same but more concise" when no, it's not the same at all. 
I really like googley docstrings. I've had them at companies I work at before, had them on my own projects, and my current company just decided to use them over Rst.
Bytes-in bytes-out seems better to me, especially since Python has base64 encoding and decoding built into the standard library.
Yepp
Don't. Prefer sqlite or potsgresql. They are both better than mysql.
How does it compare to HDF5?
It's always a good idea to have a separate test for each bit of functionality, but where are the specification strings (that appear in the end) defined. I assume they are in the javascript, but it would be nice to have them in the actual python test procedure.
Could you give me a quick answer of why py.test is better than using unittest? I use unittest all the time, but I see people mention py.test a lot.
Now I worry how the rest of your code looks like..
The example for Asking Forgiveness instead of permission is pretty meh. Most of the python programmers I know would prefer the if statement to that try/except with a pass, it's cleaner. Better example would be to have an if/else and then correctly move the else into the except.
Why would this be bad? Its more explicit.
As others have said, using PyPlot/Matplotlib for this is not that great, unless you get into the bowels of it. You can look at e.g. [Chaco](http://code.enthought.com/projects/chaco/) if you want a rich-client GUI, or [Bokeh](http://bokeh.pydata.org), if you want a web browser interface. (See e.g. https://github.com/bokeh/bokeh/blob/master/examples/plotting/server/animated.py for an example of animation with Bokeh)
+1000000000000!!!!! Catching **all** exceptions is almost always a no go!
As others have mentioned, pandas and numpy will help you a lot. The former can handle [reading and writing in several formats](http://pandas.pydata.org/pandas-docs/stable/io.html). I'd generally stay away from text-based formats like JSON or CSV other than for dumping and/or sharing relatively small datasets. Since I'm an experimental physicist, I have a fondness for the HDF5 format, which works really well as a way to store data from a single experimental run in a single file that is easily shareable, for example. SQL databases are also useful, and ubiquitous enough that it is worth learning about. I know nothing about the geodatabases you mention, but they might be perfectly capable for what you are doing (and I'd imagine so if they are common in the GIS world).
Paste is more in the league of Werkzeug which is Flask based on. So looking at and used both I don't see strong advantages of either one...
As with all of my other posts on here, I don't shy away from criticism. On the contrary, I welcome it, so have at it, people.
This tripped me up ages ago when rich comparisons were first added, and Numeric (the predecessor of numpy) made comparisons perform elementwise: `x == None` returned an array of booleans (which, unless it was of zero length, would be interpreted as true). I quickly learnt to use `x is None` instead. Right now, with numpy, if x is an array, `x == None` will return `True` or `False`, but raises a warning that that behaviour will change to be elementwise in the future. 
They are always tricky to read but, unexpected behaviour? Such as?
Supposing the blocking readline takes place in `a_boolean_function`, def do_something(arg1, arg2, arg3, arg4='some', arg5='thing'): while not a_boolean_function(): pass good()
Disabling SSL verification is extremely dangerous. That makes it a little too easy to perform a MitM attack, and spoof the source of you passwords. Also what is your definition of an OTP, because your code does to implement what most people would consider an OTP. 
Is the property defined here wrong? http://docs.quantifiedcode.com/python-anti-patterns/correctness/implementing_java-style_getters_and_setters.html I think the deleter and setter in the solution should have @length.deleter and @length.setter instead of @width.deleter and @width.setter.
That's without indentation though. With this: def my_function(function_argument, in_list): if function_argument &gt; 10: for i in in_list: template = 'Attribute 1: {0}, attribute 2: {1}, attribute 3: {2}' descriptive_variable_name = template.format(var_one, var_two, var_three) your solution is too long again, and it's breaking up what's one logical statement to two lines, so now your code takes more space vertically instead. You force me to buy a higher screen.
I would argue that if you're using a smaller laptop screen you have to make sacrifices, and having to scroll horizontally when viewing two files side by side is one example. 1920 pixels is a popular screen width nowadays, and quite a few laptops have a larger resolution, and with that you can fit 200 characters with ease. I agree that lines shouldn't be too long and that comparing or editing files side by side is a must, but I think a hard limit at 80 characters is too strict.
:( no dough there, had flushed history
&gt;I can't understand why it's treated like the plague in python. Are list comprehensions really so much cleaner? To my mind it doesn't really hurt the readable-at-a-glance code python coders are all about. 1) map is a functional language-style construct and is out of place in a mostly OO-language like Python. 2) list comprehension can do anything map can. As from the Zen of Python: "There should be one-- and preferably only one --obvious way to do it.". 3) list comprehensions to most developers are much easier to read. Readability counts. The introduction of map, reduce and filter was basically just to shut up a vocal minority of people who like functional programming and wanted it crammed into Python. They really have no good reason to be in Python.
I agree, it's kind of a dumb rule. Although I suppose it prevents you from importing some generally-named function into the namespace and using it without context. For example: from os.path import join path = join('dir', 'file') Versus the more explicit import os path = os.path.join('dir', 'file') Granted in this case it's fairly obvious what is meant, it is not always so. Use your best judgment. I use both forms.
when you install a library to use with anaconda, you have to install it with conda . The useful commands are "conda search library" for searching if the package exists (it may be case sensitive, I don't remember), "conda install library" to install and "conda pipbuild library" to make a conda package of the library if there is no conda package. You may also use "pip" but be careful to use the one from your anaconda env (pip -V to check)
But what if I encrypt something on one computer and try run decryption on another?
~~Why the lambda and not simply: `map(list, my_list)`~~ Edit: After mulling this over, the lambda seems to *always* produce the likely intended behavior, whereas my proposal will explode iterables into lists and blow up with non-iterables.
I'm waiting for the 1.8 twoscoops edition!
Write down the key instead of saving it as an environmental variable. Honestly, if you're only encrypting you stuff to guard against hackers and not, say , your roommates or anyone else who has access to your room writing down your key is by far the safest method. You could also just retrieve your key via ssh/scp.
It is incredibly refreshing to hear from someone in the Python world who isn't allergic to decent Microsoft Office products. In my workplace Word, PowerPoint, and Excel are a fact of life and using something besides Word or PowerPoint to communicate/collaborate ideas would be counter-productive for everyone. This is just my opinion for my engineering job... not trying to make any statements about what works for others.
Arf, its worthless to pick the fight of explaining that mysql as the worst possible complexity algorithms: mysql is better for small size databases (which means it has a niche in which it is legtitim), but INSERT/SELECT/UPDATE have the worst diminishing returns. Anyway, with a good backend like SQLalchemy/peewee? and focusing on standard SQL syntax, you should have your DB layer abstracted which means a fairly easy migration if needed. So, there is no worry to have when you code cleanly.
This example, and the correct way to approach it, is more nuanced than simply adhering to one pattern or another. In practice, the behavior of the code should reflect the expectations about the entire system, not simply opinions about style. Examples: # Here, we *expect* the file to exist. If it doesn't we consider that to be an # unexpected, exceptional case. try: os.unlink('file.txt') except OSError: log.exception('we exploded') # Here, it is known and accepted that the file may not exist, so our code # reflects our expectations. if os.path.exists('file.txt'): os.unlink('file.txt') Both ways are perfectly fine but their application is dependent on context. What's important to remember, and what the author doesn't bother to explore, is that exceptions are meant to reflect *exceptional* behavior. If it's reasonable to expect varying behavior in a given context, it's more appropriate to handle it conditionally.
Someone forgot to `import humor`
So, at least as old as Python 2.5. Meanwhile, it also explicity requires distinguishing new-style classes by inheriting from `object` https://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Classes#Classes
[DJANGO!](https://youtu.be/IAooXLAPoBQ) Django is great. I'm glad for the team! Ten years is a long time for software, especially when focused on the internet. Here's to another ten! 
Thanks for the insight! I'm familiar with HDF format as it's also used for large remotely sensed images from satellites, but never really thought of using it to store data in this way. It might end up being the way I go. Geodatabases are a proprietary data format for the Esri suite of ArcGIS applications. They're robust and useful but can only be read if you have their software installed, otherwise it's just a jumble of weird files in a folder with a .gdb extension. 
Sweet, this is pretty much what I was looking for, thanks! I have a little experience working with numpy but haven't yet saved any of its own data structures, just used it to manipulate and then save in other formats. However, the data I'm working with won't be spatial in nature so I won't really be able to use the tools provided by ArcGIS and so don't really want to store my data using it. Thanks for all the recommendations! 
That's unacceptable. Here's the [link to YouTube](https://www.youtube.com/watch?v=0PSdzUxRYpA). The [GEMA](http://en.wikipedia.org/wiki/Gesellschaft_f%C3%BCr_musikalische_Auff%C3%BChrungs-_und_mechanische_Vervielf%C3%A4ltigungsrechte) is in battle with Google about content license rights: http://en.wikipedia.org/wiki/Blocking_of_YouTube_videos_in_Germany
Was not a huge fan of the talk. She basically just said common python gotchas, and sometimes CPython specific, not Python *wats* She says they are same, but these are pretty tame to some of the weirs stuff from the original *wat* video. Although i did learn one thing about code objects and the interned values, but I have never encountered a reason to care about such a small detail. Overall is probably be cool with this talk at a local meetup, but PyCon seems like to big of a venue, where the average person there is experienced in python and knows this stuff already.
It's the other way round - the `str` is being applied to `other` there - the thing you're comparing with, not the string contents of the node. As such, what will happen if you use this object in a `NavigableTextElement("None") == None` check is: &gt;&gt;&gt; "None" == str(None) True 
Thanks, I just bought a ebook version because I know it takes a load of work to get it finished! However, I have a technical problem though, I am using kindle paper white to view it, and the pdf version I downloaded from No Starch doesn't scale well on my kindle. I haven't try the epub and mobi version, do they work better?
Blaze and dask are specifically designed as a numpy/pandas like front end to out of core data computations: https://github.com/ContinuumIO/blaze ; http://blaze.pydata.org/en/latest/ooc.html http://matthewrocklin.com/blog/work/2014/12/27/Towards-OOC/ 
Like I said, google wants to put pressure on GEMA, so if youtube's content ID-system recognized that the video contains music, it will block it (regardless of it the music is owned by GEMA or not). It does not block ALL music, but it definitely blocks more than they have to, to make GEMA look like the bad guy who hates entertainment. Gema actually has a FAQ-page regarding the conflict with youtube, and it reads like this: 2007 Gema was the first company to make a contract with youtube that managed in which way copyright-protected material was allowed to be used on youtube. 2009 the contract ended, and the negotiations over a renewal failed. Gema wants that the creators of the content get paid for their efforts, while youtube provides access to this content without paying, which is illegal. Since the negotiations went nowhere, they stopped them in 2010, formed a partnership with some other companies and sued youtube to take down 75 songs from the German youtube page (10 of which belong to GEMA and the rest to their international partners). Gema then sent a cease-and-desist letter to youtube, which they didn't follow, so they went to court. The first time in court they lost because of an unnamed formality, the second time they won, and the court ruled that youtube is responsible for the content they make available, and that they have to provide the means necessary to block copyright-protected content (this was about 12 songs at that point). Both youtube and gema appealed since they wanted to be sure just how far the other party had to go, and both started negotiations again (outside the court). They negotiated until 2013, again no result, so they stopped negotiations again. Gema then went to an arbitrational tribunal to check (exemparily for 1000 different songs that belonged to them) whether youtube had to pay compensation or not (and if yes: how much). About then (2013) youtube decided to influence the public to favor them, so they started blocking every single gema-owned song as well as other songs in Germany and displayed the infamous 'we can't show this content because Gema...'-blocking image. Gema sent a cease-and-desist, youtube didn't comply, Gema sued, court ruled that youtube was influencing the reality surrounding the lawsuit between them and that they had to take down these notes, youtube appealed, it's fucking 2015 and we still can't watch content, while Gema and youtube discuss in one court whether youtube is allowed to basically lie about GEMA to damage their reputation and whether they have to pay compensation for damages in another. Negotiations about how much youtube would have to pay to show the content in Germany have not been running since two years. TL;DR: Youtube is the bad guy, and Gema is the douchebag fighting him, and most people basically root for youtube simply because they (rightfully) dislike Gema.
As a GIS person, you might want to check out geopandas: https://github.com/geopandas/geopandas It's built on top of pandas and basically spatializes its data analysis. Pretty powerful way to work with geographic data within python. I now do most of my spatial analysis and map-making within python.
Since original songs from various artists, which have stated themselves that their songs are gema-free, are often not available in Germany, there can only be two explanations: 1. They are doing it on purpose 2. They have set their filters to 'anything that resembles music'.
&gt; I'm not too sure why it's not more popular Because it is in BitBucket instead of Github
This looks great! It will be very familiar to peiple who have used R and Rstudio for data science.
Hmmm... an interesting set of results in Python 3. In [1]: %timeit 9999 in set(range(10000)) 1000 loops, best of 3: 489 µs per loop In [2]: %timeit 10000 in set(range(10000)) 1000 loops, best of 3: 490 µs per loop In [3]: %timeit 9999 in list(range(10000)) 1000 loops, best of 3: 491 µs per loop In [4]: %timeit 10000 in list(range(10000)) 1000 loops, best of 3: 492 µs per loop In [5]: %timeit 99999 in set(range(100000)) 100 loops, best of 3: 6.79 ms per loop In [6]: %timeit 100000 in set(range(100000)) 100 loops, best of 3: 6.72 ms per loop In [7]: %timeit 99999 in list(range(100000)) 100 loops, best of 3: 4.58 ms per loop In [8]: %timeit 100000 in list(range(100000)) 100 loops, best of 3: 4.58 ms per loop In [9]: %timeit 999999 in set(range(1000000)) 10 loops, best of 3: 96.9 ms per loop In [10]: %timeit 1000000 in set(range(1000000)) 10 loops, best of 3: 98 ms per loop In [11]: %timeit 999999 in list(range(1000000)) 10 loops, best of 3: 65.5 ms per loop In [12]: %timeit 1000000 in list(range(1000000)) 10 loops, best of 3: 65.5 ms per loop Is `ipython` doing something odd behind the scenes or is `list` legitimately faster in this case?
Never fully hopped onto the ipython bandwagon. This looks much more my style. Very excited to test it out. 
Cool! Now to figure out how to set it up behind a nginx reverse proxy. Is there a way to set the base URL and other IPython settings?
Lots of text, no content.
Honestly I'm not seeing the point. "It's like IPython... except it does less!" really wouldn't appeal to anyone but the Arch/Gentoo/Slackware/TinyCore Linux crowd. What type of hardware was IPython being run on that made it feel "bloated"? My last PC had 2GB of memory and the old notebook I have has a single core 32bit processor, 512MB of memory, and a 70GB 4200rpm IDE hard drive and I can run OpenSUSE Linux with full KDE desktop on it. PyCharm's a bit slow on that, but the Eric5 IDE runs just fine. 
good point! we have many patterns that are currently not visible on the website since we're still doing some editing, if you like feel free to create a new article and submit a PR!
Guess we're guilty there ;) We actually started this book project a while ago but since then moved to a different way of presenting our code patterns directly on our website (https://www.quantifiedcode.com/app/patterns), so the book became a bit obsolete for us. We still wanted to publish it though since we thought it might be useful for other people as well, e.g. when teaching Python in class.
true, this term might be slightly misleading, it is a known expression though in the programmer community.
A single page would be a lot easier to read. You could use headers (or some other tag) with an `id` to allow linking to specific items on the page.
nice, thanks for this! Did you create a PR / issue on Github for this?
thanks for pointing this out, there is already a PR with an improved version of this article, should be fixed soon :)
thanks for pointing that out, I'll fix it!
thanks, I'll fix this!
thanks for pointing this out, will improve the article!
Didn't realize I could. Honestly, I just showed up to work and I don't get off until midnight, so I'll probably forget to as well.
In my experience Arch fills a lot of that niche now. I remember back in college when the cool kids of the linux club started using arch. It lasted about 3 month, full of configuring and then they all bought mac books. It was funny to see them going from making fun of ubuntu users to owning only apple products. Disclaimer - I have nothing against people who have the fortitude to actually run arch - but there is a subset of users who are complete hipsters about it
Isn't that true of any unique language feature?
&gt; Honestly I just don't understand the mindset of those who complain about "bloat" Resources are finite, and when they're gone, the swap hits the fan. Everyone complains about this, but most people don't call it "bloat"; they call it "I need a new computer".
Same here. I've been using Spyder: http://spyder-ide.blogspot.com/ That's why I asked the OP how Rodeo is better.
Can anyone tell me more about IPython bloat? What particular aspects/ features do you consider bloat?
Rosetta code is interesting, my answer was related to the "probably difficult". I don't think so, but you are right, considering the language only and no third party libraries even an innocent problem can be intriguing to solve. 
Your post should be on /r/learnpython
Bah, the bloody ctrl + ENTER runs the "highlighted code or current line". I was used to ipython notebook and how it would run the entire block. Oops. This looks pretty neat so far though. I'll give it a go for a bit.
Big data generally means out-of-core. Pandas and HDF5 won't help you there. If you can fit your data in memory Pandas and HDF5 are fine.
Spyder is a window with multiple panes: an editor, an IPython prompt, and an object explorer. You can create cells in the code like an IPython notebook and run them individually. My question for the OP stems from the fact that Spyder already exists; why do we need Rodeo?
That'll do something slightly different in the example they gave. If you just did: dct.get(key, []).append(new_item) you'll not actually add anything to the dict, just create a list not attached to anything that then gets destroyed. You'd need to do: l = dct.get(key, []) d[key] = l l.append(new_item) which requires accessing the dict twice, doing more work. setdefault is different in that it'll actually set the dict key if not there before returning it, rather than just returning the default if the key isn't set.
There are worse ways of advertising that putting correct information out there with a link to your service.
To push it a little more... def compose(*fns): def compose_(*x): return compose(*fns[1:])(fns[0](*x)) if len(fns) &gt; 1 else fns[0](*x) return compose_ Then def fmap(*fns): return lambda xs: map(compose(*fns), xs) And you can do things like &gt;&gt;&gt; v = [1] &gt;&gt;&gt; M = lambda rho: compose(lambda x: x*rho, fmap(lambda x: [x], lambda x: x*rho)) &gt;&gt;&gt; M(20)(v) [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]] Then if you don't like all the lambdas, let mul = lambda x: lambda y: y*x and rewrite def M(rho): return compose(mul(rho), fmap(listwrap, mul(rho))) 
Sorry- by bool I meant boolean compatible. It seems like Numeric still violates the contract... `array == None` returns a list of bools, which tests to True, even though the comparison should be False.
Create a Linux VM on the laptop through VirtualBox. No latency. 
Nice effort! I was really excited to try this out... until I saw the price :( $50/month is way to much for how little the API actually does. Especially when there are so many other free sources to scrape scores from.
ok, thanks for the feedback! I think it shouldn't be a problem to offer an additional version with all patterns in one single document, will put this on our feature list for the next release!
Since it is served, it allows you to edit and run python on a server without having to log into, mount, or install anything, not even X11. It's not as full-featured as Spyder, but that may not be the point.
Well, what's a pain about it? I've been using a Mac for development for well over 10 years without much trouble.
Full disclosure: I'm one of the hosts. We have been having a lot of fun making this podcast and we have some pretty excellent guests lined up. Anyone looking for a Python podcast with some breadth should definitely subscribe via either iTunes or Stitcher (links on the home page). We are happy to answer any questions and comments/suggestions are welcome.
I've been using Fernet (MultiFernet actually) to encrypt sensitive information and save it as a BLOB in our database. Not sure why or why not to use GPG, as I've only ever used it once. However, with cryptography.io's Fernet since there is so little configuration involved there is very little chance of screwing something up. That's really the biggest advantage of using Fernet IMO. 
Great, thanks for the info.
I started writing a tomato throwing script using Aroldis Chapman instances of Human class objects...but then I realized I had work to do. tldr: booooooooooooooo....
I agree, but I don't think several levels of nesting is ever appropriate in a single line. You're only hurting your reader, unless you think [this is somehow less clear](http://www.reddit.com/r/Python/comments/33gg02/google_python_style_guide/cqkvqpm). And the fact that you say "once you are used to them" already states that they're not as clear. Saving 3 vertical lines is not something to be proud of. Saving the person who now has your job 3 seconds for comprehending what you're doing, is.
I'll use it when it runs stable on Python 3. For now tho I think I'll stick to NodeDotJS and NET and C## since they all have simple IDEs that do all the programming.
I've already seen this article here.
Homebrew or macports.
I don't think its a bloat related to performance. I think they mean visually. They compare it to vim/sublime probably in terms of visual/layout efficiency and keyboard efficiency.
And my question was why do we need either of those things?
I would consider looking into tools like PureData and Processing for creative coding, they excel at task like the one you want to do, including microphone input. There is a module called [Python Mode for Processing](https://github.com/jdf/processing.py) for coding processing using python, but I'm not sure that it supports everything from processing.
For people that use Python as data or numerical analysis, or are coming from Matlab, an IDE like Spyder has many features that a regular IDE might not have that cater to a subset of people. You don't need Spyder to do Web Development, although you could. Spyder isn't better than Python. Spyder makes using Python better for certain types of people. 
Is this an invitation to downvote bad code?
You probably need to share more in depth as to your problems, I've been using a Mac for Python, Go, C and Java work for the last several years with nearly no issues. Any issues I've found or heard of are either user errors (like installing pip under sudo) or missing libraries, which are usually fixed with `brew install [lib]`. I'm not suggesting these are your issues, but my experience sounds quite a bit different.
I think of "self." as similar to the _m naming convention in c++. Python likes to force these types of conventions, which tends to make pretty and explicit and readable code in my opinion. 
Wait,what? Your C# IDE does all the programming for you? Then why did Steve Ballmer chant "Developers, developers, developers"?
WOW. I bow to your ~~masochism~~ hardcore-ness. ;-) Today I'm happy with OpenSUSE. :-) Someday I'm trying Linux From Scratch though.
I always give up on trying Arch when it drops you out to fdisk to do manual partitioning. :-) Now thanks to a new PC and a custom disk setup I know a lot more about Linux partitions, LVM, encryption, etc. but it still doesn't seem necessary. I firmly believe their "keep it simple" policy is for the satisfaction of the developers, not the users. :-( I talked to someone online once who uses Slackware. I asked him how he handles installing software with no dependency management. He said that he just keeps a pencil and pad on his desk and keeps track of all the installed libraries with it. He called it "easy" and was genuinely surprised that anyone would see it as a problem. 
I've been doing Python on Mac without a hitch. What's the actual problem?
Being a computer (beep boop), I do like tab delimited data, but graphs are nice, too. Those Brython numbers look usable! I'd be very interested to see these benchmarks run on a few mobile browsers (without cPython comparison, of course).
Blergh. Runs in the browser. 
And it might be easier to have the control if the need for a rollback arises.
Sorry, but the source scares me. 1. The source code is parsed with regexes. Do you know about [ast](https://docs.python.org/3/library/ast.html) module? 2. docopt dependency for that simple command-line interface. There will be like 5 or 6 lines of [argparse](https://docs.python.org/3/library/argparse.html). 3. You never mention that your tool does *http(s) requests* to pypi and relies on a 3rd party library for that.
they should click on “Help/Keyboard shortcuts” once. insert a code cell in the middle of a markdown cell? (Start in edit mode with the cursor where you want to split) 1. `Shift+Ctrl+-` to split 2. `Esc` to go to command mode 3. `a` to insert a code cell and the reverse? (Start in command mode with the code cell selected) 1. `x` to cut/delete the code cell 2. `Shift+m` to merge the two markdown cells
i *hate* the term. bloat basically means “the specific features that i don’t happen to use, no matter how much they don’t affect me”. * c++ features without performance impact are “bloat” (because… they exist? they take up space in the TOC of the docs? they take up a few kB of disk space?) * menu items that you don’t use are “bloat” (because obviously the cognitive burden of skipping over them is unbearable) * setting panels in the option window that you don’t need are bloat (because they EXIST. BAH!) if people just stop saying that word, maybe they’d actually say something useful.
As others have said LPTHW is great, also check out /r/learnpython!
My favourite ones are "Learning Python" and "Programming Python" by Mark Lutz (O'Reilly). Best wishes Thierry
We had a small project where we were doing car horn detection on raspberry pi. First we had to get a usb sound card. The. We use py audio. We based our code off here: http://blog.yjl.im/2012/11/frequency-spectrum-of-sound-using.html?m=1
The question has different answers depending on your background I think. If you're coming from another imperative programming language I'd say don't bother, just go through some quick tutorial and then use the reference.
Ha, yeah, it was the late 90s or really early 2000s, so the hardware was super out of date already. I was in high school with time to kill. It had a PCMCIA Ethernet card and a relatively small hard drive by today's standards. It couldn't run X (16 MB of RAM...), but it could connect to our Windows 98 machine via Samba and play MP3s from the network. Also, I seem to recall having a console-based ICQ client and Links for browsing. On a good day it could run all three at once, and with Screen it multitasked like a champ.
The last graph is super cool!
No offense to the creator, then, because it does an incomplete job at it. For example, `10 ** 100` gives a non-integral result (and `!= 1e100`). `repr(eval)` gives `&lt;function undefined&gt;` yet `eval.__name__` gives `function`. `namedtuple` doesn't seem to work. Scoping seems to be noncompliant (and can result in `Internal Javascript Error`s quite easily). A lot of this stuff is excusable, but it's nowhere near the compliance that PyPy.js would give. Speed comparisons aren't just until these - a lot of which will have significant speed penalties - are fixed.
Why write 5 lines of argparse when I can write `docopt(__doc__)`? `ast` is definitely the way to go though. **Edit:** Genuinely curious - I'm usually quite liberal about depending on things - I blame Ruby.
#####&amp;#009; ######&amp;#009; ######&amp;#009; ####&amp;#009; **Python Programming for the Absolute Beginner, 3rd Edition** Current $20.68 High $23.83 Low $18.25 [Price History Chart and Sales Rank](http://i.imgur.com/nILYQ8S.png) | [GIF](http://i.imgur.com/JyJrYNx.gif) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
That mindset in the Python community has been largely influenced by the quality of its packaging tools... but these are slowly becoming fairly decent, so it's not really appropriate anymore to be generally scared of dependencies.
The influence of integer implementation is already addressed in the comments of the blog post. I don't think any of the project claims that 100% compatibility is reached. By nature, pypy.js is obviously the most compliant, but not 100% (try "time.sleep(5)" on the pypy.js console for instance). Anyway, all projects take differences with the Python Language Reference as bugs. At the moment there doesn't seem to be bugs with namedtuple and scoping on the Brython bug tracker ; if you have found any, you are welcome to report them. I don't see how solving them would have any influence on the speed tests though.
Very interesting, thanks, and you speak just about the difficulties I had (I still have) when I tried Haskell (I gave up, but apparently this is normal). I really have the feeling Haskell is awesome, very powerful from day 0 when I tried it online. Now, interesting enough, I always want to reproduce the concepts I learnt from Haskell in python (or lisp): currying, more powerful mapping, pattern matching,… I just don't agree with point 6 which says that the libraries are excellent. Oh, maybe they are, but I feel like there is far less libraries that deel with the real world in Haskell than in Python. Python seems to have so much advance. For example, I tried to read a file's mtime and it wasn't straightforward at all. The state of web-related libraries (requests, html parser,…) still seems to be inferior than python's. Maybe you have good links that will show me wrong ? And in reddit or on blogs, nearly every news is to speak about haskelly-tech-stuff, not real-world stuff. Like if Haskell's world was exclusively filled of Phd working on the language. 
I've had the best luck with the docker container, it takes a while to build it all, but appears to have everything working all in one.
For me the major advantage is the fluidity between IPython and Javascript, mainly for more complex and interactive D3 visualizations. 
Using virtualenv would be handy for stopping those messes in the future;D
The problem with this approach is that it's harder to refactor. Let's say that you have: comment_body, nickname = scrape_comment() Then you decide that you want a more unique identifier like an email. Now you refactored and your function returns still two strings, but their meaning has changed. comment_body, email = scrape_comment() There might be some sneaky code somewhere in your project that should be refactored or deleted as a consequence, but it remained unchanged: comment_body, nickname = scrape_comment() shout_name(nickname) # will skip undetected On the other hand, the code below will throw an error, because that namedtuple no longer has the nickname attribute anymore: comment = scrape_comment() shout_name(comment.nickname) # will throw an error, because it has email attr instead Also, adding any new values to a tuple will force you to refactor your code, otherwise you'll get "too many values to unpack" error. On the other hand, adding, e.g., a date field to the namedtuple will not break the code above.
Well it *is* essentially an academic research project before anything else. It's fully capable of interesting real-world things, but that aspect of its existence doesn't seem to be a primary focus in the community (based on what I've observed as an outsider and what some of my haskelling acquaintances have told me; perhaps I'm mistaken here).
I find it interesting they knew they types of sodas and ingredients people ordered. My local Chipotle doesn't write down anything besides the type of meat and if there's guacamole, and the sodas are just cups and a soft drink fountain.
They know the drink type because the data came from Grubhub, a food delivery service that would need to know what drink you want. 
I wouldn't recommend the new Boston and I don't think a lot of people with teaching experience would either. Bucky frequently under explains. Lpthw is pretty ok. I can't knock it or anything Zeds done. It's free and they cater well to beginners. I don't like his from the ground up style where he teaches you how dictionaries work by kluging one out of lists but to each their own. I personally liked Python for informatics.
&gt; Proper scoping is relatively expensive due to the hash table indirection. (...) &gt; namedtuple requires everything to be accessible from eval, which might &gt; prevent certain optimizations that are performed. Maybe, but you don't tell us where Brython fails with scoping and namedtuple. It's hard to tell if fixing unknown bugs will have any impact on performance ; the only way to know is to report them on the tracker. &gt; currently it seems {1: ..., 1.0: ...} is a valid dictionary Good point, this needs fixing, thanks !
What possible reason would I have for learning more than one package for parsing arguments? I want one and only one way. Docopt is the best.
Thanks for your input! I will change that here in a little bit. For some reason I was thinking it was more Pythonic, so I'm glad you cleared up the confusion for me.
I think the ecosystem has quite a few real world libraries, actually. And the community does feel like its growing. * [Scotty](http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html) is analogous to Flask. You might want to check out [Spock](http://www.spock.li/tutorial/) as well. * [TagSoup](http://neilmitchell.blogspot.com/2008/04/tagsoup-parsing-dictionary-extraction.html) for html parsing * [wreq](http://www.serpentine.com/wreq/) for something requests-like 
concurrent.futures is what would help you
Hey, thanks for this write-up. I dabbled in Haskel for a bit and just learning it has helped my python. I need now to do real work in it as you point out the exact advantages I hoped it had. Looks like your blog is just starting up. I'd gladly subscribe if the content stays as good.
That dude needs to work on his graphs. No axes labeled, no title, and the labels run into each other and create a nearly unreadable mess.
I don't need need to run multiple requests calls at the same time.
I use it already, but what I really need is a way to make an object and all of its methods run in a separate thread, even when methods are invoked from the main thread.
I'm saddened that barbacoa isn't higher up on the list. That stuff makes me weak in the knees.
Maybe it goes with burritos better than the other guys (after coke, which is likely purchased habitually by cola addicts like myself). Either that or the recent ad campaign for Dr. Pepper has been very successful.
Direct link without the blogspam http://www.analyticsvidhya.com/blog/2015/04/pycon-montreal-2015-data-science-talks/
That's just a console, I would prefer an IDE. For example I use RStudio Server for R work. This is actually close to what I do now, tmux and vim and ipython. At least, when I'm doing something more in-depth than I would use the notebook for. But I would prefer a browser-based IDE that contains a terminal and an editor as I still have a long ways to go before I feel comfortable in vim.
Homebrew + virtualenvwrapper 
Will Jupyter have a variable editor and code cells in different languages?! (please say yes, please say yes...) I just saw a post from minrk saying he hope Rodeo takes away some demand for more IDE features in the notebook... Which I don't like at all. 
Depends on what a "lot" of Dr. Pepper means to you. [Someone I know](http://imgur.com/fCkXDsj) has been known to drink a whole 24 pack in 12 hours....
jupyter already supports multiple kernels. if more than one kernel per notebook is planned: idk. and a variable editor is probably not on the table…
have you considerd simply running multiple processes in parallel? Would use more memory, but also all the cores. Will probably be less code/complexity and you can throw as much hardware as you want at it. Personally i use celery a lot to distribute and have tasks processed on multiple workers... i imagine you could have one queue constantly fetching data. Each fetching task spawns off one or more new processing tasks and dies freeing the fetch queue for the next fetch. Processing tasks run undisturbed in their own queue(s). celery allows pretty complex task orchestration...
argparse works the other way round - you define the arguments in code, and it produces a human-readable description when you do `program --help`. I prefer this model to docopt, even if the argparse API is a bit clunky.
&gt; I'm still hoping to get Python 3 support going on Spyder on OS X Isn't it already supported? I used Spyder with Python 3 for quite a while on Linux. I'd be surprised if OS X was much different.
I do tend to agree. I think the data set also lacks a degree richness as well. Even a time stamp and location could provide a few other features to investigate.
What's the rule that says why it is valid? I would have thought that an empty list is a constant, so cannot be assigned to? (Tried in in the Python shell, ir does work.) 
/r/learnpython and /r/learnprogramming will be immensely helpful. I would advise you to do a LOT of *searching* through those two subreddits for posts relating to learning how to break a problem/project down into the necessary parts. Then you can figure out what technologies you need, figure out who is doing what, and each of you can go through the necessary tutorials. Better yet, afterwards you can all teach the others what you know about your part - teaching is a great way to solidify what you've learned.
Thanks a lot! Will do! 
Generalized unpacking, it's pretty awesome 
We're talking about people who choose to eat at Chipotle. If they had any taste at all they wouldn't be there.
OK. This project is doable but a bit messy, because there are several distinct parts. First, are you comfortable with essential programming in Python? (variables, loops, branches, functions, passing parameters, lists, and objects?) You need to have these fundamental ideas out of the way first. Second, do you know anything about databases? A movie database is a notorious first exercise because it requires you to understand data normalization. You can't just store everything in one table and expect it to work. You actually need several tables, which will be joined together, and perhaps a link table or two. Once you understand the data requirements, you'll need to implement them. You can do this with objects, arrays, or SQL code. The most professional way is to use SQL. Python ships with the SQLite library and a relatively easy library for connecting with SQL. Here's a simple example of creating and querying an SQLite database: http://cs.iupui.edu/~aharris/230/python/data/SQLiteDemo3.py This comes from one of my classes. You can see the lecture notes with examples here: http://cs.iupui.edu/~aharris/230/python/data/data.html (SQL stuff starts on slide 28) The next (and least important) aspect is a visual interface. Python ships with a relatively simple interface called TK. It's ugly, but easy to understand and it works pretty well. My complete notes (and audio-walkthroughs) on GUIs in TK are here: http://cs.iupui.edu/~aharris/230/python/GUI-TK/gui.html Note that the embedded audio uses Python 2.7 and I've updated much of the code to use Python 3.4.. The differences are small but critical. I actually have a movie database example written in Python / SQLite, which is running on a server here: http://corsair.cs.iupui.edu:18011/cgi-bin/CGI_DB.py (I'm not showing you the source code because you probably don't need to add a web interface like I did in this example, and I want you to try it on your own.) Try to build this yourself. If you can show that you understand the basics and can connect to a database, I'll send you the SQL code to start your project. Of course, please let your teacher know you're getting help. edit - fixed a broken link to SQL demo
Oh God, a regex for CSV? Part of me wants to see it.
It does mean you have more experience using Wacom. If I wanted opinion on Wacom I'd come to you and not the designer next to you. And I think Google is a force (hence 244upvote post about their styleguide) creating another conflicting style guide creates confusion. Exactly Gambizzle's point.
function() Is **less explicit**, package.module is implied, implicitly. package.module.function() Is the explicit way to say that. No wondering where it came from, has it been overwritten in local namespace, etc. 
 (?&lt;=\"{1})[^"]*(?=\"{1})|[^,"]+ Replace " with the string identifier, and , with the separator.
Not as bad as I imagined. Did it work well?
"Pandas and burritos" - initially I feared this was a horrible new culinary trend until I saw the sub was /r/python. Whew!
i’m only a dev of the [R kernel](https://github.com/IRkernel/IRkernel) (in the future http://irkernel.github.io/)
from large_file_with_config_settings import database_settings 
Oh come on. Chipotle isn't like Taco Bell, they use decent ingredients. I can understand liking another Mexican place more, but if you really think that Chipotle tastes horrible maybe you just don't like burritos that much?
Yeah, I also don't like how they just automatically equate "more calories = not healthy".
concurrent.futures works well with Requests! https://github.com/ross/requests-futures
It worked well enough for my needs. It didn't have a way to handle the string identifier within a string, but I didn't need it for the data I was processing.
The only thing I can think of is range literals, like in MATLAB, so you can have: for i in [0:10:2]: print i Makes sense to me since the slice notation already works for indexing. I believe this was a rejected PEP though.
They say Flask is the better option for APIs because they are a Flask shop and can't have worked with Django/DRF much.
Lesson learned the hard way: don't try and do anything light weight like dashboards with Django. 
You could always use multiprocessing.Process with ZeroMQ for passing messages. That combination worked well for me.
Not yet, unfortunately. I've been trying to help with Carlos, but it looks like there are issues with py2app, which is specifically for building OS X apps, and what he uses to build it.
&gt; Newer, active community https://github.com/django/django/pulse/monthly https://github.com/mitsuhiko/flask/pulse/monthly Newer, but not as active, at least this past month. --- And this is some pretty good company to keep: * Eventbrite * Prezi * Bitbucket * Instagram * Pinterest Not sure why they lead off with Benchmarks, especially when, as they say, you don't pick a Python framework for it's speed.
I think that, if python should steal range literals, they should be like (a..b), although this has the obvious disadvantage, that you can't specify a step. On the other hand you could invent something for a step. The problem with [a:b:c] is that this would need to be an expression but, unlike any other expression in python it could be written directly after another expression (a sequence), slicing it.
I believe they're referring to the case where, e.g.: def split_thing(s): return s[0], s[1:] a, b = split_thing("thing"); Works, but if you start doing 'None', then you get problems: def split_thing(s): if predicate(s): return None return s[0], s[1:] a,b = split_thing("thing") # error, None is not iterable
I dont know if another language does it. But I always wanted to do. obj = dict.get ('key'): obj.blah() So it's kinda like an implicit if conditional I always think obj = dicit.get ('key') if obj: .... Adds an extra line But it may not be an obvious enough operation to be considered pythonic. Edit: imagine there are indents, my phone doesn't like them apparently
It isn't bad food, it is bland food. Taco Bell is outrageously spicy in comparison.
To emulate a range literal, I simply call list() on a range object. Like this... for i in list(range(0, 11, 2)): print(i) That seems to do the job.
Maybe `sentence.replace(wordfind, wordreplace)`? This won't be perfect, such as replacing `"a"` with `"the"` in the sentence `"A message with words containing the letter a"`. You could consider splitting the sentence up into words using `sentence.split(' ')`, but lists don't have a `.replace` method. You would need a for loop like new_sentence_words = [] for word in sentence.split(' '): if word == wordfind: new_sentence_words.append(wordreplace) else: new_sentence_words.append(word) new_sentence = ' '.join(*new_sentence_words) But this uses a couple slightly more advanced techniques. If you haven't learned them in class yet, then don't worry about it, you'll learn them eventually.
For me it would be UFCS or any way to do pipeline programming. I always thought that python was really lacking such powerful way to combine functions. A simple example in D (from http://bitbashing.io/2015/01/26/d-is-like-native-python.html): import std.algorithm, std.stdio, std.range, std.conv; void main() { stdin .byLine .filter!(s =&gt; !s.empty &amp;&amp; s.front != '#’) // Filter with this lambda function .map!(s =&gt; s.to!double) // Map the strings to doubles .array // Sorting needs random access .sort!((a, b) =&gt; a &lt; b) // Another lambda .take(10) // Applyable to any range .writeln; } UFCS is the fact that fun(arg1, arg2, arg2) can also be written arg1.fun(arg2, arg3). Furthermore, in D, fun(arg1) == arg1.fun() == arg1.fun. This simple write change allows one to chain function in a readable way as shown above. Instead of writting fun1(fun2(fun3(fun4(arg)))) you write arg.fun1.fun2.fun3.fun4 This is like shell's pipe: fun1 arg | fun2 | fun3 | fun4 It is reallly useful when using a more functional style. EDIT: the whole "parenthesis are optional" isn't really pythonic, that part may be droped. Also I would be fine with a well-written and standard chaining function: chain(fun1, fun2, fun3, fun4)(arg) which might appear as more pythonic than UFCS. RE-EDIT: Here is a translation of the above snippet in imaginary-python: def main(): sys.stdin.readlines() .filter(lambda s: s and s[0] != "#") .map(float) .list() .sort() .(lamdba l: l[10])() # Do we have a "take" function? .print() 
The first is the same method I used at school, thanks so much for helping me too! 
The reason it's `str.join` is so that you can pass it arbitrary iterators without needing those iterators to also implement `join` or `knit`. And having both `join` and `knit` goes against The Zen of Python.
UFCS can't be implemented in a library as it changes the way functions are called. The easiest way to interpret arg.fun() would maybe be a preprocessing looking for a method of the object arg named fun and, if none is found rewriting it fun(arg). A chaining function could be done in a library, and yes some already exist, but there again a standard implementation would be very interesting.
About to get on a plane but this explains it pretty well- http://www.golang-book.com/10/index.htm
So normally if you want to safely get an object from a dict you have two ways. if 'key' in dict: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;obj = dict['key'] But preferably obj = dict.get('key') The issue with the latter is you still don't know if obj is what you want or None So you need a second test if obj: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;obj.something() What I was suggesting would be to turn the latter into a single test. obj = dict.get('key'): &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;obj.something() It just seems redundant, first test if an object is in the dict if it is return it otherwise None, then we need to test it ourselves. 
Well, we have asyncio and coroutines. Fits most use cases of goroutines. The only place it fails is computation heavy coroutines, in which case you would have to use the threading or multiprocessing functions. I think the idea of splitting them up into different threads automatically like golang does makes things too implicit for my tastes. 
Something to consider if it becomes more complex is tornado, which can hook into the asyncio event loop very easily and is more powerful than aiohttp.
Ah, Finally!!! &gt; It's a tie! Read about Django vs Flask to make your own choice. Damnit.
I have never been to a Chipotle that serves Diet Dr. Pepper.
I expected some kind of horrifying David Cronenberg-esque Panda Express/Chipotle hybrid.
Yeah cool, I like your syntax better. Its clearer. 
I have looked at fn.py and it looks very useful. I am planning on at least making the _ available soonish in ScalaFunctional. Agreed. I don't know anything about D, but the code sample you posted looks similar to using Scala collections. After skimming the ufcs section, it looks very similar to implicits in scala
Probably because of how concise you can be depending on what you're doing. import json from flask import Flask app = Flask(__file__) object = {1: {'name': 'hoodyhoo', 'age':90}, 2: ...} @app.route('/object/&lt;int:object_id&gt;') def get_object(object_id): return json.dumps(objects[object_id]) app.run() Bam. There's an API. It can be easier for many to scratch an API out with Flask than to start a new django project and figure it out. Django is a bit more complex to learn how to set up and get running. If you're not familiar with Django, it's much more intimidating, compared to something like I just wrote there, which actually runs and works in 8 lines. If you're just as efficient with Django, Flask isn't the better option for you unless you know it will be. Personally I like both, but if I want to write something that heavily uses objects that will be saved in sql, and I have a webapp for it too, I'd use DRF. If you have the django webapp up, you get the REST API for free. Why not. However, I certainly use flask for a lot of one-off things, and more, depending on the nature of the data. If I'm only writing a simple API that can use code I already wrote, I'd probably do it in flask. If I don't and won't ever need the webapp, I'd probably use flask.
What problems were you encountering?
But, why not `join(iter, ' ')`. Even that makes more sense to me.
I've always been jealous of blocks from Ruby. Though we don't really need them because functions are first class objects. It would make for some tasty syntactic sugar.
And the second argument could have a default value of `''` (an empty string).
range in Python 3 creates a range object which you can use in a for loop, but it's not a list. If you create a range from 0 to 1000000, a list would take up memory for a million numbers, whereas a range only needs to store the start, stop and step. It calculates the numbers as they're needed.
`a = dict.get('key', None)?.no_none_value()` instantiate dynamic_attribute as None if None `a = obj?.dynamic_attribute` `a = obj?.dynamic_attribute ? None` instantiate dynamic_attribute as 5 if None `a = obj?.dynamic_attribute ? 5` `a = obj?.dynamic_attribute ? obj?.some_property ? 5`
Tornado is also an awesome choice, really simple to get up and running.
or pylons
Better C++ integration ala RCpp
Great work, keep it up! What behind the name?
Sounds like the magrittr package in R.
Steal everything from Haskell that isn't nailed down.
When I was still learning and couldn't remember the syntax exactly... this is what I kept expecting it to be. I'm a single data point, but if that pattern holds, then this certainly passes the "things should do what you expect them to do" test. I dig it. EDIT: To be honest, this is the sort of thing that I might be inclined to make into a convenience function for myself. Except /u/Brian shows that it already exists, and so reinventing it is probably not sensible. Be nice if it didn't need another import, but I'll still probably start using it.
&gt; However, they are both insignificant when compared to frameworks in other languages. The reason to use Django or Flask is to increase dev performance, build faster, and have a "fast enough" framework. IMO that goes for python vs other languages as well.
Generator local variables, analogous to `:let` in Clojure's for. The following generator (func(item) for item in v if func(item) % 2 == 0) Could be written as (x for item in v if x % 2 == 0 let x = func(item)) Today, to avoid calling func twice we can do either xs = (func(item) for item in v) xs = (x for x in xs if x % 2 == 0) or (x for x in (func(item) for item in v) if x % 2 == 0) In Clojure, this is (for [item v :let [x (func item)] :if (even? x)] x)
Troll harder.
I understand what you're getting at, but when you're doing so much in a generator I feel like the complexity negates the conciseness. 
Well, if you know nothing about python, web development, frameworks, web frameworks, WSGI, HTTP, webservers, then just go through as many Django tutorials as you can. Because even though Django's learning curve is actually steeper (because it's bigger, has a lot of complexity, moving parts, etc), you'll be rewarded. With Flask, it's assumed you know what you need, what you are doing and so on.
Also from Clojure: dict unpacking (which they call destructuring, with plenty more options). Say you have a dict representing a tank in a game: {"life": 100, "armor": 20, "position": [134, 32], "weapon": {"name": "BLASTER", "range": 15, "power": 13}} If I wanted to get its x and y positions and weapon range to calculate possible targets, i would do: (x, y), weapon = tank["position"], tank["weapon"] range = weapon["range"] While in Clojure you can deconstruct the map and vectors at once (let [{[x y] :position {range :range} :weapon} tank] (println x y range))
&gt; Flask sounds more challenging I guess I don't know if it really is more challenging. Flask is very small but it gives you almost everything you need to build your site. You can start with a few simple lines which is enough to have a site and you can expand on it as you learn. Need a Database? Just grab SQLAlchemy or whatever you are already Familiar with. With Django, on the other hand, you need to understand a lot of concepts first. There is a reason that the Django tutorial starts with Django's own commands, config files and DB Models. Django is huge in comparison with Flask which can be a bit daunting at first. Of course that means with Django you get Solutions to Questions you need to ask when your site grows more complex and Flask does not, but Flask gives you more freedom when you want to solve these things in a different way. And Flask also lets you ignore these questions until you need to solve them (this might be positive or negative, but for learning purposes it is good). Django is not Hard to learn but Flask isn't either. Both have great beginner and advanced tutorials that don't take long. I would highly recommend anyone to check out both.
Autocurrying. TCO. Recursive lists, i.e. `fibs = 1 : 1 : zipWith (+) fibs (tail fibs)`. Type signatures that are useful but out of the way. I'd give up a finger or two for pattern matching, even if it only worked against built-in types. I'm not sure if being able to define names with arbitrary characters (like &gt;&gt;=) would necessarily go over well, but it'd be interesting. As well as defining fixity and left/right association. Basically my dream language is the unholy child of Python and Haskell. 
How about blockly: https://developers.google.com/blockly/
what if we want the fast start up of Flask with all the power built-in in Django ? We can use ImportD http://importd.readthedocs.org/en/latest/ (the D is for Django) Theres also web2py, with its own ORM and dashboard, that allows remote code editing and more http://www.web2py.com/ There's Pyramid, etc…
Go's go routines and channels. Being able to statically type a variable at programmers option in plain Cpython for both safety and speed. I really miss a compiler yelling at me when I've goofed on a type. Python will just happily run... 
Very cool!
That looks pretty good, I used Scratch in high school and it looks pretty much the same just different color scheme. Would you mind explaining the major differences.
Coming soon to an interview near you.
;) I'm glad there's at least one other python user out there who doesn't find it completely abhorrent!
&gt; light weight like dashboards with Django. Please explain that.
Yeah, I use web2py. At the very least seems like the best framework for beginners.
Coordinating url parameters easily.
if ^elif ^^elif ^^^elif ^^^^elif ^^^^^elif ^^^^^^elif ^^^^^^^elif
looks like 1.0.2 soon followed!
The way I do that is very limited, and certainly not very pythonic. But, it comes in handy sometimes: lines = sys.stdin.readlines() lines = filter(lambda s: s and s[0] != "#") lines = map(float, lines) lines = sorted(lines) lines = lines[:10] print(lines) Kinda crummy, honestly, and it doesn't really work that well for your example because I'd probably just use a generator for most of that, but I do it sometimes when I have transformations and filterings to apply and a generator expression would get too long and unwieldy to do what I want.
I would use the keyword `where` instead of `let` because it reads better. (x for item in v if x % 2 == 0 where x = func(item))
Easy: increment and decrement operators. 
&gt; (x, y), weapon = tank["position"], tank ["weapon"] This already works in Python. The other line doesn't, because `range` is a key into the dict you just unpacked into `weapon`, not `tank` itself. (I'd also suggest avoiding `range` as a variable name, since it shadows the builtin `range`.)
I'm a bit drunk and haven't thought it through very much, but couldn't you just override getattr on a monad to do all this? Like, .list() for example you could implement via putting a getattr on the monad and if it doesn't exist try an eval with self as the argument to the missing method? There'd probably be some serious performance issues, but I don't see why this wouldn't be possible to implement in plain old python. Edit: Woke up, shook off my hangover, and wrote a quick lil' implementation of what I was thinking of. eval wasn't necessary (thank god) due to the `__builtin__` module. It's obviously incomplete, but I think as a POC it stands up. from __future__ import print_function from itertools import islice import sys if sys.version_info[0] == 3: import builtins as __builtin__ else: import __builtin__ def take(n, iterable): return islice(iterable, n) class UFCS(object): def __init__(self, value): self.state = value def __getattr__(self, item): try: func = getattr(__builtin__, item) except AttributeError: func = globals()[item] def curried(*args): if not args: self.state = func(self.state) else: args = list(args) args.append(self.state) self.state = func(*args) return self return curried def get(self): return self.state x = ['#3.462289264065068', '4.283990003510465', '#1.7285949138067824', '#2.6009019446392987', '5.089491698891653', '3.854140130424576', '4.118846086899804', '5.110436429053362', '9.044631493138326', '5.503343391187907', '1.4415742971795897', '2.7162342709197618', '9.438995804377226', '1.8698624486908322', '4.008599242523804', '8.914062382096017', '4.120213633898632', '6.9189185117106975', '3.2290163348295042', '8.593769139268977', '2.9146460120473305', '6.348859785696171', '0.7666771309235598', '5.980375310600611', '3.7083580867229693', '3.2583926830849785', '3.8421660715085535', '9.81088700403593', '#0.14981180379098014', '3.4150968740288423', '5.8886907715711185', '1.6462652061789596', '9.934579695126068', '1.9920319075901671', '2.643597694672245', '7.954718801184532', '4.757597892276175', '1.7778151806600928', '9.280639202899494', '3.8052919687704656', '3.56250958485219', '5.927924956067276', '3.9862865025877325', '0.8065141292445921', '7.351681603859653', '6.9511496455651365', '#8.327067638086112', '9.882676345752381', '9.855978813525525', '#8.863764108300947'] (UFCS(x) .filter(lambda s: s and s[0] != "#") .map(float) .sorted() .take(10) .list() .print() )
c style memory managememt, oh.snap they already did :)
I think you could create and autocurrying decorator, but it would be pretty gnarly.
Wish I could post it but it's all proprietary. Basically I couldn't get easily coordinate url parameters with Pandas data frames for selecting and filtering criteria. Flask was much easier to get up and running. In the end I bailed on them both and started using Shiny. 
[Type Hints - Guido van Rossum - PyCon 2015](https://www.youtube.com/watch?v=2wDvzy6Hgxg)
And reddit!
The issue is, you dont know if obj is defined. 
Oh lord, a good data science IDE a la RStudio. Please, someone, point me in the direction of that. 
Seen [Rodeo](https://github.com/yhat/rodeo)?
Interesting that Flask serves JSON fasterthan Django as the overhead for a bare minimum text request is less for Django in the benchmarks I used. Not that it matters much, the overhead of most application code is much greater.
Static typing and type providers.
Yea, and a good switch could be a lot better because it could make it a syntax error if not all cases of an enum is covered for example.
I wish Python packaging was as nice as Ruby packaging.
There are in python 3. One could imagine supporting any iterable though, so: SOME_CONSTANT = {1, 2, 3} switch SOME_CONSTANT: case 1: etc Would be pretty useful imo.
https://github.com/benoitc/offset
It's useful for defining things like `=&lt;&lt;` which is basically `flip (&gt;&gt;=)`. Scala doesn't let you define fixity though, right? I just started playing with it, but I think I found something that'll scratch that Python-Haskell itch. 
I see what you did ether
I couldn't really imagine how useful it would be for production coding, but I seem to want to use it for scientific computing pretty regularly.
I quite like Elixir's `|&gt;` (pipe) operator, which basically allows you to do the same sort of thing - it puts the expression on the left as the first argument to a function call on the right. It means you don't need UFCS, which I found can occasionally get a bit messy, but retains pretty much all the benefits. So that would look to me like: def main(): (sys.stdin.readlines() |&gt; filter(lambda s: s and s[0] != '#') |&gt; map(float) |&gt; list() |&gt; sorted() |&gt; (lambda x: x[10:])() # There's a takewhile, but no take I don't think :/ |&gt; print()) Where the parens around the whole expression are necessary to tell the interpreter that this is all one expression and the indents are simply for readability. That said, this could probably be turned into a function fairly easily - the only difficulty would be cases where the function needs an argument as well as the one that's being passed in (the map to floats, for example). def main(): pipe(sys.stdin.readlines(), (filter, (lambda s: s and s[0] != '#')), # use a tuple to represent a function and its arguments (map, float), list, # if it isn't a tuple, assume it's a callable sorted, (lambda x: x[10:]), print) Not quite as elegant or aesthetically pleasing, but that should work fairly well.
I quite like using decorators for this sort of task. It doesn't work in all cases, it's not like you can just define a "setinterval" callback on the fly as you can in JS, but for things like Flask where you're defining callbacks for various known inputs I think it works quite well. Although I guess you're still defining functions even then.
``switch...case`` is probably the most hated feature ever for me in OO langauges! So many programmers missuse this instead of using polymorph types! Pattern matching is a different thin imho - that is much more powerfull than the simple ``switch`` we know from C, C++, C# and Java. No, I would not like to see such a mess in Python!
I realise which sub we're in, but it may be worth noting Ruby is close to Python and has excellent pattern matching as well as native map, reduce, select, lambdas etc
It's already answered. But when all else fails, read in from a file.
From the comment section on the website of Juice Box &gt;Left out Python 3 because I'm still not sure what a good setup would be regarding virtualenvwrapper and both versions installed. Example: Want to create a virtualenv for 2.7 or 3.3. Any ideas are welcome. 
&gt; I was searching online and someone suggesting going on 'My Computer - Properties - Advanced - Environmental Variables' and changing the PYTHONPATH there. There was no PYTHONPATH [...] PYTHONPATH is the environment variable Python uses; it has the same format as the PATH variable. Adding your directory to PATH does't help, you need to create PYTHONPATH if it does not already exist. 
This is how I impelented my routing logic in the IRC not I built. I really like this way of doing case matching and have used it again in a skunkworks project at work where I allow other devs to write/submit plugins to my API and the plugins expose new endpoints. The endpoints are looked up via a dictionary so I only have to pass a dict up yo the framework and the framework can do the endpoint verification. 
I'm confused. In the first example, why/how would Python skip the explicit f.close if there's an error in f.read? 
Functional programming elements. For example, in matlab I can define my own custom math function, say a custom cos function as an object. I can then call that object like how you would call a math function.
&gt; Recursive lists would necessitate tail call optimisation though, and Guido would never scratch his tracebacks in favour of functional programming. [This](https://mail.python.org/pipermail//python-ideas/2014-January/024934.html) thread from the Python ideas mailing list last year gave me hope that TCO might eventually appear in the form of `return from`. David Mertz commented [that](https://mail.python.org/pipermail//python-ideas/2014-January/025002.html), "*I was mostly disliking the idea of TCO during this discussion. However, the idiom of 'return from' seems sufficiently elegant and explicit -- and has exactly the semantics you'd expect from 'yield from' -- that I am actually +1 on that idea.* *Being an explicit construct, it definitely becomes a case of "consenting adults" not of implicit magic.*" I think that because `return from`, if added to the language, would allow the programmer to explicitly opt-in to TCO, this might persuade Guido to review his position on the subject. 
How is this better/different from https://github.com/lionheart/python-harvest ?
I really felt like this worksheet didn't help anyone at all to choose the right framework. Bottom line, if you want to figure out which framework is best for you, make a 5 page website with templates using each of the major frameworks. Don't just stop at flask and django, there's others like web2py, pyramid, and more. By that point, you should know easily which framework is for you. 
I had more problems with npm than I did with pip. Sometimes it installs in the current directory and sometimes in the home and if you use sudo and the g flag it ends up in /usr. And if you do both because different people tell you different things you get weird errors that don't make sense because of dependency. I just want to install stylus and use the goddamn command and have it in my path!
WOW, thank you! &gt; Sends this link to everyone i know
yeah that was my strategy as well. :D try it in the shell. sadly I do not know why thats a valid statement. 
I've, been playing around with lisp and now I sort of want to switch to Ruby as my main webdev launge
[Image](http://imgs.xkcd.com/comics/haskell.png) **Title:** Haskell **Title-text:** The problem with Haskell is that it's a language built on lazy evaluation and nobody's actually called for it. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1312#Explanation) **Stats:** This comic has been referenced 40 times, representing 0.0653% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cqo9u66)
That's pretty much the way to go. There's some things that don't fit well into this pattern, but we're probably better off using if/elif/else in that case. 
None, if anything Python should drop language features. [PEP-3102](https://www.python.org/dev/peps/pep-3102/) and [PEP-3132](https://www.python.org/dev/peps/pep-3132/) seem like excellent candidates for removal. Are they useful? Probably to some people. Is it worth the added cognitive overhead and line noise? I would argue they're not. Now Python does need runtime features of other languages: a JIT (and not as a rarely used alternative implementation) and asynchronous IO throughout the stdlib (not just in one or two modules).
If you get this question in an interview, you'd have to reference the Zodiac and the type of Sign that would ask such a question. Then throw in something about Jupiter rising to get to the date. Because if they're going to ask a stupid question, they deserve a stupid answer.
If there's an error, python will raise an exception, which means it'll immediately stop executing the rest of the function so that close line never gets executed. The control flow instead goes to the first `try:`/`except:` clause that encloses the code (or the function that calls it) The only way it'll get closed is via the destructor of the file object when it goes out of scope, which might not happen in the right place (even in cpython, which destroys it as soon as the last reference goes away - in pypy / jython / ironpython there will be a further delay). To get it to happen even when an error occurs, you'd need to either catch the exception, close it in the `except:` branch, and rethrow it, do the same in a `finally` clause, or (best of all) use the `with` statement.
In this case the amount of activity could be explained by the sheer simplicity of Flask - it is very simple and intuitive, it just works. As such, there is not much to talk about.
This is another one of Perl's gifts to the world
At the beginner level, python 2 and 3 are not the very different. The main differences are that in 3 you have to use parentheses with the print function -- print('Hello world') -- and raw_input is changed to input. You could just study a python 2 course and make those changes. 
This is correct. Manually editing your PYTHONPATH is setting yourself up for future frustration. Been there done that. Use virtualenv.
So he removed it as a builtin, why does that matter? Just import it.
Can you explain a bit more? What is a polymorphy type and what is the correct case (pun intended) for using switch?
I've only used it in a paid position for webdev, and it really is lovely. There's very little 'obstruction'. If you want to do something simple it's very easy to write clean and testable code to do it. If you want to do something more complex, like spam filtering or pagination then there's often a great open source library to do so. It really is a joy to work with.
I found this to be extremely long winded for such a simple exercise. 
What would your solution look like?
Can I ask when do the differences start to show? The most trouble I can remember having between the two was the encoding of text I was parsing into a database.
How comparable is sinatria to flask?
They're the same type of framework AFAIK, in that they're skinnier and leave more up to you then their more bloated and "magical" counterparts (Django, Rails). Though personally, I couldn't really comment as I've only worked under Rails.
reddit [uses pylons]( https://github.com/reddit/reddit/blob/master/r2/setup.py).
I'm used to the switch/case from php, which I understand is pretty similar. I'm a novice programmer, and love python, but this is one of those things I think is much easier to read and better than if.. Elif.. Elif.. Elif.. Else. 
Simpler answer would be that Cheryl isn't getting a party or presents if she acts like this.
Would this unholy child be compiled or interpreted? I've always dreamed of having an interpreted language which can easily be compiled for distribution or speed.
The same reason I also write a lot of C. Libraries!
&gt; It's how easy to do things that defines the nature of a programming language Yes and that competes with the Python philosophy of there should be one obvious way to do things. It's like saying base Python should implement static types for doing integer/floating point computations quickly like other languages (e.g. Matlab) do. It's a single import away though, so why stress about it 6 years later? It's like asking why Microsoft changed to the ribbon interface in 2003. They found almost nobody used 90% of their UI, so they reworked it. It's the same thing.
Have you had a look at Julia? It's still quite young but is heading towards something like that. It's not a Python/Haskell hybrid though.
Well, that explains that. I must have missed that when I was looking at the page.
Right, I've heard of virtual environment before but haven't come across it yet in the tutorial. It appears that Anaconda has its own tool for managing virtual envs called conda. I'll have to check the tutorial for using that once I finish the main python one. Thanks a lot for the help. 
Also, I just realised I posted this in the wrong subreddit, I thought I was on /r/learnpython but turns out I was using the wrong tab. Sorry.
In case you weren't paying attention to the author or URL, this was written by [Peter Norvig](http://en.wikipedia.org/wiki/Peter_Norvig). Co-author (with Russell) of the [leading AI textbook](http://en.wikipedia.org/wiki/Artificial_Intelligence:_A_Modern_Approach), one of the directors of research at Google; co-instructors (with Thrun creator of udacity) for the first MOOC on AI (which was one of the first MOOCs) that ended up on [udacity](https://www.udacity.com/course/intro-to-artificial-intelligence--cs271).
It is an amazing feeling. Even many years out of school, I still get it.
Don't think of it as "FP vs. OOP vs. procedural", think of it as "declarative vs. imperative." Declarative code is much nicer and shorter to read and write. It reads more like a human giving a computer details about the result they want (at least in a language that doesn't use symbols and sigils instead of keywords, so Haskell may not count here), rather than an algorithmic series of steps. And it's a lot easier to write declarative code in a functional language than a non-functional one.
Yeah, true. 
Congrats!
Also aren't case switches implemented as a binary search? Yes, they are. Only downside is that you can't do things like elif hashlib.md5(x).startswith("aa"): only basic string comparisons. I can't think of a case where you would need to be able to evaluate it though. So performance would be O(log n) instead of O(n). But you may need to rethink things if you are writing elif chains long enough for that to matter. 
What is this finishing projects of which you speak? Only things that I can say are finished are things like project euler challenges. And even in that case, I can always try to make it even quicker. Problem 7 is great for optimisation. There is the obvious solution, but that takes around 20 minutes to complete on my machine.
Haskell and Scala both have REPLs but are compiled languages. Technically, Python compiles. No reason you couldn't have both. 
this. it's a very very unsettling feeling. and it haunts you.
I could try, but there are so many people, who allready did that. So I just give you a link: http://c2.com/cgi/wiki?SwitchStatementsSmell 😉 And I meant of course "polymorph**ic**"...
Do you tried prime sieves?
No wrapper for HORIZONS? I only ask because I had a project a few months ago that used Horizons extensively.
There is a comprehensive list of major changes from Python 2 to 3, shown here: https://docs.python.org/3.0/whatsnew/3.0.html
really classy.
There are a lot of great texts out there for Python 3. Personally, for someone new to programming, I think the 'How to think Like A Computer Scientist' http://openbookproject.net/thinkcs/python/english3e/ and then moving onto something like 'Dive Into Python 3'. Mostly because learning the language is easy but learning the concepts and problem solving can be more difficult. It will make learning languages like C++ much easier later on. 
Very much this. I write tests for other software and even after releasing there is always that feeling of "Did I do enough?".
I could not found any example showing rendered output, can you give me an hint?
What is the problem you are trying to solve?
Also libraries that got renamed will usually have a notice on the top of the python 2 docs, along the lines of "please note, in python 3 this was renamed from SimpleHTTPServer to http.server. The 2to3 tool will convert this automatically." 
&gt; Make it work!!!
A nice compromise is: str.join(' ', my_list)
Yeah, I just want sickrage to copy a file after it has finished post processing. Apparently it even gives you the arguments in a nice little array after it finishes, but I haven't got a clue on how to work this python business. I dont even need the date checking guff to be quite honest, I just want it to deposit a carboncopy of any and all file it processes to a dump folder. &gt; Parameters that are passed: &gt; &gt; sys.argv[0]: Filepath to Script &gt; &gt; sys.argv[1]: Final full path to the episode file &gt; &gt; sys.argv[2]: Original full path of the episode file &gt; &gt; sys.argv[3]: Show indexer ID &gt; &gt; sys.argv[4]: Season number &gt; &gt; sys.argv[5]: Episode number &gt; &gt; sys.argv[6]: Episode Air Date I suppose all it has to do is make a copy of whatever sys.argv[1] points to, right?
Well apparently it already works, just not for windows. And its not like I didn't try looking it up. I was just hoping a kind stranger could get it switched over so I wont have to waste a month learning how to fix 10 lines of code in a language ill never use again. I'm pretty sure a stupid batch file could do the trick, but I'm stuck with python.
Jesus, Euler #2 in Scala vs Python: object Solution { val fib: Stream[Long] = { def fibs(h: Long, n: Long): Stream[Long] = h #:: fibs(h, n+h) fibs(0, 1) } def main(args: Array[String]) = { val solution = fib.view.takeWhile( _ &lt; 4000000).filter( _ % 2 == 0).sum println(solution) } } vs... def fib(): a, b = 0, 1 while True: yield a+b a, b = b, a+b even_fibs = (f for f in fibs() if not f % 2) solution = sum((f for f in even_fibs if f &lt; 4000000)) print(solution) Discounting what I consider the noise of wrapping in an object (wouldn't run if I used class, am I doing something wrong -- or is this even needed?), it's the same number of lines, but the logic is just so much more concentrated. Here's the Haskell for comparison: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) solution = sum $ takeWhile (&lt;4000000) $ filter even fibs print(solution) Hard to beat that.
You need to cd to the directory. (with("cd ....."))
Ah gotcha. Yes, I much prefer Ruby's regex easy syntax to Python's.
This is one main reason, in many agile development processes, you have small achievable goals - not only its better for risk amelioration, but it also helps keep developer and team motivation high. A sense of accomplishment, even if somewhat arbitrarily defined, really can help keep momentum going for the long haul.
This is why my projects often break down to smaller problems so I can fix all of these and get the feeling of it's done.
The [first blog article](http://www.mos6581.org/introducing-rinohtype) links to some example PDFs. The [first one](http://www.mos6581.org/files/intro_template.pdf) illustrates most of the features such as columns, table of contents, tables, footnotes etc. Much has improved since I wrote that article, but not the style sheet, so ignore styling for the moment.
I honestly don't remember that well. It was originally called dev-box. We started thinking about better names... *insert 10 other ridiculous names here* and after a while we ended up with this one.
Isn't that all he needs to do? Set some params and he's off?
Python is cross platform, and this script should work fine on Windows. Did you follow the directions the poster gave you? Do you have Python installed on your computer? Tell us what exactly you tried and what happened in response.
Norvig's other course "Design of Computer Programs" on Udacity is a gem. I think it's quite a rare resource to learn form in that it shows you how a true programming master thinks about solving problems. I felt good going through it and completing each exercise only for the next video having him be like "Here's how I would have solved it..." where he then goes on to blow my mind.
Sometimes I lie awake at night wondering, "Will the users notice how broken it is, or are they too stupid?"
things you do for school are usually small, simple and not very relevant eventually you will realize that software development is continuous, as long as that software solves a real life problem and isn't just a sterile homework assignment and you will learn to feel better everytime you tag a revision as stable version and release it :)
How stable is hylang?
Unfinished projects is why we have jobs. Lots to improve, lots to fix, etc. 
"complete"... You 'avin' a giggle mate? :) 
Make one that scans free Craigslist titles for user-input key words and then send an email or SMS to the user when the keyword is found. Great way to get a free BBQ or whatever without sitting there all day waiting. 
typical Cheryl
&gt; where he then goes on to blow my mind. everytime! It's one hell of a course everyone should do
Let me rephrase that. I was trying it out locally on code that's currently in production lol.
&gt; I'm not sure if being able to define names with arbitrary characters (like &gt;&gt;=) would necessarily go over well, but it'd be interesting. No. It would be shit.
Hey man, I really like your site. I think it works pretty darn well. Have you thought about getting a job in the industry?
A fuel economy tool. Accept input of petrol pumped, milage of car, date etc. to calc kms per litre. graph that shit up and you'll be looking at an A!
Bugs fixed (hopefully), still no impact on performance, despite changes in dictionary implementation. Bug reports like yours help improve the project and move towards yet more compatibility with Python. Note that in his talk at Pycon 2015, Ryan placed Brython in the zone "good web-ish-ness / good compatibility". It's compatible enough to run complex programs such as unittest (which pypy.js fails to import for the moment, by the way). Nice to see the tests you made with a different program. I couldn't reproduce them because the name "vm" is not available in the pypy.js console : does it have to be imported ? It's strange that pypy.js runs 10x slower in the global namespace than inside a function : is there a way to improve this ? I don't see these results as a massive argument in favour of pypy.js speed. In the real world, applications are not wrapped in a function : running in the global namespace is not "artificial", it's more realistic. Moreover, in web programming (which is what Brython is about) the user wants to get a result when the page is loaded, so I don't see the advantage of running faster the n-th time the program is executed.
A shared deque between two threads? You do need a control plane between the main thread and the two worker threads so you can cleanly stop the threads. That is usually hard to wire up, but you could just set a flag self.stopped on the threads and check on your producer/consumer loops whether this flag is set. Make sure to exhaust the deque in your consumer thread so that no items are left unprocessed.
Brython is a beautiful attemps, but will NEVER be Python. First, it runs on a implicit event loop. Seconds, it doesn't have one tenth of the stdlib available. Third, you need to load it (adds a lot of overhead), and then load throught the network each dependancies.It's not Python embeded in the browser, it's a close copy cat written in JS. For small projects it feels the same, but for big project, it's not. Plus, like all JS preprocessor, you pay a performance penalty. You can mitigate it by transpiling on the server, but then you need to add the tooling to your stack. And teach everybody how to use it. And document it. And support it. And of course you need a source map for debugging. It's terrible. I hate JS, but I'll stick to it if this is the only alternative. Not to mention it's still full of bugs and differences with the mature Python implementations.
I created the files as told, changed the destination folder, changed the date to 1014 instead of 2014 (id rather just tear that date check out but I dont know how), and then I just ran it. This is what it throws back: Executing command [u'C:\\Python27\\pythonw.exe', 'C:\\SickRage\\PPcopy\\file_copy.py', u'F:\\Anime\\Your Lie in April\\Your Lie in April - 01x22 - 022 - Spring Breeze.mkv', u'D:\\Complete\\Postprocessing\\Your.lie.in.April.S01E22.720p.WEBRip.x264-ANiHLS\\anihls-ylia.s01e22.720p.webrip.mkv', '279830', '1', '22', '2015-03-20'] Script result: File "C:\SickRage\PPcopy\file_copy.py", line 9 pid = subprocess.Popen(['nohup', os.path.join(os.path.dirname(__file__),'file_copy_main.py',sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5],sys.argv[6]], ^ SyntaxError: invalid syntax 
You can get mic input by running `pacat` with `subprocess.Popen` setting the `stdout` argument to `subprocess.PIPE` and then reading from the process' pipe (make sure to read the appropriate number of bytes based on the selected sample rate, number of channels, and bit depth), then using numpy to turn these read chunks into the appropriate numeric arrays. Then you can go wild with processing. Note that Python will be slow for this, even if you use numpy and other forms of accelerated processing. Consider Go for this instead (depends really on what libraries you will use for screen output and mathematical computations).
"Complete"
no project worth doing, ever finishes
Its funny actually. Lots of people come to me for technical help for diverse reasons and lately I've been answering google forms for a **lot** of stuff. Basically all a webapp is is *forms*. User input stuff and website returns stuff based on input. Google Drive handles 2/3 of the job-- the forms and the database (spreadsheet automatically filled with data from forms). And you can set ip up in minutes! Now, for OP's question in particular; he doesn't need a whole web app so I think this repsonds quite well to his specs.
in your solution you can start only check odd numbers because every even number % 2 == 0 :D 
/r/learnpython Anyway, I suppose your `or` should be an `and`. Clearly, no matter what `FileReadorWrite` is, it is definitely not equal to *both* `"read"` and `"write"` at the same time. A more natural way to write the same thing: # In camelcase, capitalise every word (except possibly the first) # That includes 'or'; it's not the same as title case def ReadOrWrite(): # I like to strip and lower immediately # Stripping avoids whitespace problems choice = input("Read or write?").strip().lower() if choice not in ["read", "write"]: ReadOrWrite()
It looks like you forgot to add a `)`.
Something fucky is going on and I have no bloody idea what the problem is. Heres the actual script it say it has a problem with; import subprocess import os import os.path import sys def main(): pid = subprocess.Popen(['nohup', os.path.join(os.path.dirname(__file__),'file_copy_main.py',sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5],sys.argv[6]], stdout = open(os.devnull, 'w+', 0), stderr = subprocess.STDOUT ).pid print pid if __name__ == "__main__": main() sys.exit()
No, it doesn't. It says "parameters that are passed", that's it. How are they passed and where do they come from? I have yet to find a definitive answer to those crucial questions in any of the sources you've shown us so far. If you look at the code of the [first link you posted](https://sickrage.tv/forums/forum/help-support/general-support/22282-postprocessing-script-that-will-save-a-duplicate) we can indeed see `file_copy.py` calling `file_copy_main.py` via `subprocess.Popen`, and indeed the **previously supplied command line parameters** are passed along, but — they have to come from somewhere, you know? Like I've said, we haven't seen yet how exactly that should work, but you might just try supplying them yourself to `file_copy.py` and see if that does something. From my understanding of this situation it should!
Bugs are coming !
&gt; I dont know where its coming from, its a python program called Sickrage, thats all I know. Haha, but see, there you already know more about it than me — I don't use that script! &gt; Cant you just assume the variables are there and go with it? Well, no. It's not working, is it? So then you have to throw your assumptions out the window and figure out what's wrong…
OK, no clue. I can only deduce from what I've seen and that's what I did. Good luck debugging!
The editor should be really usable, it does many things like autocompletion (using Jedi) and pyflakes checking. Have a look at the Github page. Feedback is very much appreciated.
It would be nice if you could disclose the reason of suspecting missing variables though?
Yes, I think it might be missing after `sys.argv[6]]`, so the code should read `sys.argv[6]]),`.
Just because I never saw them being passed anywhere. But nevermind, I now saw that you posted the actual [error message](http://www.reddit.com/r/Python/comments/33v1s9/im_so_hopelessly_lost/cqp0qvw) and, clearly, the args are there! However, as [/u/robin-gvx](http://www.reddit.com/user/robin-gvx) pointed out, it looks as though you need to add a closing parenthesis, see [my comment](http://www.reddit.com/r/Python/comments/33v1s9/im_so_hopelessly_lost/cqp3qo9).
If it's not concise enough to write with an inline generator: (j for j in (funk(i) for i in v) if not j%2) It probably shouldn't be a oneliner anyway.
I'm going to check that out, thanks!
The script looks like it is written for python 2. You are probably using python 3. Either use python 2 (comes with most linux OSs) or upgrade the script to work with python 3. Edit: To fix syntax errors you could probably just add parentheses around the `print` parameters, this `print("Hello")`.
**ATTENTION READERS** I seem to have cobbled together a script that works the way I wanted it to. I have dumped the code in the body of the original post so others may see. Its laughably simple, and im not sure why the other guy used two scripts to do it.
The double backslashes could be causing the problem here. I dunno, dude, and I'm not super interested in this, as it absolutely doesn't concern me. I wrote exactly where I think the closing paren should go, just check my comment. Good luck!
Sounds like an ambitious project! I would like to reccomend you check out the web2py framework. It comes with everything built in so IMO for a one man shop it reduces friction of development. When I say "everything" I mean it. It includes a browser based IDE and debugger w/ interactive REPL. Additionally it supports just about every database out there, I know because I have personally patched some bugs with more esoteric setups. http://web2py.com/
Wow oh wow, this is so cool! I am very limited in my knowledge of terminal functions, so I'm blown away. I'm a part time windows users, I'll be playing with it, I'll update the issue tracker with any bugs I find!
I love flask but if it's really just simple forms and CRUD then something like django might be easier 
&gt; Further, when the project develops, it should also become possible to write extensions in Python, and use Python as a scripting language. (Instead of vimscript, for instance.) Above is from the readme. But I don't totally agree. Working vimscript support would make it a viable replacement for vim, automatically filling a ton of gaps until more sanely coded things can be written.
Exactly. I'm sure OP learned some great stuff and sharpened his skills building this.
vim plugins can already be written in whatever language they want, no?
Consider implementing the neovim API, perhaps? See if you can get it to run in a [GUI](https://github.com/equalsraf/neovim-qt).
It's easier to go with python 2, as daveydave400 suggested. There are some things preventing it from working correctly with python 3, besides the parenthesis around the print strings. You also need pycrypto. On windows it can be a pain to install with the python package manager, but you can download a binary for your python version here: http://www.voidspace.org.uk/python/modules.shtml#pycrypto
It's in the post: https://github.com/jonathanslenders/pyvim#why-did-i-create-pyvim
I don't really know. Daily, it is very stable, but they didn't reach v1 so we can't consider it stable I guess.
lol this is why I had such a hard time getting real practice with programming :) whenever I came up with a problem that I thought I could code my way out of....someone comes along and reminds me to take a step back and see the problem could be solved 100x easier. This is a great suggestion and I appreciate it. I may still tackle this proj for something to add to my git, however, I think a simple web app or google forms should save the day here.
Yeah, it definitely was a project itself...took about two weeks to figure out how to do it. The data collection takes about two days and the clustering itself takes up to an hour (i7-3770) depending on how many genres you want to use.
Why bother with a merge? * Both projects are are awesome. * The code bases are immensely different (PEP8 vs CamelCase for starters), enough that a merge would take an enormous amount of work. * Sometimes it is good to reinvent the wheel, if for no other reason then to see how the wheel is made. * Competition is good. Look at Python and the Web. Zope used to rule and then lighter frameworks emerged. * Just because the projects are separate doesn't mean they can't inspire each other. For what it's worth, Cookiecutter received no less than 5 requests to merge with other templating packages, three of them opened as formal issues on the project. None of the other packages shared anything like its architecture (functions-only) or design goals (runs everywhere, including windows).
Or I could just write an alias for pyvim to whatever I want?
truth is, I am not sure you want to make an IDE user friendly by being already user unfriendly to begin with.
I wasn't inferring vai is a bad name or anything but just pointing out that pyvim by having a more descriptive, if less original, name will naturally have invited more clicks.
... I don't think the userfriendliness of an IDE should simply be judged on the name/number of keystrokes used to launch it from the command line. 
It's a neat consideration, IMO. Not in this specific case, as nobody's going to know what the fuck "vai" is, but in general. 
&gt; Why do we need another viable replacement for vim? Isn't neovim aiming for that? I don't know. These are questions for the author of this project. But if that's what he's doing way not play to win? &gt; Wouldn't an API designed to be used by Python scripts be different that just the ability to write a plugin in any language? I think you've misunderstood me. I am not saying python scripts/extensions are a bad idea. I am saying vimscript support is necessary if you're serious about competing with vim (as this involves winning vim users over from vim). That being said -- from what I understand Bram Moolenaar maintains tight control over the architecture. It seems like a good opportunity to build a modern hackable alternative. To be honest, if I could use this without much headache I probably would.
How do you feel about instead applying for moderator and then delete the posts and send them to /r/learnprogramming or /r/learnpython ? 
[Data Structures and Algorithms in Python](http://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275) has been fairly decent so for. You may want to check out /r/learnpython though and ask this question over there for more answers. 
That's just mean... it's very hard to be placed in a coding class and *not* actually be interested in the subject, from what (little) I've seen. Be a good citizen and just say "this doesn't belong here." I'm saying this as someone relatively new to programming with python being my first real language, so maybe you're better capturing the community here, but I know for a fact that would totally turn me down and crush me if I got caught for cheating by asking for help on the internet. 
Whoa whoa, I didn't sign up for that.
 #4 may not be totally unrelated to #2.
Then come help me and we make it pep8 compliant. [There's an issue about it](https://github.com/stefanoborini/vai/issues/98). If you agree, we can make it fully PEP8 for 1.8 or 1.9, and in the process you will learn so much about the codebase that you will be able to move on to other things. 
Well I can understand your point but, let me be clear, It would be your own fault for cheating at something. I'll always support the notion of do something you love, not something you don't. If I turned you away from a language you didn't like or wasn't interested in, i'm glad I did it now and not in a few years after you've sunk more time into it. At the same time, we are giving the answer to the user, although a little more complicated than it should be.
Just do what I do, give them the wrong answer. I'm not an asshole, I'm just sloppy.
&gt; Zope Man, no wonder lighter things took over. Even the [tutorial](http://docs.zope.org/zope2/zdgbook/GettingStarted.html#introduction) bombards you with stuff. Django gets you going pretty quick, compared to this.
You know your framework is way too heavy when people are citing Django as a lighter alternative. (P.S. I love Django, but often find myself using Flask these days instead for projects where I don't need so many bells and whistles.)
I just use PyCharm.
This.
Saw this book on Amazon recently. I will buy it because I buy all the things. Based on the author's stated goals and motivations, I do think there is room for this kind of book although, in general, it feels like the "first book on data science" field is reaching full on froth mode. So hopefully it does contribute something different.
I don't know about the author of pyvim, but [I can give you the motivations for vai](https://github.com/stefanoborini/vai/blob/master/RATIONALE.rst)
I mean. what the fuck! I am working on vai since a year and a half in my spare time, nobody gave a shit about it or slapped me with a "use neovim" despite multiple attempts to promote it, and now this guy comes in and rakes 350 stars on github in one day and the only _important_ feature it has it's that it has the most trivial name ever?? That makes me really pleased to develop opensource software... 
Auto complete also is not 100% in PyCharm, this is because Python is not a strongly-typed language. It is down at the interpreter level, but for IDE's they have to pretty much make a best guess at it. There is talk about putting type hinting (https://www.youtube.com/watch?v=2wDvzy6Hgxg) into Python, but that requires self dispassion to write and isn't really always needed, it's more there for some edge cases, though in the future this could help improve hinting in the IDEs. One aspect you should consider is that being dependant on type hinting in the IDE has some big pit falls. Essentially it can make you into a multiple choice developer, a trial and error coder, etc. That is where you don't really learn the language well enough to just write it in notepad. Over the long run this can really slow you down, but in the short term, learning the language can help. When you need to ssh into a remote machine and nano your code, you don't have the luxury of the IDE and type hinting. As for Pycharm being big, I presume you mean feature wise and not disk space. Well having interactive debuggers in the PyCharm ide is really nice and if you start working with frameworks like django, it can really help in some aspects. Sublime can be well configured, checkout something like https://realpython.com/blog/python/setting-up-sublime-text-3-for-full-stack-python-development/ also I think from what I've heard Anaconda is recommended over JEDIPython, but I'm not sure of the reasons. I use sublime myself, but without any Python packages. Vim also has great python support and personally I need to look into it more, as I've been working more and more in ssh sessions and having a good featured text editor would really be beneficial to me and I've seen some VIM configurations that would work pretty well for what I need. As with most things in life though, if you don't try them, you'll never know, so give PyCharm ago, give Anaconda a go, try out vim and see which one you like best.
Or you could reply without giving them the answer? E.g. Point them in the direction of a function or module that would help them. That way they learn for themselves (both in terms of discovering the answer themselves, and learning where and what to search for when they encounter future problems). If they just want the answer without trying? Yeah stuff that.
Is it outdated ?
thanks
I thought I was in that subreddit. Thanks and sorry!
question: when you've supported vi keybindings (and modal interface) etc, you've already supported more than half of vimscript? (or all of it?) and that's why whenever someone creates a vim clone, it's inevitable to support some or all fo vimscript? For some reason, this is more like a clash of keybinding interface vs programmatic interface. In a text editor you have to support both. I think (no flaming) emacs does it right when there is a programmatic (elisp) command behind every key-binding/operation (AFAIK). Maybe this should be done in a python vim clone? (a python function behind every operation?), and then python scriptability would emerge naturally from that?
Why be a dick?
Write unit tests for your new company's code. You'll learn their code, you'll come up against stuff you don't yet understand, and you'll make their code more maintainable. Maybe it's just me, but I've always found that reading/watching blow millions of goats compared to actually doing something. I read all of [this](http://www.amazon.co.uk/Pro-NET-Framework-Experts-Voice/dp/1430242337/ref=sr_1_1?ie=UTF8&amp;qid=1430082043&amp;sr=8-1&amp;keywords=c%23+pro), and I'm still not confident in C#, for instance.
I've been working on that today. I've expanded it quite a bit (more methods) and have been writing tests. I'm working on some speed optimizations to avoid the try/except via a one-time `globals()` key set extraction on the class, etc. I imagine I'll probably have the lib done by next week; it's been a lot of fun! 
Almost all production code is written in 2.7. When a job is looking for a python programmer 2.7.x is typically what they are looking for unless they specifically ask for python 3 expertise. In general, python 3 is easier to write than 2.7.x because of its sensible decisions around unicode, but its so similar that I think you'll find it trivial to pick up if you are proficient in 2.7.x. In fact its similarity is its curse. Its so similar that most people just haven't found a good enough reason to upgrade.
I don't think it's only the name (as some people indicated above), but also the general description of the projects. Vai: &gt; We love vim, but we want more. We want a terminal-based IDE that looks like vim, handles like vim, but has all those nice features of Eclipse and Sublime, is integrated with git, and is fully coded in python. I don't really want an IDE, so this project doesn't sound like something I would be interested in. Also, this guy wants to reimplement vim in Python while adding more features? Doesn't sound very realistic. pyvim: &gt; *A Vi clone in Python.* Woah, someone wrote a Vi clone in Python? It's most likely not going to replace vim for me, but that's pretty cool - I might as well star it and take a look at the code later. Also, in [another reply](http://www.reddit.com/r/Python/comments/33wvc9/pyvim_a_vim_clone_in_pure_python/cqpis4d) you sound pretty desperate for attention. I can certainly understand that your situation is frustrating, but I would encourage you to change your mindset - you should develop vai because it's something *you* want, because *you* want to take on the challenge, and ultimately, because *you* find it fun. If it turns into something good and useful then it'll likely become more popular.
Sounds more like a "right" to cheat. It doesn't impair learning in any way, since seeking an already made solution would affect learning, if not prevent it out right anyway. I think wrapped with the appropriate advise for how to learn it, it sounds like karma doing its job.
PyRedditors: please help me by ``pip install plock`` and giving Plock a whirl (even if you are not familiar with and/or interested in using Plone). I am trying to make Plone appealing to non-Python folk as we prepare for the upcoming Plone 5 release. Thank you!
This post has been removed. Please feel welcome to repost over on /r/learnpython 
Here's the table of contents from O'Reilly's site for anyone interested: Chapter 1 - Introduction The Ascendance of Data What Is Data Science? Motivating Hypothetical: DataSciencester Chapter 2 - A Crash Course in Python The Basics The Not-So-Basics For Further Exploration Chapter 3 - Visualizing Data matplotlib Bar Charts Line Charts Scatterplots For Further Exploration Chapter 4 - Linear Algebra Vectors Matrices For Further Exploration Chapter 5 - Statistics Describing a Single Set of Data Correlation Simpson’s Paradox Some Other Correlational Caveats Correlation and Causation For Further Exploration Chapter 6 - Probability Dependence and Independence Conditional Probability Bayes’s Theorem Random Variables Continuous Distributions The Normal Distribution The Central Limit Theorem For Further Exploration Chapter 7 - Hypothesis and Inference Statistical Hypothesis Testing Example: Flipping a Coin Confidence Intervals P-hacking Example: Running an A/B Test Bayesian Inference For Further Exploration Chapter 8 - Gradient Descent The Idea Behind Gradient Descent Estimating the Gradient Using the Gradient Choosing the Right Step Size Putting It All Together Stochastic Gradient Descent For Further Exploration Chapter 9 - Getting Data stdin and stdout Reading Files Scraping the Web Using APIs Example: Using the Twitter APIs For Further Exploration Chapter 10 - Working with Data Exploring Your Data Cleaning and Munging Manipulating Data Rescaling Dimensionality Reduction For Further Exploration Chapter 11 - Machine Learning Modeling What Is Machine Learning? Overfitting and Underfitting Correctness The Bias-Variance Trade-off Feature Extraction and Selection For Further Exploration Chapter 12 - k-Nearest Neighbors The Model Example: Favorite Languages The Curse of Dimensionality For Further Exploration Chapter 13 - Naive Bayes A Really Dumb Spam Filter A More Sophisticated Spam Filter Implementation Testing Our Model For Further Exploration Chapter 14 - Simple Linear Regression The Model Using Gradient Descent Maximum Likelihood Estimation For Further Exploration Chapter 15 - Multiple Regression The Model Further Assumptions of the Least Squares Model Fitting the Model Interpreting the Model Goodness of Fit Digression: The Bootstrap Standard Errors of Regression Coefficients Regularization For Further Exploration Chapter 16 - Logistic Regression The Problem The Logistic Function Applying the Model Goodness of Fit Support Vector Machines For Further Investigation Chapter 17 - Decision Trees What Is a Decision Tree? Entropy The Entropy of a Partition Creating a Decision Tree Putting It All Together Random Forests For Further Exploration Chapter 18 - Neural Networks Perceptrons Feed-Forward Neural Networks Backpropagation Example: Defeating a CAPTCHA For Further Exploration Chapter 19 - Clustering The Idea The Model Example: Meetups Choosing k Example: Clustering Colors Bottom-up Hierarchical Clustering For Further Exploration Chapter 20 - Natural Language Processing Word Clouds n-gram Models Grammars An Aside: Gibbs Sampling Topic Modeling For Further Exploration Chapter 21 - Network Analysis Betweenness Centrality Eigenvector Centrality Directed Graphs and PageRank For Further Exploration Chapter 22 - Recommender Systems Manual Curation Recommending What’s Popular User-Based Collaborative Filtering Item-Based Collaborative Filtering For Further Exploration Chapter 23 - Databases and SQL CREATE TABLE and INSERT UPDATE DELETE SELECT GROUP BY ORDER BY JOIN Subqueries Indexes Query Optimization NoSQL For Further Exploration Chapter 24 - MapReduce Example: Word Count Why MapReduce? MapReduce More Generally Example: Analyzing Status Updates Example: Matrix Multiplication An Aside: Combiners For Further Exploration Chapter 25 - Go Forth and Do Data Science IPython Mathematics Not from Scratch Find Data Do Data Science
More like people have finite amounts of energy to spend. Wading through style differences detract from making a feature or bugfix.
Whining about it is reeeeeally not helping your case.
Can Use flask + wtf forms Flaskbook.com goes through few examples that use this comination well.
For starters [Whoosh](http://pythonhosted.org//Whoosh/quickstart.html) is really nice, and pure Python. http://pyvideo.org/video/1788/whoosh-the-open-source-python-search-library
Nice. It's an interesting project and after reading a bit about it is probably a better choice for small projects or when trying to learn the concepts of search engines. I'd be very surprised if Whoosh scaled as well as Elasticsearch (or Solr) though beyond a few million documents or into the multi-terrabyte data range.
I'm new to python too, I've been studying python 2 materials and just translating it to python 3 as I go. So far it's been very simple. The few times there have been unexpected problems they haven't been hard to solve. I really wouldn't worry about it at this point. 
Looks like a very useful place to start, indeed.
While I think this is an excellent idea, I just got hired on Friday and I won't have access to the codebase until I start in a couple weeks. I'm more looking for refreshers for writing literals and importing modules and all that boring junk.
Figuring out what's wrong is the important part. The part you're supposed to do.
It makes no difference.
I know :( but I kept on trying on writing a code that works, but I just can't find a way.
No errors....it simply won't print out what is inside the else statement
I think I solved it!
Just changed my code...and it works! Thanks for the help.
Thanks for the feedback! Please feel free to open issues here: - https://github.com/plock/plock. And to address your concerns: - Plock downloads the Unified Installer to make use of the egg cache, and nothing else (this feature was added by David Bain). The buildouts used to install Plone are Plock's. In fact, Plock currently could not work with the Unified Installer buildout because it makes many configuration choices for you. It would break if you gave it a non-Plock buildout. Try the ``--no-unified`` option to get rid of it. - No-Buildout-output is by design! (Have you seen Plone's Buildout output?) That said, it could always be enabled via some flag in the future, for advanced users. - If I recall correctly, it ignores ``~/.buildout/defaults.cfg`` when you use the Unified Installer cache (which is the default) but respects it when you use ``--no-unified``. This is the way I use it and I'm about to add ``.plockrc`` support so I can define ``--no-unified`` permanently for myself. 
I'm misjudging how rusty you are, I think. You don't mean you're having trouble with import os b = 3 right?
So what? The fact that you output stuff doesn't mean anyone, anywhere, has to consume it or care that it exists.
Yes, so you could say I was asking if he considered these points you mention. Now I know. That there is already a project like that. Yours. It's all good then.
/r/thebutton for the lazy.
"shitty" is in the nose of the true believer. There's nothing intrinsically wrong with pork, but to the true believer in a couple of religions, it'll send you to hell. There's nothing intrinsically wrong with GOTOs, and sometimes they're the most economical and perspicuous solution.
/r/learnpython
Another great (underrated) python clone: https://github.com/kaaedit/kaa
Do you know about NamedDictTuple cursor factory from psycopg2 and the similar RowFactory that sqlite has? They pretty much do this. Also, do you know about SQLAlchemy? This is cool, but there are lots of *very* polished tools that do this and a lot more!
This makes no sense.
I'm not having trouble so much as I just need a whistle-stop tour of the language to remind me to use 'def' instead of 'function' or that there are no constants or what the difference is between a tuple and a list or that the import keyword is 'import' and not 'require' or that there are no private methods or ... just any of the particulars and peculiarities of the language that I may have forgotten in the past few years of disuse.
Ops, sorry. It's just that google referred me to a post here about the same problem but with a different version, so I desperately posted without reading the sidebar.
wanna help? 
Honestly, after today you can imagine where my motivation is right now. 
I would argue that you don't learn much from simply "pep8-ing" the codebase.
Weird question... How "vimmy" is this project? I ask because, while I've really been looking for a good CLI Python editor (with consistent highlighting, autocomplete, auto indenting, linting/flaking, etc), I really really dislike modal editing- I prefer a combination of C/S/M combinations and a Sublime-style command palette. How appropriate do you thing this editor would be for me?
I didn't lie during the interview. I told them during my phone screen that I hadn't used Python in years, and then reiterated that fact during the in-person interview. They weren't looking for a Python programmer; they were looking for a good software engineer. The fact that I know Python at all is a bonus for them. Unfortunately, I don't have perfect recall, and when I haven't used a language in years, it's hard to remember the syntax, quirks, and finer details. And when you've programmed in Perl, Ruby, Java, Javascript, PHP, Dart, Erlang, Elixir, and probably a couple others I'm forgetting, sometimes you forget what bits belong to which language. I was interviewed and hired by the CTO and lead developer of the company. I can't bullshit my way out of a paper bag, but even if I could, I think those guys would probably be smart enough to smell it a mile away; they're pretty intelligent guys. I graduated college a decade ago, but I still wouldn't mind it if my fellow developers cut me some slack. But I don't think they necessarily want me to "master the language." I think they hired me to gather domain knowledge and solve relevant problems. I'm sorry that you have idiots working at your company. It sounds like you're working for a terrible company and that you have some anger and resentment because of it. I would recommend that you take some of the time and effort you spend on mastering Python and learn other languages. Exposing yourself to new languages, and comparing and contrasting them broadens your horizons and makes you a better engineer. You encounter new concepts that your favorite language doesn't have and you learn to really appreciate the things that it got right. When you have a grasp on several languages, you'll start to think in terms of software development patterns instead of language-specific solutions. Then maybe you can "bullshit" your way into a better job at a better company where you won't have to feel responsible for others mistakes and instead spend your time working on interesting projects. I sincerely hope that one day soon you'll discover that the language that you code in is important, but not nearly as important as being humble and helpful and compassionate. Empathy is not something that programmers are formally taught, but it can solve more problems in fewer lines of code (namely 0) than any programming language possibly could.
Its interface is aimed at cloning vim functionality and behavior, so I don't think you will find what you need. 
You made a spelling error - 'thatn' isn't a word. Is it some kind of Freudian slip?
That's my main reason behind wanting to ditch ncurses, but I could not find a decent alternative. In any case, vaitk has a very opaque, very localized layer for terminal plotting, so it should be an extremely localized change to introduce different rendering. I don't have a windows machine, so I can't really develop in this direction, but I was hoping that someone with the expertise would join.
Python 3.4.3 here, I'm not getting any of the problems you have. Also, in your last example you're calling str('Py' 'X') and not str.replace('Py', 'X') which is why that isn't working. The only thing I can think of is that you are somehow storing these strings in an encoding other than utf8, which could cause the invalid continuation byte error (which I believe should be a UnicodeDecodeError rather than a SyntaxError, but I'm almost as lost as you are anyway).
Why not just read the Python docs, they are very well written. The Language Tutorial should cover most of what you need as a refresher. I suggest you find out which Python version your new employer is using then download/install that version for the docs and to practice.
i agree... 
Yeah, as others have said, I was not able to replicate any of the errors you're experiencing, and everything works for me in both Python 2.7.9 and 3.4.3, except, of course, the str('Py','X'), which is producing an error because it's an invalid use of the str() function, which is used to convert non-string objects into strings, for example str(1) should produce '1'. You're looking for str1.replace('Py','X') in that scenario. Hope that helps. Also, it should be noted that assigning a string value to the variable 'str' could potentially be problematic as str is a function, though I was able to make your examples work in the python interpreter using the variable name 'str'.
I can't reproduce bug #1 on either Python 3.4 or Python 2.7, but if you copied and pasted that correctly it *is* a bug and not expected behavior. And as others have noted, bug #2 is just a typo.
It looks like you're trying to overwrite the builtin `str`. Why?
su su, cerchiamo di essere professionali
/r/learnpython is a great place to be in in early stages of lrarning python.
&gt; Honestly, what should I do more to please the crowd? I'm gonna be that guy here, and tell you that probably your project isn't being successful because it is about implementing a quite advanced text editor which normally doesn't appeal to beginners, while the source code and design are majorly lacking, which surely doesn't appeal to more experienced developers. I gave a brief look at the code and quite frankly all I could see were excessively long routines containing endless cascades of IFs, and poorly -if at all- commented code. All this is packed with another big bunch of no-nos in software design. I think what you did is very respectable, but in order to capture the attention of (good) developers you may need to have a bit more than that. Also you seem to have a bit this attitude of i-got-a-degree-so-i-know-shit which may or may not pay you back in the long run.
hahaha, THIS! I once have defined a new method for my Django model, it's called `save()` and suddenly my perfectly working project began to falling into pieces. I spent millions of hours to trace into the very kernel of Django until I found out this stupid mistake.
Son 10 anni che vedo sto film. Permetti che possa scendermi la catena? 
Technically, I can add it, but you would have to specify the filetype manually. pylint assumes python3 for a .py file, unless you use the specific linter. 
Normally just lurking, but this is that much of a beautiful answer, I had to login to comment!
If you want auto-complete for 'everything' then you need to understand that supplying that requires some code size. PyCharm is awesome and probably the closest you're going to get to achieving that goal with Python. 
Is there a reason you couldn't just use tmux or screen for this?
Tried to duplicate the first bug, failed: In [1]: str = "Foo" In [2]: str[0] Out[2]: 'F' In [3]: str[0] + "Bar" Out[3]: 'FBar' ..but as others have said, it may be some inconsistency in how you're shadowing `str`, a builtin type.
Sorry, I didn't finish writing before my battery ran off. It's corrected now, although I dont offer how a dict unpacking might look like in Python. ...but I'm a fan of `locals ().update(ma_dict)` to dump all variables from a dict.
My advice will be similar; then. Write something. Install Python 2.7, and wxpython 3.0, and wxFormBuilder, and figure something out. Could be a simple image viewer, or a game, or whatever. Should force you to remember errthing pretty quickly.
Hmm, interesting. So, it seems I'm the only one getting that output. Obviously, I'm going to have top try this on a couple of different implementations on different systems. If everyone's getting one result and I'm getting another, the problem should be on my end (given that I copied and pasted. Crap, you're right about number two. [facepalm] One problem down, one to go.
The "1" was an accidental addition to the copy+paste, but you're right. The whole function is missing in that second example. After the first error (which I tested a couple of times), I was just too quick to assume it was another arbitrary limit.
As the author of asylum i can confirm it is dead and has been replaced by another project: https://pypi.python.org/pypi/butter/0.10 basically separating out the low level stuff and high level app logic so others can use it as i had problems with constants being different when doing container work on ARM. new setup is cffi based if you are looking for more info and 2x talks on the subject visit http://doger.io
In Russian it is read as [Жопа](https://translate.google.com/#ru/en/%D0%96%D0%BE%D0%BF%D0%B0).
/r/jobbit
Text problems are inherently harder to process than simply giving someone an equation to solve, because you need to first come up with the equation yourself. It's fine to give children assignments where you can guess the answer, but it has to be feasible to deduce a solution logically. That teaches them the important lesson that you don't always have to be precise and exact to get a ballpark estimate ([Fermi problem](http://en.wikipedia.org/wiki/Fermi_problem)), but you can calculate most things exactly (or pretty close to that) if you put in additional effort. Obviously, this problem is way too hard for children that age. It would be an ok problem for advanced high schoolers or college math students.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Fermi problem**](https://en.wikipedia.org/wiki/Fermi%20problem): [](#sfw) --- &gt;In [physics](https://en.wikipedia.org/wiki/Physics) or [engineering](https://en.wikipedia.org/wiki/Engineering) [education](https://en.wikipedia.org/wiki/Education), a __Fermi problem__, __Fermi quiz__, __Fermi question__, __Fermi estimate__, or __Order estimation__ is an [estimation](https://en.wikipedia.org/wiki/Estimation_theory) problem designed to teach [dimensional analysis](https://en.wikipedia.org/wiki/Dimensional_analysis), [approximation](https://en.wikipedia.org/wiki/Approximation), and the importance of clearly identifying one's assumptions. The solution of such a problem is usually a [back-of-the-envelope calculation](https://en.wikipedia.org/wiki/Back-of-the-envelope_calculation). The estimation technique is named after physicist [Enrico Fermi](https://en.wikipedia.org/wiki/Enrico_Fermi) as he was known for his ability to make good approximate calculations with little or no actual data. Fermi problems typically involve making justified guesses about quantities and their [variance](https://en.wikipedia.org/wiki/Variance) or lower and upper bounds. &gt; --- ^Interesting: [^Spherical ^cow](https://en.wikipedia.org/wiki/Spherical_cow) ^| [^Fermi ^paradox](https://en.wikipedia.org/wiki/Fermi_paradox) ^| [^Back-of-the-envelope ^calculation](https://en.wikipedia.org/wiki/Back-of-the-envelope_calculation) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqq48a6) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqq48a6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
https://www.jetbrains.com/pycharm/help/synchronizing-and-sharing-settings.html#d678274e149
I'm sad to see that you still have this attitude. It looks like you're trying to be the victim, "I did all this work so I deserve more contributors who work on the project". Open source doesn't work like that. Most of the time, people contribute back because there's a feature *they* want. If they don't use your software, what motivation would they have to spend time on working on it? /u/spookyrufus probably isn't too interested in your project, but he/she was nice enough to take a look at your code and offer some criticism. If I were to give you some comments or file a bug in the bug tracker, I don't want to hear "Then help me fix it". A simple "Thanks, I'll look into it" would in my opinion be much better, or "Thanks, would you mind pointing out some specific examples?", or even "Thanks! Would you be interested in looking into it? If you create a pull request I'll merge your changes and add you to the contributors list" would sound much more positive. The way you've responded throughout this thread makes you sound jaded and entitled, and frankly, it's off-putting. I think that before anything else, you need to work on your attitude if you want to attract collaborators.
Of course -- this is what I typically do. But then I have to use different key sequences to switch among the terminal splits or to resize the tmux vs vim panes and I get confused. Not only that but I can't get the geometry I want unless I run multiple copies of vim. I find scrollback painful in tmux/screen, as is copy/paste. I am going to try neovim -- these other guys have me intrigued.
The project is my first open source project. Any kind of feedback is very much appreciated.
Mmmmm I love belly rubs
Something like c#'s ref: my idea.. here 'over' is my 'ref': def bar(over n): n += 'bar' val = 'foo' bar(over val) I know it is possible like this: def bar(n): return n + 'bar' val = 'foo' val = bar(val) I would love the opportunity to explicitly state whether and which parameters are directly modified by a function. 
The main motivation I had to write it was that I found vim to be, at the end of the day, just an editor. I wanted something a bit more. Ok, there are plenty of plugins for vim, but none of them actually made it behave like an eclipse or a sublime. To give you an example, the lateral markers or the popup window for the linting errors are unachievable in plain vim, as well as asynchronous linting. While I am far from a full IDE, the plan is to achieve them as I go. It's not a trivial task, I am perfectly aware of it, but... why not? At the moment, what it gives you already is a few of the features you find in sublime and you don't find in plain vim: highlighting of the current identifier, lateral markers, inline linting, out of the box. 
this works as advertised on my computer ( maybe check wether the filename is spelled correctly ) also consider using the with syntax string = 'this will go at the botom' with open("thefile.txt", "a") as f: f.write(string + "\n") a lot more memory efficient
That code is fine. I suspect that written file is not really where you think it is. My guess is that you're making another one somewhere, but I know less about your environment than you should.
Code shortening is always good, giving it a try... It works, but it seems its dumping the file somewhere else, not in the same directory as the script itself. Any way of going about making it do that?
Your code is fine, you're probably looking for "thefile.txt" in the wrong directory. Try using the full path like "/home/users/Sokonomi/thefile.txt" or wherever you want it to go.
This made me think about what was calling this script (Sickrage), and sure enough, it was writing the file to the root of the program calling the script, not to the location of the script. Is there a way to prepend the textfile with the location of the script itself rather than the main program? Or am I going to have to hardcode the filepath?
yeah its ending up somewhere else it seems, im going to need to prepend thefile.txt with the path of the script itself, but Im having trouble googling for it. :')
with statement* but yes, when it goes out of scope the interpreter closes it
Any advantages over pelican? 
I came across that one at stackoverflow, but wont that burp up the path including script filename?
Oh dear god, are you giving me homework? :') I usually learn from picking scripts apart, because "look it up" doesn't work when you dont know what you are looking for. ;) Another poster pitched "os.path.dirname(os.path.abspath(_ file _))" which seems to relate to your middle link, so im going to give that a go.
Seems like a weaker version of iPython? ^_-
Woops and ahh thanks, Til! 
saving for later
Your homework is to learn the standard library or suffer pain of being bad at what you do. I wonder what I'll be tagging your username as.
Tag me as "Has to suffer through python but doesn't really want to." This language is pure nightmare fuel to me, but I have to deal with it for a handful of code because some program im using demands it. After its done im unlikely to touch this stuff ever again. So no need to spend a month studying it.
Download link?
Thanks a lot guys ! I have uninstalled all the packages and installed new fresh sublime text 3 with anaconda and now it is much better. I don't know what was wrong before but it did not work like that. I will stick to it for now. 
Python is literally the easiest language to learn in terms of syntax, so...
Just go to the O'Reilly site and do a search.
Yes, I am shit at programming python, and I dont really intend to change that. I dont need to have intricate knowledge of car mechanics to put on a bumper sticker. I'm prepared to learn how to locate the bumper and peel the sticker, but it would be senseless to learn more. That's how I think about this whole python thing, too. I just want to cobble together the bits I need so it works and be done with it, no point in reading a thousand page manual for that.
Wait, why brute force? Start with the biggest coins that make the amount: 39 $1 coins and three quarters. Or 78 $0.50 coins and three quarters. Now split the bigger coins into smaller coins: take 9 fifty cent pieces and replace with 18 quarters. I'm doing this on a phone in my head, but I think a couple more similar operations gets us done. Edit: you can easily formalize this too, just by observing that splitting a coin increases the total coin count without changing the total value. Lots of splits increase the count by 1, and splitting a quarter into two dimes and a nickel increases the count by 2. Now it's a relatively simple algorithm to figure out which coins to split.
Except not really. Even batch coding is giving me less of a headache than this.
I've posted a [short list](http://www.reddit.com/r/learnpython/comments/32qz31/eli5_what_is_the_difference_between_python_2_and/cqe3jam) of differences between Python 2 and 3 a few days ago. 
No. `os.path.dirname` extracts the directory from the path.
This is extreme, but modern CPUs sleep when there are no instructions to execute. So unnecessary computation really does waste energy.
Learning how to **explore** documentation is part of learning how to be a programmer. When you're doing real work, you're doing something that nobody else has written a thing for yet. You'll always be looking for something that you don't know about yet.
Its the library importing that gets me. Every little bit has its own set of terrors to familiarize with. :') I dont like coding at all, I just use it because I have to. Ive messed with C++, VB, PHP, HTML, Java, and Ajax a bit, and python just feels like its missing bits. Nothing seems to be squared away in "boxes", like, I dont get the feeling it has any kind of structure, like one continues ongoing slew, almost like batch code (MS-DOS is where it stems from, but windows CMD shell batch is much improved). Batch its pigeon coding. If you want something done quick and dirty, thats how most windows users do it. Everybody knows it, and with a bit of search you find thousands of samples. With python its easy to drown in linux technobabble, and it seems to only make sense if you already know what you're doing. That's why I ended up asking it on Reddit of all places. What im basically doing here is mashing the VCR buttons until the clock stops blinking. :') I'm just pushing bits of python together hoping it will somehow work, and when it does its over. Ive more or less managed to get python to actually do what I want now, and I'm sure half of my script is pointless junk, but I dont care enough to clean it up to be honest.. I'm just glad it poops out a result I can live with.
People are unwilling to spend their **freetime** on a project which is annoying and difficult to work with. In other words, needing to trim down the 10 projects I'm interested in to the 1 I want to work on, its easy to scratch off the list the non-standard, very opinionated ones. 
No, demanding someone to dig through hundreds of pages of documentation to bang together 10 stupid lines of code is ridiculous. I have no intentions of mastering an entire for one silly script. Furthermore, just smacking someone with manuals is utterly useless. Because how do you look something up if not knowing what you are looking for is the problem in the first place. "Just keep reading until it comes up"? That's a very poor way of learning what you need to know.
They executing NOP instruction.
&gt; You cant honestly expect someone to spend hours digging through thick and tough manuals just to slap together 10 lines of code, when he could just ask someone who knows and have it done in a minute. You seem to be arguing "Why do it myself when I can ask someone else to do the work and thinking for me?" which is fine, because humans invented the concept of barter and commerce. Pay someone to do your work for you, then. The ability to figure out what you need to look for given an abstract problem isn't something that can be transmitted through a reddit comment (or a blog post or a novel). It's a wide range of critical thinking and problem solving skills related to processing abstractions, breaking objectives down into discrete units of work/action, and lots of other things that only come with time and practice. Dive headfirst into documentation. You're going to need all of it, eventually. Don't pick and choose. Becoming familiar with documentation and code will grant you greater insight into how problems break down.
The file is closed when execution reaches the end of the with block. It has nothing to do with scope.